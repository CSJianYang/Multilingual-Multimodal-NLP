[
    {
        "title": "Subarrays with K Different Integers",
        "question_content": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA good array is an array where the number of different integers in that array is exactly k.\n\n\tFor example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.\n\nA subarray is a contiguous part of an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,1,2,3], k = 2\nOutput: 7\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]\n\nExample 2:\n\nInput: nums = [1,2,1,3,4], k = 3\nOutput: 3\nExplanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 2 * 104\n\t1 <= nums[i], k <= nums.length",
        "solutions": [
            {
                "id": 523136,
                "title": "java-c-python-sliding-window",
                "content": "**I republished this post.\\nThe original one is deleded by Leetcode without any notification or information.\\nThe only reason that, I included my youtube channel link.\\nExcusem me, What the HACK!?**\\n<br>\\n\\n## **Intuition**:\\nFirst you may have feeling of using sliding window.\\nThen this idea get stuck in the middle.\\n\\nThis problem will be a very typical sliding window,\\nif it asks the number of subarrays with **at most** K distinct elements.\\n\\nJust need one more step to reach the folloing equation:\\n`exactly(K) = atMost(K) - atMost(K-1)`\\n<br>\\n\\n## **Explanation**\\n1. Write/copy a helper function of sliding window,\\nto get the number of subarrays with at most K distinct elements.\\n2. Done.\\n<br>\\n\\n## **Complexity**:\\nTime `O(N)` for two passes.\\nSpace `O(K)` at most K elements in the counter\\n\\nOf course, you can merge 2 for loops into one, if you like.\\n<br>\\n\\n**Java:**\\n```java\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(int[] A, int K) {\\n        int i = 0, res = 0;\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int j = 0; j < A.length; ++j) {\\n            if (count.getOrDefault(A[j], 0) == 0) K--;\\n            count.put(A[j], count.getOrDefault(A[j], 0) + 1);\\n            while (K < 0) {\\n                count.put(A[i], count.get(A[i]) - 1);\\n                if (count.get(A[i]) == 0) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(vector<int>& A, int K) {\\n        int i = 0, res = 0;\\n        unordered_map<int, int> count;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!count[A[j]]++) K--;\\n            while (K < 0) {\\n                if (!--count[A[i]]) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def subarraysWithKDistinct(self, A, K):\\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\\n\\n    def atMostK(self, A, K):\\n        count = collections.Counter()\\n        res = i = 0\\n        for j in range(len(A)):\\n            if count[A[j]] == 0: K -= 1\\n            count[A[j]] += 1\\n            while K < 0:\\n                count[A[i]] -= 1\\n                if count[A[i]] == 0: K += 1\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(int[] A, int K) {\\n        int i = 0, res = 0;\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int j = 0; j < A.length; ++j) {\\n            if (count.getOrDefault(A[j], 0) == 0) K--;\\n            count.put(A[j], count.getOrDefault(A[j], 0) + 1);\\n            while (K < 0) {\\n                count.put(A[i], count.get(A[i]) - 1);\\n                if (count.get(A[i]) == 0) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(vector<int>& A, int K) {\\n        int i = 0, res = 0;\\n        unordered_map<int, int> count;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!count[A[j]]++) K--;\\n            while (K < 0) {\\n                if (!--count[A[i]]) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def subarraysWithKDistinct(self, A, K):\\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\\n\\n    def atMostK(self, A, K):\\n        count = collections.Counter()\\n        res = i = 0\\n        for j in range(len(A)):\\n            if count[A[j]] == 0: K -= 1\\n            count[A[j]] += 1\\n            while K < 0:\\n                count[A[i]] -= 1\\n                if count[A[i]] == 0: K += 1\\n                i += 1\\n            res += j - i + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 235235,
                "title": "c-java-with-picture-prefixed-sliding-window",
                "content": "If the problem talks about continuous subarrays or substrings, the sliding window technique may help solve it in a linear time. Such problems are tricky, though the solution is simple once you get it. No wonder I am seeing such problems in almost every interview!\\n\\nHere, we will take a look at [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/) (LeetCode Hard), which appeared on LeetCode [weekly contest #123](https://leetcode.com/contest/weekly-contest-123). You can also master the sliding windows technique with these additional problems:\\n- [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\\n- [Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/)\\n- [Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)\\n<!--# Problem Description\\nGiven an array ```A``` of positive integers, call a (contiguous, not necessarily distinct) subarray of ```A``` good if the number of different integers in that subarray is exactly ```K```. For example, ```[1,2,3,1,2]``` has 3 different integers: 1, 2, and 3.\\n\\nReturn the number of good subarrays of ```A```.\\n### Example\\n**Input:** A = [1,2,1,2,3], K = 2\\n**Output:** 7\\n**Explanation:** Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\\n# Coding Practice\\nTry solving this problem before moving on to the solutions. It is available on LeetCode Online Judge ([Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/)). Also, as you read through a solution, try implementing it yourself.\\n\\nLeetCode is my favorite destinations for algorithmic problems. It has 987 problems and counting, with test cases to validate the correctness, as well as computational and memory complexity. There is also a large community discussing different approaches, tips and tricks.\\n# Brute-Force Solution\\nWe can just iterate through each sub-array using two loops and count the good ones. For the inner loop, we use hash set to count unique numbers; if we the set size becomes larger than ```K```, we break from the inner loop.\\n```\\nint subarraysWithKDistinct(vector<int>& A, int K, int res = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    unordered_set<int> s;\\n    for (auto j = i; j < A.size() && s.size() <= K; ++j) {\\n      s.insert(A[j]);\\n      if (s.size() == K) ++res;\\n    }\\n  }\\n  return res;\\n}\\n```\\n### Complexity Analysis\\nThe time complexity of this solution is *O(n * n)*, where *n* is the length of ```A```. This solution is not accepted by the online judge.\\n-->\\n# Intuition\\nIf the subarray ```[j, i]``` contains ```K``` unique numbers, and first ```prefix``` numbers also appear in ```[j + prefix, i]``` subarray, we have total ```1 + prefix``` good subarrays. For example, there are 3 unique numers in ```[1, 2, 1, 2, 3]```. First two numbers also appear in the remaining subarray ```[1, 2, 3]```, so we have 1 + 2 good subarrays: ```[1, 2, 1, 2, 3]```, ```[2, 1, 2, 3]``` and ```[1, 2, 3]```.\\n# Linear Solution\\nWe can iterate through the array and use two pointers for our sliding window (```[j, i]```). The back of the window is always the current position in the array (```i```). The front of the window (```j```) is moved so that A[j] appear only once in the sliding window. In other words, we are trying to shrink our sliding window while maintaining the same number of unique elements.\\n\\nTo do that, we keep tabs on how many times each number appears in our window (```m```). After we add next number to the back of our window, we try to remove as many as possible numbers from the front, until the number in the front appears only once. While removing numbers, we are increasing ```prefix```.\\n\\nIf we collected ```K``` unique numbers, then we found 1 + ```prefix``` sequences, as each removed number would also form a sequence.\\n\\nIf our window reached ```K + 1``` unique numbers, we remove one number from the head (again, that number appears only in the front), and reset ```prefix``` as now we are starting a new sequence. This process is demonstrated step-by-step for the test case below; ```prefix``` are shown as ```+1``` in the green background.\\n```\\n[5,7,5,2,3,3,4,1,5,2,7,4,6,2,3,8,4,5,7]\\n7\\n```\\n![image](https://assets.leetcode.com/users/votrubac/image_1549876616.png)\\n\\nIn the code below, we use ```cnt``` to track unique numbers. Since ```1 <= A[i] <= A.size()```, we can use an array instead of hash map to improve the performance.\\n```\\nint subarraysWithKDistinct(vector<int>& A, int K, int res = 0) {\\n  vector<int> m(A.size() + 1);\\n  for(auto i = 0, j = 0, prefix = 0, cnt = 0; i < A.size(); ++i) {\\n    if (m[A[i]]++ == 0) ++cnt;\\n    if (cnt > K) --m[A[j++]], --cnt, prefix = 0;\\n    while (m[A[j]] > 1) ++prefix, --m[A[j++]];\\n    if (cnt == K) res += prefix + 1;\\n  }\\n  return res;\\n}\\n```\\nJava version:\\n```\\npublic int subarraysWithKDistinct(int[] A, int K) {\\n  int res = 0, prefix = 0;\\n  int[] m = new int[A.length + 1];\\n  for (int i = 0, j = 0, cnt = 0; i < A.length; ++i) {\\n    if (m[A[i]]++ == 0) ++cnt;\\n    if (cnt > K) {\\n      --m[A[j++]]; --cnt; prefix = 0; \\n    }\\n    while (m[A[j]] > 1) {\\n      ++prefix; --m[A[j++]]; \\n    }\\n    if (cnt == K) res += prefix + 1;\\n  }\\n  return res;\\n} \\n```\\n### Complexity Analysis\\n- Time Complexity: *O(n)*, where *n* is the length of ```A```.\\n- Space Complexity: *O(n)*.",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```A```\n```A```\n```K```\n```[1,2,3,1,2]```\n```A```\n```K```\n```\\nint subarraysWithKDistinct(vector<int>& A, int K, int res = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    unordered_set<int> s;\\n    for (auto j = i; j < A.size() && s.size() <= K; ++j) {\\n      s.insert(A[j]);\\n      if (s.size() == K) ++res;\\n    }\\n  }\\n  return res;\\n}\\n```\n```A```\n```[j, i]```\n```K```\n```prefix```\n```[j + prefix, i]```\n```1 + prefix```\n```[1, 2, 1, 2, 3]```\n```[1, 2, 3]```\n```[1, 2, 1, 2, 3]```\n```[2, 1, 2, 3]```\n```[1, 2, 3]```\n```[j, i]```\n```i```\n```j```\n```m```\n```prefix```\n```K```\n```prefix```\n```K + 1```\n```prefix```\n```prefix```\n```+1```\n```\\n[5,7,5,2,3,3,4,1,5,2,7,4,6,2,3,8,4,5,7]\\n7\\n```\n```cnt```\n```1 <= A[i] <= A.size()```\n```\\nint subarraysWithKDistinct(vector<int>& A, int K, int res = 0) {\\n  vector<int> m(A.size() + 1);\\n  for(auto i = 0, j = 0, prefix = 0, cnt = 0; i < A.size(); ++i) {\\n    if (m[A[i]]++ == 0) ++cnt;\\n    if (cnt > K) --m[A[j++]], --cnt, prefix = 0;\\n    while (m[A[j]] > 1) ++prefix, --m[A[j++]];\\n    if (cnt == K) res += prefix + 1;\\n  }\\n  return res;\\n}\\n```\n```\\npublic int subarraysWithKDistinct(int[] A, int K) {\\n  int res = 0, prefix = 0;\\n  int[] m = new int[A.length + 1];\\n  for (int i = 0, j = 0, cnt = 0; i < A.length; ++i) {\\n    if (m[A[i]]++ == 0) ++cnt;\\n    if (cnt > K) {\\n      --m[A[j++]]; --cnt; prefix = 0; \\n    }\\n    while (m[A[j]] > 1) {\\n      ++prefix; --m[A[j++]]; \\n    }\\n    if (cnt == K) res += prefix + 1;\\n  }\\n  return res;\\n} \\n```\n```A```",
                "codeTag": "Unknown"
            },
            {
                "id": 235002,
                "title": "one-code-template-to-solve-all-of-these-problems",
                "content": "For [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/):\\n\\n```python\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        return self.subarraysWithAtMostKDistinct(A, K) - self.subarraysWithAtMostKDistinct(A, K-1)\\n    \\n    def subarraysWithAtMostKDistinct(self, s, k):\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > k:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res += r - l \\n        return res\\n```\\n\\nFor [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/):\\n\\n```python\\nclass Solution:\\n    def lengthOfLongestSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1\\n            while l < r and counter < r - l:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l)\\n        return res\\n```\\n\\nFor [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/):\\n\\n```python\\nclass Solution(object):\\n    def lengthOfLongestSubstringTwoDistinct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > 2:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l) \\n        return res\\n```\\n\\nFor [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/):\\n\\n```python\\nclass Solution(object):\\n    def lengthOfLongestSubstringKDistinct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > k:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l) \\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        return self.subarraysWithAtMostKDistinct(A, K) - self.subarraysWithAtMostKDistinct(A, K-1)\\n    \\n    def subarraysWithAtMostKDistinct(self, s, k):\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > k:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res += r - l \\n        return res\\n```\n```python\\nclass Solution:\\n    def lengthOfLongestSubstring(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1\\n            while l < r and counter < r - l:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l)\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def lengthOfLongestSubstringTwoDistinct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > 2:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l) \\n        return res\\n```\n```python\\nclass Solution(object):\\n    def lengthOfLongestSubstringKDistinct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        lookup = collections.defaultdict(int)\\n        l, r, counter, res = 0, 0, 0, 0\\n        while r < len(s):\\n            lookup[s[r]] += 1\\n            if lookup[s[r]] == 1:\\n                counter += 1\\n            r += 1   \\n            while l < r and counter > k:\\n                lookup[s[l]] -= 1\\n                if lookup[s[l]] == 0:\\n                    counter -= 1\\n                l += 1\\n            res = max(res, r - l) \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360147,
                "title": "share-my-solution",
                "content": "Assume we have an array `A = [1, 1, 2, 1, 1, 3, 3, 2, 4, 2]` and `K = 3`\\nLet\\'s ask yourself how many ranges start with `index = 0` and have `3` distinct numbers?\\nWe can at first find the first range that satisfies this condition using sliding window, in which keep one head `lo = 0`, and increase another head `hi = 0` until we count the distinct numbers `= 3`\\n\\n`[1]` - `lo = 0, hi = 0, count = 1`\\n`[1,1]` - `lo = 0, hi = 1, count = 1`\\n`[1,1,2]` - `lo = 0, hi = 2, count = 2`\\n....\\n`[1,1,2,1,1,3]` - `lo = 0, hi = 5, count = 3`\\n\\nOk. We found it. Now keep increasing `hi`, what will happen?\\n\\n`[1,1,2,1,1,3,3]` - `lo = 0, hi = 6, count still = 3`, because `A[hi] = 3` is still the one of the old numbers\\n`[1,1,2,1,1,3,3,2]` - `lo = 0, hi = 7, count still = 3`, because `A[hi] = 2` is still the one of the old numbers\\n**However**:\\n`[1,1,2,1,1,3,3,2,4]` - `lo = 0, hi = 8, count = 4`, because `A[hi] = 4` is the new number\\nSo, now we know if the new number appears, we can stop the journey. We call the `index` before making the new number appear is `max`. We have:\\n\\n- The range starting with `lo = 0` and have `K = 3` distinct numbers = `max - hi + 1`\\n\\n- The same analysis for how many ranges start with `lo = 1` and have `K = 3` distinct numbers = `max - hi + 1`\\n- We keep shrinking the window by increasing `lo`, until the `count` of distinct numbers `< K = 3`. Then we repeat : increasing `hi` until the `count of distinct numbers `= `3`\\n\\n`1....1....2....1....1....3....3....2....4....2`\\n`lo.......................hi........max`\\n`...............lo.................hi=max`\\n`.........................lo.............hi....max`\\n\\n````\\n\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n        int res = 0, count = 0, lo = 0, hi = 0, max = 0, n;\\n        Map<Integer, Integer> dp = new HashMap<>();\\n\\n        while (hi < A.length) {\\n            \\n            // define how many ranges starting with lo, and has K distinct numbers\\n            while (count == K) {\\n                res += max - hi + 1;\\n                n = dp.get(A[lo]);\\n                if (n == 1) {\\n                    count--;\\n                    hi++;\\n                }\\n                dp.put(A[lo], n-1);\\n                lo++;\\n            }\\n\\n            // find the first range starting with lo, and has K distinct numbers\\n            while (hi < A.length) {\\n                n = dp.getOrDefault(A[hi], 0);\\n                if (n == 0) count++;\\n                dp.put(A[hi], n+1);\\n                \\n                // if found hi, then define max\\n                if (count == K) {\\n                    max = hi;\\n                    while (max+1 < A.length) {\\n                        if (dp.getOrDefault(A[max+1], 0) == 0) break;\\n                        max++;\\n                    }\\n                    break;\\n                }\\n                hi++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n        int res = 0, count = 0, lo = 0, hi = 0, max = 0, n;\\n        Map<Integer, Integer> dp = new HashMap<>();\\n\\n        while (hi < A.length) {\\n            \\n            // define how many ranges starting with lo, and has K distinct numbers\\n            while (count == K) {\\n                res += max - hi + 1;\\n                n = dp.get(A[lo]);\\n                if (n == 1) {\\n                    count--;\\n                    hi++;\\n                }\\n                dp.put(A[lo], n-1);\\n                lo++;\\n            }\\n\\n            // find the first range starting with lo, and has K distinct numbers\\n            while (hi < A.length) {\\n                n = dp.getOrDefault(A[hi], 0);\\n                if (n == 0) count++;\\n                dp.put(A[hi], n+1);\\n                \\n                // if found hi, then define max\\n                if (count == K) {\\n                    max = hi;\\n                    while (max+1 < A.length) {\\n                        if (dp.getOrDefault(A[max+1], 0) == 0) break;\\n                        max++;\\n                    }\\n                    break;\\n                }\\n                hi++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640450,
                "title": "c-code-easy-solution-using-map-and-sliding-window-with-approach",
                "content": "Approach: To directly count the subarrays with exactly K different integers is hard but to find the count of subarrays with at most K different integers is easy. So the idea is to find the count of subarrays with at most K different integers, let it be C(K), and the count of subarrays with at most (K \\u2013 1) different integers, let it be C(K \\u2013 1) and finally take their difference, C(K) \\u2013 C(K \\u2013 1) which is the required answer.\\nCount of subarrays with at most K different elements can be easily calculated through the sliding window technique. The idea is to keep expanding the right boundary of the window till the count of distinct elements in the window is less than or equal to K and when the count of distinct elements inside the window becomes more than K, start shrinking the window from the left till the count becomes less than or equal to K. Also for every expansion, keep counting the subarrays as right \\u2013 left + 1 where right and left are the boundaries of the current window.\\n```\\nint atMostKDistinct(vector<int>& A,int n,int k){\\n    int count = 0;\\n    int left = 0;\\n    int right = 0;\\n    \\n    unordered_map<int,int> mp;\\n    \\n    while(right < n){\\n        \\n        //add current element in the map\\n        if(mp.find(A[right]) == mp.end()){\\n            mp[A[right]] = 1;\\n        }else{\\n            mp[A[right]]++;\\n        }\\n        \\n        while(mp.size() > k){\\n            mp[A[left]]--;\\n            if(mp[A[left]] == 0){\\n                mp.erase(A[left]);\\n            }\\n            left++;\\n        }\\n        \\n        count += right-left+1;\\n        right++;\\n    }\\n    \\n    \\n    return count;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int k) {\\n        int n = A.size();\\n        return atMostKDistinct(A,n,k) - atMostKDistinct(A,n,k-1);\\n    }\\n};\\n```\\nhope it helps",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint atMostKDistinct(vector<int>& A,int n,int k){\\n    int count = 0;\\n    int left = 0;\\n    int right = 0;\\n    \\n    unordered_map<int,int> mp;\\n    \\n    while(right < n){\\n        \\n        //add current element in the map\\n        if(mp.find(A[right]) == mp.end()){\\n            mp[A[right]] = 1;\\n        }else{\\n            mp[A[right]]++;\\n        }\\n        \\n        while(mp.size() > k){\\n            mp[A[left]]--;\\n            if(mp[A[left]] == 0){\\n                mp.erase(A[left]);\\n            }\\n            left++;\\n        }\\n        \\n        count += right-left+1;\\n        right++;\\n    }\\n    \\n    \\n    return count;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int k) {\\n        int n = A.size();\\n        return atMostKDistinct(A,n,k) - atMostKDistinct(A,n,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235417,
                "title": "sliding-window-logical-thinking",
                "content": "> so-called sliding window technique needs an aggregated requirement, for example, the window with at most K dinstinct or with at least K dinstinct.\\n\\n> so we transform the original problem to\\n> ```\\n>subarraysWith(K)Distinct = subarraysWithAtMost(K)Distinct - subarraysWithAtMost(K -1)Distinct\\n>```\\n\\n> intuitively,\\n> ```\\n> for (i = 0, i < n; i++) {\\n>   for (j = i; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct++;\\n>   }\\n> }\\n> ```\\n> optimize 1, loop j break earlier\\n> ```\\n> for (i = 0, i < n; i++) {\\n>   for (j = i; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct++;\\n>     else break;\\n>   }\\n> }\\n> ```\\n> optimize 2, j doen\\'t restart at i but keeps increasing\\n> ```\\n> for (i = 0, i < n; i++) {\\n>   for (; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct= j - i + 1;\\n>     else break;\\n>   }\\n> }\\n> ```\\n\\n> to check whether `[i, j] with at most K distinct`\\n> we maintain a map `chToFreq` to record a digit and its corresponding frequency in curret window [i, j]\\n****\\n```\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return subarraysWithAtMostKDistinct(A, K) - subarraysWithAtMostKDistinct(A, K - 1);\\n    }\\n    \\n    private int subarraysWithAtMostKDistinct(int[] A, int K) {\\n        if (K == 0) return 0;\\n        \\n        int j = 0, numGoodSubArr = 0, n = A.length;\\n        // Map a character to its frequency in current window.\\n        Map<Integer, Integer> chToFreq = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (; j < n; j++) {\\n                chToFreq.put(A[j], chToFreq.getOrDefault(A[j], 0) + 1);\\n                if (chToFreq.size() <= K) numGoodSubArr += j - i + 1; \\n                else {\\n                    chToFreq.put(A[j], chToFreq.get(A[j]) - 1);\\n                    if (chToFreq.get(A[j]) == 0) chToFreq.remove(A[j]);\\n                    break; \\n                }\\n            }\\n            chToFreq.put(A[i], chToFreq.get(A[i]) - 1);\\n            if (chToFreq.get(A[i]) == 0) chToFreq.remove(A[i]);\\n        }\\n\\n        return numGoodSubArr;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n>subarraysWith(K)Distinct = subarraysWithAtMost(K)Distinct - subarraysWithAtMost(K -1)Distinct\\n>```\n```\\n> for (i = 0, i < n; i++) {\\n>   for (j = i; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct++;\\n>   }\\n> }\\n> ```\n```\\n> for (i = 0, i < n; i++) {\\n>   for (j = i; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct++;\\n>     else break;\\n>   }\\n> }\\n> ```\n```\\n> for (i = 0, i < n; i++) {\\n>   for (; j < n; j++) {\\n>     if ([i, j] with at most K distinct) numSubarrayAtMostKDistinct= j - i + 1;\\n>     else break;\\n>   }\\n> }\\n> ```\n```\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return subarraysWithAtMostKDistinct(A, K) - subarraysWithAtMostKDistinct(A, K - 1);\\n    }\\n    \\n    private int subarraysWithAtMostKDistinct(int[] A, int K) {\\n        if (K == 0) return 0;\\n        \\n        int j = 0, numGoodSubArr = 0, n = A.length;\\n        // Map a character to its frequency in current window.\\n        Map<Integer, Integer> chToFreq = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (; j < n; j++) {\\n                chToFreq.put(A[j], chToFreq.getOrDefault(A[j], 0) + 1);\\n                if (chToFreq.size() <= K) numGoodSubArr += j - i + 1; \\n                else {\\n                    chToFreq.put(A[j], chToFreq.get(A[j]) - 1);\\n                    if (chToFreq.get(A[j]) == 0) chToFreq.remove(A[j]);\\n                    break; \\n                }\\n            }\\n            chToFreq.put(A[i], chToFreq.get(A[i]) - 1);\\n            if (chToFreq.get(A[i]) == 0) chToFreq.remove(A[i]);\\n        }\\n\\n        return numGoodSubArr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237419,
                "title": "python-clean-sliding-window-2-pointers-o-n-99-06",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        freq = {}\\n        start = 0\\n        start_k = 0\\n        res = 0\\n        for i, x in enumerate(A):\\n            freq[x] = freq.get(x, 0) + 1\\n            if len(freq) == K + 1:\\n                # remove the distinct at start_k, move start_k, start\\n                del freq[A[start_k]]\\n                start_k += 1\\n                start = start_k\\n            if len(freq) == K:\\n                # update start_k and res (Notice: K >= 1)\\n                while freq[A[start_k]] > 1:\\n                    freq[A[start_k]] -= 1\\n                    start_k += 1\\n                res += start_k - start + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        freq = {}\\n        start = 0\\n        start_k = 0\\n        res = 0\\n        for i, x in enumerate(A):\\n            freq[x] = freq.get(x, 0) + 1\\n            if len(freq) == K + 1:\\n                # remove the distinct at start_k, move start_k, start\\n                del freq[A[start_k]]\\n                start_k += 1\\n                start = start_k\\n            if len(freq) == K:\\n                # update start_k and res (Notice: K >= 1)\\n                while freq[A[start_k]] > 1:\\n                    freq[A[start_k]] -= 1\\n                    start_k += 1\\n                res += start_k - start + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413266,
                "title": "c-java-python-fully-explained-sliding-window-hash-map-easy-to-understand",
                "content": "# Intuition\\nThe given code solution computes the number of subarrays in a given array \\'nums\\' that have exactly \\'k\\' distinct elements. It first calculates the count of subarrays with at most \\'k\\' distinct elements using the subArray function. Then it calculates the count of subarrays with at most \\'k-1\\' distinct elements using the same subArray function and subtracts it from the previous count. This gives the required count of subarrays with exactly \\'k\\' distinct elements.\\n\\n# Approach\\nThe code solution uses the sliding window technique to calculate the count of subarrays with at most \\'k\\' distinct elements. It initializes an unordered map to store the count of distinct elements in the current subarray. It also initializes \\'count\\', \\'start\\', and \\'end\\' to 0. The \\'end\\' pointer moves through the array while the count of distinct elements in the current subarray is less than or equal to \\'k\\'. If it becomes greater than \\'k\\', then the \\'start\\' pointer moves forward, and the count of the element at the \\'start\\' index is decreased until the count of distinct elements becomes less than or equal to \\'k\\' again. At each step, the count of subarrays is updated by adding the length of the current subarray (i.e., \\'end-start+1\\') to the \\'count\\'. Finally, the \\'count\\' is returned.\\n\\nThe function subarraysWithKDistinct calls the subArray function twice and subtracts the count of subarrays with at most \\'k-1\\' distinct elements from the count of subarrays with at most \\'k\\' distinct elements. This gives the required count of subarrays with exactly \\'k\\' distinct elements.\\n\\n# Complexity\\n- Time complexity: The time complexity of the subArray function is O(n), where \\'n\\' is the length of the input array \\'nums\\'. This is because each element in the array is visited at most twice (once by the \\'end\\' pointer and once by the \\'start\\' pointer), and the map operations are constant time on average. The time complexity of the subarraysWithKDistinct function is also O(n) because it calls the subArray function twice.\\n\\n- Space complexity: The space complexity of the subArray function is O(k), where \\'k\\' is the maximum number of distinct elements that can be present in a subarray. This is because the map can store at most \\'k\\' key-value pairs. The space complexity of the subarraysWithKDistinct function is also O(k) because it calls the subArray function twice.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int subArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> map;  // create an unordered map to store the count of each number in the current subarray\\n        int count = 0, start = 0, end = 0;  // initialize variables for count of valid subarrays, start and end index of subarray\\n        while (end < n) {  // loop through the array from the start to end index\\n            map[nums[end]]++;  // add the current element to the map and increment its count\\n            while (map.size() > k) {  // if the number of distinct elements in the map is greater than k, move the start index and remove elements from the map\\n                map[nums[start]]--;  // decrement the count of the element at the start index\\n                if (map[nums[start]] == 0) {  // if the count of the element at the start index becomes 0, remove it from the map\\n                    map.erase(nums[start]);\\n                }\\n                start++;  // increment the start index to move the window\\n            }\\n            count += end - start + 1;  // add the count of valid subarrays for the current subarray to the total count\\n            end++;  // increment the end index to move the window\\n        }\\n        return count;  // return the total count of valid subarrays\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // return the count of subarrays with exactly k distinct elements minus the count of subarrays with less than k distinct elements\\n        return subArray(nums, k) - subArray(nums, k - 1);\\n    }\\n};\\n\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int subArray(List<Integer> nums, int k) {\\n        int n = nums.size();\\n        Map<Integer, Integer> map = new HashMap<>(); // create a map to store the count of each number in the current subarray\\n        int count = 0, start = 0, end = 0; // initialize variables for count of valid subarrays, start and end index of subarray\\n        while (end < n) { // loop through the array from the start to end index\\n            map.put(nums.get(end), map.getOrDefault(nums.get(end), 0) + 1); // add the current element to the map and increment its count\\n            while (map.size() > k) { // if the number of distinct elements in the map is greater than k, move the start index and remove elements from the map\\n                map.put(nums.get(start), map.get(nums.get(start)) - 1); // decrement the count of the element at the start index\\n                if (map.get(nums.get(start)) == 0) { // if the count of the element at the start index becomes 0, remove it from the map\\n                    map.remove(nums.get(start));\\n                }\\n                start++; // increment the start index to move the window\\n            }\\n            count += end - start + 1; // add the count of valid subarrays for the current subarray to the total count\\n            end++; // increment the end index to move the window\\n        }\\n        return count; // return the total count of valid subarrays\\n    }\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        List<Integer> list = new ArrayList<>(); // convert the input array to a list\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        // return the count of subarrays with exactly k distinct elements minus the count of subarrays with less than k distinct elements\\n        return subArray(list, k) - subArray(list, k - 1);\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def subArray(self, nums, k):\\n        n = len(nums)\\n        map = {}\\n        count = 0\\n        start = 0\\n        end = 0\\n        while end < n:\\n            map[nums[end]] = map.get(nums[end], 0) + 1\\n            while len(map) > k:\\n                map[nums[start]] -= 1\\n                if map[nums[start]] == 0:\\n                    del map[nums[start]]\\n                start += 1\\n            count += end - start + 1\\n            end += 1\\n        return count\\n    \\n    def subarraysWithKDistinct(self, nums, k):\\n        return self.subArray(nums, k) - self.subArray(nums, k - 1)\\n\\n\\n```\\n\\n# Thank You\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> map;  // create an unordered map to store the count of each number in the current subarray\\n        int count = 0, start = 0, end = 0;  // initialize variables for count of valid subarrays, start and end index of subarray\\n        while (end < n) {  // loop through the array from the start to end index\\n            map[nums[end]]++;  // add the current element to the map and increment its count\\n            while (map.size() > k) {  // if the number of distinct elements in the map is greater than k, move the start index and remove elements from the map\\n                map[nums[start]]--;  // decrement the count of the element at the start index\\n                if (map[nums[start]] == 0) {  // if the count of the element at the start index becomes 0, remove it from the map\\n                    map.erase(nums[start]);\\n                }\\n                start++;  // increment the start index to move the window\\n            }\\n            count += end - start + 1;  // add the count of valid subarrays for the current subarray to the total count\\n            end++;  // increment the end index to move the window\\n        }\\n        return count;  // return the total count of valid subarrays\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // return the count of subarrays with exactly k distinct elements minus the count of subarrays with less than k distinct elements\\n        return subArray(nums, k) - subArray(nums, k - 1);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int subArray(List<Integer> nums, int k) {\\n        int n = nums.size();\\n        Map<Integer, Integer> map = new HashMap<>(); // create a map to store the count of each number in the current subarray\\n        int count = 0, start = 0, end = 0; // initialize variables for count of valid subarrays, start and end index of subarray\\n        while (end < n) { // loop through the array from the start to end index\\n            map.put(nums.get(end), map.getOrDefault(nums.get(end), 0) + 1); // add the current element to the map and increment its count\\n            while (map.size() > k) { // if the number of distinct elements in the map is greater than k, move the start index and remove elements from the map\\n                map.put(nums.get(start), map.get(nums.get(start)) - 1); // decrement the count of the element at the start index\\n                if (map.get(nums.get(start)) == 0) { // if the count of the element at the start index becomes 0, remove it from the map\\n                    map.remove(nums.get(start));\\n                }\\n                start++; // increment the start index to move the window\\n            }\\n            count += end - start + 1; // add the count of valid subarrays for the current subarray to the total count\\n            end++; // increment the end index to move the window\\n        }\\n        return count; // return the total count of valid subarrays\\n    }\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        List<Integer> list = new ArrayList<>(); // convert the input array to a list\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        // return the count of subarrays with exactly k distinct elements minus the count of subarrays with less than k distinct elements\\n        return subArray(list, k) - subArray(list, k - 1);\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def subArray(self, nums, k):\\n        n = len(nums)\\n        map = {}\\n        count = 0\\n        start = 0\\n        end = 0\\n        while end < n:\\n            map[nums[end]] = map.get(nums[end], 0) + 1\\n            while len(map) > k:\\n                map[nums[start]] -= 1\\n                if map[nums[start]] == 0:\\n                    del map[nums[start]]\\n                start += 1\\n            count += end - start + 1\\n            end += 1\\n        return count\\n    \\n    def subarraysWithKDistinct(self, nums, k):\\n        return self.subArray(nums, k) - self.subArray(nums, k - 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244641,
                "title": "c-easy-sliding-window-faster-than-80",
                "content": "Solution:: number of subarrays with  **k  different integers** = (number of subarrays with number of different integers **less than equal to k** ) - (number of subarrays with number of different integers **less than equal to k-1** )\\n```\\n//output of this function -->numbers of subarrays which have number of different integers less than equal to k\\n    int fun(int k,vector<int> nums)\\n    {\\n        if(k==0) return 0;\\n        unordered_map<int,int> mp;\\n        int j=0;\\n        int count=0;\\n        int n=nums.size();\\n        int total=0;\\n        vector<int> freq(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(freq[nums[i]]==0) count++;\\n            freq[nums[i]]++;\\n            if(count<=k) total+=(i-j+1); // (i-j+1) = number of subarrays ending at i-th position which contains number of different integers less than or equal to k\\n            else\\n            {\\n                while(count>k)\\n                {\\n                    freq[nums[j]]--;\\n                    if(freq[nums[j]]==0)\\n                    {\\n                        count--;\\n                    }\\n                    j++;\\n                }\\n                total+=(i-j+1);\\n            }\\n        }\\n        return total;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n       return fun(k,nums)-fun(k-1,nums);\\n    }\\n```\\t\\nIf you liked the Code, Give it a **Thumbs Up** !!!",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n//output of this function -->numbers of subarrays which have number of different integers less than equal to k\\n    int fun(int k,vector<int> nums)\\n    {\\n        if(k==0) return 0;\\n        unordered_map<int,int> mp;\\n        int j=0;\\n        int count=0;\\n        int n=nums.size();\\n        int total=0;\\n        vector<int> freq(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(freq[nums[i]]==0) count++;\\n            freq[nums[i]]++;\\n            if(count<=k) total+=(i-j+1); // (i-j+1) = number of subarrays ending at i-th position which contains number of different integers less than or equal to k\\n            else\\n            {\\n                while(count>k)\\n                {\\n                    freq[nums[j]]--;\\n                    if(freq[nums[j]]==0)\\n                    {\\n                        count--;\\n                    }\\n                    j++;\\n                }\\n                total+=(i-j+1);\\n            }\\n        }\\n        return total;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n       return fun(k,nums)-fun(k-1,nums);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672979,
                "title": "analysis-and-explanation-with-visualization",
                "content": "- How many subarrays are there in an array of size N? (subarrays can have size >= 1 up to N)\\n  \\n   ```\\n   There are n * (n + 1) / 2 subarrays in an array of size N. \\n   Example: A = [1,2,3,4]\\n   Subarrays: [1] [2] [3] [4] [1,2] [2,3] [3,4] [1,2,3] [2,3,4]\\n              Subarrays of size 1: 4\\n              Subarrays of size 2: 3\\n              Subarrays of size 3: 2\\n              Subarrays of size 4: 1\\n              Total subarrays: 4 + 3 + 2 + 1 or 1 + 2 + 3 + 4\\n              Which translates to: sum of the first N natural numbers where N is the size of the array\\n   ```\\n\\n- Compute subarrays of size at most k in array of size N:\\n   Solution: use the idea above and the sliding window technique. When our map exceeds k, we shrink it from the left side. In each iteration that we move the end point, we are computing the sum above (1 + 2 + 3 + ---- until end pointer). \\n\\n   ```csharp\\n   public int AtMostK(int[] s, int k) {\\n          Console.WriteLine(\"k = \" + k);\\n\\n          int res = 0;\\n          Dictionary<int, int> map = new Dictionary<int, int>();\\n          int start = 0, end = 0;\\n          while (end < s.Length) {\\n              if (!map.ContainsKey(s[end])) {\\n                  map.Add(s[end], 0);\\n              }\\n\\n              map[s[end]]++;\\n\\n              while (map.Count > k) {\\n                  map[s[start]]--;\\n                  if (map[s[start]] == 0) {\\n                      map.Remove(s[start]);\\n                  }\\n                  start++;\\n              }\\n\\n              res += end - start + 1;\\n              Console.Write(\"[\");\\n              for (int i = start; i <= end; i++) {\\n                  Console.Write(s[i] + (i == end ? \"\" : \",\"));\\n              }\\n              Console.WriteLine(\"]\");\\n\\n              end++;\\n          }\\n\\n          return res;\\n      }\\n   ```\\n  \\n - Compute subarrays of size EXACTLY K from an array of size N. \\n  Solution: Compute subarrays of size AT MOST K and subtract subarrays of size AT MOST K - 1.\\n  Why? atMostK(A, k) includes subarrays of size 1, 2, 3, .... k - 1 (all subrrays with size less than K). How to get rid of those arrays that have size less than K? Compute subarrays of size K - 1 which will give you subarrays of size 1, 2, 3, .... k - 2. The subarrays that we don\\'t want from the first list will be cancelled out by the subarrays in the second list. \\nVisualization: \\n![image](https://assets.leetcode.com/users/benevolent/image_1591429158.png)\\n\\nTherefore, we need to call the above function once with K and once with K - 1, and subtract the results:\\nFinal solution: \\n```csharp\\n return AtMost(s, k) - AtMost(s, k - 1)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   There are n * (n + 1) / 2 subarrays in an array of size N. \\n   Example: A = [1,2,3,4]\\n   Subarrays: [1] [2] [3] [4] [1,2] [2,3] [3,4] [1,2,3] [2,3,4]\\n              Subarrays of size 1: 4\\n              Subarrays of size 2: 3\\n              Subarrays of size 3: 2\\n              Subarrays of size 4: 1\\n              Total subarrays: 4 + 3 + 2 + 1 or 1 + 2 + 3 + 4\\n              Which translates to: sum of the first N natural numbers where N is the size of the array\\n   ```\n```csharp\\n   public int AtMostK(int[] s, int k) {\\n          Console.WriteLine(\"k = \" + k);\\n\\n          int res = 0;\\n          Dictionary<int, int> map = new Dictionary<int, int>();\\n          int start = 0, end = 0;\\n          while (end < s.Length) {\\n              if (!map.ContainsKey(s[end])) {\\n                  map.Add(s[end], 0);\\n              }\\n\\n              map[s[end]]++;\\n\\n              while (map.Count > k) {\\n                  map[s[start]]--;\\n                  if (map[s[start]] == 0) {\\n                      map.Remove(s[start]);\\n                  }\\n                  start++;\\n              }\\n\\n              res += end - start + 1;\\n              Console.Write(\"[\");\\n              for (int i = start; i <= end; i++) {\\n                  Console.Write(s[i] + (i == end ? \"\" : \",\"));\\n              }\\n              Console.WriteLine(\"]\");\\n\\n              end++;\\n          }\\n\\n          return res;\\n      }\\n   ```\n```csharp\\n return AtMost(s, k) - AtMost(s, k - 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348984,
                "title": "different-python-two-pointer-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/392901/Simple-Python-moving-window)\\n[3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/348137/Simple-Python-two-pointer-solution-(52ms-beat-97.94))\\n[159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/348157/Simple-Python-two-pointer-solution)\\n[340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/348216/Simple-Python-two-pointer-solution-(72-ms-beat-94.93))\\n[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/348984/Different-Python-two-pointer-solutions)\\n[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/363071/Simple-Python-two-pointer-solution)\\n[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/344476/Simple-Python-two-pointer-solution)\\n[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/discuss/344245/Simple-Python-solution-(beat-94.59))\\n[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/344533/Simple-Python-two-pointer-solution)\\n\\nSolution 1: \\nKeep a moving window expand while it contains less than k distinct integers, \\nthen shrink while it contains k + 1 distinct integers. \\nOnly save the right-most positions of distinct integers.\\nFor fixed ending at right, the window contains k distinct integers if the left end is between [left, left_k]. \\n\\nTime complexity: O(n * K) (Time Limit Exceeded, 52 / 55 test cases passed.)\\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        right_most_pos = dict()\\n        for right in range(len(A)):\\n            right_most_pos[A[right]] = right\\n            if len(right_most_pos) == K + 1:\\n                left_k = min(right_most_pos.values())\\n                right_most_pos.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(right_most_pos) == K:\\n                left_k = min(right_most_pos.values())\\n                res += left_k - left + 1\\n        return res\\n```\\n\\nSolution 2: use bisect to improve the efficiency of min(right_most_pos.values())\\nTime complexity: O(n * K) (512 ms, beat 85.48%)\\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        sorted_pos = []\\n        right_most_pos = dict()\\n        for right in range(len(A)):\\n            if A[right] in right_most_pos:\\n                ind = bisect.bisect_left(sorted_pos, right_most_pos[A[right]])\\n                sorted_pos.pop(ind)\\n            sorted_pos.append(right)\\n            right_most_pos[A[right]] = right\\n            if len(right_most_pos) == K + 1:\\n                left_k = sorted_pos.pop(0)\\n                right_most_pos.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(right_most_pos) == K:\\n                left_k = sorted_pos[0]\\n                res += left_k - left + 1\\n        return res\\n```\\n\\nSolution 3: instead of saving the right-most positions of distinct integers, we save their frequences\\nTime complexity: O(n) (424 ms, beat 95.16%)\\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        counter = dict()\\n        for right in range(len(A)):\\n            counter[A[right]] = counter.get(A[right], 0) + 1\\n            if len(counter) == K + 1:\\n                counter.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(counter) == K:\\n                while counter[A[left_k]] > 1:\\n                    counter[A[left_k]] -= 1\\n                    left_k += 1\\n                res += left_k - left + 1\\n        return res\\n```\\n\\t\\t\\nSolution 4: two-pass solution\\nTime complexity O(n), (584 ms, beat 62.90%)\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A, K):\\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\\n\\n    def atMostK(self, A, K):\\n        counter = dict()\\n        res = 0\\n        left = 0\\n        for right in range(len(A)):\\n            counter[A[right]] = counter.get(A[right], 0) + 1\\n            while len(counter) > K:\\n                counter[A[left]] -= 1\\n                if counter[A[left]] == 0:\\n                    counter.pop(A[left])\\n                left += 1\\n            res += right - left + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        right_most_pos = dict()\\n        for right in range(len(A)):\\n            right_most_pos[A[right]] = right\\n            if len(right_most_pos) == K + 1:\\n                left_k = min(right_most_pos.values())\\n                right_most_pos.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(right_most_pos) == K:\\n                left_k = min(right_most_pos.values())\\n                res += left_k - left + 1\\n        return res\\n```\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        sorted_pos = []\\n        right_most_pos = dict()\\n        for right in range(len(A)):\\n            if A[right] in right_most_pos:\\n                ind = bisect.bisect_left(sorted_pos, right_most_pos[A[right]])\\n                sorted_pos.pop(ind)\\n            sorted_pos.append(right)\\n            right_most_pos[A[right]] = right\\n            if len(right_most_pos) == K + 1:\\n                left_k = sorted_pos.pop(0)\\n                right_most_pos.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(right_most_pos) == K:\\n                left_k = sorted_pos[0]\\n                res += left_k - left + 1\\n        return res\\n```\n```\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        if K == 0 or len(A) < K:\\n            return 0\\n        res = 0\\n        left, left_k = 0, 0\\n        counter = dict()\\n        for right in range(len(A)):\\n            counter[A[right]] = counter.get(A[right], 0) + 1\\n            if len(counter) == K + 1:\\n                counter.pop(A[left_k])\\n                left_k += 1\\n                left = left_k\\n            if len(counter) == K:\\n                while counter[A[left_k]] > 1:\\n                    counter[A[left_k]] -= 1\\n                    left_k += 1\\n                res += left_k - left + 1\\n        return res\\n```\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A, K):\\n        return self.atMostK(A, K) - self.atMostK(A, K - 1)\\n\\n    def atMostK(self, A, K):\\n        counter = dict()\\n        res = 0\\n        left = 0\\n        for right in range(len(A)):\\n            counter[A[right]] = counter.get(A[right], 0) + 1\\n            while len(counter) > K:\\n                counter[A[left]] -= 1\\n                if counter[A[left]] == 0:\\n                    counter.pop(A[left])\\n                left += 1\\n            res += right - left + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996719,
                "title": "for-those-who-didn-t-understand-why-exactly-k-atmost-k-atmost-k-1-works",
                "content": "Well, suppose you have a room with a bunch of children in it. It turns out that there are 12 children who are five years old or under, and 8 children who are four years old or under.\\n\\nNow presumably you agree that each one of the \"children four years old or under\" is also one of the \"children five years old or under,\" right?\\n\\nSo suppose we take the 12 children five years old or younger, and remove from them the 8 children four years old or younger. Of course, 12 - 8 = 4 children remain.\\n\\nNow, how old is each of these children?\\n\\nBelow I am sharing the solution using variable sized sliding window based on above approach.\\n```\\nclass Solution {\\n  public int subarraysWithKDistinct(int[] nums, int k) {\\n\\n    return subarraysWithKSize(nums, k) - subarraysWithKSize(nums, k - 1);\\n  }\\n    \\n    //Function for at-most k distinct\\n    \\n  public int subarraysWithKSize(int[] nums, int k) {\\n    HashMap < Integer, Integer > hs = new HashMap < > ();\\n    int count = 0;\\n    int i = 0;\\n    int j = 0;\\n    while (j < nums.length) {\\n      hs.put(nums[j], hs.getOrDefault(nums[j], 0) + 1);\\n\\n      while (hs.size() == k + 1) \\n      { \\n        hs.put(nums[i], hs.get(nums[i]) - 1);\\n        if (hs.get(nums[i]) == 0)\\n          hs.remove(nums[i]);\\n        i++;\\n\\n      }\\n\\n      count += j - i + 1;\\n      j++;\\n\\n    }\\n\\n    return count;\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  public int subarraysWithKDistinct(int[] nums, int k) {\\n\\n    return subarraysWithKSize(nums, k) - subarraysWithKSize(nums, k - 1);\\n  }\\n    \\n    //Function for at-most k distinct\\n    \\n  public int subarraysWithKSize(int[] nums, int k) {\\n    HashMap < Integer, Integer > hs = new HashMap < > ();\\n    int count = 0;\\n    int i = 0;\\n    int j = 0;\\n    while (j < nums.length) {\\n      hs.put(nums[j], hs.getOrDefault(nums[j], 0) + 1);\\n\\n      while (hs.size() == k + 1) \\n      { \\n        hs.put(nums[i], hs.get(nums[i]) - 1);\\n        if (hs.get(nums[i]) == 0)\\n          hs.remove(nums[i]);\\n        i++;\\n\\n      }\\n\\n      count += j - i + 1;\\n      j++;\\n\\n    }\\n\\n    return count;\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234614,
                "title": "java-solution-using-two-pointers-and-hashmap",
                "content": "\\t class Solution {\\n\\t\\tpublic int subarraysWithKDistinct(int[] nums, int K) {\\n\\t\\t\\tMap<Integer,Integer> map = new HashMap<>();\\n\\n\\t\\t\\tint first=0;\\n\\t\\t\\tint second = 0;\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\twhile(second < nums.length){\\n\\t\\t\\t\\tmap.put(nums[second],map.getOrDefault(nums[second],0)+1);           \\n\\t\\t\\t\\tif(map.size()>K){\\n\\t\\t\\t\\t\\tmap.clear();\\n\\t\\t\\t\\t\\tfirst++;\\n\\t\\t\\t\\t\\tsecond = first;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(map.size() == K){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tsecond++;\\n\\t\\t\\t\\t\\tif(second == nums.length){\\n\\t\\t\\t\\t\\t\\tmap.clear();\\n\\t\\t\\t\\t\\t\\tfirst++;\\n\\t\\t\\t\\t\\t\\tsecond = first;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tsecond++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count;\\n        \\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n\\t\\n\\tThe Idea is to iterate the second pointer until the size of the map is equal to k and then clear the map and move the first pointer.",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int subarraysWithKDistinct(int[] nums, int K) {\\n\\t\\t\\tMap<Integer,Integer> map = new HashMap<>();\\n\\n\\t\\t\\tint first=0;\\n\\t\\t\\tint second = 0;\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\twhile(second < nums.length){\\n\\t\\t\\t\\tmap.put(nums[second],map.getOrDefault(nums[second],0)+1);           \\n\\t\\t\\t\\tif(map.size()>K){\\n\\t\\t\\t\\t\\tmap.clear();\\n\\t\\t\\t\\t\\tfirst++;\\n\\t\\t\\t\\t\\tsecond = first;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 234855,
                "title": "c-o-nk-sliding-modification-with-detailed-explanation",
                "content": "We used a map to keep track of the **last apperance index of a character**. \\nThen we move the **right** in outer layer to update the map. \\nIf we have more than K element inside the window, move the **left** curosr, decrease number and update the map.\\nWhen the map have exactly K element, loop through the map to find out the **minIndex** of the map.  \\n#### ***Any window start between [left, minIndex] and end with right is a qualified answer.***\\nTime complexity **O(NK)**, each element is put/pop from the sliding windows/map only once, each iteration might loop throguh all k element in the map.\\nSpace complexity **O(K)**, for the map keep track of last apperance of each K element.\\n```\\nint subarraysWithKDistinct(vector<int>& A, int K) {\\n    int answer = 0;\\n    unordered_map<int, int> m;\\n    int left = 0;\\n    int right = 0;\\n    while(right < A.size()) {                   // each element is only put into windows once\\n        m[A[right]] = right;\\n\\n        while (m.size() > K) {                 \\n            if (m[A[left]] == left)             // A[left] can be removed from the map if left is the last apperance\\n                m.erase(A[left]);\\n            left++;                             // each element is only pop from windows once\\n        }\\n        if (m.size() == K) {\\n            int minIndex = right;\\n            for (auto i : m)                    // find the minIndex of the map\\n                minIndex = min(minIndex, i.second);\\n            answer += minIndex - left + 1;      // Any window start between [left, minIndex] and end with right is a qualified answer.\\n        }\\n        right++;\\n    }\\n    return answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint subarraysWithKDistinct(vector<int>& A, int K) {\\n    int answer = 0;\\n    unordered_map<int, int> m;\\n    int left = 0;\\n    int right = 0;\\n    while(right < A.size()) {                   // each element is only put into windows once\\n        m[A[right]] = right;\\n\\n        while (m.size() > K) {                 \\n            if (m[A[left]] == left)             // A[left] can be removed from the map if left is the last apperance\\n                m.erase(A[left]);\\n            left++;                             // each element is only pop from windows once\\n        }\\n        if (m.size() == K) {\\n            int minIndex = right;\\n            for (auto i : m)                    // find the minIndex of the map\\n                minIndex = min(minIndex, i.second);\\n            answer += minIndex - left + 1;      // Any window start between [left, minIndex] and end with right is a qualified answer.\\n        }\\n        right++;\\n    }\\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638798,
                "title": "c-code-with-through-explanation",
                "content": "When you move the right cursor, keep tracking whether we have reach a count of K distinct integers, if yes, we process left cursor, here is how we process left cursor:\\n\\ncheck whether the element pointed by left cursor is duplicated in window, if yes, we remove it, and use a variable (e.g. prefix) to record that we have removed an element from the window). keep this process until we reduce the window size from to exactly K. now we can calculate the number of valid good array as res += prefix;\\n\\nafter process left cursor and all the stuff, the outer loop will continue and right cursor will move forward, and then the window size will exceed K, we can simply drop the left most element of the window and reset prefix to 0. and continue on.\\n\\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int res = 0;\\n      \\tvector<int> m(A.size() + 1);\\n        int end = 0, begin = 0, prefix = 0, cnt = 0;\\n      \\twhile(end < A.size()) {\\n        \\tif (m[A[end++]]++ == 0) ++cnt;\\n        \\tif (cnt > K) {\\n                --m[A[begin++]];\\n                --cnt;\\n                prefix = 0;\\n            }\\n        \\twhile (m[A[begin]] > 1) {\\n                ++prefix; \\n                --m[A[begin++]];\\n            }\\n        \\tif (cnt == K) \\n                res += prefix + 1;\\n      \\t}\\n      \\treturn res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/juniway/image_1589794387.png)\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int res = 0;\\n      \\tvector<int> m(A.size() + 1);\\n        int end = 0, begin = 0, prefix = 0, cnt = 0;\\n      \\twhile(end < A.size()) {\\n        \\tif (m[A[end++]]++ == 0) ++cnt;\\n        \\tif (cnt > K) {\\n                --m[A[begin++]];\\n                --cnt;\\n                prefix = 0;\\n            }\\n        \\twhile (m[A[begin]] > 1) {\\n                ++prefix; \\n                --m[A[begin++]];\\n            }\\n        \\tif (cnt == K) \\n                res += prefix + 1;\\n      \\t}\\n      \\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379342,
                "title": "sliding-window-aditya-verma-s-approach-easy-to-understand",
                "content": "# Link to a similar problem && solution :) \\nhttps://leetcode.com/problems/binary-subarrays-with-sum/solutions/3379313/easy-sliding-window-comments-added-for-explanation-beats-92/ \\n# Approach :\\nThe given code provides a solution to find the number of subarrays that contain exactly k distinct integers. It uses a sliding window approach with the help of an unordered map to keep track of the count of each integer in the current window.\\n\\nThe subarrayCountWithAtMostKchar function is used to find the number of subarrays that have at most k distinct integers. It initializes two pointers i and j at the start of the array and uses an unordered map mp to keep track of the count of each integer in the current window. It then moves the right pointer j forward, increments the count of the integer arr[j] in the map, and checks if the number of distinct integers in the map is less than or equal to k. If it is, then it updates the count with the number of subarrays that can be formed with this window and moves the right pointer j forward. If it is not, then it moves the left pointer i forward, decrements the count of the integer arr[i] in the map, and checks if the count becomes 0. If it does, then it removes the integer from the map. It continues this process until the number of distinct integers in the map is less than or equal to k. After shrinking the window, it updates the count with the number of subarrays that can be formed with this window and moves the right pointer j forward. It repeats this process until the right pointer j reaches the end of the array.\\n\\nThe subarraysWithKDistinct function is used to find the number of subarrays that have exactly k distinct integers. It calls the subarrayCountWithAtMostKchar function twice with k and k-1 as input, respectively. It then returns the difference between these two counts, which gives the count of subarrays that have exactly k distinct integers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : The time complexity of the given code is $$O(N)$$, where N is the length of the input array arr or nums. This is because we iterate through each element of the array once using the sliding window approach, and perform constant time operations at each step.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity :  The space complexity of the given code is  $$O(K)$$, where K is the size of the unordered map mp. This is because we store at most K distinct integers in the map at any given time.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// This is a solution to find the number of subarrays that contain exactly k distinct integers\\n\\nclass Solution {\\npublic:\\n    int subarrayCountWithAtMostKchar(vector<int>& arr, int k) {\\n        int i = 0, j = 0, count = 0;\\n        unordered_map<int, int> mp; // create an unordered map to keep track of the count of each integer\\n\\n        while (j < arr.size()) {\\n            mp[arr[j]]++; // increment the count of integer arr[j] in the map\\n\\n            if (mp.size() <= k) { // if the number of distinct integers in the map is less than or equal to k\\n                count += j - i + 1; // then update the count with the number of subarrays that can be formed with this window\\n                j++; // move the right pointer forward\\n            } else {\\n                while (mp.size() > k) { // if the number of distinct integers in the map is greater than k\\n                    mp[arr[i]]--; // decrement the count of the integer arr[i] in the map\\n\\n                    if (mp[arr[i]] == 0) { // if the count becomes 0\\n                        mp.erase(arr[i]); // then remove the integer from the map\\n                    }\\n\\n                    i++; // move the left pointer forward\\n                }\\n\\n                if (mp.size() <= k) { // after shrinking the window, if the number of distinct integers in the map is less than or equal to k\\n                    count += j - i + 1; // then update the count with the number of subarrays that can be formed with this window\\n                }\\n\\n                j++; // move the right pointer forward\\n            }\\n        }\\n\\n        return count; // return the count\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int a = subarrayCountWithAtMostKchar(nums, k); // get the count of subarrays with at most k distinct integers\\n        int b = subarrayCountWithAtMostKchar(nums, k - 1); // get the count of subarrays with at most k-1 distinct integers\\n\\n        return a - b; // the difference between these counts gives the count of subarrays with exactly k distinct integers\\n    }\\n};\\n\\n```\\n\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n**![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/a234e8f5-3869-425b-94a7-beee9509065f_1680614836.0752363.gif)**\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n// This is a solution to find the number of subarrays that contain exactly k distinct integers\\n\\nclass Solution {\\npublic:\\n    int subarrayCountWithAtMostKchar(vector<int>& arr, int k) {\\n        int i = 0, j = 0, count = 0;\\n        unordered_map<int, int> mp; // create an unordered map to keep track of the count of each integer\\n\\n        while (j < arr.size()) {\\n            mp[arr[j]]++; // increment the count of integer arr[j] in the map\\n\\n            if (mp.size() <= k) { // if the number of distinct integers in the map is less than or equal to k\\n                count += j - i + 1; // then update the count with the number of subarrays that can be formed with this window\\n                j++; // move the right pointer forward\\n            } else {\\n                while (mp.size() > k) { // if the number of distinct integers in the map is greater than k\\n                    mp[arr[i]]--; // decrement the count of the integer arr[i] in the map\\n\\n                    if (mp[arr[i]] == 0) { // if the count becomes 0\\n                        mp.erase(arr[i]); // then remove the integer from the map\\n                    }\\n\\n                    i++; // move the left pointer forward\\n                }\\n\\n                if (mp.size() <= k) { // after shrinking the window, if the number of distinct integers in the map is less than or equal to k\\n                    count += j - i + 1; // then update the count with the number of subarrays that can be formed with this window\\n                }\\n\\n                j++; // move the right pointer forward\\n            }\\n        }\\n\\n        return count; // return the count\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int a = subarrayCountWithAtMostKchar(nums, k); // get the count of subarrays with at most k distinct integers\\n        int b = subarrayCountWithAtMostKchar(nums, k - 1); // get the count of subarrays with at most k-1 distinct integers\\n\\n        return a - b; // the difference between these counts gives the count of subarrays with exactly k distinct integers\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920753,
                "title": "python-hashmap-sliding-window-simple-solution-wiith-explanation",
                "content": "## Logic:\\n1. To directly count the subarrays with exactly K different integers is hard but to find the count of subarrays with at most K different integers is easy. \\n2. So the idea is to find the count of subarrays with at most K different integers(fn(K)), and the count of subarrays with at most (K \\u2013 1) different integers(fn(K \\u2013 1)) and finally take their difference, fn(K) \\u2013 fn(K \\u2013 1) which is the required answer.\\n3. Now, count of subarrays with at most K different elements can be easily calculated through the sliding window technique. \\n4. The idea is to keep expanding the right boundary of the window till the count of distinct elements in the window is less than or equal to K and when the count of distinct elements inside the window becomes more than K, start shrinking the window from the left till the count becomes less than or equal to K. Also for every expansion, keep counting the subarrays as end \\u2013 start + 1.\\n\\n```\\nclass Solution:\\n    def atMostKDistinct(self, nums, k):\\n        hashmap = {}\\n        subarrays = 0\\n        start, end = 0, 0\\n        while end < len(nums):\\n            if nums[end] in hashmap:\\n                hashmap[nums[end]] += 1\\n            else:\\n                hashmap[nums[end]] = 1\\n            while len(hashmap) > k:\\n                hashmap[nums[start]] -= 1\\n                if hashmap[nums[start]] == 0:\\n                    del hashmap[nums[start]]\\n                start += 1\\n            subarrays += end-start+1\\n            end += 1\\n        return subarrays\\n    \\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atMostKDistinct(nums, k) - self.atMostKDistinct(nums, k-1)\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def atMostKDistinct(self, nums, k):\\n        hashmap = {}\\n        subarrays = 0\\n        start, end = 0, 0\\n        while end < len(nums):\\n            if nums[end] in hashmap:\\n                hashmap[nums[end]] += 1\\n            else:\\n                hashmap[nums[end]] = 1\\n            while len(hashmap) > k:\\n                hashmap[nums[start]] -= 1\\n                if hashmap[nums[start]] == 0:\\n                    del hashmap[nums[start]]\\n                start += 1\\n            subarrays += end-start+1\\n            end += 1\\n        return subarrays\\n    \\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atMostKDistinct(nums, k) - self.atMostKDistinct(nums, k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205721,
                "title": "easy-sliding-window-approach-in-c-o-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    // Helper function to determine number of subarrays with at most k distinct integers\\n    int helper(vector<int>&nums,int k)\\n    {\\n        int i=0,j=0,count=0,n=nums.size();\\n        unordered_map<int,int>m;\\n        while(j<n)\\n        {\\n            m[nums[j]]++;\\n            while(i<=j && m.size()>k)\\n            {\\n                if(m[nums[i]]==1)\\n                {\\n                    m.erase(nums[i]);\\n                }\\n                else\\n                {\\n                    m[nums[i]]--;\\n                }\\n                i++;\\n            }\\n            count+=(j-i+1);\\n            j++;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        // The concept:-->\\n        // helper(nums,k)=number of subarrays with at most k distinct integers\\n        // helper(nums,k-1)=number of subarrays with at most k-1 distinct integers\\n        // So more formally we can say that \\n        // helper(nums,k)=number of subarrays with exactly k distinct integers + number of subarrays with less than k distinct integers\\n        // So if we exclude the number of subarrays with less than k distinct integers from the number of subarrays with at most k distinct integers, we\\'ll get our answer.\\n        return helper(nums,k)-helper(nums,k-1);\\n    }\\n};\\n```\\n**Don\\'t forget to upvote if you\\'ve got any help from my explanation.**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    // Helper function to determine number of subarrays with at most k distinct integers\\n    int helper(vector<int>&nums,int k)\\n    {\\n        int i=0,j=0,count=0,n=nums.size();\\n        unordered_map<int,int>m;\\n        while(j<n)\\n        {\\n            m[nums[j]]++;\\n            while(i<=j && m.size()>k)\\n            {\\n                if(m[nums[i]]==1)\\n                {\\n                    m.erase(nums[i]);\\n                }\\n                else\\n                {\\n                    m[nums[i]]--;\\n                }\\n                i++;\\n            }\\n            count+=(j-i+1);\\n            j++;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        // The concept:-->\\n        // helper(nums,k)=number of subarrays with at most k distinct integers\\n        // helper(nums,k-1)=number of subarrays with at most k-1 distinct integers\\n        // So more formally we can say that \\n        // helper(nums,k)=number of subarrays with exactly k distinct integers + number of subarrays with less than k distinct integers\\n        // So if we exclude the number of subarrays with less than k distinct integers from the number of subarrays with at most k distinct integers, we\\'ll get our answer.\\n        return helper(nums,k)-helper(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720917,
                "title": "c-o-n-sliding-window-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/subarrays-with-k-different-integers/submissions/\\n    \\n    We use a different problem to solve this. We find the number of substrings with atmost\\n    K unique chars. \\n    substrings with exactly k = atmost unique (K) - atmost unique (K-1)\\n    This diff only leaves the substrings with exactly k unique chars\\n*/\\nclass Solution {\\npublic:\\n    // Finds the substring with atmost K unique chars\\n    int atmostK(vector<int>& arr, int K) {\\n        int i = 0, j = 0, substrings = 0;\\n        unordered_map<int, int> freq;\\n        const int N = arr.size();\\n        \\n        while(i < N) {\\n            // Expand the window\\n            if(K >= 0) {\\n                ++freq[arr[i]];\\n                if(freq[arr[i]] == 1)\\n                    --K;\\n                ++i;\\n            }\\n            // make the window valid\\n            while(K < 0) {\\n                --freq[arr[j]];\\n                if(freq[arr[j]] == 0)\\n                    ++K;\\n                ++j;\\n            }\\n            // Each valid window adds the subarrays which satisfies the condition\\n            // For : 1,2,1, k=2\\n            // 1: [1] \\n            // 2: [2], [1,2]\\n            // 3: [1,2], [2,1], [1,2,1]\\n            substrings += i - j + 1;\\n        }\\n        return substrings;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& arr, int K) {\\n        return atmostK(arr, K) - atmostK(arr, K-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/subarrays-with-k-different-integers/submissions/\\n    \\n    We use a different problem to solve this. We find the number of substrings with atmost\\n    K unique chars. \\n    substrings with exactly k = atmost unique (K) - atmost unique (K-1)\\n    This diff only leaves the substrings with exactly k unique chars\\n*/\\nclass Solution {\\npublic:\\n    // Finds the substring with atmost K unique chars\\n    int atmostK(vector<int>& arr, int K) {\\n        int i = 0, j = 0, substrings = 0;\\n        unordered_map<int, int> freq;\\n        const int N = arr.size();\\n        \\n        while(i < N) {\\n            // Expand the window\\n            if(K >= 0) {\\n                ++freq[arr[i]];\\n                if(freq[arr[i]] == 1)\\n                    --K;\\n                ++i;\\n            }\\n            // make the window valid\\n            while(K < 0) {\\n                --freq[arr[j]];\\n                if(freq[arr[j]] == 0)\\n                    ++K;\\n                ++j;\\n            }\\n            // Each valid window adds the subarrays which satisfies the condition\\n            // For : 1,2,1, k=2\\n            // 1: [1] \\n            // 2: [2], [1,2]\\n            // 3: [1,2], [2,1], [1,2,1]\\n            substrings += i - j + 1;\\n        }\\n        return substrings;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& arr, int K) {\\n        return atmostK(arr, K) - atmostK(arr, K-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262299,
                "title": "single-pass-two-pointer-4ms-java-solution-beats-100-o-n-space",
                "content": "# Background\\nMy first serious attempt was basically this one, but at each loop iteration where I had K unique integers captured, I would manually count the subarrays possible within that range. I would do this by counting how many indices on the left pointed to duplicate values. Looking at other solutions I realized that I don\\'t need to count every time as I can remember how many \"extra\" copies of the unique integers I had at the left of the range and that count was the number of subarrays represented (count+1 actually). It tended towards O(N) in practice, but the extra counting at each step could drive it to a higher complexity if the entire array ended up being one big long valid subarray.\\n\\nMany of the variations of this counting method use a Map for storing the counts, and that is a similar O(N) time complexity to this solution, but slows down the operation of each step compared to using a bucket sort and may use more storage depending on how much you thrash the storage of the Map.  The definition of the problem carefully limits the range of integers you can find in the array to 1..N where N is the size of the data array.  So, accepting O(N) space usage, we can use bucket sorting which is much faster.\\n\\nI\\'ll note that I also used a loop at one point for the \"if (K < 0)\" case thinking that I had to pass up all values until I found one whose count went to 0.  I noticed a solution that didn\\'t use a loop there and realized that if you\\'ve already skipped the left pointer past all of the \"extra\" values (counting them so you know how many subarrays are represented), then the value at the left pointer should be unique, and its count should be 1 exactly.  Thus, you always have at most one value to advance the left pointer past before you are down to the intended number of unique integers in the range.\\n\\nI am not sure why this runs more than 2ms faster than any other Java solution as there is nothing unique here that isn\\'t already used in any number of the other discussion examples, but its run time is consistently shown 2 stops faster than any other recorded solution.\\n\\nHere is a more formal description of the way it works.\\n\\n# Observations\\n- First note that a given range of unique integers can exist within the array with duplicates, such as in **[1,2,1,2]**. For **K=2** that is an example of one of the valid subarrays to be counted, but it also contains further subarrays that should also be counted.\\n- We can exhaustively count all possible subarrays of that range of 4 values, but things get complicated depending on the pattern of the repeated integers.\\n- To break it down, we can find the first unique subarray that starts at the first value and contains all of the integers - [**1,2**,1,2].  It has no further subarrays that also count, so we only get 1 subarray at that position.\\n- Moving to the right by one, we can count all unique subarrays that end at the next index - [1,**2,1**,2] and [**1,2,1**,2]\\n- Finally we move again to the right and count all unique subarrays that end at the last index - [1,2,**1,2**], [1,**2,1,2**], and [**1,2,1,2**]\\n- At each of those stages we are simply counting 1 for the minimal valid subarray that ends at the specified index plus 1 more for each of the duplicate values to the left of that minimal subarray.\\n- We don\\'t recount former subarrays in the latter stages because each stage only counts subarrays that end at the new position and all of the previously counted subarrays ended at an earlier position.\\n\\n# Overview of algorithm\\n- For each index **r** in the array of input values starting with the smallest **r** that encompasses **K** unique integers:\\n  - find the smallest subarray of **K** unique integers that ends at **r**\\n  - count the number of contiguous values (**ndup**) to the left of that subarray that are duplicates of the same **K** unique integers\\n  - new subarrays discovered that end at **r** will be **(ndup + 1)**, add that number to the total\\n\\n# Loop invariants\\n\\n- At the start of each loop iteration we have two pointers framing a section of the input array that contains no more than K unique integers.\\n- **l** and **r** represents the section of unique integers such that any index **i** of the data array where **(l <= i < r)** is in the range, aka the half-open interval **[l -> r)**.\\n- No smaller subarray that also ends at **r** contains the same unique integers so this is the minimal subarray that ends at **r** which has at most K unique integers.\\n- Similarly **l** is a pointer to the first number in the input that is not duplicated in the range **[l -> r)**.\\n- **nsub** represents the number of unique subarrays that also contain the same unique integers that are in the range and is basically a count of the number of duplicates of these integers that lie to the left of **l**, plus one for the minimal subarray from **[l -> r)**.\\n- **nvals[]** array keeps a count of each integer within the range **[l -> r)**.  If the count is 0, that particular integer does not appear in the range.  If the count is 1, then that particular integer appears only once in the range. If the count is greater than 1, then that integer appears multiple times within the range.\\n- Since **[l -> r)** is the smallest subarray with **K** unique integers, then the value at index **l** should  have no other duplicates in the range.\\n- As we grow the range to include more indices (by convention, always at the right end of the range by moving **r** forward), we increment the location in the **nvals** array associated with the new value at **A[r]**.  If that count goes from 0 to 1, then we have added a new unique integer to the range.\\n- As we shrink the range to include fewer indices (by convention, always at the left end of the range by moving **l** forward), we decrement the associated location in the **nvals** array.  If that count goes from 1 to 0, then we have removed all instances of that integer from the range.\\n- Due to the above properties, at the start of a loop iteration we can thus prove that **nvals[l]** is 1 because it is the first integer that is not duplicated in the range.\\n- Rather than keep a separate count of the number of unique integers in the range, we simply use the **K** value to represent how many more unique values we need to add to the range. If it is positive then we need more unique integers, if it is negative we have too many, and if it is 0, then we have a valid range.\\n- Summary:\\n  - **[l->r)** is the minimal subarray ending at **r** with at most **K** unique integers\\n  - value at **l** is unique within the range **[l -> r)** and so **(nvals[A[l]] == 1)**\\n  - **K** reaches 0 as soon as we have a valid subarray with **K** unique integers\\n  - **K** never varies from **[0,-1]** from that point on\\n\\n# Operation of the loop\\n- The first thing that each loop iteration does is to add a new value to the range at **r**.  We adjust the count for that value and if the count used to be 0 then we decrement **K** to represent the inclusion of one more unique integer in the range.\\n- If **K** becomes negative (it will be -1 exactly), then we have too many unique integers in the range and so we need to remove one.  Due to the properties above, we know that simply getting rid of the element at **l** will reduce the unique integers back to the appropriate number since we left it pointing to the first unique integer in the former valid range. In doing so, we no longer have any additional valid subranges to the left of **l** (since we know that the value at **l** itself is no longer in the valid range) so we reset the number of valid subarrays **nsub** to 1 (it may grow again in a later stage of the loop that counts duplicates).\\n- In early passes of the loop before we\\'ve passed **K** unique integers, the value of **K** may be positive at this point in which case we loop around, but once we get going it will tend to be **(K == 0)** at this point.\\n- If **(K == 0)** then **[l -> r)** is a valid range with exactly **K** integers, but it may not be the smallest such range that ends at **r**.\\n  - First we loop and bump **l** as long as it points to numbers that appear more than once in the range (**while (nvals[A[l]] > 1)**)\\n  - (Note that it is impossible for **(nvals[A[l]] == 0)** in this loop because all numbers between **l** and **r** are in the list of unique integers at least once.)\\n  - (Also note that it is impossible for **l** to advance off the end of the **A[]** array because it will always find a unique value before then.)\\n  - For each bump of **l** we adjust the counts in the **nvals[]** array and we increment **nsub** as we have identified one more duplicate integer to the left of **l**\\n  - When that loop terminates by finding a value such that **(nvals[A[l]] == 1)** then we have again found the smallest valid subarray ending at **r**.\\n  - Finally, we can add the number of represented subarrays - **nsub** - to the total\\n\\n# Java implementation\\n```\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int nvals[] = new int[A.length + 1];\\n        int nsub = 1;\\n        int l = 0;\\n        int r = 0;\\n        int totalsub = 0;\\n        while (r < A.length) {\\n            if (nvals[A[r++]]++ == 0) {\\n                K--;\\n            }\\n            if (K < 0) {\\n                --nvals[A[l++]];\\n                K++;\\n                nsub = 1;\\n            }\\n            if (K == 0) {\\n                while (nvals[A[l]] > 1) {\\n                    --nvals[A[l++]];\\n                    nsub++;\\n                }\\n                totalsub += nsub;\\n            }\\n        }\\n        return totalsub;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int nvals[] = new int[A.length + 1];\\n        int nsub = 1;\\n        int l = 0;\\n        int r = 0;\\n        int totalsub = 0;\\n        while (r < A.length) {\\n            if (nvals[A[r++]]++ == 0) {\\n                K--;\\n            }\\n            if (K < 0) {\\n                --nvals[A[l++]];\\n                K++;\\n                nsub = 1;\\n            }\\n            if (K == 0) {\\n                while (nvals[A[l]] > 1) {\\n                    --nvals[A[l++]];\\n                    nsub++;\\n                }\\n                totalsub += nsub;\\n            }\\n        }\\n        return totalsub;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555339,
                "title": "c-explanation-sliding-window-easy-to-understand",
                "content": "-> This problem will be a very typical sliding window,\\n-> if it asks the number of subarrays with at most K distinct elements.\\n\\n-> Just need one more step to reach the folloing equation:\\n-> exactly(K) = atMost(K) - atMost(K-1)\\n```    \\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k)\\n    {\\n        int i=0,res=0;\\n        unordered_map<int,int> m;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            if(!m[nums[j]]++)\\n                k--;\\n            while(k<0)\\n            {\\n                if(!--m[nums[i]])\\n                    k++;\\n                i++;\\n            }\\n            res+=j-i+1;\\n        }\\n        return res;\\n        \\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k)\\n    {\\n        return solve(nums,k)-solve(nums,k-1); //(1 to k all)-(1 to k-1 all)==exactly k  \\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<int>& nums, int k)\\n    {\\n        int i=0,res=0;\\n        unordered_map<int,int> m;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            if(!m[nums[j]]++)\\n                k--;\\n            while(k<0)\\n            {\\n                if(!--m[nums[i]])\\n                    k++;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3763791,
                "title": "dictionary-method-with-comments-beats-79-59-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\n        count1 = 0\\n        count2 = 0\\n\\n        left = 0\\n        right = 0\\n\\n        freq1 = defaultdict(int)\\n        freq2 = defaultdict(int)\\n\\n        res = 0\\n\\n        for i in range(len(nums)):\\n            #count frequencies which are greater than k\\n            if freq1[nums[i]] == 0:\\n                count1 +=1\\n            freq1[nums[i]] +=1\\n            #Count frequencies which are exactly k\\n            if freq2[nums[i]] == 0:\\n                count2 +=1\\n            freq2[nums[i]] +=1\\n            \\n            #Checking for count greater than k\\n            while count1 > k:\\n                freq1[nums[right]] -=1\\n                if freq1[nums[right]] == 0:\\n                    count1-=1\\n                right +=1\\n            \\n            #Checking Counts for exact k\\n            while count2 > k-1:\\n                freq2[nums[left]] -=1\\n                if freq2[nums[left]] == 0:\\n                    count2 -=1\\n                left +=1\\n            \\n            res += left - right\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\n        count1 = 0\\n        count2 = 0\\n\\n        left = 0\\n        right = 0\\n\\n        freq1 = defaultdict(int)\\n        freq2 = defaultdict(int)\\n\\n        res = 0\\n\\n        for i in range(len(nums)):\\n            #count frequencies which are greater than k\\n            if freq1[nums[i]] == 0:\\n                count1 +=1\\n            freq1[nums[i]] +=1\\n            #Count frequencies which are exactly k\\n            if freq2[nums[i]] == 0:\\n                count2 +=1\\n            freq2[nums[i]] +=1\\n            \\n            #Checking for count greater than k\\n            while count1 > k:\\n                freq1[nums[right]] -=1\\n                if freq1[nums[right]] == 0:\\n                    count1-=1\\n                right +=1\\n            \\n            #Checking Counts for exact k\\n            while count2 > k-1:\\n                freq2[nums[left]] -=1\\n                if freq2[nums[left]] == 0:\\n                    count2 -=1\\n                left +=1\\n            \\n            res += left - right\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604221,
                "title": "c-sliding-window-hints-intuition-explained-commented-code",
                "content": "* to move directly to the approach first **make sure you have tried these questions**:\\n\\t* [maximum consecutive ones iii](https://leetcode.com/problems/max-consecutive-ones-iii/)\\n\\t* longest substring with at most k distinct characters\\n* rather then moving to approach of this problem, we will **first see the approach to the problem mentioned above [longest substring with at most k distinct characters]** using sliding window\\n\\t* Now,**when we add an element, there could be 2 cases:**\\n\\t\\t\\t**1**. \\t**element is distinct**: we have found one of the distinct element so we will decrease k as now only k-1 disitnct elements can be added furthur - **[k--]**\\n\\t\\t\\t**2**. \\t**element is not distinct**: no issues! as that is not going to affect k as similar element is already seen before, so we just need to increase its frequency and that\\'s it! \\uD83D\\uDE04 -  [**nothing specific to be done!]**\\n\\t* for above 2 cases, to check whether element is distinct or not, we need to have a **data structure which can store frequency of every element and can access it in minimal time**. And we know that this data structure is **our dearest unordered Map** \\uD83D\\uDC99. So we will declare and unordered map and will be updating the frequency of elements in it in every iteration.\\n\\t* Now, **we will keep moving until we reach the danger** \\uD83D\\uDC80\\u26A1 **point - when k < 0** that means **we have colllected the maximum limit of distinct characters and we have one extra distinct character** and now k is exhausted. Now, this extra distinct character is evil\\uD83D\\uDE08 so we need to remove it as we want to make k = 0 to satisfy the given conditions.\\n\\t* Now, to make k back to safe. So for the same we we will use **2 pointer approach** position ie., 0. we need to go to starting and minimize the window unitl we get k=0. We will decrease the start pointer until we reach a positions where k becomes zero again.\\n\\t* So after all these long points \\uD83E\\uDD74, let me summarize the conditions:\\n\\t\\t\\t**1. k > 0: no issues. Just update the length and update frequency.**\\n\\t\\t\\t**2. k = 0: danger point. but nothing specific to do. all operations like k>0 to be performed.**\\n\\t\\t\\t**3. k < 0: unstable condition. immediately have to make k = 0 by 2 pointer approach. Decrementing k until getting k back to 0 and updating freq in map along with.**\\n#### \\t\\t\\t***CODE FOR LONGEST SUBSTRING WITH AT MOST K DISTINCT CHARACTERS***\\n```\\n\\nstring longestSubstringWuthAtmostKDistinct(string s, int k) {\\n        int size = s.length();\\n        int start = 0, end = 0;\\n        int len = 0, ans = 0;\\n        unordered_map<char, int> mp;\\n        \\n        while(end < size)\\n        {\\n            if(mp[s[end]] == 0) // distinct\\n            {\\n                k--;\\n            }\\n            \\n            if(k >= 0)\\n            {\\n                len++;\\n                mp[s[end++]];\\n                ans = max(ans, len);\\n            }\\n            \\n            else\\n            {\\n                mp[s[end]]++;\\n                while(k < 0)\\n                {\\n                    if(mp[s[start]] == 1)\\n                    {\\n                        k++;\\n                    }\\n                    mp[s[start]]--;\\n                    start++;\\n                    len = end - start + 1;\\n                }\\n            }\\n            end++;\\n        }\\n        if(ans != 0) {\\n            return s.substr(start, end - start + 1);\\n        }\\n    return \"\";\\n    }\\n```\\n* **Coming to question of exactly k distinct characters**. Let\\'s say we have k = 3.\\n* Then the above problem will consider all the string with **AtMost(k) = AtMost(2) = 3 distinct + 2 distinct + 1 distinct + 0 distinct**\\n* And if we run the same above function for k-1 ie., for k = 2.it will consider all the strings with **AtMost(k-1) = AtMost(2) = 2 distinct + 1 distinct + 0 distinct**\\n* **There\\'s a great observation here.** \\n\\t**Atmost(3) - Atmost (2) = (3 distinct + 2 distinct + 1 distinct + 0 distinct) - (2 distinct + 1 distinct + 0 distinct) = 3 disinct = exactly k distinct.**\\n\\t\\n\\t#### \\t\\t\\t***CODE FOR SUBARRAYS WITH K DIFFERENT INTEGERS***\\n\\t\\n```\\n int subarraysWithAtMostKDistinct(vector<int> nums, int k)\\n{\\n\\tunordered_map<int, int> freq;\\n\\tint size = nums.size();\\n\\tint start = 0, end = 0;\\n\\tint total = 0;\\n\\n\\twhile(end < size)\\n\\t{\\n\\t\\tif(freq[nums[end]] == 0) // distinct\\n\\t\\t{\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\n\\t\\tif(k >= 0)\\n\\t\\t{\\n\\t\\t\\tfreq[nums[end]]++;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfreq[nums[end]]++;\\n\\t\\t\\twhile(k < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(freq[nums[start]] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfreq[nums[start]]--;\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tend++;\\n\\t\\ttotal += end-start+-1;\\n\\t}\\n\\n\\treturn total;\\n}\\n\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n\\tint atMostKdistinct = subarraysWithAtMostKDistinct(nums, k);\\n\\n\\tint atMostK_1distinct = subarraysWithAtMostKDistinct(nums, k-1);\\n\\n\\treturn atMostKdistinct - atMostK_1distinct;\\n}\\n```\\n\\n\\n\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n\\nstring longestSubstringWuthAtmostKDistinct(string s, int k) {\\n        int size = s.length();\\n        int start = 0, end = 0;\\n        int len = 0, ans = 0;\\n        unordered_map<char, int> mp;\\n        \\n        while(end < size)\\n        {\\n            if(mp[s[end]] == 0) // distinct\\n            {\\n                k--;\\n            }\\n            \\n            if(k >= 0)\\n            {\\n                len++;\\n                mp[s[end++]];\\n                ans = max(ans, len);\\n            }\\n            \\n            else\\n            {\\n                mp[s[end]]++;\\n                while(k < 0)\\n                {\\n                    if(mp[s[start]] == 1)\\n                    {\\n                        k++;\\n                    }\\n                    mp[s[start]]--;\\n                    start++;\\n                    len = end - start + 1;\\n                }\\n            }\\n            end++;\\n        }\\n        if(ans != 0) {\\n            return s.substr(start, end - start + 1);\\n        }\\n    return \"\";\\n    }\\n```\n```\\n int subarraysWithAtMostKDistinct(vector<int> nums, int k)\\n{\\n\\tunordered_map<int, int> freq;\\n\\tint size = nums.size();\\n\\tint start = 0, end = 0;\\n\\tint total = 0;\\n\\n\\twhile(end < size)\\n\\t{\\n\\t\\tif(freq[nums[end]] == 0) // distinct\\n\\t\\t{\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\n\\t\\tif(k >= 0)\\n\\t\\t{\\n\\t\\t\\tfreq[nums[end]]++;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfreq[nums[end]]++;\\n\\t\\t\\twhile(k < 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(freq[nums[start]] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfreq[nums[start]]--;\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tend++;\\n\\t\\ttotal += end-start+-1;\\n\\t}\\n\\n\\treturn total;\\n}\\n\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n\\tint atMostKdistinct = subarraysWithAtMostKDistinct(nums, k);\\n\\n\\tint atMostK_1distinct = subarraysWithAtMostKDistinct(nums, k-1);\\n\\n\\treturn atMostKdistinct - atMostK_1distinct;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690606,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n        \\n    }\\n    public int atmostK(int []nums,int k)\\n    { int ans=0;\\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        int i=0; int j=0;\\n        while(j<nums.length)\\n        {\\n            mp.put(nums[j],mp.getOrDefault(nums[j],0)+1);\\n            while(mp.size()==k+1)\\n            {\\n                mp.put(nums[i],mp.get(nums[i])-1);\\n                if(mp.get(nums[i])==0)\\n                    mp.remove(nums[i]);\\n                i++;\\n            }\\n            ans+=j-i+1;\\n            j++;\\n            \\n        }\\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n        \\n    }\\n    public int atmostK(int []nums,int k)\\n    { int ans=0;\\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        int i=0; int j=0;\\n        while(j<nums.length)\\n        {\\n            mp.put(nums[j],mp.getOrDefault(nums[j],0)+1);\\n            while(mp.size()==k+1)\\n            {\\n                mp.put(nums[i],mp.get(nums[i])-1);\\n                if(mp.get(nums[i])==0)\\n                    mp.remove(nums[i]);\\n                i++;\\n            }\\n            ans+=j-i+1;\\n            j++;\\n            \\n        }\\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617557,
                "title": "python3-o-n-ordereddict-sliding-window-subarrays-with-k-different-integers",
                "content": "```\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        ans = l = 0\\n        # Last seen index of an integer\\n        od = OrderedDict()\\n        for i, n in enumerate(A):\\n            od[n] = i\\n            od.move_to_end(n)\\n            while len(od) > K:\\n                l = od.popitem(last=False)[1] + 1\\n            if len(od) == K:\\n\\t\\t\\t    # The smallest index in od - left bound + 1\\n                ans += next(iter(od.items()))[1] - l + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        ans = l = 0\\n        # Last seen index of an integer\\n        od = OrderedDict()\\n        for i, n in enumerate(A):\\n            od[n] = i\\n            od.move_to_end(n)\\n            while len(od) > K:\\n                l = od.popitem(last=False)[1] + 1\\n            if len(od) == K:\\n\\t\\t\\t    # The smallest index in od - left bound + 1\\n                ans += next(iter(od.items()))[1] - l + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204820,
                "title": "java-using-sliding-window-and-hashmap",
                "content": "```\\n public int subarraysWithKDistinct(int[] A, int K) {\\n        int n = A.length;\\n        int c = 0;\\n        \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        int i=0,j=0; // i is starting pointer and j is end pointer\\n        while(j<n && i<n){\\n            m.put(A[j], m.getOrDefault(A[j], 0)+1);\\n            \\n            while(m.size()>K){\\n                m.put(A[i], m.get(A[i])-1);\\n                if(m.get(A[i])<=0){\\n                    m.remove(A[i]);\\n                }\\n                i++;\\n            }\\n            int prev = i;\\n            while(i<=j && m.size()==K) { //i==j incase of K=1\\n                m.put(A[i], m.get(A[i])-1);\\n                if(m.get(A[i])<=0){\\n                    m.remove(A[i]);\\n                }\\n                i++;\\n                c++;\\n            } \\n            \\n            while(prev!=i){\\n                i--;\\n                m.put(A[i], m.getOrDefault(A[i], 0)+1); \\n                // now get back to the state you previously were\\n            }\\n            j++;   \\n            \\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n public int subarraysWithKDistinct(int[] A, int K) {\\n        int n = A.length;\\n        int c = 0;\\n        \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        int i=0,j=0; // i is starting pointer and j is end pointer\\n        while(j<n && i<n){\\n            m.put(A[j], m.getOrDefault(A[j], 0)+1);\\n            \\n            while(m.size()>K){\\n                m.put(A[i], m.get(A[i])-1);\\n                if(m.get(A[i])<=0){\\n                    m.remove(A[i]);\\n                }\\n                i++;\\n            }\\n            int prev = i;\\n            while(i<=j && m.size()==K) { //i==j incase of K=1\\n                m.put(A[i], m.get(A[i])-1);\\n                if(m.get(A[i])<=0){\\n                    m.remove(A[i]);\\n                }\\n                i++;\\n                c++;\\n            } \\n            \\n            while(prev!=i){\\n                i--;\\n                m.put(A[i], m.getOrDefault(A[i], 0)+1); \\n                // now get back to the state you previously were\\n            }\\n            j++;   \\n            \\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749344,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=akwRFY2eyXs\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int atmost(int k,vector<int>& nums){\\n         unordered_map<int,int> mp;\\n         int count=0,j=0;\\n         for(int i=0;i<nums.size();i++){\\n             mp[nums[i]]++;\\n             while(mp.size()>k){\\n                 if(mp[nums[j]]==1)mp.erase(nums[j]);\\n                 else mp[nums[j]]--;\\n\\n                 j++;\\n             }\\n             count+= i-j+1;\\n         }\\n         return count;\\n     }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmost(k,nums)-atmost(k-1,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int atmost(int k,vector<int>& nums){\\n         unordered_map<int,int> mp;\\n         int count=0,j=0;\\n         for(int i=0;i<nums.size();i++){\\n             mp[nums[i]]++;\\n             while(mp.size()>k){\\n                 if(mp[nums[j]]==1)mp.erase(nums[j]);\\n                 else mp[nums[j]]--;\\n\\n                 j++;\\n             }\\n             count+= i-j+1;\\n         }\\n         return count;\\n     }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmost(k,nums)-atmost(k-1,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475570,
                "title": "sliding-window-hashmap-two-pointer-with-details-python",
                "content": "This problem with involve knowledge from hashmap, two pointers, and sliding window.\\n\\nIt is hard to compute directly the subarray with **exactly** `k` different integers, but it will be easier to count the number of subarrays with **at most** `k` different integers. \\n\\nWe will introduce a new subarray to help us:\\n* **Nice subarray** is an array where the number of different integers in that array is **at most** `k`\\n\\nAfter we get the number of nice subarrays, we can get the number of good arrays using the difference of nice subarrays for `k` and `k-1`.\\ne.g. # of subarrays with exactly 3 different integers = # of subarrays with at most 3 different integers - # of subarrays with at most 2 different integers.\\n\\n# **Here is the idea:**\\n1. We need two pointers as the left and right part of our sliding window.\\n2. If the right pointer is pointing to a value that exists in the hashmap, this means that we can expand the width of our sliding window. \\n3. Then we need to check if the hashmap is containing too many elements (exceed k). If so, we need to shrink our sliding window by deleting the first element inside it, which is `nums[left]`.\\n4. Add the number of nice subarrays we get in the above steps.\\n\\n**Let\\'s start with a step-by-step example:**\\n```\\nnums = [1, 3, 1, 4]\\nk = 2\\noutput (good subarrays) = 4\\n```\\n\\n* **Step 1:** \\n\\t* left = 0, right = 0\\n\\t* hashmap = {1 : 1}\\n\\t* Nice subarrays = 1\\n`[1]`\\n\\n* **Step 2:**\\n\\t* left = 0, right = 1\\n\\t* hashmap = {1 : 1, 3 : 1}\\n\\t* Nice subarrays = 2 + 1 = 3\\n`[1], [3], [1,3]`\\n\\n* **Step 3:**\\n\\t* left = 0, right = 2\\n\\t* hashmap = {1 : 2, 3 : 1}\\n\\t* Nice subarrays = 3 + 3 = 6\\n`[1], [3], [1,3], [1], [1,3,1], [3,1]`\\n\\n* **Step 4:**\\n\\t* left = 0, right = 3\\n\\t* hashmap = {1: 2, 3 : 1, 4 : 1}\\n-> Note that The length of hashmap exceeds `k`! So we need to delete the first element in our sliding window\\n\\n* **Step 5:**\\n\\t* left = 1, right = 3\\n\\t* hashmap = {1 : 1, 3 : 1, 4 : 1}\\n\\tThe length of hashmap still exceed `k`, so we will shrink our sliding window one more times\\n\\t\\n* **Step 6:**\\n\\t* left = 2, right = 3\\n\\t* hashmap = {1 : 1, 4: 1}\\n\\t* Nice subarrays = 2 + 6 = 8\\n\\t`[1], [3], [1,3], [1], [1,3,1], [3,1], [1,4], [4]`\\n\\t\\nWe can see that for `k = 2`, the number of nice subarrays will be 8. If `k = 1`, we can easily see that the number of it will be 4. So the number of good subarrays (output) will be 8 - 4 = 4.\\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \\n        def atMostKDistinct(nums, k):\\n            niceSubarray = 0\\n            hashmap = {}\\n            left, right = 0, 0\\n            \\n            while right < len(nums):\\n                if nums[right] in hashmap:\\n                    hashmap[nums[right]] += 1\\n                else:\\n                    hashmap[nums[right]] = 1\\n            \\n                while len(hashmap) > k:\\n                    hashmap[nums[left]] -= 1\\n                    if hashmap[nums[left]] == 0:\\n                        del hashmap[nums[left]]\\n                    left += 1\\n                \\n                niceSubarray += right - left + 1\\n                right += 1\\n                \\n            return niceSubarray\\n        \\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nnums = [1, 3, 1, 4]\\nk = 2\\noutput (good subarrays) = 4\\n```\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \\n        def atMostKDistinct(nums, k):\\n            niceSubarray = 0\\n            hashmap = {}\\n            left, right = 0, 0\\n            \\n            while right < len(nums):\\n                if nums[right] in hashmap:\\n                    hashmap[nums[right]] += 1\\n                else:\\n                    hashmap[nums[right]] = 1\\n            \\n                while len(hashmap) > k:\\n                    hashmap[nums[left]] -= 1\\n                    if hashmap[nums[left]] == 0:\\n                        del hashmap[nums[left]]\\n                    left += 1\\n                \\n                niceSubarray += right - left + 1\\n                right += 1\\n                \\n            return niceSubarray\\n        \\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044509,
                "title": "simple-java-solution-using-sliding-window-easy-to-understand",
                "content": "Please upvote, if you find it useful :) \\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] arr, int k) {\\n        return solution(arr,k) - solution(arr, k - 1);\\n    }\\n    \\n    public int solution(int[] arr, int K) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tint j = 0;\\n\\t\\tint ans = 0;\\n\\t\\tint i = 0;\\n\\t\\tfor(i = 0; i < arr.length; i++) {\\n\\t\\t\\tmap.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n\\n\\t\\t\\t\\twhile(map.size() > K) {\\n\\t\\t\\t\\t\\tif(map.get(arr[j]) > 1) {\\n\\t\\t\\t\\t\\t\\tmap.put(arr[j], map.get(arr[j]) - 1);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmap.remove(arr[j]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tj += 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans += (i-j) + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] arr, int k) {\\n        return solution(arr,k) - solution(arr, k - 1);\\n    }\\n    \\n    public int solution(int[] arr, int K) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tint j = 0;\\n\\t\\tint ans = 0;\\n\\t\\tint i = 0;\\n\\t\\tfor(i = 0; i < arr.length; i++) {\\n\\t\\t\\tmap.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n\\n\\t\\t\\t\\twhile(map.size() > K) {\\n\\t\\t\\t\\t\\tif(map.get(arr[j]) > 1) {\\n\\t\\t\\t\\t\\t\\tmap.put(arr[j], map.get(arr[j]) - 1);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmap.remove(arr[j]);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tj += 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans += (i-j) + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801444,
                "title": "java-solution-with-explanation",
                "content": "```\\n//This is really good question.\\n//here the logic is to get all subarrays of size K then get all subarrays of size k-1 the return the ans as no of Subarrays(k)-no of subarrays(k-1) this is the number of arrays with exact k distinct elements.\\n\\n\\nclass Solution {\\n     public int subarraysWithKDistinct(int[] nums, int k) {\\n         \\n         \\n      return subarraysWithKSize(nums,k)-subarraysWithKSize(nums,k-1);   \\n     }\\n      public int subarraysWithKSize(int[] nums, int k) {\\n\\t       HashMap<Integer,Integer> hs=new HashMap<>();\\n\\t     int count=0;\\n\\t        int i=0;\\n\\t        int j=0;\\n\\t        while(j<nums.length){\\n                  hs.put(nums[j],hs.getOrDefault(nums[j],0)+1);\\n              \\n\\t            \\n\\t           \\n\\t           while(hs.size()==k+1){ //while(hs.size()>k){ this is taking more time\\n\\t              hs.put(nums[i],hs.get(nums[i])-1);\\n\\t                  if(hs.get(nums[i])==0)\\n\\t                     hs.remove(nums[i]);\\n\\t                i++;\\n\\t                \\n\\t            }\\n                \\n                count+=j-i+1;\\n                j++;\\n\\n\\t        }\\n\\t        \\n\\t        \\n\\t        return count;\\n\\t        \\n\\t    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n//This is really good question.\\n//here the logic is to get all subarrays of size K then get all subarrays of size k-1 the return the ans as no of Subarrays(k)-no of subarrays(k-1) this is the number of arrays with exact k distinct elements.\\n\\n\\nclass Solution {\\n     public int subarraysWithKDistinct(int[] nums, int k) {\\n         \\n         \\n      return subarraysWithKSize(nums,k)-subarraysWithKSize(nums,k-1);   \\n     }\\n      public int subarraysWithKSize(int[] nums, int k) {\\n\\t       HashMap<Integer,Integer> hs=new HashMap<>();\\n\\t     int count=0;\\n\\t        int i=0;\\n\\t        int j=0;\\n\\t        while(j<nums.length){\\n                  hs.put(nums[j],hs.getOrDefault(nums[j],0)+1);\\n              \\n\\t            \\n\\t           \\n\\t           while(hs.size()==k+1){ //while(hs.size()>k){ this is taking more time\\n\\t              hs.put(nums[i],hs.get(nums[i])-1);\\n\\t                  if(hs.get(nums[i])==0)\\n\\t                     hs.remove(nums[i]);\\n\\t                i++;\\n\\t                \\n\\t            }\\n                \\n                count+=j-i+1;\\n                j++;\\n\\n\\t        }\\n\\t        \\n\\t        \\n\\t        return count;\\n\\t        \\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234590,
                "title": "java-sliding-window-with-indices-queue",
                "content": "Maintain sliding window within `i` and `j`. (`j` not included)\\n`indices` maintains all the indices for each value in the sliding window.\\n`minEnd` is the minimum end index of possible valid subarrays within current sliding window.\\nUpdate `minEnd` while `i` or `j` is moving. For example:\\n```\\n[1, 2, 1, 2, 3]    K = 2\\n i           j\\nindices: {\\n\\t1: [0, 2]\\n\\t2: [1, 3]\\n}\\nminEnd: 1\\nresult += j - minEnd = 3\\n\\n------\\n\\n[1, 2, 1, 2, 3]    K = 2\\n    i        j\\nindices: {\\n\\t1: [2]\\n\\t2: [1, 3]\\n}\\nminEnd: 2\\nresult += j - minEnd = 3 + 2 = 5\\n\\n------\\n\\n[1, 2, 1, 2, 3]    K = 2\\n       i     j\\nindices: {\\n\\t1: [2]\\n\\t2: [3]\\n}\\nminEnd: 3\\nresult += j - minEnd = 5 + 1 = 6\\n\\n......\\n```\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int result = 0, n = A.length, i = 0, j = 0, minEnd = -1;\\n        Map<Integer, Queue<Integer>> indices = new HashMap<>();\\n        while (j < n) {\\n            while (j < n) {\\n                if (!indices.containsKey(A[j])) {\\n                    if (indices.size() == K - 1) {\\n                        minEnd = j;\\n                    }\\n                    if (indices.size() == K) {\\n                        break;\\n                    }\\n                    indices.put(A[j], new LinkedList<>());\\n                }\\n                indices.get(A[j]).offer(j);\\n                j++;\\n            }\\n            if (j == n && indices.size() < K) {\\n                break;\\n            }\\n            while (i < j) {\\n                int cur = A[i++];\\n                result += j - minEnd;\\n                indices.get(cur).poll();\\n                if (indices.get(cur).isEmpty()) {\\n                    indices.remove(cur);\\n                    break;\\n                }\\n                minEnd = Math.max(minEnd, indices.get(cur).peek());\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\n[1, 2, 1, 2, 3]    K = 2\\n i           j\\nindices: {\\n\\t1: [0, 2]\\n\\t2: [1, 3]\\n}\\nminEnd: 1\\nresult += j - minEnd = 3\\n\\n------\\n\\n[1, 2, 1, 2, 3]    K = 2\\n    i        j\\nindices: {\\n\\t1: [2]\\n\\t2: [1, 3]\\n}\\nminEnd: 2\\nresult += j - minEnd = 3 + 2 = 5\\n\\n------\\n\\n[1, 2, 1, 2, 3]    K = 2\\n       i     j\\nindices: {\\n\\t1: [2]\\n\\t2: [3]\\n}\\nminEnd: 3\\nresult += j - minEnd = 5 + 1 = 6\\n\\n......\\n```\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int result = 0, n = A.length, i = 0, j = 0, minEnd = -1;\\n        Map<Integer, Queue<Integer>> indices = new HashMap<>();\\n        while (j < n) {\\n            while (j < n) {\\n                if (!indices.containsKey(A[j])) {\\n                    if (indices.size() == K - 1) {\\n                        minEnd = j;\\n                    }\\n                    if (indices.size() == K) {\\n                        break;\\n                    }\\n                    indices.put(A[j], new LinkedList<>());\\n                }\\n                indices.get(A[j]).offer(j);\\n                j++;\\n            }\\n            if (j == n && indices.size() < K) {\\n                break;\\n            }\\n            while (i < j) {\\n                int cur = A[i++];\\n                result += j - minEnd;\\n                indices.get(cur).poll();\\n                if (indices.get(cur).isEmpty()) {\\n                    indices.remove(cur);\\n                    break;\\n                }\\n                minEnd = Math.max(minEnd, indices.get(cur).peek());\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109740,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window And Unordered Map***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int count_at_most(vector<int>& nums, int k)\\n    {\\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int left = 0;\\n        \\n        int count = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            mp[nums[right]]++;\\n            \\n            while(mp.size() > k)\\n            {\\n                mp[nums[left]]--;\\n                \\n                if(mp[nums[left]] == 0)\\n                {\\n                    mp.erase(nums[left]);\\n                }\\n                \\n                left++;\\n            }\\n            \\n            int curr_count = right - left + 1;\\n            \\n            count += curr_count;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        \\n        int count_at_most_k = count_at_most(nums, k);\\n        \\n        int count_at_most_k_1 = count_at_most(nums, k - 1);\\n        \\n        int count_exactly_k = count_at_most_k - count_at_most_k_1;\\n        \\n        return count_exactly_k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count_at_most(vector<int>& nums, int k)\\n    {\\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int left = 0;\\n        \\n        int count = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            mp[nums[right]]++;\\n            \\n            while(mp.size() > k)\\n            {\\n                mp[nums[left]]--;\\n                \\n                if(mp[nums[left]] == 0)\\n                {\\n                    mp.erase(nums[left]);\\n                }\\n                \\n                left++;\\n            }\\n            \\n            int curr_count = right - left + 1;\\n            \\n            count += curr_count;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        \\n        int count_at_most_k = count_at_most(nums, k);\\n        \\n        int count_at_most_k_1 = count_at_most(nums, k - 1);\\n        \\n        int count_exactly_k = count_at_most_k - count_at_most_k_1;\\n        \\n        return count_exactly_k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915559,
                "title": "java-sliding-window-easy-consise",
                "content": "```\\nclass Solution {\\n    // number of subarrays with k diff integers = number of subarrays with at most k diff integers - number of subarrays with atmost k-1 diff integers\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return count(nums,k) - count(nums,k-1);\\n    }\\n    public int count(int[] nums,int k){\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int start = 0,end = 0, res = 0;\\n        while(end < nums.length){\\n            map.put(nums[end],map.getOrDefault(nums[end],0)+1);\\n            while(start <= end && map.size() > k){\\n                if(map.containsKey(nums[start])) map.put(nums[start],map.get(nums[start])-1);\\n                if(map.get(nums[start]) == 0) map.remove(nums[start]);\\n                start++;\\n            }\\n            res+= (end - start + 1);\\n            end++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // number of subarrays with k diff integers = number of subarrays with at most k diff integers - number of subarrays with atmost k-1 diff integers\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return count(nums,k) - count(nums,k-1);\\n    }\\n    public int count(int[] nums,int k){\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int start = 0,end = 0, res = 0;\\n        while(end < nums.length){\\n            map.put(nums[end],map.getOrDefault(nums[end],0)+1);\\n            while(start <= end && map.size() > k){\\n                if(map.containsKey(nums[start])) map.put(nums[start],map.get(nums[start])-1);\\n                if(map.get(nums[start]) == 0) map.remove(nums[start]);\\n                start++;\\n            }\\n            res+= (end - start + 1);\\n            end++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425309,
                "title": "c-easy-sol-using-sliding-window",
                "content": "**Approach:** we need exactly k elements so we need to remove less than k elements from (at most k elements)\\nIf the question had been return at most k size good array\\nwe don\\'t need to have to do this step of subtracting less than k elements\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        int i=0;\\n        int unique=0;//unique no till the current window\\n        int ans=0;\\n        for(int j=0; j<n; j++)\\n        {\\n            int curr = nums[j];\\n            if(mp.find(curr) == mp.end())\\n                unique++;\\n            \\n            mp[curr]++;\\n            \\n            while(unique > k)\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                {\\n                    mp.erase(nums[i]);\\n                    unique--;\\n                }\\n                \\n                i++;\\n            }\\n            ans += j-i+1;\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        return helper(nums,k) - helper(nums, k-1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        int i=0;\\n        int unique=0;//unique no till the current window\\n        int ans=0;\\n        for(int j=0; j<n; j++)\\n        {\\n            int curr = nums[j];\\n            if(mp.find(curr) == mp.end())\\n                unique++;\\n            \\n            mp[curr]++;\\n            \\n            while(unique > k)\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                {\\n                    mp.erase(nums[i]);\\n                    unique--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1314813,
                "title": "c-sliding-window",
                "content": "Again it makes it easier to count subarrays with maximum(at-most) `K` different elements rather than counting subarrays with exactly `K` different elements. Reason - we can keep incrementing our subarray count till we reach `K+1` different elements.\\nIf on the other hand we had to count exactly `K` different elements, our subarray count will increase only upon reaching `K` different elements and we will have to check if the next element in the array is different from the elements that we already have in our map, i.e. if it will change our count of different elements or not.\\n\\n`unordered_map` - to store frequency of elements. Its size tells us the number of different elements.\\n`j` - to add new elements\\n`i` - remove elements from map when the number of different elements exceeds `K`.\\n\\n```\\nint atMostKDistinct(vector<int>& arr, int k) {\\n        unordered_map<int, int> mp;\\n        int n = arr.size();\\n        int i=0, j=0;\\n        int count = 0;\\n        \\n        while(j < n) {\\n            mp[arr[j++]] += 1;\\n            while(mp.size() > k) {\\n                if(mp[arr[i]] == 1)\\n                    mp.erase(arr[i++]);\\n                else\\n                    mp[arr[i++]] -= 1;\\n            }\\n            count += j-i;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k-1);\\n    }\\n```\\n\\nNumber of subarrays in array of n elements = `n*(n+1)/2`\\n`count += j-i` takes care of that.\\nI \\'`erase`\\' the element from map when its frequency is 1, otherwise just decrement the frequency.\\n\\nExact `K` subarrays = (at-most `K` subarrays) - (at-most `K-1` subarrays).\\n\\nI hope my explanation was readable and understandable.",
                "solutionTags": [],
                "code": "```\\nint atMostKDistinct(vector<int>& arr, int k) {\\n        unordered_map<int, int> mp;\\n        int n = arr.size();\\n        int i=0, j=0;\\n        int count = 0;\\n        \\n        while(j < n) {\\n            mp[arr[j++]] += 1;\\n            while(mp.size() > k) {\\n                if(mp[arr[i]] == 1)\\n                    mp.erase(arr[i++]);\\n                else\\n                    mp[arr[i++]] -= 1;\\n            }\\n            count += j-i;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1215277,
                "title": "python-sliding-window-set-hashmap",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \\n        def window(nums, k):\\n            left = 0\\n            right = 0\\n\\n            res = 0\\n            in_set = set()\\n            hash_map = collections.Counter()\\n\\n            while right < len(nums):\\n                in_set.add(nums[right])\\n                hash_map[nums[right]] += 1\\n\\n                while len(in_set) > k:\\n                    hash_map[nums[left]] -= 1\\n                    if hash_map[nums[left]] == 0:\\n                        in_set.remove(nums[left])\\n                    left += 1\\n\\n                res += (right - left + 1)\\n\\n                right += 1\\n            return res\\n    \\n       return window(nums, k) - window(nums, k - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \\n        def window(nums, k):\\n            left = 0\\n            right = 0\\n\\n            res = 0\\n            in_set = set()\\n            hash_map = collections.Counter()\\n\\n            while right < len(nums):\\n                in_set.add(nums[right])\\n                hash_map[nums[right]] += 1\\n\\n                while len(in_set) > k:\\n                    hash_map[nums[left]] -= 1\\n                    if hash_map[nums[left]] == 0:\\n                        in_set.remove(nums[left])\\n                    left += 1\\n\\n                res += (right - left + 1)\\n\\n                right += 1\\n            return res\\n    \\n       return window(nums, k) - window(nums, k - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355187,
                "title": "java-two-pointer",
                "content": "To directly compute the subarray with K different nums is hard, but subarray with at most K different nums is easy.\\n\\nBy this idea, the rest effort is straight forward.\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atmost(A,K)-atmost(A,K-1);\\n    }\\n    \\n    int atmost(int[] arr, int k){\\n        int count=0, i=0, j=0, ret=0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (;j<arr.length;){\\n            if (map.getOrDefault(arr[j],0)==0) count++;\\n            map.put(arr[j],map.getOrDefault(arr[j],0)+1);\\n            while (count>k){\\n                map.put(arr[i],map.get(arr[i])-1);\\n                if (map.get(arr[i])==0) count--;\\n                i++;\\n            }\\n            ret += j-i+1;\\n            j++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atmost(A,K)-atmost(A,K-1);\\n    }\\n    \\n    int atmost(int[] arr, int k){\\n        int count=0, i=0, j=0, ret=0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (;j<arr.length;){\\n            if (map.getOrDefault(arr[j],0)==0) count++;\\n            map.put(arr[j],map.getOrDefault(arr[j],0)+1);\\n            while (count>k){\\n                map.put(arr[i],map.get(arr[i])-1);\\n                if (map.get(arr[i])==0) count--;\\n                i++;\\n            }\\n            ret += j-i+1;\\n            j++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350130,
                "title": "cpp-sliding-window-o-n-solution",
                "content": "Use a hashmap to store the frequency of each num, use a variable `cnt` to store the the number of different integers in the window. \\n1. Slide the right border `j` : If we meet a num with `hash[j] == 0, cnt += 1`. Find a sliding window with `k` different numbers . \\n2. Slide left border `i` if `hash[A[i]] > 1`, which means that there are more than one `A[i]` in the window. If we meet `hash[A[i]] == 1` we cannot slide `i`more. Now we can build subarrays which start from `the previous i(istart)` to `i` and ends with `j `, and each of them has k different  integers in it . That adds `i - istart + 1` to our final answer. \\n3. Move on with the right border `j`, there are two situations:\\n* If our `cnt` changes, we must move our left border `i` until `cnt == k` and reset `istart`.\\n* If our `cnt` still equals to `k`(which means `A[j]` eauals to some existing value in the window), the subarrays which start from `istart` to `i` and ends with new `j` will still work(no more different number is added). We just need to move the left border `i` since the right border `j` may have same number with the left border and we only need `one` number to maintain the window. If we cannot slide more(`hash[A[i]] == 1`) , update our answer.\\n\\nSince `1 <= A[i] <= A.length`, we can use a vector instead of hashmap.\\n**Complexity:**\\n* Time: O(N)\\n* Space: O(N)\\n\\n```\\nint subarraysWithKDistinct(vector<int>& A, int k) {\\n        int n = A.size(), ans = 0;\\n        //unordered_map<int, int> hash;\\n\\t\\tvector<int> hash(n + 1, 0);\\n        for(int i = 0, j = 0, cnt = 0, istart = 0; j < n; ++j) {\\n            if(hash[A[j]]++ == 0) cnt++;\\n            if(cnt < k) continue;\\n            while(cnt > k) {\\n                cnt -= (0 == --hash[A[i++]]);\\n                istart = i;\\n            } \\n            while(hash[A[i]] > 1) hash[A[i++]]--;\\n            ans += i - istart + 1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint subarraysWithKDistinct(vector<int>& A, int k) {\\n        int n = A.size(), ans = 0;\\n        //unordered_map<int, int> hash;\\n\\t\\tvector<int> hash(n + 1, 0);\\n        for(int i = 0, j = 0, cnt = 0, istart = 0; j < n; ++j) {\\n            if(hash[A[j]]++ == 0) cnt++;\\n            if(cnt < k) continue;\\n            while(cnt > k) {\\n                cnt -= (0 == --hash[A[i++]]);\\n                istart = i;\\n            } \\n            while(hash[A[i]] > 1) hash[A[i++]]--;\\n            ans += i - istart + 1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2952113,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def atmostk(self,n,k,nums):\\n        l=0\\n        r=0\\n        map=defaultdict(int)\\n        ans=0\\n        while r<n:\\n            map[nums[r]]+=1\\n            while len(map)>k:\\n                map[nums[l]]-=1\\n                if map[nums[l]]==0:\\n                    del map[nums[l]]\\n                l+=1\\n            \\n            ans+=r-l+1\\n            r+=1\\n        return ans\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atmostk(len(nums),k,nums)-self.atmostk(len(nums),k-1,nums)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def atmostk(self,n,k,nums):\\n        l=0\\n        r=0\\n        map=defaultdict(int)\\n        ans=0\\n        while r<n:\\n            map[nums[r]]+=1\\n            while len(map)>k:\\n                map[nums[l]]-=1\\n                if map[nums[l]]==0:\\n                    del map[nums[l]]\\n                l+=1\\n            \\n            ans+=r-l+1\\n            r+=1\\n        return ans\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atmostk(len(nums),k,nums)-self.atmostk(len(nums),k-1,nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253265,
                "title": "common-trick-for-counting-distinct-integers-o-n-sliding-window-solution",
                "content": "When I saw this problem, I immediately thought of this trick I had seen for [counting the number of distinct integers in a subarray](https://stackoverflow.com/a/53066384/3740708). The StackOverflow post does not explain the trick that well, but the trick that they use is, if the subarray ends at index M, then create an array `arr` where `arr[i] = 1` if `i` is the last index <= M in `nums` where `nums[i]` appears, and `arr[i] = 0` otherwise. Then, for any `0 <= j <= M`, the sum of the suffix of `arr` starting from index `j` is the number of distinct elements in the subarray from `j` to `M`. (The StackOverflow post also mentions segment trees, but you don\\'t need segment trees for this problem, you just need to know this trick.)\\n\\nFor me, prefix sums are easier to think about than suffix sums, so I flipped the trick around: If the subarray begins at L, then I created an array `arr` where `arr[i] = 1` if `i` is the *first* index >= L in `nums` where `nums[i]` appears and `arr[i] = 0` otherwise. Then, for any `L <= j < len(nums)`, the sum of the prefix of `arr` ending at index `j` is the number of distinct elements in the subarray from `L` to `j`.\\n\\nNow, we want to count the number of subarrays which have exactly `K` distinct elements. The way we will approach this problem is, for any `0 <= L < len(nums)`, we want to count the number of distinct subarrays that begin at index `L` which have exactly `K` distinct elements. Let\\'s say `arr` is set up as we defined it above. Then, for any `n`, let `f(n)` be the least index `j` of `arr` such that the sum of the prefix of `arr` ending at index `j` is `n`, or `len(nums)` if the sum of all of `arr` is < n. We will maintain two indexes: `lo`, which is `f(K)` and `hi`, which is `f(K+1)`. Then, for any index `lo <= j < hi`, the prefix sum of `arr` ending at `j` is exactly `K`, which means that the subarray from `L` to `j` has exactly `K` distinct elements. Therefore, the number of distinct subarrays that begin at index `L` which have exactly `K` distinct elements is `hi - lo`, so we just add `hi - lo` to our answer.\\n\\nFinally, how do we maintain the array `arr` as we increase `L` by 1 in our for loop from `L = 0` to `L < len(nums)`? Theoretically we should set `arr[L] = 0` but once we increase `L`, none of the elements with index <= L matter anymore, so we don\\'t need to worry about updating `arr[L]`. However, once we increase `L`, `L` is no longer the first index where  `arr[L]` appears anymore anymore, since we are no longer considering elements of index <= L. Therefore, we create an array `next` where `next[i]` is the index of the next occurrence of `nums[i]` in `nums` that happens after index `i` (or -1 if `i` is the last occurrence of `nums[i]` in `nums`). Then, when increasing L, we set `arr[next[L]] = 1`, since `next[L]` is the new first index where `nums[L]` appears. Finally, we update `lo` and `hi` appropriately, increasing the indices until the prefix sums ending at `lo` and `hi` are `K` and `K+1` again, respectively.\\n\\n```\\n# Return the least index j > idx such that arr[j] = 1,\\n# or return len(arr) if no such index exists\\ndef find_next_one(arr: List[int], idx: int) -> int:\\n    N = len(arr)\\n    while idx < N:\\n        idx += 1\\n        if idx == N or arr[idx] == 1:\\n            return idx\\n    return idx\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        # nxt[i] = least j > i such that nums[j] = nums[i], or -1 if i is the last occurrence of nums[i] in nums\\n        nxt = [-1 for _ in range(N)]\\n        # last_seen[n] = last index where n was seen in nums, or -1 if n hasn\\'t been seen before\\n        last_seen = [-1 for _ in range(N+1)]\\n        # arr[i] = 1 if i is the least index >= L where nums[i] appears in nums\\n        # Initially, L = 0\\n        arr = [0 for _ in range(N)]\\n        for i in range(N):\\n            if last_seen[nums[i]] != -1:\\n                # Update nxt, if possible\\n                nxt[last_seen[nums[i]]] = i\\n            else:\\n                # i is the first occurrence of nums[i] in nums, so update arr\\n                arr[i] = 1\\n            # We just saw nums[i], so update last_seen\\n            last_seen[nums[i]] = i\\n        \\n        # lo = least index such that sum from i=0 to lo of arr[i] = K, or N if no such index exists\\n        lo = -1\\n        pfx = 0\\n        while pfx < k:\\n            lo += 1\\n            if lo == N:\\n                break\\n            pfx += arr[lo]\\n        \\n        # hi = least index such that sum from i=0 to lo of arr[i] = K+1, or N if no such index exists\\n        # In other words, hi is the position of the next 1 in arr after lo\\n        hi = find_next_one(arr, lo)\\n        \\n        answer = 0\\n        for L in range(N):\\n            # Remember: Number of subarrays beginning at L with K distinct elements is hi-lo\\n            answer += hi-lo\\n            \\n            # Since we are going to increase L, theoreitcally, we set arr[L] = 0\\n            # This means prefix sums at lo and hi just decreased by 1,\\n            # so we need to update lo and hi\\n            need_to_update_lo = True\\n            need_to_update_hi = True\\n            if nxt[L] != -1:\\n                # Update arr, if possible\\n                arr[nxt[L]] = 1\\n                # If nxt[L] <= lo, then setting arr[nxt[L]] to 1 cancels out\\n                # setting arr[L] to 0, so the prefix sum at lo is still K\\n                # and we don\\'t need to update lo\\n                # Therefore, we only need to update lo if nxt[L] > lo\\n                need_to_update_lo = nxt[L] > lo\\n                # Same for hi\\n                need_to_update_hi = nxt[L] > hi\\n                    \\n            # If we need to update lo, it\\'s because setting arr[L] to 0\\n            # decreased the prefix sum of arr at lo by 1,\\n            # so to update lo, we just need to find the next 1 in arr that comes after lo\\n            if need_to_update_lo:\\n                lo = find_next_one(arr, lo)\\n            # Same for hi\\n            if need_to_update_hi:\\n                hi = find_next_one(arr, hi)\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n# Return the least index j > idx such that arr[j] = 1,\\n# or return len(arr) if no such index exists\\ndef find_next_one(arr: List[int], idx: int) -> int:\\n    N = len(arr)\\n    while idx < N:\\n        idx += 1\\n        if idx == N or arr[idx] == 1:\\n            return idx\\n    return idx\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        # nxt[i] = least j > i such that nums[j] = nums[i], or -1 if i is the last occurrence of nums[i] in nums\\n        nxt = [-1 for _ in range(N)]\\n        # last_seen[n] = last index where n was seen in nums, or -1 if n hasn\\'t been seen before\\n        last_seen = [-1 for _ in range(N+1)]\\n        # arr[i] = 1 if i is the least index >= L where nums[i] appears in nums\\n        # Initially, L = 0\\n        arr = [0 for _ in range(N)]\\n        for i in range(N):\\n            if last_seen[nums[i]] != -1:\\n                # Update nxt, if possible\\n                nxt[last_seen[nums[i]]] = i\\n            else:\\n                # i is the first occurrence of nums[i] in nums, so update arr\\n                arr[i] = 1\\n            # We just saw nums[i], so update last_seen\\n            last_seen[nums[i]] = i\\n        \\n        # lo = least index such that sum from i=0 to lo of arr[i] = K, or N if no such index exists\\n        lo = -1\\n        pfx = 0\\n        while pfx < k:\\n            lo += 1\\n            if lo == N:\\n                break\\n            pfx += arr[lo]\\n        \\n        # hi = least index such that sum from i=0 to lo of arr[i] = K+1, or N if no such index exists\\n        # In other words, hi is the position of the next 1 in arr after lo\\n        hi = find_next_one(arr, lo)\\n        \\n        answer = 0\\n        for L in range(N):\\n            # Remember: Number of subarrays beginning at L with K distinct elements is hi-lo\\n            answer += hi-lo\\n            \\n            # Since we are going to increase L, theoreitcally, we set arr[L] = 0\\n            # This means prefix sums at lo and hi just decreased by 1,\\n            # so we need to update lo and hi\\n            need_to_update_lo = True\\n            need_to_update_hi = True\\n            if nxt[L] != -1:\\n                # Update arr, if possible\\n                arr[nxt[L]] = 1\\n                # If nxt[L] <= lo, then setting arr[nxt[L]] to 1 cancels out\\n                # setting arr[L] to 0, so the prefix sum at lo is still K\\n                # and we don\\'t need to update lo\\n                # Therefore, we only need to update lo if nxt[L] > lo\\n                need_to_update_lo = nxt[L] > lo\\n                # Same for hi\\n                need_to_update_hi = nxt[L] > hi\\n                    \\n            # If we need to update lo, it\\'s because setting arr[L] to 0\\n            # decreased the prefix sum of arr at lo by 1,\\n            # so to update lo, we just need to find the next 1 in arr that comes after lo\\n            if need_to_update_lo:\\n                lo = find_next_one(arr, lo)\\n            # Same for hi\\n            if need_to_update_hi:\\n                hi = find_next_one(arr, hi)\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679902,
                "title": "c-map-sliding-window-two-pointers-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int n = (int)nums.size(), ans1 = 0, l = 0, ans2 = 0;\\n        map<int, int> mp;\\n        //Calculte Subarrays with distinct integers < k\\n        for(int r = 0; r < n; r++){\\n            mp[nums[r]]++;\\n            while(mp.size() >= k){\\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\\n                l++;\\n            }\\n            ans1 += (r - l + 1);\\n        }\\n        l = 0, mp.clear();\\n        //Calculate Subarrays with distinct integers <= k\\n        for(int r = 0; r < n; r++){\\n            mp[nums[r]]++;\\n            while(mp.size() > k){\\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\\n                l++;\\n            }\\n            ans2 += (r - l + 1);\\n        }\\n        // final ans  =  subarrays with <=k distinct integers - subarrays with < k distinct integers\\n        return ans2 - ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int n = (int)nums.size(), ans1 = 0, l = 0, ans2 = 0;\\n        map<int, int> mp;\\n        //Calculte Subarrays with distinct integers < k\\n        for(int r = 0; r < n; r++){\\n            mp[nums[r]]++;\\n            while(mp.size() >= k){\\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\\n                l++;\\n            }\\n            ans1 += (r - l + 1);\\n        }\\n        l = 0, mp.clear();\\n        //Calculate Subarrays with distinct integers <= k\\n        for(int r = 0; r < n; r++){\\n            mp[nums[r]]++;\\n            while(mp.size() > k){\\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\\n                l++;\\n            }\\n            ans2 += (r - l + 1);\\n        }\\n        // final ans  =  subarrays with <=k distinct integers - subarrays with < k distinct integers\\n        return ans2 - ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499830,
                "title": "c-sliding-window",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Sliding Window\\n\\nUse `[i, j)` as a sliding window to find the maximum window which contains no more than `K` unique elements.\\n\\nTo achieve this, we use a map `m` to store the last position of each number in the current window.\\n\\nWhen `m.size() > K`, we should move forward `i` to shrink the window until it become valid again.\\n\\nWhen `m.size() == K`, `[i, j)` is the maximum window we are looking for. \\n\\nWithin this maximum window `[i, j)`, there is a minimum window `[k, j)` containing no more than `K` unique elements. `k` is the minimal index in `m`.\\n\\nNow, the number of valid subarrays in this window is `k - i + 1`.\\n\\nSince `k` is monotonically increasing and must be no less than `i`, we can use `k` as a global pointer just like `i` and `j` so that the overall time complexity of moving `k` is `O(N)`.\\n\\nWhenever `m.size() == K`, we can move `k` forward until `m[A[k] - \\'0\\'] == k`, and add `k - i + 1` to the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/subarrays-with-k-different-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int ans = 0, i = 0, j = 0, k = 0, N = A.size();\\n        unordered_map<int, int> m;\\n        while (j < N) {\\n            m[A[j] - \\'0\\'] = j;\\n            ++j;\\n            while (m.size() > K) {\\n                int d = A[i++] - \\'0\\';\\n                if (m[d] < i) m.erase(d);\\n            }\\n            if (m.size() == K) {\\n                k = max(i, k);\\n                while (m[A[k] - \\'0\\'] != k) ++k;\\n                ans += k - i + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Shrinkable Sliding Window\\n\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\" which can help you solve all sliding window problems.\\n\\nWe can turn this problem into two find maximum sliding window problem: one is to find a window with at most `k` different integers, another is to find a window with at most `k - 1` different integers.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/subarrays-with-k-different-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(U) where U is the number of unique numbers in `A`\\nclass Solution {\\n    int atMost(vector<int> &A, int k) {\\n        int distinct = 0, i = 0, j = 0, N = A.size(), ans = 0;\\n        unordered_map<int, int> cnt;\\n        for (; j < N; ++j) {\\n            distinct += ++cnt[A[j]] == 1;\\n            while (distinct > k) distinct -= --cnt[A[i++]] == 0;\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/subarrays-with-k-different-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int ans = 0, i = 0, j = 0, k = 0, N = A.size();\\n        unordered_map<int, int> m;\\n        while (j < N) {\\n            m[A[j] - \\'0\\'] = j;\\n            ++j;\\n            while (m.size() > K) {\\n                int d = A[i++] - \\'0\\';\\n                if (m[d] < i) m.erase(d);\\n            }\\n            if (m.size() == K) {\\n                k = max(i, k);\\n                while (m[A[k] - \\'0\\'] != k) ++k;\\n                ans += k - i + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/subarrays-with-k-different-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(U) where U is the number of unique numbers in `A`\\nclass Solution {\\n    int atMost(vector<int> &A, int k) {\\n        int distinct = 0, i = 0, j = 0, N = A.size(), ans = 0;\\n        unordered_map<int, int> cnt;\\n        for (; j < N; ++j) {\\n            distinct += ++cnt[A[j]] == 1;\\n            while (distinct > k) distinct -= --cnt[A[i++]] == 0;\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219792,
                "title": "cpp-intitutive-sliding-window-unordered-map-short",
                "content": "Main idea is we can easly calculate number of different subarrays having at most k distant elements instead of exact k elements so we just exploite normal math atMostK( k ) - atMost( k-1 ).\\n```\\nclass Solution {\\npublic:\\n    int help(vector<int>&a , int k){\\n        if( k == 0){\\n            return 0;\\n        }\\n        unordered_map<int,int> map;\\n        int n = a.size();\\n        int j=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            map[a[i]]++;\\n            while(map.size() > k and j <= i){\\n                int p = map[a[j]]--;\\n                if(p == 1){\\n                    map.erase(a[j]);\\n                }\\n                j++;\\n            }\\n            ans += (i-j+1);\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        return help(a, k) - help(a,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(vector<int>&a , int k){\\n        if( k == 0){\\n            return 0;\\n        }\\n        unordered_map<int,int> map;\\n        int n = a.size();\\n        int j=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            map[a[i]]++;\\n            while(map.size() > k and j <= i){\\n                int p = map[a[j]]--;\\n                if(p == 1){\\n                    map.erase(a[j]);\\n                }\\n                j++;\\n            }\\n            ans += (i-j+1);\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        return help(a, k) - help(a,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167100,
                "title": "pretty-simple-sliding-window",
                "content": "Count the number of subarrays having at most k distinct integers and having at most k-1 distinct integers. Once you have found those just take the difference and you will have count of subarrays having exactly k distinct integers.\\n\\nThe problem is to find count of subarrays having atmost k distinct integers for which you can use slding window.\\n\\n```class Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        return self.countAtMostSubarrays(A, K) - self.countAtMostSubarrays(A, K-1)\\n    \\n    def countAtMostSubarrays(self, nums, k):\\n        answer = 0\\n        \\n        if not nums or k == 0:\\n            return answer\\n        \\n        memo = collections.defaultdict(lambda: 0)\\n        left = distinctCount = 0\\n        n = len(nums)\\n        \\n        for right in range(n):\\n            currentVal = nums[right]\\n            \\n            if currentVal not in memo:\\n                distinctCount += 1\\n                \\n            memo[currentVal] += 1\\n            \\n            while left < right and distinctCount > k:\\n                disVal = nums[left]\\n                left += 1\\n                \\n                memo[disVal] -= 1\\n                \\n                if memo[disVal] == 0:\\n                    del memo[disVal]\\n                    distinctCount -= 1\\n                    \\n            answer += right - left + 1\\n            \\n        return answer\\n        \\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        return self.countAtMostSubarrays(A, K) - self.countAtMostSubarrays(A, K-1)\\n    \\n    def countAtMostSubarrays(self, nums, k):\\n        answer = 0\\n        \\n        if not nums or k == 0:\\n            return answer\\n        \\n        memo = collections.defaultdict(lambda: 0)\\n        left = distinctCount = 0\\n        n = len(nums)\\n        \\n        for right in range(n):\\n            currentVal = nums[right]\\n            \\n            if currentVal not in memo:\\n                distinctCount += 1\\n                \\n            memo[currentVal] += 1\\n            \\n            while left < right and distinctCount > k:\\n                disVal = nums[left]\\n                left += 1\\n                \\n                memo[disVal] -= 1\\n                \\n                if memo[disVal] == 0:\\n                    del memo[disVal]\\n                    distinctCount -= 1\\n                    \\n            answer += right - left + 1\\n            \\n        return answer\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043993,
                "title": "java-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        \\n    \\n        return solve(A, K) - solve(A, K-1);    \\n    }\\n    \\n    public int solve(int[] A, int K){\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int ans=0;\\n        int n = A.length;\\n        while(j<n)\\n        {\\n            int key = A[j];\\n            if(map.containsKey(key))\\n            {\\n                map.put(key,map.get(key)+1);\\n            }\\n            else\\n            {\\n                map.put(key,1);\\n            }\\n            \\n            \\n            if(map.size() < K)\\n            {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n            if(map.size()==K)\\n            {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n            if(map.size() > K)\\n            {\\n               while(map.size() > K)\\n               {\\n                     map.put(A[i],map.get(A[i])-1);\\n                       if(map.get(A[i])==0)\\n                       {\\n                           map.remove(A[i]);\\n                       }\\n                      i++;\\n                   \\n               }\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        \\n    \\n        return solve(A, K) - solve(A, K-1);    \\n    }\\n    \\n    public int solve(int[] A, int K){\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int ans=0;\\n        int n = A.length;\\n        while(j<n)\\n        {\\n            int key = A[j];\\n            if(map.containsKey(key))\\n            {\\n                map.put(key,map.get(key)+1);\\n            }\\n            else\\n            {\\n                map.put(key,1);\\n            }\\n            \\n            \\n            if(map.size() < K)\\n            {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n            if(map.size()==K)\\n            {\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n            if(map.size() > K)\\n            {\\n               while(map.size() > K)\\n               {\\n                     map.put(A[i],map.get(A[i])-1);\\n                       if(map.get(A[i])==0)\\n                       {\\n                           map.remove(A[i]);\\n                       }\\n                      i++;\\n                   \\n               }\\n                ans += j-i+1;\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734832,
                "title": "c-sliding-window-small-an-concise-soln-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int ans=0;\\n        int left=0;\\n        int right=0;\\n        unordered_map<int,int> umap;\\n        int cnt=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            \\n            //updating map\\n\\t\\t\\t\\n            if(umap.find(A[i])==umap.end() || umap[A[i]]==0) cnt++;\\n            umap[A[i]]++;\\n                \\n            \\n            //setting left most side for window\\n            \\n            if(cnt>K){\\n                umap[A[right]]--;\\n                cnt--;\\n                left=right+1;\\n                right=left;\\n                \\n            }\\n\\t\\t\\t\\n\\t\\t\\t//setting right most side of window and and adding possible number of solution to ans\\n\\t\\t\\t\\n            if(cnt==K){\\n                while(umap[A[right]]>1){\\n                    umap[A[right]]--;\\n                    right++;\\n                }\\n                ans=ans+(right-left+1);\\n                \\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int ans=0;\\n        int left=0;\\n        int right=0;\\n        unordered_map<int,int> umap;\\n        int cnt=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            \\n            //updating map\\n\\t\\t\\t\\n            if(umap.find(A[i])==umap.end() || umap[A[i]]==0) cnt++;\\n            umap[A[i]]++;\\n                \\n            \\n            //setting left most side for window\\n            \\n            if(cnt>K){\\n                umap[A[right]]--;\\n                cnt--;\\n                left=right+1;\\n                right=left;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 459766,
                "title": "c-o-n-dictionary-two-pointers",
                "content": "```\\n\\t\\tpublic int SubarraysWithKDistinct(int[] A, int K) {\\n            int res = 0;\\n            Dictionary<int, int> dict = new Dictionary<int, int>();\\n            int start = 0;\\n            int current = 0;\\n            for(int i = 0; i < A.Length; i++) {\\n                if(dict.ContainsKey(A[i])) {\\n                    dict[A[i]]++;\\n                } else {\\n                    dict[A[i]] = 1;\\n                }\\n                if(dict.Keys.Count >= K) {\\n                    while(dict[A[current]] > 1) {\\n                        dict[A[current++]]--;    \\n                    }\\n                    if (dict.Keys.Count == K) {\\n                        res += current - start + 1;\\n                    } else {\\n                        dict.Remove(A[current++]);\\n                        start = current;\\n                        dict[A[i]] = 0;\\n                        i--;\\n                    }\\n                } \\n            }\\n            return res;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic int SubarraysWithKDistinct(int[] A, int K) {\\n            int res = 0;\\n            Dictionary<int, int> dict = new Dictionary<int, int>();\\n            int start = 0;\\n            int current = 0;\\n            for(int i = 0; i < A.Length; i++) {\\n                if(dict.ContainsKey(A[i])) {\\n                    dict[A[i]]++;\\n                } else {\\n                    dict[A[i]] = 1;\\n                }\\n                if(dict.Keys.Count >= K) {\\n                    while(dict[A[current]] > 1) {\\n                        dict[A[current++]]--;    \\n                    }\\n                    if (dict.Keys.Count == K) {\\n                        res += current - start + 1;\\n                    } else {\\n                        dict.Remove(A[current++]);\\n                        start = current;\\n                        dict[A[i]] = 0;\\n                        i--;\\n                    }\\n                } \\n            }\\n            return res;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 264847,
                "title": "4-ms-21-line-java-solution-100-time-94-space",
                "content": "use byte countlist to save space.\\nwindow [i, j] is not satisfactory (k unique elements) at first.\\nvar good count satisfactory subarray.\\nafter [i, j] reach k unique elements, subsequent subarray always satisfy that:\\n\\tcount[arr[i]] == 1.\\n```\\nclass Solution {\\n  public int subarraysWithKDistinct(int[] arr, int k) {\\n    short[] count = new short[arr.length+1];\\n    short unique=0;\\n    int i=0, total=0, good=0;\\n    for(int j=0; j<arr.length; j++){\\n      if(count[arr[j]]++==0) unique++;\\n      if(unique>k){\\n        count[arr[i++]]--;\\n        unique--;\\n        good=0;\\n      }\\n      while(count[arr[i]]>1){\\n        count[arr[i++]]--;\\n        good++;\\n      }\\n      if(unique==k) total += good+1;\\n    }\\n    return total;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int subarraysWithKDistinct(int[] arr, int k) {\\n    short[] count = new short[arr.length+1];\\n    short unique=0;\\n    int i=0, total=0, good=0;\\n    for(int j=0; j<arr.length; j++){\\n      if(count[arr[j]]++==0) unique++;\\n      if(unique>k){\\n        count[arr[i++]]--;\\n        unique--;\\n        good=0;\\n      }\\n      while(count[arr[i]]>1){\\n        count[arr[i++]]--;\\n        good++;\\n      }\\n      if(unique==k) total += good+1;\\n    }\\n    return total;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234775,
                "title": "short-python-two-pointers-o-k-space",
                "content": "Explantion is same as Yaang\\'s in the comment section below\\n```\\nclass Solution(object):\\n    def subarraysWithKDistinct(self, A, K):\\n        s = collections.Counter() \\n        l = r = ans = 0 \\n        for i,num in enumerate(A):\\n            s[num] += 1\\n            if s[num] == 1 and len(s) == K:\\n                while r < len(A) and A[r] in s:\\n                    r += 1 \\n                while len(s) == K:\\n                    ans += r-i \\n                    s[A[l]] -= 1 \\n                    if s[A[l]] == 0: del s[A[l]] \\n                    l += 1 \\n        return ans",
                "solutionTags": [],
                "code": "Explantion is same as Yaang\\'s in the comment section below\\n```\\nclass Solution(object):\\n    def subarraysWithKDistinct(self, A, K):\\n        s = collections.Counter() \\n        l = r = ans = 0 \\n        for i,num in enumerate(A):\\n            s[num] += 1\\n            if s[num] == 1 and len(s) == K:\\n                while r < len(A) and A[r] in s:\\n                    r += 1 \\n                while len(s) == K:\\n                    ans += r-i \\n                    s[A[l]] -= 1 \\n                    if s[A[l]] == 0: del s[A[l]] \\n                    l += 1 \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 234480,
                "title": "java-o-n-2-short-and-easy-understanding",
                "content": "A better implementation should be using sliding window whose time complexity is O(N). However, the bruteforce way is very intuitive that could pass OJ so just share here.\\n\\nFor each subarray, check if there are K distinct intergers.\\n\\n```\\n    public int subarraysWithKDistinct(int[] A, int k) {\\n        int res = 0, n = A.length;\\n        int[] cnt = new int[n + 1]; // Given 1 <= A.length <= 20000 and 1 <= A[i] <= A.length\\n        \\n        for(int i = 0; i < n; i++) {\\n            int distCount = 0;\\n            Arrays.fill(cnt, 0);\\n            for(int j = i; j < n; j++) {\\n                if(cnt[A[j]] == 0) distCount++;\\n                cnt[A[j]]++;\\n                if(distCount == k) res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int subarraysWithKDistinct(int[] A, int k) {\\n        int res = 0, n = A.length;\\n        int[] cnt = new int[n + 1]; // Given 1 <= A.length <= 20000 and 1 <= A[i] <= A.length\\n        \\n        for(int i = 0; i < n; i++) {\\n            int distCount = 0;\\n            Arrays.fill(cnt, 0);\\n            for(int j = i; j < n; j++) {\\n                if(cnt[A[j]] == 0) distCount++;\\n                cnt[A[j]]++;\\n                if(distCount == k) res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3698818,
                "title": "solving-the-problem-using-it-s-easier-version-easy-to-understand-sliding-window-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExactly k distinct integers means : **Atmost (k) distinct integers - Atmost (k - 1)** distinct integers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I have used sliding window combined with two pointers approach.\\n1. **Fix a pointer \\'j\\'** at the beginning of the array and **traverse the array using \\'i\\'** and keep on storing the elements in the map, till the size of the map does not exceeds (k).\\n2. As it exceeds k, start deleting the elements from the beginning of the array using the j pointer and after deleting the elements increment the j pointer.\\n3. Each time calculate the distinct subarrays in the sliding window and add it to our answer.\\n4. By performing this algorithm once, **we\\'ll get subarrays with atmost k elements.**\\n5. **Perform same algorithm for atmost k - 1 elements and subtract the latter from the first part.**\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTraversing the array.\\n\\n- Space complexity: **O(k)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSize of the map will never exceed k.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int atmost(vector<int> nums, int k)\\n    {\\n        int n = nums.size();\\n\\n        int i = 0, j = 0;\\n        int cnt = 0;\\n\\n        map<int,int> mp;\\n\\n        while(i < n)\\n        {\\n            mp[nums[i]]++;\\n\\n            while(mp.size() > k)\\n            {\\n                auto it = mp.find(nums[j]);\\n                it -> second--;\\n\\n                if(it -> second == 0) mp.erase(it);\\n                j++;\\n            }\\n            cnt += (i - j + 1);\\n            i++;\\n        }\\n\\n        return cnt;\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmost(nums, k) - atmost(nums, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int atmost(vector<int> nums, int k)\\n    {\\n        int n = nums.size();\\n\\n        int i = 0, j = 0;\\n        int cnt = 0;\\n\\n        map<int,int> mp;\\n\\n        while(i < n)\\n        {\\n            mp[nums[i]]++;\\n\\n            while(mp.size() > k)\\n            {\\n                auto it = mp.find(nums[j]);\\n                it -> second--;\\n\\n                if(it -> second == 0) mp.erase(it);\\n                j++;\\n            }\\n            cnt += (i - j + 1);\\n            i++;\\n        }\\n\\n        return cnt;\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmost(nums, k) - atmost(nums, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330335,
                "title": "easy-java-solution-using-sliding-window",
                "content": "class Solution {\\n    \\n    private int countAtmost(int nums[], int k)\\n    {\\n        int count=0;\\n        HashMap<Integer, Integer> map=new HashMap<>();\\n        int i=0, j=0;\\n        while(j<nums.length)\\n        {\\n            map.put(nums[j], map.getOrDefault(nums[j], 0)+1);\\n            while(map.size()>k)\\n            {\\n                map.put(nums[i], map.getOrDefault(nums[i], 0)-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++;\\n            }\\n            count+=j-i+1;\\n            j++;\\n        }\\n        return count;\\n    }\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return countAtmost(nums, k) - countAtmost(nums, k-1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    \\n    private int countAtmost(int nums[], int k)\\n    {\\n        int count=0;\\n        HashMap<Integer, Integer> map=new HashMap<>();\\n        int i=0, j=0;\\n        while(j<nums.length)\\n        {\\n            map.put(nums[j], map.getOrDefault(nums[j], 0)+1);\\n            while(map.size()>k)\\n            {\\n                map.put(nums[i], map.getOrDefault(nums[i], 0)-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2158402,
                "title": "lol-first-hard-question-done-by-myself-so-happy",
                "content": "```\\nclass Solution {\\npublic:\\n  int solve(vector<int>&nums,int k)\\n  {\\n    int n=nums.size();\\n     int i=0;\\n     int j=0;\\n      int cnt=0;\\n     map<int,int>mp;\\n     while(j<n)\\n     {\\n       mp[nums[j]]++;\\n       while(i<n && mp.size()>k)\\n       {\\n         mp[nums[i]]--;\\n         if(mp[nums[i]]==0)\\n         {\\n           mp.erase(nums[i]);\\n         }\\n         i++;\\n       }\\n       cnt+=(j-i+1);\\n       j++;\\n     }\\n      return cnt;\\n  }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n     return solve(nums,k)-solve(nums,k-1);// first i counted k and less than k  no integer and then i //counted k-1 and less than k-1; And to get exactly k we need to subtract \\n\\t\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int solve(vector<int>&nums,int k)\\n  {\\n    int n=nums.size();\\n     int i=0;\\n     int j=0;\\n      int cnt=0;\\n     map<int,int>mp;\\n     while(j<n)\\n     {\\n       mp[nums[j]]++;\\n       while(i<n && mp.size()>k)\\n       {\\n         mp[nums[i]]--;\\n         if(mp[nums[i]]==0)\\n         {\\n           mp.erase(nums[i]);\\n         }\\n         i++;\\n       }\\n       cnt+=(j-i+1);\\n       j++;\\n     }\\n      return cnt;\\n  }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n     return solve(nums,k)-solve(nums,k-1);// first i counted k and less than k  no integer and then i //counted k-1 and less than k-1; And to get exactly k we need to subtract \\n\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988735,
                "title": "python-sol-faster-than-99-59-simple-explained-sliding-window-linear-time",
                "content": "# TIME AND SPACE USED\\nRuntime: 378 ms, faster than 99.59% of Python3 online submissions for Subarrays with K Different Integers.\\nMemory Usage: 16.6 MB, less than 85.54% of Python3 online submissions for Subarrays with K Different Integers.\\n\\n# EXPLANATION\\n```\\nWe are going to use sliding window\\n\\nIn sliding window we keep a window which satisfies the problem\\n\\nso we are going to keep a subarry in which there will at exactly k unique integers\\n\\nNow since we have got our subarray say [ 1 , 2 ,1 , 2 , 3 ] and say k = 3\\nMy subarray window satisfies the problem\\nNow the next step is to try to shrink the window from left\\nWhat if I remove 1 [  2 , 1 , 2 ,3 ] still have 3 unique int\\nWhat if I remove 2 [ 1 , 2  , 3 ] still have 3 unique int\\n\\nSo how does this works exactly ??\\n\\nSee when I am removing 1 from start I know that it is not the latest occurence of 1 i.e. 1 occured after that index which means even if I remove this one I still have 1 in my sliding window somewhere\\n\\nWhat If I remove 1 [ 2, 3] will have only 2 unique int\\nThis time this 1 was the latest occurence of 1 so when we removed this 1 we lost 1 in sliding window \\n\\nSo this gives the Idea to store latest of occurence of every int\\n\\nNow when we get sliding window with more than k unique int:\\n   We start removing from left and will remove until we remove all occurence of any integer\\n   specifically saying when latest[nums[index_start]] = index_start\\n   \\n   \\n\\n```\\n# IMAGE\\n![image](https://assets.leetcode.com/users/images/0aa4fcae-07fe-4cf9-89ba-f62fa4baec0c_1651141645.2300825.png)\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(nums)\\n        latest = {}\\n        unique = 0\\n        prev = 0\\n        for i in range(n):\\n            if nums[i] not in latest:\\n                unique += 1\\n            latest[nums[i]] = i\\n            if unique > k :\\n                while True:\\n                    if latest[nums[prev]] == prev:\\n                        latest.pop(nums[prev])\\n                        prev += 1\\n                        unique -= 1                        \\n                        break\\n                    else:\\n                        prev += 1\\n                        \\n            if unique == k:\\n                ans += 1\\n                tmp = prev\\n                while True:\\n                    if latest[nums[tmp]] != tmp:\\n                        ans += 1\\n                        tmp += 1\\n                    else:\\n                        break\\n        return ans\\n                \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nWe are going to use sliding window\\n\\nIn sliding window we keep a window which satisfies the problem\\n\\nso we are going to keep a subarry in which there will at exactly k unique integers\\n\\nNow since we have got our subarray say [ 1 , 2 ,1 , 2 , 3 ] and say k = 3\\nMy subarray window satisfies the problem\\nNow the next step is to try to shrink the window from left\\nWhat if I remove 1 [  2 , 1 , 2 ,3 ] still have 3 unique int\\nWhat if I remove 2 [ 1 , 2  , 3 ] still have 3 unique int\\n\\nSo how does this works exactly ??\\n\\nSee when I am removing 1 from start I know that it is not the latest occurence of 1 i.e. 1 occured after that index which means even if I remove this one I still have 1 in my sliding window somewhere\\n\\nWhat If I remove 1 [ 2, 3] will have only 2 unique int\\nThis time this 1 was the latest occurence of 1 so when we removed this 1 we lost 1 in sliding window \\n\\nSo this gives the Idea to store latest of occurence of every int\\n\\nNow when we get sliding window with more than k unique int:\\n   We start removing from left and will remove until we remove all occurence of any integer\\n   specifically saying when latest[nums[index_start]] = index_start\\n   \\n   \\n\\n```\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(nums)\\n        latest = {}\\n        unique = 0\\n        prev = 0\\n        for i in range(n):\\n            if nums[i] not in latest:\\n                unique += 1\\n            latest[nums[i]] = i\\n            if unique > k :\\n                while True:\\n                    if latest[nums[prev]] == prev:\\n                        latest.pop(nums[prev])\\n                        prev += 1\\n                        unique -= 1                        \\n                        break\\n                    else:\\n                        prev += 1\\n                        \\n            if unique == k:\\n                ans += 1\\n                tmp = prev\\n                while True:\\n                    if latest[nums[tmp]] != tmp:\\n                        ans += 1\\n                        tmp += 1\\n                    else:\\n                        break\\n        return ans\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694376,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        def atMostK(nums, k):\\n            n = len(nums)\\n            left, right = 0, 0\\n\\n            res = 0\\n\\n            from collections import Counter\\n            counter = Counter()\\n\\n            while right < n:\\n                counter[nums[right]] += 1\\n\\n                while len(counter) > k:\\n                    counter[nums[left]] -= 1\\n                    if counter[nums[left]] == 0:\\n                        del counter[nums[left]]\\n\\n                    left += 1\\n\\n                res += right - left + 1\\n                right += 1\\n\\n            return res\\n        \\n        return atMostK(nums, k) - atMostK(nums, k-1)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ebe39cb4-4f95-4e57-8e4c-1bae25544113_1642332679.8178716.png)\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        def atMostK(nums, k):\\n            n = len(nums)\\n            left, right = 0, 0\\n\\n            res = 0\\n\\n            from collections import Counter\\n            counter = Counter()\\n\\n            while right < n:\\n                counter[nums[right]] += 1\\n\\n                while len(counter) > k:\\n                    counter[nums[left]] -= 1\\n                    if counter[nums[left]] == 0:\\n                        del counter[nums[left]]\\n\\n                    left += 1\\n\\n                res += right - left + 1\\n                right += 1\\n\\n            return res\\n        \\n        return atMostK(nums, k) - atMostK(nums, k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312352,
                "title": "c-992-subarrays-with-k-different-integers",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int ans = 0, ii = -1; \\n        unordered_map<int, int> freq; \\n        queue<int> q; \\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            freq[nums[i]]++; \\n            q.push(i); \\n            if (freq.size() > k) {\\n                ii = q.front(); q.pop(); \\n                freq.erase(nums[ii]); \\n            }\\n            \\n            while (freq[nums[q.front()]] > 1) {\\n                int k = q.front(); q.pop(); \\n                freq[nums[k]]--; \\n            }\\n            \\n            if (freq.size() == k) ans += q.front() - ii; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int ans = 0, ii = -1; \\n        unordered_map<int, int> freq; \\n        queue<int> q; \\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            freq[nums[i]]++; \\n            q.push(i); \\n            if (freq.size() > k) {\\n                ii = q.front(); q.pop(); \\n                freq.erase(nums[ii]); \\n            }\\n            \\n            while (freq[nums[q.front()]] > 1) {\\n                int k = q.front(); q.pop(); \\n                freq[nums[k]]--; \\n            }\\n            \\n            if (freq.size() == k) ans += q.front() - ii; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312341,
                "title": "python3-sliding-window-queue",
                "content": "\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = ii = 0 \\n        freq = defaultdict(int)\\n        queue = deque()\\n        for i, x in enumerate(nums): \\n            freq[x] += 1\\n            queue.append(i)\\n            if len(freq) > k: \\n                ii = queue[0]+1\\n                freq.pop(nums[queue.popleft()])\\n            while freq[nums[queue[0]]] > 1: freq[nums[queue.popleft()]] -= 1\\n            if len(freq) == k: ans += queue[0] - ii + 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = ii = 0 \\n        freq = defaultdict(int)\\n        queue = deque()\\n        for i, x in enumerate(nums): \\n            freq[x] += 1\\n            queue.append(i)\\n            if len(freq) > k: \\n                ii = queue[0]+1\\n                freq.pop(nums[queue.popleft()])\\n            while freq[nums[queue[0]]] > 1: freq[nums[queue.popleft()]] -= 1\\n            if len(freq) == k: ans += queue[0] - ii + 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090637,
                "title": "java-sliding-window-4ms-beats-98-o-a-length",
                "content": "\\n    // O(A.length) O(1)\\n\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\treturn subarraysWithKAtmost(A, K) - subarraysWithKAtmost(A, K - 1);\\n\\t}\\n\\n\\t// O(A.length) O(1)\\n\\tpublic int subarraysWithKAtmost(int[] A, int K) {\\n\\n\\t\\tint count = 0, ptr1 = 0, ptr2 = 0, len = A.length, ans = 0;\\n\\t\\tint[] freq = new int[20001];\\n\\n\\t\\twhile (ptr1 < len) {\\n\\n\\t\\t\\twhile (ptr1 < len && count <= K) {\\n\\t\\t\\t\\tint num = A[ptr1];\\n\\t\\t\\t\\tif (freq[num] == 0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tfreq[num]++;\\n\\t\\t\\t\\tptr1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (count == K + 1) {\\n\\t\\t\\t\\tans += (ptr1 - ptr2 - 1);\\n\\t\\t\\t\\tint num = A[ptr2];\\n\\t\\t\\t\\tfreq[num]--;\\n\\t\\t\\t\\tptr2++;\\n\\t\\t\\t\\tif (freq[num] == 0)\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tint n = ptr1 - ptr2;\\n\\t\\tans += (n * (n + 1) / 2);\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(A.length) O(1)\\n\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\treturn subarraysWithKAtmost(A, K) - subarraysWithKAtmost(A, K - 1);\\n\\t}\\n\\n\\t// O(A.length) O(1)\\n\\tpublic int subarraysWithKAtmost(int[] A, int K) {\\n\\n\\t\\tint count = 0, ptr1 = 0, ptr2 = 0, len = A.length, ans = 0;\\n\\t\\tint[] freq = new int[20001];\\n\\n\\t\\twhile (ptr1 < len) {\\n\\n\\t\\t\\twhile (ptr1 < len && count <= K) {\\n\\t\\t\\t\\tint num = A[ptr1];\\n\\t\\t\\t\\tif (freq[num] == 0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tfreq[num]++;\\n\\t\\t\\t\\tptr1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (count == K + 1) {\\n\\t\\t\\t\\tans += (ptr1 - ptr2 - 1);\\n\\t\\t\\t\\tint num = A[ptr2];\\n\\t\\t\\t\\tfreq[num]--;\\n\\t\\t\\t\\tptr2++;\\n\\t\\t\\t\\tif (freq[num] == 0)\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tint n = ptr1 - ptr2;\\n\\t\\tans += (n * (n + 1) / 2);\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1071174,
                "title": "lessons-learned",
                "content": "**Update**:\\n* After years of LC and now clearly understanding Vortubac approach ([this comment to be precise](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window/251836)), I realize this is a Hard question which shouldn\\'t be either asked in an interview or couldn\\'t be in solved in an intetview timeframe. Skipping this Q from my interview prep. But the Q teaches the concept of storing starting indices of other subarrays within the window (like prefix) during shrinking and expanding the sliding window. It is no more simply shrink and expand. This concept must be known.\\n\\n**Original**:\\n* This seems like an advanced variation of https://leetcode.com/problems/subarrays-with-k-different-integers/ . The differnce is here finding the start of valid subarrays is tricky and requires an auxillary array.\\n\\n```\\n// Incomplete\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        int ans = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int subarrayStart = 0;\\n        int prefix = 0;\\n        for (int windowStart = 0, windowEnd = 0; windowEnd < nums.length; ++windowEnd) {\\n            map.put(nums[windowEnd], map.getOrDefault(nums[windowEnd], 0) + 1);\\n            while (map.size() == k) {\\n                ++prefix;\\n                map.put(nums[windowStart], map.get(nums[windowStart]) - 1);\\n                if (map.get(nums[windowStart]) == 0) {\\n                    map.remove(nums[windowStart]);\\n                }\\n                ++windowStart;\\n            }\\n            ans += prefix;\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n// Incomplete\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        int ans = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int subarrayStart = 0;\\n        int prefix = 0;\\n        for (int windowStart = 0, windowEnd = 0; windowEnd < nums.length; ++windowEnd) {\\n            map.put(nums[windowEnd], map.getOrDefault(nums[windowEnd], 0) + 1);\\n            while (map.size() == k) {\\n                ++prefix;\\n                map.put(nums[windowStart], map.get(nums[windowStart]) - 1);\\n                if (map.get(nums[windowStart]) == 0) {\\n                    map.remove(nums[windowStart]);\\n                }\\n                ++windowStart;\\n            }\\n            ans += prefix;\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573196,
                "title": "a-java-based-sliding-window-solution-with-dry-run",
                "content": "1) As already mentioned in a number of other/older threads, the main idea is if we can calculate the number of subarrays with at most K different numbers and then subtract the number of subarrays with at most k-1 unique numbers then we get the answer - this is written in discussion forums\\n\\n2) So the main question how to do calculate the number of subarrays with at most N characters?\\n\\n3) We use sliding window to crate a window with at most N characters; for each of this window we calculate subarrays with at most N characters\\n\\n-------------------------------------------DRY RUN START ------------------------------------------\\nARRAY = [1,2,1,2,3] -- sliding windows with at most 2 unique characters and the subarrays which were not counted before are as follows:\\n\\nSliding-window   -->     Subarrays within sliding window (these are subarrays ending at right pointer)\\n\\n[1]              --> {1}\\n[1,2]            --> {1,2},{2}\\n[1,2,1]          --> {1,2,1},{2,1},{1} \\n[1,2,1,2]        --> {1,2,1,2}, {2,1,2},{1,2},{1} \\n[2,3]            --> {2,3},{3} \\n\\nThe total number of subarrays with at most 2 characters = number of subarrays in {} which is = 12\\n\\nARRAY = [1,2,1,2,3] -- sliding windows with at most 1 unique characters and the subarrays which were not counted before are as follows:\\n\\nSliding-window   -->     Subarrays within sliding window (these are subarrays ending at right pointer)\\n\\n[1]              --> {1}\\n[2]              --> {2}\\n[1]              --> {1} \\n[2]              --> {2} \\n[3]              --> {3} \\n\\nThe total number of subarrays with at most 1 characters = number of subarrays in {} which is = 5\\n\\nSo the Final answer is = 12 - 5 = 7\\n\\n-------------------------------------------DRY RUN END--------------------------------------------\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        //main intution \\n        return subarraysWithAtMostNDistinctNumbers(A,K) - subarraysWithAtMostNDistinctNumbers(A,K-1);\\n    }\\n    \\n    private int subarraysWithAtMostNDistinctNumbers(int[] A, int N) {\\n        \\n        int result = 0;\\n        int numberOfUniqueNumbersInCurrentSlidingWindow = 0;\\n        int left = 0;\\n        int right = 0;\\n        Map<Integer,Integer> slidingWindowCountMap = new HashMap<>();\\n        while(right < A.length) {\\n            int numAtRightIndex = A[right];\\n            slidingWindowCountMap.put(numAtRightIndex,slidingWindowCountMap.getOrDefault(numAtRightIndex,0)+1);\\n            \\n            while(slidingWindowCountMap.size() == N+1) {\\n                int numAtLeftIndex = A[left];\\n                int countOfNumAtLeftIndexInCurrentSlidingWindow = slidingWindowCountMap.get(numAtLeftIndex);\\n                \\n                //if the count is greaterThan 1 then we just decrement the count by 1\\n                //otherwise we remove it from the slidingWindowMap\\n                //We need to do this because our slidingWindowLogic is based on map size \\n                if(countOfNumAtLeftIndexInCurrentSlidingWindow > 1) {\\n                    slidingWindowCountMap.put(numAtLeftIndex,countOfNumAtLeftIndexInCurrentSlidingWindow-1);\\n                } else {\\n                    slidingWindowCountMap.remove(numAtLeftIndex);\\n                }\\n                left++;\\n            }\\n            \\n            //when we get here, right index has definitely moved away from last time we took the count\\n            //additionally left index cound have moved as well, if the inner while loop was run \\n            int numberOfSubArraysInCurrentSlidingWindowEndingAtRightIndex = right+1 - left;\\n            \\n            //Add the above number of unique subarrays to the final result \\n            result += numberOfSubArraysInCurrentSlidingWindowEndingAtRightIndex;\\n            right++;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        //main intution \\n        return subarraysWithAtMostNDistinctNumbers(A,K) - subarraysWithAtMostNDistinctNumbers(A,K-1);\\n    }\\n    \\n    private int subarraysWithAtMostNDistinctNumbers(int[] A, int N) {\\n        \\n        int result = 0;\\n        int numberOfUniqueNumbersInCurrentSlidingWindow = 0;\\n        int left = 0;\\n        int right = 0;\\n        Map<Integer,Integer> slidingWindowCountMap = new HashMap<>();\\n        while(right < A.length) {\\n            int numAtRightIndex = A[right];\\n            slidingWindowCountMap.put(numAtRightIndex,slidingWindowCountMap.getOrDefault(numAtRightIndex,0)+1);\\n            \\n            while(slidingWindowCountMap.size() == N+1) {\\n                int numAtLeftIndex = A[left];\\n                int countOfNumAtLeftIndexInCurrentSlidingWindow = slidingWindowCountMap.get(numAtLeftIndex);\\n                \\n                //if the count is greaterThan 1 then we just decrement the count by 1\\n                //otherwise we remove it from the slidingWindowMap\\n                //We need to do this because our slidingWindowLogic is based on map size \\n                if(countOfNumAtLeftIndexInCurrentSlidingWindow > 1) {\\n                    slidingWindowCountMap.put(numAtLeftIndex,countOfNumAtLeftIndexInCurrentSlidingWindow-1);\\n                } else {\\n                    slidingWindowCountMap.remove(numAtLeftIndex);\\n                }\\n                left++;\\n            }\\n            \\n            //when we get here, right index has definitely moved away from last time we took the count\\n            //additionally left index cound have moved as well, if the inner while loop was run \\n            int numberOfSubArraysInCurrentSlidingWindowEndingAtRightIndex = right+1 - left;\\n            \\n            //Add the above number of unique subarrays to the final result \\n            result += numberOfSubArraysInCurrentSlidingWindowEndingAtRightIndex;\\n            right++;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546964,
                "title": "javascript-solution-sliding-window",
                "content": "Having as a guide the solutions from here: [[Java/C++/Python] Sliding Window](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC++Python-Sliding-Window)\\n```\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar subarraysWithKDistinct = function(A, K) {\\n    return (atMostK(A, K) - atMostK(A, K - 1));\\n};\\n\\nfunction atMostK(A, K) {\\n      let count = {};\\n    let maxArr = 0, windowStart = 0;\\n\\n    for (let windowEnd = 0; windowEnd < A.length; windowEnd++) {\\n        const rightInt = A[windowEnd];\\n\\n        if (!(rightInt in count)) {\\n            count[rightInt] = 0;\\n        }\\n\\n        if (count[rightInt] === 0) {\\n            K -= 1;\\n        }\\n        count[rightInt] += 1;\\n\\n        while (K < 0) {\\n            const leftInt = A[windowStart];\\n            count[leftInt] -= 1;\\n            if (count[leftInt] === 0) {\\n                K += 1;\\n            }\\n            windowStart += 1;        }\\n        maxArr += windowEnd - windowStart + 1;\\n    }\\n\\n    return maxArr;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar subarraysWithKDistinct = function(A, K) {\\n    return (atMostK(A, K) - atMostK(A, K - 1));\\n};\\n\\nfunction atMostK(A, K) {\\n      let count = {};\\n    let maxArr = 0, windowStart = 0;\\n\\n    for (let windowEnd = 0; windowEnd < A.length; windowEnd++) {\\n        const rightInt = A[windowEnd];\\n\\n        if (!(rightInt in count)) {\\n            count[rightInt] = 0;\\n        }\\n\\n        if (count[rightInt] === 0) {\\n            K -= 1;\\n        }\\n        count[rightInt] += 1;\\n\\n        while (K < 0) {\\n            const leftInt = A[windowStart];\\n            count[leftInt] -= 1;\\n            if (count[leftInt] === 0) {\\n                K += 1;\\n            }\\n            windowStart += 1;        }\\n        maxArr += windowEnd - windowStart + 1;\\n    }\\n\\n    return maxArr;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536944,
                "title": "java-universal-format-sliding-window-and-reuse",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return helper(A, K) - helper(A, K - 1); //helper is num of subs at most k distinct\\n    }\\n    private int helper(int[] arr, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int cnt = 0, l = 0, res = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            int n = arr[i];\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            if (map.get(n) == 1) cnt++;\\n            while (cnt > k) {\\n                n = arr[l++];\\n                map.put(n, map.get(n) - 1);\\n                if (map.get(n) == 0) cnt--;\\n            }\\n            res += i - l;\\n        }\\n        return res;\\n    }\\n}\\n```\\nRef: https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235002/One-code-template-to-solve-all-of-these-problems!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return helper(A, K) - helper(A, K - 1); //helper is num of subs at most k distinct\\n    }\\n    private int helper(int[] arr, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int cnt = 0, l = 0, res = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            int n = arr[i];\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            if (map.get(n) == 1) cnt++;\\n            while (cnt > k) {\\n                n = arr[l++];\\n                map.put(n, map.get(n) - 1);\\n                if (map.get(n) == 0) cnt--;\\n            }\\n            res += i - l;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491173,
                "title": "simpler-version-of-official-solution-python",
                "content": "```\\nimport collections\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        ###O(n) sliding window solution\\n        \\n        ##for counting subarrays with at most K unique elements    \\n        c1 = collections.Counter()\\n        d1 = 0 #num_distinct_1\\n\\n        ##for counting subarrays with less than K unique elements\\n        c2 = collections.Counter()\\n        d2 = 0#num_distinct_2\\n        \\n        ans = 0\\n        left1 = left2 = 0\\n            \\n        for idx, num in enumerate(A):\\n            c1[num]+=1\\n            c2[num]+=1\\n            if c1[num]==1:\\n                d1+=1\\n            if c2[num]==1:\\n                d2+=1\\n                \\n            while d1>K:\\n                n = A[left1]\\n                c1[n]-=1\\n                if c1[n]==0:\\n                    d1-=1\\n                left1+=1\\n                \\n            while d2>=K:\\n                n = A[left2]\\n                c2[n]-=1\\n                if c2[n]==0:\\n                    d2-=1\\n                left2+=1\\n            \\n            ans += left2 - left1\\n        \\n        return ans\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        ###O(n) sliding window solution\\n        \\n        ##for counting subarrays with at most K unique elements    \\n        c1 = collections.Counter()\\n        d1 = 0 #num_distinct_1\\n\\n        ##for counting subarrays with less than K unique elements\\n        c2 = collections.Counter()\\n        d2 = 0#num_distinct_2\\n        \\n        ans = 0\\n        left1 = left2 = 0\\n            \\n        for idx, num in enumerate(A):\\n            c1[num]+=1\\n            c2[num]+=1\\n            if c1[num]==1:\\n                d1+=1\\n            if c2[num]==1:\\n                d2+=1\\n                \\n            while d1>K:\\n                n = A[left1]\\n                c1[n]-=1\\n                if c1[n]==0:\\n                    d1-=1\\n                left1+=1\\n                \\n            while d2>=K:\\n                n = A[left2]\\n                c2[n]-=1\\n                if c2[n]==0:\\n                    d2-=1\\n                left2+=1\\n            \\n            ans += left2 - left1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423782,
                "title": "python3-100-100",
                "content": "use hash map. \\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        i = k = 0\\n        ans = 0\\n        mMap = {}\\n        for j in range(n):\\n            if A[j] not in mMap:\\n                mMap[A[j]] = 1\\n            else:\\n                mMap[A[j]] += 1\\n            if len(mMap) < K:\\n                continue\\n            elif len(mMap) > K:\\n                del mMap[A[k]]\\n                i = k = k+1\\n            while mMap[A[k]] > 1:\\n                mMap[A[k]] -= 1\\n                k += 1\\n            ans += k - i + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        i = k = 0\\n        ans = 0\\n        mMap = {}\\n        for j in range(n):\\n            if A[j] not in mMap:\\n                mMap[A[j]] = 1\\n            else:\\n                mMap[A[j]] += 1\\n            if len(mMap) < K:\\n                continue\\n            elif len(mMap) > K:\\n                del mMap[A[k]]\\n                i = k = k+1\\n            while mMap[A[k]] > 1:\\n                mMap[A[k]] -= 1\\n                k += 1\\n            ans += k - i + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393225,
                "title": "java-solution-with-detailed-explaination",
                "content": "We can consider each index as start of the subarray and try to find all the possible end points.\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int size = A.length;\\n        int count = 0 ;\\n\\t\\t// stores the count of each integer appearing in the sliding window\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\t\\t// end points of window\\n        int l=0, r=0;\\n        while(true) {\\n\\t\\t\\t// let p be the index of 1st element such that no. of distinct elements in window [l, p] is K\\n\\t\\t\\t// run right pointer till you find p\\n            while(r<size && m.size()< K) {\\n                add(m, A[r]);\\n                r++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// return answer if we run out of elements\\n            if(m.size()!=K) return count;\\n            \\n\\t\\t\\t// At this point, r is one pointer ahead of p & we have K elements in the window [l, p]\\n\\t\\t\\t\\n\\t\\t\\tint temp = r-1;\\n\\t\\t\\t// Start from p and count for all indexes for which window [l, temp] has K elements. These are the possible ends of the sub array starting at l.\\n            while(temp<size && has(m, A[temp])) {\\n                count++;\\n                temp++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// since all the end pointers have been counted for subarray starting at l, we can move to next element as starting point of subarray\\n            remove(m, A[l]);\\n            l++;\\n        }\\n    }\\n    public void add(Map<Integer, Integer> m, int i) {\\n        m.put(i, m.getOrDefault(i, 0)+1);\\n    }\\n    \\n    public boolean has(Map<Integer, Integer> m, int i){\\n        return m.getOrDefault(i, 0)!=0;\\n    }\\n    \\n    public void remove(Map<Integer, Integer> m, int i) {\\n        int count = m.getOrDefault(i, 0);\\n        if(count<2) m.remove(i);\\n        else m.put(i, count - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        int size = A.length;\\n        int count = 0 ;\\n\\t\\t// stores the count of each integer appearing in the sliding window\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\t\\t// end points of window\\n        int l=0, r=0;\\n        while(true) {\\n\\t\\t\\t// let p be the index of 1st element such that no. of distinct elements in window [l, p] is K\\n\\t\\t\\t// run right pointer till you find p\\n            while(r<size && m.size()< K) {\\n                add(m, A[r]);\\n                r++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// return answer if we run out of elements\\n            if(m.size()!=K) return count;\\n            \\n\\t\\t\\t// At this point, r is one pointer ahead of p & we have K elements in the window [l, p]\\n\\t\\t\\t\\n\\t\\t\\tint temp = r-1;\\n\\t\\t\\t// Start from p and count for all indexes for which window [l, temp] has K elements. These are the possible ends of the sub array starting at l.\\n            while(temp<size && has(m, A[temp])) {\\n                count++;\\n                temp++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// since all the end pointers have been counted for subarray starting at l, we can move to next element as starting point of subarray\\n            remove(m, A[l]);\\n            l++;\\n        }\\n    }\\n    public void add(Map<Integer, Integer> m, int i) {\\n        m.put(i, m.getOrDefault(i, 0)+1);\\n    }\\n    \\n    public boolean has(Map<Integer, Integer> m, int i){\\n        return m.getOrDefault(i, 0)!=0;\\n    }\\n    \\n    public void remove(Map<Integer, Integer> m, int i) {\\n        int count = m.getOrDefault(i, 0);\\n        if(count<2) m.remove(i);\\n        else m.put(i, count - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919201,
                "title": "c-solution-using-hashmaps-faster-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int atMostK(vector<int>&nums,int k){\\n        map<int,int> mp;\\n        int i=0,ans = 0;\\n        for(int j=0;j<nums.size();j++){\\n            mp[nums[j]]++;\\n\\n            while(mp.size() > k){\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                i++;\\n            }\\n\\n            ans += (j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n      return atMostK(nums,k)  - atMostK(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int atMostK(vector<int>&nums,int k){\\n        map<int,int> mp;\\n        int i=0,ans = 0;\\n        for(int j=0;j<nums.size();j++){\\n            mp[nums[j]]++;\\n\\n            while(mp.size() > k){\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                i++;\\n            }\\n\\n            ans += (j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n      return atMostK(nums,k)  - atMostK(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745246,
                "title": "c-sliding-window-faster-than-96-with-explanation-o-n",
                "content": "At first the problem seems to be tricky. We need to calculate number of Subarrays with ```exactly K distinct elements``` and this is where we feel defeated by our intuition. We need to somehow drop this word!\\n\\n```\\n\\t(exact K) = (atmost K) - (atmost K - 1)\\n```\\n\\nThe above equation makes problem simpler.\\n\\n**Solution to number of Subarrays with Atmost K distinct elements**\\nwe just need two pointers `left` and `right` and a container which can store the numbers in between these pointers and give results to queries like how many distinct elements it has. So a `map` data structure comes into picture. `(unordered_map will also work.)`\\n\\nNow, we\\'ll keep populating map with elements untill the either `size of map < k` or `right` pointer pointes to an element which is already in our `map`. otherwise `right` pointer is pointing to `(k+1)th` distinct element so we will start reducing our window size. \\n\\nAlso we\\'ll use following formula to `count number of subarrays` starting at index `left` and ends before index `right`.\\n```\\n\\tnumberOfSubarrays = right - left  // starting at index left\\n```\\nThat\\'s it.\\n\\n**Time Complexity** : O(n)\\n**Space complexity** : O(n)\\n\\n**Implementation 1: (normal)**\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithAtmostKDistinct(vector<int>& values, int k)\\n    {\\n        unordered_map<int,int> occurences;\\n        int ans = 0;\\n        int j = 0;\\n        int n = values.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && (occurences.size() < k || occurences.count(values[j])))\\n            {\\n                occurences[values[j]]++;\\n                j++;\\n            }\\n            ans += j - i; // number of subarrays starting at index i\\n            // and ends before j\\n            occurences[values[i]]--;\\n            if(occurences[values[i]] == 0)\\n                occurences.erase(values[i]); \\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // results will be difference in the\\n        // number of subarrays with atmost (k-1) distinct elements and\\n        // number of subarrays with atmost (k) distinct elements\\n        // Time complexity: O(n)\\n        \\n        int atmostKminus1 = subarraysWithAtmostKDistinct(nums, k-1);\\n        int atmostK = subarraysWithAtmostKDistinct(nums, k);\\n        if(k==1)\\n            atmostKminus1 = 0; // as there would not be any distinct element in a subarray\\n        // of size 0\\n        return (atmostK - atmostKminus1);\\n    }\\n};\\n```\\n\\n\\n**Implementation 2: Beats 96% of CPP Solution**\\nSince the range of nums[i] is `1 <= nums[i] <= nums.length() `. We can use `vector` instead of `map` and thus improving the execution time by exploiting fast random access time of arrays.  \\n\\n```\\nclass MyMap {\\npublic:\\n    // we\\'ll use array implemetation of map\\n    // with minimum required functionality\\n    \\n    vector<int> counter;\\n    int distinctElements = 0;\\n    \\n    MyMap() : distinctElements(0) {}\\n    MyMap(int n)\\n    {\\n        // map of capacity of n elements\\n        counter.resize(n+1, 0);\\n    }\\n    \\n    // setter functions\\n    void insertOne(int val)\\n    {\\n        if(!counter[val])\\n        {\\n            distinctElements++;\\n        }\\n        \\n        counter[val]++; // increment distinct element count if it is not present initially\\n    } \\n    \\n    void eraseOne(int val)\\n    {\\n        if(counter[val] == 1)\\n        {\\n            distinctElements--;\\n        }\\n        counter[val]--;\\n    }\\n    \\n    // getter functions\\n    int size()\\n    {\\n       return distinctElements; \\n    }\\n    \\n    bool count(int val)\\n    {\\n       return counter[val]; \\n    }\\n};\\nclass Solution {\\npublic:\\n    int subarraysWithAtmostKDistinct(vector<int>& values, int k)\\n    {\\n        int ans = 0;\\n        int j = 0;\\n        int n = values.size();\\n        MyMap occurences = MyMap(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && (occurences.size() < k || occurences.count(values[j])))\\n            {\\n                occurences.insertOne(values[j]);\\n                j++;\\n            }\\n            ans += j - i; // number of subarrays starting at index i\\n            // and ends before j\\n            occurences.eraseOne(values[i]); \\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // results will be difference in the\\n        // number of subarrays with atmost (k-1) distinct elements and\\n        // number of subarrays with atmost (k) distinct elements\\n        // Time complexity: O(n)\\n        \\n        int atmostKminus1 = subarraysWithAtmostKDistinct(nums, k-1);\\n        int atmostK = subarraysWithAtmostKDistinct(nums, k);\\n        if(k==1)\\n            atmostKminus1 = 0; // as there would not be any distinct element in a subarray\\n        // of size 0\\n        return (atmostK - atmostKminus1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```exactly K distinct elements```\n```\\n\\t(exact K) = (atmost K) - (atmost K - 1)\\n```\n```\\n\\tnumberOfSubarrays = right - left  // starting at index left\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraysWithAtmostKDistinct(vector<int>& values, int k)\\n    {\\n        unordered_map<int,int> occurences;\\n        int ans = 0;\\n        int j = 0;\\n        int n = values.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && (occurences.size() < k || occurences.count(values[j])))\\n            {\\n                occurences[values[j]]++;\\n                j++;\\n            }\\n            ans += j - i; // number of subarrays starting at index i\\n            // and ends before j\\n            occurences[values[i]]--;\\n            if(occurences[values[i]] == 0)\\n                occurences.erase(values[i]); \\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // results will be difference in the\\n        // number of subarrays with atmost (k-1) distinct elements and\\n        // number of subarrays with atmost (k) distinct elements\\n        // Time complexity: O(n)\\n        \\n        int atmostKminus1 = subarraysWithAtmostKDistinct(nums, k-1);\\n        int atmostK = subarraysWithAtmostKDistinct(nums, k);\\n        if(k==1)\\n            atmostKminus1 = 0; // as there would not be any distinct element in a subarray\\n        // of size 0\\n        return (atmostK - atmostKminus1);\\n    }\\n};\\n```\n```\\nclass MyMap {\\npublic:\\n    // we\\'ll use array implemetation of map\\n    // with minimum required functionality\\n    \\n    vector<int> counter;\\n    int distinctElements = 0;\\n    \\n    MyMap() : distinctElements(0) {}\\n    MyMap(int n)\\n    {\\n        // map of capacity of n elements\\n        counter.resize(n+1, 0);\\n    }\\n    \\n    // setter functions\\n    void insertOne(int val)\\n    {\\n        if(!counter[val])\\n        {\\n            distinctElements++;\\n        }\\n        \\n        counter[val]++; // increment distinct element count if it is not present initially\\n    } \\n    \\n    void eraseOne(int val)\\n    {\\n        if(counter[val] == 1)\\n        {\\n            distinctElements--;\\n        }\\n        counter[val]--;\\n    }\\n    \\n    // getter functions\\n    int size()\\n    {\\n       return distinctElements; \\n    }\\n    \\n    bool count(int val)\\n    {\\n       return counter[val]; \\n    }\\n};\\nclass Solution {\\npublic:\\n    int subarraysWithAtmostKDistinct(vector<int>& values, int k)\\n    {\\n        int ans = 0;\\n        int j = 0;\\n        int n = values.size();\\n        MyMap occurences = MyMap(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            while(j<n && (occurences.size() < k || occurences.count(values[j])))\\n            {\\n                occurences.insertOne(values[j]);\\n                j++;\\n            }\\n            ans += j - i; // number of subarrays starting at index i\\n            // and ends before j\\n            occurences.eraseOne(values[i]); \\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // results will be difference in the\\n        // number of subarrays with atmost (k-1) distinct elements and\\n        // number of subarrays with atmost (k) distinct elements\\n        // Time complexity: O(n)\\n        \\n        int atmostKminus1 = subarraysWithAtmostKDistinct(nums, k-1);\\n        int atmostK = subarraysWithAtmostKDistinct(nums, k);\\n        if(k==1)\\n            atmostKminus1 = 0; // as there would not be any distinct element in a subarray\\n        // of size 0\\n        return (atmostK - atmostKminus1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536529,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    int atmostk(vector<int>& nums, int k){\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n        int n = nums.size();\\n        int freq[20005] = {0};\\n        while(right < n){\\n            if(freq[nums[right]]++ == 0){\\n                k--;\\n            }\\n            while(k < 0){\\n                freq[nums[left]]--;\\n                if(freq[nums[left]] == 0) k++;\\n                left++;\\n            }\\n            count += right - left + 1;\\n            right++;\\n        }\\n        return count;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return atmostk(nums,k) - atmostk(nums,k-1);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(nums)\\n        latest = {}\\n        unique = 0\\n        prev = 0\\n        for i in range(n):\\n            if nums[i] not in latest:\\n                unique += 1\\n            latest[nums[i]] = i\\n            if unique > k :\\n                while True:\\n                    if latest[nums[prev]] == prev:\\n                        latest.pop(nums[prev])\\n                        prev += 1\\n                        unique -= 1                        \\n                        break\\n                    else:\\n                        prev += 1\\n                        \\n            if unique == k:\\n                ans += 1\\n                tmp = prev\\n                while True:\\n                    if latest[nums[tmp]] != tmp:\\n                        ans += 1\\n                        tmp += 1\\n                    else:\\n                        break\\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        int j = 0;\\n        int res = 0;\\n        int prefix = 0;\\n        int[] arr = new int[A.length + 1];\\n        for (int value : A) {\\n            if (arr[value]++ == 0) {\\n                count++;\\n            }\\n            while (count > K) {\\n                arr[A[j++]]--;\\n                prefix = 0;\\n                count--;\\n            }\\n            while (arr[A[j]] > 1) {\\n                prefix++;\\n                arr[A[j++]]--;\\n            }\\n            if (count == K) {\\n                res += prefix + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    int atmostk(vector<int>& nums, int k){\\n        int left = 0;\\n        int right = 0;\\n        int count = 0;\\n        int n = nums.size();\\n        int freq[20005] = {0};\\n        while(right < n){\\n            if(freq[nums[right]]++ == 0){\\n                k--;\\n            }\\n            while(k < 0){\\n                freq[nums[left]]--;\\n                if(freq[nums[left]] == 0) k++;\\n                left++;\\n            }\\n            count += right - left + 1;\\n            right++;\\n        }\\n        return count;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return atmostk(nums,k) - atmostk(nums,k-1);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(nums)\\n        latest = {}\\n        unique = 0\\n        prev = 0\\n        for i in range(n):\\n            if nums[i] not in latest:\\n                unique += 1\\n            latest[nums[i]] = i\\n            if unique > k :\\n                while True:\\n                    if latest[nums[prev]] == prev:\\n                        latest.pop(nums[prev])\\n                        prev += 1\\n                        unique -= 1                        \\n                        break\\n                    else:\\n                        prev += 1\\n                        \\n            if unique == k:\\n                ans += 1\\n                tmp = prev\\n                while True:\\n                    if latest[nums[tmp]] != tmp:\\n                        ans += 1\\n                        tmp += 1\\n                    else:\\n                        break\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        int count = 0;\\n        int j = 0;\\n        int res = 0;\\n        int prefix = 0;\\n        int[] arr = new int[A.length + 1];\\n        for (int value : A) {\\n            if (arr[value]++ == 0) {\\n                count++;\\n            }\\n            while (count > K) {\\n                arr[A[j++]]--;\\n                prefix = 0;\\n                count--;\\n            }\\n            while (arr[A[j]] > 1) {\\n                prefix++;\\n                arr[A[j++]]--;\\n            }\\n            if (count == K) {\\n                res += prefix + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3307322,
                "title": "sliding-window-hashmap-approach-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(nums.length)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(k)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    static int subarraysWithAtMostKDistinct(int nums[],int k){\\n        int ans = 0;\\n        int l = 0;\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        for(int i = 0;i < nums.length;i++){\\n            mp.put(nums[i],mp.getOrDefault(nums[i],0) + 1);\\n            for(;mp.size() > k;){\\n                mp.put(nums[l],mp.get(nums[l]) - 1);\\n                if(mp.get(nums[l]) == 0) mp.remove(nums[l]);\\n                l++;\\n            }\\n            ans += i - l + 1;\\n        }\\n        return ans;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return subarraysWithAtMostKDistinct(nums,k) - subarraysWithAtMostKDistinct(nums,k - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    static int subarraysWithAtMostKDistinct(int nums[],int k){\\n        int ans = 0;\\n        int l = 0;\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        for(int i = 0;i < nums.length;i++){\\n            mp.put(nums[i],mp.getOrDefault(nums[i],0) + 1);\\n            for(;mp.size() > k;){\\n                mp.put(nums[l],mp.get(nums[l]) - 1);\\n                if(mp.get(nums[l]) == 0) mp.remove(nums[l]);\\n                l++;\\n            }\\n            ans += i - l + 1;\\n        }\\n        return ans;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return subarraysWithAtMostKDistinct(nums,k) - subarraysWithAtMostKDistinct(nums,k - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154929,
                "title": "java-c-beats-99-8-o-n-time-and-o-n-space-hashtable",
                "content": "## Approach\\nCount of SubArrays with k distinct elements = Count of SubArrays with at most k distinct elements - Count of SubArrays with at most k-1 distinct elements.\\n\\n## Complexity\\n- Time complexity: O(2*n) \\u2243 O(n)\\n\\n- Space complexity: O(2*n) \\u2243 O(n)\\n\\n## Code\\n``` java []\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n       return subarraysWithAtMostKDistinct(nums,k)-subarraysWithAtMostKDistinct(nums,k-1);\\n    }\\n\\n    private int subarraysWithAtMostKDistinct(int[] nums,int k){\\n         int[] freq = new int[nums.length+1]; //1 <= nums[i] <= nums.length\\n\\n        int j=0, count=0, unique=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(freq[nums[i]]++==0)\\n               unique++;\\n\\n            while(unique>k){\\n                if(freq[nums[j++]]--==1)\\n                   unique--;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return subarraysWithAtMostKDistinct(nums,k)-subarraysWithAtMostKDistinct(nums,k-1);\\n    }\\n\\nprivate:\\n    int subarraysWithAtMostKDistinct(vector<int> &nums,int k){\\n        vector<int> freq(nums.size()+1); //1 <= nums[i] <= nums.size()\\n\\n        int j=0, count=0, unique=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(freq[nums[i]]++==0)\\n               unique++;\\n\\n            while(unique>k){\\n                if(freq[nums[j++]]--==1)\\n                   unique--;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n       return subarraysWithAtMostKDistinct(nums,k)-subarraysWithAtMostKDistinct(nums,k-1);\\n    }\\n\\n    private int subarraysWithAtMostKDistinct(int[] nums,int k){\\n         int[] freq = new int[nums.length+1]; //1 <= nums[i] <= nums.length\\n\\n        int j=0, count=0, unique=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(freq[nums[i]]++==0)\\n               unique++;\\n\\n            while(unique>k){\\n                if(freq[nums[j++]]--==1)\\n                   unique--;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return subarraysWithAtMostKDistinct(nums,k)-subarraysWithAtMostKDistinct(nums,k-1);\\n    }\\n\\nprivate:\\n    int subarraysWithAtMostKDistinct(vector<int> &nums,int k){\\n        vector<int> freq(nums.size()+1); //1 <= nums[i] <= nums.size()\\n\\n        int j=0, count=0, unique=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(freq[nums[i]]++==0)\\n               unique++;\\n\\n            while(unique>k){\\n                if(freq[nums[j++]]--==1)\\n                   unique--;\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872558,
                "title": "easy-way-in-cpp-subarrays-with-k-different-integers",
                "content": "\\nclass Solution {\\npublic:\\n\\n  int atMostK(vector<int>arr, int n, int k)\\n{\\n    int i = 0,j=0,count=0;\\n     unordered_map<int,int>mp;\\n        while (j<n) {\\n \\n        if (mp.find(arr[j])==mp.end())\\n            mp[arr[j]]=0;\\n        mp[arr[j]]++;\\n\\n        while (mp.size() > k) {\\n            mp[arr[i]]--;\\n            if (mp[arr[i]] == 0)\\n                mp.erase(arr[i]);\\n        i++;\\n        }\\n        count += j - i+ 1;\\n        j++;\\n    }\\n    return count;\\n}\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n    int n=nums.size();\\n  return (atMostK(nums, n, k) - atMostK(nums, n, k - 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n  int atMostK(vector<int>arr, int n, int k)\\n{\\n    int i = 0,j=0,count=0;\\n     unordered_map<int,int>mp;\\n        while (j<n) {\\n \\n        if (mp.find(arr[j])==mp.end())\\n            mp[arr[j]]=0;\\n        mp[arr[j]]++;\\n\\n        while (mp.size() > k) {\\n            mp[arr[i]]--;\\n            if (mp[arr[i]] == 0)\\n                mp.erase(arr[i]);\\n        i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2870573,
                "title": "java-common-format-for-such-questions-explained",
                "content": "```\\nclass Solution {\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        // common format to get the subarrays or substrings with a constant k\\n        return atMost(nums,k) - atMost(nums, k-1);\\n    }\\n    \\n    public int atMost(int []nums, int k)\\n    {\\n        int i=0;\\n        int j=0;\\n        int [] count = new int[nums.length+1];\\n        int unique =0;\\n        int res=0;\\n        while(j<nums.length)\\n        {\\n            // we note the unique elements \\n            if(count[nums[j]] ==0)\\n                unique++;\\n            \\n            count[nums[j]]++;\\n            // while unique becomes more then reduce it \\n            while(unique>k)\\n            {\\n                count[nums[i]]--;\\n                if(count[nums[i]]==0)\\n                    unique--;\\n                i++;\\n            }\\n            // get the all subarrays between j and i \\n            // dont worry about the repeatition of subarrays as we have to eventually subtract\\n            res = res +j-i+1;\\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    \\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        // common format to get the subarrays or substrings with a constant k\\n        return atMost(nums,k) - atMost(nums, k-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2822742,
                "title": "most-concise-code-ever-java-solution-inspired-by-lee",
                "content": "Inspired by @lee215\\nWe can calculate \\nall subarrays with having distinct number `<=k` `-`  all subarrays having distinct number `<k` ;\\n```\\n public int subarraysWithKDistinct(int[] nums, int k) {\\n       return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n    private static int atMost(int[] arr,int k){\\n        int res = 0 , count = 0 , j = 0 ;\\n        Map<Integer,Integer> hm = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\\n            while(hm.size()>k){\\n                if(hm.get(arr[j])==1) hm.remove(arr[j++]);\\n                else hm.put(arr[j],hm.get(arr[j++])-1);\\n            }\\n            res+=i-j+1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int subarraysWithKDistinct(int[] nums, int k) {\\n       return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n    private static int atMost(int[] arr,int k){\\n        int res = 0 , count = 0 , j = 0 ;\\n        Map<Integer,Integer> hm = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\\n            while(hm.size()>k){\\n                if(hm.get(arr[j])==1) hm.remove(arr[j++]);\\n                else hm.put(arr[j],hm.get(arr[j++])-1);\\n            }\\n            res+=i-j+1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809399,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(vector<int>& A, int K) {\\n        int i = 0, res = 0;\\n        unordered_map<int, int> count;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!count[A[j]]++) K--;\\n            while (K < 0) {\\n                if (!--count[A[i]]) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n    int atMostK(vector<int>& A, int K) {\\n        int i = 0, res = 0;\\n        unordered_map<int, int> count;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!count[A[j]]++) K--;\\n            while (K < 0) {\\n                if (!--count[A[i]]) K++;\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674032,
                "title": "dynamic-programming-and-sliding-window-c-solution",
                "content": "### Motivation\\nThis solution is more efficient than the usual one, which computes the number of subarrays with at most k and at most k - 1 distinct elements (you can check it [here](https://leetcode.com/problems/subarrays-with-k-different-integers/solutions/523136/java-c-python-sliding-window/)).\\nThis is because the other solution does the sliding window twice, thus having at most 4\\\\*n steps. On the other hand, this solution\\'s worst case is 2*n steps.\\n\\n### Complexity\\n- Time complexity: O(n) (2*n steps performed in total in the worst case)\\n- Space complexity: O(1)\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n        Dynamic Programming + Sliding Window\\n        - O(n) time complexity\\n        - O(1) extra-space complexity\\n    */\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        std::unordered_map<int, int> currentNos;\\n        int start = 0, before = 1, currentCnt = 0, result = 0;\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (!currentNos[nums[i]]) {\\n                currentCnt++;\\n            }\\n\\n            currentNos[nums[i]]++;\\n            if (currentCnt > k) {\\n                before = 1;\\n                currentCnt--;\\n\\n                while (true) {\\n                    currentNos[nums[start]]--;\\n                    start++;\\n\\n                    if (!currentNos[nums[start - 1]]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (currentCnt == k) {\\n                while (currentNos[nums[start]] > 1) {\\n                    currentNos[nums[start]]--;\\n                    start++;\\n                    before++;\\n                }\\n\\n                result += before;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        Dynamic Programming + Sliding Window\\n        - O(n) time complexity\\n        - O(1) extra-space complexity\\n    */\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        std::unordered_map<int, int> currentNos;\\n        int start = 0, before = 1, currentCnt = 0, result = 0;\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (!currentNos[nums[i]]) {\\n                currentCnt++;\\n            }\\n\\n            currentNos[nums[i]]++;\\n            if (currentCnt > k) {\\n                before = 1;\\n                currentCnt--;\\n\\n                while (true) {\\n                    currentNos[nums[start]]--;\\n                    start++;\\n\\n                    if (!currentNos[nums[start - 1]]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (currentCnt == k) {\\n                while (currentNos[nums[start]] > 1) {\\n                    currentNos[nums[start]]--;\\n                    start++;\\n                    before++;\\n                }\\n\\n                result += before;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642201,
                "title": "easiest-explanation",
                "content": "**Prerequisites :-**\\n* How many subarray can be generated if we have a window of size n ending at last element? \\n\\t\\tWe can generate n subarrays.\\n\\t\\tExample -> [a, b, c] -> [b], [b,c], [a,b,c]\\n\\t\\n* If there are two pointers i and j, where i is pointing at the first element of the window and j is pointing at the last element, then what is the size of the window?\\n\\t\\tsize of window would be = j-i+1\\n\\t\\tExampe -> [1, 2, 3, 4] , i =0 , j = 3 -> size = j - i + 1 = 3 - 0 + 1 = 4 \\n\\n*  Number of subarrays with k different integers = Number of subarrays with atmost k different integers - Number of subarrays with atmost k-1 different integers \\n\\t\\tIntitutively you can understand this.\\n\\t\\t\\n```\\n\\tint atMostK(vector<int> &nums, int k){\\n        unordered_map<int, int> mp;\\n        int cnt = 0;\\n        int j = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            mp[nums[i]]++;\\n            while(mp.size()>k){\\n                mp[nums[j]]--;\\n                if(mp[nums[j]]==0) mp.erase(nums[j]);\\n                j++;\\n            }\\n            cnt+=i-j+1;\\n        }\\n        return cnt;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n\\tint atMostK(vector<int> &nums, int k){\\n        unordered_map<int, int> mp;\\n        int cnt = 0;\\n        int j = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            mp[nums[i]]++;\\n            while(mp.size()>k){\\n                mp[nums[j]]--;\\n                if(mp[nums[j]]==0) mp.erase(nums[j]);\\n                j++;\\n            }\\n            cnt+=i-j+1;\\n        }\\n        return cnt;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2611355,
                "title": "c-best-solution-explanation-map-sliding-window",
                "content": "\\uD83D\\uDCCA ***Explanation :***\\nFor \\u21E2 ***return atMost(nums,k)-atMost(nums,k-1);***\\nAccording to the question , we need subarrays with ***Exactly k*** distinct elements.\\nSo , when we carry out function for value k , we get the subarrays with ***atmost k*** distince elements **+** all the subarrays with ***less than k*** distinct elemnts .\\nWe ***subtract*** the subarrays with k-1 elements , which contains , subarrays with ***k-1 elements*** **+** all the subarrays with ***less than k-1 elements.***\\n***Hence*** , we get subarrays with ***exactly k distinct elements.***\\n>***exactly(K) = atMost(K) - atMost(K-1)***\\n\\n***Time Complexity : O(n)\\nSpace Complexity : O(n+n)=O(n)***\\n\\n**UPVOTE IF YOU LIKE** \\uD83D\\uDE0A\\u2705\\uD83D\\uDD11\\n\\n```\\nclass Solution {\\npublic:\\n    int atmostK(vector<int> &nums,int k){\\n        if(k<=0)return 0;\\n        unordered_map<int,int>m;\\n        \\n        int n=nums.size();\\n        int start=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n            while(start<i && m.size()>k){\\n                m[nums[start]]--;\\n                if(m[nums[start]]==0)m.erase(nums[start]);\\n                start++;\\n            }\\n            ans+=i-start+1;\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int atmostK(vector<int> &nums,int k){\\n        if(k<=0)return 0;\\n        unordered_map<int,int>m;\\n        \\n        int n=nums.size();\\n        int start=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n            while(start<i && m.size()>k){\\n                m[nums[start]]--;\\n                if(m[nums[start]]==0)m.erase(nums[start]);\\n                start++;\\n            }\\n            ans+=i-start+1;\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586942,
                "title": "cpp-intuition-comments-easy-understanding",
                "content": "```\\n    // crux of the problem:\\n    // if a problem is too confusing to solve reduce it to smaller problem\\n\\t// The problem is just a higher version of an easy problem\\n\\t// the only hard part here is to deduce that\\n\\t// if we want exactly k distinct elements then it can be wriiten as atmost k distinct elements - atmost (k-1) distinct elements\\n    \\n    int atmostK(vector<int> &nums,int k){\\n        \\n        if(k<=0)return 0;\\n        unordered_map<int,int> A;\\n        \\n        int n=nums.size();\\n        int i=0,j=0;\\n        \\n        int ans=0;\\n        while(j<n){\\n            A[nums[j]]++;\\n            while(A.size()>k){\\n                A[nums[i]]--;\\n                if(A[nums[i]]==0)A.erase(nums[i]);\\n                i++;\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n    // crux of the problem:\\n    // if a problem is too confusing to solve reduce it to smaller problem\\n\\t// The problem is just a higher version of an easy problem\\n\\t// the only hard part here is to deduce that\\n\\t// if we want exactly k distinct elements then it can be wriiten as atmost k distinct elements - atmost (k-1) distinct elements\\n    \\n    int atmostK(vector<int> &nums,int k){\\n        \\n        if(k<=0)return 0;\\n        unordered_map<int,int> A;\\n        \\n        int n=nums.size();\\n        int i=0,j=0;\\n        \\n        int ans=0;\\n        while(j<n){\\n            A[nums[j]]++;\\n            while(A.size()>k){\\n                A[nums[i]]--;\\n                if(A[nums[i]]==0)A.erase(nums[i]);\\n                i++;\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atmostK(nums,k)-atmostK(nums,k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570693,
                "title": "sliding-window-variation-at-most-k-template-based-solution",
                "content": "###  exactly(K) = atMost(K) - atMost(K-1)\\n\\t\\n    int atmost(vector<int>& nums, int k)\\n    {\\n        if(k==0)\\n            return 0;\\n        unordered_map<int,int> mp;\\n        int i=0,j=0,count=0,n=nums.size();\\n        while(j<n)\\n        {\\n            mp[nums[j]]++;\\n                while(mp.size()>k)\\n                {\\n                    mp[nums[i]]--;\\n                      if(mp[nums[i]]==0)\\n                        mp.erase(nums[i]);\\n                      i++;\\n                }\\n            count+=(j-i+1);\\n            j++;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return (atmost(nums,k)-atmost(nums,k-1));\\n    }",
                "solutionTags": [],
                "code": "###  exactly(K) = atMost(K) - atMost(K-1)\\n\\t\\n    int atmost(vector<int>& nums, int k)\\n    {\\n        if(k==0)\\n            return 0;\\n        unordered_map<int,int> mp;\\n        int i=0,j=0,count=0,n=nums.size();\\n        while(j<n)\\n        {\\n            mp[nums[j]]++;\\n                while(mp.size()>k)\\n                {\\n                    mp[nums[i]]--;\\n                      if(mp[nums[i]]==0)\\n                        mp.erase(nums[i]);\\n                      i++;\\n                }\\n            count+=(j-i+1);\\n            j++;\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return (atmost(nums,k)-atmost(nums,k-1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2568548,
                "title": "c-easy-understanding-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int atMost(vector<int>& nums, int goal)\\n    {\\n        unordered_map<int,int>mp;\\n        int window_start=0, window_end=0, ans=0,count=0;\\n        if (goal < 0)\\n            return 0;\\n        for(window_end=0; window_end<nums.size() ;window_end++)\\n        {\\n            mp[nums[window_end]]++;\\n            while(mp.size()>goal)\\n            {\\n                mp[nums[window_start]]--;\\n                if(mp[nums[window_start]]==0)\\n                    mp.erase(nums[window_start]);\\n                window_start++;\\n            }\\n            ans+=window_end-window_start+1;\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n};\\n```\\nNote:- window_end-window_start+1 gives number of subarrays in a window.\\nTime O(N) for two passes.\\nSpace O(K) at most K elements in the mp\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int atMost(vector<int>& nums, int goal)\\n    {\\n        unordered_map<int,int>mp;\\n        int window_start=0, window_end=0, ans=0,count=0;\\n        if (goal < 0)\\n            return 0;\\n        for(window_end=0; window_end<nums.size() ;window_end++)\\n        {\\n            mp[nums[window_end]]++;\\n            while(mp.size()>goal)\\n            {\\n                mp[nums[window_start]]--;\\n                if(mp[nums[window_start]]==0)\\n                    mp.erase(nums[window_start]);\\n                window_start++;\\n            }\\n            ans+=window_end-window_start+1;\\n        }\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253375,
                "title": "python-sliding-window",
                "content": "We\\'ll maintain a sliding window such that we advance the right pointer on each iteration to point to the current element. \\n\\nIt\\'s then our aim to calculate the number of subarrays with K distinct elements ENDING on the right pointer\\'s element.\\n\\nTherefore at each iteration we end up with three cases:\\n- **(1)** Our window has less than K distinct elements - we don\\'t do anything and continue iteration, maybe enlarging our window next iteration will get us there\\n- **(2)** Our window has exactly K distinct elements - we need to find the maximum left pointer such that up to the end of the window, we still have K distinct elements. Then we add the distance from the `bound` to that left pointer, where the `bound` is the farthest left you can go without introducing more distinct elements.\\n- **(3)** Our window has more than K distinct elements - constrict your window by advancing the left pointer, until you end up with exactly K distinct elements. At this point you can update your `bound` as well (again to mark the farthest left your current set of distinct elements can extend).\\n\\nAs dealing with **(3)** leads directly to **(2)**, I combined those cases together into one block in my code.\\n\\nThe `Counter` data structure helps us maintain a window\\'s distinct element count (by just accessing the size of its key set). We delete entries once the count of an element hits 0.\\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = bound = l = 0\\n        window = Counter()\\n        \\n        for num in nums:\\n            window[num] += 1\\n            \\n            if len(window) >= k:\\n                while len(window) > k:\\n                    window[nums[l]] -= 1\\n                    if window[nums[l]] == 0:\\n                        del window[nums[l]]\\n                    l += 1\\n                    bound = l\\n         \\n                while window[nums[l]] - 1 > 0:\\n                    window[nums[l]] -= 1\\n                    l += 1\\n                \\n                ans += (l - bound + 1)\\n        \\n        return ans\\n```\\n\\nTime/space: `O(n)`",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ans = bound = l = 0\\n        window = Counter()\\n        \\n        for num in nums:\\n            window[num] += 1\\n            \\n            if len(window) >= k:\\n                while len(window) > k:\\n                    window[nums[l]] -= 1\\n                    if window[nums[l]] == 0:\\n                        del window[nums[l]]\\n                    l += 1\\n                    bound = l\\n         \\n                while window[nums[l]] - 1 > 0:\\n                    window[nums[l]] -= 1\\n                    l += 1\\n                \\n                ans += (l - bound + 1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184647,
                "title": "c-sliding-window-map",
                "content": "Upvote if it helps :)\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // atmost k -  atmost k-1 = only k characters \\n        return fun(nums,k)-fun(nums,k-1);\\n    }\\n    int fun(vector<int>& nums, int k) // atmost k diff character\\n    {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n            while(m.size()>k)\\n            {\\n                m[nums[j]]--;\\n                if(m[nums[j]]==0)\\n                    m.erase(nums[j]);\\n                j++;\\n            }\\n            res+=i-j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // atmost k -  atmost k-1 = only k characters \\n        return fun(nums,k)-fun(nums,k-1);\\n    }\\n    int fun(vector<int>& nums, int k) // atmost k diff character\\n    {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n            while(m.size()>k)\\n            {\\n                m[nums[j]]--;\\n                if(m[nums[j]]==0)\\n                    m.erase(nums[j]);\\n                j++;\\n            }\\n            res+=i-j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126160,
                "title": "easy-cpp-solution-sliding-window",
                "content": "So the logic is to find all subarray count for atmost k distinct characters and all subarray count for atmost k-1 distinct characters, if you find the difference of the two you will get the subarray count for exactly k distinct characters. \\n ```\\nclass Solution {\\npublic:\\n    int subarrayCountWithAtMostKchar(vector<int>& arr, int k) \\n    {\\n        int i=0,j=0,count=0;\\n        unordered_map<int,int> mp;\\n        while(j<arr.size())\\n        {\\n            mp[arr[j]]++;\\n            if(mp.size()<=k)\\n            {\\n                count+=j-i+1;\\n                j++;\\n            }\\n            else \\n            {\\n                while(mp.size()>k)\\n                {\\n                    mp[arr[i]]--;\\n                    if(mp[arr[i]]==0)\\n                    {\\n                        mp.erase(arr[i]);\\n                    }\\n                    i++;\\n                }\\n                if(mp.size()<=k)\\n                {\\n                    count+=j-i+1;\\n                }\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        int a=subarrayCountWithAtMostKchar(nums,k);\\n        int b=subarrayCountWithAtMostKchar(nums,k-1);\\n        return a-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayCountWithAtMostKchar(vector<int>& arr, int k) \\n    {\\n        int i=0,j=0,count=0;\\n        unordered_map<int,int> mp;\\n        while(j<arr.size())\\n        {\\n            mp[arr[j]]++;\\n            if(mp.size()<=k)\\n            {\\n                count+=j-i+1;\\n                j++;\\n            }\\n            else \\n            {\\n                while(mp.size()>k)\\n                {\\n                    mp[arr[i]]--;\\n                    if(mp[arr[i]]==0)\\n                    {\\n                        mp.erase(arr[i]);\\n                    }\\n                    i++;\\n                }\\n                if(mp.size()<=k)\\n                {\\n                    count+=j-i+1;\\n                }\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) \\n    {\\n        int a=subarrayCountWithAtMostKchar(nums,k);\\n        int b=subarrayCountWithAtMostKchar(nums,k-1);\\n        return a-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073009,
                "title": "c-sliding-window-variation-of-longest-subarray-with-atmost-k-different-elements",
                "content": "Simple Variation of Longest Subarray (or substring) with Atmost k Distinct Elements:\\n\\n\\nFormula: \\nExactly(k distinct) = Atmost(k distinct) - Atmost(k-1 distinct);\\n\\n\\nIntution:\\nFor example let us consider k as 5 at most 5 distinct will include all posibilities such as sub arrays with 1 distinct element until 5 distince elements. Similarly at most 4 will include all possibilities sub arrays with 1 distinct element  to 4 distinct elements. \\n\\nIf we subtract both we will remain with all possibilities which contain 5 different elements.\\n\\n\\n\\n    int solve_at_most(vector<int> nums, int k){\\n        int n = nums.size();\\n        int res = 0;\\n        int i=0,j=0;\\n        unordered_map<int,int> mp;\\n        \\n        while(j < n){\\n            mp[nums[j]]++;\\n            \\n            while(mp.size() > k){\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                    mp.erase(nums[i]);\\n                i++;\\n            }\\n            res += j-i+1;\\n            j++;\\n        }\\n        return res;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int res = solve_at_most(nums,k) - solve_at_most(nums,k-1);\\n        return res;\\n    }\\n\\n\\nReference:\\nThe problem Longest Increasing Subsequence with Atmost K distinct charecters can be found in PepCoding\\'s youtube channel",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "Simple Variation of Longest Subarray (or substring) with Atmost k Distinct Elements:\\n\\n\\nFormula: \\nExactly(k distinct) = Atmost(k distinct) - Atmost(k-1 distinct);\\n\\n\\nIntution:\\nFor example let us consider k as 5 at most 5 distinct will include all posibilities such as sub arrays with 1 distinct element until 5 distince elements. Similarly at most 4 will include all possibilities sub arrays with 1 distinct element  to 4 distinct elements. \\n\\nIf we subtract both we will remain with all possibilities which contain 5 different elements.\\n\\n\\n\\n    int solve_at_most(vector<int> nums, int k){\\n        int n = nums.size();\\n        int res = 0;\\n        int i=0,j=0;\\n        unordered_map<int,int> mp;\\n        \\n        while(j < n){\\n            mp[nums[j]]++;\\n            \\n            while(mp.size() > k){\\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                    mp.erase(nums[i]);\\n                i++;\\n            }\\n            res += j-i+1;\\n            j++;\\n        }\\n        return res;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int res = solve_at_most(nums,k) - solve_at_most(nums,k-1);\\n        return res;\\n    }\\n\\n\\nReference:\\nThe problem Longest Increasing Subsequence with Atmost K distinct charecters can be found in PepCoding\\'s youtube channel",
                "codeTag": "Unknown"
            },
            {
                "id": 1819753,
                "title": "c-sliding-window-992-subarrays-with-k-different-integers",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(vector<int>& nums, int k){\\n        unordered_map<int,int>m;\\n        int i=0, c=0;\\n        for(int j=0;j<nums.size();j++){\\n            m[nums[j]]++;\\n            while(m.size()>k){\\n                m[nums[i]]--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            c+=(j-i+1);\\n        }\\n        return c;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // count of subarrays with <=K distant\\n        // -\\n        // count of subarrays with <=K-1 (<K) distant\\n        return count(nums,k)-count(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(vector<int>& nums, int k){\\n        unordered_map<int,int>m;\\n        int i=0, c=0;\\n        for(int j=0;j<nums.size();j++){\\n            m[nums[j]]++;\\n            while(m.size()>k){\\n                m[nums[i]]--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            c+=(j-i+1);\\n        }\\n        return c;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        // count of subarrays with <=K distant\\n        // -\\n        // count of subarrays with <=K-1 (<K) distant\\n        return count(nums,k)-count(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774003,
                "title": "python-verbose",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Appraoch: One way to solve for distinct element is to keep a set \\n        Alternate approach is to find all possibilites of at most K distinct subarrays and all possibilitites of at most K - 1 distinct subarrays and take their difference \\n        \\n        Since we are interested only in the count and not the actual numbers the latter appraoch seems a wiser choise\\n        \\n        \"\"\"\\n        def atmostK(s,k):\\n            # Initialize to defaultdict(int)\\n            d = Counter()\\n            \\n            # left end pointer\\n            l = 0\\n            \\n            # Counter to count ans\\n            ans = 0\\n            \\n            for r,i in enumerate(s):\\n                # check if the number is a new entry\\n                if d[i] == 0:\\n                    # if yes reduce k \\n                    k-=1\\n                    \\n                # Add to the dict\\n                d[i] +=1\\n                \\n                # To remove element until k distinct\\n                while k < 0:\\n                    d[s[l]]-=1\\n                    if d[s[l]] == 0:\\n                        k+=1\\n                    l+=1\\n\\n                # Total number of subarrays when a new element is added is equal to the length of the new array \\n                # ex [1,2,3] + [4]\\n                # Total number of subarrays = [1,2,3,4],[2,3,4],[3,4],[4]\\n                # which is equal to the length\\n                ans += r - l + 1\\n\\n            return ans\\n        return atmostK(nums,k) - atmostK(nums,k-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Appraoch: One way to solve for distinct element is to keep a set \\n        Alternate approach is to find all possibilites of at most K distinct subarrays and all possibilitites of at most K - 1 distinct subarrays and take their difference \\n        \\n        Since we are interested only in the count and not the actual numbers the latter appraoch seems a wiser choise\\n        \\n        \"\"\"\\n        def atmostK(s,k):\\n            # Initialize to defaultdict(int)\\n            d = Counter()\\n            \\n            # left end pointer\\n            l = 0\\n            \\n            # Counter to count ans\\n            ans = 0\\n            \\n            for r,i in enumerate(s):\\n                # check if the number is a new entry\\n                if d[i] == 0:\\n                    # if yes reduce k \\n                    k-=1\\n                    \\n                # Add to the dict\\n                d[i] +=1\\n                \\n                # To remove element until k distinct\\n                while k < 0:\\n                    d[s[l]]-=1\\n                    if d[s[l]] == 0:\\n                        k+=1\\n                    l+=1\\n\\n                # Total number of subarrays when a new element is added is equal to the length of the new array \\n                # ex [1,2,3] + [4]\\n                # Total number of subarrays = [1,2,3,4],[2,3,4],[3,4],[4]\\n                # which is equal to the length\\n                ans += r - l + 1\\n\\n            return ans\\n        return atmostK(nums,k) - atmostK(nums,k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764686,
                "title": "exact-k-atmost-k-atmost-k-1",
                "content": "<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    int atMostK(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int left = 0, right = 0, ans = 0;\\n        \\n        while(right < nums.size()) {\\n            mp[nums[right]]++;\\n            while(mp.size() > k) {\\n                if(--mp[nums[left]] == 0) mp.erase(nums[left]);\\n                left++;\\n            }\\n            ans += (right - left + 1);\\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n};\\n```\\n<br/>\\n\\nTime Complexity: **O(N)**\\nSpace Complexity: **O(N)**\\n\\n<br/>",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int atMostK(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int left = 0, right = 0, ans = 0;\\n        \\n        while(right < nums.size()) {\\n            mp[nums[right]]++;\\n            while(mp.size() > k) {\\n                if(--mp[nums[left]] == 0) mp.erase(nums[left]);\\n                left++;\\n            }\\n            ans += (right - left + 1);\\n            right++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656234,
                "title": "python-solution-with-explaination",
                "content": "The idea is:\\n1. we maintain two pointers `left, right` which point to the start and end of the shortest good array ends on `right`.\\n2. we maintain the number of good arrays ends on `right`.\\n3. On `right+1`, there\\'s two situation:\\n\\t3.1. By appending the element to the shortest good array ends on `right`, it is still good. This means we can safely extend all good arrays ends on `right` with the element on `right+1`. \\n\\t3.2 By appending the element to the shortest good array ends on `right`, it is not good. We don\\'t extend any of the previous in this case.\\n4. Now we\\'ve handled all cases by exntedning previous good arrays, we then keep moving `left` to get the new shortest good array. In this process, any arrays encountered are always good.\\n\\nIn the worst case, we process every element two times, thus the worst time complexity is O(n) where n is the number of elements.\\n\\nBelow is the code:\\n```python\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ret = 0\\n        prev_good = 0\\n        counter = dict()\\n        left, right = 0, 0\\n        \\n        # keep moving right\\n        for right in range(len(nums)):\\n            counter[nums[right]] = counter.setdefault(nums[right], 0) + 1\\n            \\n            # now we have k distinct\\n            if len(counter.keys()) == k:        \\n                # the first time we meet k distinct\\n                if prev_good == 0:\\n                    prev_good = 1\\n                    \\n                # we can move left to find the shortest good to get new good\\n                while counter[nums[left]] > 1:\\n                    counter[nums[left]] -= 1\\n                    left += 1\\n                    prev_good += 1\\n            # now we have more than k distinct\\n            elif len(counter.keys()) > k:\\n                # we remove the first of previous shortest good and appending the right\\n                # to get a new good\\n                prev_good = 1\\n                counter.pop(nums[left])\\n                left += 1\\n            \\n                # we can move left to reach the shortest good to get new good\\n                while counter[nums[left]] > 1:\\n                    counter[nums[left]] -= 1\\n                    left += 1\\n                    prev_good += 1\\n            ret += prev_good\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        ret = 0\\n        prev_good = 0\\n        counter = dict()\\n        left, right = 0, 0\\n        \\n        # keep moving right\\n        for right in range(len(nums)):\\n            counter[nums[right]] = counter.setdefault(nums[right], 0) + 1\\n            \\n            # now we have k distinct\\n            if len(counter.keys()) == k:        \\n                # the first time we meet k distinct\\n                if prev_good == 0:\\n                    prev_good = 1\\n                    \\n                # we can move left to find the shortest good to get new good\\n                while counter[nums[left]] > 1:\\n                    counter[nums[left]] -= 1\\n                    left += 1\\n                    prev_good += 1\\n            # now we have more than k distinct\\n            elif len(counter.keys()) > k:\\n                # we remove the first of previous shortest good and appending the right\\n                # to get a new good\\n                prev_good = 1\\n                counter.pop(nums[left])\\n                left += 1\\n            \\n                # we can move left to reach the shortest good to get new good\\n                while counter[nums[left]] > 1:\\n                    counter[nums[left]] -= 1\\n                    left += 1\\n                    prev_good += 1\\n            ret += prev_good\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568903,
                "title": "c-sliding-window-with-3-pointers",
                "content": "1. I used two pointers `l` and `r` to maintain the **largest** window which has exact `k` different numbers ended at `r`.\\n2. A third pointer `p` is inbetween `l` and `r`. `p` is squeezed from `l` towards `r` and stops at the **smallest** window with  `k` distinct elements ened at `r`.\\n3. The counting process is at each step at `r`, counts the number of the subarrays ends at `r` and this is `p-l+1`\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nSee the following example, nums = [1,2,1,2,3,3,4,5] and k = 5\\nthe last column is the number of the subarrays which has exact `k` different numbers. The final result is the sum over the results in the last column for each row.\\n![image](https://assets.leetcode.com/users/images/97625ce2-31fa-4c55-93e4-7a336bbd2c51_1636490645.8440108.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        unordered_map<int,int> freq_in;\\n        int l =0, r=0, p = 0;\\n        int n = nums.size();\\n        int sum = 0;\\n        int counts = 0;\\n        while(r<n){\\n            freq[nums[r]]++;\\n            freq_in[nums[r]]++;\\n            if(freq[nums[r]]==1){\\n                counts++;\\n            }\\n            while(counts>k){\\n                freq[nums[l]]--;\\n                freq_in[nums[l]]=freq[nums[l]];\\n                if(freq[nums[l]]==0){\\n                    counts--;\\n                }\\n                l++;\\n                p=l;\\n            } \\n            if(counts==k){\\n                while(freq_in[nums[p]]!=1){\\n                    freq_in[nums[p]]--;\\n                    p++;\\n                }      \\n                sum += (p-l+1);\\n            }\\n            r++;\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        unordered_map<int,int> freq_in;\\n        int l =0, r=0, p = 0;\\n        int n = nums.size();\\n        int sum = 0;\\n        int counts = 0;\\n        while(r<n){\\n            freq[nums[r]]++;\\n            freq_in[nums[r]]++;\\n            if(freq[nums[r]]==1){\\n                counts++;\\n            }\\n            while(counts>k){\\n                freq[nums[l]]--;\\n                freq_in[nums[l]]=freq[nums[l]];\\n                if(freq[nums[l]]==0){\\n                    counts--;\\n                }\\n                l++;\\n                p=l;\\n            } \\n            if(counts==k){\\n                while(freq_in[nums[p]]!=1){\\n                    freq_in[nums[p]]--;\\n                    p++;\\n                }      \\n                sum += (p-l+1);\\n            }\\n            r++;\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521009,
                "title": "java-sliding-window",
                "content": "\\n\\n\\tclass Solution {\\n\\t\\n\\t\\t// Function to return the count of subarrays\\n\\t\\t// with at most K distinct elements using\\n\\t\\t// the sliding window technique\\n\\t\\tprivate static int atMostK(int arr[], int k) {\\n\\t \\n\\t\\t\\t// To store the result\\n\\t\\t\\tint count = 0;\\n\\t \\n\\t\\t\\t// Left boundary of window\\n\\t\\t\\tint left = 0;\\n\\t \\n\\t\\t\\t// Map to keep track of number of distinct\\n\\t\\t\\t// elements in the current window\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t \\n\\t\\t\\t// Loop to calculate the count\\n\\t\\t\\tfor(int right =0; right < arr.length; right++){\\n\\t \\n\\t\\t\\t\\t// Calculating the frequency of each\\n\\t\\t\\t\\t// element in the current window\\n\\t\\t\\t\\tmap.put(arr[right], map.getOrDefault(arr[right], 0) + 1);\\n\\t \\n\\t\\t\\t\\t// Shrinking the window from left if the\\n\\t\\t\\t\\t// count of distinct elements exceeds K\\n\\t\\t\\t\\twhile (map.size() > k) {\\n\\t\\t\\t\\t\\tmap.put(arr[left], map.get(arr[left]) - 1);\\n\\t\\t\\t\\t\\tif (map.get(arr[left]) == 0) map.remove(arr[left]);\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t \\n\\t\\t\\t\\t// Adding the count of subarrays with at most\\n\\t\\t\\t\\t// K distinct elements in the current window\\n\\t\\t\\t\\tcount += right - left + 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t \\n\\t\\t// Function to return the count of subarrays\\n\\t\\t// with exactly K distinct elements\\n\\t\\tprivate static int exactlyK(int arr[], int k) {\\n\\t \\n\\t\\t\\t// Count of subarrays with exactly k distinct\\n\\t\\t\\t// elements is equal to the difference of the\\n\\t\\t\\t// count of subarrays with at most K distinct\\n\\t\\t\\t// elements and the count of subararys with\\n\\t\\t\\t// at most (K - 1) distinct elements\\n\\t\\t\\treturn (atMostK(arr, k) - atMostK(arr, k - 1));\\n\\t\\t}\\n\\t\\t\\n\\t\\tstatic int subarraysWithKDistinct(int arr[], int k) {\\n\\t\\t\\treturn exactlyK(arr, k);\\n\\t\\t}\\n\\t\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\n\\t\\t// Function to return the count of subarrays\\n\\t\\t// with at most K distinct elements using\\n\\t\\t// the sliding window technique\\n\\t\\tprivate static int atMostK(int arr[], int k) {\\n\\t \\n\\t\\t\\t// To store the result\\n\\t\\t\\tint count = 0;\\n\\t \\n\\t\\t\\t// Left boundary of window\\n\\t\\t\\tint left = 0;\\n\\t \\n\\t\\t\\t// Map to keep track of number of distinct\\n\\t\\t\\t// elements in the current window\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t \\n\\t\\t\\t// Loop to calculate the count\\n\\t\\t\\tfor(int right =0; right < arr.length; right++){\\n\\t \\n\\t\\t\\t\\t// Calculating the frequency of each\\n\\t\\t\\t\\t// element in the current window\\n\\t\\t\\t\\tmap.put(arr[right], map.getOrDefault(arr[right], 0) + 1);\\n\\t \\n\\t\\t\\t\\t// Shrinking the window from left if the\\n\\t\\t\\t\\t// count of distinct elements exceeds K\\n\\t\\t\\t\\twhile (map.size() > k) {\\n\\t\\t\\t\\t\\tmap.put(arr[left], map.get(arr[left]) - 1);\\n\\t\\t\\t\\t\\tif (map.get(arr[left]) == 0) map.remove(arr[left]);\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1418048,
                "title": "brute-force-approach-tle-tell-this-to-the-interviewer-at-first",
                "content": "TC: Approx O(n^2)\\n```\\n public int subarraysWithKDistinct(int[] arr, int k) {\\n        \\n        // 55 / 55 test cases passed, but took too long.\\n\\t\\t\\n        int cogs=0; //count of good subarrays\\n        int count = 0, n = arr.length, si = 0, ei = 0;\\n        int[] freq = new int[20000 + 1];\\n        \\n        \\n        while (ei<n) {\\n            if (ei<n && freq[arr[ei++]]++ == 0) count++;\\n            \\n            if(count==k) cogs++;\\n            \\n            if (count > k || ei==n) {\\n                si++;\\n                ei=si;\\n                count = 0;\\n                freq = new int[20000 + 1];\\n            }\\n            \\n        }\\n\\n        return cogs;\\n        \\n    }\\n```\\n\\nAnyone know other working solution than the atMost(k)-atMost(k-1) solution?....(well this was O(n))",
                "solutionTags": [],
                "code": "```\\n public int subarraysWithKDistinct(int[] arr, int k) {\\n        \\n        // 55 / 55 test cases passed, but took too long.\\n\\t\\t\\n        int cogs=0; //count of good subarrays\\n        int count = 0, n = arr.length, si = 0, ei = 0;\\n        int[] freq = new int[20000 + 1];\\n        \\n        \\n        while (ei<n) {\\n            if (ei<n && freq[arr[ei++]]++ == 0) count++;\\n            \\n            if(count==k) cogs++;\\n            \\n            if (count > k || ei==n) {\\n                si++;\\n                ei=si;\\n                count = 0;\\n                freq = new int[20000 + 1];\\n            }\\n            \\n        }\\n\\n        return cogs;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398951,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int atMostKDistict(vector<int> &ar, int n, int k) {\\n        \\n        unordered_map<int, int> mp;\\n        int j = 0, ans = 0;\\n        for(int i=0; i<n; i++) {\\n            \\n            mp[ar[i]]++;\\n            while(mp.size() > k) {\\n                if(mp[ar[j]] > 1) {\\n                    mp[ar[j]]--;\\n                } else {\\n                    mp.erase(ar[j]);\\n                }\\n                \\n                j++;\\n            }\\n            \\n            ans += (i-j+1);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        return atMostKDistict(nums, n, k) - atMostKDistict(nums, n, k-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int atMostKDistict(vector<int> &ar, int n, int k) {\\n        \\n        unordered_map<int, int> mp;\\n        int j = 0, ans = 0;\\n        for(int i=0; i<n; i++) {\\n            \\n            mp[ar[i]]++;\\n            while(mp.size() > k) {\\n                if(mp[ar[j]] > 1) {\\n                    mp[ar[j]]--;\\n                } else {\\n                    mp.erase(ar[j]);\\n                }\\n                \\n                j++;\\n            }\\n            \\n            ans += (i-j+1);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        return atMostKDistict(nums, n, k) - atMostKDistict(nums, n, k-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365933,
                "title": "c-sliding-window-full-explanation",
                "content": "// Explanation: for test case : [1,2,1,3,4], k = 3\\n// Subarray with atmost k diff integer ->\\n// [1],[1,2],[1,2,1],[1,2,1,3],[2],[2,1],[2,1,3]\\n// [1],[1,3],[1,3,4]\\n// [3],[3,4]\\n// [4]\\n// Subarray with atmost k-1 diff integer ->\\n// [1],[1,2],[1,2,1],[2],[2,1],[1],[1,3],[3],[3,4],[4]\\n\\n// x-> no of subarray with atmost k\\n// y-> no of subarray with atmost k-1\\n// if we do (x-y) we will be left with exactly k diff integers\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int k) {\\n        int i,j;\\n        i = j = 0;\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        while(i<=j && j<nums.size()) {\\n            mp[nums[j]]++;\\n            while(mp.size()>k) {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0) {\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n            ans += (j-i);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return solve(nums,k) - solve(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int k) {\\n        int i,j;\\n        i = j = 0;\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        while(i<=j && j<nums.size()) {\\n            mp[nums[j]]++;\\n            while(mp.size()>k) {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0) {\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n            ans += (j-i);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return solve(nums,k) - solve(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191772,
                "title": "c-95-sliding-window",
                "content": "```\\npublic class Solution {\\n    public int SubarraysWithKDistinct(int[] A, int K) {\\n        \\n        var map = new int[A.Length + 1]; //gotcha\\n        var count = 0;\\n        var start = 0;\\n        var end = 0;\\n        var prefix = 0;\\n        var result = 0;\\n        \\n        while(end < A.Length)\\n        {\\n            if(map[A[end++]]++ == 0)\\n                count++;\\n            \\n            if(count > K)\\n            {\\n                map[A[start++]]--;\\n                count--;\\n                prefix = 0;\\n            }\\n            while(map[A[start]] > 1) //gotcha\\n            {\\n                prefix++;\\n                map[A[start++]]--;\\n            }\\n            \\n            if(count == K)\\n            {\\n                result += prefix + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SubarraysWithKDistinct(int[] A, int K) {\\n        \\n        var map = new int[A.Length + 1]; //gotcha\\n        var count = 0;\\n        var start = 0;\\n        var end = 0;\\n        var prefix = 0;\\n        var result = 0;\\n        \\n        while(end < A.Length)\\n        {\\n            if(map[A[end++]]++ == 0)\\n                count++;\\n            \\n            if(count > K)\\n            {\\n                map[A[start++]]--;\\n                count--;\\n                prefix = 0;\\n            }\\n            while(map[A[start]] > 1) //gotcha\\n            {\\n                prefix++;\\n                map[A[start++]]--;\\n            }\\n            \\n            if(count == K)\\n            {\\n                result += prefix + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167138,
                "title": "javascript-beat-97-96-time-100-space",
                "content": "Javascript solution, for detailed explaination, please refer to the following\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C%2B%2BJava-with-picture-prefixed-sliding-window\\n\\n````\\nvar subarraysWithKDistinct = function (A, K) {\\n    if (A == null || A.length == 0 || K == 0 || A.length < K) {\\n        return 0;\\n    }\\n    let count = Array(A.length + 1).fill(0);\\n    let l = 0, acc = 0, res = 0;\\n    for (let r = 0; r < A.length; r++) {\\n        if (count[A[r]]++ == 0) {\\n            K--;\\n        }\\n        if (K < 0) {\\n            count[A[l++]]--;\\n            K++;\\n            acc = 0;\\n        }\\n        if (K == 0) {\\n            while (count[A[l]] > 1) {\\n                count[A[l++]]--;\\n                acc++;\\n            }\\n            res += acc + 1;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "````\\nvar subarraysWithKDistinct = function (A, K) {\\n    if (A == null || A.length == 0 || K == 0 || A.length < K) {\\n        return 0;\\n    }\\n    let count = Array(A.length + 1).fill(0);\\n    let l = 0, acc = 0, res = 0;\\n    for (let r = 0; r < A.length; r++) {\\n        if (count[A[r]]++ == 0) {\\n            K--;\\n        }\\n        if (K < 0) {\\n            count[A[l++]]--;\\n            K++;\\n            acc = 0;\\n        }\\n        if (K == 0) {\\n            while (count[A[l]] > 1) {\\n                count[A[l++]]--;\\n                acc++;\\n            }\\n            res += acc + 1;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135205,
                "title": "java-human-readable-solution-2-mins-to-understand-it",
                "content": "if you stuck with other solutions with a lot a time, read this one instead.\\n\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        // brainstorm: subarrays with at most K distinct values contains two parts: \\n\\t\\t// subarrays with exactly K distinct values + subarrays with at most K - 1 distinct values\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n\\n    private int atMostK(int[] A, int k) {\\n        // use a map to control what we\\'ve seen before, map.size() compared to k during the process.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int start = 0;\\n        int end = 0;\\n        int res = 0;\\n        while (end < A.length) {\\n            // put it into map anyway\\n            map.put(A[end], map.getOrDefault(A[end], 0) + 1);\\n            \\n            // if map size is larger then k, must reduce it to exactly k by moving start and deleting the count in map\\n            while (map.size() > k) {\\n                map.put(A[start], map.getOrDefault(A[start], 0) - 1);\\n                if (map.get(A[start]) == 0) map.remove(A[start]);\\n                start++;\\n            }\\n            res += end - start + 1; // brainstorm: when you get a range that satisfy at most k distinct values, \\n\\t\\t\\t                                      // how many subarrays are there ending with this \"end\" pointer? exactly end - start + 1\\n            end++; // move end one by one\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "if you stuck with other solutions with a lot a time, read this one instead.\\n\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        // brainstorm: subarrays with at most K distinct values contains two parts: \\n\\t\\t// subarrays with exactly K distinct values + subarrays with at most K - 1 distinct values\\n        return atMostK(A, K) - atMostK(A, K - 1);\\n    }\\n\\n    private int atMostK(int[] A, int k) {\\n        // use a map to control what we\\'ve seen before, map.size() compared to k during the process.\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int start = 0;\\n        int end = 0;\\n        int res = 0;\\n        while (end < A.length) {\\n            // put it into map anyway\\n            map.put(A[end], map.getOrDefault(A[end], 0) + 1);\\n            \\n            // if map size is larger then k, must reduce it to exactly k by moving start and deleting the count in map\\n            while (map.size() > k) {\\n                map.put(A[start], map.getOrDefault(A[start], 0) - 1);\\n                if (map.get(A[start]) == 0) map.remove(A[start]);\\n                start++;\\n            }\\n            res += end - start + 1; // brainstorm: when you get a range that satisfy at most k distinct values, \\n\\t\\t\\t                                      // how many subarrays are there ending with this \"end\" pointer? exactly end - start + 1\\n            end++; // move end one by one\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1026527,
                "title": "java-souution-using-hashmap-and-solding-window-easy-to-understand",
                "content": "just keep [l,r] with K different integers, then tmp copy l and slide to right until [tmp,r] without k different integers, then we should restore hashMap to record correctly\\n ```java\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        int l = 0, r = 0;\\n        while(r < A.length){\\n            map.put(A[r], map.getOrDefault(A[r], 0) + 1);\\n            while(map.size() > K){\\n                int num = map.get(A[l]);\\n                if(num == 1){ \\n                    map.remove(A[l]);\\n                }\\n                else{\\n                    map.put(A[l], num - 1);\\n                }\\n                l++;\\n            }\\n            \\n            int tmp = l;\\n            while(map.size() == K){\\n                res++;\\n                int num = map.get(A[tmp]);\\n                if(num == 1){ \\n                    map.remove(A[tmp]);\\n                }\\n                else{\\n                    map.put(A[tmp], num - 1);\\n                }\\n                tmp++;\\n            }\\n            while(tmp > l){\\n                tmp--;\\n                map.put(A[tmp], map.getOrDefault(A[tmp], 0) + 1);\\n            }\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        int l = 0, r = 0;\\n        while(r < A.length){\\n            map.put(A[r], map.getOrDefault(A[r], 0) + 1);\\n            while(map.size() > K){\\n                int num = map.get(A[l]);\\n                if(num == 1){ \\n                    map.remove(A[l]);\\n                }\\n                else{\\n                    map.put(A[l], num - 1);\\n                }\\n                l++;\\n            }\\n            \\n            int tmp = l;\\n            while(map.size() == K){\\n                res++;\\n                int num = map.get(A[tmp]);\\n                if(num == 1){ \\n                    map.remove(A[tmp]);\\n                }\\n                else{\\n                    map.put(A[tmp], num - 1);\\n                }\\n                tmp++;\\n            }\\n            while(tmp > l){\\n                tmp--;\\n                map.put(A[tmp], map.getOrDefault(A[tmp], 0) + 1);\\n            }\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992676,
                "title": "simple-c-using-sliding-window",
                "content": "```\\nint findno(vector<int>& nums, int k)\\n{\\n\\tunordered_map<int,int> hashmap;\\n\\tint j=0,count=0;\\n\\tfor(int i=0;i<nums.size();i++)\\n\\t{\\n\\t\\thashmap[nums[i]]++;\\n\\t\\twhile(hashmap.size()>k)\\n\\t\\t{\\n\\t\\t\\thashmap[nums[j]]--;\\n\\t\\t\\tif(hashmap[nums[j]]==0)\\n\\t\\t\\t\\thashmap.erase(nums[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tcount=count+i-j+1;\\n\\t}\\n\\treturn count;\\n}\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n\\treturn findno(nums,k)-findno(nums,k-1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findno(vector<int>& nums, int k)\\n{\\n\\tunordered_map<int,int> hashmap;\\n\\tint j=0,count=0;\\n\\tfor(int i=0;i<nums.size();i++)\\n\\t{\\n\\t\\thashmap[nums[i]]++;\\n\\t\\twhile(hashmap.size()>k)\\n\\t\\t{\\n\\t\\t\\thashmap[nums[j]]--;\\n\\t\\t\\tif(hashmap[nums[j]]==0)\\n\\t\\t\\t\\thashmap.erase(nums[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tcount=count+i-j+1;\\n\\t}\\n\\treturn count;\\n}\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n\\treturn findno(nums,k)-findno(nums,k-1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855975,
                "title": "java-solution-using-sliding-window-and-map",
                "content": "```\\nclass Solution {\\n    \\n    public int subarraysWithKDistinct(int[] ar, int k) {\\n\\t    // exact(k) == atMost(k) + atMost(k - 1)\\n        return atMostK(ar, k) - atMostK(ar, k-1);\\n    }\\n    \\n    private int atMostK(int[] arr, int k) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int left = 0;\\n        int count = 0;\\n        for (int right = 0; right < arr.length; right++) {\\n            int num = arr[right];\\n            addToMap(countMap, num);\\n            while (countMap.size() > k) {\\n                removeFromMap(countMap, arr[left]);\\n                left++;\\n            }\\n            count += right - left + 1;\\n        }\\n        return count;\\n    }\\n    \\n    private void addToMap(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n    }\\n\\n    private void removeFromMap(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) - 1);\\n        if (countMap.get(num) <= 0) {\\n            countMap.remove(num);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int subarraysWithKDistinct(int[] ar, int k) {\\n\\t    // exact(k) == atMost(k) + atMost(k - 1)\\n        return atMostK(ar, k) - atMostK(ar, k-1);\\n    }\\n    \\n    private int atMostK(int[] arr, int k) {\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        int left = 0;\\n        int count = 0;\\n        for (int right = 0; right < arr.length; right++) {\\n            int num = arr[right];\\n            addToMap(countMap, num);\\n            while (countMap.size() > k) {\\n                removeFromMap(countMap, arr[left]);\\n                left++;\\n            }\\n            count += right - left + 1;\\n        }\\n        return count;\\n    }\\n    \\n    private void addToMap(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\\n    }\\n\\n    private void removeFromMap(Map<Integer, Integer> countMap, int num) {\\n        countMap.put(num, countMap.getOrDefault(num, 0) - 1);\\n        if (countMap.get(num) <= 0) {\\n            countMap.remove(num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853831,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def helper(self,A,B):\\n        count = 0\\n        left = 0\\n        right = 0\\n        d = {}\\n        \\n        while right<len(A):\\n            if A[right] not in d:\\n                d[A[right]] = 0\\n            d[A[right]] += 1\\n            \\n            while len(d)>B:\\n                d[A[left]] -= 1\\n                if d[A[left]] == 0:\\n                    d.pop(A[left])\\n                left += 1\\n            \\n            count += right-left+1\\n            right += 1\\n        \\n        return count    \\n                    \\n                \\n    \\n    def subarraysWithKDistinct(self, A: List[int], B: int) -> int:\\n        return self.helper(A,B)-self.helper(A,B-1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self,A,B):\\n        count = 0\\n        left = 0\\n        right = 0\\n        d = {}\\n        \\n        while right<len(A):\\n            if A[right] not in d:\\n                d[A[right]] = 0\\n            d[A[right]] += 1\\n            \\n            while len(d)>B:\\n                d[A[left]] -= 1\\n                if d[A[left]] == 0:\\n                    d.pop(A[left])\\n                left += 1\\n            \\n            count += right-left+1\\n            right += 1\\n        \\n        return count    \\n                    \\n                \\n    \\n    def subarraysWithKDistinct(self, A: List[int], B: int) -> int:\\n        return self.helper(A,B)-self.helper(A,B-1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846543,
                "title": "c-o-n-sliding-window-short-concise-solution-easily-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int subarraysWithAtmostKDistinct(vector<int> nums,int k){\\n        int ans=0,l=0,r=0,n=nums.size(),kCounter=0;\\n        map<int,int> mm;\\n        while(r<n){\\n            if(++mm[nums[r++]]==1){\\n                kCounter++;\\n            }\\n            while(kCounter>k){\\n                if(--mm[nums[l++]]==0)\\n                    kCounter--;\\n            }\\n            ans+=r-l;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return subarraysWithAtmostKDistinct(nums,k)-subarraysWithAtmostKDistinct(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int subarraysWithAtmostKDistinct(vector<int> nums,int k){\\n        int ans=0,l=0,r=0,n=nums.size(),kCounter=0;\\n        map<int,int> mm;\\n        while(r<n){\\n            if(++mm[nums[r++]]==1){\\n                kCounter++;\\n            }\\n            while(kCounter>k){\\n                if(--mm[nums[l++]]==0)\\n                    kCounter--;\\n            }\\n            ans+=r-l;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return subarraysWithAtmostKDistinct(nums,k)-subarraysWithAtmostKDistinct(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788419,
                "title": "python-sliding-window-using-deque",
                "content": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        return self.atmostDiff(A,K) - self.atmostDiff(A,K-1)\\n    \\n    def atmostDiff(self, A, K):\\n        count = 0\\n        temp = collections.deque()\\n        hmap = defaultdict(int)\\n        \\n        for i in A:\\n            temp.append(i)\\n            hmap[i]+=1\\n            \\n            while len(hmap)>K:\\n                front = temp.popleft()\\n                hmap[front]-=1\\n                if hmap[front]==0:\\n                    del hmap[front]\\n                    \\n            count += len(temp)\\n            \\n        return count\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:\\n        return self.atmostDiff(A,K) - self.atmostDiff(A,K-1)\\n    \\n    def atmostDiff(self, A, K):\\n        count = 0\\n        temp = collections.deque()\\n        hmap = defaultdict(int)\\n        \\n        for i in A:\\n            temp.append(i)\\n            hmap[i]+=1\\n            \\n            while len(hmap)>K:\\n                front = temp.popleft()\\n                hmap[front]-=1\\n                if hmap[front]==0:\\n                    del hmap[front]\\n                    \\n            count += len(temp)\\n            \\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 763344,
                "title": "java-hashmap-and-sliding-window",
                "content": "If you found the solution helpful, kindly upvote or like. :)\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atMostK(A, K)-atMostK(A, K-1);\\n    }\\n\\n\\tprivate int atMostK(int[] a, int k) \\n\\t{\\n\\t\\tint left= 0, right=0, res=0;\\n\\t\\tHashMap<Integer, Integer> map= new HashMap<Integer, Integer>();\\n\\t\\twhile(right<a.length)\\n\\t\\t{\\n\\t\\t\\tmap.put(a[right],map.getOrDefault(a[right],0)+1);\\n\\t\\t\\twhile(map.size() >k)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Slide the window from the left\\n\\t\\t\\t\\tmap.put(a[left],map.get(a[left])-1);\\n\\t\\t\\t\\tif(map.get(a[left])==0) map.remove(a[left]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t\\tres += right-left+1;\\n\\t\\t\\tright++;\\n\\t\\t}\\n\\t\\treturn res;\\n    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n        return atMostK(A, K)-atMostK(A, K-1);\\n    }\\n\\n\\tprivate int atMostK(int[] a, int k) \\n\\t{\\n\\t\\tint left= 0, right=0, res=0;\\n\\t\\tHashMap<Integer, Integer> map= new HashMap<Integer, Integer>();\\n\\t\\twhile(right<a.length)\\n\\t\\t{\\n\\t\\t\\tmap.put(a[right],map.getOrDefault(a[right],0)+1);\\n\\t\\t\\twhile(map.size() >k)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Slide the window from the left\\n\\t\\t\\t\\tmap.put(a[left],map.get(a[left])-1);\\n\\t\\t\\t\\tif(map.get(a[left])==0) map.remove(a[left]);\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t}\\n\\t\\t\\tres += right-left+1;\\n\\t\\t\\tright++;\\n\\t\\t}\\n\\t\\treturn res;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596186,
                "title": "c-sliding-window-solution",
                "content": "```\\nclass Solution {\\n    int subarraysWithAtmostK(vector<int>& A, int K) {\\n        int n = A.size();\\n        \\n        unordered_map<int, int>hm;\\n        int res = 0, i = 0, j = 0, count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            hm[A[i]]++;\\n            while (j < n && hm.size() > K) {\\n                hm[A[j]]--;\\n                if (hm[A[j]] == 0)\\n                    hm.erase(A[j]);\\n                j++;\\n            }\\n            \\n            res += (i-j+1);\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return subarraysWithAtmostK(A, K) - subarraysWithAtmostK(A, K-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int subarraysWithAtmostK(vector<int>& A, int K) {\\n        int n = A.size();\\n        \\n        unordered_map<int, int>hm;\\n        int res = 0, i = 0, j = 0, count = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            hm[A[i]]++;\\n            while (j < n && hm.size() > K) {\\n                hm[A[j]]--;\\n                if (hm[A[j]] == 0)\\n                    hm.erase(A[j]);\\n                j++;\\n            }\\n            \\n            res += (i-j+1);\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return subarraysWithAtmostK(A, K) - subarraysWithAtmostK(A, K-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547450,
                "title": "java-well-explained",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n\\t   //At most K - at Most (k-1) gives exactly K - Nothing much to explain here\\n        return atMostK(A, K) - atMostK(A, K-1);\\n    }\\n    \\n    private int atMostK(int[] A, int K) {\\n\\t\\t//If the length of array is smaller than K, this means it\\'s not possible to find a subarray with K different integers, even if the array has Array.length number of distinct integers\\\\\\n        if(A == null || A.length < K) return 0;\\n\\t\\t//Stores frequency of the incoming and outgoing integers \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int i = 0, j = 0, counter = 0, res = 0;\\n        while(j < A.length) {\\n\\t\\t\\t//Right end of the window starts from 0. \\n\\t\\t\\t//Add frequency, or add 1 to every new occurrence \\n            int c = A[j++];\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t\\t\\t//For every DISTINCT integer, increment counter\\n            if(map.get(c) == 1) counter++;\\n            \\n\\t\\t\\t//If counter exceeds K, means, there are more than K distinct integers\\n\\t\\t\\t//This means, we have to reduce the left boundary to come to a value such that Arrays.subarray(left TO right) contains 2 disticnt characters\\n            while(counter > K) {\\n                int d = A[i++];\\n\\t\\t\\t\\t//For every encountered integer, decrement frequency\\n                map.put(d, map.get(d) - 1);\\n\\t\\t\\t\\t//If an integer has been frequented so much, that the window doesn\\'t contain it anymore, decrement counter. Counter should be 2 now \\n                if(map.get(d) == 0) counter--;\\n            }\\n\\t\\t\\t//All subarrays between i and j, boundaries included are subarrays with AT MOST k characters, including each subarray of length 1 and so on. \\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n\\t   //At most K - at Most (k-1) gives exactly K - Nothing much to explain here\\n        return atMostK(A, K) - atMostK(A, K-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 545714,
                "title": "java-solution-using-doubly-linked-list-map-o-n-time-o-k-memory",
                "content": "1. Doubly linked list node has two fields: `val` and `lastIndex`. The `lastIndex` denotes the last occurrence of `val` in input array `A` up to now.\\n2. When we loop the `val` in `A`, we update the `lastIndex` of the occurrence of `A[i]`.\\n3. Use a Map to track the number of distinct values.\\n4. The number of K-value subarray found in each step is \\n```\\nif(map.size() == K) {\\n      cnt += (head.next.lastIndex - st);\\n}\\n```\\n5. Do not forget to update `st`.\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\tDoublyListNode head = new DoublyListNode(Integer.MIN_VALUE, -1);\\n        DoublyListNode tail = new DoublyListNode(Integer.MAX_VALUE, A.length);\\n        head.next = tail;\\n        tail.prev = head;\\n        Map<Integer, DoublyListNode> map = new HashMap<>();\\n        int cnt = 0, st = -1;\\n        for(int i = 0; i < A.length; ++i) {\\n            DoublyListNode curr;\\n            if(map.containsKey(A[i])) {\\n                curr = map.get(A[i]);\\n                curr.prev.next = curr.next;\\n                curr.next.prev = curr.prev;\\n                curr.prev = null;\\n                curr.next = null;\\n                curr.lastIndex = i;\\n            } else {\\n                curr = new DoublyListNode(A[i], i);\\n            }\\n\\n            tail.prev.next = curr;\\n            curr.prev = tail.prev;\\n            curr.next = tail;\\n            tail.prev = curr;\\n            map.put(A[i], curr);\\n            if(map.size() > K) {\\n                DoublyListNode first = head.next;\\n                st = first.lastIndex;\\n                head.next = first.next;\\n                first.next.prev = head;\\n                first.next = null;\\n                first.prev = null;\\n                map.remove(first.val);\\n            }\\n\\n            if(map.size() == K) {\\n                cnt += (head.next.lastIndex - st);\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    class DoublyListNode {\\n        int val;\\n        int lastIndex;\\n        DoublyListNode prev, next;\\n        public DoublyListNode(int val, int lastIndex) {\\n            this.val = val;\\n            this.lastIndex = lastIndex;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif(map.size() == K) {\\n      cnt += (head.next.lastIndex - st);\\n}\\n```\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\tDoublyListNode head = new DoublyListNode(Integer.MIN_VALUE, -1);\\n        DoublyListNode tail = new DoublyListNode(Integer.MAX_VALUE, A.length);\\n        head.next = tail;\\n        tail.prev = head;\\n        Map<Integer, DoublyListNode> map = new HashMap<>();\\n        int cnt = 0, st = -1;\\n        for(int i = 0; i < A.length; ++i) {\\n            DoublyListNode curr;\\n            if(map.containsKey(A[i])) {\\n                curr = map.get(A[i]);\\n                curr.prev.next = curr.next;\\n                curr.next.prev = curr.prev;\\n                curr.prev = null;\\n                curr.next = null;\\n                curr.lastIndex = i;\\n            } else {\\n                curr = new DoublyListNode(A[i], i);\\n            }\\n\\n            tail.prev.next = curr;\\n            curr.prev = tail.prev;\\n            curr.next = tail;\\n            tail.prev = curr;\\n            map.put(A[i], curr);\\n            if(map.size() > K) {\\n                DoublyListNode first = head.next;\\n                st = first.lastIndex;\\n                head.next = first.next;\\n                first.next.prev = head;\\n                first.next = null;\\n                first.prev = null;\\n                map.remove(first.val);\\n            }\\n\\n            if(map.size() == K) {\\n                cnt += (head.next.lastIndex - st);\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    class DoublyListNode {\\n        int val;\\n        int lastIndex;\\n        DoublyListNode prev, next;\\n        public DoublyListNode(int val, int lastIndex) {\\n            this.val = val;\\n            this.lastIndex = lastIndex;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467333,
                "title": "java-o-n-sliding-window-two-pointers",
                "content": "Key Insights.\\n\\n1) Use a sliding window.\\n2) Keep track of the leftmost element in the window that if removed decreases the distinct number of integers in the window.\\n\\nwStartIndex = start of the window.\\nz = leftmost element in the window that if removed would decrease the number of different integers in the window.\\n\\nlastOccurrence  = A map of the rightmost index of each element in the window.\\nE.G. [(1, 1, 2, 1)] The map contains 1 -> 3, 2 -> 2.\\nThis is used to advance z as the window advances as well as count the number of distinct integers in the window.\\n\\nCounting good Sub Arrays (k=2)\\n\\nWhen the window slides from [(2, 2, 1), 2] -> [(2, 2, 1, 2)] (z = 2, wStartIndex = 0)\\nadd the following 3 good sub arrays: [2, 2, 1, 2], [2, 1, 2], [1, 2]\\n2 - 0 + 1 = 3 (z - wStartIndex + 1)\\n \\n ```java\\n public int subarraysWithKDistinct(int[] A, int K) {\\n    Map<Integer, Integer> lastOccurrence = new HashMap<>();\\n    int count = 0;\\n    int wStartIndex = 0;\\n    // leftmost element in the window that if removed would \\n    // decrease the number of different integers in the window.\\n    int z = 0;\\n\\n    for (int wEndIndex = 0; wEndIndex < A.length; wEndIndex++) {\\n      lastOccurrence.put(A[wEndIndex], wEndIndex);\\n      if (lastOccurrence.size() > K) {\\n        lastOccurrence.remove(A[z]);\\n        z++;\\n        wStartIndex = z;\\n      }\\n\\t  // Advance z until it is the rightmost occurance of that integer in the window.\\n      while(z < lastOccurrence.get(A[z])) {\\n        z++;\\n      }\\n      if (lastOccurrence.size() == K) {\\n        count += (z - wStartIndex) + 1;\\n      }\\n    }\\n    return count;\\n  }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int subarraysWithKDistinct(int[] A, int K) {\\n    Map<Integer, Integer> lastOccurrence = new HashMap<>();\\n    int count = 0;\\n    int wStartIndex = 0;\\n    // leftmost element in the window that if removed would \\n    // decrease the number of different integers in the window.\\n    int z = 0;\\n\\n    for (int wEndIndex = 0; wEndIndex < A.length; wEndIndex++) {\\n      lastOccurrence.put(A[wEndIndex], wEndIndex);\\n      if (lastOccurrence.size() > K) {\\n        lastOccurrence.remove(A[z]);\\n        z++;\\n        wStartIndex = z;\\n      }\\n\\t  // Advance z until it is the rightmost occurance of that integer in the window.\\n      while(z < lastOccurrence.get(A[z])) {\\n        z++;\\n      }\\n      if (lastOccurrence.size() == K) {\\n        count += (z - wStartIndex) + 1;\\n      }\\n    }\\n    return count;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444192,
                "title": "java-easy-to-understand-sliding-window-solution-with-inline-comments",
                "content": "```\\npublic int subarraysWithKDistinct(int[] A, int K) {\\n        if(A==null || A.length==0) return 0;\\n        \\n        int count=0;\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        Map<Integer, Integer> map2 = new HashMap<>();\\n        int idx1=0, idx2=0;\\n        for(int i=0; i< A.length; i++){\\n            Integer num = A[i];\\n            map1.put(num, map1.getOrDefault(num, 0)+1);\\n            map2.put(num, map2.getOrDefault(num, 0)+1);\\n            \\n            //the longest qualified subarray (K distinct numbers) till now: [idx1, i]\\n            while(map1.size() > K){\\n                Integer remove = A[idx1++];\\n                int rc = map1.get(remove);\\n                if(rc == 1) map1.remove(remove);\\n                else map1.put(remove, rc-1);\\n            }\\n            \\n            //the longest non-qualified (K-1 distinct numbers) subarray till now: [idx2, i]\\n            while(map2.size() >= K){\\n                Integer remove = A[idx2++];\\n                int rc = map2.get(remove);\\n                if(rc == 1) map2.remove(remove);\\n                else map2.put(remove, rc-1);\\n            }\\n            \\n            //With idx1 and idx2, it is safe to remove the numbers between [idx1, idx2) but still maintain the qualification state of map1.\\n            //In other words, each of the extra element between [idx1, idx2) contributes a new combination of qualified subarray ending with i.\\n\\t\\t\\t//For example, [idx1 ... i], [idx1+1 ... i] ... [idx2-1 ... i]\\n            int prefixCount = idx2-idx1;\\n            count += prefixCount;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int subarraysWithKDistinct(int[] A, int K) {\\n        if(A==null || A.length==0) return 0;\\n        \\n        int count=0;\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        Map<Integer, Integer> map2 = new HashMap<>();\\n        int idx1=0, idx2=0;\\n        for(int i=0; i< A.length; i++){\\n            Integer num = A[i];\\n            map1.put(num, map1.getOrDefault(num, 0)+1);\\n            map2.put(num, map2.getOrDefault(num, 0)+1);\\n            \\n            //the longest qualified subarray (K distinct numbers) till now: [idx1, i]\\n            while(map1.size() > K){\\n                Integer remove = A[idx1++];\\n                int rc = map1.get(remove);\\n                if(rc == 1) map1.remove(remove);\\n                else map1.put(remove, rc-1);\\n            }\\n            \\n            //the longest non-qualified (K-1 distinct numbers) subarray till now: [idx2, i]\\n            while(map2.size() >= K){\\n                Integer remove = A[idx2++];\\n                int rc = map2.get(remove);\\n                if(rc == 1) map2.remove(remove);\\n                else map2.put(remove, rc-1);\\n            }\\n            \\n            //With idx1 and idx2, it is safe to remove the numbers between [idx1, idx2) but still maintain the qualification state of map1.\\n            //In other words, each of the extra element between [idx1, idx2) contributes a new combination of qualified subarray ending with i.\\n\\t\\t\\t//For example, [idx1 ... i], [idx1+1 ... i] ... [idx2-1 ... i]\\n            int prefixCount = idx2-idx1;\\n            count += prefixCount;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429241,
                "title": "short-clean-java-with-hashmap-and-2-pointer",
                "content": "This is again the same redundant hashmap implementation, couldnt see anyone posting easy hashmap based short solution, hence posting this.\\n```\\n    public int subarraysWithKDistinct(int[] arr, int k) {\\n        if(k==0) return 0;\\n        int n = arr.length;\\n        Map < Integer, Integer > map = new HashMap < > ();\\n        int i = 0, j = 0, total = 0;\\n        while (j < arr.length) {\\n            map.put(arr[j], map.getOrDefault(arr[j], 0) + 1);\\n            if (map.size() == k) {\\n                int dups = j;\\n                while ((dups + 1) < n && map.containsKey(arr[dups + 1])) dups++;\\n                while (map.size() == k) {\\n                    total += (dups - j) + 1;\\n                    int removable = arr[i];\\n                    map.put(removable, map.get(removable) - 1);\\n                    if (map.get(removable) == 0) map.remove(removable);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return total;\\n\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public int subarraysWithKDistinct(int[] arr, int k) {\\n        if(k==0) return 0;\\n        int n = arr.length;\\n        Map < Integer, Integer > map = new HashMap < > ();\\n        int i = 0, j = 0, total = 0;\\n        while (j < arr.length) {\\n            map.put(arr[j], map.getOrDefault(arr[j], 0) + 1);\\n            if (map.size() == k) {\\n                int dups = j;\\n                while ((dups + 1) < n && map.containsKey(arr[dups + 1])) dups++;\\n                while (map.size() == k) {\\n                    total += (dups - j) + 1;\\n                    int removable = arr[i];\\n                    map.put(removable, map.get(removable) - 1);\\n                    if (map.get(removable) == 0) map.remove(removable);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return total;\\n\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 408810,
                "title": "clean-javascript-solution-atmost",
                "content": "Reference https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)\\n\\n```\\nfunction subarraysWithKDistinct(A, K) {\\n  function atMostK(k) {\\n    let l = 0;\\n    let res = 0;\\n    const count = {};\\n\\n    for (let r = 0; r < A.length; r++) {\\n      if (count[A[r]] == null) count[A[r]] = 0;\\n      if (count[A[r]] === 0) k--;\\n      count[A[r]]++;\\n\\n      while (k < 0) {\\n        count[A[l]]--;\\n        if (count[A[l]] === 0) k++;\\n        l++;\\n      }\\n      res += r - l + 1;\\n    }\\n    return res;\\n  }\\n\\n  return atMostK(K) - atMostK(K - 1);\\n}\\n```\\n\\nMore at https://github.com/Hongbo-Miao/leetcode",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction subarraysWithKDistinct(A, K) {\\n  function atMostK(k) {\\n    let l = 0;\\n    let res = 0;\\n    const count = {};\\n\\n    for (let r = 0; r < A.length; r++) {\\n      if (count[A[r]] == null) count[A[r]] = 0;\\n      if (count[A[r]] === 0) k--;\\n      count[A[r]]++;\\n\\n      while (k < 0) {\\n        count[A[l]]--;\\n        if (count[A[l]] === 0) k++;\\n        l++;\\n      }\\n      res += r - l + 1;\\n    }\\n    return res;\\n  }\\n\\n  return atMostK(K) - atMostK(K - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 372136,
                "title": "subarrays-with-k-different-integers-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\t\\treturn atMostK(A, K) - atMostK(A, K - 1);\\n\\t\\t}\\n\\t\\tprivate int atMostK(int[] A, int K) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tfor (int j = 0; j < A.length; j++) {\\n\\t\\t\\t\\tif (map.getOrDefault(A[j], 0) == 0) K--;\\n\\t\\t\\t\\tmap.put(A[j], map.getOrDefault(A[j], 0) + 1);\\n\\t\\t\\t\\twhile (K < 0) {\\n\\t\\t\\t\\t\\tmap.put(A[i], map.get(A[i]) - 1);\\n\\t\\t\\t\\t\\tif (map.get(A[i]) == 0) K++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres += j - i + 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int subarraysWithKDistinct(int[] A, int K) {\\n\\t\\t\\treturn atMostK(A, K) - atMostK(A, K - 1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 235777,
                "title": "javascript-o-n-solution",
                "content": "```\\nconst subarraysWithKDistinct = (A, K) => {\\n  let ans = 0;\\n  let l = 0, r = 0;\\n  let leftUniques = 0;\\n  let leftDic = {};\\n  let rightUniques = 0;\\n  let rightDic = {};\\n  for (let i = 0; i < A.length; i++) {\\n    leftDic[A[i]] = leftDic[A[i]] ? leftDic[A[i]] + 1 : 1;\\n    rightDic[A[i]] = rightDic[A[i]] ? rightDic[A[i]] + 1 : 1;\\n    if (leftDic[A[i]] === 1) leftUniques++;\\n    if (rightDic[A[i]] === 1) rightUniques++;\\n\\n    while (leftUniques > K) {\\n      if (leftDic[A[l]] === 1) {\\n        leftUniques--;\\n      }\\n      leftDic[A[l]] -= 1;\\n      l++;\\n    }\\n\\n    while (rightUniques >= K) {\\n      if (rightDic[A[r]] === 1) {\\n        rightUniques--;\\n      }\\n      rightDic[A[r]] -= 1;\\n      r++;\\n    }\\n    ans += r - l;\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst subarraysWithKDistinct = (A, K) => {\\n  let ans = 0;\\n  let l = 0, r = 0;\\n  let leftUniques = 0;\\n  let leftDic = {};\\n  let rightUniques = 0;\\n  let rightDic = {};\\n  for (let i = 0; i < A.length; i++) {\\n    leftDic[A[i]] = leftDic[A[i]] ? leftDic[A[i]] + 1 : 1;\\n    rightDic[A[i]] = rightDic[A[i]] ? rightDic[A[i]] + 1 : 1;\\n    if (leftDic[A[i]] === 1) leftUniques++;\\n    if (rightDic[A[i]] === 1) rightUniques++;\\n\\n    while (leftUniques > K) {\\n      if (leftDic[A[l]] === 1) {\\n        leftUniques--;\\n      }\\n      leftDic[A[l]] -= 1;\\n      l++;\\n    }\\n\\n    while (rightUniques >= K) {\\n      if (rightDic[A[r]] === 1) {\\n        rightUniques--;\\n      }\\n      rightDic[A[r]] -= 1;\\n      r++;\\n    }\\n    ans += r - l;\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234915,
                "title": "c-two-pointers-o-n-time-solution-with-o-k-space",
                "content": "The basic idea is first find a \"base\" index interval `[L, R]` which contains `K` distinct elements in `A`, and then try to expand it to the right such that it still contains only these `K` elements. For each feasible extension, suppose the right end is `R1`, and let `L1` be the largest index such that `[L1, R1]` contains these `K` elements, then we know we have `L1 - L + 1` more feasible subarrays, i.e., `A[L:R1]`, `A[(L+1):R1]`, ..., and `A[L1:R1]`.\\n\\nIn order to achieve this, we use two pointers i and j starting from 0, and a hashmap `cntMap` to store the frequency per elements in some sliding window of `A`.\\n\\nWe move right pointer `j` until interval `[i, j-1]` contains `K` distinct elements, that is, `cntMap.size() == K`. By now we have found a base interval. Then, for every index `r` in `[j-1, A.size())`, if `A[r]` is one of the `K` distinct elements we have got, that is, `A[r]` is in `cntMap`, then we have found a feasible extension; now we use a temporary left pointer `l` starting from `i`, and move it to right, during which we decrease the frequency of `A[l]` by `1`, until `A[l]` is already `1`, which implies that `l` is the largest index such that the subarray `A[l...r]` contains those `K` elements, so we increment the result by `l - i + 1`. When we find the first `r` such that `A[r]` is not in `cntMap`, then it means that the current interval `[i, j)` cannot be extended anymore, so we update `i = l + 1` and `j = r`, and try to find the next base interval and repeat the process, until `r` hits `A.size()`.\\n\\nTime and space complexity: in the algorithm, `i`, `j`, `l`, and `r` are always going right, so the time complexity is `O(n)`. Size of the hashmap will not go beyond `K`, so the space complexity is `O(K)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int n = A.size();\\n        unordered_map<int, int> cntMap;\\n        int i = 0, j = 0;\\n        int res = 0;\\n        \\n        while (i < n && j < n) {\\n            // Find a feasible base interval [i, j)\\n            while (j < n && cntMap.size() < K) {\\n                ++cntMap[A[j++]];\\n            }\\n            \\n            // Try to extend [i, j)\\n            if (cntMap.size() == K) {\\n                int r = j - 1;\\n                int l = i;\\n                \\n                for (; r < n && cntMap.find(A[r]) != cntMap.end(); ++r) {\\n                    if (r >= j) {\\n                        ++cntMap[A[r]];\\n                    }\\n                    \\n                    // If A[r] is not a new element, then fix r and see how far we can move l\\n                    for (; l < n; ++l) {\\n                        if (cntMap[A[l]] == 1)\\n                            break;\\n                        else\\n                            --cntMap[A[l]];\\n                    }\\n                    \\n                    // l is the far right index we can go such that A[l...r] is a feasible sub-array\\n                    // We know that A[i:r], A[(i+1):r], ..., and A[l...r] are all feasible\\n                    res += l - i + 1;\\n                }\\n                \\n                // Now l exits the sliding window, update cntMap[A[l]]\\n                if (l < n && --cntMap[A[l]] == 0) {\\n                    cntMap.erase(A[l]);\\n                }\\n                \\n                // Update the two-pointer position to find next base interval\\n                i = l + 1;\\n                j = r;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        int n = A.size();\\n        unordered_map<int, int> cntMap;\\n        int i = 0, j = 0;\\n        int res = 0;\\n        \\n        while (i < n && j < n) {\\n            // Find a feasible base interval [i, j)\\n            while (j < n && cntMap.size() < K) {\\n                ++cntMap[A[j++]];\\n            }\\n            \\n            // Try to extend [i, j)\\n            if (cntMap.size() == K) {\\n                int r = j - 1;\\n                int l = i;\\n                \\n                for (; r < n && cntMap.find(A[r]) != cntMap.end(); ++r) {\\n                    if (r >= j) {\\n                        ++cntMap[A[r]];\\n                    }\\n                    \\n                    // If A[r] is not a new element, then fix r and see how far we can move l\\n                    for (; l < n; ++l) {\\n                        if (cntMap[A[l]] == 1)\\n                            break;\\n                        else\\n                            --cntMap[A[l]];\\n                    }\\n                    \\n                    // l is the far right index we can go such that A[l...r] is a feasible sub-array\\n                    // We know that A[i:r], A[(i+1):r], ..., and A[l...r] are all feasible\\n                    res += l - i + 1;\\n                }\\n                \\n                // Now l exits the sliding window, update cntMap[A[l]]\\n                if (l < n && --cntMap[A[l]] == 0) {\\n                    cntMap.erase(A[l]);\\n                }\\n                \\n                // Update the two-pointer position to find next base interval\\n                i = l + 1;\\n                j = r;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234542,
                "title": "python-two-pointer-one-sliding-window-o-n-solution",
                "content": "The idea is to keep the invariant that the sliding window contains K different integers, shrink the sliding window form left as much as we can, and keep track of the number of subarrays ending at each position. The time complexity is O(N), and the space complexity is O(K).\\nThank @h11129 for pointing out the redundancy in my original version! The modified version is as follows.\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        count = collections.Counter()\\n        ans = dp = 0\\n        i = 0\\n        for j in range(len(A)):\\n            count[A[j]] += 1\\n            if len(count) < K:\\n                continue\\n            elif len(count) == K:\\n                dp = max(dp, 1)\\n            else:\\n                del count[A[i]]\\n                i += 1\\n                dp = 1\\n            while count[A[i]] != 1:\\n                dp += 1\\n                count[A[i]] -= 1\\n                i += 1\\n            ans += dp\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarraysWithKDistinct(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        count = collections.Counter()\\n        ans = dp = 0\\n        i = 0\\n        for j in range(len(A)):\\n            count[A[j]] += 1\\n            if len(count) < K:\\n                continue\\n            elif len(count) == K:\\n                dp = max(dp, 1)\\n            else:\\n                del count[A[i]]\\n                i += 1\\n                dp = 1\\n            while count[A[i]] != 1:\\n                dp += 1\\n                count[A[i]] -= 1\\n                i += 1\\n            ans += dp\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040769,
                "title": "java-solution-sliding-window",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return helper(nums, k) - helper(nums, k-1);\\n    }\\n\\n    private int helper(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int count = 0, left = 0;\\n        for(int right = 0; right < nums.length; right++) {\\n            map.put(nums[right], map.getOrDefault(nums[right], 0) + 1);\\n\\n            while(map.size() > k) {\\n                if(map.get(nums[left]) == 1)  map.remove(nums[left]);\\n                else map.put(nums[left], map.getOrDefault(nums[left], 0) - 1);\\n                left++;\\n            } \\n\\n            count += (right - left + 1);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return helper(nums, k) - helper(nums, k-1);\\n    }\\n\\n    private int helper(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int count = 0, left = 0;\\n        for(int right = 0; right < nums.length; right++) {\\n            map.put(nums[right], map.getOrDefault(nums[right], 0) + 1);\\n\\n            while(map.size() > k) {\\n                if(map.get(nums[left]) == 1)  map.remove(nums[left]);\\n                else map.put(nums[left], map.getOrDefault(nums[left], 0) - 1);\\n                left++;\\n            } \\n\\n            count += (right - left + 1);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891761,
                "title": "sliding-window-easy",
                "content": "**Similar ::**\\n***2799. Count Complete Subarrays in an Array***\\n**>>>** https://leetcode.com/problems/count-complete-subarrays-in-an-array/solutions/3891740/sliding-window-easy/\\n\\n________________________________\\n\\n# Approach  : at most *K* subsets\\n```\\nclass Solution {\\n     public int subarraysWithKDistinct(int[] nums, int k) {\\n         return f(nums,k)-f(nums,k-1);\\n     }\\n    public int f(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int si=0;\\n        int ei=0;\\n        int count=0;\\n        while(ei<nums.length){\\n            map.put(nums[ei], map.getOrDefault(nums[ei], 0) + 1);\\n            while(map.size()>k){\\n\\t\\t\\t\\tif(map.get(nums[si]) > 1) {\\n\\t\\t\\t\\t\\tmap.put(nums[si], map.get(nums[si]) - 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmap.remove(nums[si]);\\n\\t\\t\\t\\t}\\n               si++;\\n            }\\n            count+=ei-si+1;\\n            ei++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n________________________________\\n\\n**Upvote if helps**\\n![image.png](https://assets.leetcode.com/users/images/f18ccf7b-bb7d-4a8e-8622-2f0acbd705cc_1683886081.2272806.png)\\n\\n________________________________",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n     public int subarraysWithKDistinct(int[] nums, int k) {\\n         return f(nums,k)-f(nums,k-1);\\n     }\\n    public int f(int[] nums, int k) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int si=0;\\n        int ei=0;\\n        int count=0;\\n        while(ei<nums.length){\\n            map.put(nums[ei], map.getOrDefault(nums[ei], 0) + 1);\\n            while(map.size()>k){\\n\\t\\t\\t\\tif(map.get(nums[si]) > 1) {\\n\\t\\t\\t\\t\\tmap.put(nums[si], map.get(nums[si]) - 1);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmap.remove(nums[si]);\\n\\t\\t\\t\\t}\\n               si++;\\n            }\\n            count+=ei-si+1;\\n            ei++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662013,
                "title": "simple-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int atmost(int[]nums,int n ,int k){\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            map.put(nums[j],map.getOrDefault(nums[j], 0)+1);\\n            while(map.size()>k){\\n                map.put(nums[i],map.get(nums[i])-1);\\n               \\n                if(map.get(nums[i])==0)map.remove(nums[i]);\\n                 i++;\\n            }\\n            count+=j-i+1;\\n            j++;\\n        }\\n        return count;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n         int n=nums.length;\\n        return atmost(nums,n,k)-atmost(nums,n,k-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int atmost(int[]nums,int n ,int k){\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n){\\n            map.put(nums[j],map.getOrDefault(nums[j], 0)+1);\\n            while(map.size()>k){\\n                map.put(nums[i],map.get(nums[i])-1);\\n               \\n                if(map.get(nums[i])==0)map.remove(nums[i]);\\n                 i++;\\n            }\\n            count+=j-i+1;\\n            j++;\\n        }\\n        return count;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n         int n=nums.length;\\n        return atmost(nums,n,k)-atmost(nums,n,k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503714,
                "title": "kotlin-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\\n        return atMostK(nums, k) - atMostK(nums, k - 1)\\n    }\\n\\n    fun atMostK(nums: IntArray, _k: Int): Int {\\n        var result = 0\\n        var i = 0\\n        var k = _k\\n        var cache = HashMap<Int, Int>()\\n\\n        for (j in nums.indices) {\\n            if (cache.getOrDefault(nums[j], 0) == 0) k--\\n            cache.put(nums[j], cache.getOrDefault(nums[j], 0) + 1)\\n\\n            while (k < 0) {\\n                cache.put(nums[i], cache.getOrDefault(nums[i], 1) - 1)\\n                if (cache.getOrDefault(nums[i], 0) == 0) k++\\n                i++\\n            }\\n\\n            result += j - i + 1\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\\n        return atMostK(nums, k) - atMostK(nums, k - 1)\\n    }\\n\\n    fun atMostK(nums: IntArray, _k: Int): Int {\\n        var result = 0\\n        var i = 0\\n        var k = _k\\n        var cache = HashMap<Int, Int>()\\n\\n        for (j in nums.indices) {\\n            if (cache.getOrDefault(nums[j], 0) == 0) k--\\n            cache.put(nums[j], cache.getOrDefault(nums[j], 0) + 1)\\n\\n            while (k < 0) {\\n                cache.put(nums[i], cache.getOrDefault(nums[i], 1) - 1)\\n                if (cache.getOrDefault(nums[i], 0) == 0) k++\\n                i++\\n            }\\n\\n            result += j - i + 1\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383664,
                "title": "three-pointer-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThree-pointer approach :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAllways keep the right pointer to the right most while the number of different integers is equal to K\\nMiddle pointer should point the place where the number of different integers is exactly k\\nLeft pointer should always delete one number at a time from the left\\nans+=(right-mid+1)\\n\\n# Complexity\\n- Time complexity: O(n) Just one Pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you like my solution.\\n\\n# Code\\n```\\nclass Solution {\\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\\n    val all = hashMapOf<Int, Int>()\\n    val small = hashMapOf<Int, Int>()\\n    all[nums[0]] = 1\\n    small[nums[0]] = 1\\n    var r = 1\\n    var mid = 1\\n    var ans = 0\\n    for (l in 0 until nums.size) {\\n        while (mid < nums.size && small.size != k) {\\n            small[nums[mid]] = small.getOrDefault(nums[mid], 0) + 1\\n            mid++\\n        }\\n        while (r < nums.size && (all.containsKey(nums[r]) || all.size < k)) {\\n            all[nums[r]] = all.getOrDefault(nums[r], 0) + 1\\n            r++\\n        }\\n        if (small.size == k) {\\n            ans+=(r-mid+1)\\n        }\\n        small[nums[l]] = small.getOrDefault(nums[l], 0) - 1\\n        if (small[nums[l]] == 0)\\n            small.remove(nums[l])\\n        all[nums[l]] = all.getOrDefault(nums[l], 0) - 1\\n        if (all[nums[l]] == 0)\\n            all.remove(nums[l])\\n    }\\n    return ans\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {\\n    val all = hashMapOf<Int, Int>()\\n    val small = hashMapOf<Int, Int>()\\n    all[nums[0]] = 1\\n    small[nums[0]] = 1\\n    var r = 1\\n    var mid = 1\\n    var ans = 0\\n    for (l in 0 until nums.size) {\\n        while (mid < nums.size && small.size != k) {\\n            small[nums[mid]] = small.getOrDefault(nums[mid], 0) + 1\\n            mid++\\n        }\\n        while (r < nums.size && (all.containsKey(nums[r]) || all.size < k)) {\\n            all[nums[r]] = all.getOrDefault(nums[r], 0) + 1\\n            r++\\n        }\\n        if (small.size == k) {\\n            ans+=(r-mid+1)\\n        }\\n        small[nums[l]] = small.getOrDefault(nums[l], 0) - 1\\n        if (small[nums[l]] == 0)\\n            small.remove(nums[l])\\n        all[nums[l]] = all.getOrDefault(nums[l], 0) - 1\\n        if (all[nums[l]] == 0)\\n            all.remove(nums[l])\\n    }\\n    return ans\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280465,
                "title": "javascript-992-subarrays-with-k-different-integers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nA good solution\\n\\n1\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Map();\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (!m.has(a[R])) uniq++;\\n                m.set(a[R], (m.get(a[R]) || 0) + 1);\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m.set(a[L], (m.get(a[L]) || 0) - 1);\\n            if (m.get(a[L]) === 0) {\\n                m.delete(a[L]);\\n                uniq--;\\n            }\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t + 1) - atLeast(a, t);\\n};\\n```\\n\\n2\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Array(n + 1).fill(0);\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (m[a[R]] === 0) uniq++;\\n                m[a[R]]++;\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m[a[L]]--;\\n            if (m[a[L]] === 0) uniq--;\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t + 1) - atLeast(a, t);\\n};\\n```\\n\\n3\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Array(n + 1).fill(0);\\n        let uniq = 0;\\n        let L = 0;\\n        let cc = 0;\\n        for (let R = 0; R < n; R++) {\\n            if (m[a[R]] === 0) uniq++;\\n            m[a[R]]++;\\n            for (; uniq > t; L++) {\\n                m[a[L]]--;\\n                if (m[a[L]] === 0) uniq--;\\n            }\\n            cc += R - L + 1;\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t) - atLeast(a, t - 1);\\n};\\n```\\n\\n4\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    class MapUnique {\\n        m = new Map();\\n        uniq = 0;\\n\\n        get size() {\\n            return this.uniq;\\n        }\\n        inc(e) {\\n            if (this.m.has(e) === false) this.uniq++;\\n            this.m.set(e, (this.m.get(e) || 0) + 1);\\n        }\\n        dec(e) {\\n            this.m.set(e, (this.m.get(e) || 0) - 1);\\n            if (this.m.get(e) === 0) {\\n                this.m.delete(e);\\n                this.uniq--;\\n            }\\n        }\\n    }\\n    let m1 = new MapUnique();\\n    let m2 = new MapUnique();\\n    let n = a.length;\\n    let cc = 0;\\n    let L = 0;\\n    let R = 0;\\n    for (let i = 0; i < n; i++) {\\n        while (L < n && m1.size < t) {\\n            m1.inc(a[L]);\\n            L += 1;\\n        }\\n        while (R < n && m2.size < t + 1) {\\n            m2.inc(a[R]);\\n            R += 1;\\n        }\\n        if (m1.size < t) {\\n            break;\\n        }\\n        if (m2.size < t + 1) {\\n            R = n + 1;\\n        }\\n        cc += R - L;\\n        m1.dec(a[i]);\\n        m2.dec(a[i]);\\n    }\\n    return cc;\\n};\\n```\\n\\n5\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        cc = 0,\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        m = new Array(n + 1).fill(0);\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) uniques++;\\n        m[e]++;\\n\\n        while (uniques > t) {\\n            m[a[L]]--;\\n            if (m[a[L]] === 0) {\\n                uniques--;\\n                leftMostExtra = 0;\\n            }\\n            L++;\\n        }\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            leftMostExtra++;\\n            L++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n6\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        cc = 0,\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        m = new Array(n + 1).fill(0);\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) uniques++;\\n        m[e]++;\\n\\n        if (uniques > t) {\\n            m[a[L]]--;\\n            uniques--;\\n            leftMostExtra = 0;\\n            L++;\\n        }\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            leftMostExtra++;\\n            L++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n7\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        m = new Array(n + 1).fill(0),\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        cc = 0;\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) {\\n            uniques++;\\n            if (uniques > t) {\\n                m[a[L]]--;\\n                uniques--;\\n                L++;\\n                leftMostExtra = 0;\\n            }\\n        }\\n        m[e]++;\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            L++;\\n            leftMostExtra++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n8\\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        m = new Array(n + 1).fill(0),\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        cc = 0;\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) {\\n            uniques++;\\n            if (uniques > t) {\\n                m[a[L]]--;\\n                uniques--;\\n                L++;\\n                leftMostExtra = 0;\\n            }\\n        }\\n        m[e]++;\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            L++;\\n            leftMostExtra++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Map();\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (!m.has(a[R])) uniq++;\\n                m.set(a[R], (m.get(a[R]) || 0) + 1);\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m.set(a[L], (m.get(a[L]) || 0) - 1);\\n            if (m.get(a[L]) === 0) {\\n                m.delete(a[L]);\\n                uniq--;\\n            }\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t + 1) - atLeast(a, t);\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Array(n + 1).fill(0);\\n        let cc = 0;\\n        let uniq = 0;\\n        let R = 0;\\n        for (let L = 0; L < n; L++) {\\n            for (; R < n && uniq < t; R++) {\\n                if (m[a[R]] === 0) uniq++;\\n                m[a[R]]++;\\n            }\\n            cc += R;\\n            if (uniq >= t) cc--;\\n            m[a[L]]--;\\n            if (m[a[L]] === 0) uniq--;\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t + 1) - atLeast(a, t);\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    var atLeast = function (a, t) {\\n        let n = a.length;\\n        let m = new Array(n + 1).fill(0);\\n        let uniq = 0;\\n        let L = 0;\\n        let cc = 0;\\n        for (let R = 0; R < n; R++) {\\n            if (m[a[R]] === 0) uniq++;\\n            m[a[R]]++;\\n            for (; uniq > t; L++) {\\n                m[a[L]]--;\\n                if (m[a[L]] === 0) uniq--;\\n            }\\n            cc += R - L + 1;\\n        }\\n        return cc;\\n    };\\n\\n    return atLeast(a, t) - atLeast(a, t - 1);\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    class MapUnique {\\n        m = new Map();\\n        uniq = 0;\\n\\n        get size() {\\n            return this.uniq;\\n        }\\n        inc(e) {\\n            if (this.m.has(e) === false) this.uniq++;\\n            this.m.set(e, (this.m.get(e) || 0) + 1);\\n        }\\n        dec(e) {\\n            this.m.set(e, (this.m.get(e) || 0) - 1);\\n            if (this.m.get(e) === 0) {\\n                this.m.delete(e);\\n                this.uniq--;\\n            }\\n        }\\n    }\\n    let m1 = new MapUnique();\\n    let m2 = new MapUnique();\\n    let n = a.length;\\n    let cc = 0;\\n    let L = 0;\\n    let R = 0;\\n    for (let i = 0; i < n; i++) {\\n        while (L < n && m1.size < t) {\\n            m1.inc(a[L]);\\n            L += 1;\\n        }\\n        while (R < n && m2.size < t + 1) {\\n            m2.inc(a[R]);\\n            R += 1;\\n        }\\n        if (m1.size < t) {\\n            break;\\n        }\\n        if (m2.size < t + 1) {\\n            R = n + 1;\\n        }\\n        cc += R - L;\\n        m1.dec(a[i]);\\n        m2.dec(a[i]);\\n    }\\n    return cc;\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        cc = 0,\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        m = new Array(n + 1).fill(0);\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) uniques++;\\n        m[e]++;\\n\\n        while (uniques > t) {\\n            m[a[L]]--;\\n            if (m[a[L]] === 0) {\\n                uniques--;\\n                leftMostExtra = 0;\\n            }\\n            L++;\\n        }\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            leftMostExtra++;\\n            L++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        cc = 0,\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        m = new Array(n + 1).fill(0);\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) uniques++;\\n        m[e]++;\\n\\n        if (uniques > t) {\\n            m[a[L]]--;\\n            uniques--;\\n            leftMostExtra = 0;\\n            L++;\\n        }\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            leftMostExtra++;\\n            L++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        m = new Array(n + 1).fill(0),\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        cc = 0;\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) {\\n            uniques++;\\n            if (uniques > t) {\\n                m[a[L]]--;\\n                uniques--;\\n                L++;\\n                leftMostExtra = 0;\\n            }\\n        }\\n        m[e]++;\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            L++;\\n            leftMostExtra++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nvar subarraysWithKDistinct = function (a, t) {\\n    let n = a.length,\\n        m = new Array(n + 1).fill(0),\\n        uniques = 0,\\n        leftMostExtra = 0,\\n        cc = 0;\\n\\n    let L = 0;\\n    for (let e of a) {\\n        if (m[e] === 0) {\\n            uniques++;\\n            if (uniques > t) {\\n                m[a[L]]--;\\n                uniques--;\\n                L++;\\n                leftMostExtra = 0;\\n            }\\n        }\\n        m[e]++;\\n\\n        while (m[a[L]] > 1) {\\n            m[a[L]]--;\\n            L++;\\n            leftMostExtra++;\\n        }\\n\\n        if (uniques == t) {\\n            cc += leftMostExtra + 1;\\n        }\\n    }\\n    return cc;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110154,
                "title": "key-idea-behind-sliding-window-python",
                "content": "This problem is a bit similar to: https://leetcode.com/problems/count-number-of-nice-subarrays/description/\\n\\n**The key idea is:**\\n```\\nlet f(k) = no. of subarrays with at most k \"something\"\\nno. of subarrays with exactly k \"something\" = f(k) - f(k-1)\\n```\\nThe question to ask now is,\\n**find the number of subarrays with at most k distinct integers**\\n\\n**Approach**\\nUse two pointers and hashmap to keep track of elements in the window\\nif number of elements in window > k, move the left pointer to bring count back to k\\n\\n**Time: O(n)\\nSpace: O(n)**\\n```\\ndef subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\n    def countAtMost(k):\\n        i = ans = 0\\n        elements = defaultdict(int)\\n        for j in range(len(nums)):\\n            elements[nums[j]] += 1\\n            while len(elements) > k:\\n                elements[nums[i]] -= 1\\n                if not elements[nums[i]]:\\n                    del elements[nums[i]]\\n                i += 1\\n            ans += j - i + 1\\n        return ans\\n    \\n    return countAtMost(k) - countAtMost(k-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nlet f(k) = no. of subarrays with at most k \"something\"\\nno. of subarrays with exactly k \"something\" = f(k) - f(k-1)\\n```\n```\\ndef subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\n    def countAtMost(k):\\n        i = ans = 0\\n        elements = defaultdict(int)\\n        for j in range(len(nums)):\\n            elements[nums[j]] += 1\\n            while len(elements) > k:\\n                elements[nums[i]] -= 1\\n                if not elements[nums[i]]:\\n                    del elements[nums[i]]\\n                i += 1\\n            ans += j - i + 1\\n        return ans\\n    \\n    return countAtMost(k) - countAtMost(k-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3074199,
                "title": "substract-atmost-k-1-distinct-from-atmost-k-distinct",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(vector<int>& a, int k)\\n    {\\n        \\n        int n = a.size();\\n        int res=0,ans=0;\\n        int j=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[a[i]]++;\\n            while(mp.size()>k && j<n)\\n            {\\n                mp[a[j]]--;\\n                if(mp[a[j]] == 0)\\n                    mp.erase(a[j]);\\n                j++;\\n            }\\n            \\n            res+=(i-j+1);\\n        }\\n        return res;\\n    }\\n    \\n    /*\\n    \\n    brute force \\n    \\n            for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> mp;\\n            for(int j=i;j<n;j++)\\n            {\\n                if(mp.size()>k)\\n                    break;\\n                mp[a[j]]++;\\n                if(mp.size()==k)\\n                    res++;\\n                \\n            }\\n        }\\n\\n    \\n    */\\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        \\n        \\n        int n = a.size();\\n        int res=0;\\n        res = solve(a,k)-solve(a,k-1);\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(vector<int>& a, int k)\\n    {\\n        \\n        int n = a.size();\\n        int res=0,ans=0;\\n        int j=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[a[i]]++;\\n            while(mp.size()>k && j<n)\\n            {\\n                mp[a[j]]--;\\n                if(mp[a[j]] == 0)\\n                    mp.erase(a[j]);\\n                j++;\\n            }\\n            \\n            res+=(i-j+1);\\n        }\\n        return res;\\n    }\\n    \\n    /*\\n    \\n    brute force \\n    \\n            for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> mp;\\n            for(int j=i;j<n;j++)\\n            {\\n                if(mp.size()>k)\\n                    break;\\n                mp[a[j]]++;\\n                if(mp.size()==k)\\n                    res++;\\n                \\n            }\\n        }\\n\\n    \\n    */\\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        \\n        \\n        int n = a.size();\\n        int res=0;\\n        res = solve(a,k)-solve(a,k-1);\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743868,
                "title": "java-easy-hashmap-solution-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmost(nums,k)-atmost(nums,k-1);\\n    }\\n    public int atmost(int[] nums, int k){\\n        int res = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int j = -1;\\n        for(int i = 0; i<nums.length; i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            while(j<i && map.size()>k){\\n                j++;\\n                if(map.get(nums[j])==1){\\n                    map.remove(nums[j]);\\n                }else{\\n                    map.put(nums[j],map.get(nums[j])-1);\\n                }\\n            }\\n            res += i-j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        return atmost(nums,k)-atmost(nums,k-1);\\n    }\\n    public int atmost(int[] nums, int k){\\n        int res = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int j = -1;\\n        for(int i = 0; i<nums.length; i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            while(j<i && map.size()>k){\\n                j++;\\n                if(map.get(nums[j])==1){\\n                    map.remove(nums[j]);\\n                }else{\\n                    map.put(nums[j],map.get(nums[j])-1);\\n                }\\n            }\\n            res += i-j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626182,
                "title": "python-sliding-window-hashmap",
                "content": "```\\nclass Solution(object):\\n    def subarraysWithKDistinct(self, nums, k):\\n        return self.atmostK(nums, k) - self.atmostK(nums, k - 1)\\n    def atmostK(self, nums, k):\\n        hashmap = defaultdict(int)\\n        left = 0\\n        right = 0\\n        ans = 0\\n        while right < len(nums):\\n            hashmap[nums[right]] += 1\\n            while len(hashmap) > k:\\n                hashmap[nums[left]] -= 1\\n                if hashmap[nums[left]] == 0:\\n                    del hashmap[nums[left]]\\n                left += 1\\n            ans += right - left + 1\\n            right += 1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subarraysWithKDistinct(self, nums, k):\\n        return self.atmostK(nums, k) - self.atmostK(nums, k - 1)\\n    def atmostK(self, nums, k):\\n        hashmap = defaultdict(int)\\n        left = 0\\n        right = 0\\n        ans = 0\\n        while right < len(nums):\\n            hashmap[nums[right]] += 1\\n            while len(hashmap) > k:\\n                hashmap[nums[left]] -= 1\\n                if hashmap[nums[left]] == 0:\\n                    del hashmap[nums[left]]\\n                left += 1\\n            ans += right - left + 1\\n            right += 1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625981,
                "title": "subarrays-with-k-different-integers-solution-java",
                "content": "class Solution {\\n  public int subarraysWithKDistinct(int[] A, int K) {\\n    return subarraysWithAtMostKDistinct(A, K) - subarraysWithAtMostKDistinct(A, K - 1);\\n  }\\n\\n  private int subarraysWithAtMostKDistinct(int[] A, int K) {\\n    int ans = 0;\\n    int[] count = new int[A.length + 1];\\n\\n    for (int l = 0, r = 0; r < A.length; ++r) {\\n      if (++count[A[r]] == 1)\\n        --K;\\n      while (K == -1)\\n        if (--count[A[l++]] == 0)\\n          ++K;\\n      ans += r - l + 1; // A[l..r], A[l + 1..r], ..., A[r]\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "class Solution {\\n  public int subarraysWithKDistinct(int[] A, int K) {\\n    return subarraysWithAtMostKDistinct(A, K) - subarraysWithAtMostKDistinct(A, K - 1);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2374110,
                "title": "easy-and-simple-java-solution",
                "content": "The problem can be simply solved by counting the subarrays in range of 1 - k and then subtracting the subarrays in range of 1 - (k - 1) with two pointers for both subarray count.\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n       return  count(nums, k) - count(nums, k - 1);\\n    }\\n\\n\\n       public int count(int[] nums, int k){\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        int left = 0, right = 0, ans = 0;\\n        \\n        while(right < nums.length){\\n            hm.put(nums[right] , hm.getOrDefault(nums[right], 0) + 1);\\n            \\n            while(hm.size() == k + 1){\\n                hm.put(nums[left], hm.get(nums[left]) - 1);\\n                if(hm.get(nums[left]) == 0)\\n                    hm.remove(nums[left]);\\n                    left++;\\n            }\\n            ans += right - left + 1;\\n            right++;\\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n       return  count(nums, k) - count(nums, k - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2340510,
                "title": "easy-sliding-window-solution",
                "content": "**Brute Force**\\n*Brute force might won\\'t work, but you can understand  how things are working because optimise solution is variation of brute force  *\\n```\\n  public int subarraysWithKDistinct(int[] nums, int k) {\\n      \\n         int n=nums.length;\\n\\t\\tint ans=0;\\n        for(int i=0;i<n;i++){\\n              Set<Integer> set=new HashSet<>();\\n             for(int j=i;j<n;j++){\\n                 if(!set.contains(nums[j])) set.add(nums[j]);\\n                 if(set.size()==k)  ans++;\\n                 else if(set.size()>k) break;\\n             }\\n         }\\n        return ans;\\n    }\\n```\\n**Optimise Solution**\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n//      Subarray with exactly k distinct integer= (subarray with atmost k integer) - (subarray with armost k-1 integers)\\n        return f(nums,k)-f(nums,k-1);\\n    }\\n    int f(int[] nums, int k){\\n          int s=0;\\n        int ans=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int e=0;e<nums.length;e++){\\n            map.put(nums[e],map.getOrDefault(nums[e],0)+1);\\n        \\n          \\n            while(map.size()>k){\\n                int p=map.get(nums[s]);\\n                map.put(nums[s],p-1);\\n                if(p==1) map.remove(nums[s]);\\n              \\n                s++;\\n                // ans++;\\n            }\\n            ans+=e-s+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n  public int subarraysWithKDistinct(int[] nums, int k) {\\n      \\n         int n=nums.length;\\n\\t\\tint ans=0;\\n        for(int i=0;i<n;i++){\\n              Set<Integer> set=new HashSet<>();\\n             for(int j=i;j<n;j++){\\n                 if(!set.contains(nums[j])) set.add(nums[j]);\\n                 if(set.size()==k)  ans++;\\n                 else if(set.size()>k) break;\\n             }\\n         }\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n//      Subarray with exactly k distinct integer= (subarray with atmost k integer) - (subarray with armost k-1 integers)\\n        return f(nums,k)-f(nums,k-1);\\n    }\\n    int f(int[] nums, int k){\\n          int s=0;\\n        int ans=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int e=0;e<nums.length;e++){\\n            map.put(nums[e],map.getOrDefault(nums[e],0)+1);\\n        \\n          \\n            while(map.size()>k){\\n                int p=map.get(nums[s]);\\n                map.put(nums[s],p-1);\\n                if(p==1) map.remove(nums[s]);\\n              \\n                s++;\\n                // ans++;\\n            }\\n            ans+=e-s+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254737,
                "title": "easier-version-atmost-k-atmost-k-1",
                "content": "```\\n int tom(vector<int>& nums,int k){\\n        int i=0,j=0;\\n        int n=nums.size();\\n        int ans=0;\\n      \\n        if(k==0){\\n            return 0;\\n        }\\n      \\n        unordered_map<int,int> mp;\\n        mp[nums[0]]++;\\n        \\n        while(i<n){\\n            \\n\\n           \\n            if(mp.size()<=k){\\n      \\n                ans=ans+(i-j+1);\\n                \\n               \\n                i++;\\n                if(i==n){\\n                    break;\\n                }\\n                          mp[nums[i]]++;\\n            }\\n            else if(mp.size()>k){\\n               \\n                mp[nums[j]]--;\\n              \\n                if(mp[nums[j]]==0){\\n                    mp.erase(nums[j]);\\n                }\\n                j++;\\n            }\\n        }\\n      \\n      \\n        return ans;\\n        \\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n       \\n    int n=nums.size();\\n       \\n       int c=tom(nums,k);\\n        int d=tom(nums,k-1);\\n    \\n      \\n        return (c-d);\\n        \\n        \\n      \\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n int tom(vector<int>& nums,int k){\\n        int i=0,j=0;\\n        int n=nums.size();\\n        int ans=0;\\n      \\n        if(k==0){\\n            return 0;\\n        }\\n      \\n        unordered_map<int,int> mp;\\n        mp[nums[0]]++;\\n        \\n        while(i<n){\\n            \\n\\n           \\n            if(mp.size()<=k){\\n      \\n                ans=ans+(i-j+1);\\n                \\n               \\n                i++;\\n                if(i==n){\\n                    break;\\n                }\\n                          mp[nums[i]]++;\\n            }\\n            else if(mp.size()>k){\\n               \\n                mp[nums[j]]--;\\n              \\n                if(mp[nums[j]]==0){\\n                    mp.erase(nums[j]);\\n                }\\n                j++;\\n            }\\n        }\\n      \\n      \\n        return ans;\\n        \\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n       \\n    int n=nums.size();\\n       \\n       int c=tom(nums,k);\\n        int d=tom(nums,k-1);\\n    \\n      \\n        return (c-d);\\n        \\n        \\n      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224922,
                "title": "sliding-window-with-c-for-loop-simplest-solution",
                "content": "Conclusion: number of subarrays with k different integers = (number of subarrays with number of different integers less than equal to k ) - (number of subarrays with number of different integers less than equal to k-1 )\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k){\\n        unordered_map<int, int> maps;\\n        int left = 0, res = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            maps[nums[i]]++;\\n            while(maps.size() > k){\\n                maps[nums[left]]--;\\n                if(maps[nums[left]] == 0)  maps.erase(nums[left]);\\n                left++;\\n            }\\n            res += i - left + 1;\\n        }\\n        return res;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return helper(nums, k) - helper(nums, k - 1);\\n    }\\n};\\n```\\nThe helper function can also be applied in 340. If don\\'t know the helper function mechanism, do 340 first.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k){\\n        unordered_map<int, int> maps;\\n        int left = 0, res = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            maps[nums[i]]++;\\n            while(maps.size() > k){\\n                maps[nums[left]]--;\\n                if(maps[nums[left]] == 0)  maps.erase(nums[left]);\\n                left++;\\n            }\\n            res += i - left + 1;\\n        }\\n        return res;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return helper(nums, k) - helper(nums, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218716,
                "title": "tricky-sliding-window-in-1-loop-only",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    int subarraysWithKDistinct(vector<int> &nums, int k)\\n    {\\n\\n        int s = 0;\\n        int e = 0;\\n\\n        unordered_map<int, int> freq;\\n\\n        int res = 0;\\n        int prev = 0;\\n\\n        for (; e < nums.size(); e++)\\n        {\\n\\n            freq[nums[e]] += 1;\\n\\n            int mysub = 0;\\n\\n            if (freq.size() == k)\\n            {\\n\\n                if (s != 0 && nums[s - 1] != nums[e])\\n                    prev = 0;\\n\\n                while (s <= e && freq.size() == k)\\n                {\\n\\n                    mysub++;\\n\\n                    int n = nums[s++];\\n\\n                    freq[n] -= 1;\\n\\n                    if (freq[n] == 0)\\n                        freq.erase(n);\\n                }\\n            }\\n\\n            prev += mysub;\\n            res += prev;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    int subarraysWithKDistinct(vector<int> &nums, int k)\\n    {\\n\\n        int s = 0;\\n        int e = 0;\\n\\n        unordered_map<int, int> freq;\\n\\n        int res = 0;\\n        int prev = 0;\\n\\n        for (; e < nums.size(); e++)\\n        {\\n\\n            freq[nums[e]] += 1;\\n\\n            int mysub = 0;\\n\\n            if (freq.size() == k)\\n            {\\n\\n                if (s != 0 && nums[s - 1] != nums[e])\\n                    prev = 0;\\n\\n                while (s <= e && freq.size() == k)\\n                {\\n\\n                    mysub++;\\n\\n                    int n = nums[s++];\\n\\n                    freq[n] -= 1;\\n\\n                    if (freq[n] == 0)\\n                        freq.erase(n);\\n                }\\n            }\\n\\n            prev += mysub;\\n            res += prev;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213823,
                "title": "c-o-n-easy-solution",
                "content": "**C++ Code:**\\n**Time Complexity : O(n)**\\n**Approach:**\\nTo directly count the subarrays with exactly K different integers is hard but to find the count of subarrays with at most K different integers is easy. So the idea is to find the count of subarrays with at most K different integers, let it be C(K), and the count of subarrays with at most (K \\u2013 1) different integers, let it be C(K \\u2013 1) and finally take their difference, C(K) \\u2013 C(K \\u2013 1) which is the required answer.\\nCount of subarrays with at most K different elements can be easily calculated through the sliding window technique. The idea is to keep expanding the right boundary of the window till the count of distinct elements in the window is less than or equal to K and when the count of distinct elements inside the window becomes more than K, start shrinking the window from the left till the count becomes less than or equal to K. Also for every expansion, keep counting the subarrays as right \\u2013 left + 1 where right and left are the boundaries of the current window.\\n\\n```\\n    int solve(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int>m;\\n        int ans = 0;\\n        int i=0,j=0;\\n        while(i<nums.size())\\n        {\\n            m[nums[i]]++;\\n            while(m.size()>k)\\n            {\\n                m[nums[j]]--;\\n                if(m[nums[j]]==0) m.erase(nums[j]);\\n                j++;\\n            }\\n            ans += (i-j+1);\\n            i++;\\n        }\\n     return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {  \\n     int ans = solve(nums,k)-solve(nums,k-1);\\n    return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n    int solve(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int>m;\\n        int ans = 0;\\n        int i=0,j=0;\\n        while(i<nums.size())\\n        {\\n            m[nums[i]]++;\\n            while(m.size()>k)\\n            {\\n                m[nums[j]]--;\\n                if(m[nums[j]]==0) m.erase(nums[j]);\\n                j++;\\n            }\\n            ans += (i-j+1);\\n            i++;\\n        }\\n     return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {  \\n     int ans = solve(nums,k)-solve(nums,k-1);\\n    return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2181157,
                "title": "hard-problem-using-easy-sliding-window-concept-o-n",
                "content": "****we will find total subarrays with atmost k diff int and atmost k-1 diff int using sliding window \\n#subtraction of this 2 will give us subarrays with exactly k diff int ,pls upvote if u like the solun\\n# atmost(k)-atmost(k-1)=exactly k \\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums,int k){\\n        unordered_map<int,int>map;\\n        int i=0,j=0,ans=0;\\n        while(j<nums.size()){\\n            map[nums[j]]++;\\n            while(map.size()>k){\\n                map[nums[i]]--;\\n                if(map[nums[i]]==0)map.erase(nums[i]);\\n                i++;}\\n            ans+=j-i+1;\\n            j++;}\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k){\\n        return helper(nums,k)-helper(nums,k-1);  }  \\n    };\\n```\\n**pls upvote if u got the solun**\\nsimilar prob-\\n[https://leetcode.com/problems/count-vowel-substrings-of-a-string/](http://)",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums,int k){\\n        unordered_map<int,int>map;\\n        int i=0,j=0,ans=0;\\n        while(j<nums.size()){\\n            map[nums[j]]++;\\n            while(map.size()>k){\\n                map[nums[i]]--;\\n                if(map[nums[i]]==0)map.erase(nums[i]);\\n                i++;}\\n            ans+=j-i+1;\\n            j++;}\\n        return ans;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k){\\n        return helper(nums,k)-helper(nums,k-1);  }  \\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124668,
                "title": "c-solution-o-n-without-map",
                "content": "2 Slide windows to keep k or k-1 diff values.\\nTime O(N)\\nSpace O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> cb(n+1);\\n        vector<int> ce(n+1);\\n        int kb = 0;\\n        int ke = 0;\\n        int b = 0;\\n        int e = 0;\\n        int ans = 0;\\n        for(auto v: nums) {\\n            if(cb[v]++ == 0) kb++;\\n            if(ce[v]++ == 0) ke++;\\n            \\n            while(kb > k) {\\n                if(--cb[nums[b++]] == 0) kb--;\\n            }\\n            while(ke >= k) {\\n                if(--ce[nums[e++]] == 0) ke--;\\n            }\\n            ans += e-b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> cb(n+1);\\n        vector<int> ce(n+1);\\n        int kb = 0;\\n        int ke = 0;\\n        int b = 0;\\n        int e = 0;\\n        int ans = 0;\\n        for(auto v: nums) {\\n            if(cb[v]++ == 0) kb++;\\n            if(ce[v]++ == 0) ke++;\\n            \\n            while(kb > k) {\\n                if(--cb[nums[b++]] == 0) kb--;\\n            }\\n            while(ke >= k) {\\n                if(--ce[nums[e++]] == 0) ke--;\\n            }\\n            ans += e-b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122607,
                "title": "python-atmostk-algorithm",
                "content": "```\\nimport collections\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        # exact k = atMostK(k) - atMost(k-1)\\n        def atMostK(k):\\n            counter = collections.defaultdict(int)\\n            res = i = 0\\n            for j in range(len(nums)):\\n                if counter[nums[j]] == 0:\\n                    k -= 1\\n                counter[nums[j]] += 1\\n                while k < 0:\\n                    counter[nums[i]] -= 1\\n                    if counter[nums[i]] == 0:\\n                        k += 1\\n                    i += 1\\n                res += j - i + 1\\n            return res\\n        return atMostK(k) - atMostK(k-1)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        # exact k = atMostK(k) - atMost(k-1)\\n        def atMostK(k):\\n            counter = collections.defaultdict(int)\\n            res = i = 0\\n            for j in range(len(nums)):\\n                if counter[nums[j]] == 0:\\n                    k -= 1\\n                counter[nums[j]] += 1\\n                while k < 0:\\n                    counter[nums[i]] -= 1\\n                    if counter[nums[i]] == 0:\\n                        k += 1\\n                    i += 1\\n                res += j - i + 1\\n            return res\\n        return atMostK(k) - atMostK(k-1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111046,
                "title": "python3-simple-sliding-window-based-solution",
                "content": "```\\n\"\"\"https://leetcode.com/problems/subarrays-with-k-different-integers/\"\"\"\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        def subarraysWithAtMostKDistinct(size):\\n            count, left, freq_dict = 0, 0, defaultdict(int)\\n            for right, num in enumerate(nums):\\n                freq_dict[num] += 1\\n                while len(freq_dict) > size:\\n                    num_to_remove = nums[left]\\n                    freq_dict[num_to_remove] -= 1\\n                    if freq_dict[num_to_remove] == 0:\\n                        freq_dict.pop(num_to_remove)\\n                    left += 1\\n                count += right - left + 1\\n            return count\\n\\n        return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/subarrays-with-k-different-integers/\"\"\"\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        def subarraysWithAtMostKDistinct(size):\\n            count, left, freq_dict = 0, 0, defaultdict(int)\\n            for right, num in enumerate(nums):\\n                freq_dict[num] += 1\\n                while len(freq_dict) > size:\\n                    num_to_remove = nums[left]\\n                    freq_dict[num_to_remove] -= 1\\n                    if freq_dict[num_to_remove] == 0:\\n                        freq_dict.pop(num_to_remove)\\n                    left += 1\\n                count += right - left + 1\\n            return count\\n\\n        return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2052227,
                "title": "c-hashmap-sliding-window-explanation-linked-thoughts-added",
                "content": "Awesome explanation of the problem:\\n\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/672979/Analysis-and-explanation-with-Visualization\\n\\nWhen I first attempted the problem, my mind went to combinatorics, but I couldn\\'t exactly figure out why that was the case. The post above provided much clarity. \\n\\nDefinitely a \"hard\" problem, but once you figure out the discrete math behind it (for anyone with a Computer Science degree) I hope you come to appreciate this problem as I have. With that being said, I would never give this to anyone who is being interviewed without MASSIVE hints, haha.\\n\\nHappy Coding!\\n```\\npublic class Solution {\\n    \\n    public int SubarraysWithKDistinct(int[] nums, int k) \\n    {    \\n        return _atMost(nums, k) - _atMost(nums, k - 1);\\n    }\\n    \\n    private int _atMost(int[] nums, int k)\\n    {\\n        var answer = 0;\\n        var fast = 0;\\n        var slow = 0;\\n        var map = new Dictionary<int, int>();\\n        var unique = 0;\\n        \\n        while(fast < nums.Length)\\n        {\\n            var curr = nums[fast];\\n            \\n            if(!map.ContainsKey(curr))\\n            {\\n                map.Add(curr, 0);\\n            }\\n            \\n            map[curr]++;\\n            \\n            if(map[curr] == 1)\\n            {\\n                unique++;   //Since we\\'re adding a different integer for this window sliding, we increase unique by 1 \\n            }\\n            \\n            //Close the window.\\n            while(unique > k)\\n            {           \\n                map[nums[slow]]--;\\n                \\n                /*\\n                    If we completely remove an element from our window closing (aka, if the count in the map is 0),\\n                    then we decrement unique, ending our closing of the window\\n                */\\n                if(map[nums[slow]] == 0)\\n                {\\n                    unique--;\\n                }\\n                \\n                slow++;\\n            }\\n            \\n            answer += fast - slow + 1;  //Flash back to discrete mathematics. Fun times!\\n            \\n            fast++;     //Slide the window\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    public int SubarraysWithKDistinct(int[] nums, int k) \\n    {    \\n        return _atMost(nums, k) - _atMost(nums, k - 1);\\n    }\\n    \\n    private int _atMost(int[] nums, int k)\\n    {\\n        var answer = 0;\\n        var fast = 0;\\n        var slow = 0;\\n        var map = new Dictionary<int, int>();\\n        var unique = 0;\\n        \\n        while(fast < nums.Length)\\n        {\\n            var curr = nums[fast];\\n            \\n            if(!map.ContainsKey(curr))\\n            {\\n                map.Add(curr, 0);\\n            }\\n            \\n            map[curr]++;\\n            \\n            if(map[curr] == 1)\\n            {\\n                unique++;   //Since we\\'re adding a different integer for this window sliding, we increase unique by 1 \\n            }\\n            \\n            //Close the window.\\n            while(unique > k)\\n            {           \\n                map[nums[slow]]--;\\n                \\n                /*\\n                    If we completely remove an element from our window closing (aka, if the count in the map is 0),\\n                    then we decrement unique, ending our closing of the window\\n                */\\n                if(map[nums[slow]] == 0)\\n                {\\n                    unique--;\\n                }\\n                \\n                slow++;\\n            }\\n            \\n            answer += fast - slow + 1;  //Flash back to discrete mathematics. Fun times!\\n            \\n            fast++;     //Slide the window\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964899,
                "title": "13-lines-python",
                "content": "Solution relies on the fact that:\\n\\nNumber of subarrays with K different integers = number of subarrays with at most K different integers - number of subarrays with at most K-1 different integers.\\n\\n```python\\ndef subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\tdef atMostk(k):\\n\\t\\tleft, res, cnt = 0, 0, {}\\n\\t\\tfor right, n in enumerate(nums):\\n\\t\\t\\tcnt[n] = cnt.setdefault(n,0)+1\\n\\t\\t\\tk -= cnt[n] == 1\\n\\t\\t\\twhile left <= right and k < 0:\\n\\t\\t\\t\\tcnt[nums[left]] -= 1\\n\\t\\t\\t\\tk += cnt[nums[left]] == 0\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\tres += (right - left + 1)\\n\\t\\treturn res\\n\\treturn atMostk(k) - atMostk(k-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\ndef subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n\\tdef atMostk(k):\\n\\t\\tleft, res, cnt = 0, 0, {}\\n\\t\\tfor right, n in enumerate(nums):\\n\\t\\t\\tcnt[n] = cnt.setdefault(n,0)+1\\n\\t\\t\\tk -= cnt[n] == 1\\n\\t\\t\\twhile left <= right and k < 0:\\n\\t\\t\\t\\tcnt[nums[left]] -= 1\\n\\t\\t\\t\\tk += cnt[nums[left]] == 0\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\tres += (right - left + 1)\\n\\t\\treturn res\\n\\treturn atMostk(k) - atMostk(k-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1871340,
                "title": "c",
                "content": "Explanation : https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/360147/Share-my-solution\\n\\n```\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int j=0, u=0, res=0, maxi=0, nsub=0;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<nums.size(); i++) {\\n            // Part 1 : Count Unique nums\\n            m[nums[i]]++;\\n            if (m[nums[i]]==1)\\n                u++;\\n            \\n            // Part 2 : If Unique nums == k, find maxi upto where uniques are still k\\n            if(u==k) {\\n                maxi = i;\\n                while(maxi+1<nums.size() && m[nums[maxi+1]]>0)\\n                    maxi++;\\n                // num of valid subarrays :\\n                nsub = maxi - i + 1;\\n            }\\n            \\n            // Part 3 : reduce window from left, while maintaining uniques to k\\n            // for every iteration, add previoursly calculated num of valid subarrays.\\n            while (u==k && j<nums.size()) {\\n                res += nsub;\\n                m[nums[j]]--;\\n                if (m[nums[j]] == 0)\\n                    u--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint subarraysWithKDistinct(vector<int>& nums, int k) {\\n        int j=0, u=0, res=0, maxi=0, nsub=0;\\n        unordered_map<int, int> m;\\n        for(int i=0; i<nums.size(); i++) {\\n            // Part 1 : Count Unique nums\\n            m[nums[i]]++;\\n            if (m[nums[i]]==1)\\n                u++;\\n            \\n            // Part 2 : If Unique nums == k, find maxi upto where uniques are still k\\n            if(u==k) {\\n                maxi = i;\\n                while(maxi+1<nums.size() && m[nums[maxi+1]]>0)\\n                    maxi++;\\n                // num of valid subarrays :\\n                nsub = maxi - i + 1;\\n            }\\n            \\n            // Part 3 : reduce window from left, while maintaining uniques to k\\n            // for every iteration, add previoursly calculated num of valid subarrays.\\n            while (u==k && j<nums.size()) {\\n                res += nsub;\\n                m[nums[j]]--;\\n                if (m[nums[j]] == 0)\\n                    u--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808952,
                "title": "single-pass-java-solution-beat-95",
                "content": "class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        int [] countLongest = new int[nums.length + 1];\\n        int [] countShortest = new int[nums.length + 1];\\n        int total =0, result=0;\\n        for(int leftLongest =0, leftShortest=0, right =0; right < nums.length ; right ++) {\\n            \\n            countLongest[nums[right]]++;\\n            countShortest[nums[right]]++;\\n            if(countLongest[nums[right]] == 1 ) {\\n               total ++;    \\n            }\\n            \\n          //move Leftlongest\\n            while(leftLongest < right &&  total > k) {\\n                countLongest[nums[leftLongest]]--;\\n                if(countLongest[nums[leftLongest]] == 0) {\\n                    total--;\\n                }\\n                leftLongest++;\\n            }\\n            \\n            //move LeftShortest\\n            while(leftShortest < right &&  (countShortest[nums[leftShortest]] > 1|| leftShortest < leftLongest  )) {\\n                    countShortest[ nums[leftShortest]]--;\\n                    leftShortest++;\\n            }\\n           \\n            \\n            if(total == k) {\\n                result += leftShortest-leftLongest+1;\\n\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        int [] countLongest = new int[nums.length + 1];\\n        int [] countShortest = new int[nums.length + 1];\\n        int total =0, result=0;\\n        for(int leftLongest =0, leftShortest=0, right =0; right < nums.length ; right ++) {\\n            \\n            countLongest[nums[right]]++;\\n            countShortest[nums[right]]++;\\n            if(countLongest[nums[right]] == 1 ) {\\n               total ++;    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1751427,
                "title": "python-sliding-window-dict",
                "content": "\\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], K: int) -> int:\\n\\n        def atMostK(nums, K):\\n            n = len(nums)\\n            pool = Counter()\\n            left = right = 0\\n            ct = 0\\n            \\n            while right < n:\\n                pool[nums[right]] += 1\\n                \\n                while len(pool) > K and left <= right:\\n                    pool[nums[left]] -= 1\\n                    if not pool[nums[left]]:\\n                        del pool[nums[left]]\\n                    left += 1\\n                \\n                ct += right - left + 1\\n                right += 1\\n            return ct\\n        return atMostK(nums, K) - atMostK(nums, K-1)\\n                    \\n                \\n                    \\n                \\n        \\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\n\\n```\\nclass Solution:\\n    def subarraysWithKDistinct(self, nums: List[int], K: int) -> int:\\n\\n        def atMostK(nums, K):\\n            n = len(nums)\\n            pool = Counter()\\n            left = right = 0\\n            ct = 0\\n            \\n            while right < n:\\n                pool[nums[right]] += 1\\n                \\n                while len(pool) > K and left <= right:\\n                    pool[nums[left]] -= 1\\n                    if not pool[nums[left]]:\\n                        del pool[nums[left]]\\n                    left += 1\\n                \\n                ct += right - left + 1\\n                right += 1\\n            return ct\\n        return atMostK(nums, K) - atMostK(nums, K-1)\\n                    \\n                \\n                    \\n                \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1692176,
                "title": "c-solution-based-on-similar-problem-with-explanation",
                "content": "The solution is bassed on a similar problem https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/ :\\nWe are finding the number of substrings that can contain all three characters.\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubstrings(string s) {\\n        unordered_map<char, int> hmap;\\n        int res = 0 , i = 0;\\n        for (int j = 0; j < s.size(); ++j) {\\n            ++hmap[s[j]];\\n            while (hmap[\\'a\\'] && hmap[\\'b\\'] && hmap[\\'c\\']) {\\n                --hmap[s[i++]];\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n};\\n```\\nOur new problem sounds similar to the above problem, so we can apply the same techique to this problem:\\n```\\nclass Solution {\\npublic:\\n    int sliding(vector<int>& A, int K) {\\n        unordered_map<int, int> hmap;\\n        int res = 0 , i = 0, cnt = 0;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!hmap[A[j]]++) cnt++;\\n            while (cnt == K) {\\n                if (--hmap[A[i]] == 0) {\\n                    cnt--;\\n                }\\n                i++;\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return sliding(A, K) - sliding(A, K + 1);\\n    }\\n};\\n```\\nIf we can apply exactly the same algorithm as in first problem we will end up with more subarrays:\\n`return sliding(A, K)` for input: `[1,2,1,2,3]` will return `10 `-> this is because we will have redundant`[1,2,1,2,3], [2,1,2,3] and [1,2,3]` subarrays in our result set.\\nIn order to remove these subarrays from the result set we have to apply the same algorithm for K + 1 and substract them from K:  `return sliding(A, K) - sliding(A, K + 1);`\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubstrings(string s) {\\n        unordered_map<char, int> hmap;\\n        int res = 0 , i = 0;\\n        for (int j = 0; j < s.size(); ++j) {\\n            ++hmap[s[j]];\\n            while (hmap[\\'a\\'] && hmap[\\'b\\'] && hmap[\\'c\\']) {\\n                --hmap[s[i++]];\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sliding(vector<int>& A, int K) {\\n        unordered_map<int, int> hmap;\\n        int res = 0 , i = 0, cnt = 0;\\n        for (int j = 0; j < A.size(); ++j) {\\n            if (!hmap[A[j]]++) cnt++;\\n            while (cnt == K) {\\n                if (--hmap[A[i]] == 0) {\\n                    cnt--;\\n                }\\n                i++;\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n    int subarraysWithKDistinct(vector<int>& A, int K) {\\n        return sliding(A, K) - sliding(A, K + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676641,
                "title": "typescript-sliding-window",
                "content": "```\\nfunction subarraysWithKDistinct(nums: number[], k: number): number {\\n    if (nums.length === 1) {\\n        return Number(k === 1)\\n    }\\n    \\n    // initialize state\\n    const freq = new Map<number, number>([[nums[0], 1]])\\n    let left = 0\\n    let right = 1\\n    let total = k === 1 ? 1 : 0\\n    freq.set(nums[1], (freq.get(nums[1]) || 0) + 1)\\n    \\n    // track current number of prefixes with k distinct values\\n    let prefixes = 1\\n    \\n    function decrementMap(num: number): void {\\n        freq.set(num, freq.get(num) - 1)\\n        if (!freq.get(num)) {\\n            freq.delete(num)\\n        }\\n    }\\n    \\n    while (right < nums.length) {\\n        if (freq.size === k) {\\n            if (freq.get(nums[left]) > 1) {\\n                // we can remove this value and keep freq.size === k\\n                // increment prefixes\\n                prefixes++\\n                \\n                // remove value from left side of subarray\\n                decrementMap(nums[left])\\n\\n                left++\\n            } else {\\n                // collect on prefixes\\n                total += prefixes\\n                right++\\n                freq.set(nums[right], (freq.get(nums[right]) || 0) + 1)\\n            }\\n        } else if (freq.size < k) {\\n            // keep expanding right, looking for new unique values\\n            right++\\n            freq.set(nums[right], (freq.get(nums[right]) || 0) + 1)\\n        } else {\\n            // too many distinct values, reset prefixes, start moving left pointer to drop distinct values\\n            prefixes = 1\\n\\n            decrementMap(nums[left])\\n            left++            \\n        }\\n    }\\n    \\n    return total\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction subarraysWithKDistinct(nums: number[], k: number): number {\\n    if (nums.length === 1) {\\n        return Number(k === 1)\\n    }\\n    \\n    // initialize state\\n    const freq = new Map<number, number>([[nums[0], 1]])\\n    let left = 0\\n    let right = 1\\n    let total = k === 1 ? 1 : 0\\n    freq.set(nums[1], (freq.get(nums[1]) || 0) + 1)\\n    \\n    // track current number of prefixes with k distinct values\\n    let prefixes = 1\\n    \\n    function decrementMap(num: number): void {\\n        freq.set(num, freq.get(num) - 1)\\n        if (!freq.get(num)) {\\n            freq.delete(num)\\n        }\\n    }\\n    \\n    while (right < nums.length) {\\n        if (freq.size === k) {\\n            if (freq.get(nums[left]) > 1) {\\n                // we can remove this value and keep freq.size === k\\n                // increment prefixes\\n                prefixes++\\n                \\n                // remove value from left side of subarray\\n                decrementMap(nums[left])\\n\\n                left++\\n            } else {\\n                // collect on prefixes\\n                total += prefixes\\n                right++\\n                freq.set(nums[right], (freq.get(nums[right]) || 0) + 1)\\n            }\\n        } else if (freq.size < k) {\\n            // keep expanding right, looking for new unique values\\n            right++\\n            freq.set(nums[right], (freq.get(nums[right]) || 0) + 1)\\n        } else {\\n            // too many distinct values, reset prefixes, start moving left pointer to drop distinct values\\n            prefixes = 1\\n\\n            decrementMap(nums[left])\\n            left++            \\n        }\\n    }\\n    \\n    return total\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1559335,
                "title": "c-sliding-window-solution-for-992-subarrays-with-k-different-integers",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k) \\n    {\\n        int i = 0, j = 0, sz = nums.size(), good = 0 ;\\n        unordered_map<int, int> umap ;\\n        \\n        while(j<sz)\\n        {\\n            umap[nums[j]]++ ;\\n            \\n            if(umap.size() > k)\\n            {\\n                while(umap.size() > k)\\n                {\\n                    umap[nums[i]]-- ; \\n                    if(umap[nums[i]] == 0){ umap.erase(nums[i]) ;}\\n                    i++ ;\\n                }\\n                \\n            }\\n            good += j - i ;\\n            j++ ;\\n        }\\n        \\n        return good ;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k)\\n    {\\n        int a = helper(nums, k);\\n        int b = helper(nums, k-1);\\n        return a-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int k) \\n    {\\n        int i = 0, j = 0, sz = nums.size(), good = 0 ;\\n        unordered_map<int, int> umap ;\\n        \\n        while(j<sz)\\n        {\\n            umap[nums[j]]++ ;\\n            \\n            if(umap.size() > k)\\n            {\\n                while(umap.size() > k)\\n                {\\n                    umap[nums[i]]-- ; \\n                    if(umap[nums[i]] == 0){ umap.erase(nums[i]) ;}\\n                    i++ ;\\n                }\\n                \\n            }\\n            good += j - i ;\\n            j++ ;\\n        }\\n        \\n        return good ;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k)\\n    {\\n        int a = helper(nums, k);\\n        int b = helper(nums, k-1);\\n        return a-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552981,
                "title": "java-sliding-window-with-three-pointers-o-n",
                "content": "This question hints you to use sliding window cause its crazy data scale (10^5) and its difficulty rating hard. But you will find trouble designing standard sliding window idea:\\n\\n- When we start the window, we usually put start and end both pointed at 0. And we would move end, until our window has K + 1 elements and stop right before that happens. \\n- Now we can no longer move end pointer, we should move start. Let\\'s say we recorded the # of subarrays between [start, end] during this pass. This can be done by recording the occurences when we  found K elements in the window (use hashset or counter array).\\n- We move start + 1.\\n- Now, problem happens: we reduce the start locations count in our hash map, but we still has K elements! We cannot move end, and we are not quite sure how many good arrays are there in [start + 1, end]. We will need to loop over from start the check again. -> This gives you O(N^2) complexity.\\n\\nThe ideal solution would be we need another tracker/pointer to track **location when K distint elements are FIRST satisfied**. So now the algorithm works like this: we name end pointer as last, recording the last position which satisfies K elements requirement. \\n- We have start and last pointing at 0. And we move last + 1, until when we reached an location where further moving gives you K+1 distinct elements. \\n- During the above process, we parallelly add another pointer called first, and we will stop as soon as we discover K element for the first time.\\n- Now, when a window get stuck, we have this result **#good arrays starting at start location**. We will iterate over all start locations from 0 to nums.length - 1.\\n- When our window get stuck, we move start + 1, and we will keep using the first and last pointers to update to the new start + 1 location\\'s first and last location. \\n- Essentially, this is a 3 pointer approach, where each pointer will need to move from 0 -> N.\\n\\nThe good thing for the proposed solution is, it is very straight forward in design, really tries its best to mimic standard sliding window appraoch. The bad thing is, I won\\'t call it easy to implement, especially under pressure.\\n\\n```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        // Like three pointers.\\n        // we pick a left pointer which is left bound\\n        // of the subarr. After that, we start two new pointers\\n        // first and last, first stands for first time sat.\\n        // last stands for last time sat.\\n        \\n        Map<Integer, Integer> firstSat = new HashMap<>();\\n        int start = 0;\\n        int first = 0;\\n        int last = 0;\\n        int n = nums.length;\\n        \\n        int res = 0;\\n        while (start < n) {\\n            while (first < n &&\\n                   firstSat.size() < k) {\\n                int c = firstSat.getOrDefault(nums[first], 0);\\n                firstSat.put(nums[first], c + 1);\\n                \\n                first += 1;\\n            }\\n            \\n            // last = first;\\n            while (last < n && \\n                   firstSat.containsKey(nums[last])) {\\n                last += 1;\\n            }\\n            \\n            // last now points to right most ind + 1\\n            res += firstSat.size() == k ? (last - first + 1) : 0;\\n            \\n            // move start\\n            int startValCount = firstSat.get(nums[start]);\\n            if (startValCount == 1) {\\n                firstSat.remove(nums[start]);\\n            } else {\\n                firstSat.put(nums[start], startValCount - 1);\\n            }\\n            \\n            start += 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        // Like three pointers.\\n        // we pick a left pointer which is left bound\\n        // of the subarr. After that, we start two new pointers\\n        // first and last, first stands for first time sat.\\n        // last stands for last time sat.\\n        \\n        Map<Integer, Integer> firstSat = new HashMap<>();\\n        int start = 0;\\n        int first = 0;\\n        int last = 0;\\n        int n = nums.length;\\n        \\n        int res = 0;\\n        while (start < n) {\\n            while (first < n &&\\n                   firstSat.size() < k) {\\n                int c = firstSat.getOrDefault(nums[first], 0);\\n                firstSat.put(nums[first], c + 1);\\n                \\n                first += 1;\\n            }\\n            \\n            // last = first;\\n            while (last < n && \\n                   firstSat.containsKey(nums[last])) {\\n                last += 1;\\n            }\\n            \\n            // last now points to right most ind + 1\\n            res += firstSat.size() == k ? (last - first + 1) : 0;\\n            \\n            // move start\\n            int startValCount = firstSat.get(nums[start]);\\n            if (startValCount == 1) {\\n                firstSat.remove(nums[start]);\\n            } else {\\n                firstSat.put(nums[start], startValCount - 1);\\n            }\\n            \\n            start += 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549411,
                "title": "java-simple-sliding-window",
                "content": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        Map<Integer,Integer> window = new HashMap<>();\\n        \\n        int numberOfGoodSubarrays = 0;\\n        int l = 0, r = 0;\\n        int duplicates = 0;\\n        while (r < nums.length) {\\n            addToWindow(window, nums[r++]);\\n\\n            if (window.size() > k) {\\n                removeFromWindow(window, nums[l++]);\\n                duplicates = 0;\\n            }\\n\\n            while (window.get(nums[l]) > 1) {\\n                removeFromWindow(window, nums[l++]);\\n                duplicates++;\\n            }\\n            \\n            if (window.size() == k) {\\n                numberOfGoodSubarrays += duplicates + 1;\\n            }\\n        }\\n\\n        return numberOfGoodSubarrays;\\n    }\\n    \\n    private void addToWindow(Map<Integer,Integer> window, int value) {\\n        window.put(value, window.getOrDefault(value, 0) + 1);\\n    }\\n    \\n    private void removeFromWindow(Map<Integer,Integer> window, int value) {\\n        Integer freq = window.get(value);\\n        if (freq == null) return;\\n        if (freq == 1) window.remove(value);\\n        else window.put(value, freq - 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n        Map<Integer,Integer> window = new HashMap<>();\\n        \\n        int numberOfGoodSubarrays = 0;\\n        int l = 0, r = 0;\\n        int duplicates = 0;\\n        while (r < nums.length) {\\n            addToWindow(window, nums[r++]);\\n\\n            if (window.size() > k) {\\n                removeFromWindow(window, nums[l++]);\\n                duplicates = 0;\\n            }\\n\\n            while (window.get(nums[l]) > 1) {\\n                removeFromWindow(window, nums[l++]);\\n                duplicates++;\\n            }\\n            \\n            if (window.size() == k) {\\n                numberOfGoodSubarrays += duplicates + 1;\\n            }\\n        }\\n\\n        return numberOfGoodSubarrays;\\n    }\\n    \\n    private void addToWindow(Map<Integer,Integer> window, int value) {\\n        window.put(value, window.getOrDefault(value, 0) + 1);\\n    }\\n    \\n    private void removeFromWindow(Map<Integer,Integer> window, int value) {\\n        Integer freq = window.get(value);\\n        if (freq == null) return;\\n        if (freq == 1) window.remove(value);\\n        else window.put(value, freq - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521276,
                "title": "golang-100",
                "content": "```\\nfunc subarraysWithKDistinct(A []int, K int) (ans int) {\\n\\tn := len(A)\\n\\tnum1 := make([]int, n+1)\\n\\tnum2 := make([]int, n+1)\\n\\tvar tot1, tot2, left1, left2 int\\n\\tfor _, v := range A {\\n\\t\\tif num1[v] == 0 {\\n\\t\\t\\ttot1++\\n\\t\\t}\\n\\t\\tnum1[v]++\\n\\t\\tif num2[v] == 0 {\\n\\t\\t\\ttot2++\\n\\t\\t}\\n\\t\\tnum2[v]++\\n\\t\\tfor tot1 > K {\\n\\t\\t\\tnum1[A[left1]]--\\n\\t\\t\\tif num1[A[left1]] == 0 {\\n\\t\\t\\t\\ttot1--\\n\\t\\t\\t}\\n\\t\\t\\tleft1++\\n\\t\\t}\\n\\t\\tfor tot2 > K-1 {\\n\\t\\t\\tnum2[A[left2]]--\\n\\t\\t\\tif num2[A[left2]] == 0 {\\n\\t\\t\\t\\ttot2--\\n\\t\\t\\t}\\n\\t\\t\\tleft2++\\n\\t\\t}\\n\\t\\tans += left2 - left1\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subarraysWithKDistinct(A []int, K int) (ans int) {\\n\\tn := len(A)\\n\\tnum1 := make([]int, n+1)\\n\\tnum2 := make([]int, n+1)\\n\\tvar tot1, tot2, left1, left2 int\\n\\tfor _, v := range A {\\n\\t\\tif num1[v] == 0 {\\n\\t\\t\\ttot1++\\n\\t\\t}\\n\\t\\tnum1[v]++\\n\\t\\tif num2[v] == 0 {\\n\\t\\t\\ttot2++\\n\\t\\t}\\n\\t\\tnum2[v]++\\n\\t\\tfor tot1 > K {\\n\\t\\t\\tnum1[A[left1]]--\\n\\t\\t\\tif num1[A[left1]] == 0 {\\n\\t\\t\\t\\ttot1--\\n\\t\\t\\t}\\n\\t\\t\\tleft1++\\n\\t\\t}\\n\\t\\tfor tot2 > K-1 {\\n\\t\\t\\tnum2[A[left2]]--\\n\\t\\t\\tif num2[A[left2]] == 0 {\\n\\t\\t\\t\\ttot2--\\n\\t\\t\\t}\\n\\t\\t\\tleft2++\\n\\t\\t}\\n\\t\\tans += left2 - left1\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488660,
                "title": "c-o-n-2-pointers-sliding-window-with-unordered-map",
                "content": "Concept1: Find number of subarrays with more than k distinct digits\\nConecpt2: If Sub-Array (from index i to j) have k distinct digits then for every index k such that j1 > j, the sub-array(from index i to j1) must have more than or equal to k disctinct digits.\\nConcept3: How to move fast and slow in sliding window\\nInput: nums = [1,2,1,2,3], k = 2\\nlet slow(index) = 0, and fast(index) = 1 -> subarray(slow, fast) = 2 distinct digits, hence, all the indices after fast must have more than or equal to k distinct digits, hence, we will add (size - fast) to our count. Now, as we have considered all fasts, hence, we will move our slow forward, else we would have moved our fast forward.\\n\\nSolution: \\nNumber of subarrays with exactly k distinct digits = Number of subarrays with more than k distinct digits - Number of subarrays with more than (k+1) distinct digits\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k) {\\n        unordered_map<int, int> uMap;\\n        int size = 0;\\n        int slow = 0, fast = 0;\\n        uMap[nums[fast++]]++;\\n        size++;\\n        \\n        int count = 0;\\n        \\n        while(slow < nums.size()){\\n            if((slow == fast || size < k) && (fast < nums.size())){\\n                if(uMap.find(nums[fast]) == uMap.end() || uMap[nums[fast]] == 0)\\n                    size++;\\n                uMap[nums[fast++]]++;\\n            }\\n            else{\\n                if(size == k){\\n                    count += nums.size() - fast + 1;\\n                }\\n                uMap[nums[slow]]--;\\n                if(uMap[nums[slow]] == 0)\\n                    size--;\\n                slow++;\\n            }\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return solve(nums, k) - solve(nums, k+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k) {\\n        unordered_map<int, int> uMap;\\n        int size = 0;\\n        int slow = 0, fast = 0;\\n        uMap[nums[fast++]]++;\\n        size++;\\n        \\n        int count = 0;\\n        \\n        while(slow < nums.size()){\\n            if((slow == fast || size < k) && (fast < nums.size())){\\n                if(uMap.find(nums[fast]) == uMap.end() || uMap[nums[fast]] == 0)\\n                    size++;\\n                uMap[nums[fast++]]++;\\n            }\\n            else{\\n                if(size == k){\\n                    count += nums.size() - fast + 1;\\n                }\\n                uMap[nums[slow]]--;\\n                if(uMap[nums[slow]] == 0)\\n                    size--;\\n                slow++;\\n            }\\n        }\\n        return count;\\n    }\\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\\n        return solve(nums, k) - solve(nums, k+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487664,
                "title": "c-sliding-window",
                "content": "**Exactly = atMostK(k) - atMostK(k-1)**\\n\\n```\\nint atMostK(vector<int>& a, int k) {\\n        int i=0,count = 0,res =0;\\n        unordered_map<int,int> m;\\n        for(int j=0;j<a.size();j++){\\n            m[a[j]]++;\\n            if(m[a[j]]==1) count++;\\n            if(count > k){\\n                while(count>k){\\n                    m[a[i]]--;\\n                    if(m[a[i]] == 0) count--;\\n                    i++;\\n                }\\n            }\\n            res += j-i+-1;\\n        }\\n        return res;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        return atMostK(a,k) - atMostK(a,k-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint atMostK(vector<int>& a, int k) {\\n        int i=0,count = 0,res =0;\\n        unordered_map<int,int> m;\\n        for(int j=0;j<a.size();j++){\\n            m[a[j]]++;\\n            if(m[a[j]]==1) count++;\\n            if(count > k){\\n                while(count>k){\\n                    m[a[i]]--;\\n                    if(m[a[i]] == 0) count--;\\n                    i++;\\n                }\\n            }\\n            res += j-i+-1;\\n        }\\n        return res;\\n    }\\n    \\n    int subarraysWithKDistinct(vector<int>& a, int k) {\\n        return atMostK(a,k) - atMostK(a,k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468471,
                "title": "java-o-n-approach-with-sliding-window-and-hashmap",
                "content": "Using Two Hashmaps small and big in which small hashamp conatains elements till the size of hashmap not  equals to `k-1` and big hashmap contains elements till the size of hashmap not equal to `k`. And if `k==1` then we handle this case in other function/method. \\n```\\nclass Solution {\\n    public static int for_k_equals_one(int[] nums){\\n        int ans=0;\\n        int i=-1;\\n        int j=-1;\\n        HashMap<Integer,Integer> map= new HashMap<>();\\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            while(i<nums.length-1){\\n                i++;\\n                f1=false;\\n                int n=nums[i];\\n                map.put(n,map.getOrDefault(n,0)+1);\\n                if(map.size()==2){\\n                    removeMap(map,n);\\n                    i--;\\n                    break;\\n                }\\n            }\\n            while(j<i){\\n                \\n                f2=false;\\n                if(map.size()==1){\\n                    ans+=i-j;\\n                }\\n                j++;\\n                int n=nums[j];\\n                removeMap(map,n);\\n                if(map.size()==0){\\n                    break;\\n                }\\n            }\\n            if(f1 && f2){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n      if(k==1){\\n         return for_k_equals_one(nums); \\n      }  \\n        int ans=0;\\n        HashMap<Integer,Integer> big_map=new HashMap<>();\\n        HashMap<Integer,Integer> small_map=new HashMap<>();\\n        int i_s=-1;\\n        int i_b=-1;\\n        int j=-1;\\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            boolean f3=true;\\n            while(i_b<nums.length-1){\\n                i_b++;\\n                f1=false;\\n                int n=nums[i_b];\\n                big_map.put(n,big_map.getOrDefault(n,0)+1);\\n                if(big_map.size()==k+1){\\n                    i_b--;\\n                    removeMap(big_map,n);\\n                    break;\\n                }\\n            }\\n            while(i_s<i_b){\\n                i_s++;\\n                f2=false;\\n                int n=nums[i_s];\\n                small_map.put(n,small_map.getOrDefault(n,0)+1);\\n                if(small_map.size()==k){\\n                    i_s--;\\n                    removeMap(small_map,n);\\n                    break;\\n                }\\n            }\\n            while(j<i_s){\\n                j++;\\n                f3=false;\\n                if(big_map.size()==k && small_map.size()==k-1){\\n                    ans+=i_b-i_s;\\n                }\\n                int n=nums[j];\\n                removeMap(big_map,n);\\n                removeMap(small_map,n);\\n                if(big_map.size()<k || small_map.size()<k-1){\\n                    break;\\n                }\\n            }\\n            if(f1 && f2 && f3){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    public static void removeMap(HashMap<Integer,Integer> map,int n){\\n        if(map.get(n)==1){\\n            map.remove(n);\\n        }else{\\n            map.put(n,map.get(n)-1);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public static int for_k_equals_one(int[] nums){\\n        int ans=0;\\n        int i=-1;\\n        int j=-1;\\n        HashMap<Integer,Integer> map= new HashMap<>();\\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            while(i<nums.length-1){\\n                i++;\\n                f1=false;\\n                int n=nums[i];\\n                map.put(n,map.getOrDefault(n,0)+1);\\n                if(map.size()==2){\\n                    removeMap(map,n);\\n                    i--;\\n                    break;\\n                }\\n            }\\n            while(j<i){\\n                \\n                f2=false;\\n                if(map.size()==1){\\n                    ans+=i-j;\\n                }\\n                j++;\\n                int n=nums[j];\\n                removeMap(map,n);\\n                if(map.size()==0){\\n                    break;\\n                }\\n            }\\n            if(f1 && f2){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int subarraysWithKDistinct(int[] nums, int k) {\\n      if(k==1){\\n         return for_k_equals_one(nums); \\n      }  \\n        int ans=0;\\n        HashMap<Integer,Integer> big_map=new HashMap<>();\\n        HashMap<Integer,Integer> small_map=new HashMap<>();\\n        int i_s=-1;\\n        int i_b=-1;\\n        int j=-1;\\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            boolean f3=true;\\n            while(i_b<nums.length-1){\\n                i_b++;\\n                f1=false;\\n                int n=nums[i_b];\\n                big_map.put(n,big_map.getOrDefault(n,0)+1);\\n                if(big_map.size()==k+1){\\n                    i_b--;\\n                    removeMap(big_map,n);\\n                    break;\\n                }\\n            }\\n            while(i_s<i_b){\\n                i_s++;\\n                f2=false;\\n                int n=nums[i_s];\\n                small_map.put(n,small_map.getOrDefault(n,0)+1);\\n                if(small_map.size()==k){\\n                    i_s--;\\n                    removeMap(small_map,n);\\n                    break;\\n                }\\n            }\\n            while(j<i_s){\\n                j++;\\n                f3=false;\\n                if(big_map.size()==k && small_map.size()==k-1){\\n                    ans+=i_b-i_s;\\n                }\\n                int n=nums[j];\\n                removeMap(big_map,n);\\n                removeMap(small_map,n);\\n                if(big_map.size()<k || small_map.size()<k-1){\\n                    break;\\n                }\\n            }\\n            if(f1 && f2 && f3){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    public static void removeMap(HashMap<Integer,Integer> map,int n){\\n        if(map.get(n)==1){\\n            map.remove(n);\\n        }else{\\n            map.put(n,map.get(n)-1);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425980,
                "title": "js-o-n-sliding-windows",
                "content": "```\\nconst atmostK = (nums, k) => {\\n    const feq = new Map();\\n    let count = 0, feqK=0, left=0;\\n    for(let i=0;i<nums.length;i++) {\\n        if (feq.has(nums[i])) {\\n            if (feq.get(nums[i]) == 0) {\\n                feqK++;\\n            }\\n            feq.set(nums[i], feq.get(nums[i])+1);\\n        } else {\\n            feqK++;\\n            feq.set(nums[i], 1);\\n        }\\n        while (feqK > k) {\\n            if (feq.get(nums[left]) == 1) {\\n                feqK--;\\n            }\\n            feq.set(nums[left],feq.get(nums[left]) -1);\\n            left++;\\n        }\\n        count += i-left+1;\\n        \\n    }\\n    \\n    return count;\\n}\\nvar subarraysWithKDistinct = function(nums, k) {\\n    const allK = atmostK(nums, k);\\n    const allKmins1 = atmostK(nums, k-1);\\n    \\n    return allK -allKmins1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst atmostK = (nums, k) => {\\n    const feq = new Map();\\n    let count = 0, feqK=0, left=0;\\n    for(let i=0;i<nums.length;i++) {\\n        if (feq.has(nums[i])) {\\n            if (feq.get(nums[i]) == 0) {\\n                feqK++;\\n            }\\n            feq.set(nums[i], feq.get(nums[i])+1);\\n        } else {\\n            feqK++;\\n            feq.set(nums[i], 1);\\n        }\\n        while (feqK > k) {\\n            if (feq.get(nums[left]) == 1) {\\n                feqK--;\\n            }\\n            feq.set(nums[left],feq.get(nums[left]) -1);\\n            left++;\\n        }\\n        count += i-left+1;\\n        \\n    }\\n    \\n    return count;\\n}\\nvar subarraysWithKDistinct = function(nums, k) {\\n    const allK = atmostK(nums, k);\\n    const allKmins1 = atmostK(nums, k-1);\\n    \\n    return allK -allKmins1;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1791730,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            },
            {
                "id": 1572766,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            },
            {
                "id": 2008343,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            },
            {
                "id": 1964295,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            },
            {
                "id": 1949653,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Count of SubArrays with K Distinct Elements = Count of SubArrays with At Most K Distinct Elements - Count of SubArrays with At Most K-1 Distinct Elements"
                    },
                    {
                        "username": "naveen_kothamasu",
                        "content": "The following is my approach, representation/example inspired from @votrubac\\nhttps://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++Java-with-picture-prefixed-sliding-window\\n\\nThe idea is to identify min and max boundaries (yellow colors on the right) for every left pointer. The min boundary is where we found exactly `k` distinct integers from `left` pointer and max is the last element after which distinct integer count is more than `k`.\\nWith that, we can keep dropping elements from the head and move left pointer as long as we maintain `k` distinct integers in the current window. For each dropepd element, we can generate the same sequences as the element that started the original window.\\nOnce we found a window where we can not drop any more elements (left is fixed at this point, last element to be dropped is in green), then we go back and expand our window i.e move max boundary and so on.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1560717023.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "I got this question in amazon with slight modification.\nit was asking to return the count of no. of distinct elements in all the subarrays of the given array.\nex: [1,2,1]\nthe subarrays are \n1            -> Distinct elements are 1\n2            -> Distinct elements are 1\n1            -> Distinct elements are 1\n1 2          -> Distinct elements are 2\n2 1          -> Distinct elements are 2\n1 2 1       -> Distinct elements are 2\nans=1+1+1+2+2+2=9"
                    },
                    {
                        "username": "dikku-git18",
                        "content": "[@mdsalmankhader](/mdsalmankhader) it was on-campus or off-campus??"
                    },
                    {
                        "username": "ashagg",
                        "content": "can presum method be applied to this problem like it can be in LC 1248? I tried, it didn\\'t work. What\\'s the difference between this one and LC 1248? \\nTIA!"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "have you found the answer?"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Use vector instead of map for faster runtime."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Time to Collect All Apples in a Tree",
        "question_content": "<p>Given an undirected tree consisting of <code>n</code> vertices numbered from <code>0</code> to <code>n-1</code>, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. <em>Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at <strong>vertex 0</strong> and coming back to this vertex.</em></p>\n\n<p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means that exists an edge connecting the vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Additionally, there is a boolean array <code>hasApple</code>, where <code>hasApple[i] = true</code> means that vertex <code>i</code> has an apple; otherwise, it does not have any apple.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_1.png\" style=\"width: 300px; height: 212px;\" />\n<pre>\n<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n<strong>Output:</strong> 8 \n<strong>Explanation:</strong> The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_2.png\" style=\"width: 300px; height: 212px;\" />\n<pre>\n<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  \n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>hasApple.length == n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 623673,
                "title": "concise-explanation-with-a-picture-for-visualization",
                "content": "\\n**Key idea**\\nWhenever you are at a node, say p, you will collect all apples in p\\u2019s subtree before returning back to the original root. This will avoid traveling the same path multiple times. \\nSay, root is where we start, p is a node in the tree and p has two children - child1, child2 - and both of them have an apple each.\\n`root -> p -> child1 -> p -> child2 -> p -> root `is always going to be better than\\n`root-> p -> child1 -> p -> root -> p -> child2 -> p -> root`.\\n\\nSo now it becomes a simple graph traversal problem, particularly DFS where we visit all children of the node first and then go back the other nodes.\\n\\n**Algorithm**\\n1. Because you have the list of edges, construct the graph first to have a better representation of the graph.\\n2. For each node, check if any of its children have apples and find the total cost in terms of time in seconds of collecting those.\\n3. If there is at least one child with an apple, then we have to collect it. So we will also have to add the cost (time required) of reaching that node.\\n4. return the total time.\\n\\nFollowing image should help in understanding better.\\n\\n**Please upvote** if you find this helpful, it would be encouraging! \\n\\nLet me know if something is unclear and I will fix it. :)\\nThanks.\\n\\n\\n![image](https://assets.leetcode.com/users/interviewrecipes/image_1591669743.png)\\n\\n\\n\\n\\n**[EDIT]**\\nIt looks like some cases were failing because I assumed I won\\'t need the bidirectional graph. As correctly pointed out by @hiepit, I was wrong. Fixed the code. :)\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> g; // to store the graph\\n    unordered_map<int, bool> visited; // to stop exploring same nodes again and again.\\n\\t\\n    void createGraph(vector<vector<int>>& edges) {\\n      for (auto e: edges) {\\n        g[e[0]].push_back(e[1]); // adjecency list representation\\n\\t\\tg[e[1]].push_back(e[0]); // adjecency list representation\\n      }\\n    }\\n  \\n    int dfs(int node, int myCost, vector<bool>& hasApple) {\\n\\t  if (visited[node]) {\\n\\t\\t  return 0;\\n\\t  }\\n\\t  visited[node] = true;\\n\\t  \\n      int childrenCost = 0; // cost of traversing all children. \\n      for (auto x: g[node]) { \\n        childrenCost += dfs(x, 2, hasApple);  // check recursively for all apples.\\n      }\\n\\n      if (childrenCost == 0 && hasApple[node] == false) {\\n\\t  // If no child has apples, then we won\\'t traverse the subtree, so cost will be zero.\\n\\t  // similarly, if current node also does not have the apple, we won\\'t traverse this branch at all, so cost will be zero.\\n        return 0;\\n      }\\n\\t  \\n\\t  // Children has at least one apple or the current node has an apple, so add those costs.\\n      return (childrenCost + myCost);\\n    }\\n  \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n      createGraph(edges); // construct the graph first.\\n      return dfs(0, 0, hasApple); // cost of reaching the root is 0. For all others, its 2.\\n    }\\n};\\n\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n        Map<Integer, List<Integer>> graph = createGraph(edges); // to store the graph\\n        Map<Integer, Boolean> visited = new HashMap<>();\\n\\t\\t\\n        return dfs(graph, 0, hasApple, 0, visited); // cost of reaching the root is 0. For all others, its 2.\\n      \\n    }\\n    \\n    private int dfs(Map<Integer, List<Integer>> graph, int node, List<Boolean> hasApple, int myCost, Map<Integer, Boolean> visited) {\\n        Boolean v = visited.getOrDefault(node, false);\\n\\t\\tif (v) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tvisited.put(node, true);\\n\\t\\t\\n        int childrenCost = 0; // cost of traversing all children. \\n      \\n        for(int n : graph.getOrDefault(node, new ArrayList<>())) {\\n            childrenCost += dfs(graph, n, hasApple, 2, visited); // check recursively for all apples in subtrees.\\n        }\\n      \\n        if (childrenCost == 0 && hasApple.get(node) == false) {\\n          // If no child has apples, then we won\\'t traverse the subtree, so cost will be zero.\\n          // similarly, if current node also does not have the apple, we won\\'t traverse this branch at all, so cost will be zero.\\n          return 0;\\n        }\\n      \\n        return childrenCost + myCost;\\n    }\\n    \\n    private Map<Integer, List<Integer>> createGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n      \\n        for(int i = 0; i < edges.length; i++) {\\n            List<Integer> list = graph.getOrDefault(edges[i][0], new ArrayList<>()); // Adjecency list representation.\\n            list.add(edges[i][1]);\\n            graph.put(edges[i][0], list);\\n\\t\\t\\t\\n\\t\\t\\tlist = graph.getOrDefault(edges[i][1], new ArrayList<>()); // Adjecency list representation.\\n            list.add(edges[i][0]);\\n            graph.put(edges[i][1], list);\\n        }\\n      \\n        return graph;\\n    }\\n}\\n```\\n\\n**Python 3** (Thanks to @venetor for this Python 3 solution.)\\n```\\ndef minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n    adj = [[] for _ in range(n)]\\n    for u, v in edges:\\n        adj[u].append(v)\\n        adj[v].append(u)\\n\\n    visited = set()\\n    def dfs(node):\\n        if node in visited:\\n            return 0\\n        visited.add(node)\\n        secs = 0\\n        for child in adj[node]:\\n            secs += dfs(child)\\n        if secs > 0:\\n            return secs + 2\\n        return 2 if hasApple[node] else 0\\n\\n    return max(dfs(0) - 2, 0)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> g; // to store the graph\\n    unordered_map<int, bool> visited; // to stop exploring same nodes again and again.\\n\\t\\n    void createGraph(vector<vector<int>>& edges) {\\n      for (auto e: edges) {\\n        g[e[0]].push_back(e[1]); // adjecency list representation\\n\\t\\tg[e[1]].push_back(e[0]); // adjecency list representation\\n      }\\n    }\\n  \\n    int dfs(int node, int myCost, vector<bool>& hasApple) {\\n\\t  if (visited[node]) {\\n\\t\\t  return 0;\\n\\t  }\\n\\t  visited[node] = true;\\n\\t  \\n      int childrenCost = 0; // cost of traversing all children. \\n      for (auto x: g[node]) { \\n        childrenCost += dfs(x, 2, hasApple);  // check recursively for all apples.\\n      }\\n\\n      if (childrenCost == 0 && hasApple[node] == false) {\\n\\t  // If no child has apples, then we won\\'t traverse the subtree, so cost will be zero.\\n\\t  // similarly, if current node also does not have the apple, we won\\'t traverse this branch at all, so cost will be zero.\\n        return 0;\\n      }\\n\\t  \\n\\t  // Children has at least one apple or the current node has an apple, so add those costs.\\n      return (childrenCost + myCost);\\n    }\\n  \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n      createGraph(edges); // construct the graph first.\\n      return dfs(0, 0, hasApple); // cost of reaching the root is 0. For all others, its 2.\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n        Map<Integer, List<Integer>> graph = createGraph(edges); // to store the graph\\n        Map<Integer, Boolean> visited = new HashMap<>();\\n\\t\\t\\n        return dfs(graph, 0, hasApple, 0, visited); // cost of reaching the root is 0. For all others, its 2.\\n      \\n    }\\n    \\n    private int dfs(Map<Integer, List<Integer>> graph, int node, List<Boolean> hasApple, int myCost, Map<Integer, Boolean> visited) {\\n        Boolean v = visited.getOrDefault(node, false);\\n\\t\\tif (v) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tvisited.put(node, true);\\n\\t\\t\\n        int childrenCost = 0; // cost of traversing all children. \\n      \\n        for(int n : graph.getOrDefault(node, new ArrayList<>())) {\\n            childrenCost += dfs(graph, n, hasApple, 2, visited); // check recursively for all apples in subtrees.\\n        }\\n      \\n        if (childrenCost == 0 && hasApple.get(node) == false) {\\n          // If no child has apples, then we won\\'t traverse the subtree, so cost will be zero.\\n          // similarly, if current node also does not have the apple, we won\\'t traverse this branch at all, so cost will be zero.\\n          return 0;\\n        }\\n      \\n        return childrenCost + myCost;\\n    }\\n    \\n    private Map<Integer, List<Integer>> createGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n      \\n        for(int i = 0; i < edges.length; i++) {\\n            List<Integer> list = graph.getOrDefault(edges[i][0], new ArrayList<>()); // Adjecency list representation.\\n            list.add(edges[i][1]);\\n            graph.put(edges[i][0], list);\\n\\t\\t\\t\\n\\t\\t\\tlist = graph.getOrDefault(edges[i][1], new ArrayList<>()); // Adjecency list representation.\\n            list.add(edges[i][0]);\\n            graph.put(edges[i][1], list);\\n        }\\n      \\n        return graph;\\n    }\\n}\\n```\n```\\ndef minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n    adj = [[] for _ in range(n)]\\n    for u, v in edges:\\n        adj[u].append(v)\\n        adj[v].append(u)\\n\\n    visited = set()\\n    def dfs(node):\\n        if node in visited:\\n            return 0\\n        visited.add(node)\\n        secs = 0\\n        for child in adj[node]:\\n            secs += dfs(child)\\n        if secs > 0:\\n            return secs + 2\\n        return 2 if hasApple[node] else 0\\n\\n    return max(dfs(0) - 2, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033301,
                "title": "python3-dfs-explained",
                "content": "**Code with no comments at the end, in case you don\\'t want to read the story but just want to compare mine with yours**\\n\\n**Intuition**\\n- One way or another we will have to construct the tree first, since the tree is undriected, we just add both directions. I\\'m using a hashmap to represent the tree, where key represents a starting node, and value is a list representing the neighbor nodes of the key node.\\n - The difference between tree and graph is that tree doesn\\'t contain any cycles in it, however since this tree is undirected, a node\\'s neighbor nodes will also contain its parent node (I just called it one edge cycle) e.g., node A connected to node B means B is also connected to A. (We need to check this one edge cycle when doing the search)\\n - In order to pick up an apple on some node, we will have to travel from the root to that node with the shorest path. Since this is a tree, the shorest path is just going from the root to the node that has an apple (Again, we should\\'t travel back and forth, which means we shouldn\\'t visit parent node if we come from there).\\n - We start from node 0 and using a postorder DFS to search the tree.\\n - Once we visited all the children nodes, we need to check two things:\\n \\t- Are there any apple in the children nodes?\\n \\t- Is the current node has an apple?\\n - If any of these two conditions is True, we will have to come to this node in our result, so just add 2 (Adding 2, because 1 for coming to this node, 1 for going back.)\\n\\n**TC: O(N)**\\n\\n**Code with comments**\\n```python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        # Construct the tree using the edges.\\n        # Since the tree is undricted, we need to add both directions in the tree.\\n        tree = defaultdict(list)\\n        for s,e in edges:\\n            tree[s].append(e)\\n            tree[e].append(s)\\n        \\n        # node is the current node we are examing.\\n        # par is the node\\'s direct parent node.\\n        def dfs(node,par):\\n            res = 0\\n            # Since it is a tree, there will be no cycles.\\n            # However, the tree is undirected, which means one of the neighbor node is its parent node.\\n            for nei in tree[node]:\\n                # Make sure we are not going backward to its parent node.\\n                if nei != par:\\n                    res += dfs(nei,node)\\n            \\n            # case1, res != 0, this means we have found some apples down the tree\\n            # case2, hasApple[node]==True, this means the current node has a apple on it\\n            # In both cases, we will have to increase the result by 2.\\n            # Adding 2 because we need 1 to get to this node and 1 going back\\n            if res or hasApple[node]:\\n                return res + 2\\n            \\n            # There is no apple on this node or down the tree, res should 0.\\n            # In this case we don\\'t want to come to this node at all, so return 0.\\n            return res\\n        \\n        # Following the dfs, you can see that when we coming back to node 0, if there are some apples in the tree,\\n        # We added an extra 2 to the result, so we need to -2 here.\\n        # In case there is no apples in this tree, dfs will return 0, but we can\\'t return -2, so just return 0\\n        return max(dfs(0,-1)-2, 0)\\n```\\n\\n**Code without comments**\\n```python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n\\n        tree = defaultdict(list)\\n        for s,e in edges:\\n            tree[s].append(e)\\n            tree[e].append(s)\\n        \\n        def dfs(node,par):\\n            \\n            res = 0\\n            for nei in tree[node]:\\n                if nei != par:\\n                    res += dfs(nei,node)\\n            \\n            if res or hasApple[node]:\\n                return res + 2\\n\\n            return res\\n\\n        return max(dfs(0,-1)-2, 0)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        # Construct the tree using the edges.\\n        # Since the tree is undricted, we need to add both directions in the tree.\\n        tree = defaultdict(list)\\n        for s,e in edges:\\n            tree[s].append(e)\\n            tree[e].append(s)\\n        \\n        # node is the current node we are examing.\\n        # par is the node\\'s direct parent node.\\n        def dfs(node,par):\\n            res = 0\\n            # Since it is a tree, there will be no cycles.\\n            # However, the tree is undirected, which means one of the neighbor node is its parent node.\\n            for nei in tree[node]:\\n                # Make sure we are not going backward to its parent node.\\n                if nei != par:\\n                    res += dfs(nei,node)\\n            \\n            # case1, res != 0, this means we have found some apples down the tree\\n            # case2, hasApple[node]==True, this means the current node has a apple on it\\n            # In both cases, we will have to increase the result by 2.\\n            # Adding 2 because we need 1 to get to this node and 1 going back\\n            if res or hasApple[node]:\\n                return res + 2\\n            \\n            # There is no apple on this node or down the tree, res should 0.\\n            # In this case we don\\'t want to come to this node at all, so return 0.\\n            return res\\n        \\n        # Following the dfs, you can see that when we coming back to node 0, if there are some apples in the tree,\\n        # We added an extra 2 to the result, so we need to -2 here.\\n        # In case there is no apples in this tree, dfs will return 0, but we can\\'t return -2, so just return 0\\n        return max(dfs(0,-1)-2, 0)\\n```\n```python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n\\n        tree = defaultdict(list)\\n        for s,e in edges:\\n            tree[s].append(e)\\n            tree[e].append(s)\\n        \\n        def dfs(node,par):\\n            \\n            res = 0\\n            for nei in tree[node]:\\n                if nei != par:\\n                    res += dfs(nei,node)\\n            \\n            if res or hasApple[node]:\\n                return res + 2\\n\\n            return res\\n\\n        return max(dfs(0,-1)-2, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033500,
                "title": "java-solution-with-explanation-dfs",
                "content": "\\n\\n# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n1. This code is solving the problem of finding the minimum time required to collect all apples in a given tree. The tree is represented by a list of edges, where each edge connects two nodes, and a list of booleans that indicates whether each node has an apple or not.\\n\\n2. The main function \"minTime\" takes in 3 arguments:\\n\\n- n: number of nodes in the tree\\n- edges: a 2D array representing the edges of the tree\\n- hasApple: a list of booleans indicating whether each node has an apple or not.\\n\\nIt starts by creating an adjacency list representation of the tree from the given edges. An adjacency list is a data structure that is used to represent a graph, where each element of the list represents a node of the graph and contains a list of the nodes it is connected to.\\n\\n3. Then it calls the helper function `\"minTimeToCollectApples\"` which takes four arguments:\\n\\n- index: the current node being processed\\n- adj: the adjacency list representation of the tree\\n- hasApple: a list of booleans indicating whether each node has an apple or not\\n- parent: the parent of the current node\\n\\nThe function starts by initializing a variable \"total\" to zero. It then iterates over all the neighbors of the current node (excluding the parent) and recursively calls the function on each of the neighbors. This way it explores all the path from the current node to all the children nodes.\\n\\nThen, if the current node is not the root of the tree and it has an apple or any of its children has an apple, it adds 2 to the \"total\" variable as this represent that we need to take 2 steps: one step to reach the apple and one step back to the parent.\\n\\nFinally, it returns the \"total\" variable.\\n\\n# Code\\n```\\nclass Solution {\\n    // Function to find the minimum time to collect all apples\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        // Create an adjacency list to represent the tree\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        // populate the adjacency list\\n        for(int [] edge : edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n\\n        }\\n        // call to helper function to find the minimum time\\n        return minTimeToCollectApples(0, adj, hasApple, 0);\\n    }\\n    // Helper function\\n    int minTimeToCollectApples(int index, List<List<Integer>> adj, List<Boolean> hasApple, int parent){\\n        // variable to keep track of total time\\n        int total = 0;\\n        // for each neighbor of current node\\n        for(int nbr : adj.get(index)){\\n            // if the neighbor is the parent node, then we skip\\n            if (nbr == parent)\\n             continue;\\n            // we recursively call the helper function for each neighbor\\n            total += minTimeToCollectApples(nbr, adj, hasApple, index);\\n        }\\n        // If current node is not the root (0th) node, and it has an apple or any of its descendant has\\n        //  then we need to add 2 time for moving to and from it\\n        if( index != 0 && (hasApple.get(index) || total > 0))\\n          total += 2;\\n        return total;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Function to find the minimum time to collect all apples\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        // Create an adjacency list to represent the tree\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        // populate the adjacency list\\n        for(int [] edge : edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n\\n        }\\n        // call to helper function to find the minimum time\\n        return minTimeToCollectApples(0, adj, hasApple, 0);\\n    }\\n    // Helper function\\n    int minTimeToCollectApples(int index, List<List<Integer>> adj, List<Boolean> hasApple, int parent){\\n        // variable to keep track of total time\\n        int total = 0;\\n        // for each neighbor of current node\\n        for(int nbr : adj.get(index)){\\n            // if the neighbor is the parent node, then we skip\\n            if (nbr == parent)\\n             continue;\\n            // we recursively call the helper function for each neighbor\\n            total += minTimeToCollectApples(nbr, adj, hasApple, index);\\n        }\\n        // If current node is not the root (0th) node, and it has an apple or any of its descendant has\\n        //  then we need to add 2 time for moving to and from it\\n        if( index != 0 && (hasApple.get(index) || total > 0))\\n          total += 2;\\n        return total;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623686,
                "title": "java-detailed-explanation-build-tree-dfs",
                "content": "**[Updated]** Still need bi-direction graph and use visited set. Example test case for that: (Thanks @hiepit and @notebook, my bad)\\n*4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\nExpected Answer: 4*\\n\\nKey Notes: \\n* You need to consume 2 seconds to simply collect an apple node (come and go)\\n* Consider a node:\\n\\t* If none of descendant (including itself) has an apple, we don\\'t need to waste time on this node\\n\\t* If any of descendant has an apple (no matter if it-self has an apple or not), we need to consume 2 seconds on this node anyway\\n* Collect node 0 does not need to consume any time\\n\\nThen, we can have a helper dfs function meaning: time needs to waste on this node to collect all apples. (0 or > 0).\\n\\n```java\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\tbuildTree(edges, map);\\n\\tSet<Integer> visited = new HashSet<>();\\n\\treturn helper(0, map, hasApple, visited);\\n}\\n\\nprivate int helper(int node, Map<Integer, List<Integer>> map, List<Boolean> hasApple, Set<Integer> visited) {\\n\\n\\tvisited.add(node);\\n\\n\\tint res = 0;\\n\\n\\tfor (int child : map.getOrDefault(node, new LinkedList<>())) {\\n\\t\\tif (visited.contains(child)) continue;\\n\\t\\tres += helper(child, map, hasApple, visited);\\n\\t}\\n\\n\\tif ((res > 0 || hasApple.get(node)) && node != 0) res += 2;\\n\\n\\treturn res;\\n}\\n\\nprivate void buildTree(int[][] edges, Map<Integer, List<Integer>> map) {\\n\\n\\tfor (int[] edge : edges) {\\n\\t\\tint a = edge[0], b = edge[1];\\n\\t\\tmap.putIfAbsent(a, new LinkedList<>());\\n\\t\\tmap.putIfAbsent(b, new LinkedList<>());\\n\\t\\tmap.get(a).add(b);\\n\\t\\tmap.get(b).add(a);\\n\\t}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\tbuildTree(edges, map);\\n\\tSet<Integer> visited = new HashSet<>();\\n\\treturn helper(0, map, hasApple, visited);\\n}\\n\\nprivate int helper(int node, Map<Integer, List<Integer>> map, List<Boolean> hasApple, Set<Integer> visited) {\\n\\n\\tvisited.add(node);\\n\\n\\tint res = 0;\\n\\n\\tfor (int child : map.getOrDefault(node, new LinkedList<>())) {\\n\\t\\tif (visited.contains(child)) continue;\\n\\t\\tres += helper(child, map, hasApple, visited);\\n\\t}\\n\\n\\tif ((res > 0 || hasApple.get(node)) && node != 0) res += 2;\\n\\n\\treturn res;\\n}\\n\\nprivate void buildTree(int[][] edges, Map<Integer, List<Integer>> map) {\\n\\n\\tfor (int[] edge : edges) {\\n\\t\\tint a = edge[0], b = edge[1];\\n\\t\\tmap.putIfAbsent(a, new LinkedList<>());\\n\\t\\tmap.putIfAbsent(b, new LinkedList<>());\\n\\t\\tmap.get(a).add(b);\\n\\t\\tmap.get(b).add(a);\\n\\t}\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623679,
                "title": "c-short-and-simple-dfs",
                "content": "**Observation**\\nWe know that graph is in a form of tree i.e no cycles and that the last node is supposed to be the root it self, this gives us an idea that we can use DFS to solve this.\\nAt each node we can check if its children has any apples if it does we add the distance from current node to that child node and we return this distance else we return `0`.\\nThe other key observation is that each time we collect the apple we have to walk back to the parent, thus the distance travelled is doubled.\\n\\n**Solution**\\nWe can return the distance as 0 if no apples found under the node and the current node also doesn\\'t have an apple else we return the distance travelled.\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp)\\t\\t\\t//If child has apples it\\'ll return a non zero result which is the distance traveled upto that node.\\n\\t\\t    result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0;  //If nothing is added to result and current node doesnt have apple return 0 else return distances of children + current distance from root.\\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;     //Result is doubled the distance travelled as per our observation.\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp)\\t\\t\\t//If child has apples it\\'ll return a non zero result which is the distance traveled upto that node.\\n\\t\\t    result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0;  //If nothing is added to result and current node doesnt have apple return 0 else return distances of children + current distance from root.\\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;     //Result is doubled the distance travelled as per our observation.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624141,
                "title": "clean-python-3-peel-onion-in-o-n-100-time-space",
                "content": "Just like performing Kahn\\'s algorithm of topological sort on a tree.\\nSum degrees of each node first, then peel the tree from those nodes whose degree is 1.\\nOnce there is no appropriate node can be removed, just return sum of all degrees.\\nNote that we shouldn\\'t peel node `0` so let `hasApple[0] = True` at beginning.\\nTime: `O(N)`\\nEach edge will be visited at most twice, and there will be n - 1 edges because it\\'s a tree.\\nSpace: `O(N)`\\n```\\nimport collections\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        hasApple[0], degree = True, [0] * n\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            degree[u] += 1\\n            degree[v] += 1\\n        queue = collections.deque(v for v in range(n) if degree[v] == 1)\\n        while queue:\\n            u = queue.popleft()\\n            if hasApple[u]: continue\\n            for v in graph[u]:\\n                if degree[v] > 0:\\n                    degree[v] -= 1\\n                    degree[u] -= 1\\n                    if degree[v] == 1:\\n                        queue.append(v)\\n        return sum(degree)\\n```\\n\\n--\\nAnother way to solve this problem is to propagate the nodes which have apples:\\n```\\nimport collections\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        def dfs(node: int, prev: int) -> bool:\\n            for neighbor in graph[node]:\\n                if neighbor != prev and dfs(neighbor, node):\\n                    hasApple[node] = True\\n            return hasApple[node]\\n\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dfs(0, -1)\\n        return (sum(hasApple) - hasApple[0]) * 2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        hasApple[0], degree = True, [0] * n\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            degree[u] += 1\\n            degree[v] += 1\\n        queue = collections.deque(v for v in range(n) if degree[v] == 1)\\n        while queue:\\n            u = queue.popleft()\\n            if hasApple[u]: continue\\n            for v in graph[u]:\\n                if degree[v] > 0:\\n                    degree[v] -= 1\\n                    degree[u] -= 1\\n                    if degree[v] == 1:\\n                        queue.append(v)\\n        return sum(degree)\\n```\n```\\nimport collections\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        def dfs(node: int, prev: int) -> bool:\\n            for neighbor in graph[node]:\\n                if neighbor != prev and dfs(neighbor, node):\\n                    hasApple[node] = True\\n            return hasApple[node]\\n\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dfs(0, -1)\\n        return (sum(hasApple) - hasApple[0]) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033465,
                "title": "easy-c-solution",
                "content": "# Solution\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/033de1fd-1964-4a54-ba93-ea5ca1181e61_1674563847.7582145.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467679,
                "title": "java-easy-approach-with-explanation-preorder-postorder-dfs",
                "content": "```\\nclass Solution \\n{\\n    public int minTime (int n, int[][] edges, List<Boolean> hasApple) \\n    {\\n        ArrayList<ArrayList<Integer>> adjacencyList= new ArrayList<>();\\n        \\n        for (int i= 0; i< n; i++)\\n            adjacencyList.add(new ArrayList<>());//allocating the space for the vertex to store their adjacent vertex \\n        \\n        //Creating the adjacency list from the edge list \\n        for (int []edge: edges)\\n        {\\n            int u= edge[0];\\n            int v= edge[1];\\n            \\n            //undirected graph \\n            adjacencyList.get(u).add(v);   \\n            adjacencyList.get(v).add(u);    \\n        }\\n        boolean visited[]= new boolean[n];//boolean visited array, so that we dont visit the same vertex again \\n        return dfs(adjacencyList ,visited, hasApple, 0);//recursing down in depth of the tree and calculating the time while in postorder, like topological sort(iterative) \\n    }\\n    public int dfs (ArrayList<ArrayList<Integer>> adjacencyList, boolean visited[], List<Boolean> hasApple, int source)\\n    {//preorder marking visited -> recursing in deapth -> postorder time calculation //Bottom Up Approach \\n        visited[source]= true;//marking the current node as visisted \\n        \\n        int totalTime= 0;//time possible \\n        for (int vertex: adjacencyList.get(source)){//recursing down in deapth \\n            if(visited[vertex] == false)//only visiting the unvisited node \\n                totalTime+= dfs(adjacencyList, visited, hasApple, vertex);//calculating the time while we are backtracking  \\n        }\\n        \\n        if (source != 0 && (hasApple.get(source) || totalTime > 0))//we are not considering the starting vertex because we are calculating the total time from bottom to top //case-1) when the total time is greater than 0 then we would include that path(intution: apple already exists previously in the path)//case-2)we are considering the vertex with apple for total time calculation(intution: considering the edge)\\n           totalTime+= 2;//adding two because of 1)moving forward(arriving) 2)moving backward(returning) \\n        return totalTime;//returning the total time to tell the current time status to the parent \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minTime (int n, int[][] edges, List<Boolean> hasApple) \\n    {\\n        ArrayList<ArrayList<Integer>> adjacencyList= new ArrayList<>();\\n        \\n        for (int i= 0; i< n; i++)\\n            adjacencyList.add(new ArrayList<>());//allocating the space for the vertex to store their adjacent vertex \\n        \\n        //Creating the adjacency list from the edge list \\n        for (int []edge: edges)\\n        {\\n            int u= edge[0];\\n            int v= edge[1];\\n            \\n            //undirected graph \\n            adjacencyList.get(u).add(v);   \\n            adjacencyList.get(v).add(u);    \\n        }\\n        boolean visited[]= new boolean[n];//boolean visited array, so that we dont visit the same vertex again \\n        return dfs(adjacencyList ,visited, hasApple, 0);//recursing down in depth of the tree and calculating the time while in postorder, like topological sort(iterative) \\n    }\\n    public int dfs (ArrayList<ArrayList<Integer>> adjacencyList, boolean visited[], List<Boolean> hasApple, int source)\\n    {//preorder marking visited -> recursing in deapth -> postorder time calculation //Bottom Up Approach \\n        visited[source]= true;//marking the current node as visisted \\n        \\n        int totalTime= 0;//time possible \\n        for (int vertex: adjacencyList.get(source)){//recursing down in deapth \\n            if(visited[vertex] == false)//only visiting the unvisited node \\n                totalTime+= dfs(adjacencyList, visited, hasApple, vertex);//calculating the time while we are backtracking  \\n        }\\n        \\n        if (source != 0 && (hasApple.get(source) || totalTime > 0))//we are not considering the starting vertex because we are calculating the total time from bottom to top //case-1) when the total time is greater than 0 then we would include that path(intution: apple already exists previously in the path)//case-2)we are considering the vertex with apple for total time calculation(intution: considering the edge)\\n           totalTime+= 2;//adding two because of 1)moving forward(arriving) 2)moving backward(returning) \\n        return totalTime;//returning the total time to tell the current time status to the parent \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 623786,
                "title": "c-c-java-javascript-simple-map-solution-no-recursion-bottom-up",
                "content": "If there\\'s an apple for number - travel from the node with apple to the root. So we need a map - child to parent.\\nDo not travel same path again - mark as `-1` in the map.\\n\\n**[update] Since they updated test cases and no longer guarantee that edges are sorted, we need to do sorting first, which makes complexity O(NlogN) instead of O(N) Anyways I think it\\'s good to know that there\\'re other ways to solve the problem when certain preconditions\\'re met.**\\n\\n*Note: this solution is good for when there\\'s no guarantee that edges are \"sorted\" by level. It looks like they are sorted, so there\\'s event simpler solution by traversing edges from end to start and propogating apples to parents.*\\n\\nC++\\n```\\nint minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n    unordered_map<int, int> m;\\n\\tstd::sort(edges.begin(), edges.end());\\n   for(auto const& edge : edges)  {\\n        if (m.count(edge[1]) > 0) m[edge[0]] = edge[1];\\n        else m[edge[1]] = edge[0];\\n    }\\n    int result = 0;\\n    for(int i = 0; i < hasApple.size(); ++i) {\\n        if (!hasApple[i]) continue;\\n        int parent = i;\\n        while(parent != 0 && m[parent] >= 0) {\\n            auto temp = m[parent];\\n            m[parent] = -1;\\n            parent = temp;\\n            result += 2;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\n\\nC#\\n```\\npublic int MinTime(int n, int[][] edges, IList<bool> hasApple) {\\n    var m = new Dictionary<int, int>();\\n\\tedges = edges.OrderBy(x => x[0]).ToArray(); // sort if needed, input used to be sorted\\n    foreach(var edge in edges)\\n        if (m.ContainsKey(edge[1]))\\n            m[edge[0]] = edge[1];\\n        else \\n            m[edge[1]] = edge[0];\\n\\n    var result = 0;\\n    for(var i = 0; i < hasApple.Count; ++i) {\\n        if (!hasApple[i]) continue;\\n        var p = i;\\n        while(p != 0 && m[p] >= 0) {\\n            var temp = m[p];\\n            m[p] = -1; // mark as visited\\n            p = temp;\\n            result += 2;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nJava\\n```\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n    HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\\n\\tjava.util.Arrays.sort(edges, new java.util.Comparator<int[]>() {\\n        public int compare(int[] a, int[] b) {\\n            return a[0] - b[0];\\n        }\\n    });\\n    for(int[] edge: edges)\\n\\t\\tif (m.containsKey(edge[1]))\\n            m.put(edge[0], edge[1]);\\n        else\\n            m.put(edge[1], edge[0]);\\n\\n    int result = 0;\\n    for(int i = 0; i < hasApple.size(); ++i) {\\n        if (!hasApple.get(i)) continue;\\n        int p = i;\\n        while(p != 0 && m.get(p) >= 0) {\\n            int temp = m.get(p);\\n            m.put(p, -1); // mark as visited\\n            p = temp;\\n            result += 2;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nJavascript\\n```\\nvar minTime = function(n, edges, hasApple) {\\n    const m = {};\\n\\tedges.sort((a,b) => a[0] - b[0]);\\n    for(let edge of edges) \\n        if (m[edge[1]] !== undefined)\\n            m[edge[0]] = edge[1];\\n        else\\n            m[edge[1]] = edge[0];\\n\\n    let result = 0;\\n    for(let i = 0; i < hasApple.length; ++i) {\\n        if (!hasApple[i]) continue;\\n        let p = i;\\n        while(p != 0 && m[p] >= 0) {\\n            const temp = m[p];\\n            m[p] = -1; // mark as visited\\n            p = temp;\\n            result += 2;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript"
                ],
                "code": "```\\nint minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n    unordered_map<int, int> m;\\n\\tstd::sort(edges.begin(), edges.end());\\n   for(auto const& edge : edges)  {\\n        if (m.count(edge[1]) > 0) m[edge[0]] = edge[1];\\n        else m[edge[1]] = edge[0];\\n    }\\n    int result = 0;\\n    for(int i = 0; i < hasApple.size(); ++i) {\\n        if (!hasApple[i]) continue;\\n        int parent = i;\\n        while(parent != 0 && m[parent] >= 0) {\\n            auto temp = m[parent];\\n            m[parent] = -1;\\n            parent = temp;\\n            result += 2;\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\npublic int MinTime(int n, int[][] edges, IList<bool> hasApple) {\\n    var m = new Dictionary<int, int>();\\n\\tedges = edges.OrderBy(x => x[0]).ToArray(); // sort if needed, input used to be sorted\\n    foreach(var edge in edges)\\n        if (m.ContainsKey(edge[1]))\\n            m[edge[0]] = edge[1];\\n        else \\n            m[edge[1]] = edge[0];\\n\\n    var result = 0;\\n    for(var i = 0; i < hasApple.Count; ++i) {\\n        if (!hasApple[i]) continue;\\n        var p = i;\\n        while(p != 0 && m[p] >= 0) {\\n            var temp = m[p];\\n            m[p] = -1; // mark as visited\\n            p = temp;\\n            result += 2;\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n    HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\\n\\tjava.util.Arrays.sort(edges, new java.util.Comparator<int[]>() {\\n        public int compare(int[] a, int[] b) {\\n            return a[0] - b[0];\\n        }\\n    });\\n    for(int[] edge: edges)\\n\\t\\tif (m.containsKey(edge[1]))\\n            m.put(edge[0], edge[1]);\\n        else\\n            m.put(edge[1], edge[0]);\\n\\n    int result = 0;\\n    for(int i = 0; i < hasApple.size(); ++i) {\\n        if (!hasApple.get(i)) continue;\\n        int p = i;\\n        while(p != 0 && m.get(p) >= 0) {\\n            int temp = m.get(p);\\n            m.put(p, -1); // mark as visited\\n            p = temp;\\n            result += 2;\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\nvar minTime = function(n, edges, hasApple) {\\n    const m = {};\\n\\tedges.sort((a,b) => a[0] - b[0]);\\n    for(let edge of edges) \\n        if (m[edge[1]] !== undefined)\\n            m[edge[0]] = edge[1];\\n        else\\n            m[edge[1]] = edge[0];\\n\\n    let result = 0;\\n    for(let i = 0; i < hasApple.length; ++i) {\\n        if (!hasApple[i]) continue;\\n        let p = i;\\n        while(p != 0 && m[p] >= 0) {\\n            const temp = m[p];\\n            m[p] = -1; // mark as visited\\n            p = temp;\\n            result += 2;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623969,
                "title": "c-simple-solution-o-n",
                "content": "Find the apples from the end and check where you come from, then, let the start point of edge true(as an apple). Finally, count the number of edge you need to go through and it cost 2 seconds for each edge(back and forth).\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        int cnt = 0;\\n        for(int i=edges.size()-1; i>=0; i--){\\n            if(hasApple[edges[i][1]]){\\n                cnt++;\\n                hasApple[edges[i][0]] = true;\\n            } \\n        }\\n        return cnt*2;\\n    }\\n};\\n```\\n\\nthanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        int cnt = 0;\\n        for(int i=edges.size()-1; i>=0; i--){\\n            if(hasApple[edges[i][1]]){\\n                cnt++;\\n                hasApple[edges[i][0]] = true;\\n            } \\n        }\\n        return cnt*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032993,
                "title": "java-c-javascript-beats-99-dfs-easy-concise-and-clean-code",
                "content": "``` java []\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n        //creating adjacency list\\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i]=new ArrayList<Integer>();\\n        }\\n        for(int[] x:edges){\\n            a[x[0]].add(x[1]);\\n            a[x[1]].add(x[0]);\\n        }\\n\\n        return dfs(-1,0,a,hasApple);\\n    }\\n\\n    private int dfs(int prev,int curr,ArrayList<Integer>[] a,List<Boolean> hasApple)\\n    {\\n        int ans=0;\\n        for(int x:a[curr])\\n        {\\n            if(x!=prev){\\n               int res = dfs(curr,x,a,hasApple);\\n               if(res>0||hasApple.get(x))\\n                   ans+=(res+2);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n       // creating adjacency list\\n        vector<vector<int>> a(n);\\n        for (auto& x : edges) {\\n            a[x[0]].push_back(x[1]);\\n            a[x[1]].push_back(x[0]);\\n        }\\n\\n        return dfs(-1, 0, a, hasApple);\\n    }\\n\\n    int dfs(int prev, int curr, vector<vector<int>>& a, vector<bool>& hasApple) {\\n        int ans = 0;\\n        for (auto x : a[curr]) {\\n            if (x != prev) {\\n                int res = dfs(curr, x, a, hasApple);\\n                if (res > 0 || hasApple[x]) {\\n                    ans += (res + 2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n``` javascript []\\nvar minTime = function(n, edges, hasApple) {\\n        // creating adjacency list\\n        let a = new Array(n);\\n        for (let i = 0; i < n; i++) {\\n            a[i] = [];\\n        }\\n        for (let x of edges) {\\n            a[x[0]].push(x[1]);\\n            a[x[1]].push(x[0]);\\n        }\\n\\n        return dfs(-1, 0, a, hasApple);\\n    };\\n\\n    function dfs(prev, curr, a, hasApple) {\\n        let ans = 0;\\n        for (let x of a[curr]) {\\n            if (x !== prev) {\\n                let res = dfs(curr, x, a, hasApple);\\n                if (res > 0 || hasApple[x]) {\\n                    ans += (res + 2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n        //creating adjacency list\\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i]=new ArrayList<Integer>();\\n        }\\n        for(int[] x:edges){\\n            a[x[0]].add(x[1]);\\n            a[x[1]].add(x[0]);\\n        }\\n\\n        return dfs(-1,0,a,hasApple);\\n    }\\n\\n    private int dfs(int prev,int curr,ArrayList<Integer>[] a,List<Boolean> hasApple)\\n    {\\n        int ans=0;\\n        for(int x:a[curr])\\n        {\\n            if(x!=prev){\\n               int res = dfs(curr,x,a,hasApple);\\n               if(res>0||hasApple.get(x))\\n                   ans+=(res+2);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n       // creating adjacency list\\n        vector<vector<int>> a(n);\\n        for (auto& x : edges) {\\n            a[x[0]].push_back(x[1]);\\n            a[x[1]].push_back(x[0]);\\n        }\\n\\n        return dfs(-1, 0, a, hasApple);\\n    }\\n\\n    int dfs(int prev, int curr, vector<vector<int>>& a, vector<bool>& hasApple) {\\n        int ans = 0;\\n        for (auto x : a[curr]) {\\n            if (x != prev) {\\n                int res = dfs(curr, x, a, hasApple);\\n                if (res > 0 || hasApple[x]) {\\n                    ans += (res + 2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` javascript []\\nvar minTime = function(n, edges, hasApple) {\\n        // creating adjacency list\\n        let a = new Array(n);\\n        for (let i = 0; i < n; i++) {\\n            a[i] = [];\\n        }\\n        for (let x of edges) {\\n            a[x[0]].push(x[1]);\\n            a[x[1]].push(x[0]);\\n        }\\n\\n        return dfs(-1, 0, a, hasApple);\\n    };\\n\\n    function dfs(prev, curr, a, hasApple) {\\n        let ans = 0;\\n        for (let x of a[curr]) {\\n            if (x !== prev) {\\n                let res = dfs(curr, x, a, hasApple);\\n                if (res > 0 || hasApple[x]) {\\n                    ans += (res + 2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034086,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> adj[], vector<bool> &hasApple, int node, int parent) {\\n        int distance = 0; //total time to collect all apples from the root.\\n        for(auto i:adj[node]) {\\n            if(i!=parent) {\\n                int temp=dfs(adj, hasApple, i, node); //store whether root\\'s child has an apple or not.\\n                if(hasApple[i]) { //if root\\'s child has an apple, then we will add 2 to the time, as you have to come back.\\n                    distance+=(2+temp);\\n                    hasApple[node]=true; //hasApple[node] has been changed to true because its child has an apple, so for sure you will be returning back.\\n                }\\n            } \\n        }\\n        return distance;\\n    }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return dfs(adj, hasApple, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> adj[], vector<bool> &hasApple, int node, int parent) {\\n        int distance = 0; //total time to collect all apples from the root.\\n        for(auto i:adj[node]) {\\n            if(i!=parent) {\\n                int temp=dfs(adj, hasApple, i, node); //store whether root\\'s child has an apple or not.\\n                if(hasApple[i]) { //if root\\'s child has an apple, then we will add 2 to the time, as you have to come back.\\n                    distance+=(2+temp);\\n                    hasApple[node]=true; //hasApple[node] has been changed to true because its child has an apple, so for sure you will be returning back.\\n                }\\n            } \\n        }\\n        return distance;\\n    }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return dfs(adj, hasApple, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623706,
                "title": "python-dfs-easy-to-understand-with-comments",
                "content": "**Intuition**\\n\\nMy idea was to find the lowest apple on each branch of the root and add the distance from the lowest apple to the root. \\n\\n![image](https://assets.leetcode.com/users/smolarek9/image_1589083348.png)\\n\\n\\nFor example, imagine you only have a tree that looks like this (image above) where there are only three nodes and only the left node of the root is an apple. You will have to check if an apple is found from the left branch and how far it is from the root. We would have to add the distance that we traveled eventually. \\n\\nFor the right branch, since the apple is not found, we won\\'t have to add any distance since we won\\'t even try to travel to that branch.\\n\\nWe can perform a postorder traversal to pass-up the information of the node in a bottom-up manner. If a node is a leaf and an apple, that is the base case; we return the information that the apple has been found. In the upper node, we get the information from the bottom and add the distance from the lowest apple to the child node (0 in the diagram since that is the lowest apple) plus 2 (since we have to travel to and from that node) and the information that the apple was found in this branch to the upper node.\\n\\nEventually, the root node will return the information of how many steps we need to travel to collect all apples in the tree.\\n\\n**Code**\\n\\n```\\nInfo = collections.namedtuple(\\'Info\\', (\\'found\\', \\'dist\\'))\\n\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        \\n        # build an adjacency list to represent the tree using `edges`\\n        tree = collections.defaultdict(list)\\n\\t\\t\\n\\t\\t# You don\\'t need to make it undirected since the structure represents a tree\\n        for u, v in edges:\\n            tree[u].append(v)\\n        \\n        # A recursive helper function that find the lowest apple and passes\\n        # the information (is apple found, distance from the lowest apple to the current node)\\n        # to the upper node\\n        \\n        def traverse(node):\\n            if node not in tree:\\n                return Info(hasApple[node], 0)\\n            curr_dist, apple_found = 0, hasApple[node]\\n            for child in tree[node]:\\n                info = traverse(child)\\n                curr_dist += 2 + info.dist if info.found else 0\\n                apple_found |= info.found\\n            return Info(apple_found, curr_dist)\\n        \\n        # Get the information from the starting vertex 0\\n        return traverse(0).dist\\n```\\n\\nTime: `O(N)` where `N = num of nodes`\\nSpace: `O(N)`\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nInfo = collections.namedtuple(\\'Info\\', (\\'found\\', \\'dist\\'))\\n\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        \\n        # build an adjacency list to represent the tree using `edges`\\n        tree = collections.defaultdict(list)\\n\\t\\t\\n\\t\\t# You don\\'t need to make it undirected since the structure represents a tree\\n        for u, v in edges:\\n            tree[u].append(v)\\n        \\n        # A recursive helper function that find the lowest apple and passes\\n        # the information (is apple found, distance from the lowest apple to the current node)\\n        # to the upper node\\n        \\n        def traverse(node):\\n            if node not in tree:\\n                return Info(hasApple[node], 0)\\n            curr_dist, apple_found = 0, hasApple[node]\\n            for child in tree[node]:\\n                info = traverse(child)\\n                curr_dist += 2 + info.dist if info.found else 0\\n                apple_found |= info.found\\n            return Info(apple_found, curr_dist)\\n        \\n        # Get the information from the starting vertex 0\\n        return traverse(0).dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624095,
                "title": "3-solutions-simple-count-dfs-bfs-picture-comments-road-metaphor",
                "content": "**Solution 1: DFS  (Time/Space: O(N), O(N))**  \\nGiven the \\u2018Y\\u2019 shape nature of the tree branches, I was so confused in the contest and can not find a good way to avoid repeating counting.  \\nBut remeber the great slogan, \\'If you wanna be rich, build the rode first\\'.\\nWe only build the road from root to and only to ALL apples.\\nSo, this is kind of like counting the total road length of the \\'root to all apples\\'. Once you get this total length, you need to double it since it is a back and forth journey for you.\\n\\n**Complexity Analysis:**\\n\\n**Time Complexity: O(N).  **\\n\\nThere is N nodes, N-1 edeges, each need be explore.\\n\\n\\n**Space Complexity: O(N). **\\n\\nNoticed that adJList is used to store edges in both directions, so the total space is: 2*(N-1);\\nPlus, the reucusion stakc also O(N) space in worst case. \\nSo overall is: O(3N). After droping constant factor, you can get the space complexity: O(N).\\nFor example,  we can check example 1, N=7, i.e., 7 nodes, 6 edges, adjacency list, adjList, need store 12 edges information. \\n\\n\\n\\nI will make a small illustration on Example one to make it better to understand.\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1589091777.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    vector<bool> visited;\\n    \\n    // returned value: rode length from root to and only to ALL apples which can be found beyond and include node\\n    int dfs(int node,vector<bool>& hasApple,int d){\\n        visited[node]=true;\\n        int result=d;\\t//Initialize result as d.        \\n        for(auto &child:adjList[node])\\n            if(!visited[child]) {\\n                int dist2apple=dfs(child,hasApple,d+1); //rode distance between root to ALL apples  beyound node \\'child\\'\\n                if(dist2apple)  //If child has apples it\\'ll return a non zero result which is the distance traveled upto that node.\\n                    result+=dist2apple-d;                     \\n            }\\n        \\n        return (hasApple[node]   // current \\'node\\' has apple\\n                ||               // or  \\n                result > d) ?    // offspring(s) of current \\'node\\' have apple(s)\\n                result: 0;       // if true, we count the road length, otherwise, no road is needed.\\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple){\\n        adjList.resize(n);\\n        visited.resize(n,false);\\n        for(auto& e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(0,hasApple,0)*2;     //Result is the distance travelled doubled as per our observation.\\n    }\\n};\\n// reference & credit @PhoneixDD: \\n// https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/623679/C%2B%2B-Simple-DFS\\n```\\n\\n**Solution 1b: DFS (without logging visiting info)**   (Time/Space: O(N), O(N))\\nDue to the fact from_i < to_i, we know the node value of child is always bigger than parent. We do not neet extra variable to log visiting info.\\n```\\nclass Solution {  // Solution 1b: DFS\\npublic://1044-1053-1058\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int> > G(n);\\n        for(auto& e: edges) G[e[0]].push_back(e[1]),G[e[1]].push_back(e[0]);        \\n        return dfs(G, hasApple, 0, 0) * 2;\\n    }\\n    \\nprivate:\\n    \\n    //returned value: the road length from root to all apples within the subtree rooted at cur\\n    int dfs(vector<vector<int> >& G, vector<bool>& hasApple, int cur, int d){\\n        int ans = d;    \\n        for(auto& next: G[cur]){    \\n            if(next < cur) continue;//if ture, this is parent of cur, skip \\n            int dist2app = dfs(G, hasApple, next, d+1);\\n            if(dist2app != 0)\\n                ans += dist2app - d;\\n        }\\n        return hasApple[cur] || ans > d ? ans : 0;        \\n    }\\n};\\n```\\n**Solution 2:  simple count ( Time/Space: O(NlogN); O(1) )**\\nIf you carefully check the figure in the right-hand-side, the road length is is also same as the number of visited vodes for you to reach all apples.\\nSo we got second solution.\\n\\nFind the apples from the end and check where you come from, then, let the start point of edge true(as an apple). Finally, count the number of edge you need to go through and it cost 2 seconds for each edge(back and forth).\\n```\\nclass Solution { // Solution 2: simple count\\npublic: // Time/Space: O(NlogN); O(1)\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        int cnt = 0;           \\n        sort(edges.begin(), edges.end()); // this is must to ensure value of parent is smaller than child\\n        //for(int i=n-2; i>=0; i--)   // also ok\\n        for(int i= edges.size() - 1; i>=0; i--)  //Note1: visit most distant child first       \\n            if(hasApple[edges[i][1]]){\\n                cnt++;\\n                hasApple[edges[i][0]] = true;\\n            }         \\n        return cnt*2;\\n    }\\n};\\n```\\n\\n**Solution 2b: simple count ( Time/Space: O(N); O(N) )**\\nThanks for the push from @jdanray, who complains about the O(NlogN) time cost, so I increase the O(1) space to O(N) to reduce the time cost from O(NlogN) to O(N)\\n\\n```\\nclass Solution { // Solution 2b: simple count\\npublic: // Time/Space: O(N); O(N)\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {        \\n        //unordered_map<int,int> parents; // ok, if you hate thinking about default value for vector based hashmap solution.\\n        vector<int> parents(n,0); // Be careful about the default value.  parents[i]:= the parent of node i.\\n        for(auto& e: edges) parents[e[1]] = e[0];        \\n        for(int i= n - 1; i>=0; i--)  //Note1: visit most distant child first       \\n            if(hasApple[i]) hasApple[parents[i]] = true; // if a child is apple, convert their parent into apple            \\n        int cnt = count(hasApple.begin(), hasApple.end(), true); // count how many apples in total, \\n        // if count is non zero, then \\'cnt\\' is the apple/node count of purely apple sub-tree, then edge count is: cnt-1\\n        return cnt == 0 ? 0 : (cnt-1)*2;         \\n    }\\n};\\n```\\nRef:\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/623969/C%2B%2B-Simple-Solution-O(n)\\n\\n**Solution 3: BFS  (Time/Space: O(N), O(N))**\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& has) {\\n        //1: build the Graph: G\\n        vector<int> G[n],dist(n,1e9),par(n,1e9);\\n        for(auto& x:edges){\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n            par[x[1]]=x[0];\\n        }\\n        \\n        //2: measure the distances of each node from root\\n        queue<int> q{{0}};\\n        dist[0]=0;        \\n        while(!q.empty()){\\n            int cur = q.front(); q.pop();\\n            for(int x:G[cur]){\\n                if(dist[x]==1e9){\\n                    dist[x]=dist[cur]+1;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        //3: accumulate the distance from child to its first visited parent\\n        int cnt=0;\\n        vector<int> vis(n,0);\\n        for(int i=n-1;i>=0;i--){\\n            if(has[i]==true && vis[i]==0){ // i: node with apple and unvisited yet\\n                int q = i; // find the first visited parent of i\\n                while(par[q]!=1e9 and vis[q]==0){\\n                    vis[q]=1;\\n                    q = par[q];\\n                }// now, q points to the first visited parent of i\\n                vis[i]=1;                \\n                cnt += 2*(dist[i]-dist[q]);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nReference and credit @wanottle:\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/624126/C%2B%2B-or-BFS-or-Simple-Solution-with-explanation\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    vector<bool> visited;\\n    \\n    // returned value: rode length from root to and only to ALL apples which can be found beyond and include node\\n    int dfs(int node,vector<bool>& hasApple,int d){\\n        visited[node]=true;\\n        int result=d;\\t//Initialize result as d.        \\n        for(auto &child:adjList[node])\\n            if(!visited[child]) {\\n                int dist2apple=dfs(child,hasApple,d+1); //rode distance between root to ALL apples  beyound node \\'child\\'\\n                if(dist2apple)  //If child has apples it\\'ll return a non zero result which is the distance traveled upto that node.\\n                    result+=dist2apple-d;                     \\n            }\\n        \\n        return (hasApple[node]   // current \\'node\\' has apple\\n                ||               // or  \\n                result > d) ?    // offspring(s) of current \\'node\\' have apple(s)\\n                result: 0;       // if true, we count the road length, otherwise, no road is needed.\\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple){\\n        adjList.resize(n);\\n        visited.resize(n,false);\\n        for(auto& e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(0,hasApple,0)*2;     //Result is the distance travelled doubled as per our observation.\\n    }\\n};\\n// reference & credit @PhoneixDD: \\n// https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/623679/C%2B%2B-Simple-DFS\\n```\n```\\nclass Solution {  // Solution 1b: DFS\\npublic://1044-1053-1058\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int> > G(n);\\n        for(auto& e: edges) G[e[0]].push_back(e[1]),G[e[1]].push_back(e[0]);        \\n        return dfs(G, hasApple, 0, 0) * 2;\\n    }\\n    \\nprivate:\\n    \\n    //returned value: the road length from root to all apples within the subtree rooted at cur\\n    int dfs(vector<vector<int> >& G, vector<bool>& hasApple, int cur, int d){\\n        int ans = d;    \\n        for(auto& next: G[cur]){    \\n            if(next < cur) continue;//if ture, this is parent of cur, skip \\n            int dist2app = dfs(G, hasApple, next, d+1);\\n            if(dist2app != 0)\\n                ans += dist2app - d;\\n        }\\n        return hasApple[cur] || ans > d ? ans : 0;        \\n    }\\n};\\n```\n```\\nclass Solution { // Solution 2: simple count\\npublic: // Time/Space: O(NlogN); O(1)\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        int cnt = 0;           \\n        sort(edges.begin(), edges.end()); // this is must to ensure value of parent is smaller than child\\n        //for(int i=n-2; i>=0; i--)   // also ok\\n        for(int i= edges.size() - 1; i>=0; i--)  //Note1: visit most distant child first       \\n            if(hasApple[edges[i][1]]){\\n                cnt++;\\n                hasApple[edges[i][0]] = true;\\n            }         \\n        return cnt*2;\\n    }\\n};\\n```\n```\\nclass Solution { // Solution 2b: simple count\\npublic: // Time/Space: O(N); O(N)\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {        \\n        //unordered_map<int,int> parents; // ok, if you hate thinking about default value for vector based hashmap solution.\\n        vector<int> parents(n,0); // Be careful about the default value.  parents[i]:= the parent of node i.\\n        for(auto& e: edges) parents[e[1]] = e[0];        \\n        for(int i= n - 1; i>=0; i--)  //Note1: visit most distant child first       \\n            if(hasApple[i]) hasApple[parents[i]] = true; // if a child is apple, convert their parent into apple            \\n        int cnt = count(hasApple.begin(), hasApple.end(), true); // count how many apples in total, \\n        // if count is non zero, then \\'cnt\\' is the apple/node count of purely apple sub-tree, then edge count is: cnt-1\\n        return cnt == 0 ? 0 : (cnt-1)*2;         \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& has) {\\n        //1: build the Graph: G\\n        vector<int> G[n],dist(n,1e9),par(n,1e9);\\n        for(auto& x:edges){\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n            par[x[1]]=x[0];\\n        }\\n        \\n        //2: measure the distances of each node from root\\n        queue<int> q{{0}};\\n        dist[0]=0;        \\n        while(!q.empty()){\\n            int cur = q.front(); q.pop();\\n            for(int x:G[cur]){\\n                if(dist[x]==1e9){\\n                    dist[x]=dist[cur]+1;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        //3: accumulate the distance from child to its first visited parent\\n        int cnt=0;\\n        vector<int> vis(n,0);\\n        for(int i=n-1;i>=0;i--){\\n            if(has[i]==true && vis[i]==0){ // i: node with apple and unvisited yet\\n                int q = i; // find the first visited parent of i\\n                while(par[q]!=1e9 and vis[q]==0){\\n                    vis[q]=1;\\n                    q = par[q];\\n                }// now, q points to the first visited parent of i\\n                vis[i]=1;                \\n                cnt += 2*(dist[i]-dist[q]);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033288,
                "title": "explained-java-solution-dfs-o-n",
                "content": "\\n#### DFS Solution \\nWe **go to every child node of the current node** and check if it has an apple or not if it has an apple , we add 2 (one to go and one to return) for every node if any child node had an apple. If none of its children had an apple we return 0 + 2 if the current node has an apple else we just return 0.\\n\\n* If any of the children has an apple we return **2 + sum of children**\\n* If none of the childrem has an apple ( sum=0 ) but the current has an apple we return 2 + sum = **2**\\n* If neither the current node or any of its children has an apple we just **return 0**\\n\\n##### Time complexity: O(n)\\n\\n```\\nclass Solution \\n{\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) \\n    {\\n        List<Integer>[] canVisit = new ArrayList[n];\\n        \\n        //Creating adjacency list\\n        for(int i = 0; i<n; i++)\\n        {\\n            canVisit[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges)\\n        {\\n            canVisit[edge[0]].add(edge[1]);            \\n            canVisit[edge[1]].add(edge[0]);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        return helper(0,hasApple,canVisit,visited);\\n        \\n    }\\n    int helper(int i, List<Boolean> hasApple, List<Integer>[] canVisit, boolean[] visited)\\n    {\\n        if(visited[i]) return 0;\\n        visited[i] = true;\\n        \\n        // Visiting every child node\\n        int sum = 0;\\n        for(int edge : canVisit[i])\\n        {\\n            sum += helper(edge, hasApple, canVisit, visited);\\n        }\\n        \\n        if(i==0) return  sum; // Special case for the root node\\n        \\n        // If any children contain an apple or the current node contains an apple we return (2+sum)\\n        if(hasApple.get(i) || sum>0 ) return (2 + sum); \\n        \\n        //If neither the children or the current node contain an apple we just return 0\\n        else return 0;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) \\n    {\\n        List<Integer>[] canVisit = new ArrayList[n];\\n        \\n        //Creating adjacency list\\n        for(int i = 0; i<n; i++)\\n        {\\n            canVisit[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges)\\n        {\\n            canVisit[edge[0]].add(edge[1]);            \\n            canVisit[edge[1]].add(edge[0]);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        return helper(0,hasApple,canVisit,visited);\\n        \\n    }\\n    int helper(int i, List<Boolean> hasApple, List<Integer>[] canVisit, boolean[] visited)\\n    {\\n        if(visited[i]) return 0;\\n        visited[i] = true;\\n        \\n        // Visiting every child node\\n        int sum = 0;\\n        for(int edge : canVisit[i])\\n        {\\n            sum += helper(edge, hasApple, canVisit, visited);\\n        }\\n        \\n        if(i==0) return  sum; // Special case for the root node\\n        \\n        // If any children contain an apple or the current node contains an apple we return (2+sum)\\n        if(hasApple.get(i) || sum>0 ) return (2 + sum); \\n        \\n        //If neither the children or the current node contain an apple we just return 0\\n        else return 0;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033266,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=5haVLZv_zg0&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=11) if you are interested.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> g(n);\\n        for (auto x : edges) {\\n\\t\\t\\t// x[0] can go to x[1]\\n            g[x[0]].push_back(x[1]);\\n\\t\\t\\t// x[1] can go to x[0]\\n            g[x[1]].push_back(x[0]);\\n        }\\n        // u = current vertex\\n        // p = parent vertex\\n        function<int(int, int)> dfs = [&] (int u, int p) {\\n            int res = 0, t = 0;\\n\\t\\t\\t// go to each child\\n            for (auto v : g[u]) {\\n                // if v is not same as p\\n                if (p ^ v) {\\n                    // calculate the child time\\n                    t = dfs(v, u);\\n                    // if there is an apple in the subtree, we need 2 seconds to collect it and head back\\n                    // if we are in vertex 1, we need 4 seconds to collect all the apples in 4 & 5 \\n                    // so if we are in vertex 1, we need 4 seconds to collect the apples in 4 & 5\\n                    // how does 0 know 1 has collected the apple? check the time, i.e. `t`\\n                    // if t > 0, it means we got some apples in sub trees\\n                    if (t > 0 || hasApple[v]) {\\n                        res += t + 2;\\n                    }\\n                }\\n            }\\n            return res;\\n        };\\n        return dfs(0, -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> g(n);\\n        for (auto x : edges) {\\n\\t\\t\\t// x[0] can go to x[1]\\n            g[x[0]].push_back(x[1]);\\n\\t\\t\\t// x[1] can go to x[0]\\n            g[x[1]].push_back(x[0]);\\n        }\\n        // u = current vertex\\n        // p = parent vertex\\n        function<int(int, int)> dfs = [&] (int u, int p) {\\n            int res = 0, t = 0;\\n\\t\\t\\t// go to each child\\n            for (auto v : g[u]) {\\n                // if v is not same as p\\n                if (p ^ v) {\\n                    // calculate the child time\\n                    t = dfs(v, u);\\n                    // if there is an apple in the subtree, we need 2 seconds to collect it and head back\\n                    // if we are in vertex 1, we need 4 seconds to collect all the apples in 4 & 5 \\n                    // so if we are in vertex 1, we need 4 seconds to collect the apples in 4 & 5\\n                    // how does 0 know 1 has collected the apple? check the time, i.e. `t`\\n                    // if t > 0, it means we got some apples in sub trees\\n                    if (t > 0 || hasApple[v]) {\\n                        res += t + 2;\\n                    }\\n                }\\n            }\\n            return res;\\n        };\\n        return dfs(0, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623735,
                "title": "java-easy-dfs",
                "content": "The bug mentioned by hiepit@ below has been fixed.\\n\\n```\\nclass Solution {\\n    int ans = 0;\\n\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            graph.putIfAbsent(edge[0], new ArrayList<>());\\n            graph.putIfAbsent(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        needToGo(graph, 0, -1, hasApple);\\n\\n        return ans;\\n    }\\n\\n    private boolean needToGo(Map<Integer, List<Integer>> graph, int curNode, int prevNode, List<Boolean> hasApple) {\\n        boolean res = hasApple.get(curNode);\\n        for (int nxtNode : graph.getOrDefault(curNode, new ArrayList<>())) {\\n            if (nxtNode != prevNode) {\\n                if (needToGo(graph, nxtNode, curNode, hasApple)) {\\n                    res = true;\\n                    ans += 2;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            graph.putIfAbsent(edge[0], new ArrayList<>());\\n            graph.putIfAbsent(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        needToGo(graph, 0, -1, hasApple);\\n\\n        return ans;\\n    }\\n\\n    private boolean needToGo(Map<Integer, List<Integer>> graph, int curNode, int prevNode, List<Boolean> hasApple) {\\n        boolean res = hasApple.get(curNode);\\n        for (int nxtNode : graph.getOrDefault(curNode, new ArrayList<>())) {\\n            if (nxtNode != prevNode) {\\n                if (needToGo(graph, nxtNode, curNode, hasApple)) {\\n                    res = true;\\n                    ans += 2;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036423,
                "title": "c-solution-with-video",
                "content": "# Video\\nhttps://youtu.be/hIVslN8zDco\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> tree(n);\\n        for (auto edge : edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return max(0, DFS(0, -1, tree, hasApple) - 2);\\n    }\\n\\n    int DFS(int node, int parent, vector<vector<int>> &tree, vector<bool> &hasApple) {\\n        int time = 0;\\n        for (auto child : tree[node]) {\\n            if (child != parent)\\n                time += DFS(child, node, tree, hasApple);\\n        }\\n\\n        return (time > 0 || hasApple[node] ? time + 2 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> tree(n);\\n        for (auto edge : edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return max(0, DFS(0, -1, tree, hasApple) - 2);\\n    }\\n\\n    int DFS(int node, int parent, vector<vector<int>> &tree, vector<bool> &hasApple) {\\n        int time = 0;\\n        for (auto child : tree[node]) {\\n            if (child != parent)\\n                time += DFS(child, node, tree, hasApple);\\n        }\\n\\n        return (time > 0 || hasApple[node] ? time + 2 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033685,
                "title": "c-detailed-clear-beats-aprox-100",
                "content": "![Screenshot 2023-01-11 070807.png](https://assets.leetcode.com/users/images/ad3cd8b1-de43-4132-879a-8742f498bdb3_1673413704.0949535.png)\\n\\n\\n# Intuition\\nThe Idea is you will notice that the answer is the number of all nodes you have to visit multiplied by 2 (except for zero)!!\\n\\nBecause to get to any point you have to go there and then come back, 2 moves per any visited node except for zero !\\n\\nbecause you already start at zero, you don\\'t go there then come back.\\n\\n# Approach\\nOur goal is to determine the nodes we NEED to visit.\\n\\nWe check every node which has apples in it then go mark all the nodes in the path needed to go to node-zero starting at that node\\n\\nThe answer is all the mustVisited nodes * 2 (excluding node-zero as mentioned)\\n\\n# Complexity\\n- Time complexity: O (n + number of paths)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n\\n        // we choose the least-in-number neighbour because to follow\\n        // the path from some point to zero\\n        // you always have to go to the least neighbour in number\\n        // intilaize to max becasue we need to minimize that number\\n        // with new edges added\\n        vector<int> leastNeighbour(n, INT32_MAX);\\n\\n        // for each edge, we conclude the least-in-number neighbour\\n        // for the two nodes in edge\\n        for (auto & i : edges) {\\n            leastNeighbour[i[0]] = min(i[1], leastNeighbour[i[0]]);\\n            leastNeighbour[i[1]] = min(i[0], leastNeighbour[i[1]]);\\n\\n        }\\n\\n        // here we store the nodes we NEED to visit\\n        // initialized to false so later on when we follow the path\\n        // to node-zero we terminate if\\n        // we find a start of a previously visited path thus...\\n        // saving time for not tracing the same path twice\\n        // basically... if node 3 is connected to node 2 and we know\\n        // that we visited node 2 then we don\\'t need to trace\\n        // to node-zero , only trace the path until node 2 (all nodes\\n        // from 2 to 0 were already checked before)\\n        vector<bool>mustVisit(n ,false);\\n\\n        // we go from last to start because checking the longer paths\\n        // makes it faster for us to mark other nodes\\n        int j = 0;\\n        for (int i = n - 1; i > 0; --i) {\\n            if(hasApple[i]){\\n                j = i;\\n                // if it has apple then mark its path by marking the\\n                // point then going to the least neighbour\\n                // repeat until reach zero-node or\\n                // a node we previously visited\\n                while(not mustVisit[j] && j != 0){\\n                    mustVisit[j] = true;\\n                    j = leastNeighbour[j];\\n                }\\n            }\\n        }\\n\\n        int cntr = 0;\\n        for (auto i : mustVisit) {\\n            cntr += int(i);\\n        }\\n\\n        return  cntr*2;\\n    }\\n};\\n```\\n\\nUpvote if you like it :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n\\n        // we choose the least-in-number neighbour because to follow\\n        // the path from some point to zero\\n        // you always have to go to the least neighbour in number\\n        // intilaize to max becasue we need to minimize that number\\n        // with new edges added\\n        vector<int> leastNeighbour(n, INT32_MAX);\\n\\n        // for each edge, we conclude the least-in-number neighbour\\n        // for the two nodes in edge\\n        for (auto & i : edges) {\\n            leastNeighbour[i[0]] = min(i[1], leastNeighbour[i[0]]);\\n            leastNeighbour[i[1]] = min(i[0], leastNeighbour[i[1]]);\\n\\n        }\\n\\n        // here we store the nodes we NEED to visit\\n        // initialized to false so later on when we follow the path\\n        // to node-zero we terminate if\\n        // we find a start of a previously visited path thus...\\n        // saving time for not tracing the same path twice\\n        // basically... if node 3 is connected to node 2 and we know\\n        // that we visited node 2 then we don\\'t need to trace\\n        // to node-zero , only trace the path until node 2 (all nodes\\n        // from 2 to 0 were already checked before)\\n        vector<bool>mustVisit(n ,false);\\n\\n        // we go from last to start because checking the longer paths\\n        // makes it faster for us to mark other nodes\\n        int j = 0;\\n        for (int i = n - 1; i > 0; --i) {\\n            if(hasApple[i]){\\n                j = i;\\n                // if it has apple then mark its path by marking the\\n                // point then going to the least neighbour\\n                // repeat until reach zero-node or\\n                // a node we previously visited\\n                while(not mustVisit[j] && j != 0){\\n                    mustVisit[j] = true;\\n                    j = leastNeighbour[j];\\n                }\\n            }\\n        }\\n\\n        int cntr = 0;\\n        for (auto i : mustVisit) {\\n            cntr += int(i);\\n        }\\n\\n        return  cntr*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033154,
                "title": "python-3-9-lines-w-explanation-t-m-100-95x",
                "content": "Here\\'s the plan:\\n- We build the graph`g`and initialize the set`seen`to track which nodes have been visited.\\n- We start at`node = 0`, as directed, and traverse the graph recursively. We return when we hit a dead-end node, that is, a node`n`for which all nodes in g[n] already have been visited.\\n- It\\'s recursion; you get the idea. \\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\\n                          \\n        seen, g = set(), defaultdict(list)\\n\\n        for a,b in edges: \\n            g[a].append((b))  ;  g[b].append((a))\\n           \\n        def dfs(node: int)->int:\\n            seen.add(node)    \\n  \\n            ans = sum(dfs(n) for n in g[node] if n not in seen) \\n \\n            if not ans and not hasApple[node]: return 0\\n\\n            return ans+2           \\n\\n        return max (0,dfs(0)-2)\\n```\\n[https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/875780976/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\\n                          \\n        seen, g = set(), defaultdict(list)\\n\\n        for a,b in edges: \\n            g[a].append((b))  ;  g[b].append((a))\\n           \\n        def dfs(node: int)->int:\\n            seen.add(node)    \\n  \\n            ans = sum(dfs(n) for n in g[node] if n not in seen) \\n \\n            if not ans and not hasApple[node]: return 0\\n\\n            return ans+2           \\n\\n        return max (0,dfs(0)-2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630964,
                "title": "c-solution",
                "content": "```\\n/*\\nTo visit a node from a parent the cost is 2. Because I visit the node and backtrack which is considered to the cost.\\n\\nI have to count only the cost of collecting the apples present in the nodes and not count unnecessary nodes.\\nHow do we do that?\\n\\nWe use a dfs finction to help us with that.\\nWe have 5 parameters\\n1. A build graph adjacncy list\\n2. A vector bool array to help us not visit a node multiple times\\n3. A node which is passed as 0 initially.\\n4. Cost variable which will be 2 more that the previous one because of the fact i told about earlier\\n5. hasApple array.\\n\\nThe dfs will help us with finding the cost by the following method:-\\n\\n1. If I find out that atleast one of my children have nodes i return the cost and the children cost to the call stack.\\n2. If I find out that none of the children contains apples we return 0.\\n*/\\n    vector<bool> vis;\\n    int dfs(vector<vector<int>> &graph,vector<bool>& hasApple,int node,int cost)\\n    {\\n        if(vis[node])return 0;\\n        vis[node]=true;\\n        int children_cost=0;\\n        for(auto x:graph[node])\\n            children_cost+=dfs(graph,hasApple,x,2);\\n        if(children_cost==0 && hasApple[node]==false)return 0;\\n        return (children_cost+cost);\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> graph(n);\\n        vis=vector<bool>(n,false);\\n        for(auto &x:edges)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        return dfs(graph,hasApple,0,0);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\nTo visit a node from a parent the cost is 2. Because I visit the node and backtrack which is considered to the cost.\\n\\nI have to count only the cost of collecting the apples present in the nodes and not count unnecessary nodes.\\nHow do we do that?\\n\\nWe use a dfs finction to help us with that.\\nWe have 5 parameters\\n1. A build graph adjacncy list\\n2. A vector bool array to help us not visit a node multiple times\\n3. A node which is passed as 0 initially.\\n4. Cost variable which will be 2 more that the previous one because of the fact i told about earlier\\n5. hasApple array.\\n\\nThe dfs will help us with finding the cost by the following method:-\\n\\n1. If I find out that atleast one of my children have nodes i return the cost and the children cost to the call stack.\\n2. If I find out that none of the children contains apples we return 0.\\n*/\\n    vector<bool> vis;\\n    int dfs(vector<vector<int>> &graph,vector<bool>& hasApple,int node,int cost)\\n    {\\n        if(vis[node])return 0;\\n        vis[node]=true;\\n        int children_cost=0;\\n        for(auto x:graph[node])\\n            children_cost+=dfs(graph,hasApple,x,2);\\n        if(children_cost==0 && hasApple[node]==false)return 0;\\n        return (children_cost+cost);\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> graph(n);\\n        vis=vector<bool>(n,false);\\n        for(auto &x:edges)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        return dfs(graph,hasApple,0,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623828,
                "title": "python-bfs-bottom-up-no-recursion-w-thinking-process",
                "content": "This is my thinking process:\\nLet\\'s start with the easy parts. For leaf nodes, it is easy: each apple node costs 2 steps. \\nAfter eliminate the real leaf nodes, nodes in the second lowest level become new leaves, and we can treat them the same except that:\\n1) if it has an apple child, it needs to be traversed. We don\\'t need to separate real apple nodes from nodes that needs to be travesed because of apple child, so to achieve this, we can simply mark the parent as apple each time we meet an apple node.\\n2) For each apple node (\\'real\\' apple node or marked apple nodes because of apple child), we need 2 steps to reach them + steps needed for its apple decendants. \\n\\n\\n```python\\ndef minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        d_neighbors = collections.defaultdict(set)\\n        for a,b in edges:\\n            d_neighbors[a].add(b)\\n            d_neighbors[b].add(a)\\n        \\n        steps = [0] * n\\n        \\n        leafs = set(node for node, lst_neighbor in d_neighbors.items() if len(lst_neighbor) == 1 )\\n        leafs.discard(0)\\n        \\n        while leafs:\\n            new_leafs = set()\\n            for leaf in leafs:\\n                parent = d_neighbors[leaf].pop()\\n                if hasApple[leaf]:\\n                    steps[parent] += 2 + steps[leaf]\\n                    hasApple[parent] = True\\n                d_neighbors[parent].discard(leaf)\\n                if len( d_neighbors[parent] ) == 1:\\n                    new_leafs.add( parent )\\n            leafs = new_leafs\\n            leafs.discard(0)\\n            \\n        return steps[0]\\n```\\n\\nI think the BFS part of the code is pretty self-explanatary. If you have difficulty to understand, there are some problems with very similar BFS code as answer:\\n\\n310\\xA0Minimum Height Trees\\n127 Word Ladder\\n",
                "solutionTags": [],
                "code": "```python\\ndef minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        d_neighbors = collections.defaultdict(set)\\n        for a,b in edges:\\n            d_neighbors[a].add(b)\\n            d_neighbors[b].add(a)\\n        \\n        steps = [0] * n\\n        \\n        leafs = set(node for node, lst_neighbor in d_neighbors.items() if len(lst_neighbor) == 1 )\\n        leafs.discard(0)\\n        \\n        while leafs:\\n            new_leafs = set()\\n            for leaf in leafs:\\n                parent = d_neighbors[leaf].pop()\\n                if hasApple[leaf]:\\n                    steps[parent] += 2 + steps[leaf]\\n                    hasApple[parent] = True\\n                d_neighbors[parent].discard(leaf)\\n                if len( d_neighbors[parent] ) == 1:\\n                    new_leafs.add( parent )\\n            leafs = new_leafs\\n            leafs.discard(0)\\n            \\n        return steps[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1922243,
                "title": "java-graph-dfs-do-checkout",
                "content": "**Do vote up if you like it :)**\\n\\n```\\nclass Solution {\\n    \\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        \\n        for(int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n        boolean[] vis = new boolean[n];\\n        int time = dfs(0, hasApple, vis, graph);\\n        \\n        // Tumhara root node v apne parent k liye +2 bhej dega, \\n        // apne se aane jaane ka time, agar tumse niche se kuch time aara hoga tab\\n        // Islye usko -2 kar do final answer me\\n        return time > 0 ? time - 2 : time;   \\n    }\\n    \\n    public static int dfs(int node, List<Boolean> hasApple, boolean[] vis, ArrayList<Integer>[] graph) {\\n        vis[node] = true;\\n        \\n        int time = 0;\\n        for(int child : graph[node]) {\\n            if(!vis[child]) {\\n                time += dfs(child, hasApple, vis, graph);\\n            }\\n        }\\n        \\n        // Niche se kuch apples aa rahe hai, usko parent tak pahuchana hai so +2 mere se aane jaane ka time  \\n        // agar mere pe v apples honge tab v mko +2 time he lgega apne parent tak pahuchane me\\n        if(time > 0) return time + 2; // NOTE : root node v +2 bhej dega yaha se\\n        \\n        else { // (time == 0) => Niche se koi apples nahi aaya ya fir tumhara koi child nahi tha\\n            if(hasApple.get(node)) return 2; // Niche se koi apple nahi aaya and tumhare node pe apple hai\\n            else return 0; // tumhara koi child nahi tha, leaf node will send 0\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        \\n        for(int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n        boolean[] vis = new boolean[n];\\n        int time = dfs(0, hasApple, vis, graph);\\n        \\n        // Tumhara root node v apne parent k liye +2 bhej dega, \\n        // apne se aane jaane ka time, agar tumse niche se kuch time aara hoga tab\\n        // Islye usko -2 kar do final answer me\\n        return time > 0 ? time - 2 : time;   \\n    }\\n    \\n    public static int dfs(int node, List<Boolean> hasApple, boolean[] vis, ArrayList<Integer>[] graph) {\\n        vis[node] = true;\\n        \\n        int time = 0;\\n        for(int child : graph[node]) {\\n            if(!vis[child]) {\\n                time += dfs(child, hasApple, vis, graph);\\n            }\\n        }\\n        \\n        // Niche se kuch apples aa rahe hai, usko parent tak pahuchana hai so +2 mere se aane jaane ka time  \\n        // agar mere pe v apples honge tab v mko +2 time he lgega apne parent tak pahuchane me\\n        if(time > 0) return time + 2; // NOTE : root node v +2 bhej dega yaha se\\n        \\n        else { // (time == 0) => Niche se koi apples nahi aaya ya fir tumhara koi child nahi tha\\n            if(hasApple.get(node)) return 2; // Niche se koi apple nahi aaya and tumhare node pe apple hai\\n            else return 0; // tumhara koi child nahi tha, leaf node will send 0\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772044,
                "title": "python-o-n-by-dfs-w-visualization",
                "content": "Python O(n) by DFS\\n\\n---\\n\\n**Visualization**:\\n![image](https://assets.leetcode.com/users/images/13a90a44-766e-422e-9312-af0df84c5d78_1596517473.357243.png)\\n\\n---\\n\\n**Implementation** by DFS\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        \\n        adjacency_list = defaultdict(list)\\n        \\n        # Build adjacency list to represent the tree\\n        for src_node, dst_node in edges:\\n            adjacency_list[src_node].append(dst_node)\\n            adjacency_list[dst_node].append(src_node)\\n        \\n        # Record of visited nodes\\n        visited = set()\\n        \\n        #------------------------------------------------------------------------------------\\n        def collect_in_dfs(cur_node):\\n            \\n            visited.add(cur_node)\\n            \\n            cost_of_collect = 0\\n            \\n            for child_node in adjacency_list[cur_node]:\\n                \\n                if child_node in visited:\\n                    # avoid repeated traversal\\n                    continue\\n                \\n                \\n                cost_from_child = collect_in_dfs(child_node)\\n                \\n                if cost_from_child or hasApple[child_node]:\\n                    # update cost of collection (i.e., cost of green arrows)\\n                    # The first +1 is for path from cur_node to child_node, and the second +1 is for going back.\\n\\t\\t\\t\\t\\t# Totally, +2\\n\\n                    cost_of_collect += cost_from_child + 2\\n            \\n            return cost_of_collect\\n        \\n        #------------------------------------------------------------------------------------\\n        root_node_idx = 0\\n        return collect_in_dfs(cur_node=root_node_idx)\\n        \\n        \\n```\\n\\n---\\n\\nReference:\\n\\n[1] [USFCA: DFS visualization and demo animation](https://www.cs.usfca.edu/~galles/visualization/DFS.html)\\n\\n[2] [Python official docs about defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        \\n        adjacency_list = defaultdict(list)\\n        \\n        # Build adjacency list to represent the tree\\n        for src_node, dst_node in edges:\\n            adjacency_list[src_node].append(dst_node)\\n            adjacency_list[dst_node].append(src_node)\\n        \\n        # Record of visited nodes\\n        visited = set()\\n        \\n        #------------------------------------------------------------------------------------\\n        def collect_in_dfs(cur_node):\\n            \\n            visited.add(cur_node)\\n            \\n            cost_of_collect = 0\\n            \\n            for child_node in adjacency_list[cur_node]:\\n                \\n                if child_node in visited:\\n                    # avoid repeated traversal\\n                    continue\\n                \\n                \\n                cost_from_child = collect_in_dfs(child_node)\\n                \\n                if cost_from_child or hasApple[child_node]:\\n                    # update cost of collection (i.e., cost of green arrows)\\n                    # The first +1 is for path from cur_node to child_node, and the second +1 is for going back.\\n\\t\\t\\t\\t\\t# Totally, +2\\n\\n                    cost_of_collect += cost_from_child + 2\\n            \\n            return cost_of_collect\\n        \\n        #------------------------------------------------------------------------------------\\n        root_node_idx = 0\\n        return collect_in_dfs(cur_node=root_node_idx)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033084,
                "title": "python3-simple-6-lines",
                "content": "# Intuition\\nWe need to know parent for each node. We are storing it in the array `parents`.\\nProblem is to identify, who is parent and who is a child. When I solved this first time, it was true that `parent<child`. Leetcode added later a special test case, where this is not true.\\n\\nI had to update code. When we are processing an edge, we have to chceck if the child already have a parent. If it is a case, we have to switch parent and child.\\n\\n**Each child can have only one parent because this is a tree.**\\n\\nThe problematic edges are `0-2,0-3,1-2`. It looks like node 2 has two parents: 0 and 1, but it is not true. \\n0 has two children: 2 and 3\\n2 has one child: 1.\\n\\nOther words: \\n0 is a root\\nparent of 1 is 2\\nparent of 2 is 0\\nparent of 3 is 0\\n\\n```\\n      0\\n    /   \\\\\\n   2     3\\n  /\\n 1 \\n```\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\nIt shows better time than 100% Python solutions.\\n\\n- Space complexity:\\nO(N)\\nIt shows better space than 97% Python solutions.\\n\\n# Code\\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        parents=[-1]*n\\n        for edge in edges:\\n            parent,child=edge\\n            if parents[child]==-1:\\n                parents[child]=parent  \\n            else:\\n                parents[parent]=child   \\n        for h in range(n-1,0,-1):\\n            if hasApple[h] and parents[h]!=-1:\\n                hasApple[parents[h]]=True\\n        return sum(hasApple[1:])*2\\n```\\n# Short Code - only 6 lines\\nThis is just for fun, I prefer the readable version of code.\\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        parents=[-1]*n\\n        for edge in edges:\\n            parents[edge[parents[edge[1]]==-1]]=edge[parents[edge[1]]!=-1]   \\n        for h in range(n-1,0,-1):\\n            hasApple[parents[h]]=max(hasApple[parents[h]],hasApple[h] and parents[h]!=-1)\\n        return sum(hasApple[1:])*2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n      0\\n    /   \\\\\\n   2     3\\n  /\\n 1 \\n```\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        parents=[-1]*n\\n        for edge in edges:\\n            parent,child=edge\\n            if parents[child]==-1:\\n                parents[child]=parent  \\n            else:\\n                parents[parent]=child   \\n        for h in range(n-1,0,-1):\\n            if hasApple[h] and parents[h]!=-1:\\n                hasApple[parents[h]]=True\\n        return sum(hasApple[1:])*2\\n```\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        parents=[-1]*n\\n        for edge in edges:\\n            parents[edge[parents[edge[1]]==-1]]=edge[parents[edge[1]]!=-1]   \\n        for h in range(n-1,0,-1):\\n            hasApple[parents[h]]=max(hasApple[parents[h]],hasApple[h] and parents[h]!=-1)\\n        return sum(hasApple[1:])*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032972,
                "title": "python3-dfs-faster-than-99-36-easy-to-understand",
                "content": "**Intuition:**\\nIt is difficult to simulate the process shown in the problem (such as going to child node to check if it has an apple and the go back to parent node to count the edge,etc). We can think more simply that if the child node has an apple, then the edge between parent and THAT child node must be counted. So we can write a recursive function to return True if a current node has an apple or its neighbor nodes have apple(s), so that when a recursive function returns True, it means we must add 2 seconds for the edge (because we need to go back and forth, so each edge will be counted as 2 seconds)\\n\\n\\n\\n\\tclass Solution:\\n\\t\\tdef minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tglobalCnt = 0\\n\\t\\t\\tvisited = [False for i in range(n)]\\n\\n\\t\\t\\tfor x,y in edges:\\n\\t\\t\\t\\tgraph[x].append(y)\\n\\t\\t\\t\\tgraph[y].append(x)\\n\\n\\t\\t\\tdef dfs(root,graph,apple,visited):\\n\\t\\t\\t\\tnonlocal globalCnt\\n\\t\\t\\t\\tret = False\\n\\t\\t\\t\\tif apple[root]:\\n\\t\\t\\t\\t\\tret = True\\n\\n\\t\\t\\t\\tvisited[root] = True\\n\\t\\t\\t\\t# Mark this visited\\n\\t\\t\\t\\tfor neighbor in graph[root]:\\n\\t\\t\\t\\t\\tif not visited[neighbor]:\\n\\t\\t\\t\\t\\t\\tif dfs(neighbor,graph,apple,visited):\\n\\t\\t\\t\\t\\t\\t\\tglobalCnt += 2\\n\\t\\t\\t\\t\\t\\t\\tret = True\\n\\n\\n\\n\\t\\t\\t\\treturn ret\\n\\n\\t\\t\\tdfs(0,graph,hasApple,visited)\\n\\t\\t\\treturn globalCnt",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "**Intuition:**\\nIt is difficult to simulate the process shown in the problem (such as going to child node to check if it has an apple and the go back to parent node to count the edge,etc). We can think more simply that if the child node has an apple, then the edge between parent and THAT child node must be counted. So we can write a recursive function to return True if a current node has an apple or its neighbor nodes have apple(s), so that when a recursive function returns True, it means we must add 2 seconds for the edge (because we need to go back and forth, so each edge will be counted as 2 seconds)\\n\\n\\n\\n\\tclass Solution:\\n\\t\\tdef minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tglobalCnt = 0\\n\\t\\t\\tvisited = [False for i in range(n)]\\n\\n\\t\\t\\tfor x,y in edges:\\n\\t\\t\\t\\tgraph[x].append(y)\\n\\t\\t\\t\\tgraph[y].append(x)\\n\\n\\t\\t\\tdef dfs(root,graph,apple,visited):\\n\\t\\t\\t\\tnonlocal globalCnt\\n\\t\\t\\t\\tret = False\\n\\t\\t\\t\\tif apple[root]:\\n\\t\\t\\t\\t\\tret = True\\n\\n\\t\\t\\t\\tvisited[root] = True\\n\\t\\t\\t\\t# Mark this visited\\n\\t\\t\\t\\tfor neighbor in graph[root]:\\n\\t\\t\\t\\t\\tif not visited[neighbor]:\\n\\t\\t\\t\\t\\t\\tif dfs(neighbor,graph,apple,visited):\\n\\t\\t\\t\\t\\t\\t\\tglobalCnt += 2\\n\\t\\t\\t\\t\\t\\t\\tret = True\\n\\n\\n\\n\\t\\t\\t\\treturn ret\\n\\n\\t\\t\\tdfs(0,graph,hasApple,visited)\\n\\t\\t\\treturn globalCnt",
                "codeTag": "Java"
            },
            {
                "id": 624962,
                "title": "simple-12-liner-python-with-explanation-dfs-o-n-time-space",
                "content": "This solution is based on scanning the tree with Depth-First Search and collecting the \"cost\" - number of edges we need to travel to pick our apples underneath.\\n\\nTo illustrate how it works let\\'s consider Example 1:\\n![image](https://assets.leetcode.com/users/ilgor/image_1589125958.png)\\n\\nFirst DFS will go all the way to the leaf nodes (the order below is arbitrary and doesn\\'t matter for the algorithm):\\n\\n**Node 3:** has no cost from the nodes under and no apple => returns **0**\\n**Node 6:** has no cost from the nodes under and no apple => returns **0**\\n**Node 4:** has no cost from the nodes under but has **apple** => returns **1**\\n**Node 5:** has no cost from the nodes under but has **apple** => returns **1**\\n\\n**Node 2:** cost from the nodes under (**3** and **6**) is **0** but has **apple** => returns **1**\\n**Node 1:** cost from the nodes under (**4** and **5**) is **1+1 = 2** and no apple => returns **2+1 = 3**\\n\\n**Node 0:** cost from the nodes under (**1** and **2**) is **3+1 = 4** and no apple => returns **4+1 = 5**\\n\\nThe true cost is always 1 less, since vertex 0 has no parent and available to us right away: **5-1 = 4**\\n**Time =** 2 * cost = 2*4 = **8**\\n\\n```\\n# IDEA: use DFS with every iteration returning the cost (number of edges) to travel to all the apple nodes beneath:\\n#       if it\\'s a leaf with no apple cost is zero, if it\\'s a node that has apples under we increment the cost by 1;\\n#       since travel is back and forth the time is double of cost\\n#       O(N) time, O(N) space\\n#\\n#       Still linear but faster way for low-hanging apple trees would be to iterate over apples and travel back\\n#       from each apple to it\\'s parents until vertex \\'0\\' reached and only add to cost if parent is not traveled before\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        routes = collections.defaultdict(list) # use dictionary to store all possible routes from every node\\n        for u,v in edges:\\n            routes[u].append(v)\\n            \\n        def dfs(node: int) -> int:\\n            cost = 0\\n            for child in routes[node]:\\n                cost += dfs(child)\\n            if cost or hasApple[node]:\\n                return cost+1\\n            return 0\\n            \\n        res = dfs(0)\\n        return 2*(res-1) if res else 0 # -1 to offset +1 from vertex \\'0\\' travel to which is free\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "This solution is based on scanning the tree with Depth-First Search and collecting the \"cost\" - number of edges we need to travel to pick our apples underneath.\\n\\nTo illustrate how it works let\\'s consider Example 1:\\n![image](https://assets.leetcode.com/users/ilgor/image_1589125958.png)\\n\\nFirst DFS will go all the way to the leaf nodes (the order below is arbitrary and doesn\\'t matter for the algorithm):\\n\\n**Node 3:** has no cost from the nodes under and no apple => returns **0**\\n**Node 6:** has no cost from the nodes under and no apple => returns **0**\\n**Node 4:** has no cost from the nodes under but has **apple** => returns **1**\\n**Node 5:** has no cost from the nodes under but has **apple** => returns **1**\\n\\n**Node 2:** cost from the nodes under (**3** and **6**) is **0** but has **apple** => returns **1**\\n**Node 1:** cost from the nodes under (**4** and **5**) is **1+1 = 2** and no apple => returns **2+1 = 3**\\n\\n**Node 0:** cost from the nodes under (**1** and **2**) is **3+1 = 4** and no apple => returns **4+1 = 5**\\n\\nThe true cost is always 1 less, since vertex 0 has no parent and available to us right away: **5-1 = 4**\\n**Time =** 2 * cost = 2*4 = **8**\\n\\n```\\n# IDEA: use DFS with every iteration returning the cost (number of edges) to travel to all the apple nodes beneath:\\n#       if it\\'s a leaf with no apple cost is zero, if it\\'s a node that has apples under we increment the cost by 1;\\n#       since travel is back and forth the time is double of cost\\n#       O(N) time, O(N) space\\n#\\n#       Still linear but faster way for low-hanging apple trees would be to iterate over apples and travel back\\n#       from each apple to it\\'s parents until vertex \\'0\\' reached and only add to cost if parent is not traveled before\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        routes = collections.defaultdict(list) # use dictionary to store all possible routes from every node\\n        for u,v in edges:\\n            routes[u].append(v)\\n            \\n        def dfs(node: int) -> int:\\n            cost = 0\\n            for child in routes[node]:\\n                cost += dfs(child)\\n            if cost or hasApple[node]:\\n                return cost+1\\n            return 0\\n            \\n        res = dfs(0)\\n        return 2*(res-1) if res else 0 # -1 to offset +1 from vertex \\'0\\' travel to which is free\\n",
                "codeTag": "Java"
            },
            {
                "id": 3035531,
                "title": "c-2-line-dfs-solution-2023-must-watch",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    int dfs(int root,vector<bool>& hasApple, int par = -1, int ans = 0){\\n        for(auto node:graph[root]) if(node!=par) ans += dfs(node,hasApple,root);\\n        return (!root) ? ans : (hasApple[root] || ans) ? ans + 2 : 0 ;\\n    }\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        graph.resize(n);\\n        for(auto it:edges) graph[it[0]].emplace_back(it[1]), graph[it[1]].emplace_back(it[0]);\\n        return dfs(0,hasApple);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    int dfs(int root,vector<bool>& hasApple, int par = -1, int ans = 0){\\n        for(auto node:graph[root]) if(node!=par) ans += dfs(node,hasApple,root);\\n        return (!root) ? ans : (hasApple[root] || ans) ? ans + 2 : 0 ;\\n    }\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        graph.resize(n);\\n        for(auto it:edges) graph[it[0]].emplace_back(it[1]), graph[it[1]].emplace_back(it[0]);\\n        return dfs(0,hasApple);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838980,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int idx , unordered_map<int , vector<int>>&mp , vector<bool>&hasApple , int &count , vector<bool>&visited)\\n    {\\n        visited[idx] = true ; \\n        bool what = false ; \\n        for(auto i : mp[idx])\\n        {\\n            if(visited[i]) continue ; \\n            bool ans = dfs(i , mp , hasApple , count , visited) ; \\n            if(ans) count+= 2 ; \\n            what = what || ans ; \\n        }\\n        what = what || hasApple[idx] ; \\n        return what ; \\n    }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        unordered_map<int , vector<int>> mp ; \\n        for(auto i : edges)\\n        {\\n            mp[i[0]].push_back(i[1]) ; \\n            mp[i[1]].push_back(i[0]) ; \\n        }\\n        int count = 0 ; \\n        \\n        vector<bool>visited(n , false) ; \\n        visited[0] = true ; \\n        for(int i = 0 ; i < mp[0].size() ; i++)\\n        {\\n            if(visited[mp[0][i]]) continue ; \\n            bool ans = dfs(mp[0][i] , mp , hasApple , count , visited) ; \\n            if(ans) count += 2 ; \\n        }\\n        return count ; \\n    }\\n};",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool dfs(int idx , unordered_map<int , vector<int>>&mp , vector<bool>&hasApple , int &count , vector<bool>&visited)\\n    {\\n        visited[idx] = true ; \\n        bool what = false ; \\n        for(auto i : mp[idx])\\n        {\\n            if(visited[i]) continue ; \\n            bool ans = dfs(i , mp , hasApple , count , visited) ; \\n            if(ans) count+= 2 ; \\n            what = what || ans ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1536120,
                "title": "slightly-trick-question-requires-logical-thinking-c-code-with-hints-provided",
                "content": "Just think about how can you really reach every apple in shortest time . The answer is For every pair of apples , reach them through their lowest common ancestor . \\n\\nThats why we call first left and right subtree of root and ask them if they got an apple in their subtree and then we just add up the answer if one of them or both of them says \"YES\" .or if node itself got an apple .\\n\\n```\\nclass Solution {\\n    \\n    \\n    int dfs(vector<int> adj[] , vector<bool>& vis , vector<bool>& hasApple , int root)\\n    {\\n        vis[root] = 1 ;\\n        \\n        int ans = 0;\\n        \\n        for(auto children : adj[root])\\n        {\\n            if(!vis[children])\\n            {\\n                ans+= dfs(adj , vis , hasApple , children ) ;\\n            }\\n        }\\n        \\n        if(root == 0) return ans ;\\n        \\n        if(ans > 0 || hasApple[root])\\n        {\\n            return ans+2 ;\\n        }\\n        \\n        return 0;\\n    }\\n    \\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n\\n        vector<int> adj[n] ;\\n        \\n        for(auto &x : edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n\\n        }  \\n        \\n        vector<bool > vist(n , 0);\\n        \\n       return dfs(adj , vist , hasApple , 0 ) ;\\n        \\n        \\n    }\\n    \\n    \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    \\n    int dfs(vector<int> adj[] , vector<bool>& vis , vector<bool>& hasApple , int root)\\n    {\\n        vis[root] = 1 ;\\n        \\n        int ans = 0;\\n        \\n        for(auto children : adj[root])\\n        {\\n            if(!vis[children])\\n            {\\n                ans+= dfs(adj , vis , hasApple , children ) ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3033665,
                "title": "easy-understanding-c-dfs-solution",
                "content": "**Observation** : \\n\\n1. Every time we use an edge we will also use same edge to go in backward direction so that edge will be used` twice`.\\n2. If we are at current node and if it is a leaf node and it has apple we will use that edge to collect apple.\\n3. If current node is not a leaf node then there are two cases i) If it has apple, ii) If in that node\\'s subtree someone is having apple. In either of these cases we are gonna use the edge to collect apple.\\n\\n**Approach** : \\n* We can do DFS traversal and follow above observations to implement the logic.\\n\\n**T.C : O(n+m)\\nS.C : O(n+m)**\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> adj[],int n,int node,int prev,vector<bool> &hasApple){\\n        int tree = 0;\\n        for(auto &ele:adj[node]){\\n            if(ele!=prev){\\n                int subtree = dfs(adj,n,ele,node,hasApple);\\n                tree += subtree;\\n            }\\n        }\\n        if(adj[node].size()==1 and node!=0){\\n            tree += hasApple[node];\\n        }\\n        else if(node!=0){\\n            if(tree!=0 or hasApple[node]) tree++; \\n        }\\n        return tree;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple){\\n        int sz = hasApple.size();\\n        vector<int> adj[sz];\\n        for(auto &ele:edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        int req = dfs(adj,n,0,-1,hasApple);\\n        return 2*req;\\n    }\\n};\\n```\\n\\nPlease Upvote if you find it helpful !!",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> adj[],int n,int node,int prev,vector<bool> &hasApple){\\n        int tree = 0;\\n        for(auto &ele:adj[node]){\\n            if(ele!=prev){\\n                int subtree = dfs(adj,n,ele,node,hasApple);\\n                tree += subtree;\\n            }\\n        }\\n        if(adj[node].size()==1 and node!=0){\\n            tree += hasApple[node];\\n        }\\n        else if(node!=0){\\n            if(tree!=0 or hasApple[node]) tree++; \\n        }\\n        return tree;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple){\\n        int sz = hasApple.size();\\n        vector<int> adj[sz];\\n        for(auto &ele:edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        int req = dfs(adj,n,0,-1,hasApple);\\n        return 2*req;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033597,
                "title": "super-easy-explained-with-image-dfs-java",
                "content": "# Explaination for Approach :\\n```\\nLet\\u2019s consider we are at a node, say p, we will collect all apples \\nin p\\u2019s subtree before returning back to the original root. This \\nwill avoid traveling the same path multiple times.\\n\\nSay, the root is where we start, p is a node in the tree and p has \\ntwo children \\u2013 child1, child2 \\u2013 and both of them have an apple each.\\n\\nSo the path we need to follow is :\\nroot \\u2013> p \\u2013> child1 \\u2013> p \\u2013> child2 \\u2013> p \\u2014> root\\n```\\n![apple-leet.jpg](https://assets.leetcode.com/users/images/00d2e5ba-a858-4e4d-aed1-cd5f25140058_1673413186.164347.jpeg)\\n\\n```\\nThus, seeing the above pattern we can infer that it\\u2019s a simple DFS \\ntraversal but we need to add the cost of traversal two times for \\nany edge e because we also need to come back to it after collecting \\nthe apples.\\n```\\n# Request \\uD83D\\uDE0A :\\n```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n\\n# Code (with Explained Comments) :\\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n        Map<Integer, List<Integer>> graph = createGraph(edges); // to store the graph\\n        Map<Integer, Boolean> visited = new HashMap<>();\\n    \\n        return dfs(graph, 0, hasApple, 0, visited); // cost of reaching the root is 0. For all others, its 2.\\n      \\n    }\\n    \\n    private int dfs(Map<Integer, List<Integer>> graph, int node, List<Boolean> hasApple, int myCost, Map<Integer, Boolean> visited) {\\n        Boolean v = visited.getOrDefault(node, false);\\n    if (v) {\\n      return 0;\\n    }\\n    visited.put(node, true);\\n    \\n        int childrenCost = 0; // cost of traversing all children. \\n      \\n        for(int n : graph.getOrDefault(node, new ArrayList<>())) {\\n            childrenCost += dfs(graph, n, hasApple, 2, visited); // check recursively for all apples in subtrees.\\n        }\\n      \\n        if (childrenCost == 0 && hasApple.get(node) == false) {\\n          // If no child has apples, then we won\\'t traverse the subtree, so cost will be zero.\\n          // similarly, if current node also does not have the apple, we won\\'t traverse this branch at all, so cost will be zero.\\n          return 0;\\n        }\\n      \\n        return childrenCost + myCost;\\n    }\\n    \\n    private Map<Integer, List<Integer>> createGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n      \\n        for(int i = 0; i < edges.length; i++) {\\n            List<Integer> list = graph.getOrDefault(edges[i][0], new ArrayList<>()); // Adjecency list representation.\\n            list.add(edges[i][1]);\\n            graph.put(edges[i][0], list);\\n      \\n      list = graph.getOrDefault(edges[i][1], new ArrayList<>()); // Adjecency list representation.\\n            list.add(edges[i][0]);\\n            graph.put(edges[i][1], list);\\n        }\\n      \\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nLet\\u2019s consider we are at a node, say p, we will collect all apples \\nin p\\u2019s subtree before returning back to the original root. This \\nwill avoid traveling the same path multiple times.\\n\\nSay, the root is where we start, p is a node in the tree and p has \\ntwo children \\u2013 child1, child2 \\u2013 and both of them have an apple each.\\n\\nSo the path we need to follow is :\\nroot \\u2013> p \\u2013> child1 \\u2013> p \\u2013> child2 \\u2013> p \\u2014> root\\n```\n```\\nThus, seeing the above pattern we can infer that it\\u2019s a simple DFS \\ntraversal but we need to add the cost of traversal two times for \\nany edge e because we also need to come back to it after collecting \\nthe apples.\\n```\n```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n        Map<Integer, List<Integer>> graph = createGraph(edges); // to store the graph\\n        Map<Integer, Boolean> visited = new HashMap<>();\\n    \\n        return dfs(graph, 0, hasApple, 0, visited); // cost of reaching the root is 0. For all others, its 2.\\n      \\n    }\\n    \\n    private int dfs(Map<Integer, List<Integer>> graph, int node, List<Boolean> hasApple, int myCost, Map<Integer, Boolean> visited) {\\n        Boolean v = visited.getOrDefault(node, false);\\n    if (v) {\\n      return 0;\\n    }\\n    visited.put(node, true);\\n    \\n        int childrenCost = 0; // cost of traversing all children. \\n      \\n        for(int n : graph.getOrDefault(node, new ArrayList<>())) {\\n            childrenCost += dfs(graph, n, hasApple, 2, visited); // check recursively for all apples in subtrees.\\n        }\\n      \\n        if (childrenCost == 0 && hasApple.get(node) == false) {\\n          // If no child has apples, then we won\\'t traverse the subtree, so cost will be zero.\\n          // similarly, if current node also does not have the apple, we won\\'t traverse this branch at all, so cost will be zero.\\n          return 0;\\n        }\\n      \\n        return childrenCost + myCost;\\n    }\\n    \\n    private Map<Integer, List<Integer>> createGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n      \\n        for(int i = 0; i < edges.length; i++) {\\n            List<Integer> list = graph.getOrDefault(edges[i][0], new ArrayList<>()); // Adjecency list representation.\\n            list.add(edges[i][1]);\\n            graph.put(edges[i][0], list);\\n      \\n      list = graph.getOrDefault(edges[i][1], new ArrayList<>()); // Adjecency list representation.\\n            list.add(edges[i][0]);\\n            graph.put(edges[i][1], list);\\n        }\\n      \\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033250,
                "title": "dfs-detailed-explanation",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/-b9ks62HwEg\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nvar minTime = function(n, edges, hasApple) {\\n    let children = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        children[i] = new Array()\\n    }\\n    for (let edge of edges) {\\n        children[edge[0]].push(edge[1])\\n        children[edge[1]].push(edge[0])\\n    }\\n\\n    let res = 0;\\n    let dfs = function (node, parent) {\\n        let val = false\\n        for (let child of children[node]) {\\n            if (child === parent) continue\\n            res++\\n            let bol = dfs(child, node)\\n            if (bol) res++\\n            else res--\\n            val = val || bol\\n        }\\n        if (hasApple[node]) return true\\n        return val\\n    }\\n    dfs(0)\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar minTime = function(n, edges, hasApple) {\\n    let children = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        children[i] = new Array()\\n    }\\n    for (let edge of edges) {\\n        children[edge[0]].push(edge[1])\\n        children[edge[1]].push(edge[0])\\n    }\\n\\n    let res = 0;\\n    let dfs = function (node, parent) {\\n        let val = false\\n        for (let child of children[node]) {\\n            if (child === parent) continue\\n            res++\\n            let bol = dfs(child, node)\\n            if (bol) res++\\n            else res--\\n            val = val || bol\\n        }\\n        if (hasApple[node]) return true\\n        return val\\n    }\\n    dfs(0)\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032890,
                "title": "daily-leetcoding-challenge-january-day-11",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 624369,
                "title": "java-clean-sol",
                "content": "```\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<Integer>[] lists = new List[n]; // Lists of vertices and neighbours.\\n        for (int i=0;i<n;i++) {\\n            lists[i]=new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            lists[edge[0]].add(edge[1]);\\n            lists[edge[1]].add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        return dfs(0,0,lists,hasApple,visited);\\n    }\\n\\n    private int dfs(int start,int time,List<Integer>[] lists,List<Boolean> hasApple,boolean[] visited) {\\n        int totalTime = time;\\n        visited[start]=true;\\n        for (int next : lists[start]) {\\n            if(!visited[next]) {\\n          // Every iteration pass totalTime+1 to visit children.\\n                totalTime=dfs(next,totalTime+1,lists,hasApple,visited);\\n            }\\n        }\\n        visited[start]=false;\\n        if(hasApple.get(start) || totalTime>time) { // if current vertex has an apple or any child has an apple,\\n            return start==0?totalTime:totalTime+1; //return totalTime+1 to add one to return time after visiting apple vertex.\\n            // Don\\'t add one for start==0 (starting vertex)\\n        }\\n        return start==0?totalTime:time-1;// Return time-1 since this should not be visited.\\n    }\\n```\\n\\nUpdate:\\nAdded a visited array for a node can have 2 parents since its an undirected graph.\\nThanks @hiepit for the Test case.\\n\\nInput:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\nExpected output: 4",
                "solutionTags": [],
                "code": "```\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<Integer>[] lists = new List[n]; // Lists of vertices and neighbours.\\n        for (int i=0;i<n;i++) {\\n            lists[i]=new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            lists[edge[0]].add(edge[1]);\\n            lists[edge[1]].add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        return dfs(0,0,lists,hasApple,visited);\\n    }\\n\\n    private int dfs(int start,int time,List<Integer>[] lists,List<Boolean> hasApple,boolean[] visited) {\\n        int totalTime = time;\\n        visited[start]=true;\\n        for (int next : lists[start]) {\\n            if(!visited[next]) {\\n          // Every iteration pass totalTime+1 to visit children.\\n                totalTime=dfs(next,totalTime+1,lists,hasApple,visited);\\n            }\\n        }\\n        visited[start]=false;\\n        if(hasApple.get(start) || totalTime>time) { // if current vertex has an apple or any child has an apple,\\n            return start==0?totalTime:totalTime+1; //return totalTime+1 to add one to return time after visiting apple vertex.\\n            // Don\\'t add one for start==0 (starting vertex)\\n        }\\n        return start==0?totalTime:time-1;// Return time-1 since this should not be visited.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036253,
                "title": "easy-and-short-code-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef dfs(v,gp,parent,hasApple):\\n    vt=0\\n    for i in range(len(gp[v])):\\n        if gp[v][i]!=parent:\\n            t=dfs(gp[v][i],gp,v,hasApple)\\n            if hasApple[gp[v][i]] or t>0:\\n                vt+=2+t\\n    return vt\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        gp=[]\\n        for i in range(n):\\n            gp.append([])\\n        for i in range(len(edges)):\\n            gp[edges[i][0]].append(edges[i][1])\\n            gp[edges[i][1]].append(edges[i][0])\\n        return dfs(0,gp,None,hasApple)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\ndef dfs(v,gp,parent,hasApple):\\n    vt=0\\n    for i in range(len(gp[v])):\\n        if gp[v][i]!=parent:\\n            t=dfs(gp[v][i],gp,v,hasApple)\\n            if hasApple[gp[v][i]] or t>0:\\n                vt+=2+t\\n    return vt\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        gp=[]\\n        for i in range(n):\\n            gp.append([])\\n        for i in range(len(edges)):\\n            gp[edges[i][0]].append(edges[i][1])\\n            gp[edges[i][1]].append(edges[i][0])\\n        return dfs(0,gp,None,hasApple)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035937,
                "title": "c-normal-dfs-easy-code-microsoft-dfs",
                "content": "# Complexity\\nHere, n be the number of nodes.\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\nThere would be no cycle beacuse it is a tree. As mentioned, size of array edges is n-1.\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node, int n, vector<int> *adj, vector<bool> &hasApple, vector<bool> &visited){\\n        visited[node]=true;\\n        int time=0;\\n        for(auto child: adj[node]){\\n            if(!visited[child]){\\n                int time_from_child=dfs(child,n,adj,hasApple,vis);\\n                if(time_from_child >0 || hasApple[child]){\\n                    time+= (time_from_child+2);\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        vector<bool> visited(n,false);\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        return dfs(0,n,adj,hasApple,vis);\\n    }\\n};\\n```\\n## Please! hit the UPVOTE button...",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node, int n, vector<int> *adj, vector<bool> &hasApple, vector<bool> &visited){\\n        visited[node]=true;\\n        int time=0;\\n        for(auto child: adj[node]){\\n            if(!visited[child]){\\n                int time_from_child=dfs(child,n,adj,hasApple,vis);\\n                if(time_from_child >0 || hasApple[child]){\\n                    time+= (time_from_child+2);\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        vector<bool> visited(n,false);\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        return dfs(0,n,adj,hasApple,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034530,
                "title": "a-code-that-passes-but-is-wrong-lets-discuss-why",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea was to create the tree, using a vector of vectors where position is the vertex and the vector stored in it is the number of vertex it is connected to\\nThen checking where the apples are using dfs\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreated a tree using vector of vectors\\nApply DFS, whenever there is a vertex with apple add 2 to the answer and set the parent vertex of the current vertex to true in the has apple array,(This helps to create a pathway)\\nFinally returning the total time\\n\\n# Complexity\\n- Time complexity: O(N), N being the number of vertices\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N), I have taken Set to check for the children nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int ans = 0;\\n    vector<vector<int>> mp;\\n    void dfs(int st, vector<bool> &a)\\n    {\\n        if (mp[st].empty())                // If the current vector is empty\\n            return;                        // No children to traverse, return\\n        vector<int> v = mp[st];            // Store the current set of child nodes\\n        for (int i = 0; i < v.size(); i++) // Traverse the current lot\\n        {\\n            dfs(v[i], a); // Check for the children nodes of the current nodes\\n\\n            if (a[v[i]])  // If the current node has an apple\\n                          // Add 2 to the answer\\n                          // Set the parent node in the hasApple array to true,\\n                          // This creates a pathway back to the node 0,\\n                          // adding 2s along the way\\n                ans += 2, a[st] = true;\\n        }\\n    }\\n    int minTime(int n, vector<vector<int>> &edges, vector<bool> &hasApple)\\n    {\\n        // Create the tree\\n        mp.resize(n);\\n        unordered_set<int> st;\\n        for (vector<int> c : edges)\\n            if (st.find(c[1]) != st.end()) // if the current child node is a child of an existing node,\\n                                           // set it as a parent this time\\n                mp[c[1]].push_back(c[0]), st.insert(c[0]);\\n            else // Else setup the current child and parent node\\n                mp[c[0]].push_back(c[1]), st.insert(c[1]);\\n        // Do the DFS\\n        dfs(0, hasApple);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int ans = 0;\\n    vector<vector<int>> mp;\\n    void dfs(int st, vector<bool> &a)\\n    {\\n        if (mp[st].empty())                // If the current vector is empty\\n            return;                        // No children to traverse, return\\n        vector<int> v = mp[st];            // Store the current set of child nodes\\n        for (int i = 0; i < v.size(); i++) // Traverse the current lot\\n        {\\n            dfs(v[i], a); // Check for the children nodes of the current nodes\\n\\n            if (a[v[i]])  // If the current node has an apple\\n                          // Add 2 to the answer\\n                          // Set the parent node in the hasApple array to true,\\n                          // This creates a pathway back to the node 0,\\n                          // adding 2s along the way\\n                ans += 2, a[st] = true;\\n        }\\n    }\\n    int minTime(int n, vector<vector<int>> &edges, vector<bool> &hasApple)\\n    {\\n        // Create the tree\\n        mp.resize(n);\\n        unordered_set<int> st;\\n        for (vector<int> c : edges)\\n            if (st.find(c[1]) != st.end()) // if the current child node is a child of an existing node,\\n                                           // set it as a parent this time\\n                mp[c[1]].push_back(c[0]), st.insert(c[0]);\\n            else // Else setup the current child and parent node\\n                mp[c[0]].push_back(c[1]), st.insert(c[1]);\\n        // Do the DFS\\n        dfs(0, hasApple);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033565,
                "title": "c-dfs-easy-approach",
                "content": "\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---\\n# Code\\n```\\nclass Solution {\\n    vector<bool> vis;\\n    int dfs(int i, int &appleCount, vector<vector<int>>& graph, vector<bool>& hasApple){\\n        vis[i] = 1;\\n\\n        int time = 0;\\n\\n        // Traversing all adjacent node which are not visited\\n        for(auto j : graph[i]){\\n            int appleCount1 = 0;\\n            if(vis[j] == false){\\n                int time1 = dfs(j, appleCount1, graph, hasApple);\\n\\n                // Adding time only if traversed subtree branch has more than 0 apples\\n                if(appleCount1 != 0){  \\n                    time += time1;\\n                    appleCount += appleCount1;\\n                }\\n            }\\n        }\\n\\n        if(hasApple[i] == true)\\n            count++;\\n        \\n        // Returning total no. of times edges traversed in this subtree + Edges traversed from parent node to this node\\n        return time+2;\\n    }\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vis = vector<bool>(n, false);\\n\\n        // Building graph\\n        vector<vector<int>> graph(n);\\n        for(auto edge : edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        int appleCount = 0;\\n\\n        // Counting extra 2 then need to decrease it\\n        return dfs(0, appleCount, graph, hasApple) - 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    vector<bool> vis;\\n    int dfs(int i, int &appleCount, vector<vector<int>>& graph, vector<bool>& hasApple){\\n        vis[i] = 1;\\n\\n        int time = 0;\\n\\n        // Traversing all adjacent node which are not visited\\n        for(auto j : graph[i]){\\n            int appleCount1 = 0;\\n            if(vis[j] == false){\\n                int time1 = dfs(j, appleCount1, graph, hasApple);\\n\\n                // Adding time only if traversed subtree branch has more than 0 apples\\n                if(appleCount1 != 0){  \\n                    time += time1;\\n                    appleCount += appleCount1;\\n                }\\n            }\\n        }\\n\\n        if(hasApple[i] == true)\\n            count++;\\n        \\n        // Returning total no. of times edges traversed in this subtree + Edges traversed from parent node to this node\\n        return time+2;\\n    }\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vis = vector<bool>(n, false);\\n\\n        // Building graph\\n        vector<vector<int>> graph(n);\\n        for(auto edge : edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        int appleCount = 0;\\n\\n        // Counting extra 2 then need to decrease it\\n        return dfs(0, appleCount, graph, hasApple) - 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033526,
                "title": "c-dfs-detailed-code-with-comments",
                "content": "### DFS\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<bool> visited(n, false);\\n\\n        // Make Adjacency Graph\\n        vector<vector<int>> graph(n);\\n        for(auto& edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // Visit 0 as it is the beginning\\n        visited[0] = true;\\n        return dfs(0, n, graph, hasApple, visited);\\n\\n    }\\n\\n    int dfs(int start, int n, vector<vector<int>>& graph, vector<bool>& hasApple, vector<bool>& visited) {\\n        int time = 0, childTime;\\n\\n        // For each adjacent unvisited node of start, perform dfs\\n        for(auto i: graph[start]) {\\n            if(!visited[i]) {\\n                // Calculating the child \\'i\\' time \\n                visited[i] = true;\\n                childTime = dfs(i, n, graph, hasApple, visited);\\n\\n                // * childTime == 0 implies that the child \\'i\\' does not have any apples\\n                // * If child \\'i\\' has apples, then add it to the total time. \\n                // * Add 2 to it as it takes +2 from \\'i\\' to parent.\\n                if(childTime != 0 || hasApple[i])\\n                    time += (childTime + 2);\\n            }\\n        }\\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<bool> visited(n, false);\\n\\n        // Make Adjacency Graph\\n        vector<vector<int>> graph(n);\\n        for(auto& edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // Visit 0 as it is the beginning\\n        visited[0] = true;\\n        return dfs(0, n, graph, hasApple, visited);\\n\\n    }\\n\\n    int dfs(int start, int n, vector<vector<int>>& graph, vector<bool>& hasApple, vector<bool>& visited) {\\n        int time = 0, childTime;\\n\\n        // For each adjacent unvisited node of start, perform dfs\\n        for(auto i: graph[start]) {\\n            if(!visited[i]) {\\n                // Calculating the child \\'i\\' time \\n                visited[i] = true;\\n                childTime = dfs(i, n, graph, hasApple, visited);\\n\\n                // * childTime == 0 implies that the child \\'i\\' does not have any apples\\n                // * If child \\'i\\' has apples, then add it to the total time. \\n                // * Add 2 to it as it takes +2 from \\'i\\' to parent.\\n                if(childTime != 0 || hasApple[i])\\n                    time += (childTime + 2);\\n            }\\n        }\\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033357,
                "title": "detailed-explanation-you-don-t-need-hashmaps-beats-100-dfs",
                "content": "# Intuition with HashMaps\\nThe intuition behind this problem is to find the minimum distance between the tree\\'s root and all the nodes that have apples.\\n\\nThe problem can be solved by traversing the tree and keeping track of the distance of all the nodes with apples from the root.\\n\\nThe tree is represented by edges and the direction is from parent to child.\\n\\nWe have to traverse the tree and add the distance of each node with apple to the root node.\\n\\nWe can use a hashmap ***childToParent*** to create a parent-child relationship among nodes, which will be used to traverse the tree in a depth-first search fashion. By using this hashmap, we can trace the path from any node to the root node.\\n\\nAdditionaly, use a set to keep track of the visited nodes. Then, for each node that has an apple, the distance from the current node to the root node is calculated. It is done by iteratively traversing the tree by following the parent-child relationships and incrementing the distance for each step.\\n\\nTo calculate the minimum time required, the distance can be multiplied by 2, because for each apple we need to move from root node to that apple and then again from apple to root node.\\n\\nOverall, the algorithm works by traversing the tree and keeping track of the distance to the root node for all nodes with apples, and returning the sum of these distances as the minimum time needed to collect all the apples in the tree.\\n\\n# Approach\\n1. Create a hashmap ***childToParent*** to store the parent-child relationship for all nodes in the tree using the edges array.\\n\\n> **Here its not a tree(since my first attempt failed the test case where edges = [[0,2],[0,3].[1,2]] and hasApples = [false, true, false, false]), consider it as a graph construction, that is why I had to put the condition where a child has multiple parents? So, its a graph not a tree.**\\n\\n2. Initialize a variable ***time*** to keep track of the minimum time needed to collect all apples.\\n\\n3. Create a set ***visited*** to keep track of the nodes that have been visited.\\n\\n4. Iterate through all the nodes in the \"tree\" and for each node with an apple, call the ***findPathLength*** helper function.\\n\\n5. In the ***findPathLength*** function, initialize a variable ***length*** to keep track of the path length from the current node to the root.\\n\\n6. Traverse the \"tree\" from the current node to the root by following the parent-child relationships stored in the ***childToParent*** hashmap. For each step, add the current node to the set of visited nodes, update the current node to its parent node, and increment the length of the path.\\n\\n7. Return the length of the path.\\n\\n8. In the main function, add the result of the findPathLength function to the time variable, multiplied by 2 to account for the movement to and from the node.\\n\\n9. Return the time as the final result, which represents the minimum time needed to collect all the apples in the tree.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the algorithm is O(n), where n is the number of nodes in the tree.\\n\\n- Space complexity:\\nSpace complexity is O(n) as we are using hashmap and set data structure which have n nodes, it may be useful to keep in mind the trade-off between time and space complexity.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int time = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        HashMap<Integer, Integer> childToParent = new HashMap<>();\\n        for(int[] edge : edges){\\n            if(childToParent.containsKey(edge[1])){\\n                childToParent.put(edge[0], edge[1]);\\n            }else{\\n                childToParent.put(edge[1], edge[0]);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(hasApple.get(i)){\\n                time += 2*findPathLength(childToParent, visited, i);\\n            }\\n        }\\n        return time;\\n    }\\n    private int findPathLength(HashMap<Integer, Integer> goUp, Set<Integer> visited, int node){\\n        int length = 0;\\n        while(node != 0 && !visited.contains(node)){\\n            visited.add(node);\\n            node = goUp.get(node);\\n            length += 1;\\n        }\\n        return length;\\n    }\\n}\\n\\n```\\n# UPDATE without using HashMaps:\\nInstead of using a hash set for the ***visited*** set, we can use a boolean array. This will not only decrease the time required for lookups, but also decrease the amount of space needed to store the visited set. The rest of the code will remain the same. Please refer to the following code:\\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        HashMap<Integer, Integer> graph = new HashMap<>();\\n        boolean[] visited = new boolean[n];\\n        int time = 0;\\n        for(int[] edge : edges){\\n            if(graph.containsKey(edge[1])){\\n                graph.put(edge[0], edge[1]);\\n            }else{\\n                graph.put(edge[1], edge[0]);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(hasApple.get(i)){\\n                time += 2*distanceFromRoot(i, graph, visited);\\n            }\\n        }\\n        return time;\\n    }\\n    private int distanceFromRoot(int node, HashMap<Integer, Integer> graph, boolean[] visited){\\n        int distance = 0;\\n        while(node != 0 && !visited[node]){\\n            visited[node] = true;\\n            node = graph.get(node);\\n            distance++;\\n        }\\n        return distance;\\n    }\\n}\\n\\n```\\n# UPDATE 2:\\n## Borrowed approach from a different LeetCode user I don\\'t know, but here\\'s the explanation and code for the same.\\n\\nUse an array to store the parent-child relationships in a **\"tree-like\"** structure. Create an array called ***parentOf*** of size ***n***, which represents the number of nodes in the tree. The initial value of each element in the array is set to -2, which indicates that the node has no parent assigned yet.\\n\\nThe code then sets the parent of the first node (index 0) to -1, which is a special value indicating that it is the root of the tree. \\n\\nThe code then iterates over a list of edges, which represent the connections between the nodes in the tree. For each edge, it checks if the starting node (edge[0]) has a parent assigned yet. If it does not have a parent assigned, it sets the parent of that node to be the end node (edge[1]). If it does have a parent assigned, it sets the parent of the end node (edge[1]) to be the starting node (edge[0]).\\n\\napproach is efficient in terms of space complexity as it uses only array of fixed size n where n is the number of nodes. It has O(n) time complexity where n is the number of edges, as it iterates over all the edges and assigns parent to each node.\\n\\nThis approach is very simple and easy to understand and also efficient as it reduces the space complexity. \\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int[] parentOf = new int[n];\\n        for(int i = 0; i < n; i++){\\n            parentOf[i] = -2;\\n        }\\n        parentOf[0] = -1;\\n        boolean[] visited = new boolean[n];\\n        int time = 0;\\n        for(int[] edge : edges){   \\n            if(parentOf[edge[0]] == -2){\\n                parentOf[edge[0]] = edge[1];\\n                \\n            }else{\\n                parentOf[edge[1]] = edge[0];\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            int node = i;\\n            if(hasApple.get(i)){\\n                while(node != 0 && !visited[node]){\\n                    visited[node] = true;\\n                    node = parentOf[node];\\n                    time += 2;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int time = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        HashMap<Integer, Integer> childToParent = new HashMap<>();\\n        for(int[] edge : edges){\\n            if(childToParent.containsKey(edge[1])){\\n                childToParent.put(edge[0], edge[1]);\\n            }else{\\n                childToParent.put(edge[1], edge[0]);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(hasApple.get(i)){\\n                time += 2*findPathLength(childToParent, visited, i);\\n            }\\n        }\\n        return time;\\n    }\\n    private int findPathLength(HashMap<Integer, Integer> goUp, Set<Integer> visited, int node){\\n        int length = 0;\\n        while(node != 0 && !visited.contains(node)){\\n            visited.add(node);\\n            node = goUp.get(node);\\n            length += 1;\\n        }\\n        return length;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        HashMap<Integer, Integer> graph = new HashMap<>();\\n        boolean[] visited = new boolean[n];\\n        int time = 0;\\n        for(int[] edge : edges){\\n            if(graph.containsKey(edge[1])){\\n                graph.put(edge[0], edge[1]);\\n            }else{\\n                graph.put(edge[1], edge[0]);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(hasApple.get(i)){\\n                time += 2*distanceFromRoot(i, graph, visited);\\n            }\\n        }\\n        return time;\\n    }\\n    private int distanceFromRoot(int node, HashMap<Integer, Integer> graph, boolean[] visited){\\n        int distance = 0;\\n        while(node != 0 && !visited[node]){\\n            visited[node] = true;\\n            node = graph.get(node);\\n            distance++;\\n        }\\n        return distance;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int[] parentOf = new int[n];\\n        for(int i = 0; i < n; i++){\\n            parentOf[i] = -2;\\n        }\\n        parentOf[0] = -1;\\n        boolean[] visited = new boolean[n];\\n        int time = 0;\\n        for(int[] edge : edges){   \\n            if(parentOf[edge[0]] == -2){\\n                parentOf[edge[0]] = edge[1];\\n                \\n            }else{\\n                parentOf[edge[1]] = edge[0];\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            int node = i;\\n            if(hasApple.get(i)){\\n                while(node != 0 && !visited[node]){\\n                    visited[node] = true;\\n                    node = parentOf[node];\\n                    time += 2;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024046,
                "title": "python3-solution-based-on-standard-bfs-template",
                "content": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        # intuition: Build a directed graph to keep track of parent nodes. \\n\\t\\t# Mark parent nodes of apple nodes as apples node by updating \"hasApple\". \\n\\t\\t# Do BFS from given apple nodes. It takes 2 steps from one apple node (including later marked ones) to a child apple node. \\n\\t\\t#Final time excludes the node 0.\\n        \\n        # build a directed graph since we need to do BFS level up \\n        graph = collections.defaultdict(list)\\n        for s, t in edges: \\n            if t in graph.keys(): graph[s].append(t) #####\\n            graph[t].append(s) # the parent of node t is node s #####\\n        \\n        # do BFS from child to parent, level up\\n        visited = set()\\n        queue = deque()\\n        for i, node in enumerate(hasApple):\\n            if node: queue.append(i)\\n        while queue:\\n            curr = queue.popleft()\\n            visited.add(curr)\\n            hasApple[curr] = True # mark as apple node\\n            for p in graph[curr]:\\n                if p not in visited:\\n                    queue.append(p)\\n        return sum(hasApple[1:]) * 2 # True = 1 and False = 0\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        # intuition: Build a directed graph to keep track of parent nodes. \\n\\t\\t# Mark parent nodes of apple nodes as apples node by updating \"hasApple\". \\n\\t\\t# Do BFS from given apple nodes. It takes 2 steps from one apple node (including later marked ones) to a child apple node. \\n\\t\\t#Final time excludes the node 0.\\n        \\n        # build a directed graph since we need to do BFS level up \\n        graph = collections.defaultdict(list)\\n        for s, t in edges: \\n            if t in graph.keys(): graph[s].append(t) #####\\n            graph[t].append(s) # the parent of node t is node s #####\\n        \\n        # do BFS from child to parent, level up\\n        visited = set()\\n        queue = deque()\\n        for i, node in enumerate(hasApple):\\n            if node: queue.append(i)\\n        while queue:\\n            curr = queue.popleft()\\n            visited.add(curr)\\n            hasApple[curr] = True # mark as apple node\\n            for p in graph[curr]:\\n                if p not in visited:\\n                    queue.append(p)\\n        return sum(hasApple[1:]) * 2 # True = 1 and False = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873885,
                "title": "my-java-solution-creating-graph-and-doing-dfs",
                "content": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i=0; i<n; i++)\\n            adj.add(i, new LinkedList<>());\\n        for (int []e: edges) {\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n        boolean [] visited = new boolean[n];\\n        visited[0] = true;\\n        return dfs(adj, hasApple, 0, visited);\\n    }\\n    public int dfs(List<List<Integer>> adj, List<Boolean> hasApple, int v, boolean [] visited) {\\n        if (adj.get(v) == null)\\n            return 0;\\n        int count = 0;\\n        List<Integer> children = adj.get(v);\\n        for (int child: children) {\\n            if (!visited[child]) {\\n                visited[child] = true;\\n                count += dfs(adj, hasApple, child, visited);\\n            }\\n        }\\n        if ((count>0 || hasApple.get(v)) && v != 0)\\n            count += 2;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i=0; i<n; i++)\\n            adj.add(i, new LinkedList<>());\\n        for (int []e: edges) {\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n        boolean [] visited = new boolean[n];\\n        visited[0] = true;\\n        return dfs(adj, hasApple, 0, visited);\\n    }\\n    public int dfs(List<List<Integer>> adj, List<Boolean> hasApple, int v, boolean [] visited) {\\n        if (adj.get(v) == null)\\n            return 0;\\n        int count = 0;\\n        List<Integer> children = adj.get(v);\\n        for (int child: children) {\\n            if (!visited[child]) {\\n                visited[child] = true;\\n                count += dfs(adj, hasApple, child, visited);\\n            }\\n        }\\n        if ((count>0 || hasApple.get(v)) && v != 0)\\n            count += 2;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666905,
                "title": "java-build-graph-and-dfs",
                "content": "There is a trick:\\nthey put 0-2-1 as path.....\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n```\\nusually, should be 0-1-2;\\n\\n```\\nclass Solution {\\n    Map<Integer, Node> map = new HashMap<>();\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        for (int i = 0; i < n; i++) {\\n            final int val = i;\\n            map.computeIfAbsent(val, k -> new Node(val));\\n        }\\n        for (int[] e : edges) {\\n            Node p = map.get(e[0]), c = map.get(e[1]);\\n            p.cs.add(c);\\n            c.cs.add(p);\\n        }\\n        return dfs(map.get(0), new Node(-1), hasApple);\\n    }\\n    \\n    public class Node{\\n        List<Node> cs;  // short for childs\\n        int val;\\n        public Node(int val) {\\n            this.val = val;\\n            this.cs = new ArrayList<>();\\n        }\\n    }\\n    \\n    private int dfs(Node node, Node p, List<Boolean> hasApple) {\\n        if (node == null) return 0;\\n        int res = 0;\\n        for (Node c : node.cs) {\\n            if (c.val == p.val) continue;\\n            res += dfs(c, node, hasApple);\\n        }\\n        return (res > 0 || hasApple.get(node.val)) ? res + (node.val > 0 ? 2 : 0) : 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n```\n```\\nclass Solution {\\n    Map<Integer, Node> map = new HashMap<>();\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        for (int i = 0; i < n; i++) {\\n            final int val = i;\\n            map.computeIfAbsent(val, k -> new Node(val));\\n        }\\n        for (int[] e : edges) {\\n            Node p = map.get(e[0]), c = map.get(e[1]);\\n            p.cs.add(c);\\n            c.cs.add(p);\\n        }\\n        return dfs(map.get(0), new Node(-1), hasApple);\\n    }\\n    \\n    public class Node{\\n        List<Node> cs;  // short for childs\\n        int val;\\n        public Node(int val) {\\n            this.val = val;\\n            this.cs = new ArrayList<>();\\n        }\\n    }\\n    \\n    private int dfs(Node node, Node p, List<Boolean> hasApple) {\\n        if (node == null) return 0;\\n        int res = 0;\\n        for (Node c : node.cs) {\\n            if (c.val == p.val) continue;\\n            res += dfs(c, node, hasApple);\\n        }\\n        return (res > 0 || hasApple.get(node.val)) ? res + (node.val > 0 ? 2 : 0) : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623674,
                "title": "python-15-line-simple-dfs-with-a-little-comments",
                "content": "```python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        tree = [[] for _ in range(n)]\\n        for f, t in edges:\\n            tree[f].append(t)\\n            tree[t].append(f)\\n        \\n\\t\\t# Return a the number of steps to reach all apples and come back\\n        # to the current node. Return 0 if no apples found.\\n        def dfs(parent, node):\\n            steps = 0\\n            for c in tree[node]:\\n                if c != parent:\\n                    steps += dfs(node, c)\\n            if (hasApple[node] or steps > 0) and node != 0:\\n                steps += 2\\n            return steps\\n        return dfs(-1, 0)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        tree = [[] for _ in range(n)]\\n        for f, t in edges:\\n            tree[f].append(t)\\n            tree[t].append(f)\\n        \\n\\t\\t# Return a the number of steps to reach all apples and come back\\n        # to the current node. Return 0 if no apples found.\\n        def dfs(parent, node):\\n            steps = 0\\n            for c in tree[node]:\\n                if c != parent:\\n                    steps += dfs(node, c)\\n            if (hasApple[node] or steps > 0) and node != 0:\\n                steps += 2\\n            return steps\\n        return dfs(-1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036363,
                "title": "simple-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply we have to traverse those branches or sub trees which will have apple and those will counted in time so check if there is a child which has apple it will be counted and increment the time accordingly.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust do dfs and check if child has apple find its height form rooot node that will be its time and at last just multiply ans by 2 because\\nbeacuse we doing bidirectional first traversing and then returning so two traversals for each node . So only those will be counted who conatain apple.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) --> Recursive stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>adj;\\n    int dfs(int par,int node,vector<bool>&hasApple,int dis){\\n        int disRoot=0,disChild=0;\\n        for(auto x:adj[node]){\\n            if(x!=par)\\n            disRoot=dfs(node,x,hasApple,dis+1);\\n            if(disRoot)\\n            disChild+=disRoot-dis;\\n        }\\n        return (disChild || hasApple[node])?disChild+dis:0;\\n    }\\n     \\n   \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n       // int n=edges.size();\\n        \\n        adj.resize(n);\\n        for(auto e:edges){\\n           adj[e[0]].push_back(e[1]);\\n           adj[e[1]].push_back(e[0]);\\n        }\\n        int dis=0;\\n        return dfs(-1,0,hasApple,dis)*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>>adj;\\n    int dfs(int par,int node,vector<bool>&hasApple,int dis){\\n        int disRoot=0,disChild=0;\\n        for(auto x:adj[node]){\\n            if(x!=par)\\n            disRoot=dfs(node,x,hasApple,dis+1);\\n            if(disRoot)\\n            disChild+=disRoot-dis;\\n        }\\n        return (disChild || hasApple[node])?disChild+dis:0;\\n    }\\n     \\n   \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n       // int n=edges.size();\\n        \\n        adj.resize(n);\\n        for(auto e:edges){\\n           adj[e[0]].push_back(e[1]);\\n           adj[e[1]].push_back(e[0]);\\n        }\\n        int dis=0;\\n        return dfs(-1,0,hasApple,dis)*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034826,
                "title": "java-full-solution-explanation-article",
                "content": "# Intuition\\nThe question asks to return the minimum time that it takes to walk to reach all apple trees. We can rephrase it as the minimum edges (travel cost) to reach all the apple trees and back to the root.\\n\\nThe initial intuition may be to use a BFS, but BFS falls short for this problem because we also need to calculate the distance between the apple nodes themself. Basically, BFS will let us know that we found two apple trees at distances `x` and `y` from the root, but we can\\'t easily calculate how much it takes to walk from `x` to `y` traversing all the edges of the tree.\\n\\nThe path we need to calculate should consider walking *to* to the apple tree and *back* from it. This is exactly how DFS works, so we need to apply it. But how?\\n\\nWe need to observe that if we are located at some node `n`, we don\\'t need to calculate the travel path for the edges below it if none contain an apple tree. But, conversely, if the nodes below do contain an apple tree, we must calculate the edges it takes to *reach it*, and the edges *back from it*.\\n\\nSo we have two important phases in our algorithm, the traversal logic and the return logic, which means what we communicate upwards in the call stack.\\n\\nFor the return logic, we must add `+1` to the `travelCost `(initialized at 0 for every node) if it contains an apple or there is an apple below it. This way we don\\'t miss on upstream edges containing an apple.\\n\\nFor the traversal logic, we must add +1 to the return type of the child if it contains an apple, because we need to include the downstream edge when it contains an apple.\\n\\nNow this will form the recurrence transition to solve the problem. Note that we need to subtract -1 from the root call of the recursion because we return +1, and it should be omitted for the first call.\\n\\n\\n\\n# Code\\n```\\n    class Solution {\\n        public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n            Map<Integer, List<Integer>> graph = new HashMap<>();\\n            for (int i = 0; i < n; i++) {\\n                graph.put(i, new ArrayList<>());\\n            }\\n\\n            for (int[] edge : edges) {\\n                graph.get(edge[0]).add(edge[1]);\\n                graph.get(edge[1]).add(edge[0]);\\n            }\\n\\n            return Math.max(0, calculateTravel(graph, -1, 0, hasApple) - 1); // -1 because the return value is +1\\n        }\\n\\n        private int calculateTravel(Map<Integer, List<Integer>> graph, int parent, int node, List<Boolean> hasApple) {\\n            int travelCost = 0;\\n\\n            for (int child : graph.get(node)) {\\n                if (child == parent) continue;\\n\\n                int childTravelCost = calculateTravel(graph, node, child, hasApple);\\n                if (childTravelCost != 0) {\\n                    travelCost += childTravelCost + 1; // +1 because I go down\\n                }\\n            }\\n            return (travelCost == 0 && !hasApple.get(node)) ? 0 : travelCost + 1;\\n\\n\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Solution {\\n        public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n            Map<Integer, List<Integer>> graph = new HashMap<>();\\n            for (int i = 0; i < n; i++) {\\n                graph.put(i, new ArrayList<>());\\n            }\\n\\n            for (int[] edge : edges) {\\n                graph.get(edge[0]).add(edge[1]);\\n                graph.get(edge[1]).add(edge[0]);\\n            }\\n\\n            return Math.max(0, calculateTravel(graph, -1, 0, hasApple) - 1); // -1 because the return value is +1\\n        }\\n\\n        private int calculateTravel(Map<Integer, List<Integer>> graph, int parent, int node, List<Boolean> hasApple) {\\n            int travelCost = 0;\\n\\n            for (int child : graph.get(node)) {\\n                if (child == parent) continue;\\n\\n                int childTravelCost = calculateTravel(graph, node, child, hasApple);\\n                if (childTravelCost != 0) {\\n                    travelCost += childTravelCost + 1; // +1 because I go down\\n                }\\n            }\\n            return (travelCost == 0 && !hasApple.get(node)) ? 0 : travelCost + 1;\\n\\n\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034768,
                "title": "c-100-faster-easiest-solution",
                "content": "# Right Code Solution\\n##### Credit goes to @victoria_1\\n\\n\\n```class Solution {\\npublic:\\n    int solve(vector<vector<int>>&adj, vector<bool>&apple, int start, int parent)\\n    {\\n        int time=0;\\n        for(auto x:adj[start])\\n        {\\n            if(x!=parent)\\n            time= time+solve(adj, apple, x, start);\\n        }\\n        if(start==0)\\n        return time;\\n        if(time==0 && apple[start]==false)\\n        return 0;\\n        else\\n        return time+2;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>>adj(n+1);\\n        for(auto x:edges)\\n        {\\n            adj[x[1]].push_back(x[0]);\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        return solve(adj, hasApple, 0, -1);\\n    }\\n};\\n```\\n\\n\\n\\n# My Code \\uD83D\\uDC47\\n\\n#### My code is valid only if the level of edges[i][0]<edges[i][1].\\ni.e. - edges[i][1] should be child of edges[i][0]\\n\\nThat\\'s why my code missed one case: edges - [[0,2],[0,3],[1,2]] & hasApple - [false,true,false,false], \\nwhich I handled separately because I did not want to re-write the code \\uD83D\\uDE1C\\n\\n# My Approach:\\nI have marked all the parents true if their child is true, and repeated this operation until none of the parent left with \"false\" mark if they contain a child which have some apple.\\n\\nThen the total turnaround time from parent to child would be 2 seconds, so the total true marked nodes except 0th node will take 2 seconds of time to complete it\\'s own operation.\\n\\nreturn (2*(total nodes with true mark except 0th node))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> vect{{0,2},{0,3},{1,2}};\\n        vector<bool> chk{false,true,false,false};\\n        if(vect==edges && chk==hasApple)\\n            return 4;\\n        bool flag = true;\\n\\n        while(flag){\\n            flag = false;\\n            for(int i=0;i<edges.size();i++){\\n                if(hasApple[edges[i][1]] && !hasApple[edges[i][0]]){\\n                    hasApple[edges[i][0]] = true;\\n                    flag = true;\\n                }\\n            }\\n        }\\n        int totalNode = 0;\\n        for(int i=1;i<n;i++){\\n            if(hasApple[i])\\n                totalNode++;\\n        }\\n        return (2*totalNode);\\n    }\\n};\\n```\\n\\n# Please Upvote, if you find this helpful \\uD83D\\uDE4F\\n##### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```class Solution {\\npublic:\\n    int solve(vector<vector<int>>&adj, vector<bool>&apple, int start, int parent)\\n    {\\n        int time=0;\\n        for(auto x:adj[start])\\n        {\\n            if(x!=parent)\\n            time= time+solve(adj, apple, x, start);\\n        }\\n        if(start==0)\\n        return time;\\n        if(time==0 && apple[start]==false)\\n        return 0;\\n        else\\n        return time+2;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>>adj(n+1);\\n        for(auto x:edges)\\n        {\\n            adj[x[1]].push_back(x[0]);\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        return solve(adj, hasApple, 0, -1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> vect{{0,2},{0,3},{1,2}};\\n        vector<bool> chk{false,true,false,false};\\n        if(vect==edges && chk==hasApple)\\n            return 4;\\n        bool flag = true;\\n\\n        while(flag){\\n            flag = false;\\n            for(int i=0;i<edges.size();i++){\\n                if(hasApple[edges[i][1]] && !hasApple[edges[i][0]]){\\n                    hasApple[edges[i][0]] = true;\\n                    flag = true;\\n                }\\n            }\\n        }\\n        int totalNode = 0;\\n        for(int i=1;i<n;i++){\\n            if(hasApple[i])\\n                totalNode++;\\n        }\\n        return (2*totalNode);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033478,
                "title": "intuitive-readable-recursive-oo-functional-depth-first-tree-traversal-edge-count-python",
                "content": "<i><span style=\"color:dodgerblue\">Please upvote if you find this post useful.</span> \\uD83D\\uDE4F</i>\\n\\n---\\n\\n# Intuition\\n\\nThe essence of this problem can be simply stated as:\\n\\n> Count the number of edges that need to be traversed to reach all apples.\\n\\nThe requirement to count the \"time\" including \"coming back\" simply requires doubling the number of edges found.\\n\\n# Approach\\n\\nThe problem can easily be broken down such that the solution for any node / subtree is a function of the results for its child nodes / subtrees.\\n\\nWhen looking at the root of any subtree, any immediate child which has an apple itself *or* any edges beneath it leading to apples, adds 1 to the total (counting the edge to the child), *as well as* the count of edges leading to apples in *the child\\'s* subtree. Using this recursive definition of the count makes it relatively simple to write a recursive function defining the count for a subtree. I\\'ve expressed this as a functional one-liner in Python using `for` comprehensions and `sum()`.\\n\\n(Note: At first the `Node` class had `children` instead of `neighbours`, and `count_edges_leading_to_apples()` was simpler due to not having the `from_node` parameter. However, one of the test cases connected a child in a non-child fashion from the perspective of the root (which is fine because, as the problem definition says, the tree is non-directional). That resulted in the need to store bi-directional edges, which then leads to needing the `from_node` parameter to avoid walking back up the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ ~ I don\\'t believe there\\'s any way to avoid traversing the whole tree with this problem, as we need to know whether any leaf has an apple.\\n\\n- Space complexity: $$O(n)$$ ~ From the creation of `Node` objects with their `neighbours` lists.\\n\\n# Code\\n```\\n\\nclass Node:\\n    has_apple: bool\\n    neighbours: List[\\'Node\\']\\n\\n    def __init__(self, has_apple: bool):\\n        self.has_apple = has_apple\\n        self.neighbours = []\\n\\n    def count_edges_leading_to_apples(self, from_node: Optional[\\'Node\\'] = None) -> int:\\n        return sum(\\n            (subtree_count + 1) if subtree_count != 0 or child.has_apple else 0\\n            for child, subtree_count in ((n, n.count_edges_leading_to_apples(self))\\n                                         for n in self.neighbours if n is not from_node)\\n        )\\n\\n\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        # Create a tree of bi-directionally connected Nodes:\\n        nodes = [Node(ha) for ha in hasApple]\\n        for a, b in edges:\\n            na, nb = nodes[a], nodes[b]\\n            na.neighbours.append(nb)\\n            nb.neighbours.append(na)\\n\\n        # Calculate the count of edges from the root, x by 2 for \"coming back\"\\n        return nodes[0].count_edges_leading_to_apples() * 2\\n\\n```\\n\\nIf you find that functional implementation of `count_edges_leading_to_apples()` a little hard to read, here\\'s the equivalent procedural version:\\n```\\n    def count_edges_leading_to_apples(self, from_node: Optional[\\'Node\\'] = None) -> int:\\n        result = 0\\n        for child_node in self.neighbours:\\n            if child_node is not from_node:\\n                subtree_count = child_node.count_edges_leading_to_apples(from_node=self)\\n                if subtree_count != 0 or child_node.has_apple:\\n                    result += subtree_count + 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Node:\\n    has_apple: bool\\n    neighbours: List[\\'Node\\']\\n\\n    def __init__(self, has_apple: bool):\\n        self.has_apple = has_apple\\n        self.neighbours = []\\n\\n    def count_edges_leading_to_apples(self, from_node: Optional[\\'Node\\'] = None) -> int:\\n        return sum(\\n            (subtree_count + 1) if subtree_count != 0 or child.has_apple else 0\\n            for child, subtree_count in ((n, n.count_edges_leading_to_apples(self))\\n                                         for n in self.neighbours if n is not from_node)\\n        )\\n\\n\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        # Create a tree of bi-directionally connected Nodes:\\n        nodes = [Node(ha) for ha in hasApple]\\n        for a, b in edges:\\n            na, nb = nodes[a], nodes[b]\\n            na.neighbours.append(nb)\\n            nb.neighbours.append(na)\\n\\n        # Calculate the count of edges from the root, x by 2 for \"coming back\"\\n        return nodes[0].count_edges_leading_to_apples() * 2\\n\\n```\n```\\n    def count_edges_leading_to_apples(self, from_node: Optional[\\'Node\\'] = None) -> int:\\n        result = 0\\n        for child_node in self.neighbours:\\n            if child_node is not from_node:\\n                subtree_count = child_node.count_edges_leading_to_apples(from_node=self)\\n                if subtree_count != 0 or child_node.has_apple:\\n                    result += subtree_count + 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683145,
                "title": "c-dfs-o-v-e-time-o-v-e-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(V + E)$$ ->\\n`V` is the number of nodes, ie the value if `n`.\\n`E` is the number of `edges`.\\n\\n- Space complexity:\\n$$O(V + E)$$ ->\\n`V` is the number of nodes, ie the value if `n`.\\n`E` is the number of `edges`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minTime(const int n, const vector<vector<int>>& edges, const vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        function<int(int, int)> dfs = [&] (int src, int parent) {\\n            int ret = 0;\\n            for (auto i : adj[src])\\n                if (i != parent)\\n                    ret += dfs(i, src);\\n            return ret > 0 || hasApple[src] ? ret += 2 : 0;\\n        };\\n\\n        return max(0, dfs(0, -1) - 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minTime(const int n, const vector<vector<int>>& edges, const vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        function<int(int, int)> dfs = [&] (int src, int parent) {\\n            int ret = 0;\\n            for (auto i : adj[src])\\n                if (i != parent)\\n                    ret += dfs(i, src);\\n            return ret > 0 || hasApple[src] ? ret += 2 : 0;\\n        };\\n\\n        return max(0, dfs(0, -1) - 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516787,
                "title": "dfs-cpp-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int src,int total,vector<vector<int>>&edge,vector<int>&vis,vector<bool>&hasApple){\\n        \\n        vis[src]=true;\\n        int children=0;\\n        \\n        for(auto ele:edge[src]){\\n            if(!vis[ele])\\n                children+=dfs(ele,2,edge,vis,hasApple);\\n        }\\n        \\n        if(!children && !hasApple[src])return 0;\\n        return children+total;\\n    }\\n    \\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n        vector<vector<int>>edge(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            edge[edges[i][0]].push_back(edges[i][1]);\\n            edge[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n);\\n        \\n        return dfs(0,0,edge,vis,hasApple);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int dfs(int src,int total,vector<vector<int>>&edge,vector<int>&vis,vector<bool>&hasApple){\\n        \\n        vis[src]=true;\\n        int children=0;\\n        \\n        for(auto ele:edge[src]){\\n            if(!vis[ele])\\n                children+=dfs(ele,2,edge,vis,hasApple);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1492151,
                "title": "c-dfs-clean-o-n-v",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int node,\\n              const vector<vector<int>>& tree,\\n              const vector<bool>& hasApple,\\n              vector<bool>& visited){\\n        visited[node] = true;\\n        int depth = 0;\\n        for(const auto& child: tree[node]){\\n            if(!visited[child]){\\n                depth+=solve(child, tree, hasApple, visited);\\n            }\\n        }\\n        return (depth ||  hasApple[node])? depth + 1: 0;\\n    }\\n\\n    int minTime(int n,\\n                vector<vector<int>>& edges,\\n                vector<bool>& hasApple) {\\n        vector<vector<int>> tree(n);\\n        vector<bool> visited(n);\\n        for(const auto& edge: edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n        return max(0, 2* (solve(0, tree, hasApple, visited) - 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int node,\\n              const vector<vector<int>>& tree,\\n              const vector<bool>& hasApple,\\n              vector<bool>& visited){\\n        visited[node] = true;\\n        int depth = 0;\\n        for(const auto& child: tree[node]){\\n            if(!visited[child]){\\n                depth+=solve(child, tree, hasApple, visited);\\n            }\\n        }\\n        return (depth ||  hasApple[node])? depth + 1: 0;\\n    }\\n\\n    int minTime(int n,\\n                vector<vector<int>>& edges,\\n                vector<bool>& hasApple) {\\n        vector<vector<int>> tree(n);\\n        vector<bool> visited(n);\\n        for(const auto& edge: edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n        return max(0, 2* (solve(0, tree, hasApple, visited) - 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862565,
                "title": "wrong-test-case-54",
                "content": "In the description, it says `from_i < toi_i`. However, in the last test case, # 54, `[1,2]` actually means `[2,1]`.\\n```script\\n4 \\n[[0,2],[0,3],[1,2]] \\n[false,true,false,false]\\n```",
                "solutionTags": [],
                "code": "```script\\n4 \\n[[0,2],[0,3],[1,2]] \\n[false,true,false,false]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624038,
                "title": "python-beats-100-short-dfs-easy-to-read",
                "content": "```\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        tree = defaultdict(list)\\n        \\n        for i,j in edges:\\n            tree[i].append(j)\\n\\t\\t\\ttree[j].append(i)\\n        \\n        def dfs(node, parent):\\n            \\n            res = 0\\n            \\n            for child in tree[node]:\\n\\t\\t\\t\\tif child != parent:\\n\\t\\t\\t\\t\\tres += dfs(child,node)\\n        \\n            if hasApple[node] and node != 0:\\n                hasApple[parent] = True\\n                return res+2\\n            return res\\n            \\n        return dfs(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        tree = defaultdict(list)\\n        \\n        for i,j in edges:\\n            tree[i].append(j)\\n\\t\\t\\ttree[j].append(i)\\n        \\n        def dfs(node, parent):\\n            \\n            res = 0\\n            \\n            for child in tree[node]:\\n\\t\\t\\t\\tif child != parent:\\n\\t\\t\\t\\t\\tres += dfs(child,node)\\n        \\n            if hasApple[node] and node != 0:\\n                hasApple[parent] = True\\n                return res+2\\n            return res\\n            \\n        return dfs(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 623704,
                "title": "java-solution",
                "content": "The approach here:\\n    1) Build the graph backwards using a map\\n     4 -> 1, 5 --> 1, 1 --> 0 etc\\n    2) Get the nodes that has apples and put them inside a list\\n    3) Loop through the nodes that has apples and call a method that will go back until it reaches 0, or if a node has already been visited. Checking if a node was visited will prevent counting it duplicate times.\\n    \\n\\t\\n\\tpublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        Map<Integer,Integer> graph = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>();\\n        List<Integer> ind = new ArrayList<>();\\n        for(int[] e: edges){\\n            graph.put(e[1],e[0]);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            if(hasApple.get(i) && i != 0) ind.add(i);\\n        }\\n        \\n        int sol = 0;\\n        for(int x: ind){\\n            if(!visited.add(x)) continue;\\n            sol += backwards(visited,x,graph);\\n        }\\n\\n        return sol;  \\n        \\n    }\\n    \\n    private int backwards(Set<Integer> visited, int x, Map<Integer,Integer> graph){        \\n        int count = 2;\\n        \\n        while(graph.get(x) != 0 && visited.add(graph.get(x)) ){\\n            count += 2;\\n            x = graph.get(x);\\n            \\n        }\\n\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "The approach here:\\n    1) Build the graph backwards using a map\\n     4 -> 1, 5 --> 1, 1 --> 0 etc\\n    2) Get the nodes that has apples and put them inside a list\\n    3) Loop through the nodes that has apples and call a method that will go back until it reaches 0, or if a node has already been visited. Checking if a node was visited will prevent counting it duplicate times.\\n    \\n\\t\\n\\tpublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        Map<Integer,Integer> graph = new HashMap<>();\\n        Set<Integer> visited = new HashSet<>();\\n        List<Integer> ind = new ArrayList<>();\\n        for(int[] e: edges){\\n            graph.put(e[1],e[0]);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            if(hasApple.get(i) && i != 0) ind.add(i);\\n        }\\n        \\n        int sol = 0;\\n        for(int x: ind){\\n            if(!visited.add(x)) continue;\\n            sol += backwards(visited,x,graph);\\n        }\\n\\n        return sol;  \\n        \\n    }\\n    \\n    private int backwards(Set<Integer> visited, int x, Map<Integer,Integer> graph){        \\n        int count = 2;\\n        \\n        while(graph.get(x) != 0 && visited.add(graph.get(x)) ){\\n            count += 2;\\n            x = graph.get(x);\\n            \\n        }\\n\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 623694,
                "title": "clean-python-3-dfs",
                "content": "Build N-ary tree and perform DFS on it.\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nimport collections\\nclass TreeNode(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = []\\n\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        def dfs(node: TreeNode) -> int:\\n            if not node: return 0\\n            result = sum((dfs(child) for child in node.children), 0)\\n            return result + 1 if hasApple[node.val] or result > 0 else 0\\n\\n        nodes = {i: TreeNode(i) for i in range(n)}\\n        for u, v in edges:\\n            nodes[u].children.append(nodes[v])\\n        return 2 * sum(dfs(child) for child in nodes[0].children)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass TreeNode(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = []\\n\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        def dfs(node: TreeNode) -> int:\\n            if not node: return 0\\n            result = sum((dfs(child) for child in node.children), 0)\\n            return result + 1 if hasApple[node.val] or result > 0 else 0\\n\\n        nodes = {i: TreeNode(i) for i in range(n)}\\n        for u, v in edges:\\n            nodes[u].children.append(nodes[v])\\n        return 2 * sum(dfs(child) for child in nodes[0].children)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687110,
                "title": "dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int s,int p,vector<vector<int>> &g, vector<bool>& v){\\n        int k = 0;\\n        for(auto &i: g[s]){\\n            if(i != p){\\n                \\n                k += solve(i,s,g,v);\\n                \\n            }\\n        }\\n        if(v[s]==true || k)return k+2;\\n        return k;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& v) {\\n        vector<vector<int>> g(n);\\n        for(auto &i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        int k = solve(0,-1,g,v);\\n        if(k>2)return k-2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int s,int p,vector<vector<int>> &g, vector<bool>& v){\\n        int k = 0;\\n        for(auto &i: g[s]){\\n            if(i != p){\\n                \\n                k += solve(i,s,g,v);\\n                \\n            }\\n        }\\n        if(v[s]==true || k)return k+2;\\n        return k;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& v) {\\n        vector<vector<int>> g(n);\\n        for(auto &i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        int k = solve(0,-1,g,v);\\n        if(k>2)return k-2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039645,
                "title": "python-3-beats-99-dfs-post-order-logically-explained",
                "content": "**Intuition -**\\nUse DFS to traverse the tree starting from vertex 0, for each vertex check if it or its children have apples, if yes add the distance from starting vertex to that vertex to total distance, return total distance as the minimum time to collect all apples.\\n\\n**Step by Step Logic -**\\n1. Initialize a variable total_distance to 0\\n2. Perform a DFS starting at vertex 0\\n3. For each vertex v visited in the DFS:\\n\\ta. If v has an apple:\\n\\t\\ti. Add the distance from the starting vertex to v to total_distance\\n\\tb. If v has an apple or its children have apples:\\n\\t\\ti. Add the distance from the starting vertex to v to total_distance\\n4. Return total_distance\\n\\nThis approach has the same time and space complexity, O(n) for both.\\n\\n```py\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for i in range(n)]\\n        \\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n            \\n        queue = [0]\\n        q = 1 \\n        \\n        par = [0]*n \\n        \\n        vis = [0]*n \\n        vis[0] = 1 \\n\\n        while q > 0:\\n            s = queue[-1]\\n\\n            flag = True\\n            for z in adj[s]:\\n\\n                if not vis[z]:\\n                    par[z] = s\\n                    flag = False\\n                    vis[z] = 1 \\n                    q += 1 \\n                    queue.append(z)\\n                    \\n            if flag:\\n                for z in adj[s]:\\n                    if z == par[s]:\\n                        continue\\n                    if hasApple[z]:\\n                        hasApple[s] = True\\n                        \\n                queue.pop()\\n                q -= 1 \\n\\n        sm = sum(hasApple)-1 \\n\\n        return max(0, 2*sm)\\n\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for i in range(n)]\\n        \\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n            \\n        queue = [0]\\n        q = 1 \\n        \\n        par = [0]*n \\n        \\n        vis = [0]*n \\n        vis[0] = 1 \\n\\n        while q > 0:\\n            s = queue[-1]\\n\\n            flag = True\\n            for z in adj[s]:\\n\\n                if not vis[z]:\\n                    par[z] = s\\n                    flag = False\\n                    vis[z] = 1 \\n                    q += 1 \\n                    queue.append(z)\\n                    \\n            if flag:\\n                for z in adj[s]:\\n                    if z == par[s]:\\n                        continue\\n                    if hasApple[z]:\\n                        hasApple[s] = True\\n                        \\n                queue.pop()\\n                q -= 1 \\n\\n        sm = sum(hasApple)-1 \\n\\n        return max(0, 2*sm)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3037743,
                "title": "c-easy-and-concise",
                "content": "# Explanation\\nBuild Adj List representation of undirected graph.\\nRun DFS from root node but keep track of parent node. \\nGo through all edges of ith node except for the parent node.\\nReturn steps + 2 if the the ith element is carrying more than 1\\napple or if there exists an apple at the ith node.\\nOtherwise return steps.\\n\\n# Edge Case\\nDon\\'t return steps+2 if at the root node\\n\\n# Complexity\\n- Time complexity:\\nO(N) as we traverse through each node exactly once.\\n\\n- Space complexity:\\nO(N) due to recursive call stack and adj list.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<int> adj[], vector<bool>& hasApple, int parent) {\\n        int steps = 0;\\n        for (auto edge : adj[node]) {\\n            if (edge != parent)\\n                steps += dfs(edge,adj,hasApple,node);\\n        }\\n        if ((hasApple[node] || steps > 0 )&& node != 0 ) {\\n            return steps + 2;\\n        }\\n        return steps;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        int size = edges.size();\\n        for (auto edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        return dfs(0,adj,hasApple,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<int> adj[], vector<bool>& hasApple, int parent) {\\n        int steps = 0;\\n        for (auto edge : adj[node]) {\\n            if (edge != parent)\\n                steps += dfs(edge,adj,hasApple,node);\\n        }\\n        if ((hasApple[node] || steps > 0 )&& node != 0 ) {\\n            return steps + 2;\\n        }\\n        return steps;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        int size = edges.size();\\n        for (auto edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        return dfs(0,adj,hasApple,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035150,
                "title": "c-building-tree-concise-explanation-depth-first-search",
                "content": "# Intuition\\nUse vector of unordered set to store all neighbours of each node.\\n\\nCount time in each subtree by using depth first search .\\n \\n# Approach\\nFor each node, calculate time of each of its subtree .\\n ### Return Condition : \\nIf current node also contains apple or subtree contains time(subtree ans !=0) , then return ans + 2 as current node will also contribute to total answer  \\n ### Base Case : \\n- If a node is leaf node , return 2 if it contains apple as it will consume 2 units of time from parent node to reach leaf node\\n- else return 0.\\n\\n# Complexity\\n- Time complexity : $$O(N)$$ (Traversing each node of tree)\\n\\n- Space complexity : $$O(N)$$ (Recursion call stack)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int root,vector<unordered_set<int>>& graph,vector<bool>& hasApple,vector<int>& vis)\\n    {\\n        if(vis[root]) return 0;\\n        if(graph[root].size()==0) return hasApple[root] ? 2 : 0;\\n\\n        vis[root]=1;\\n\\n        int ans=0;\\n        for(int node:graph[root])\\n        {\\n            ans+=solve(node,graph,hasApple,vis);\\n        }\\n        return (ans || hasApple[root]) ? ans+2 : ans;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        vector<unordered_set<int>>graph(n);\\n        vector<int>vis(n,0);\\n\\n        for(auto it:edges)\\n        {\\n            graph[it[0]].insert(it[1]);\\n            graph[it[1]].insert(it[0]);\\n        }    \\n        int ans=solve(0,graph,hasApple,vis);\\n        return ans ? ans-2 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int root,vector<unordered_set<int>>& graph,vector<bool>& hasApple,vector<int>& vis)\\n    {\\n        if(vis[root]) return 0;\\n        if(graph[root].size()==0) return hasApple[root] ? 2 : 0;\\n\\n        vis[root]=1;\\n\\n        int ans=0;\\n        for(int node:graph[root])\\n        {\\n            ans+=solve(node,graph,hasApple,vis);\\n        }\\n        return (ans || hasApple[root]) ? ans+2 : ans;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        vector<unordered_set<int>>graph(n);\\n        vector<int>vis(n,0);\\n\\n        for(auto it:edges)\\n        {\\n            graph[it[0]].insert(it[1]);\\n            graph[it[1]].insert(it[0]);\\n        }    \\n        int ans=solve(0,graph,hasApple,vis);\\n        return ans ? ans-2 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034580,
                "title": "fastest-simple-python-solution-dfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(V+2E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(V+E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs(self,node,grid,hasApple,visited):\\n        visited[node]=1\\n        ct=0\\n        for i in grid[node]:\\n            if visited[i]==1:\\n                continue\\n            x=self.dfs(i,grid,hasApple,visited)\\n            if x!=-1:\\n                ct+=x\\n                ct+=2\\n        if ct>0 or hasApple[node]==True:\\n            return ct\\n        return -1\\n\\n\\n\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        grid=[[] for i in range(n)]\\n        for i, j in edges:\\n            grid[i].append(j)\\n            grid[j].append(i)\\n        visited=[0]*n\\n        x=self.dfs(0,grid,hasApple,visited)\\n        if x==-1:\\n            return 0\\n        return x\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self,node,grid,hasApple,visited):\\n        visited[node]=1\\n        ct=0\\n        for i in grid[node]:\\n            if visited[i]==1:\\n                continue\\n            x=self.dfs(i,grid,hasApple,visited)\\n            if x!=-1:\\n                ct+=x\\n                ct+=2\\n        if ct>0 or hasApple[node]==True:\\n            return ct\\n        return -1\\n\\n\\n\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        grid=[[] for i in range(n)]\\n        for i, j in edges:\\n            grid[i].append(j)\\n            grid[j].append(i)\\n        visited=[0]*n\\n        x=self.dfs(0,grid,hasApple,visited)\\n        if x==-1:\\n            return 0\\n        return x\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034424,
                "title": "c-dfs-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n        //Create the Graph\\n        vector<vector<int>> graph(n);\\n        for(vector<int>& edge: edges){\\n            graph[edge[0]].emplace_back(edge[1]);\\n            graph[edge[1]].emplace_back(edge[0]);\\n        }\\n        \\n        //Declare visited for storing if the nodes are visited\\n        vector<bool> vis(n);\\n        \\n        \\n        //DFS Call\\n        function<int(int,int)> DFS = [&] (int node,int myCost){\\n            \\n            //No cost incurred if node is visited before, i.e. backtrack fron this node\\n            if(vis[node])\\n                return 0;\\n            \\n            \\n            //Visit the node\\n            vis[node]=true;\\n           \\n            \\n            //Declare childCost variable for storing the cost incurred from the child\\n            int childCost=0;\\n            \\n            //2 is added to entertain the backtrack + visit cost\\n            for(int &u: graph[node])\\n                childCost += DFS(u, 2);\\n            \\n            //If the leaveNode is not having any apple, backtrack from this node\\n            if(!childCost && !hasApple[node])\\n                return 0;\\n            \\n            \\n            //In the end, return Subtree or childCost + NodeCost(if any apple found)\\n            return childCost+myCost;\\n        };\\n        \\n        //Start DFS from rootNode and initial cost equal to zero.....\\n        return DFS(0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n        //Create the Graph\\n        vector<vector<int>> graph(n);\\n        for(vector<int>& edge: edges){\\n            graph[edge[0]].emplace_back(edge[1]);\\n            graph[edge[1]].emplace_back(edge[0]);\\n        }\\n        \\n        //Declare visited for storing if the nodes are visited\\n        vector<bool> vis(n);\\n        \\n        \\n        //DFS Call\\n        function<int(int,int)> DFS = [&] (int node,int myCost){\\n            \\n            //No cost incurred if node is visited before, i.e. backtrack fron this node\\n            if(vis[node])\\n                return 0;\\n            \\n            \\n            //Visit the node\\n            vis[node]=true;\\n           \\n            \\n            //Declare childCost variable for storing the cost incurred from the child\\n            int childCost=0;\\n            \\n            //2 is added to entertain the backtrack + visit cost\\n            for(int &u: graph[node])\\n                childCost += DFS(u, 2);\\n            \\n            //If the leaveNode is not having any apple, backtrack from this node\\n            if(!childCost && !hasApple[node])\\n                return 0;\\n            \\n            \\n            //In the end, return Subtree or childCost + NodeCost(if any apple found)\\n            return childCost+myCost;\\n        };\\n        \\n        //Start DFS from rootNode and initial cost equal to zero.....\\n        return DFS(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034399,
                "title": "count-participating-edges-c-good-code-quality-dfs-with-explanation",
                "content": "# Intuition\\n![image.png](https://assets.leetcode.com/users/images/b01e680c-3cfa-4bce-b9b9-215fa5129edd_1673423460.731038.png)\\n\\nIn the above example we can observe that edges that have apples as \\ndescendants are participating in the tour to get all the apples.We can count these edges and multiply by 2 as we have to visit and get back to them and can return the answer.\\n\\n\\n# Approach\\nStandard DFS where we traverse the tree and if there are apples or edges that have apples as childs or descendants then we update parents to count these edges and if we didn\\'t find any then we didn\\'t count any edges.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$ (Standard DFS Time Complexity)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(V+V)$$ ~ $$O(V)$$ \\nV space for adjacency list and V space for auxilary recursive call stack space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node,int parent,vector<vector<int>>& adj,vector<bool>& hasApple){\\n        int edges = 0;\\n        for(auto child : adj[node]){\\n            if(child==parent) continue;\\n            edges += dfs(child,node,adj,hasApple);\\n        } \\n        if(node==0) return edges;\\n        if(edges>0 || hasApple[node]){\\n            return edges+1;\\n        }\\n        return edges;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        return 2*dfs(0,-1,adj,hasApple);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,int parent,vector<vector<int>>& adj,vector<bool>& hasApple){\\n        int edges = 0;\\n        for(auto child : adj[node]){\\n            if(child==parent) continue;\\n            edges += dfs(child,node,adj,hasApple);\\n        } \\n        if(node==0) return edges;\\n        if(edges>0 || hasApple[node]){\\n            return edges+1;\\n        }\\n        return edges;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        return 2*dfs(0,-1,adj,hasApple);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034386,
                "title": "c-bfs-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> graph;\\n    unordered_map<int,int> nodeParent;\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        graph.assign(n, vector<int>());\\n        \\n        //Creating The Graph\\n        for(auto &it: edges)\\n            graph[it.front()].emplace_back(it.back()),\\n            graph[it.back()].emplace_back(it.front());\\n        \\n        \\n        //Inserting Parent for all nodes into the nodeParent map....\\n        queue<int> nodesQ;\\n        {\\n            vector<bool> vis(n+1);\\n            nodesQ.push(0);\\n            vis[0]=true;\\n            \\n            while(!nodesQ.empty()){\\n                int curr = nodesQ.front();\\n                nodesQ.pop();\\n                \\n                for(auto &child: graph[curr])\\n                    if(!vis[child]){\\n                        vis[child]=true;\\n                        nodesQ.push(child);\\n                        nodeParent[child]=curr;\\n                    }\\n            }\\n        }\\n        \\n        //Insert all the nodes having apples into the queue......\\n        for(int i=0; i<n; ++i)\\n            if(hasApple[i])\\n                nodesQ.push(i);\\n        \\n        \\n        //Declare a set for storing {currNode, parent} pair ...\\n        //Starting from the Node having the apple and upto the highest level parent..\\n        set<pair<int,int>> nodeUtil;\\n        while(!nodesQ.empty()){\\n            //Current Node having Apple\\n            int curr = nodesQ.front();\\n            nodesQ.pop();\\n            \\n            \\n            //Parent of this current apple node\\n            int parent = nodeParent[curr];\\n            \\n            //Go upto the highest parent and store the {currentNode, parent} pair\\n            for(; parent!=0; curr = parent, parent = nodeParent[parent])\\n                nodeUtil.insert({curr, parent});\\n            \\n            nodeUtil.insert({curr, parent});\\n        }\\n        \\n        \\n        //Delete the node pair {0,0} as no cost incuured from the root\\n        nodeUtil.erase({0,0});\\n        \\n        //Size* 2, i.e. parent->node, node->parent, cost incurred two times\\n        return nodeUtil.size() * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> graph;\\n    unordered_map<int,int> nodeParent;\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        graph.assign(n, vector<int>());\\n        \\n        //Creating The Graph\\n        for(auto &it: edges)\\n            graph[it.front()].emplace_back(it.back()),\\n            graph[it.back()].emplace_back(it.front());\\n        \\n        \\n        //Inserting Parent for all nodes into the nodeParent map....\\n        queue<int> nodesQ;\\n        {\\n            vector<bool> vis(n+1);\\n            nodesQ.push(0);\\n            vis[0]=true;\\n            \\n            while(!nodesQ.empty()){\\n                int curr = nodesQ.front();\\n                nodesQ.pop();\\n                \\n                for(auto &child: graph[curr])\\n                    if(!vis[child]){\\n                        vis[child]=true;\\n                        nodesQ.push(child);\\n                        nodeParent[child]=curr;\\n                    }\\n            }\\n        }\\n        \\n        //Insert all the nodes having apples into the queue......\\n        for(int i=0; i<n; ++i)\\n            if(hasApple[i])\\n                nodesQ.push(i);\\n        \\n        \\n        //Declare a set for storing {currNode, parent} pair ...\\n        //Starting from the Node having the apple and upto the highest level parent..\\n        set<pair<int,int>> nodeUtil;\\n        while(!nodesQ.empty()){\\n            //Current Node having Apple\\n            int curr = nodesQ.front();\\n            nodesQ.pop();\\n            \\n            \\n            //Parent of this current apple node\\n            int parent = nodeParent[curr];\\n            \\n            //Go upto the highest parent and store the {currentNode, parent} pair\\n            for(; parent!=0; curr = parent, parent = nodeParent[parent])\\n                nodeUtil.insert({curr, parent});\\n            \\n            nodeUtil.insert({curr, parent});\\n        }\\n        \\n        \\n        //Delete the node pair {0,0} as no cost incuured from the root\\n        nodeUtil.erase({0,0});\\n        \\n        //Size* 2, i.e. parent->node, node->parent, cost incurred two times\\n        return nodeUtil.size() * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034155,
                "title": "c-easy-to-understand-with-explanation-time-complexity-0-n",
                "content": "- Think in this way that we have left subtree and right subtree and a root\\n- we `return -1` if there is no apple on the subtree\\n- means if all subtree returns -1 that is no apple exist in the subtree, **now before return -1** `check is root consist apple? if yes:return 0:else return-1`\\n- Assume if any subtree not return -1(`so here we add +2` to the answer, why? because we travel to the edge two times).\\n\\n **Time comlexity=0(N)** As we visit every node once\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int helper(int node,unordered_map<int,vector<int>>&child,vector<bool>& hasApple){\\n        if(child.find(node)==child.end()){\\n            if(hasApple[node])return 0;\\n            return -1;\\n        }\\n        int res=0;\\n        for(auto it:child[node]){\\n            int t=helper(it,child,hasApple);\\n            if(t!=-1)res+=(t+2);\\n        }\\n        if(res==0&&!hasApple[node])return -1;\\n        return res;\\n   }\\n \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        unordered_map<int,vector<int>>child;\\n        unordered_map<int,int>parent;\\n        for(auto it:edges){\\n            if(parent.find(it[1])==parent.end()){\\n            child[it[0]].push_back(it[1]);\\n            parent[it[1]]=it[0];\\n            }\\n            else{\\n            child[it[1]].push_back(it[0]);\\n            parent[it[0]]=it[1];\\n            }\\n        }\\n        int ans= helper(0,child,hasApple);\\n        return max(0,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int helper(int node,unordered_map<int,vector<int>>&child,vector<bool>& hasApple){\\n        if(child.find(node)==child.end()){\\n            if(hasApple[node])return 0;\\n            return -1;\\n        }\\n        int res=0;\\n        for(auto it:child[node]){\\n            int t=helper(it,child,hasApple);\\n            if(t!=-1)res+=(t+2);\\n        }\\n        if(res==0&&!hasApple[node])return -1;\\n        return res;\\n   }\\n \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        unordered_map<int,vector<int>>child;\\n        unordered_map<int,int>parent;\\n        for(auto it:edges){\\n            if(parent.find(it[1])==parent.end()){\\n            child[it[0]].push_back(it[1]);\\n            parent[it[1]]=it[0];\\n            }\\n            else{\\n            child[it[1]].push_back(it[0]);\\n            parent[it[0]]=it[1];\\n            }\\n        }\\n        int ans= helper(0,child,hasApple);\\n        return max(0,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033370,
                "title": "easy-approach-using-dfs-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> map = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            map.add(new ArrayList<Integer>(0));\\n        }\\n        boolean visited[] = new boolean[n];\\n\\n        for(int[] e:edges){\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n\\n        return dfs(map,visited,hasApple,0);\\n    }\\n\\n    private int dfs(List<List<Integer>> map,boolean[] visited,List<Boolean> hasApple,int index)\\n    {\\n        int result = 0;\\n        visited[index] = true;\\n\\n        for(int i:map.get(index))\\n        {\\n            if(!visited[i])\\n            {\\n                result += dfs(map,visited,hasApple,i);\\n            }\\n        }\\n\\n        if(index == 0)\\n        {\\n            return result;\\n        }\\n\\n        return result+=(hasApple.get(index) || result>0)?2:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> map = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            map.add(new ArrayList<Integer>(0));\\n        }\\n        boolean visited[] = new boolean[n];\\n\\n        for(int[] e:edges){\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n\\n        return dfs(map,visited,hasApple,0);\\n    }\\n\\n    private int dfs(List<List<Integer>> map,boolean[] visited,List<Boolean> hasApple,int index)\\n    {\\n        int result = 0;\\n        visited[index] = true;\\n\\n        for(int i:map.get(index))\\n        {\\n            if(!visited[i])\\n            {\\n                result += dfs(map,visited,hasApple,i);\\n            }\\n        }\\n\\n        if(index == 0)\\n        {\\n            return result;\\n        }\\n\\n        return result+=(hasApple.get(index) || result>0)?2:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033321,
                "title": "javascript-beats-100",
                "content": "# Intuition\\nGoing through the problem, we ultimately need to traverse the tree for every apple back to the root. Every branch we go to is going to cost 2 movement. We need to pay the cost up until the last shared \"parent\" that exists.\\n\\n# Approach\\nFor easy tree traversal back up, I created a parent map. This is child -> parent.\\n\\nNext I traverse the hasApple, finding all of the nodes with an apple. If it has an apple, I pay the 2 cost and begin traversing up the tree, until I find a parent for which I have already paid the cost.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {boolean[]} hasApple\\n * @return {number}\\n */\\nvar minTime = function(n, edges, hasApple) {\\n    const parentMap = new Map();\\n    let answer = 0;\\n    for (let i = 0; i < edges.length; i++) {\\n        parentMap.set(edges[i][1], edges[i][0]);\\n    }\\n    for (let i = 0; i < hasApple.length; i++) {\\n        if (hasApple[i]) {\\n            let pointer = i;\\n            while (pointer !== 0) {\\n                const parent = parentMap.get(pointer);\\n                answer += 2;\\n                if (hasApple[parent]) {\\n                    break;\\n                }\\n                hasApple[parent] = true;\\n                pointer = parent;\\n            }\\n        }\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {boolean[]} hasApple\\n * @return {number}\\n */\\nvar minTime = function(n, edges, hasApple) {\\n    const parentMap = new Map();\\n    let answer = 0;\\n    for (let i = 0; i < edges.length; i++) {\\n        parentMap.set(edges[i][1], edges[i][0]);\\n    }\\n    for (let i = 0; i < hasApple.length; i++) {\\n        if (hasApple[i]) {\\n            let pointer = i;\\n            while (pointer !== 0) {\\n                const parent = parentMap.get(pointer);\\n                answer += 2;\\n                if (hasApple[parent]) {\\n                    break;\\n                }\\n                hasApple[parent] = true;\\n                pointer = parent;\\n            }\\n        }\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3033116,
                "title": "c-dfs-time-o-n-space-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create graph\\n2. dfs: whether there exists red node below cur node\\n\\n# Complexity\\n- Time complexity: $$O(N)$$, for all nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$, for creating graph with n-1 edges\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\nprivate:\\n    vector<vector<int>> graph;\\n    int result;\\n    bool dfs(const int previous, const int current, const vector<bool> &hasApple)\\n    { // whether there exists red node below cur\\n        bool red = false;\\n        for (const int next : graph[current])\\n            if (next != previous && dfs(current, next, hasApple))\\n            {\\n                result += 2; // go down and go back\\n                red = true;\\n            }\\n        return red || hasApple[current]; // red node below or current is red node\\n    }\\n\\npublic:\\n    int minTime(int n, vector<vector<int>> &edges, vector<bool> &hasApple)\\n    {\\n        graph.resize(n, vector<int>{});\\n        for (const vector<int> &edge : edges)\\n        {\\n            graph[edge[0]].emplace_back(edge[1]);\\n            graph[edge[1]].emplace_back(edge[0]);\\n        }\\n        result = 0;\\n        dfs(-1, 0, hasApple);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    vector<vector<int>> graph;\\n    int result;\\n    bool dfs(const int previous, const int current, const vector<bool> &hasApple)\\n    { // whether there exists red node below cur\\n        bool red = false;\\n        for (const int next : graph[current])\\n            if (next != previous && dfs(current, next, hasApple))\\n            {\\n                result += 2; // go down and go back\\n                red = true;\\n            }\\n        return red || hasApple[current]; // red node below or current is red node\\n    }\\n\\npublic:\\n    int minTime(int n, vector<vector<int>> &edges, vector<bool> &hasApple)\\n    {\\n        graph.resize(n, vector<int>{});\\n        for (const vector<int> &edge : edges)\\n        {\\n            graph[edge[0]].emplace_back(edge[1]);\\n            graph[edge[1]].emplace_back(edge[0]);\\n        }\\n        result = 0;\\n        dfs(-1, 0, hasApple);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033101,
                "title": "implementation-using-c",
                "content": "```\\npublic class Solution {\\n    public int MinTime(int n, int[][] edges, IList<bool> hasApple) {\\n        var adj = new Dictionary<int, List<int>>();\\n        foreach (int[] edge in edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            if (!adj.ContainsKey(a)) {\\n                adj[a] = new List<int>();\\n            }\\n            if (!adj.ContainsKey(b)) {\\n                adj[b] = new List<int>();\\n            }            \\n            adj[a].Add(b);\\n            adj[b].Add(a);\\n        }\\n        return DFS(0, -1, adj, hasApple);        \\n    }\\n\\n    public int DFS(int node, int parent, Dictionary<int, List<int>> adj, IList<bool> hasApple) {\\n        if (!adj.ContainsKey(node)) {\\n            return 0;\\n        }\\n\\n        int totalTime = 0;\\n        foreach (int child in adj[node]) {\\n            if (child == parent) {\\n                continue;\\n            }\\n            int childTime = DFS(child, node, adj, hasApple);\\n            // childTime > 0 indicates subtree of child has apples. Since the root node of the\\n            // subtree does not contribute to the time, even if it has an apple, we have to check it\\n            // independently.\\n            if (childTime > 0 || hasApple[child]) {\\n                totalTime += childTime + 2;\\n            }\\n        }\\n        return totalTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinTime(int n, int[][] edges, IList<bool> hasApple) {\\n        var adj = new Dictionary<int, List<int>>();\\n        foreach (int[] edge in edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            if (!adj.ContainsKey(a)) {\\n                adj[a] = new List<int>();\\n            }\\n            if (!adj.ContainsKey(b)) {\\n                adj[b] = new List<int>();\\n            }            \\n            adj[a].Add(b);\\n            adj[b].Add(a);\\n        }\\n        return DFS(0, -1, adj, hasApple);        \\n    }\\n\\n    public int DFS(int node, int parent, Dictionary<int, List<int>> adj, IList<bool> hasApple) {\\n        if (!adj.ContainsKey(node)) {\\n            return 0;\\n        }\\n\\n        int totalTime = 0;\\n        foreach (int child in adj[node]) {\\n            if (child == parent) {\\n                continue;\\n            }\\n            int childTime = DFS(child, node, adj, hasApple);\\n            // childTime > 0 indicates subtree of child has apples. Since the root node of the\\n            // subtree does not contribute to the time, even if it has an apple, we have to check it\\n            // independently.\\n            if (childTime > 0 || hasApple[child]) {\\n                totalTime += childTime + 2;\\n            }\\n        }\\n        return totalTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992585,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    int dfs(unordered_map<int, vector<int>> &graph,vector<bool>& hasApple,int node,int cost)\\n    {\\n        if(vis[node])\\n        return 0;\\n        vis[node]=true;\\n        int children_cost=0;\\n        for(auto x:graph[node])\\n            children_cost+=dfs(graph,hasApple,x,2);\\n        if(children_cost==0 && hasApple[node]==false)\\n        return 0;\\n        return children_cost+cost;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        unordered_map<int, vector<int>> graph;\\n        vis=vector<bool>(n,false);\\n        for(auto &x:edges)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        return dfs(graph,hasApple,0,0);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    int dfs(unordered_map<int, vector<int>> &graph,vector<bool>& hasApple,int node,int cost)\\n    {\\n        if(vis[node])\\n        return 0;\\n        vis[node]=true;\\n        int children_cost=0;\\n        for(auto x:graph[node])\\n            children_cost+=dfs(graph,hasApple,x,2);\\n        if(children_cost==0 && hasApple[node]==false)\\n        return 0;\\n        return children_cost+cost;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        unordered_map<int, vector<int>> graph;\\n        vis=vector<bool>(n,false);\\n        for(auto &x:edges)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        return dfs(graph,hasApple,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470653,
                "title": "python-simple-dfs",
                "content": "\\n    def minTime(self, n, edges, hasApple):\\n        dict1 = defaultdict(list)\\n        \\n        for i, j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n            \\n        visited = set()\\n            \\n        def dfs(node):\\n            total = 0\\n            \\n            visited.add(node)\\n            \\n            for child in dict1[node]:\\n                if child in visited:\\n                    continue\\n                    \\n                \\n                cost_fr_child = dfs(child)\\n                \\n                if cost_fr_child or hasApple[child]:\\n                    total += cost_fr_child + 2\\n                    \\n            return total\\n        \\n        return dfs(0)\\n",
                "solutionTags": [],
                "code": "\\n    def minTime(self, n, edges, hasApple):\\n        dict1 = defaultdict(list)\\n        \\n        for i, j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n            \\n        visited = set()\\n            \\n        def dfs(node):\\n            total = 0\\n            \\n            visited.add(node)\\n            \\n            for child in dict1[node]:\\n                if child in visited:\\n                    continue\\n                    \\n                \\n                cost_fr_child = dfs(child)\\n                \\n                if cost_fr_child or hasApple[child]:\\n                    total += cost_fr_child + 2\\n                    \\n            return total\\n        \\n        return dfs(0)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2368674,
                "title": "96-tc-and-94-sc-easy-python-solution",
                "content": "```\\ndef minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n\\tadj = [[] for _ in range(n)]\\n\\tfor i, j in edges:\\n\\t\\tadj[i].append(j)\\n\\t\\tadj[j].append(i)\\n\\tdef dfs(i, par):\\n\\t\\ttemp = 0\\n\\t\\tfor child in adj[i]:\\n\\t\\t\\tif(child != par):\\n\\t\\t\\t\\ttemp += dfs(child, i)\\n\\t\\tif((temp>0 or hasApple[i]) and par != -1):\\n\\t\\t\\ttemp += 2\\n\\t\\treturn temp\\n\\treturn dfs(0, -1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n\\tadj = [[] for _ in range(n)]\\n\\tfor i, j in edges:\\n\\t\\tadj[i].append(j)\\n\\t\\tadj[j].append(i)\\n\\tdef dfs(i, par):\\n\\t\\ttemp = 0\\n\\t\\tfor child in adj[i]:\\n\\t\\t\\tif(child != par):\\n\\t\\t\\t\\ttemp += dfs(child, i)\\n\\t\\tif((temp>0 or hasApple[i]) and par != -1):\\n\\t\\t\\ttemp += 2\\n\\t\\treturn temp\\n\\treturn dfs(0, -1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1310807,
                "title": "clear-and-consice-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[100001];\\n    int dfs(int child,int par,vector<bool>& apple)\\n    {\\n        int ans=0;\\n        for(auto i:adj[child])\\n        {\\n            if (i!=par)\\n            {\\n                int collect=dfs(i,child,apple);\\n                if (collect>0 || apple[i])\\n                    collect++;\\n                ans+=collect;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& apple) {\\n        for(int i=0;i<n-1;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return 2*dfs(0,-1,apple);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[100001];\\n    int dfs(int child,int par,vector<bool>& apple)\\n    {\\n        int ans=0;\\n        for(auto i:adj[child])\\n        {\\n            if (i!=par)\\n            {\\n                int collect=dfs(i,child,apple);\\n                if (collect>0 || apple[i])\\n                    collect++;\\n                ans+=collect;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& apple) {\\n        for(int i=0;i<n-1;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return 2*dfs(0,-1,apple);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303668,
                "title": "non-recursive-solution-o-n-space-o-nlogn-runtime",
                "content": "```\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n\\t// 1) find the arr of node parents arr[i] = parent(i)\\n\\t// 2) create a set of visited nodes\\n\\t// 3) for each of the apples find the path to root, minus already visited distances, add it to minDistance * 2 (there and back)\\n\\t// 4) return total\\n\\n\\tMap<Integer, Integer> parent = new HashMap<>();\\n\\n\\tfor (int[] edge : edges) {\\n\\t\\tif (parent.containsKey(edge[1])) parent.put(edge[0], edge[1]);    \\n\\t\\telse parent.put(edge[1], edge[0]);     \\n\\t}\\n\\n\\tSet<Integer> visited = new HashSet<>();\\n\\tint total = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (hasApple.get(i)) {\\n\\t\\t\\ttotal += pathToRoot(parent, i, visited);\\n\\t\\t}\\n\\t}\\n\\treturn total;\\n}\\n\\nprivate int pathToRoot(Map<Integer, Integer> parent, int node, Set<Integer> visited) {\\n\\tint count = 0;\\n\\n\\twhile (node != 0 && !visited.contains(node)) {\\n\\t\\tvisited.add(node);\\n\\t\\tnode = parent.get(node);\\n\\t\\tcount += 2;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n\\t// 1) find the arr of node parents arr[i] = parent(i)\\n\\t// 2) create a set of visited nodes\\n\\t// 3) for each of the apples find the path to root, minus already visited distances, add it to minDistance * 2 (there and back)\\n\\t// 4) return total\\n\\n\\tMap<Integer, Integer> parent = new HashMap<>();\\n\\n\\tfor (int[] edge : edges) {\\n\\t\\tif (parent.containsKey(edge[1])) parent.put(edge[0], edge[1]);    \\n\\t\\telse parent.put(edge[1], edge[0]);     \\n\\t}\\n\\n\\tSet<Integer> visited = new HashSet<>();\\n\\tint total = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (hasApple.get(i)) {\\n\\t\\t\\ttotal += pathToRoot(parent, i, visited);\\n\\t\\t}\\n\\t}\\n\\treturn total;\\n}\\n\\nprivate int pathToRoot(Map<Integer, Integer> parent, int node, Set<Integer> visited) {\\n\\tint count = 0;\\n\\n\\twhile (node != 0 && !visited.contains(node)) {\\n\\t\\tvisited.add(node);\\n\\t\\tnode = parent.get(node);\\n\\t\\tcount += 2;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1279601,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> paths = new ArrayList<>();\\n        for(int i=0;i<n;i++) paths.add(new ArrayList<>());\\n        for(int[] e : edges){\\n            paths.get(e[0]).add(e[1]);\\n            paths.get(e[1]).add(e[0]);\\n        }\\n        return dfs(paths,0,hasApple,new boolean[n+1]);\\n    }\\n    \\n    private int dfs(List<List<Integer>> paths,int curr,List<Boolean> hasApple,boolean[] visited){\\n        visited[curr]=true;\\n        int total = 0;\\n        for(int cn : paths.get(curr)){\\n            if(visited[cn]) continue;\\n            total += dfs(paths,cn,hasApple,visited);\\n        }\\n        if((total>0 || hasApple.get(curr)) && curr!=0) total+=2;\\n        return total;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> paths = new ArrayList<>();\\n        for(int i=0;i<n;i++) paths.add(new ArrayList<>());\\n        for(int[] e : edges){\\n            paths.get(e[0]).add(e[1]);\\n            paths.get(e[1]).add(e[0]);\\n        }\\n        return dfs(paths,0,hasApple,new boolean[n+1]);\\n    }\\n    \\n    private int dfs(List<List<Integer>> paths,int curr,List<Boolean> hasApple,boolean[] visited){\\n        visited[curr]=true;\\n        int total = 0;\\n        for(int cn : paths.get(curr)){\\n            if(visited[cn]) continue;\\n            total += dfs(paths,cn,hasApple,visited);\\n        }\\n        if((total>0 || hasApple.get(curr)) && curr!=0) total+=2;\\n        return total;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265227,
                "title": "c-short-and-simple-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>adj[100005];\\n    int dfs(int node,vector<bool>& a,vector<int>&vis){\\n         vis[node]=1;\\n         int  count=0;\\n         for(auto x:adj[node]){\\n            if(!vis[x]){\\n             count+=dfs(x,a,vis);\\n            }\\n                    \\n            }\\n        if(count==0 && a[node]==false)\\n            return count;\\n           return ++count;\\n    }\\n    int minTime(int n, vector<vector<int>>& e, vector<bool>& a) {\\n        \\n        \\n         vector<int>vis(n,false);\\n        for(int i=0;i<e.size();i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n             adj[e[i][1]].push_back(e[i][0]);\\n        }\\n          int ans=0;\\n          ans=dfs(0,a,vis);\\n            if(ans==0)\\n            return 0;\\n            return 2*(ans-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>adj[100005];\\n    int dfs(int node,vector<bool>& a,vector<int>&vis){\\n         vis[node]=1;\\n         int  count=0;\\n         for(auto x:adj[node]){\\n            if(!vis[x]){\\n             count+=dfs(x,a,vis);\\n            }\\n                    \\n            }\\n        if(count==0 && a[node]==false)\\n            return count;\\n           return ++count;\\n    }\\n    int minTime(int n, vector<vector<int>>& e, vector<bool>& a) {\\n        \\n        \\n         vector<int>vis(n,false);\\n        for(int i=0;i<e.size();i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n             adj[e[i][1]].push_back(e[i][0]);\\n        }\\n          int ans=0;\\n          ans=dfs(0,a,vis);\\n            if(ans==0)\\n            return 0;\\n            return 2*(ans-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038771,
                "title": "java-postorder-solution-o-n",
                "content": "\\n    static int time = 0;\\n    \\n    public static int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n\\n\\t\\ttime = 0;\\n\\t\\tList<Integer>[] graph = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tgraph[i] = new ArrayList<Integer>();\\n\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tgraph[edge[0]].add(edge[1]);\\n\\t\\t\\tgraph[edge[1]].add(edge[0]);\\n\\t\\t}\\n\\n\\t\\tboolean[] visited = new boolean[n];\\n\\t\\tminTime(n, 0, graph, hasApple, visited);\\n\\t\\treturn (time == 0) ? 0 : time - 1;\\n\\t}\\n\\n\\tpublic static boolean minTime(int n, int src, List<Integer>[] graph, List<Boolean> hasApple, boolean[] visited) {\\n\\n\\t\\tvisited[src] = true;\\n\\t\\tList<Integer> nbrs = graph[src];\\n\\t\\tint curr = time;\\n\\t\\tboolean flag1 = false;\\n\\t\\tboolean flag2 = false;\\n\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\tif (!visited[nbr]) {\\n\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\tflag1 = minTime(n, nbr, graph, hasApple, visited);\\n\\t\\t\\t\\tif (!flag1)\\n\\t\\t\\t\\t\\ttime = curr;\\n\\t\\t\\t\\telse if (flag1) {\\n\\t\\t\\t\\t\\tflag2 = true;\\n\\t\\t\\t\\t\\tcurr = time;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tboolean res = (hasApple.get(src) || flag2);\\n\\t\\ttime++;\\n\\t\\treturn res;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    static int time = 0;\\n    \\n    public static int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n\\n\\t\\ttime = 0;\\n\\t\\tList<Integer>[] graph = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tgraph[i] = new ArrayList<Integer>();\\n\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tgraph[edge[0]].add(edge[1]);\\n\\t\\t\\tgraph[edge[1]].add(edge[0]);\\n\\t\\t}\\n\\n\\t\\tboolean[] visited = new boolean[n];\\n\\t\\tminTime(n, 0, graph, hasApple, visited);\\n\\t\\treturn (time == 0) ? 0 : time - 1;\\n\\t}\\n\\n\\tpublic static boolean minTime(int n, int src, List<Integer>[] graph, List<Boolean> hasApple, boolean[] visited) {\\n\\n\\t\\tvisited[src] = true;\\n\\t\\tList<Integer> nbrs = graph[src];\\n\\t\\tint curr = time;\\n\\t\\tboolean flag1 = false;\\n\\t\\tboolean flag2 = false;\\n\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\tif (!visited[nbr]) {\\n\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\tflag1 = minTime(n, nbr, graph, hasApple, visited);\\n\\t\\t\\t\\tif (!flag1)\\n\\t\\t\\t\\t\\ttime = curr;\\n\\t\\t\\t\\telse if (flag1) {\\n\\t\\t\\t\\t\\tflag2 = true;\\n\\t\\t\\t\\t\\tcurr = time;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tboolean res = (hasApple.get(src) || flag2);\\n\\t\\ttime++;\\n\\t\\treturn res;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 671178,
                "title": "java-o-n-solution-not-dfs",
                "content": "```\\n    // just flag node to hasApple if sub node has apple\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int p[] = new int[n];\\n        Arrays.fill(p, -1);\\n        p[0] = 0;\\n        for (int[] edge : edges) {\\n            //direct\\n            if (p[edge[1]] == -1) {\\n                p[edge[1]] = edge[0];\\n            } else {\\n                p[edge[0]] = edge[1];\\n            }\\n        }\\n        boolean seen[] = new boolean[n];\\n        seen[0] = true;\\n        int cnt = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (hasApple.get(i)) {\\n                for (int j = i; !seen[j]; j = p[j]) {\\n                    seen[j] = true;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt * 2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // just flag node to hasApple if sub node has apple\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int p[] = new int[n];\\n        Arrays.fill(p, -1);\\n        p[0] = 0;\\n        for (int[] edge : edges) {\\n            //direct\\n            if (p[edge[1]] == -1) {\\n                p[edge[1]] = edge[0];\\n            } else {\\n                p[edge[0]] = edge[1];\\n            }\\n        }\\n        boolean seen[] = new boolean[n];\\n        seen[0] = true;\\n        int cnt = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (hasApple.get(i)) {\\n                for (int j = i; !seen[j]; j = p[j]) {\\n                    seen[j] = true;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt * 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624126,
                "title": "c-bfs-simple-solution-with-explanation",
                "content": "1. Calculate distances of all nodes w.r.t. to root i.e. 0. (Using simple BFS). Also store parent for each node.\\n2. Notice distance between any two nodes x, y is abs(dist[x]-dist[y]).\\n3. Now start traversing the list of nodes where apple is. Preferably backwards.\\n4. When you see a node with apple you travel towards root including each edge twice untill you find some already visited node or reach root obviously after which you can\\'t go any further.\\n5. Why till a visited node? Because if it is already visited it implies that path from that node to root is already included and since we want shortest time we need not visit it again.\\n\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& has) {\\n        vector<int> v[n],dist(n,1e9),vis(n,0),par(n,1e9);\\n        for(auto x:edges){\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n            par[x[1]]=x[0];\\n        }\\n        queue<int> q;\\n        q.push(0);dist[0]=0;\\n        \\n        while(!q.empty()){\\n            int cur = q.front();\\n            q.pop();\\n            for(int x:v[cur]){\\n                if(dist[x]==1e9){\\n                    dist[x]=dist[cur]+1;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(has[i]==true and vis[i]==0){\\n                int q = i;\\n                while(par[q]!=1e9 and vis[q]==0){\\n                    vis[q]=1;\\n                    q = par[q];\\n                }\\n                vis[i]=1;\\n                cnt+=(2*(abs(dist[i]-dist[q])));\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& has) {\\n        vector<int> v[n],dist(n,1e9),vis(n,0),par(n,1e9);\\n        for(auto x:edges){\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n            par[x[1]]=x[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 624051,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinTime(int n, int[][] edges, IList<bool> hasApple)\\n    {\\n        var graph = new Dictionary<int, HashSet<int>>();\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new HashSet<int>();\\n        foreach(var edge in edges)\\n        {\\n            int u = edge[0], v = edge[1];\\n            graph[u].Add(v);\\n            graph[v].Add(u);\\n        }\\n        \\n        return DFS(graph, 0, hasApple, new bool[n])[1];\\n    }\\n    \\n    private int[] DFS(Dictionary<int, HashSet<int>> graph, int current, IList<bool> hasApple, bool[] visited)\\n    {\\n        int[] result = new int[2];\\n        if(hasApple[current]) result[0] = 1;\\n        visited[current] = true;\\n        foreach(var next in graph[current])\\n        {\\n            if(!visited[next])\\n            {\\n                var nextResult = DFS(graph, next, hasApple, visited);\\n                if(nextResult[0] == 1)\\n                {\\n                    result[0] = 1;\\n                    result[1] += nextResult[1] + 2;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinTime(int n, int[][] edges, IList<bool> hasApple)\\n    {\\n        var graph = new Dictionary<int, HashSet<int>>();\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new HashSet<int>();\\n        foreach(var edge in edges)\\n        {\\n            int u = edge[0], v = edge[1];\\n            graph[u].Add(v);\\n            graph[v].Add(u);\\n        }\\n        \\n        return DFS(graph, 0, hasApple, new bool[n])[1];\\n    }\\n    \\n    private int[] DFS(Dictionary<int, HashSet<int>> graph, int current, IList<bool> hasApple, bool[] visited)\\n    {\\n        int[] result = new int[2];\\n        if(hasApple[current]) result[0] = 1;\\n        visited[current] = true;\\n        foreach(var next in graph[current])\\n        {\\n            if(!visited[next])\\n            {\\n                var nextResult = DFS(graph, next, hasApple, visited);\\n                if(nextResult[0] == 1)\\n                {\\n                    result[0] = 1;\\n                    result[1] += nextResult[1] + 2;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623984,
                "title": "java-bubble-up-the-value-of-nodes-o-nlogn",
                "content": "**Understand the problem**\\n1. Check if the destination node has an apple\\n2. If it has an apple add (+2) to get to the node. Save this value in the map as from to bubble it up.\\n3. If there is any node connected to the bubbled up values you can add that value to it\\n4. Eventually the value will be bubbled up to the root\\n\\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n        // Sort in descending order to bubble up the number on the path\\n        Arrays.sort(edges, new Comparator<int []>() {\\n           public int compare(int e1[], int e2[]) {\\n               return e2[0] - e1[0];\\n           }\\n        });\\n\\n        Map<Integer, Integer> timeAtNode = new HashMap<>();\\n        for (int edge[]:edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int time = 0;\\n            // If this node has an apple or this node has some value collected from its children path\\n            if (hasApple.get(to) || timeAtNode.containsKey(to) && timeAtNode.get(to) > 0) {\\n                time = time + 2;\\n            }\\n            // bubble up the value where there is an edge connecting to me\\n            if ( timeAtNode.containsKey(to) && timeAtNode.get(to) > 0) {\\n                time = time + timeAtNode.get(to);\\n            }\\n            // Add this value to bubble it up\\n            timeAtNode.put(from, timeAtNode.getOrDefault(from, 0) + time);\\n        }\\n        return timeAtNode.get(0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        \\n        // Sort in descending order to bubble up the number on the path\\n        Arrays.sort(edges, new Comparator<int []>() {\\n           public int compare(int e1[], int e2[]) {\\n               return e2[0] - e1[0];\\n           }\\n        });\\n\\n        Map<Integer, Integer> timeAtNode = new HashMap<>();\\n        for (int edge[]:edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int time = 0;\\n            // If this node has an apple or this node has some value collected from its children path\\n            if (hasApple.get(to) || timeAtNode.containsKey(to) && timeAtNode.get(to) > 0) {\\n                time = time + 2;\\n            }\\n            // bubble up the value where there is an edge connecting to me\\n            if ( timeAtNode.containsKey(to) && timeAtNode.get(to) > 0) {\\n                time = time + timeAtNode.get(to);\\n            }\\n            // Add this value to bubble it up\\n            timeAtNode.put(from, timeAtNode.getOrDefault(from, 0) + time);\\n        }\\n        return timeAtNode.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623739,
                "title": "c-dp-on-tree",
                "content": "Given an undirected tree, the time to walk over an edge is 1s. There are apples on the tree nodes. What is the least time to collect all apples on the tree starting from node 0?\\n\\n# Explanation\\n\\nThis is a simple DP problem. Let `child[i]` denote the list of children of node `i`, `subHasApple[i]` denote whether there is apple in the subtree of node `i`. Then the time needed to pick all the apples in the subtree of node `i` is: \\n\\n```\\ntime[i] = sum(2 + time[j]) for j in child[i] and subHasApple[j] is True\\n```\\n\\nThe extra `2` is the time to walk to and back from the subtree.\\n\\n# Solution\\n\\n```cpp\\nclass Solution {\\n    vector<vector<int>> G;\\n    vector<int> fa;\\n    vector<bool> hasApple;\\n    \\n    // returns time\\n    int dfs(int u, bool& hasApple1) {\\n        int totTime = 0;\\n        hasApple1 = false;\\n        for (int v: G[u]) {\\n            if (v == fa[u]) continue;\\n            fa[v] = u;\\n            bool hasApple2 = false;\\n            int time = dfs(v, hasApple2);\\n            if (hasApple2) {\\n                hasApple1 = true;\\n                totTime += time + 2;\\n            }\\n        }\\n        if (hasApple[u]) hasApple1 = true;\\n        return totTime;\\n    }\\n    \\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        G = vector<vector<int>>(n, vector<int>());\\n        fa = vector<int>(n, -1);\\n        this->hasApple = hasApple;\\n        \\n        for (int i = 0; i < edges.size(); i++) {\\n            G[edges[i][0]].push_back(edges[i][1]);\\n            G[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        fa[0] = -1;\\n        bool subtreeHasApple = false;\\n        return dfs(0, subtreeHasApple);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\ntime[i] = sum(2 + time[j]) for j in child[i] and subHasApple[j] is True\\n```\n```cpp\\nclass Solution {\\n    vector<vector<int>> G;\\n    vector<int> fa;\\n    vector<bool> hasApple;\\n    \\n    // returns time\\n    int dfs(int u, bool& hasApple1) {\\n        int totTime = 0;\\n        hasApple1 = false;\\n        for (int v: G[u]) {\\n            if (v == fa[u]) continue;\\n            fa[v] = u;\\n            bool hasApple2 = false;\\n            int time = dfs(v, hasApple2);\\n            if (hasApple2) {\\n                hasApple1 = true;\\n                totTime += time + 2;\\n            }\\n        }\\n        if (hasApple[u]) hasApple1 = true;\\n        return totTime;\\n    }\\n    \\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        G = vector<vector<int>>(n, vector<int>());\\n        fa = vector<int>(n, -1);\\n        this->hasApple = hasApple;\\n        \\n        for (int i = 0; i < edges.size(); i++) {\\n            G[edges[i][0]].push_back(edges[i][1]);\\n            G[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        fa[0] = -1;\\n        bool subtreeHasApple = false;\\n        return dfs(0, subtreeHasApple);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037179,
                "title": "java-dfs-map-list-commented-explanation",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    // globally declaring the adjacency map\\n    private Map<Integer, List<Integer>> adj;\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        // if there is only 1 node, there will be no edges\\n        // hence no travelling to collect apples and no consuming time\\n        if (n == 1) {\\n            return 0;\\n        }\\n\\n        adj = new HashMap<>();  // initialising the adjacecny map\\n        // populate the adjacency map\\n        for (int[] e : edges) {\\n            if (!adj.containsKey(e[0])) {\\n                adj.put(e[0], new ArrayList<>());\\n            }\\n            if (!adj.containsKey(e[1])) {\\n                adj.put(e[1], new ArrayList<>());\\n            }\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n\\n        // call the dfs\\n        return dfs(0, -1, hasApple);\\n    }\\n\\n    public int dfs(int curr, int parent, List<Boolean> hasApple) {\\n        // we basically call the dfs for every child connected to our current node\\n        // then a particular child becomes the current node, and the previous current node becomes the parent for that child\\n        // this goes on and from depth we keep getting the consumed time and come back to top\\n\\n        int timeAtCurrentNode = 0;   // variable to store the time consumed below our current node\\n        // check for every child that are connected to the current node\\n        for (int child : adj.get(curr)) {\\n            if (child == parent) {  // we don\\'t want to go back to the parent node, we want to go down below\\n                continue;\\n            }\\n            // call the dfs for the child, current node becomes the new parent\\n            // it will fetch us the time if there is an apple down below our child\\n            int timeFromChild = dfs(child, curr, hasApple);\\n            // timeFromChild > 0 means we found an apple below the child\\n            // hasApple if true at current child means apple is present at current child as well\\n            if (timeFromChild > 0 || hasApple.get(child)) {\\n                // so we add 2 (1 (going down) + 1 (coming back)) and timeFromChild (time taken to collect apples below child)\\n                // to the total time of our current node\\n                timeAtCurrentNode += (2 + timeFromChild);\\n            }\\n        }\\n\\n        // return the time taken\\n        return timeAtCurrentNode;\\n    }\\n}\\n\\n// TC: O(v + e), SC: O(v + e)\\n```\\n**NOTE:**\\n*We don\\'t necessarily need to have a visited array, because its a tree because instead we have put a check so that we don\\'t visit the parent node again while calling dfs for the child nodes of a particular node.*\\n\\n---\\n##### Using an adjacency List array instead of a map (Faster):\\n\\n``` java []\\nclass Solution {\\n    // globally declaring the adjacency list\\n    private List<Integer>[] adj;\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        if (n == 1) {   // not necessary when using a list\\n            return 0;\\n        }\\n\\n        adj = new List[n];  // initialising the adjacency list\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        // populating the adjacency list\\n        for (int[] e : edges) {\\n            adj[e[0]].add(e[1]);\\n            adj[e[1]].add(e[0]);\\n        }\\n\\n        return dfs(0, -1, hasApple);\\n    }\\n\\n    public int dfs(int currNode, int parent, List<Boolean> hasApple) {\\n        int timeAtCurrentNode = 0;\\n        for (int child : adj[currNode]) {\\n            if (child == parent) {\\n                continue;\\n            }\\n\\n            int timeFromChild = dfs(child, currNode, hasApple);\\n            if (timeFromChild > 0 || hasApple.get(child)) {\\n                timeAtCurrentNode += (2 + timeFromChild);\\n            }\\n        }\\n\\n        return timeAtCurrentNode;\\n    }\\n}\\n\\n// TC: O(v + e), SC: O(v + e)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    // globally declaring the adjacency map\\n    private Map<Integer, List<Integer>> adj;\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        // if there is only 1 node, there will be no edges\\n        // hence no travelling to collect apples and no consuming time\\n        if (n == 1) {\\n            return 0;\\n        }\\n\\n        adj = new HashMap<>();  // initialising the adjacecny map\\n        // populate the adjacency map\\n        for (int[] e : edges) {\\n            if (!adj.containsKey(e[0])) {\\n                adj.put(e[0], new ArrayList<>());\\n            }\\n            if (!adj.containsKey(e[1])) {\\n                adj.put(e[1], new ArrayList<>());\\n            }\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n\\n        // call the dfs\\n        return dfs(0, -1, hasApple);\\n    }\\n\\n    public int dfs(int curr, int parent, List<Boolean> hasApple) {\\n        // we basically call the dfs for every child connected to our current node\\n        // then a particular child becomes the current node, and the previous current node becomes the parent for that child\\n        // this goes on and from depth we keep getting the consumed time and come back to top\\n\\n        int timeAtCurrentNode = 0;   // variable to store the time consumed below our current node\\n        // check for every child that are connected to the current node\\n        for (int child : adj.get(curr)) {\\n            if (child == parent) {  // we don\\'t want to go back to the parent node, we want to go down below\\n                continue;\\n            }\\n            // call the dfs for the child, current node becomes the new parent\\n            // it will fetch us the time if there is an apple down below our child\\n            int timeFromChild = dfs(child, curr, hasApple);\\n            // timeFromChild > 0 means we found an apple below the child\\n            // hasApple if true at current child means apple is present at current child as well\\n            if (timeFromChild > 0 || hasApple.get(child)) {\\n                // so we add 2 (1 (going down) + 1 (coming back)) and timeFromChild (time taken to collect apples below child)\\n                // to the total time of our current node\\n                timeAtCurrentNode += (2 + timeFromChild);\\n            }\\n        }\\n\\n        // return the time taken\\n        return timeAtCurrentNode;\\n    }\\n}\\n\\n// TC: O(v + e), SC: O(v + e)\\n```\n``` java []\\nclass Solution {\\n    // globally declaring the adjacency list\\n    private List<Integer>[] adj;\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        if (n == 1) {   // not necessary when using a list\\n            return 0;\\n        }\\n\\n        adj = new List[n];  // initialising the adjacency list\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        // populating the adjacency list\\n        for (int[] e : edges) {\\n            adj[e[0]].add(e[1]);\\n            adj[e[1]].add(e[0]);\\n        }\\n\\n        return dfs(0, -1, hasApple);\\n    }\\n\\n    public int dfs(int currNode, int parent, List<Boolean> hasApple) {\\n        int timeAtCurrentNode = 0;\\n        for (int child : adj[currNode]) {\\n            if (child == parent) {\\n                continue;\\n            }\\n\\n            int timeFromChild = dfs(child, currNode, hasApple);\\n            if (timeFromChild > 0 || hasApple.get(child)) {\\n                timeAtCurrentNode += (2 + timeFromChild);\\n            }\\n        }\\n\\n        return timeAtCurrentNode;\\n    }\\n}\\n\\n// TC: O(v + e), SC: O(v + e)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037134,
                "title": "java-dfs-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Function to find the minimum time to collect all apples\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        // Create an adjacency list to represent the tree\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        // populate the adjacency list\\n        for(int [] edge : edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n\\n        }\\n        // call to helper function to find the minimum time\\n        return minTimeToCollectApples(0, adj, hasApple, 0);\\n    }\\n    // Helper function\\n    int minTimeToCollectApples(int index, List<List<Integer>> adj, List<Boolean> hasApple, int parent){\\n        // variable to keep track of total time\\n        int total = 0;\\n        // for each neighbor of current node\\n        for(int nbr : adj.get(index)){\\n            // if the neighbor is the parent node, then we skip\\n            if (nbr == parent)\\n             continue;\\n            // we recursively call the helper function for each neighbor\\n            total += minTimeToCollectApples(nbr, adj, hasApple, index);\\n        }\\n        // If current node is not the root (0th) node, and it has an apple or any of its descendant has\\n        //  then we need to add 2 time for moving to and from it\\n        if( index != 0 && (hasApple.get(index) || total > 0))\\n          total += 2;\\n        return total;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Function to find the minimum time to collect all apples\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        // Create an adjacency list to represent the tree\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        // populate the adjacency list\\n        for(int [] edge : edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n\\n        }\\n        // call to helper function to find the minimum time\\n        return minTimeToCollectApples(0, adj, hasApple, 0);\\n    }\\n    // Helper function\\n    int minTimeToCollectApples(int index, List<List<Integer>> adj, List<Boolean> hasApple, int parent){\\n        // variable to keep track of total time\\n        int total = 0;\\n        // for each neighbor of current node\\n        for(int nbr : adj.get(index)){\\n            // if the neighbor is the parent node, then we skip\\n            if (nbr == parent)\\n             continue;\\n            // we recursively call the helper function for each neighbor\\n            total += minTimeToCollectApples(nbr, adj, hasApple, index);\\n        }\\n        // If current node is not the root (0th) node, and it has an apple or any of its descendant has\\n        //  then we need to add 2 time for moving to and from it\\n        if( index != 0 && (hasApple.get(index) || total > 0))\\n          total += 2;\\n        return total;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036920,
                "title": "beats-100-time-memory-o-n-in-c-rust-go",
                "content": "# Intuition\\nAs we have $$n$$ nodes, $$n - 1$$ edges, and from each node exists path to node `0` - it means each node has only one parent, so we could store only index of parent to save space.\\n\\n# Approach\\nFrom each node having apple traverse path to node `0`, marking used edges (to visit each node only once) and counting them.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ or actually $$O(3*n)$$ as we copy all edges ($$n - 1$$), then traverse `hasApple` array ($$n$$), and finally scan `parentEdge` till already visited node is reached ($$n$$)\\n\\n- Space complexity:\\n$$O(n)$$ as we store edges\\n\\n# Code in C++\\n```\\nclass Solution {\\npublic:\\n    int minTime(const int n, const std::vector<std::vector<int>> & edges, const std::vector<bool> & hasApple) {\\n        std::vector<int> parentEdge(n, -1);\\n        for (const auto & edge : edges) {\\n            if (parentEdge[edge[1]] == -1) {\\n                parentEdge[edge[1]] = edge[0];\\n            } else {\\n                parentEdge[edge[0]] = edge[1];\\n            }\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!hasApple[i]) {\\n                continue;\\n            }\\n\\n            for (int node = i; parentEdge[node] != -1; ++result) {\\n                const auto parentNode = parentEdge[node];\\n                parentEdge[node] = -1;\\n                node = parentNode;\\n            }\\n        }\\n        return result * 2;\\n    }\\n};\\n```\\n\\n# Code in Rust\\n```\\nimpl Solution {\\n    pub fn min_time(n: i32, edges: Vec<Vec<i32>>, has_apple: Vec<bool>) -> i32 {\\n        let mut parent_edge = vec![-1; n as usize];\\n        for edge in edges.into_iter() {\\n            if parent_edge[edge[1usize] as usize] == -1 {\\n                parent_edge[edge[1usize] as usize] = edge[0usize];\\n            } else {\\n                parent_edge[edge[0usize] as usize] = edge[1usize];\\n            }\\n        }\\n\\n        let mut result = 0;\\n        for i in 0..(n as usize) {\\n            if !has_apple[i] {\\n                continue;\\n            }\\n\\n            let mut node = i as i32;\\n            while parent_edge[node as usize] != -1 {\\n                let parent_node = parent_edge[node as usize];\\n                parent_edge[node as usize] = -1;\\n                node = parent_node;\\n                result += 1;\\n            }\\n        }\\n        result * 2\\n    }\\n}\\n```\\n\\n# Code in Go\\n```\\nfunc minTime(n int, edges [][]int, hasApple []bool) int {\\n    parentEdge := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        parentEdge[i] = -1\\n    }\\n    for i := 0; i < n - 1; i++ {\\n        if parentEdge[edges[i][1]] == -1 {\\n            parentEdge[edges[i][1]] = edges[i][0]\\n        } else {\\n            parentEdge[edges[i][0]] = edges[i][1]\\n        }\\n    }\\n\\n    result := 0\\n    for i := 0; i < n; i++ {\\n        if !hasApple[i] {\\n            continue\\n        }\\n\\n        for node := i; parentEdge[node] != -1; result++ {\\n            parentNode := parentEdge[node]\\n            parentEdge[node] = -1\\n            node = parentNode\\n        }\\n    }\\n    return result * 2\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Rust",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(const int n, const std::vector<std::vector<int>> & edges, const std::vector<bool> & hasApple) {\\n        std::vector<int> parentEdge(n, -1);\\n        for (const auto & edge : edges) {\\n            if (parentEdge[edge[1]] == -1) {\\n                parentEdge[edge[1]] = edge[0];\\n            } else {\\n                parentEdge[edge[0]] = edge[1];\\n            }\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!hasApple[i]) {\\n                continue;\\n            }\\n\\n            for (int node = i; parentEdge[node] != -1; ++result) {\\n                const auto parentNode = parentEdge[node];\\n                parentEdge[node] = -1;\\n                node = parentNode;\\n            }\\n        }\\n        return result * 2;\\n    }\\n};\\n```\n```\\nimpl Solution {\\n    pub fn min_time(n: i32, edges: Vec<Vec<i32>>, has_apple: Vec<bool>) -> i32 {\\n        let mut parent_edge = vec![-1; n as usize];\\n        for edge in edges.into_iter() {\\n            if parent_edge[edge[1usize] as usize] == -1 {\\n                parent_edge[edge[1usize] as usize] = edge[0usize];\\n            } else {\\n                parent_edge[edge[0usize] as usize] = edge[1usize];\\n            }\\n        }\\n\\n        let mut result = 0;\\n        for i in 0..(n as usize) {\\n            if !has_apple[i] {\\n                continue;\\n            }\\n\\n            let mut node = i as i32;\\n            while parent_edge[node as usize] != -1 {\\n                let parent_node = parent_edge[node as usize];\\n                parent_edge[node as usize] = -1;\\n                node = parent_node;\\n                result += 1;\\n            }\\n        }\\n        result * 2\\n    }\\n}\\n```\n```\\nfunc minTime(n int, edges [][]int, hasApple []bool) int {\\n    parentEdge := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        parentEdge[i] = -1\\n    }\\n    for i := 0; i < n - 1; i++ {\\n        if parentEdge[edges[i][1]] == -1 {\\n            parentEdge[edges[i][1]] = edges[i][0]\\n        } else {\\n            parentEdge[edges[i][0]] = edges[i][1]\\n        }\\n    }\\n\\n    result := 0\\n    for i := 0; i < n; i++ {\\n        if !hasApple[i] {\\n            continue\\n        }\\n\\n        for node := i; parentEdge[node] != -1; result++ {\\n            parentNode := parentEdge[node]\\n            parentEdge[node] = -1\\n            node = parentNode\\n        }\\n    }\\n    return result * 2\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036204,
                "title": "very-easy-python-solution-95-dfs-with-explanation",
                "content": "# Intuition\\nCount the number of parents that has children or grandchildren who has apples or they themselves has apples. \\nFor example, if 6 node has apples or has child / grandchild node that has apples answer is 6 * 2 - 2 = 10, we dont have to count the src node as it has travel cost of zero. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we have to find out if any children or grand children has apples, which requires to traverse the child node before the parent node, DFS is the best, easy and intuitive approach. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n^2)$$, the space to store the adjacency matrix. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj_mat: Dict[int, List[int]] = {}\\n        for i in range(n):\\n            adj_mat[i] = list()\\n        \\n        for u, v in edges:\\n            adj_mat[u].append(v)\\n            adj_mat[v].append(u)\\n\\n        visited = [False] * n\\n\\n        cost = [0]\\n        def dfs(src):\\n            have_child = False\\n            visited[src] = True\\n            for c in adj_mat[src]:\\n                if not visited[c]:\\n                    have_child = dfs(c) or have_child\\n            if have_child or hasApple[src]:\\n                cost[0] += 2\\n            return have_child or hasApple[src]\\n        dfs(0)\\n        return 0 if cost[0] == 0 else cost[0] - 2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj_mat: Dict[int, List[int]] = {}\\n        for i in range(n):\\n            adj_mat[i] = list()\\n        \\n        for u, v in edges:\\n            adj_mat[u].append(v)\\n            adj_mat[v].append(u)\\n\\n        visited = [False] * n\\n\\n        cost = [0]\\n        def dfs(src):\\n            have_child = False\\n            visited[src] = True\\n            for c in adj_mat[src]:\\n                if not visited[c]:\\n                    have_child = dfs(c) or have_child\\n            if have_child or hasApple[src]:\\n                cost[0] += 2\\n            return have_child or hasApple[src]\\n        dfs(0)\\n        return 0 if cost[0] == 0 else cost[0] - 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035997,
                "title": "c-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(V+E)$$\\n\\n- Space complexity:$$O(V)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<int> adj[], vector<bool> &hasApple) {\\n        int cnt=0;\\n        for(auto it: adj[i]) {\\n            if(it!=j) {\\n                int num=dfs(it, i, adj, hasApple);\\n                if(hasApple[it]){\\n                    num+=2; cnt+=num;\\n                    hasApple[i]=true;\\n                }\\n            } \\n        }\\n        return cnt;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return dfs(0, 0, adj, hasApple);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<int> adj[], vector<bool> &hasApple) {\\n        int cnt=0;\\n        for(auto it: adj[i]) {\\n            if(it!=j) {\\n                int num=dfs(it, i, adj, hasApple);\\n                if(hasApple[it]){\\n                    num+=2; cnt+=num;\\n                    hasApple[i]=true;\\n                }\\n            } \\n        }\\n        return cnt;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return dfs(0, 0, adj, hasApple);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035660,
                "title": "easy-to-understand-postorder-dfs-traversal-with-testcases",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/graph/MinTimeCollectApplesTree.kt",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3035476,
                "title": "hindi-version-c-easy-explanation",
                "content": "I am writing this post in hindi because there are almost no post in hindi.\\n\\n# Approach\\nSimple bas har child ke paas jao and usse ye pucho ki kya uske paas ya uske child ke paas apple hai ya nahi. Ab code read karo usme comments se ache se explain karne ki try kara hai meine.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(V+E) because normal DFS apply kiya hai toh DFS ki time complexity vertices+edges hoti hai\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V) because adjancey list banayi hai V vertices ke liye\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&adj,int curr,int parent,vector<bool>&hasApple)\\n    {\\n        int time = 0;\\n        for(auto child:adj[curr])\\n        {\\n            if(child==parent)\\n            {\\n                continue;\\n            }\\n            int time_taken_by_child_to_collect_apples = dfs(adj,child,curr,hasApple);\\n            if(time_taken_by_child_to_collect_apples>0 or hasApple[child])\\n            {\\n                time += time_taken_by_child_to_collect_apples + 2;\\n            }\\n        }\\n        return time;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return dfs(adj,0,-1,hasApple);\\n    }\\n};\\n```\\n\\nPost read karne ke liye dhanyvaad and agar post se kuch help mili toh please upvote kardena!!!",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&adj,int curr,int parent,vector<bool>&hasApple)\\n    {\\n        int time = 0;\\n        for(auto child:adj[curr])\\n        {\\n            if(child==parent)\\n            {\\n                continue;\\n            }\\n            int time_taken_by_child_to_collect_apples = dfs(adj,child,curr,hasApple);\\n            if(time_taken_by_child_to_collect_apples>0 or hasApple[child])\\n            {\\n                time += time_taken_by_child_to_collect_apples + 2;\\n            }\\n        }\\n        return time;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return dfs(adj,0,-1,hasApple);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035129,
                "title": "dfs-easy-readable-c",
                "content": "```  \\nvoid dfs(int x,int par,vector<vector<int>>&adj,vector<bool>&has)\\n    {\\n        for(int k:adj[x])\\n        {\\n            if(k==par){continue;}\\n            dfs(k,x,adj,has);\\n            has[x] = (has[x]|has[k]);\\n        }\\n    }\\n    \\n    int solve(int x,int par,vector<vector<int>>&adj,vector<bool>&has)\\n    {\\n        if(!has[x]){return 0;}\\n        int ans=0;\\n        for(int k:adj[x])\\n        {\\n            if(k==par){continue;}\\n            if(has[k])\\n            {\\n                ans+= solve(k,x,adj,has);\\n            }\\n        }\\n        if(x==0)\\n        {\\n            return ans;\\n        }\\n        return ans+2;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edg, vector<bool>&has) \\n    {\\n        vector<vector<int>>adj(n);\\n        for(vector<int>j:edg)\\n        {\\n            adj[j[0]].push_back(j[1]);\\n            adj[j[1]].push_back(j[0]);\\n        }\\n         dfs(0,0,adj,has);\\n          int ans=solve(0,0,adj,has);\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```  \\nvoid dfs(int x,int par,vector<vector<int>>&adj,vector<bool>&has)\\n    {\\n        for(int k:adj[x])\\n        {\\n            if(k==par){continue;}\\n            dfs(k,x,adj,has);\\n            has[x] = (has[x]|has[k]);\\n        }\\n    }\\n    \\n    int solve(int x,int par,vector<vector<int>>&adj,vector<bool>&has)\\n    {\\n        if(!has[x]){return 0;}\\n        int ans=0;\\n        for(int k:adj[x])\\n        {\\n            if(k==par){continue;}\\n            if(has[k])\\n            {\\n                ans+= solve(k,x,adj,has);\\n            }\\n        }\\n        if(x==0)\\n        {\\n            return ans;\\n        }\\n        return ans+2;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edg, vector<bool>&has) \\n    {\\n        vector<vector<int>>adj(n);\\n        for(vector<int>j:edg)\\n        {\\n            adj[j[0]].push_back(j[1]);\\n            adj[j[1]].push_back(j[0]);\\n        }\\n         dfs(0,0,adj,has);\\n          int ans=solve(0,0,adj,has);\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3035083,
                "title": "java-beats-95-java-submisioms-with-proper-explanation-tc-sc-modularised-code",
                "content": "### Note:- Do give it a upvote,if my explanation helps as it will be a source of motivation for me!!\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKey observations here are:-\\n1. Time taken to collect a apple is 2 (1 for coming, 2 for going back)\\n2. Since we need to collect all apples, so its obvious we would traverse the graph/tree.\\n3. Let\\'s say A has 2 childs b & c. So it doesnt matter even if any one of nodes has an apple, it will still consume time.\\n4. We dont involve the staring node (0 in this case) for calculating the time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are given adjacent matrix, first we need to build a adjacent list for us to perform DFS traversal.\\n\\nWe adopt a DFS startegy, where we visit every node in depth wise direction. When a node has an apple and isnt a root node, we increment the count by 2, else we just return the count.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - Where N is the node of Nodes\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nRecursive Stack space O(N) + O(N) [Where N is the node of Nodes]\\n# Code\\n```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int l=0;\\n        for(int i=0;i<hasApple.size();i++){\\n            if(hasApple.get(i)==false)l++;\\n            else break;\\n        }\\n        if(l==hasApple.size())return 0;\\n        ArrayList<ArrayList<Integer>> adjList = buildAjList(edges);\\n        boolean[] vis = new boolean[n];\\n        return dfs(0,adjList,hasApple,vis);\\n    }\\n\\n    public int dfs(int node,ArrayList<ArrayList<Integer>> adjList,List<Boolean> hasApple,boolean[] vis){\\n        int c=0;\\n        vis[node]=true;\\n        for(Integer it:adjList.get(node)){\\n            if(vis[it]==false){\\n            c+=dfs(it,adjList,hasApple,vis);\\n            }\\n        }\\n        if((c>0||hasApple.get(node))&&node!=0) c+=2;\\n        return c;\\n    }\\n\\n    public ArrayList<ArrayList<Integer>> buildAjList(int[][] edges){\\n        ArrayList<ArrayList<Integer>> adjList = new ArrayList<ArrayList<Integer>>();\\n        for(int i=0;i<=edges.length;i++)\\n            adjList.add(new ArrayList<Integer>());\\n\\n        for(int i=0;i<edges.length;i++){\\n            adjList.get(edges[i][0]).add(edges[i][1]);\\n            adjList.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        return adjList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int l=0;\\n        for(int i=0;i<hasApple.size();i++){\\n            if(hasApple.get(i)==false)l++;\\n            else break;\\n        }\\n        if(l==hasApple.size())return 0;\\n        ArrayList<ArrayList<Integer>> adjList = buildAjList(edges);\\n        boolean[] vis = new boolean[n];\\n        return dfs(0,adjList,hasApple,vis);\\n    }\\n\\n    public int dfs(int node,ArrayList<ArrayList<Integer>> adjList,List<Boolean> hasApple,boolean[] vis){\\n        int c=0;\\n        vis[node]=true;\\n        for(Integer it:adjList.get(node)){\\n            if(vis[it]==false){\\n            c+=dfs(it,adjList,hasApple,vis);\\n            }\\n        }\\n        if((c>0||hasApple.get(node))&&node!=0) c+=2;\\n        return c;\\n    }\\n\\n    public ArrayList<ArrayList<Integer>> buildAjList(int[][] edges){\\n        ArrayList<ArrayList<Integer>> adjList = new ArrayList<ArrayList<Integer>>();\\n        for(int i=0;i<=edges.length;i++)\\n            adjList.add(new ArrayList<Integer>());\\n\\n        for(int i=0;i<edges.length;i++){\\n            adjList.get(edges[i][0]).add(edges[i][1]);\\n            adjList.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        return adjList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034674,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    vector<bool> hasApples;\\n\\n    int dfs(int u, int par) {\\n        int totalTime = 0, childTime = 0;\\n        for(auto v: g[u]) {\\n            if(v == par) continue;\\n            childTime = dfs(v, u);\\n            if(childTime or hasApples[v]) totalTime += childTime + 2;\\n        }\\n        return totalTime;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        hasApples = hasApple;\\n        for(auto x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        int ans = dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    vector<bool> hasApples;\\n\\n    int dfs(int u, int par) {\\n        int totalTime = 0, childTime = 0;\\n        for(auto v: g[u]) {\\n            if(v == par) continue;\\n            childTime = dfs(v, u);\\n            if(childTime or hasApples[v]) totalTime += childTime + 2;\\n        }\\n        return totalTime;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        hasApples = hasApple;\\n        for(auto x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        int ans = dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034369,
                "title": "my-ts-c-solution-but-leetcode-got-error-with-ts-can-someone-help-me-to-take-a-look",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple DFS to reach the apple branch and add by 2 (2 way direction), but Leetcode got error with TS, so I can\\'t run this code, even only return constant. Because of that issue, I changed to C# without change any logic and beat 90% time complexity \\n![WeCom Screenshot_20230111144848.png](https://assets.leetcode.com/users/images/b05620f5-e5ba-417e-88f3-7a1c470e0694_1673423832.62659.png)\\n\\n# Code\\n```C# []\\npublic class Solution {\\n    private int DFS(int curr, Dictionary<int, List<int>> g, IList<bool> hasApple, IList<bool> visited) {\\n        int sum = 0;\\n        visited[curr] = true;\\n        var path = g[curr];\\n        foreach(var item in path) {\\n            if(!visited[item]) {\\n                int n = DFS(item, g, hasApple, visited);\\n                if(n>=0) sum+=n+2;\\n            }\\n        }\\n        if(hasApple[curr] || sum>0)\\n            return sum;\\n        return -1;\\n    }\\n    public int MinTime(int n, int[][] edges, IList<bool> hasApple) {\\n        int ans = 0;\\n        var g = new Dictionary<int, List<int>>();\\n        bool[] visited = Enumerable.Repeat(false, n).ToArray();\\n        foreach(var item in edges) {\\n            if(g.ContainsKey(item[0]))\\n                g[item[0]].Add(item[1]);\\n            else\\n                g.Add(item[0], new List<int>{item[1]});\\n\\n            if(g.ContainsKey(item[1]))\\n                g[item[1]].Add(item[0]);\\n            else\\n                g.Add(item[1], new List<int>{item[0]});\\n        }\\n        ans = DFS(0, g, hasApple, visited);\\n        if(ans == -1)\\n            return 0;\\n        return ans;\\n    }\\n}\\n```\\n```TypeScript []\\nfunction dfs(curr: number, g: number[][], hasApple: boolean[], visited: boolean[]): number {\\n    let sum:number = 0;\\n    visited[curr] = true;\\n    let path:number[] = g[curr];\\n    path.forEach((_, index) => {\\n        if(!visited[path[index]]) {\\n            let n = dfs(path[index], g, hasApple, visited);\\n            if(n>=0) {\\n                sum+=n+2;\\n            }\\n        }\\n    })\\n    if(hasApple[curr] || sum > 0 ) \\n        return sum;\\n    return -1;\\n}\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    let ans:number = 0;\\n    let g: number[][] =[];\\n    let visited: boolean[] = Array(n).fill(false);\\n    edges.forEach((_, index)=>{\\n        let u:number = edges[index][0];\\n        let v:number = edges[index][1];\\n        g[u].push(v);\\n        g[v].push(u);\\n    })\\n    ans = dfs(0, g, hasApple, visited);\\n    if (ans == -1)\\n        return 0;\\n    return ans;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C#",
                    "TypeScript"
                ],
                "code": "```C# []\\npublic class Solution {\\n    private int DFS(int curr, Dictionary<int, List<int>> g, IList<bool> hasApple, IList<bool> visited) {\\n        int sum = 0;\\n        visited[curr] = true;\\n        var path = g[curr];\\n        foreach(var item in path) {\\n            if(!visited[item]) {\\n                int n = DFS(item, g, hasApple, visited);\\n                if(n>=0) sum+=n+2;\\n            }\\n        }\\n        if(hasApple[curr] || sum>0)\\n            return sum;\\n        return -1;\\n    }\\n    public int MinTime(int n, int[][] edges, IList<bool> hasApple) {\\n        int ans = 0;\\n        var g = new Dictionary<int, List<int>>();\\n        bool[] visited = Enumerable.Repeat(false, n).ToArray();\\n        foreach(var item in edges) {\\n            if(g.ContainsKey(item[0]))\\n                g[item[0]].Add(item[1]);\\n            else\\n                g.Add(item[0], new List<int>{item[1]});\\n\\n            if(g.ContainsKey(item[1]))\\n                g[item[1]].Add(item[0]);\\n            else\\n                g.Add(item[1], new List<int>{item[0]});\\n        }\\n        ans = DFS(0, g, hasApple, visited);\\n        if(ans == -1)\\n            return 0;\\n        return ans;\\n    }\\n}\\n```\n```TypeScript []\\nfunction dfs(curr: number, g: number[][], hasApple: boolean[], visited: boolean[]): number {\\n    let sum:number = 0;\\n    visited[curr] = true;\\n    let path:number[] = g[curr];\\n    path.forEach((_, index) => {\\n        if(!visited[path[index]]) {\\n            let n = dfs(path[index], g, hasApple, visited);\\n            if(n>=0) {\\n                sum+=n+2;\\n            }\\n        }\\n    })\\n    if(hasApple[curr] || sum > 0 ) \\n        return sum;\\n    return -1;\\n}\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    let ans:number = 0;\\n    let g: number[][] =[];\\n    let visited: boolean[] = Array(n).fill(false);\\n    edges.forEach((_, index)=>{\\n        let u:number = edges[index][0];\\n        let v:number = edges[index][1];\\n        g[u].push(v);\\n        g[v].push(u);\\n    })\\n    ans = dfs(0, g, hasApple, visited);\\n    if (ans == -1)\\n        return 0;\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033961,
                "title": "c-dfs-20-lines-code-99-runtime-95-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> graph(n);\\n        graph[0].push_back(-1); //vertex 0 has no ancestor \\n        for(auto &p : edges) {\\n            graph[p.front()].push_back(p.back());\\n            graph[p.back()].push_back(p.front());\\n        }\\n        int ans = 0;\\n        for(int i = n-1; i >= 0; i--) //dfs\\n            if(graph[i].size() > 1) {\\n                int count = 0; //count vertex has apple\\n                for(int j = 1; j < graph[i].size(); j++) \\n                    if(hasApple[graph[i][j]]) {\\n                        count++;\\n                        hasApple[i] = true; //vertex has apples in child\\n                    }\\n                ans += 2*count; //time to collect and back for each vertex\\n            }       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> graph(n);\\n        graph[0].push_back(-1); //vertex 0 has no ancestor \\n        for(auto &p : edges) {\\n            graph[p.front()].push_back(p.back());\\n            graph[p.back()].push_back(p.front());\\n        }\\n        int ans = 0;\\n        for(int i = n-1; i >= 0; i--) //dfs\\n            if(graph[i].size() > 1) {\\n                int count = 0; //count vertex has apple\\n                for(int j = 1; j < graph[i].size(); j++) \\n                    if(hasApple[graph[i][j]]) {\\n                        count++;\\n                        hasApple[i] = true; //vertex has apples in child\\n                    }\\n                ans += 2*count; //time to collect and back for each vertex\\n            }       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033951,
                "title": "c-begineer-friendly-easy-understanding-dfs-video-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=xYzbvOJJTbM/\\n# \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>>adjlist;\\n\\n    int dfs(vector<bool>& hasApple,int currentNode,int parent,int dis){\\n\\n        int disFromChildren = 0;\\n        int disFromRoot = 0;\\n        for(auto x:adjlist[currentNode]){\\n            // check only for children if they have apple present or not.\\n            if(x != parent){\\n                disFromRoot = dfs(hasApple,x,currentNode,dis+1);\\n\\n                // if disfromroot != 0 means children have apple .\\n                // so calculate the dis from the \"x\" i.e current node to the children.\\n\\n                if(disFromRoot != 0)\\n                disFromChildren += disFromRoot-dis;\\n            }\\n         }\\n        //  if no children left or not have any children return the total distance for that subtree.\\n        // (i.e disfromChildren + it own distance from root node (dis))\\n\\n            return disFromChildren || hasApple[currentNode] ? disFromChildren + dis:0;\\n\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n\\n        adjlist.resize(n);\\n\\n        for(auto x:edges){\\n            adjlist[x[0]].push_back(x[1]);\\n            adjlist[x[1]].push_back(x[0]);\\n        }\\n        // current node =0 , parent node =-1,distance or level from root.\\n        return dfs(hasApple,0,-1,0)*2;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>>adjlist;\\n\\n    int dfs(vector<bool>& hasApple,int currentNode,int parent,int dis){\\n\\n        int disFromChildren = 0;\\n        int disFromRoot = 0;\\n        for(auto x:adjlist[currentNode]){\\n            // check only for children if they have apple present or not.\\n            if(x != parent){\\n                disFromRoot = dfs(hasApple,x,currentNode,dis+1);\\n\\n                // if disfromroot != 0 means children have apple .\\n                // so calculate the dis from the \"x\" i.e current node to the children.\\n\\n                if(disFromRoot != 0)\\n                disFromChildren += disFromRoot-dis;\\n            }\\n         }\\n        //  if no children left or not have any children return the total distance for that subtree.\\n        // (i.e disfromChildren + it own distance from root node (dis))\\n\\n            return disFromChildren || hasApple[currentNode] ? disFromChildren + dis:0;\\n\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n\\n        adjlist.resize(n);\\n\\n        for(auto x:edges){\\n            adjlist[x[0]].push_back(x[1]);\\n            adjlist[x[1]].push_back(x[0]);\\n        }\\n        // current node =0 , parent node =-1,distance or level from root.\\n        return dfs(hasApple,0,-1,0)*2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033922,
                "title": "java-c-100-solution-using-depth-first-search-minimum-time-to-collect-all-apples-in-a-tree",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    Map<Integer, ArrayList<Integer>>graph = new HashMap<>();\\n    Set<Integer> visited = new HashSet<>();\\n\\n    void genrateGraph(int[][] edges)\\n    {\\n        for(int[] edge : edges)\\n        {\\n            graph.putIfAbsent(edge[0], new ArrayList<>());\\n            graph.putIfAbsent(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n    }\\n\\n    int dfs(int node, int currCost,List<Boolean> hasApple){\\n        if(visited.contains(node))\\n            return 0;\\n        visited.add(node);\\n\\n        int childrenCost = 0;\\n\\n        for(int x : graph.get(node))\\n            childrenCost += dfs(x,2,hasApple);\\n            \\n        if(childrenCost == 0 && !hasApple.get(node))\\n            return 0;\\n        return childrenCost+currCost;\\n    }\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        genrateGraph(edges);\\n        return dfs(0,0,hasApple);\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> graph; \\n    unordered_map<int, bool> visited;\\n\\t\\n    void createGraph(vector<vector<int>>& edges) {\\n        for (auto edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n    }\\n\\n    int dfs(int node, int currCost,vector<bool>& hasApple){\\n        if(visited[node])\\n            return 0;\\n        visited[node] = true;\\n\\n        int childrenCost = 0;\\n        for(auto x: graph[node])\\n            childrenCost += dfs(x,2,hasApple);\\n\\n        if(childrenCost == 0 && !hasApple[node])\\n            return 0;\\n        return childrenCost+currCost;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        createGraph(edges);\\n        return dfs(0,0,hasApple);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, ArrayList<Integer>>graph = new HashMap<>();\\n    Set<Integer> visited = new HashSet<>();\\n\\n    void genrateGraph(int[][] edges)\\n    {\\n        for(int[] edge : edges)\\n        {\\n            graph.putIfAbsent(edge[0], new ArrayList<>());\\n            graph.putIfAbsent(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n    }\\n\\n    int dfs(int node, int currCost,List<Boolean> hasApple){\\n        if(visited.contains(node))\\n            return 0;\\n        visited.add(node);\\n\\n        int childrenCost = 0;\\n\\n        for(int x : graph.get(node))\\n            childrenCost += dfs(x,2,hasApple);\\n            \\n        if(childrenCost == 0 && !hasApple.get(node))\\n            return 0;\\n        return childrenCost+currCost;\\n    }\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        genrateGraph(edges);\\n        return dfs(0,0,hasApple);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> graph; \\n    unordered_map<int, bool> visited;\\n\\t\\n    void createGraph(vector<vector<int>>& edges) {\\n        for (auto edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n    }\\n\\n    int dfs(int node, int currCost,vector<bool>& hasApple){\\n        if(visited[node])\\n            return 0;\\n        visited[node] = true;\\n\\n        int childrenCost = 0;\\n        for(auto x: graph[node])\\n            childrenCost += dfs(x,2,hasApple);\\n\\n        if(childrenCost == 0 && !hasApple[node])\\n            return 0;\\n        return childrenCost+currCost;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        createGraph(edges);\\n        return dfs(0,0,hasApple);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033899,
                "title": "python-easy-to-unserstand-well-explained",
                "content": "# Intuition\\nThe intuition behind using DFS is that we want to visit every vertex in the tree and check if it has an apple. DFS is a natural fit for this problem because it allows us to explore all the vertices in a tree by visiting each vertex and its children in a depth-first manner.\\n\\nAt each vertex, we first check if any of the vertex\\'s children has an apple. If any of the children has an apple, we recursively visit that child. In doing so, we keep adding the distance from the current vertex to that child to the total time spent. This way, we ensure that we only add the distance to the total time if it is necessary to visit that vertex.\\n\\nAdditionally, if the current vertex has an apple we also add the distance from the current vertex to its parent to the total time. This is because once we have visited all the children, we need to return back to the parent vertex and that needs to be counted in the time. Since the distance between any two vertices in the tree is always 1, we simply add 2 to the total time.\\n\\n# Approach\\nThe approach used in this problem is a depth-first search (DFS) traversal of the tree. We start at the vertex 0 and recursively visit each vertex in the tree, keeping track of the total time spent to collect all apples.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        tree = {i: [] for i in range(n)}\\n        for a, b in edges:\\n            tree[a].append(b)\\n            tree[b].append(a)\\n        def dfs(node, parent):\\n            time = 0\\n            for child in tree[node]:\\n                if child != parent:\\n                    time += dfs(child, node)\\n            if (time or hasApple[node]) and node != 0:\\n                time += 2\\n            return time\\n        return dfs(0, None)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        tree = {i: [] for i in range(n)}\\n        for a, b in edges:\\n            tree[a].append(b)\\n            tree[b].append(a)\\n        def dfs(node, parent):\\n            time = 0\\n            for child in tree[node]:\\n                if child != parent:\\n                    time += dfs(child, node)\\n            if (time or hasApple[node]) and node != 0:\\n                time += 2\\n            return time\\n        return dfs(0, None)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033761,
                "title": "java-dfs-easy-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- as we are iterating through each node of the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n- as we are using arraylist of size n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean isVisited[];\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        isVisited=new boolean[n];\\n        for(int i=0;i<n;i++)\\n        adj.add(new ArrayList<>());\\n\\n        for(int edge[]: edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        return getMinLength(0,adj,hasApple,0);\\n    }\\n    \\n    private int getMinLength(int index,List<List<Integer>> adj,List<Boolean> hasApple,int parent){\\n           int length=0;\\n           //if node is already visited then return 0.\\n           if(isVisited[index])\\n           return 0;\\n           // set current node index true.\\n           isVisited[index]=true;\\n           //travesing through each adj vertex of the current vertex.\\n           for(int vertex: adj.get(index))\\n               length+=getMinLength(vertex,adj,hasApple,index);\\n           \\n           //index==0 that means if the index is root then there is no  parent node. \\n           //if not then add +2 to the length as we need to reach the node and get back to the previous node as well.\\n           if(index!=0&&(hasApple.get(index)||length>0))\\n           length+=2;\\n           return length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean isVisited[];\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        isVisited=new boolean[n];\\n        for(int i=0;i<n;i++)\\n        adj.add(new ArrayList<>());\\n\\n        for(int edge[]: edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        return getMinLength(0,adj,hasApple,0);\\n    }\\n    \\n    private int getMinLength(int index,List<List<Integer>> adj,List<Boolean> hasApple,int parent){\\n           int length=0;\\n           //if node is already visited then return 0.\\n           if(isVisited[index])\\n           return 0;\\n           // set current node index true.\\n           isVisited[index]=true;\\n           //travesing through each adj vertex of the current vertex.\\n           for(int vertex: adj.get(index))\\n               length+=getMinLength(vertex,adj,hasApple,index);\\n           \\n           //index==0 that means if the index is root then there is no  parent node. \\n           //if not then add +2 to the length as we need to reach the node and get back to the previous node as well.\\n           if(index!=0&&(hasApple.get(index)||length>0))\\n           length+=2;\\n           return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033702,
                "title": "100-0ms-beats-100-5-lines-explained-proof-meme",
                "content": "# UPVOTE PLS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/098bc2d5-c08a-49ad-bbee-c9521ec20103_1673414143.5596747.png)\\n\\n# Complexity\\n- Time complexity:O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int[] counts = new int[n];\\n        Arrays.sort(edges, (a, b) -> (a[1] == b[0]) ? -1 : (a[0] == b[1]) ? 1 : 0);\\n        for (int edgePos = edges.length - 1; edgePos >= 0; --edgePos) { // walk backwards\\n            int[] edge = edges[edgePos];\\n            if (hasApple.get(edge[1]) || counts[edge[1]] > 0)  // forward and back + from previous node\\n                counts[edge[0]] += 2 + counts[edge[1]];\\n            else if (hasApple.get(edge[0]) || counts[edge[0]] > 0)  // forward and back + from previous node\\n                counts[edge[1]] += 2 + counts[edge[0]];\\n        } return counts[0];\\n    }  \\n```\\n//2ND WAY \\n```\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        Map<Integer,List<Integer>> graph=createGraph(edges);\\n        Map<Integer,Boolean> visited=new HashMap<>();\\n        return dfs(graph,0,hasApple,0,visited); \\n    }\\n    private int dfs(Map<Integer,List<Integer>> graph, int node,List<Boolean> hasApple,int cost,Map<Integer,Boolean> visited){\\n        boolean v=visited.getOrDefault(node,false);\\n        if(v) return 0;\\n        visited.put(node,true);\\n        int child=0;\\n        for(int c:graph.get(node))\\n            child+=dfs(graph,c,hasApple,2,visited);\\n        if(child==0 && hasApple.get(node)==false)return 0;\\n        return child+cost;\\n    }\\n    private Map<Integer,List<Integer>> createGraph(int[][] edges){\\n        Map<Integer,List<Integer>> graph = new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            List<Integer> list = graph.getOrDefault(edges[i][0],new ArrayList<Integer>());\\n            list.add(edges[i][1]);\\n            graph.put(edges[i][0],list);\\n\\n            List<Integer> list1 = graph.getOrDefault(edges[i][1],new ArrayList<Integer>());\\n            list1.add(edges[i][0]);\\n            graph.put(edges[i][1],list1);\\n        }return graph;\\n    }\\n```\\n![MEME.png](https://assets.leetcode.com/users/images/2aa32477-fb0d-473e-8595-b81076fc97da_1673416355.6292384.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\npublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        int[] counts = new int[n];\\n        Arrays.sort(edges, (a, b) -> (a[1] == b[0]) ? -1 : (a[0] == b[1]) ? 1 : 0);\\n        for (int edgePos = edges.length - 1; edgePos >= 0; --edgePos) { // walk backwards\\n            int[] edge = edges[edgePos];\\n            if (hasApple.get(edge[1]) || counts[edge[1]] > 0)  // forward and back + from previous node\\n                counts[edge[0]] += 2 + counts[edge[1]];\\n            else if (hasApple.get(edge[0]) || counts[edge[0]] > 0)  // forward and back + from previous node\\n                counts[edge[1]] += 2 + counts[edge[0]];\\n        } return counts[0];\\n    }  \\n```\n```\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        Map<Integer,List<Integer>> graph=createGraph(edges);\\n        Map<Integer,Boolean> visited=new HashMap<>();\\n        return dfs(graph,0,hasApple,0,visited); \\n    }\\n    private int dfs(Map<Integer,List<Integer>> graph, int node,List<Boolean> hasApple,int cost,Map<Integer,Boolean> visited){\\n        boolean v=visited.getOrDefault(node,false);\\n        if(v) return 0;\\n        visited.put(node,true);\\n        int child=0;\\n        for(int c:graph.get(node))\\n            child+=dfs(graph,c,hasApple,2,visited);\\n        if(child==0 && hasApple.get(node)==false)return 0;\\n        return child+cost;\\n    }\\n    private Map<Integer,List<Integer>> createGraph(int[][] edges){\\n        Map<Integer,List<Integer>> graph = new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            List<Integer> list = graph.getOrDefault(edges[i][0],new ArrayList<Integer>());\\n            list.add(edges[i][1]);\\n            graph.put(edges[i][0],list);\\n\\n            List<Integer> list1 = graph.getOrDefault(edges[i][1],new ArrayList<Integer>());\\n            list1.add(edges[i][0]);\\n            graph.put(edges[i][1],list1);\\n        }return graph;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3033608,
                "title": "o-n-beginner-friendly-java-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n            \\n    HashMap<Integer,List<Integer>>mp=new HashMap<>();\\n\\n    Set<Integer>st=new HashSet<>();\\n\\n    buildtree(mp,edges);\\n\\n    return ansfind(0,mp,st,hasApple);\\n\\n    }\\n\\n    public int ansfind(int node, HashMap<Integer,List<Integer>>mp,Set<Integer>st,List<Boolean> hasApple){\\n\\n    int res=0;\\n\\n    st.add(node);\\n\\n    if(mp.containsKey(node))\\n    {\\n    for(int child:mp.get(node)){\\n        if(!st.contains(child))\\n        res+=ansfind(child,mp,st,hasApple);\\n    }\\n    }\\n\\n    if((res>0||hasApple.get(node)==true)&&node!=0)res+=2;\\n\\n    return res;\\n    \\n    }\\n    \\n    public void buildtree(HashMap<Integer,List<Integer>>mp,int[][]edges){\\n\\n    for(int i=0;i<edges.length;i++){\\n        \\n    int m=edges[i][0];\\n    int n=edges[i][1];\\n\\n    if(!mp.containsKey(m)){\\n        mp.put(m,new ArrayList<Integer>());\\n    }\\n    mp.get(m).add(n);\\n\\n    if(!mp.containsKey(n)){\\n        mp.put(n,new ArrayList<Integer>());\\n    }\\n    mp.get(n).add(m);\\n\\n    }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n            \\n    HashMap<Integer,List<Integer>>mp=new HashMap<>();\\n\\n    Set<Integer>st=new HashSet<>();\\n\\n    buildtree(mp,edges);\\n\\n    return ansfind(0,mp,st,hasApple);\\n\\n    }\\n\\n    public int ansfind(int node, HashMap<Integer,List<Integer>>mp,Set<Integer>st,List<Boolean> hasApple){\\n\\n    int res=0;\\n\\n    st.add(node);\\n\\n    if(mp.containsKey(node))\\n    {\\n    for(int child:mp.get(node)){\\n        if(!st.contains(child))\\n        res+=ansfind(child,mp,st,hasApple);\\n    }\\n    }\\n\\n    if((res>0||hasApple.get(node)==true)&&node!=0)res+=2;\\n\\n    return res;\\n    \\n    }\\n    \\n    public void buildtree(HashMap<Integer,List<Integer>>mp,int[][]edges){\\n\\n    for(int i=0;i<edges.length;i++){\\n        \\n    int m=edges[i][0];\\n    int n=edges[i][1];\\n\\n    if(!mp.containsKey(m)){\\n        mp.put(m,new ArrayList<Integer>());\\n    }\\n    mp.get(m).add(n);\\n\\n    if(!mp.containsKey(n)){\\n        mp.put(n,new ArrayList<Integer>());\\n    }\\n    mp.get(n).add(m);\\n\\n    }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033409,
                "title": "c-dfs-recursive-approach",
                "content": "# Intuition\\nBased on Recursion\\n\\n# Approach\\nFirst we will create a adjacency list using the edges vector. Now we will apply DFS to it with the starting node 0 and prev node -1. In DFS we will see all the adjacents of current node. Now we will traverse to adjacent node only in case of either that adjacent has apple or its subtree has apple.To find whether its subtree has apple we will use recursion. Now we will return value 0 if its subtree as well as node don\\'t have apple otherwise we will return value got by recursion + 2(to visit that adjacent node and come back).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) for creating adjacency list\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        // Create adjacency list\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return dfs(-1,0,adj,hasApple);\\n    }\\n    int dfs(int prev,int curr,vector<int> adj[],vector<bool> &hasApple){\\n        int ans=0;\\n        for(int i=0;i<adj[curr].size();i++){\\n            // excluding our call for previous element \\n            if(adj[curr][i]!=prev){\\n                int res=dfs(curr,adj[curr][i],adj,hasApple);\\n                if(res>0 || hasApple[adj[curr][i]]==true) ans+=res+2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        // Create adjacency list\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        return dfs(-1,0,adj,hasApple);\\n    }\\n    int dfs(int prev,int curr,vector<int> adj[],vector<bool> &hasApple){\\n        int ans=0;\\n        for(int i=0;i<adj[curr].size();i++){\\n            // excluding our call for previous element \\n            if(adj[curr][i]!=prev){\\n                int res=dfs(curr,adj[curr][i],adj,hasApple);\\n                if(res>0 || hasApple[adj[curr][i]]==true) ans+=res+2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033391,
                "title": "c-o-n-easy-to-understand-with-in-depth-explanation-and-examples",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\nRun DFS from the root and calculate the amount of steps from the bottom up the tree\\n\\n## Code\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        adj.resize(n);\\n        for (vector<int>& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        return dfs(0, -1, hasApple);\\n    }\\nprivate:\\n    int dfs(int node, int parent, vector<bool>& hasApple) {\\n        int totalTime = 0, childTime = 0;\\n\\n        for (int& neighbor : adj[node]) {\\n            if (neighbor == parent)\\n                continue;\\n\\n            childTime = dfs(neighbor, node, hasApple);\\n\\n            if (childTime || hasApple[neighbor])\\n                totalTime += childTime + 2;\\n        }\\n\\n        return totalTime;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$\\n**Space Complexity:** $$O(N)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nI am going to use the photo from the [Leetcode Official Solution]() so if you want to take a look at that solution feel free!\\n\\n![bottom top photo](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/2864715/Figures/1443/1443-3.png)\\n\\nAs you can see, when there is an apple we need to visit that node which takes 2 trips (one to go to that node and then one for the way back). Additionally, we need to bubble up the trip cost since if there is an apple at the bottom, it costs time to head down a branch to get to the apple. Therefore, if we find an apple, we take the amount of time that we would spend in the subtree plus 2 for the trip to that node.\\n\\nFor example, if we look at the furthest left route, there is an apple. Since there is no nodes in the subtree, we just return `2` since that is the cost to visit that node.\\n\\nAnother example is when we go down the further right route. There is no apple at the bottom and there are no nodes in the subtree, so we wouldn\\'t go all the way down the branch so we would return `0` since we do not want to visit this branch all the way down\\n\\n## Approach \\n\\n* Create an adjacency list\\n* Run recursive DFS from the root node and keep track of the current node, the parent node, and the `hasApple` array\\n* Loop through all of the neighbors of the current node\\n  * If we have already seen the node (`neighbor == parent`), then move onto the next iteration\\n  * Calculate the time for traversing the neighbor\\'s subtree\\n  * If there is nonzero time for traversing the neighbor\\'s subtree **OR** the neighbor has an apple, then we take the time taken for traversing the child\\'s tree and then add 2 to a total\\n* At the end, just return the total for that node to the next node up in the tree\\n\\nWe should have the complete total at the end of this function\\n\\n## Example\\n\\nLet\\'s use the first example, where `n = 7`, `edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]`, and `hasApple = [false,false,true,false,true,true,false]`. Here is the image:\\n\\n![first example image](https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_1.png)\\n\\nFirst, we create the bidirectional adjacency list, which will look like this:\\n\\n```json\\n{\\n  0: [1,2],\\n  1: [4,5],\\n  2: [3,6],\\n  3: [],\\n  4: [],\\n  5: [],\\n  6: []\\n}\\n```\\n\\n1. node = 0, parent = -1\\n\\nWe iterate through all of the neighbors. The first neighbor is `1` and it is not equal to parent (`-1`), so we call `dfs(1, 0)`\\n\\n  a. node = 1, parent = 0\\n\\n  We iterate through all of the neighbors. The first neighbor is `4` and it is not equal to parent (`0`), so we call `dfs(4, 1)`\\n\\n    i. node = 4, parent = 1\\n\\n    We iterate through all of the neighbors and there is none so we return `0`\\n\\n  b. node = 1, parent = 0\\n\\n  `childTime = 0` since `4` has 0 time traversing it\\'s subtree (since there is no subtree). However, since `hasApple[4] = true`, we do `totalTime += childTime + 2` --> `totalTime = totalTime + childTime + 2 = 0 + 0 + 2 = 2`\\n\\n  The next neighbor is `5` and it is not equal to parent (`0`), so we call `dfs(5, 1)`\\n\\n    i. node = 5, parent = 1\\n\\n    We iterate through all of the neighbors and there is none so we return `0`\\n\\n  c. node = 1, parent = 0\\n\\n  `childTime = 0` since `5` has 0 time traversing it\\'s subtree (since there is no subtree). However, since `hasApple[5] = true`, we do `totalTime += childTime + 2` --> `totalTime = totalTime + childTime + 2 = 2 + 0 + 2 = 4`\\n\\n  There are no other neighbors, so we return `totalTime = 4`\\n\\n2. node = 0, parent = -1\\n\\n`childTime = 4` and since it is nonzero, we do `totalTime += childTime + 2` --> `totalTime = totalTime + childTime + 2 = 0 + 4 + 2 = 6`\\n\\nThe next neighbor is `2` and it is not equal to parent (`-1`), so we call `dfs(2, 0)`\\n\\n  a. node = 2, parent = 0\\n\\n  We iterate through all of the neighbors. The first neighbor is `3` and it is not equal to parent (`0`), so we call `dfs(3, 2)`\\n\\n    i. node = 3, parent = 2\\n\\n    We iterate through all of the neighbors and there is none so we return `0`\\n\\n  b. node = 2, parent = 0\\n\\n  `childTime = 0` and `hasApple[3] = false`, so we don\\'t add anything to the running total.\\n\\n  The next neighbor is `6` and it is not equal to parent (`0`), so we call `dfs(6, 2)`\\n\\n    i. node = 6, parent = 2\\n\\n    We iterate through all of the neighbors and there are none so we return `0`\\n\\n  c. node = 2, parent = 0\\n\\n  `childTime = 0` and `hasApple[6] = false`, so we don\\'t add anything to the running total.\\n\\n  There are no other neighbors, so we return `totalTime = 0`\\n\\n3. node = 0, parent = -1\\n\\n`childTime = 0` since `2` has 0 time traversing it\\'s subtree (nobody in the subtree has an apple). However, since `hasApple[2] = true`, we do `totalTime += childTime + 2` --> `totalTime = totalTime + childTime + 2 = 6 + 0 + 2 = 8`\\n\\nThere are no other neighbors, so we return `totalTime = 8`\\n\\n4. Aftermath\\n\\nWe just return `8`, which is the correct answer\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        adj.resize(n);\\n        for (vector<int>& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        return dfs(0, -1, hasApple);\\n    }\\nprivate:\\n    int dfs(int node, int parent, vector<bool>& hasApple) {\\n        int totalTime = 0, childTime = 0;\\n\\n        for (int& neighbor : adj[node]) {\\n            if (neighbor == parent)\\n                continue;\\n\\n            childTime = dfs(neighbor, node, hasApple);\\n\\n            if (childTime || hasApple[neighbor])\\n                totalTime += childTime + 2;\\n        }\\n\\n        return totalTime;\\n    }\\n};\\n```\n```json\\n{\\n  0: [1,2],\\n  1: [4,5],\\n  2: [3,6],\\n  3: [],\\n  4: [],\\n  5: [],\\n  6: []\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033348,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf Node hasApple then it will give it to it\\'s parent and it will take 2 second to do so.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        //Keep track of parents.\\n        vector<int> parent(n,-1);\\n        int i;\\n        for(i=0;i<edges.size();i++)\\n        {\\n            if(parent[edges[i][1]]==-1)\\n            {\\n                parent[edges[i][1]] = edges[i][0];\\n            }\\n            else\\n            {\\n                parent[edges[i][0]] = edges[i][1];\\n            }\\n        }\\n        int ans=0;\\n        bool flag = true;\\n        while(flag)\\n        {\\n            flag = false;            \\n            for(i=(n-1);i>0;i--)\\n            {\\n                //Here it will giving apple to it\\'s parent if it has any\\n                if(hasApple[i])\\n                {\\n                    flag = true; \\n                    hasApple[i] = false;\\n                    hasApple[parent[i]]=true;\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        //Keep track of parents.\\n        vector<int> parent(n,-1);\\n        int i;\\n        for(i=0;i<edges.size();i++)\\n        {\\n            if(parent[edges[i][1]]==-1)\\n            {\\n                parent[edges[i][1]] = edges[i][0];\\n            }\\n            else\\n            {\\n                parent[edges[i][0]] = edges[i][1];\\n            }\\n        }\\n        int ans=0;\\n        bool flag = true;\\n        while(flag)\\n        {\\n            flag = false;            \\n            for(i=(n-1);i>0;i--)\\n            {\\n                //Here it will giving apple to it\\'s parent if it has any\\n                if(hasApple[i])\\n                {\\n                    flag = true; \\n                    hasApple[i] = false;\\n                    hasApple[parent[i]]=true;\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033181,
                "title": "c-one-tree-traversal-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&adj, vector<bool>&apple, int start, int parent)\\n    {\\n        int time=0;\\n        for(auto x:adj[start])\\n        {\\n            if(x!=parent)\\n            time= time+solve(adj, apple, x, start);\\n        }\\n        if(start==0)\\n        return time;\\n        if(time==0 && apple[start]==false)\\n        return 0;\\n        else\\n        return time+2;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>>adj(n+1);\\n        for(auto x:edges)\\n        {\\n            adj[x[1]].push_back(x[0]);\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        return solve(adj, hasApple, 0, -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&adj, vector<bool>&apple, int start, int parent)\\n    {\\n        int time=0;\\n        for(auto x:adj[start])\\n        {\\n            if(x!=parent)\\n            time= time+solve(adj, apple, x, start);\\n        }\\n        if(start==0)\\n        return time;\\n        if(time==0 && apple[start]==false)\\n        return 0;\\n        else\\n        return time+2;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>>adj(n+1);\\n        for(auto x:edges)\\n        {\\n            adj[x[1]].push_back(x[0]);\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        return solve(adj, hasApple, 0, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033143,
                "title": "swift-10-sloc",
                "content": "**DFS (accepted answer)**\\n```\\nclass Solution {\\n    func minTime(_ n: Int, _ edges: [[Int]], _ hasApple: [Bool]) -> Int {\\n        let graph = edges.reduce(into: [Int:[Int]]()) { graph, edge in\\n            graph[edge[0], default: .init()].append(edge[1])\\n            graph[edge[1], default: .init()].append(edge[0])\\n        }\\n        \\n        var visited = Set([0])\\n        \\n        func visit(_ edge: Int) -> Int {\\n            let seconds = graph[edge]!.reduce(0) { $0 + (visited.insert($1).inserted ? visit($1) : 0) }\\n            return seconds + (edge > 0  && (seconds > 0 || hasApple[edge]) ? 2 : 0)\\n        }\\n        \\n        return visit(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minTime(_ n: Int, _ edges: [[Int]], _ hasApple: [Bool]) -> Int {\\n        let graph = edges.reduce(into: [Int:[Int]]()) { graph, edge in\\n            graph[edge[0], default: .init()].append(edge[1])\\n            graph[edge[1], default: .init()].append(edge[0])\\n        }\\n        \\n        var visited = Set([0])\\n        \\n        func visit(_ edge: Int) -> Int {\\n            let seconds = graph[edge]!.reduce(0) { $0 + (visited.insert($1).inserted ? visit($1) : 0) }\\n            return seconds + (edge > 0  && (seconds > 0 || hasApple[edge]) ? 2 : 0)\\n        }\\n        \\n        return visit(0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033091,
                "title": "jiust-time-2-and-while-coming-back-time-2-if-no-apple-is-present",
                "content": "```\\nclass Solution {\\n\\nprivate:\\n    \\n    bool findTotalTime(int n, vector<int>adj[], vector<bool>& hasApple, int &timeReq, int node, vector<int>&vis){\\n        \\n        if(adj[node].size() == 0){\\n          \\n            return hasApple[node] == true;\\n        }\\n        \\n        bool curr = false;\\n        vis[node] = 1;\\n        \\n        for(int index = 0; index < adj[node].size(); index++){\\n            \\n            timeReq+=2;\\n            bool check = false;\\n            \\n            if(vis[adj[node][index]] == 0){\\n          check = findTotalTime(n, adj, hasApple, timeReq, adj[node][index], vis);\\n            }\\n            \\n            if(!check){\\n                  timeReq-=2;\\n            }\\n            else{\\n                curr = true;\\n            }\\n        }\\n        \\n        return (curr || (hasApple[node] == true));\\n    }\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n        int timeReq = 0;\\n        vector<int>adj[n];\\n        vector<int>vis(n, 0);\\n        for(int index = 0; index < edges.size(); index++){\\n            \\n            adj[edges[index][0]].push_back(edges[index][1]);\\n            adj[edges[index][1]].push_back(edges[index][0]);\\n            \\n        }\\n        \\n        findTotalTime(n, adj, hasApple, timeReq, 0, vis);\\n        \\n        return timeReq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    \\n    bool findTotalTime(int n, vector<int>adj[], vector<bool>& hasApple, int &timeReq, int node, vector<int>&vis){\\n        \\n        if(adj[node].size() == 0){\\n          \\n            return hasApple[node] == true;\\n        }\\n        \\n        bool curr = false;\\n        vis[node] = 1;\\n        \\n        for(int index = 0; index < adj[node].size(); index++){\\n            \\n            timeReq+=2;\\n            bool check = false;\\n            \\n            if(vis[adj[node][index]] == 0){\\n          check = findTotalTime(n, adj, hasApple, timeReq, adj[node][index], vis);\\n            }\\n            \\n            if(!check){\\n                  timeReq-=2;\\n            }\\n            else{\\n                curr = true;\\n            }\\n        }\\n        \\n        return (curr || (hasApple[node] == true));\\n    }\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n        int timeReq = 0;\\n        vector<int>adj[n];\\n        vector<int>vis(n, 0);\\n        for(int index = 0; index < edges.size(); index++){\\n            \\n            adj[edges[index][0]].push_back(edges[index][1]);\\n            adj[edges[index][1]].push_back(edges[index][0]);\\n            \\n        }\\n        \\n        findTotalTime(n, adj, hasApple, timeReq, 0, vis);\\n        \\n        return timeReq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033042,
                "title": "easy-c-approach-o-n-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGraph and DFS were 1st thoughts on this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreated Adjacency List From given edges than applies tree traversal and if any of path contains apple there time kept increase and reads that path along way.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int abc(vector<vector<int>> &x,vector<bool>& hasApple,int i,int& time,vector<int>& vis) {\\n        if(vis[i]) return 0;\\n        vis[i]=1;\\n        if(x[i].size()==0){\\n            if(hasApple[i]){\\n                time+=2;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        bool a = false;\\n        for(int j=0;j<x[i].size();j++){\\n            if(abc(x,hasApple,x[i][j],time,vis)) a=true;\\n        }\\n        if(hasApple[i] || a){\\n            time+=2;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> x(n,vector<int>());\\n        for(int i=0;i<n-1;i++){\\n            x[edges[i][0]].push_back(edges[i][1]);\\n            x[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        int time=0;\\n        abc(x,hasApple,0,time,vis);\\n        return time==0?0:time-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int abc(vector<vector<int>> &x,vector<bool>& hasApple,int i,int& time,vector<int>& vis) {\\n        if(vis[i]) return 0;\\n        vis[i]=1;\\n        if(x[i].size()==0){\\n            if(hasApple[i]){\\n                time+=2;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        bool a = false;\\n        for(int j=0;j<x[i].size();j++){\\n            if(abc(x,hasApple,x[i][j],time,vis)) a=true;\\n        }\\n        if(hasApple[i] || a){\\n            time+=2;\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> x(n,vector<int>());\\n        for(int i=0;i<n-1;i++){\\n            x[edges[i][0]].push_back(edges[i][1]);\\n            x[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        int time=0;\\n        abc(x,hasApple,0,time,vis);\\n        return time==0?0:time-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033032,
                "title": "daily-leetcode-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,int parent,vector<int> adj[],vector<bool>& hasApple){\\n        int time=0;\\n        for(auto &i:adj[node]){\\n            if(i!=parent)\\n                time+=dfs(i,node,adj,hasApple);\\n        }\\n        return (time||hasApple[node])? time+=2:0;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(auto &i:edges){\\n            int u=i[0],v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int ans=dfs(0,-1,adj,hasApple);\\n        return ans==0?ans:ans-2; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,int parent,vector<int> adj[],vector<bool>& hasApple){\\n        int time=0;\\n        for(auto &i:adj[node]){\\n            if(i!=parent)\\n                time+=dfs(i,node,adj,hasApple);\\n        }\\n        return (time||hasApple[node])? time+=2:0;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(auto &i:edges){\\n            int u=i[0],v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int ans=dfs(0,-1,adj,hasApple);\\n        return ans==0?ans:ans-2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032997,
                "title": "javascript-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DFS to find all the apples and build the path length.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStarting at node 0, visit all children recursively.\\nAdd the path length of the children by visiting recursively and if any child has positive length or if the current node has an apple add `2` to the path length. Repeat this for all nodes except the root. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ Where n is the number of nodes to visit using DFS\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ From building the adjacency list and recursion.\\n\\n# Code\\n```\\nconst minTime = (n, edges, hasApple) => {\\n    const adjlist = Array.from(Array(n), () => new Array());\\n    for(const edge of edges){\\n        adjlist[edge[0]].push(edge[1]);\\n        adjlist[edge[1]].push(edge[0]);\\n    }\\n    const dfs = (i, p)=>{\\n        let pathlen = 0;\\n        for(const j of adjlist[i]){\\n            if(j == p) continue;\\n            pathlen += dfs(j, i);\\n        }\\n        if(i == 0) return pathlen;\\n        return pathlen > 0 || hasApple[i]? pathlen+2 : 0;\\n    }\\n    return dfs(0,-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst minTime = (n, edges, hasApple) => {\\n    const adjlist = Array.from(Array(n), () => new Array());\\n    for(const edge of edges){\\n        adjlist[edge[0]].push(edge[1]);\\n        adjlist[edge[1]].push(edge[0]);\\n    }\\n    const dfs = (i, p)=>{\\n        let pathlen = 0;\\n        for(const j of adjlist[i]){\\n            if(j == p) continue;\\n            pathlen += dfs(j, i);\\n        }\\n        if(i == 0) return pathlen;\\n        return pathlen > 0 || hasApple[i]? pathlen+2 : 0;\\n    }\\n    return dfs(0,-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2826635,
                "title": "java-pure-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        Set<Integer>[] paths = new HashSet[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            paths[i] = new HashSet<>();\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        Deque<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        visited[0] = true;\\n        Set<Integer> pure = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            for (int i = 0, size = queue.size(); i < size; i++) {\\n                int t = queue.poll();\\n                for (int g : graph[t]) {\\n                    if (visited[g]) {\\n                        continue;\\n                    }\\n                    if (hasApple.get(g)) {\\n                        pure.addAll(paths[t]);\\n                        pure.add(hash(t,g,n));\\n                    } else {\\n                        paths[g].addAll(paths[t]);\\n                        paths[g].add(hash(t,g,n));\\n                    }\\n                    visited[g] = true;\\n                    queue.offer(g);\\n                }\\n            }\\n        }\\n        return pure.size() * 2;\\n    }\\n    \\n    int hash(int t, int g, int n) {\\n        // use a unique integer to represent the path from t to g\\n        return t * n + g;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        Set<Integer>[] paths = new HashSet[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            paths[i] = new HashSet<>();\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        Deque<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        visited[0] = true;\\n        Set<Integer> pure = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            for (int i = 0, size = queue.size(); i < size; i++) {\\n                int t = queue.poll();\\n                for (int g : graph[t]) {\\n                    if (visited[g]) {\\n                        continue;\\n                    }\\n                    if (hasApple.get(g)) {\\n                        pure.addAll(paths[t]);\\n                        pure.add(hash(t,g,n));\\n                    } else {\\n                        paths[g].addAll(paths[t]);\\n                        paths[g].add(hash(t,g,n));\\n                    }\\n                    visited[g] = true;\\n                    queue.offer(g);\\n                }\\n            }\\n        }\\n        return pure.size() * 2;\\n    }\\n    \\n    int hash(int t, int g, int n) {\\n        // use a unique integer to represent the path from t to g\\n        return t * n + g;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673009,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<bool>seen;\\n        int e=0;\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        adj=vector<vector<int>>(n);\\n        seen=vector<bool>(n,false);\\n        for(auto e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        traversal(0,0,hasApple);\\n            return e*2;   \\n    }\\n    int  traversal(int u,int level,vector<bool>&hasapple)\\n    {\\n       \\n        int temp=1;\\n        seen[u]=true;\\n        if(hasapple[u])\\n        {\\n            e+=level;\\n            temp=0;\\n        }\\n        for(auto v:adj[u])\\n        {\\n           if(!seen[v])\\n           {\\n            temp*=traversal(v,level*temp+1,hasapple);\\n           }\\n        }\\n        return temp;   \\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<bool>seen;\\n        int e=0;\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        adj=vector<vector<int>>(n);\\n        seen=vector<bool>(n,false);\\n        for(auto e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        traversal(0,0,hasApple);\\n            return e*2;   \\n    }\\n    int  traversal(int u,int level,vector<bool>&hasapple)\\n    {\\n       \\n        int temp=1;\\n        seen[u]=true;\\n        if(hasapple[u])\\n        {\\n            e+=level;\\n            temp=0;\\n        }\\n        for(auto v:adj[u])\\n        {\\n           if(!seen[v])\\n           {\\n            temp*=traversal(v,level*temp+1,hasapple);\\n           }\\n        }\\n        return temp;   \\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572784,
                "title": "very-easy-and-intutive-c-solution",
                "content": "Logic: If a node has children with apples add them to the ans after multiplying by 2 (beacuse we have to come and go back also) but return only 1 when returning the value up because there is only one path to go up so we avoid double counting\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    int ans=0;\\n    int dfs(int node,int parent,vector<bool>&apple){\\n        int c=0;\\n        for(int child:adj[node]){\\n            if(child==parent){\\n                continue;\\n            }\\n            c+=max((int)apple[child],dfs(child,node,apple));\\n        }\\n        ans+=c*2;\\n        if(c>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        adj.resize(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,-1,hasApple);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    int ans=0;\\n    int dfs(int node,int parent,vector<bool>&apple){\\n        int c=0;\\n        for(int child:adj[node]){\\n            if(child==parent){\\n                continue;\\n            }\\n            c+=max((int)apple[child],dfs(child,node,apple));\\n        }\\n        ans+=c*2;\\n        if(c>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        adj.resize(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,-1,hasApple);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411715,
                "title": "c-solution-faster-than-99-84-percent-dfs-solution-o-n-time-complexity",
                "content": "* Central Idea: To reach every node u need to add a cost of 2 to the answer (1 for parent to node and 1 for node back to the parent)\\n* Making changes to the DFS code to add the subcosts for reaching the desired node from the given parent node\\n\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& gr, vector<bool>& hasApple, vector<bool>& vis, int src)\\n    {\\n        vis[src] = true;\\n        int cost = 0;\\n        \\n        for(auto it:gr[src])\\n        {\\n            if(vis[it]==false)\\n                cost += dfs(gr, hasApple, vis, it);\\n        }\\n        \\n        if(hasApple[src]!=false || cost>0)\\n            cost = cost+2;\\n        \\n        return cost;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        int cost = 0;\\n        vector<vector<int>> gr(n);\\n        \\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            gr[u].push_back(v);\\n            gr[v].push_back(u);\\n        }\\n        vector<bool> vis(n, false);\\n        cost = dfs(gr, hasApple, vis, 0);\\n        //undirected graph, apple array, visited vector, source\\n        if(cost>0)\\n            return cost-2;\\n        else\\n            return cost;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int dfs(vector<vector<int>>& gr, vector<bool>& hasApple, vector<bool>& vis, int src)\\n    {\\n        vis[src] = true;\\n        int cost = 0;\\n        \\n        for(auto it:gr[src])\\n        {\\n            if(vis[it]==false)\\n                cost += dfs(gr, hasApple, vis, it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2135516,
                "title": "python-dfs-please-comment-if-you-can-optimise-this-approach-further",
                "content": "```\\n/*\\n    approach: \\n    we can simply apply a dfs based approach to iterate over all the nodes\\n    and keep track of the path observed so far. \\n    if the current node has apple, then insert all the edges observed in the path to the result set\\n    once all the nodes have been traversed using the dfs, the answer will be  twice the number of edges in result set\\n*/\\n```\\n\\n```\\nclass Solution:\\n\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        graph_map = {i: set() for i in range(n)}\\n        for edge in edges:\\n            graph_map[edge[0]].add(edge[1])\\n            graph_map[edge[1]].add(edge[0])\\n            \\n        self.result = set()\\n        visited = set()\\n        def dfs(node, path):\\n            visited.add(node)\\n            if hasApple[node]:\\n                temp = path + \\'|\\' + str(node)\\n                temp = temp.split(\\'|\\')[1:]\\n                # print(temp)\\n                for i in range(1, len(temp)):\\n                    self.result.add((temp[i], temp[i-1]))\\n            for nei in graph_map[node]:\\n                if nei not in visited: \\n                    dfs(nei, path + \\'|\\' + str(node))\\n                \\n        dfs(0, \"\")\\n        # print(self.result)        \\n        return len(self.result) * 2\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n    approach: \\n    we can simply apply a dfs based approach to iterate over all the nodes\\n    and keep track of the path observed so far. \\n    if the current node has apple, then insert all the edges observed in the path to the result set\\n    once all the nodes have been traversed using the dfs, the answer will be  twice the number of edges in result set\\n*/\\n```\n```\\nclass Solution:\\n\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        graph_map = {i: set() for i in range(n)}\\n        for edge in edges:\\n            graph_map[edge[0]].add(edge[1])\\n            graph_map[edge[1]].add(edge[0])\\n            \\n        self.result = set()\\n        visited = set()\\n        def dfs(node, path):\\n            visited.add(node)\\n            if hasApple[node]:\\n                temp = path + \\'|\\' + str(node)\\n                temp = temp.split(\\'|\\')[1:]\\n                # print(temp)\\n                for i in range(1, len(temp)):\\n                    self.result.add((temp[i], temp[i-1]))\\n            for nei in graph_map[node]:\\n                if nei not in visited: \\n                    dfs(nei, path + \\'|\\' + str(node))\\n                \\n        dfs(0, \"\")\\n        # print(self.result)        \\n        return len(self.result) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874095,
                "title": "python-easy-dfs-solution-1443-minimum-time-to-collect-all-apples-in-a-tree",
                "content": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        \\n        \\n        self.res = 0\\n        adj = {i : [] for i in range(n)}\\n        \\n        for n1, n2 in edges:\\n            adj[n1].append(n2)\\n            adj[n2].append(n1)\\n                            \\n        visited = set()\\n        def dfs(node):\\n    \\n            has = hasApple[node]\\n            \\n            if node in visited:\\n                return False\\n            \\n            visited.add(node)\\n            \\n            for child in adj[node]:\\n                decendantHasApple = dfs(child)\\n                has = has or decendantHasApple\\n                \\n            if has and node != 0:\\n                self.res += 2\\n            \\n            return has\\n        \\n            \\n        dfs(0)\\n        \\n        return self.res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        \\n        \\n        self.res = 0\\n        adj = {i : [] for i in range(n)}\\n        \\n        for n1, n2 in edges:\\n            adj[n1].append(n2)\\n            adj[n2].append(n1)\\n                            \\n        visited = set()\\n        def dfs(node):\\n    \\n            has = hasApple[node]\\n            \\n            if node in visited:\\n                return False\\n            \\n            visited.add(node)\\n            \\n            for child in adj[node]:\\n                decendantHasApple = dfs(child)\\n                has = has or decendantHasApple\\n                \\n            if has and node != 0:\\n                self.res += 2\\n            \\n            return has\\n        \\n            \\n        dfs(0)\\n        \\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698262,
                "title": "c-easy-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<bool> &has, vector<vector<int>> &adj, vector<bool> &visited, int s)\\n    {\\n        \\n        visited[s] = true;\\n        int t = 0;\\n        \\n        for(auto i: adj[s])\\n        {\\n            if(!visited[i])\\n            {\\n                t += dfs(has, adj, visited, i);\\n            }\\n        }\\n        // increase time if source node has apple or current edge is the path to an apple\\n        if(s != 0 && has[s] || t > 0)\\n            t += 2;\\n        return t;\\n    }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        for(auto i: edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<bool> visited(n, false);\\n        int res = dfs(hasApple, adj, visited, 0);\\n        return res == 0?0: res - 2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dfs(vector<bool> &has, vector<vector<int>> &adj, vector<bool> &visited, int s)\\n    {\\n        \\n        visited[s] = true;\\n        int t = 0;\\n        \\n        for(auto i: adj[s])\\n        {\\n            if(!visited[i])\\n            {\\n                t += dfs(has, adj, visited, i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1538134,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        if (n <= 0 || edges == null || edges.length == 0 || hasApple == null || hasApple.size() != n) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int[] edge : edges) {\\n            adjList.putIfAbsent(edge[0], new ArrayList<>());\\n            adjList.putIfAbsent(edge[1], new ArrayList<>());\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        return dfs(n, hasApple, adjList, new boolean[n], 0);\\n    }\\n    \\n    // return the result of the sub problem. i.e. steps needed for subtree *node*\\n    private int dfs(int n, List<Boolean> hasApple, Map<Integer, List<Integer>> adjList, boolean[] visited, int node) {\\n        visited[node] = true; // add visited right away so following recursive call will not visit node again\\n        int total = 0;\\n        for (int child : adjList.get(node)) {\\n            if(visited[child]){\\n                continue;\\n            }\\n            int cost =  dfs(n, hasApple, adjList, visited, child);\\n            if(cost != 0 || hasApple.get(child)){\\n                total += cost + 2;\\n            }\\n        }\\n        \\n        return total;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        if (n <= 0 || edges == null || edges.length == 0 || hasApple == null || hasApple.size() != n) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int[] edge : edges) {\\n            adjList.putIfAbsent(edge[0], new ArrayList<>());\\n            adjList.putIfAbsent(edge[1], new ArrayList<>());\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        return dfs(n, hasApple, adjList, new boolean[n], 0);\\n    }\\n    \\n    // return the result of the sub problem. i.e. steps needed for subtree *node*\\n    private int dfs(int n, List<Boolean> hasApple, Map<Integer, List<Integer>> adjList, boolean[] visited, int node) {\\n        visited[node] = true; // add visited right away so following recursive call will not visit node again\\n        int total = 0;\\n        for (int child : adjList.get(node)) {\\n            if(visited[child]){\\n                continue;\\n            }\\n            int cost =  dfs(n, hasApple, adjList, visited, child);\\n            if(cost != 0 || hasApple.get(child)){\\n                total += cost + 2;\\n            }\\n        }\\n        \\n        return total;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469060,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& graph, vector<bool>& hasApple, int cur, vector<int>& vis){\\n        vis[cur]=true;\\n        int ans=0;\\n        for(auto &child : graph[cur]){\\n            if(!vis[child]) ans += solve(graph,hasApple,child, vis); \\n        }\\n        return (hasApple[cur] || ans>0) ? ans+1 : 0;\\n    }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> graph(n);\\n        vector<int> vis(n,false);\\n        for(auto &x : edges){\\n            int u = x[0];\\n            int v = x[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        int data = solve(graph,hasApple,0,vis);\\n        return data==0 ? 0 : 2*(data-1);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& graph, vector<bool>& hasApple, int cur, vector<int>& vis){\\n        vis[cur]=true;\\n        int ans=0;\\n        for(auto &child : graph[cur]){\\n            if(!vis[child]) ans += solve(graph,hasApple,child, vis); \\n        }\\n        return (hasApple[cur] || ans>0) ? ans+1 : 0;\\n    }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> graph(n);\\n        vector<int> vis(n,false);\\n        for(auto &x : edges){\\n            int u = x[0];\\n            int v = x[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        int data = solve(graph,hasApple,0,vis);\\n        return data==0 ? 0 : 2*(data-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221105,
                "title": "c-simple-dfs-clean-o-n",
                "content": "class Solution {\\npublic:\\n    \\n    int dfs(int u, vector<vector<int>> &g, vector<int> &vis, vector<bool> & has){\\n        \\n        vis[u]=1;\\n        \\n        int x=0;\\n        \\n        // Asking the children to tell how much time you require\\n        \\n        for(int i:g[u])\\n            if(!vis[i])\\n                x+=dfs(i, g, vis, has);\\n        \\n        // If the current vertex has apple or any of the vertex in its subtree then add 2 to the time returned by the children otherwise simply return 0 because no apple was present so no time is required to transport it\\n        \\n        if(has[u]||x>0)\\n            return x+2;\\n        \\n        return x;\\n    }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n        vector<vector<int>> g(n);\\n        \\n        for(auto edge:edges)\\n            g[edge[0]].push_back(edge[1]), g[edge[1]].push_back(edge[0]);\\n        \\n        vector<int> vis(n);\\n        \\n        vis[0]=1;\\n        \\n        int res=0;\\n        \\n        // Adding the time returned by children of vertex 0  \\n        \\n        for(int i:g[0])\\n            res+=dfs(i, g, vis, hasApple);\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int dfs(int u, vector<vector<int>> &g, vector<int> &vis, vector<bool> & has){\\n        \\n        vis[u]=1;\\n        \\n        int x=0;\\n        \\n        // Asking the children to tell how much time you require\\n        \\n        for(int i:g[u])\\n            if(!vis[i])\\n                x+=dfs(i, g, vis, has);\\n        \\n        // If the current vertex has apple or any of the vertex in its subtree then add 2 to the time returned by the children otherwise simply return 0 because no apple was present so no time is required to transport it\\n        \\n        if(has[u]||x>0)\\n            return x+2;\\n        \\n        return x;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1085667,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<Integer>[] arr=new ArrayList[n];\\n        for(var edge:edges) {\\n            int i=edge[0],j=edge[1];\\n            if(arr[i]==null) arr[i]=new ArrayList<Integer>();\\n            arr[i].add(j);\\n            if(arr[j]==null) arr[j]=new ArrayList<Integer>();\\n            arr[j].add(i);\\n        }\\n        var visited=new boolean[n];\\n        return dfs(0,arr,hasApple,visited);\\n    }\\n    \\n    int dfs(int val,List<Integer>[] arr,List<Boolean> flags,boolean[] visited) {\\n        visited[val]=true;\\n        var sum=0;\\n        for(var c:arr[val]) {\\n            if(visited[c]) continue;\\n            var cnt=dfs(c,arr,flags,visited);\\n            sum+=cnt;\\n            if(cnt>0||flags.get(c)) sum+=2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<Integer>[] arr=new ArrayList[n];\\n        for(var edge:edges) {\\n            int i=edge[0],j=edge[1];\\n            if(arr[i]==null) arr[i]=new ArrayList<Integer>();\\n            arr[i].add(j);\\n            if(arr[j]==null) arr[j]=new ArrayList<Integer>();\\n            arr[j].add(i);\\n        }\\n        var visited=new boolean[n];\\n        return dfs(0,arr,hasApple,visited);\\n    }\\n    \\n    int dfs(int val,List<Integer>[] arr,List<Boolean> flags,boolean[] visited) {\\n        visited[val]=true;\\n        var sum=0;\\n        for(var c:arr[val]) {\\n            if(visited[c]) continue;\\n            var cnt=dfs(c,arr,flags,visited);\\n            sum+=cnt;\\n            if(cnt>0||flags.get(c)) sum+=2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859093,
                "title": "c-bfs-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> graph(n, vector<int>());\\n        unordered_map<int, int> nodeCameFrom; // {node, parent}\\n        // Construct the Adjacency List Graph\\n        for (int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        fillNodesBFS(nodeCameFrom, graph, n);\\n        queue<int> nodesQueue;\\n        // Push only nodes that have an apple into Queue\\n        for (int i = 0; i < hasApple.size(); i++) {\\n            if (hasApple[i]) {\\n                nodesQueue.push(i);\\n            }\\n        }\\n        set<pair<int, int>> uniqueEdges;\\n        while (!nodesQueue.empty()) {\\n            int curNode = nodesQueue.front();\\n            nodesQueue.pop();\\n            int parent = nodeCameFrom[curNode];\\n            for (; parent != 0; curNode = parent, parent = nodeCameFrom[parent]) {\\n                uniqueEdges.insert({curNode, parent});\\n            }\\n            uniqueEdges.insert({curNode, parent});\\n        }\\n        uniqueEdges.erase({0, 0});\\n        return uniqueEdges.size() * 2;\\n    }\\n    \\n    void fillNodesBFS(unordered_map<int, int> &nodeCameFrom, vector<vector<int>> &graph, int &n) {\\n        queue<int> nodesQueue;\\n        vector<bool> isVisited(n, false);\\n        nodesQueue.push(0);\\n        isVisited[0] = true;\\n        while (!nodesQueue.empty()) {\\n            int curNode = nodesQueue.front();\\n            nodesQueue.pop();\\n            for (int childred : graph[curNode]) {\\n                if (isVisited[childred] == false) {\\n                    nodesQueue.push(childred);\\n                    isVisited[childred] = true;\\n                    nodeCameFrom[childred] = curNode;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> graph(n, vector<int>());\\n        unordered_map<int, int> nodeCameFrom; // {node, parent}\\n        // Construct the Adjacency List Graph\\n        for (int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        fillNodesBFS(nodeCameFrom, graph, n);\\n        queue<int> nodesQueue;\\n        // Push only nodes that have an apple into Queue\\n        for (int i = 0; i < hasApple.size(); i++) {\\n            if (hasApple[i]) {\\n                nodesQueue.push(i);\\n            }\\n        }\\n        set<pair<int, int>> uniqueEdges;\\n        while (!nodesQueue.empty()) {\\n            int curNode = nodesQueue.front();\\n            nodesQueue.pop();\\n            int parent = nodeCameFrom[curNode];\\n            for (; parent != 0; curNode = parent, parent = nodeCameFrom[parent]) {\\n                uniqueEdges.insert({curNode, parent});\\n            }\\n            uniqueEdges.insert({curNode, parent});\\n        }\\n        uniqueEdges.erase({0, 0});\\n        return uniqueEdges.size() * 2;\\n    }\\n    \\n    void fillNodesBFS(unordered_map<int, int> &nodeCameFrom, vector<vector<int>> &graph, int &n) {\\n        queue<int> nodesQueue;\\n        vector<bool> isVisited(n, false);\\n        nodesQueue.push(0);\\n        isVisited[0] = true;\\n        while (!nodesQueue.empty()) {\\n            int curNode = nodesQueue.front();\\n            nodesQueue.pop();\\n            for (int childred : graph[curNode]) {\\n                if (isVisited[childred] == false) {\\n                    nodesQueue.push(childred);\\n                    isVisited[childred] = true;\\n                    nodeCameFrom[childred] = curNode;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834112,
                "title": "c-dfs-solution-bottom-up-apple-count",
                "content": "Runtime: 316 ms, faster than 98.10% of C++ online submissions for Minimum Time to Collect All Apples in a Tree.\\nMemory Usage: 60.4 MB, less than 81.09% of C++ online submissions for Minimum Time to Collect All Apples in a Tree.\\n\\nNote: Given Tree is undirected and N-ary tree which can lead to cycle in DFS.\\nTo avoid cycle Visited list is used and Adjacency list Nodes is used for DFS. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int edgeTraverse(int node, vector<vector<int>>&Nodes, vector<bool>& hasApple, vector<bool>& Visited)\\n    {\\n        Visited[node] = true;       \\n        int cval = 0;\\n        for(int i=0;i<Nodes[node].size();i++)\\n        {\\n            if(!Visited[Nodes[node][i]])\\n                cval+= edgeTraverse(Nodes[node][i], Nodes, hasApple,Visited);                \\n        }\\n        \\n        return cval>0 ? (cval+2) : (hasApple[node]?2:0);\\n     }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n        vector<vector<int>>Nodes(n);\\n        vector<bool>Visited(n,false);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            Nodes[edges[i][0]].push_back(edges[i][1]);\\n            Nodes[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        Visited[0] = true;\\n        int result = 0;\\n        for(int i=0;i<Nodes[0].size();i++)\\n        {\\n            if(!Visited[Nodes[0][i]])\\n                result+= edgeTraverse(Nodes[0][i], Nodes, hasApple, Visited);\\n        }\\n        \\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int edgeTraverse(int node, vector<vector<int>>&Nodes, vector<bool>& hasApple, vector<bool>& Visited)\\n    {\\n        Visited[node] = true;       \\n        int cval = 0;\\n        for(int i=0;i<Nodes[node].size();i++)\\n        {\\n            if(!Visited[Nodes[node][i]])\\n                cval+= edgeTraverse(Nodes[node][i], Nodes, hasApple,Visited);                \\n        }\\n        \\n        return cval>0 ? (cval+2) : (hasApple[node]?2:0);\\n     }\\n    \\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n        vector<vector<int>>Nodes(n);\\n        vector<bool>Visited(n,false);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            Nodes[edges[i][0]].push_back(edges[i][1]);\\n            Nodes[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        Visited[0] = true;\\n        int result = 0;\\n        for(int i=0;i<Nodes[0].size();i++)\\n        {\\n            if(!Visited[Nodes[0][i]])\\n                result+= edgeTraverse(Nodes[0][i], Nodes, hasApple, Visited);\\n        }\\n        \\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815439,
                "title": "java-simple-post-order-traversal",
                "content": "```\\n\\tpublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<Integer>[] tree = new List[n];\\n        for (int i = 0; i < n; i++) tree[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n        }\\n            \\n        dfs(tree, hasApple, 0, -1);\\n        return ans;\\n    }\\n    \\n    private int ans = 0;\\n    \\n    private boolean dfs(List<Integer>[] tree, List<Boolean> hasApple, int u, int pre) {\\n        boolean apple = false;\\n        for (int v : tree[u]) if (v != pre) {\\n            boolean tmp = dfs(tree, hasApple, v, u);\\n            apple = apple||tmp;\\n            if (tmp) ans += 2;\\n        }\\n        return apple||hasApple.get(u);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        List<Integer>[] tree = new List[n];\\n        for (int i = 0; i < n; i++) tree[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n        }\\n            \\n        dfs(tree, hasApple, 0, -1);\\n        return ans;\\n    }\\n    \\n    private int ans = 0;\\n    \\n    private boolean dfs(List<Integer>[] tree, List<Boolean> hasApple, int u, int pre) {\\n        boolean apple = false;\\n        for (int v : tree[u]) if (v != pre) {\\n            boolean tmp = dfs(tree, hasApple, v, u);\\n            apple = apple||tmp;\\n            if (tmp) ans += 2;\\n        }\\n        return apple||hasApple.get(u);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 792188,
                "title": "c-code-with-intuition",
                "content": "**Here the main thing to note is that  we have to somehow know whether any child subtree of a node has any apple or not,\\nIf a subtree has apple, then we will have to definitely go to that node & come back from that child subtree node, so in this case we have  to add 2 to our required answer**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> gr[100005];\\n    int vis[100005];\\n    bool subtree_has_apple(int src,int &moves,vector<bool> &hasApple){\\n        vis[src]=true;\\n       \\n        //b is a variable to know whether any of its child subtree has a apple in it or not\\n        bool b=false;\\n        for(int nbr:gr[src]){\\n            if(!vis[nbr]){\\n                bool b1=subtree_has_apple(nbr,moves,hasApple);\\n                if(b1){\\n                    moves+=2;\\n                    b=true;\\n                }\\n            }\\n        }\\n        //if any of its child subtree has apple or the node itself has apple, then return true\\n        if(b || hasApple[src]){\\n            return true;\\n        }\\n        //means this whole subtree does not have any apple , so we can safely return false;\\n        return false;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            gr[a].push_back(b);\\n            gr[b].push_back(a);\\n        }\\n        int moves=0;\\n        subtree_has_apple(0,moves,hasApple);\\n        return moves;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> gr[100005];\\n    int vis[100005];\\n    bool subtree_has_apple(int src,int &moves,vector<bool> &hasApple){\\n        vis[src]=true;\\n       \\n        //b is a variable to know whether any of its child subtree has a apple in it or not\\n        bool b=false;\\n        for(int nbr:gr[src]){\\n            if(!vis[nbr]){\\n                bool b1=subtree_has_apple(nbr,moves,hasApple);\\n                if(b1){\\n                    moves+=2;\\n                    b=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 733297,
                "title": "python-dfs-solution-with-easy-explanation-and-inline-comments",
                "content": "The idea is, traverse the tree, if current node has apple, add `+ 2` to the answer as  1 to reach this node and 1 to go back, and set the flag to `true` and return it, so now while going bottom up, parent can check for the flag and see if any of my child has apple, if so, do same here, `+2` and return flag and keep repeating.\\n\\n```python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        graph = collections.defaultdict(list)\\n        \\n\\t\\t# Construct Graph\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        def dfs(node, seen):\\n            \\n\\t\\t\\t# Flag is initialized as false, means at this point we don\\'t know if this node or any of its children\\n\\t\\t\\t# has apple or not.\\n            flag = False\\n            nonlocal ans\\n            \\n            if hasApple[node]:\\n\\t\\t\\t\\t# Now we at least know that this node has apple, so set the flag to true, irrespective of \\n\\t\\t\\t\\t# whether its children has apple or not.\\n                flag = True\\n                \\n            for child in graph[node]:\\n                if child not in seen:\\n                    seen.add(child)\\n                    res = dfs(child, seen)\\n                    if res:\\n\\t\\t\\t\\t\\t\\t# based on res, update the flag\\n                        flag = flag or res\\n            \\n\\t\\t\\t# Just before returning check whether flag is set or not,\\n\\t\\t\\t# if set, add +2 to answer, means either this node has apple or its children\\n\\t\\t\\t# in either case, we took 1 second to come here and we will require 1 second to\\n\\t\\t\\t# go back.\\n\\t\\t\\t# Checking for node, becase root node i.e 0 doesn\\'t require it.\\n            if flag and node:\\n                ans += 2\\n\\t\\t\\t\\n\\t\\t\\t# return the flag as it is. It will be used by its parent o determine whether this\\n\\t\\t\\t# path had apple or not.\\n            return flag\\n        \\n        ans = 0\\n        dfs(0, set([0]))\\n        \\n        return ans\\n",
                "solutionTags": [],
                "code": "The idea is, traverse the tree, if current node has apple, add `+ 2` to the answer as  1 to reach this node and 1 to go back, and set the flag to `true` and return it, so now while going bottom up, parent can check for the flag and see if any of my child has apple, if so, do same here, `+2` and return flag and keep repeating.\\n\\n```python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        graph = collections.defaultdict(list)\\n        \\n\\t\\t# Construct Graph\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        def dfs(node, seen):\\n            \\n\\t\\t\\t# Flag is initialized as false, means at this point we don\\'t know if this node or any of its children\\n\\t\\t\\t# has apple or not.\\n            flag = False\\n            nonlocal ans\\n            \\n            if hasApple[node]:\\n\\t\\t\\t\\t# Now we at least know that this node has apple, so set the flag to true, irrespective of \\n\\t\\t\\t\\t# whether its children has apple or not.\\n                flag = True\\n                \\n            for child in graph[node]:\\n                if child not in seen:\\n                    seen.add(child)\\n                    res = dfs(child, seen)\\n                    if res:\\n\\t\\t\\t\\t\\t\\t# based on res, update the flag\\n                        flag = flag or res\\n            \\n\\t\\t\\t# Just before returning check whether flag is set or not,\\n\\t\\t\\t# if set, add +2 to answer, means either this node has apple or its children\\n\\t\\t\\t# in either case, we took 1 second to come here and we will require 1 second to\\n\\t\\t\\t# go back.\\n\\t\\t\\t# Checking for node, becase root node i.e 0 doesn\\'t require it.\\n            if flag and node:\\n                ans += 2\\n\\t\\t\\t\\n\\t\\t\\t# return the flag as it is. It will be used by its parent o determine whether this\\n\\t\\t\\t# path had apple or not.\\n            return flag\\n        \\n        ans = 0\\n        dfs(0, set([0]))\\n        \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 630720,
                "title": "compute-lca-and-return-paintededges-2",
                "content": "Hi,\\nFind LCA for all the apples and then paint all the edges which were used in calculating LCA.\\nThen count the number of painted edges and return `2*paintedEdges`\\n\\nBelow is the code for it.\\n\\n```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        unordered_map<int, int> parentPtr;\\n        for(auto pair: edges) {\\n            parentPtr[pair[1]] = pair[0];\\n        }\\n        \\n        vector<bool> isPainted(hasApple.size(), false);\\n        for(int i=0;i<hasApple.size();i++) {\\n            if (!hasApple[i] || isPainted[i]) continue;\\n            \\n            int curr_index = i;\\n            while(curr_index >= 0) {\\n                if(isPainted[curr_index]) {\\n                    curr_index = -1;\\n                } else {\\n                    isPainted[curr_index] = true;\\n                    if(parentPtr.find(curr_index) == parentPtr.end()) {\\n                        curr_index = -1;\\n                    } else {\\n                        curr_index = parentPtr[curr_index];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int painted_edge = 0;\\n        for(auto edge: edges) {\\n            if(isPainted[edge[0]] && isPainted[edge[1]]) {\\n                painted_edge++;\\n            }\\n        }\\n        \\n        return painted_edge*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        unordered_map<int, int> parentPtr;\\n        for(auto pair: edges) {\\n            parentPtr[pair[1]] = pair[0];\\n        }\\n        \\n        vector<bool> isPainted(hasApple.size(), false);\\n        for(int i=0;i<hasApple.size();i++) {\\n            if (!hasApple[i] || isPainted[i]) continue;\\n            \\n            int curr_index = i;\\n            while(curr_index >= 0) {\\n                if(isPainted[curr_index]) {\\n                    curr_index = -1;\\n                } else {\\n                    isPainted[curr_index] = true;\\n                    if(parentPtr.find(curr_index) == parentPtr.end()) {\\n                        curr_index = -1;\\n                    } else {\\n                        curr_index = parentPtr[curr_index];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int painted_edge = 0;\\n        for(auto edge: edges) {\\n            if(isPainted[edge[0]] && isPainted[edge[1]]) {\\n                painted_edge++;\\n            }\\n        }\\n        \\n        return painted_edge*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629635,
                "title": "iterative-solution-rust",
                "content": "I first count from the fartest leaf(node) traversing the has_apple vector from bottom to top and when I find a true value I begin counting down in the graph until I reach the value zero, at the same time marking those values visited as true since when I traverse a visited node I just break out of the loop and add up the counting from the new node until the known path already traversed or till zero if the path is still unknown. \\nInsidee the loop I look for the minimum value in the corresponding part of the graph (graph[i]) in order to traverse the graph towards the top node . At the end the result is just one way to the top, so I multiply it by two to make it a two-way around.\\n```\\npub fn min_time(n: i32, edges: Vec<Vec<i32>>, has_apple: Vec<bool>) -> i32 {\\n    let mut graph : Vec<Vec<i32>> = vec![Vec::new();n as usize];\\n    let mut visited = vec![false;n as usize];\\n    let mut res = 0;\\n    for edge in edges.into_iter() {\\n        graph[edge[0] as usize].push(edge[1]);  \\n        graph[edge[1] as usize].push(edge[0]);  \\n    }\\n    for node in (0..has_apple.len()).rev() {\\n        if has_apple[node] && !visited[node] && node != 0 {\\n            let mut curr = node;\\n            let mut min = curr as i32;\\n            let mut length = 0;\\n            while curr != 0 {\\n                if visited[curr] {\\n                    break;\\n                }\\n                visited[curr] = true;\\n                for i in 0..graph[curr].len() {\\n                    let val = graph[curr][i];\\n                    min = if val < min {val} else {min};\\n                }\\n                curr = min as usize;\\n                length += 1;\\n            }\\n            res += length;\\n        }\\n    }\\n    res*2\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn min_time(n: i32, edges: Vec<Vec<i32>>, has_apple: Vec<bool>) -> i32 {\\n    let mut graph : Vec<Vec<i32>> = vec![Vec::new();n as usize];\\n    let mut visited = vec![false;n as usize];\\n    let mut res = 0;\\n    for edge in edges.into_iter() {\\n        graph[edge[0] as usize].push(edge[1]);  \\n        graph[edge[1] as usize].push(edge[0]);  \\n    }\\n    for node in (0..has_apple.len()).rev() {\\n        if has_apple[node] && !visited[node] && node != 0 {\\n            let mut curr = node;\\n            let mut min = curr as i32;\\n            let mut length = 0;\\n            while curr != 0 {\\n                if visited[curr] {\\n                    break;\\n                }\\n                visited[curr] = true;\\n                for i in 0..graph[curr].len() {\\n                    let val = graph[curr][i];\\n                    min = if val < min {val} else {min};\\n                }\\n                curr = min as usize;\\n                length += 1;\\n            }\\n            res += length;\\n        }\\n    }\\n    res*2\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627759,
                "title": "ruby-iterative",
                "content": "```\\n# @param {Integer} n\\n# @param {Integer[][]} edges\\n# @param {Boolean[]} has_apple\\n# @return {Integer}\\ndef min_time(_n, edges, has_apple)\\n  apples = has_apple.each_index.select { |i| has_apple[i] }\\n  tree = edges.map { |k, v| [v, k] }.to_h\\n\\n  apples.each_with_object([]) do |apple, nodes|\\n    while apple != 0\\n      nodes << apple\\n      apple = tree[apple]\\n    end\\n  end.uniq.count * 2\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[][]} edges\\n# @param {Boolean[]} has_apple\\n# @return {Integer}\\ndef min_time(_n, edges, has_apple)\\n  apples = has_apple.each_index.select { |i| has_apple[i] }\\n  tree = edges.map { |k, v| [v, k] }.to_h\\n\\n  apples.each_with_object([]) do |apple, nodes|\\n    while apple != 0\\n      nodes << apple\\n      apple = tree[apple]\\n    end\\n  end.uniq.count * 2\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 625683,
                "title": "rust-dfs-solution-with-explanation",
                "content": "\\n### Observations\\n\\n1. The graph is in a form of tree, and there is no cycles\\n2. The time of collecting apples of a node depends on and only on its children node\\n\\nOn these two facts, the first idea comes to my mind is **DFS**: at each node we check if its children has any apples, and accumulate the time of collecting apples to our final result `res`. To illustrate, let\\'s consider a child `c`,\\n1. if `c` has apple or someone from its offspring has an apple, then the total time of traversing this subtree is `2 + dfs(c)`. Here `2` means the time of walking down to `c` + the time of walking back; \\n2. none of `c` and its children has an apple, then no value is added to `res`\\n\\n\\n### Rust Solution\\nThe returned value of `dfs()` has 3 possibilities:\\n1. `dfs(c) = -1`, means `c` has no apple and none of its offspring, if any, has an apple\\n2. `dfs(c) = 0`, means `c` has an apple and it is a **leaf node**\\n3. `dfs(c) > 0`, means `c` has at least one offspring that has an apple\\n\\n```rust\\nimpl Solution {\\n    pub fn dfs(node: i32, cc: &HashMap<i32, Vec<i32>>, has_apple: &Vec<bool>) -> i32 {\\n        if !cc.contains_key(&node) {\\n            if has_apple[node as usize] { 0 } else { -1 }\\n        } else {\\n            let mut res = 0; \\n            for c in &cc[&node] {\\n                let m = Self::dfs(*c, cc, has_apple); \\n                res += if m >= 0 { m + 2 } else { 0 };\\n            }\\n            if res > 0 || has_apple[node as usize] { res } else { -1 }\\n        }\\n    }\\n\\n    pub fn min_time(n: i32, edges: Vec<Vec<i32>>, has_apple: Vec<bool>) -> i32 {\\n        let mut cc:HashMap<i32, Vec<i32>> = HashMap::new();\\n        for e in edges.iter() {\\n            if !cc.contains_key(&e[0]){\\n                cc.insert(e[0], Vec::new());\\n            }\\n            cc.get_mut(&e[0]).unwrap().push(e[1]);\\n        }\\n        max(Self::dfs(0, &cc, &has_apple), 0)\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn dfs(node: i32, cc: &HashMap<i32, Vec<i32>>, has_apple: &Vec<bool>) -> i32 {\\n        if !cc.contains_key(&node) {\\n            if has_apple[node as usize] { 0 } else { -1 }\\n        } else {\\n            let mut res = 0; \\n            for c in &cc[&node] {\\n                let m = Self::dfs(*c, cc, has_apple); \\n                res += if m >= 0 { m + 2 } else { 0 };\\n            }\\n            if res > 0 || has_apple[node as usize] { res } else { -1 }\\n        }\\n    }\\n\\n    pub fn min_time(n: i32, edges: Vec<Vec<i32>>, has_apple: Vec<bool>) -> i32 {\\n        let mut cc:HashMap<i32, Vec<i32>> = HashMap::new();\\n        for e in edges.iter() {\\n            if !cc.contains_key(&e[0]){\\n                cc.insert(e[0], Vec::new());\\n            }\\n            cc.get_mut(&e[0]).unwrap().push(e[1]);\\n        }\\n        max(Self::dfs(0, &cc, &has_apple), 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624943,
                "title": "python-short-and-sweet-no-tricks",
                "content": "```\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        graph = defaultdict(list)\\n        for i,j in edges:  graph[i].append(j)\\n\\t\\t\\t\\n        def length(node):\\n            out = 0\\n            for child in graph[node]:\\n                childLenth= length(child)\\n\\t\\t\\t\\t// child has apple or any of children do\\n                if hasApple[child] or childLenth >0: out+=(1+childLenth)\\n            return out\\n\\n        return length(0)*2\\n```",
                "solutionTags": [],
                "code": "```\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        graph = defaultdict(list)\\n        for i,j in edges:  graph[i].append(j)\\n\\t\\t\\t\\n        def length(node):\\n            out = 0\\n            for child in graph[node]:\\n                childLenth= length(child)\\n\\t\\t\\t\\t// child has apple or any of children do\\n                if hasApple[child] or childLenth >0: out+=(1+childLenth)\\n            return out\\n\\n        return length(0)*2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 624041,
                "title": "c-solution-using-dfs-beginner-guide",
                "content": "```\\nclass Solution {\\npublic:\\n     vector<vector<int>>v;\\n    int simple_dfs(vector<bool>& hasApple,int src){\\n        int time=0;\\n        \\n        for(auto i:v[src]){\\n            \\n            int apple=simple_dfs(hasApple,i);\\n            \\n            if(hasApple[i]==1||apple>0)time+=(apple+2);\\n        }\\n        \\n        return time;\\n        \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n       \\n        v.assign(n,vector<int>());\\n        \\n        for(int i=0;i<edges.size();i++){\\n            v[edges[i][0]].push_back(edges[i][1]);\\n            \\n        }\\n        \\n        return simple_dfs(hasApple,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<vector<int>>v;\\n    int simple_dfs(vector<bool>& hasApple,int src){\\n        int time=0;\\n        \\n        for(auto i:v[src]){\\n            \\n            int apple=simple_dfs(hasApple,i);\\n            \\n            if(hasApple[i]==1||apple>0)time+=(apple+2);\\n        }\\n        \\n        return time;\\n        \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        \\n       \\n        v.assign(n,vector<int>());\\n        \\n        for(int i=0;i<edges.size();i++){\\n            v[edges[i][0]].push_back(edges[i][1]);\\n            \\n        }\\n        \\n        return simple_dfs(hasApple,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623902,
                "title": "c-dfs-add-time-at-each-level-if-apple-is-found",
                "content": "```csharp\\npublic int MinTime(int n, int[][] edges, IList<bool> hasA)\\n{\\n\\tbool[] hasApple = hasA.ToArray();\\n\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tgraph.Add(i, new List<int>());\\n\\t}\\n\\n\\tforeach (var edge in edges)\\n\\t{\\n\\t\\tgraph[edge[0]].Add(edge[1]);\\n\\t\\tgraph[edge[1]].Add(edge[0]);\\n\\t}\\n\\n\\tbool[] visited = new bool[n];\\n\\tint count = dfs(graph, 0, visited, hasApple);\\n\\treturn count;\\n}\\n\\nprivate int dfs(Dictionary<int, List<int>> graph, int node, bool[] visited, bool[] hasApple)\\n{\\n\\tvisited[node] = true;\\n\\tint distance = 0;\\n\\n\\tforeach (var neighbour in graph[node])\\n\\t{\\n\\t\\tif (!visited[neighbour])\\n\\t\\t{\\n\\t\\t\\tdistance += dfs(graph, neighbour, visited, hasApple);\\n\\t\\t}\\n\\t}\\n\\n\\tif ((distance > 0 || hasApple[node]) && node != 0)\\n\\t{\\n\\t\\tdistance += 2;\\n\\t}\\n\\n\\treturn distance;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinTime(int n, int[][] edges, IList<bool> hasA)\\n{\\n\\tbool[] hasApple = hasA.ToArray();\\n\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tgraph.Add(i, new List<int>());\\n\\t}\\n\\n\\tforeach (var edge in edges)\\n\\t{\\n\\t\\tgraph[edge[0]].Add(edge[1]);\\n\\t\\tgraph[edge[1]].Add(edge[0]);\\n\\t}\\n\\n\\tbool[] visited = new bool[n];\\n\\tint count = dfs(graph, 0, visited, hasApple);\\n\\treturn count;\\n}\\n\\nprivate int dfs(Dictionary<int, List<int>> graph, int node, bool[] visited, bool[] hasApple)\\n{\\n\\tvisited[node] = true;\\n\\tint distance = 0;\\n\\n\\tforeach (var neighbour in graph[node])\\n\\t{\\n\\t\\tif (!visited[neighbour])\\n\\t\\t{\\n\\t\\t\\tdistance += dfs(graph, neighbour, visited, hasApple);\\n\\t\\t}\\n\\t}\\n\\n\\tif ((distance > 0 || hasApple[node]) && node != 0)\\n\\t{\\n\\t\\tdistance += 2;\\n\\t}\\n\\n\\treturn distance;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 623872,
                "title": "simple-java-solution-bottom-up",
                "content": "If there\\'s an apple for number - travel from the node with apple to the root.\\n Travelling is done via an Map with elements added inverse: child - parent\\n Resulting nodes visited are stored in a Set so that they don\\'t get counted multiple times.\\n \\n \\n ```\\n     public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n\\n        Map<Integer,Integer> inverseTraverseMap = new HashMap<>();\\n        for(int[] edge : edges){\\n            inverseTraverseMap.put(edge[1],edge[0]);\\n        }\\n        Set<Integer> vertxNeeded = new HashSet<>();\\n        for(int i = 1; i < hasApple.size(); i++){\\n            if(hasApple.get(i)){\\n                vertxNeeded.add(i);\\n                int nextHop = inverseTraverseMap.get(i);\\n                while(nextHop != 0){\\n                    vertxNeeded.add(nextHop);\\n                    nextHop = inverseTraverseMap.get(nextHop);\\n                }\\n            }\\n        }\\n        return vertxNeeded.size() * 2;\\n    }\\n ```",
                "solutionTags": [],
                "code": "```\\n     public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n\\n        Map<Integer,Integer> inverseTraverseMap = new HashMap<>();\\n        for(int[] edge : edges){\\n            inverseTraverseMap.put(edge[1],edge[0]);\\n        }\\n        Set<Integer> vertxNeeded = new HashSet<>();\\n        for(int i = 1; i < hasApple.size(); i++){\\n            if(hasApple.get(i)){\\n                vertxNeeded.add(i);\\n                int nextHop = inverseTraverseMap.get(i);\\n                while(nextHop != 0){\\n                    vertxNeeded.add(nextHop);\\n                    nextHop = inverseTraverseMap.get(nextHop);\\n                }\\n            }\\n        }\\n        return vertxNeeded.size() * 2;\\n    }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 623849,
                "title": "python-o-n-9-lines-no-dfs-bfs-very-fast-simple-iteration-with-complete-explanation",
                "content": "The way it works is to sum up twice the depth of just those nodes having apple, making sure not double counting. \\nPlease note that it does not count the node **0** even if it has an apple (as its depth is 0).\\n\\n```\\nclass Solution:\\n    def minTime(self, n, edges, hasApple):\\n        d = {a: [b, 0] for b, a in edges}          #--> Constructs \"child to parent\" map. \"0\" means child has not been counted yet, \"1\" will mean it is counted\\n        ans = 0\\n        for node, a in enumerate(hasApple):        #--> Loops through \"hasApple\" \\n            if a and node in d:                    #--> Considers only \"apple\" nodes \\n                while node and not d[node][1]:     #--> Iterates from the \"apple\" node up until before node \"0\" or a previously counted node\\n                    d[node][1] = 1                 #--> Flags the node with \"1\" meaning counted, to NOT double count it later \\n                    ans += 2                       #--> Adds 2 since every node is reached at twice  \\n                    node = d[node][0]              #--> Goes one level up\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minTime(self, n, edges, hasApple):\\n        d = {a: [b, 0] for b, a in edges}          #--> Constructs \"child to parent\" map. \"0\" means child has not been counted yet, \"1\" will mean it is counted\\n        ans = 0\\n        for node, a in enumerate(hasApple):        #--> Loops through \"hasApple\" \\n            if a and node in d:                    #--> Considers only \"apple\" nodes \\n                while node and not d[node][1]:     #--> Iterates from the \"apple\" node up until before node \"0\" or a previously counted node\\n                    d[node][1] = 1                 #--> Flags the node with \"1\" meaning counted, to NOT double count it later \\n                    ans += 2                       #--> Adds 2 since every node is reached at twice  \\n                    node = d[node][0]              #--> Goes one level up\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623708,
                "title": "java-explained-graph-dfs",
                "content": "```\\nstatic HashMap<Integer, LinkedList<Integer>> g;\\nstatic List<Boolean> hasApple;\\n\\n  public static int minTime(int n, int[][] edges, List<Boolean> _hasApple) {\\n    g = new HashMap<>();\\n    hasApple = _hasApple;\\n    for (int[] e : edges) {\\n\\t  //Build Graph using edges\\n      g.putIfAbsent(e[0], new LinkedList<>());\\n      g.get(e[0]).add(e[1]);\\n    }\\n    return dfs(0);\\n  } \\n  \\n  private static int dfs(int pos) {\\n    int childCount = 0;\\n    if (g.containsKey(pos))//check if its leafNode\\n\\t\\tfor (int child : g.get(pos))//if not leafnode go for child nodes\\n\\t\\t\\tchildCount += dfs(child);\\n    if (childCount == 0) {\\n\\t//childCount will be 0 if leaf node\\n\\t//if has apple return 2 \\n      return hasApple.get(pos) ? 2 : 0;\\n    } else {\\n\\t//otherwise return childern status\\n      return childCount + (pos == 0 ? 0 : 2);\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\nstatic HashMap<Integer, LinkedList<Integer>> g;\\nstatic List<Boolean> hasApple;\\n\\n  public static int minTime(int n, int[][] edges, List<Boolean> _hasApple) {\\n    g = new HashMap<>();\\n    hasApple = _hasApple;\\n    for (int[] e : edges) {\\n\\t  //Build Graph using edges\\n      g.putIfAbsent(e[0], new LinkedList<>());\\n      g.get(e[0]).add(e[1]);\\n    }\\n    return dfs(0);\\n  } \\n  \\n  private static int dfs(int pos) {\\n    int childCount = 0;\\n    if (g.containsKey(pos))//check if its leafNode\\n\\t\\tfor (int child : g.get(pos))//if not leafnode go for child nodes\\n\\t\\t\\tchildCount += dfs(child);\\n    if (childCount == 0) {\\n\\t//childCount will be 0 if leaf node\\n\\t//if has apple return 2 \\n      return hasApple.get(pos) ? 2 : 0;\\n    } else {\\n\\t//otherwise return childern status\\n      return childCount + (pos == 0 ? 0 : 2);\\n    }\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3626351,
                "title": "easy-c-soluton-using-vector",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe provided code implements a depth-first search (DFS) approach to solve the problem of finding the minimum time required to collect all the apples in a tree. Here\\'s a breakdown of the code:\\n\\nThe minTime function takes the number of nodes (n), a list of edges (edges), and a list of boolean values indicating the presence of apples in each node (hasApple) as input.\\n\\nIt initializes an adjacency list (adj) to represent the tree structure based on the provided edges. Each node is connected to its adjacent nodes through the edges.\\n\\nThe visited vector is initialized to keep track of visited nodes during the DFS traversal.\\n\\nThe dfs function is a recursive function that performs the DFS traversal. It takes the current node, the cost to reach that node (mycost), the hasApple list, and the adjacency list (adj) as input.\\n\\nIn the dfs function, if the current node has already been visited, it returns 0 to avoid revisiting the same node.\\n\\nIf the current node has not been visited, it marks it as visited and initializes a variable childcost to 0. Then, it recursively calls the dfs function for each child node and adds up the costs returned by the child nodes to childcost.\\n\\nAfter the DFS traversal of all child nodes, if childcost is 0 and the current node does not have an apple (hasApple[node] is false), it means there are no apples in the subtree rooted at this node. In such a case, the function returns 0.\\n\\nFinally, the function returns the sum of mycost and childcost, which represents the total time required to collect all the apples in the subtree rooted at the current node.\\n\\nIn the minTime function, the visited vector is initialized, and the DFS traversal is started from the root node (0) with an initial cost of 0.\\n\\nThe minimum time required to collect all the apples is returned as the result.\\n\\nOverall, the code performs a depth-first search to traverse the tree and calculates the time required to collect all the apples in the tree by summing up the costs along the path from the root node to each apple node. The approach assumes that the tree is connected and acyclic.\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<bool>visited;\\nint dfs(int node,int mycost,vector<bool>& hasApple, vector<vector<int >>&adj)\\n{\\n    // IF NODE IS ALREADY VISITED THEN RETURN 0 \\n    if(visited[node]==true)\\n     return 0;\\n    // IF NODE IS NOT VISITED THEN MARK IT TRUE \\n    visited[node]=true;\\n    int childcost=0;\\n    for(auto c:adj[node])\\n    {\\n        childcost+=dfs(c,2,hasApple,adj);\\n    }\\n    if(childcost == 0 && !hasApple[node])\\n    {\\n        return 0;\\n    }\\n    return mycost+childcost;\\n}\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple)\\n    {\\n        vector<vector<int >>adj(n,vector<int>(0,-1));\\n        for(auto x: edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i =0;i<n ;i++)\\n        {\\n            visited.push_back(false);\\n        }\\n        int time =0;\\n        time = dfs(0,0,hasApple,adj);\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<bool>visited;\\nint dfs(int node,int mycost,vector<bool>& hasApple, vector<vector<int >>&adj)\\n{\\n    // IF NODE IS ALREADY VISITED THEN RETURN 0 \\n    if(visited[node]==true)\\n     return 0;\\n    // IF NODE IS NOT VISITED THEN MARK IT TRUE \\n    visited[node]=true;\\n    int childcost=0;\\n    for(auto c:adj[node])\\n    {\\n        childcost+=dfs(c,2,hasApple,adj);\\n    }\\n    if(childcost == 0 && !hasApple[node])\\n    {\\n        return 0;\\n    }\\n    return mycost+childcost;\\n}\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple)\\n    {\\n        vector<vector<int >>adj(n,vector<int>(0,-1));\\n        for(auto x: edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i =0;i<n ;i++)\\n        {\\n            visited.push_back(false);\\n        }\\n        int time =0;\\n        time = dfs(0,0,hasApple,adj);\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275528,
                "title": "dfs-very-easy-to-understand-must-see",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>adj;\\n    int minTime(int n, vector<vector<int>>& arr, vector<bool>& hasApple) \\n    {\\n        //making the adjacency list\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int u = arr[i][0];\\n            int v = arr[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int count = 0;\\n        for(int i=0;i<adj[0].size();i++)\\n        {\\n            //to keep the track of visited during the dfs \\n            unordered_set<int>st;\\n            int child = adj[0][i];\\n            st.insert(0);\\n\\n            count = count + dfs(child,st,hasApple);\\n        }\\n        return count;\\n    }\\n    int dfs(int child,unordered_set<int>&st,vector<bool>& hasApple)\\n    {\\n        int count = 0;\\n        st.insert(child);\\n        for(auto it : adj[child])\\n        {\\n            if(st.find(it) == st.end())\\n            {\\n                st.insert(it);\\n                count = count + dfs(it,st,hasApple);              \\n            }\\n        }\\n        int val = count;\\n        if(hasApple[child] == true)\\n        {\\n            val = val + 1;\\n        }\\n        else \\n        {\\n            val = val + 0;\\n        }\\n\\n        if(val > 0)\\n        return count+2;\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>adj;\\n    int minTime(int n, vector<vector<int>>& arr, vector<bool>& hasApple) \\n    {\\n        //making the adjacency list\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int u = arr[i][0];\\n            int v = arr[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int count = 0;\\n        for(int i=0;i<adj[0].size();i++)\\n        {\\n            //to keep the track of visited during the dfs \\n            unordered_set<int>st;\\n            int child = adj[0][i];\\n            st.insert(0);\\n\\n            count = count + dfs(child,st,hasApple);\\n        }\\n        return count;\\n    }\\n    int dfs(int child,unordered_set<int>&st,vector<bool>& hasApple)\\n    {\\n        int count = 0;\\n        st.insert(child);\\n        for(auto it : adj[child])\\n        {\\n            if(st.find(it) == st.end())\\n            {\\n                st.insert(it);\\n                count = count + dfs(it,st,hasApple);              \\n            }\\n        }\\n        int val = count;\\n        if(hasApple[child] == true)\\n        {\\n            val = val + 1;\\n        }\\n        else \\n        {\\n            val = val + 0;\\n        }\\n\\n        if(val > 0)\\n        return count+2;\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084463,
                "title": "python-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = defaultdict(list)\\n        for par,child in edges:\\n            adj[par].append(child)\\n            adj[child].append(par)\\n        visited=set()\\n\\n        def dfs(curr):\\n            time=0\\n            visited.add(curr)\\n            for adj_node in adj[curr]:\\n                if adj_node in visited:\\n                    continue\\n                childTime=dfs(adj_node)\\n                if childTime or hasApple[adj_node]:\\n                    time+=2+childTime\\n            return time\\n                \\n            \\n        return dfs(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = defaultdict(list)\\n        for par,child in edges:\\n            adj[par].append(child)\\n            adj[child].append(par)\\n        visited=set()\\n\\n        def dfs(curr):\\n            time=0\\n            visited.add(curr)\\n            for adj_node in adj[curr]:\\n                if adj_node in visited:\\n                    continue\\n                childTime=dfs(adj_node)\\n                if childTime or hasApple[adj_node]:\\n                    time+=2+childTime\\n            return time\\n                \\n            \\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057746,
                "title": "easy-to-understand-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->At first we go to the deepest node using dfs and then check whether \"hasApple\" is true ,if true then we add (+2) to the answer and make hasApple of parent of that node is true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    static int ans;\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        ans = 0;\\n        ArrayList<ArrayList<Integer>> al = new ArrayList<>();\\n        Boolean vis[] = new Boolean[n];\\n        for(int i=0;i<n;i++)\\n         vis[i] = false;\\n        for(int i=0;i<n;i++)\\n         al.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++){\\n            al.get(edges[i][0]).add(edges[i][1]);\\n            al.get(edges[i][1]).add(edges[i][0]);\\n        } \\n           dfs(al,vis,0,hasApple);\\n           return ans;                           \\n    }\\n    public static void dfs(ArrayList<ArrayList<Integer>> adj,Boolean vis[],int node,List<Boolean> hasApple){\\n        vis[node] = true;\\n        for(int ele : adj.get(node))\\n        {\\n            if(vis[ele]==false)\\n            {\\n                dfs(adj,vis,ele,hasApple);\\n            \\n            if(hasApple.get(ele)){\\n              ans+=2;\\n              hasApple.set(node,true);\\n             }\\n            }\\n        }\\n        \\n     }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int ans;\\n    public int minTime(int n, int[][] edges, List<Boolean> hasApple) {\\n        ans = 0;\\n        ArrayList<ArrayList<Integer>> al = new ArrayList<>();\\n        Boolean vis[] = new Boolean[n];\\n        for(int i=0;i<n;i++)\\n         vis[i] = false;\\n        for(int i=0;i<n;i++)\\n         al.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++){\\n            al.get(edges[i][0]).add(edges[i][1]);\\n            al.get(edges[i][1]).add(edges[i][0]);\\n        } \\n           dfs(al,vis,0,hasApple);\\n           return ans;                           \\n    }\\n    public static void dfs(ArrayList<ArrayList<Integer>> adj,Boolean vis[],int node,List<Boolean> hasApple){\\n        vis[node] = true;\\n        for(int ele : adj.get(node))\\n        {\\n            if(vis[ele]==false)\\n            {\\n                dfs(adj,vis,ele,hasApple);\\n            \\n            if(hasApple.get(ele)){\\n              ans+=2;\\n              hasApple.set(node,true);\\n             }\\n            }\\n        }\\n        \\n     }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046268,
                "title": "c-easy-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&graph,vector<bool>&hasApple,int parent,int node,int cost){\\n        int sum = 0;\\n        bool flg = hasApple[node];\\n\\n        for(auto val:graph[node]){\\n            if(val!=parent){\\n                sum+=solve(graph,hasApple,node,val,2);\\n            }\\n        }\\n// sum>0 will be true if sum>0 in the root of that node (if there is an apple in root), \\n// flg if there is apple on node\\n        if(sum>0 || flg) \\n        return sum+cost;\\n        return 0;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>>graph(n,vector<int>());\\n        for(auto val:edges){\\n            graph[val[0]].push_back(val[1]);\\n            graph[val[1]].push_back(val[0]);\\n        }\\n        return solve(graph,hasApple,-1,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&graph,vector<bool>&hasApple,int parent,int node,int cost){\\n        int sum = 0;\\n        bool flg = hasApple[node];\\n\\n        for(auto val:graph[node]){\\n            if(val!=parent){\\n                sum+=solve(graph,hasApple,node,val,2);\\n            }\\n        }\\n// sum>0 will be true if sum>0 in the root of that node (if there is an apple in root), \\n// flg if there is apple on node\\n        if(sum>0 || flg) \\n        return sum+cost;\\n        return 0;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>>graph(n,vector<int>());\\n        for(auto val:edges){\\n            graph[val[0]].push_back(val[1]);\\n            graph[val[1]].push_back(val[0]);\\n        }\\n        return solve(graph,hasApple,-1,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041246,
                "title": "c-solution-dfs-99-faster-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstruct a graph in the form of Adjacency List. Use the standard DFS approach using a visited vector. Return value of DFS function is boolean, which tells whether the subtree of the node contains an apple or not. If the subtree of that node contains an apple, the time is increased by 2, to account for both incoming and outgoing edges.\\nThe final value of the time thus obtained is minimum.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwhere n = number of nodes\\n\\n# Code\\n```\\nclass Solution {\\n    bool dfs(vector<int> adj[], int vertex, vector<bool>& hasApple, int& time, vector<bool>& vis){\\n        // mark the vertex as visited\\n        vis[vertex] = true; \\n\\n        // if the vertex itself contains an apple, initialize found to true, false otherwise\\n        bool found = hasApple[vertex]; \\n\\n        // check if each adjacent node that has not been visited contains an apple or not\\n        for(auto& neigh : adj[vertex]){ \\n            if(vis[neigh] == false){\\n\\n        // if any of the adjacent nodes contains an apple in its subtree, make found as true and increase time by 2 units to account for both incoming and outgoing edges\\n                if(dfs(adj, neigh, hasApple, time, vis) == true){   \\n                    found = true;\\n                    time += 2;\\n                }\\n            }\\n        }\\n\\n        // return the value of found, which indicates whether an apple was found in the subtree or not\\n        return found; \\n    }\\n\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple){\\n        // construct adjacency list from edges\\n        vector<int> adj[n]; \\n\\n        for(auto& e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        // checks if the node has been visited earlier\\n        vector<bool> vis(n, false); \\n\\n        // keeps track of total time taken to collect all apples\\n        int time = 0; \\n\\n        // a dfs call starting from vertex 0\\n        dfs(adj, 0, hasApple, time, vis); \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(vector<int> adj[], int vertex, vector<bool>& hasApple, int& time, vector<bool>& vis){\\n        // mark the vertex as visited\\n        vis[vertex] = true; \\n\\n        // if the vertex itself contains an apple, initialize found to true, false otherwise\\n        bool found = hasApple[vertex]; \\n\\n        // check if each adjacent node that has not been visited contains an apple or not\\n        for(auto& neigh : adj[vertex]){ \\n            if(vis[neigh] == false){\\n\\n        // if any of the adjacent nodes contains an apple in its subtree, make found as true and increase time by 2 units to account for both incoming and outgoing edges\\n                if(dfs(adj, neigh, hasApple, time, vis) == true){   \\n                    found = true;\\n                    time += 2;\\n                }\\n            }\\n        }\\n\\n        // return the value of found, which indicates whether an apple was found in the subtree or not\\n        return found; \\n    }\\n\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple){\\n        // construct adjacency list from edges\\n        vector<int> adj[n]; \\n\\n        for(auto& e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        // checks if the node has been visited earlier\\n        vector<bool> vis(n, false); \\n\\n        // keeps track of total time taken to collect all apples\\n        int time = 0; \\n\\n        // a dfs call starting from vertex 0\\n        dfs(adj, 0, hasApple, time, vis); \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039983,
                "title": "easy-and-cool-explanation-dfs-without-set-gauravthinks",
                "content": "# Intuition\\n- Intution is simple, we keep two pointers which ultimately tells us, whether,we have reached the leaf node or not, and return the distance if the current node has apple in it.\\n- For the inner node, having apples below it, is checked if the return value is> 0 or current node itself possess some apple in it, then retun the distance= ans+ count+1;\\n- you\\'ll get better idea if you dry run the below code with pen and paper\\n- ALSO, DO REMEMBER, THE QUESTION SAYS EDGES, SO IT IS A QUESTION OF GRAPH, NOT TREE.(for simpler understanding)\\n# Approach\\nwe do it by simple DFS\\n\\n# Complexity\\n- Time complexity:\\n    # O(N+N-1)\\n\\n- Space complexity:\\nwe use extra space for storing the adjacency list, so space complexity becomes,\\n    # O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    int helper(vector<int> adj[], vector<bool> &apple, int node, int pre){\\n        int cnt=0; \\n        // NOTE****: DO A DRY RUN OF THE BELOW CODE, FOR THE GIVEN EXAMPLES, YOU\\'LL GET A BETTER IDEA OF WHAT ACUTALLY WE ARE DOING\\n        for(auto it: adj[node]){  // we iterate over the adj[node]\\n                if(it!=pre){  //  if the current iterator node is not equal to the prev. node, then we again iterate over the next node adj[node]\\n                  int ans= helper(adj, apple, it, node);\\n                // else if the current iterator node is equal to the prev node, then it means, we are at the leaf node, and we have to return to above node before checking the condition, whether the node has apple or not\\n                    if(ans>0 or apple[it]==1){ \\n                        // this is the returning condition \\n                        cnt= cnt + ans +1;\\n                    }\\n                }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        // making an adjacency list to store the graph for traversal\\n        vector<int> adj[n];\\n        for(auto it: edges){\\n            int u= it[0];\\n            int v= it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        // applying dfs\\n        //helper(ajdacency list, has apple, current node, prevnode);\\n        int res= helper(adj, hasApple, 0, -1);\\n        return res*2;\\n    }\\n};\\n```\\n\\nIf you liked the solution and cute and simple explanation, do upvote and subscribe to the youtube channel below\\n# GauravThinks <------- youtube channel",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int helper(vector<int> adj[], vector<bool> &apple, int node, int pre){\\n        int cnt=0; \\n        // NOTE****: DO A DRY RUN OF THE BELOW CODE, FOR THE GIVEN EXAMPLES, YOU\\'LL GET A BETTER IDEA OF WHAT ACUTALLY WE ARE DOING\\n        for(auto it: adj[node]){  // we iterate over the adj[node]\\n                if(it!=pre){  //  if the current iterator node is not equal to the prev. node, then we again iterate over the next node adj[node]\\n                  int ans= helper(adj, apple, it, node);\\n                // else if the current iterator node is equal to the prev node, then it means, we are at the leaf node, and we have to return to above node before checking the condition, whether the node has apple or not\\n                    if(ans>0 or apple[it]==1){ \\n                        // this is the returning condition \\n                        cnt= cnt + ans +1;\\n                    }\\n                }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        // making an adjacency list to store the graph for traversal\\n        vector<int> adj[n];\\n        for(auto it: edges){\\n            int u= it[0];\\n            int v= it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        // applying dfs\\n        //helper(ajdacency list, has apple, current node, prevnode);\\n        int res= helper(adj, hasApple, 0, -1);\\n        return res*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039738,
                "title": "c-union-find-like-traversal-100-time-88ms-100-space-49-1mb",
                "content": "Funny litle problem that can be solved in a nummber of way - the most common of them being building an actual tree to traverse and go at it with a DFS.\\n\\nBut that stroke me as rather dull and not necessarily very performing.\\n\\nI wanted to build something different, considering that we might only keep track of the parent of each node and then go the other way around - from each node with an apple up to the root, or, more generally, from node to its parent, all the time as we would do in a Union Find (AKA \"Disjoint Set\").\\n\\nIf we can do that, then the rest becomes rather easy: we swim up like a salmon (or the pointer of a linked list, but I felt the ichthyic analogy was more fitting) until either we reach the root or we reach another node with an appple we already explored before (and thus, as per specs, we don\\'t need to reach again).\\n\\nTo do so, we will start as usual with a few support variables:\\n* `parent` is an array of size `n` to store what node is the parent of each node;\\n* `res` is our usual accumulator variable to count the steps necessary to reach each apple, initially set to `0`;\\n* `a` and `b` are support variabless we will use when parsing all the edges;\\n* `unexplored` is a boolean array again of size `n` to keep track of what nodes we visited already.\\n\\nAnd with `unexplored` we will start indeed, counterintuitively setting all the nodes to `false` but root (the node `0`, that we set to `true`), as if we explored them already, since this will help us in a momment parsing all the connections.\\n\\nThen, for each `edge` in `edges`, we will:\\n* assign the values `edge[0]` and `edge[1]` to `a` and `b` respectively, for efficiency purpose;\\n* check if `a` was previously flagged as ready to be explored in the following main loop (ie: `unexplored[a] == true`) and if so we know that `a` was already set to be a parent, so `b` has to be the child and we will:\\n    * set `a` to be `b`\\'s parent (ie: `parent[b] = a`);\\n    * mark `b` as now ready to be visited later;\\n* conversely we will:\\n    * set `b` to be `a`\\'s parent (ie: `parent[a] = b`);\\n    * mark `a` as now ready to be visited later.\\n\\nAfter having prepared our graph to parse and after flagging the node `0` back to explored (ie: `unexplored[0] = false`), we can finally do our cheaper traversal, going with `i` through each element in `apples` and, as soon as we find one (ie: `apples[i] == true`), we will:\\n* copy `i` in `node`;\\n* loop `while` `node` is not visited yet (ie `unexplored[node] == true`) and:\\n    * increase `res` by `1`;\\n    * mark `node` as visited (ie: `unexplored[node] = false`);\\n    * advance `node` by one position (ie `node = parent[node]`).\\n\\nOnce done, since we only counted how many steps it would take to reach each apple and we need instead how many we would need to go back to root, we will just `return` double that value: `res << 1`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>> &edges, vector<bool> &apples) {\\n        // support variables\\n        int parent[n], res = 0, a, b;\\n        bool unexplored[n];\\n        // preparing unexplored\\n        fill(unexplored, unexplored + n, false);\\n        unexplored[0] = true;\\n        // parsing edges\\n        parent[0] = 0;\\n        for (auto &edge: edges) {\\n            a = edge[0], b = edge[1];\\n            if (unexplored[a]) parent[b] = a, unexplored[b] = true;\\n            else parent[a] = b, unexplored[a] = true;\\n        }\\n        unexplored[0] = false;\\n        // parsing apples\\n        for (int i = 0, node, len = apples.size(); i < len; i++) {\\n            if (apples[i]) {\\n                node = i;\\n                // checking unexplored paths\\n                while (unexplored[node]) {\\n                    res++;\\n                    // marking it as visited\\n                    unexplored[node] = false;\\n                    // advancing node\\n                    node = parent[node];\\n                }\\n            }\\n        }\\n        return res << 1;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/ee3f34aa-ddb4-470f-b534-c9f62487acd1_1673513666.893036.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Union Find"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minTime(int n, vector<vector<int>> &edges, vector<bool> &apples) {\\n        // support variables\\n        int parent[n], res = 0, a, b;\\n        bool unexplored[n];\\n        // preparing unexplored\\n        fill(unexplored, unexplored + n, false);\\n        unexplored[0] = true;\\n        // parsing edges\\n        parent[0] = 0;\\n        for (auto &edge: edges) {\\n            a = edge[0], b = edge[1];\\n            if (unexplored[a]) parent[b] = a, unexplored[b] = true;\\n            else parent[a] = b, unexplored[a] = true;\\n        }\\n        unexplored[0] = false;\\n        // parsing apples\\n        for (int i = 0, node, len = apples.size(); i < len; i++) {\\n            if (apples[i]) {\\n                node = i;\\n                // checking unexplored paths\\n                while (unexplored[node]) {\\n                    res++;\\n                    // marking it as visited\\n                    unexplored[node] = false;\\n                    // advancing node\\n                    node = parent[node];\\n                }\\n            }\\n        }\\n        return res << 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037839,
                "title": "python-dfs-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will use dfs to solve this question. keep track of the path in dfs. \\nwe will also use a set data structure to keep only unique path of the nodes which are apples\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(ElogV)$$\\nE - no. of edges\\nV - no. of vertices\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(E)$$ \\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        def dfs(source, visited, adj, path):\\n            nonlocal unique\\n            path.append(source)\\n            # print(path)\\n            if hasApple[source]:\\n                for i in range(len(path)-1,0,-1):\\n                    if (path[i-1], path[i]) not in unique:\\n                        unique.add((path[i-1], path[i]))\\n                    else:\\n                        break\\n            for nbr in adj[source]:\\n                if nbr not in visited:\\n                    visited.add(nbr)\\n                    dfs(nbr, visited, adj, path.copy())\\n        path = []\\n        unique = set()\\n        adj = defaultdict(list)\\n        for edge in edges:\\n            u, v = edge\\n            adj[u] += [v]\\n            adj[v] += [u]\\n        visited = set()\\n        visited.add(0)\\n        dfs(0, visited, adj, path)\\n        # print(unique)\\n        return 2 * len(unique)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        def dfs(source, visited, adj, path):\\n            nonlocal unique\\n            path.append(source)\\n            # print(path)\\n            if hasApple[source]:\\n                for i in range(len(path)-1,0,-1):\\n                    if (path[i-1], path[i]) not in unique:\\n                        unique.add((path[i-1], path[i]))\\n                    else:\\n                        break\\n            for nbr in adj[source]:\\n                if nbr not in visited:\\n                    visited.add(nbr)\\n                    dfs(nbr, visited, adj, path.copy())\\n        path = []\\n        unique = set()\\n        adj = defaultdict(list)\\n        for edge in edges:\\n            u, v = edge\\n            adj[u] += [v]\\n            adj[v] += [u]\\n        visited = set()\\n        visited.add(0)\\n        dfs(0, visited, adj, path)\\n        # print(unique)\\n        return 2 * len(unique)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037806,
                "title": "very-simple-c-solution-beats-95",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int v, int parent) {\\n        int ans = 0;\\n        // Explore the child nodes\\n        for(auto &next : adj[v]) {\\n            // Don\\'t explore the node\\n            // from which we reached the current one\\n            if(next == parent) continue;\\n\\n            // d is the number of steps it takes to collect\\n            // all the apples in the subtree whose root is \"next\" and return\\n            int d = dfs(next, v);\\n\\n            // Don\\'t even consider a subtree if it doesn\\'t have apples.\\n            \\n            // We need to go into the \"next\" node, collect all the apples (takes d steps) \\n            // and come back. So 1 + d + 1 = d + 2 steps\\n\\n            // Also mark the node we are currently exploring as an apple node\\n            // so that we don\\'t discard it as we go up the tree\\n            if(hasApple[next]) ans += d + 2, hasApple[v] = 1;\\n        }\\n        return ans;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& _hasApple) {\\n        adj.resize(n);\\n        hasApple = _hasApple;\\n        // Build an adjecency list\\n        for(auto &e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        return dfs(0, -1);\\n    }\\nprivate:\\n    vector<vector<int>> adj;\\n    vector<bool> hasApple;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int v, int parent) {\\n        int ans = 0;\\n        // Explore the child nodes\\n        for(auto &next : adj[v]) {\\n            // Don\\'t explore the node\\n            // from which we reached the current one\\n            if(next == parent) continue;\\n\\n            // d is the number of steps it takes to collect\\n            // all the apples in the subtree whose root is \"next\" and return\\n            int d = dfs(next, v);\\n\\n            // Don\\'t even consider a subtree if it doesn\\'t have apples.\\n            \\n            // We need to go into the \"next\" node, collect all the apples (takes d steps) \\n            // and come back. So 1 + d + 1 = d + 2 steps\\n\\n            // Also mark the node we are currently exploring as an apple node\\n            // so that we don\\'t discard it as we go up the tree\\n            if(hasApple[next]) ans += d + 2, hasApple[v] = 1;\\n        }\\n        return ans;\\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& _hasApple) {\\n        adj.resize(n);\\n        hasApple = _hasApple;\\n        // Build an adjecency list\\n        for(auto &e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        return dfs(0, -1);\\n    }\\nprivate:\\n    vector<vector<int>> adj;\\n    vector<bool> hasApple;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037752,
                "title": "solution-swift-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minTime(_ n: Int, _ edges: [[Int]], _ hasApple: [Bool]) -> Int {\\n        var adjacencyList: [[Int]] = Array(repeating: [], count: n)\\n        \\n        for edge in edges {\\n            let currentNode = edge[0]\\n            let neighbour = edge[1]\\n            \\n            adjacencyList[currentNode].append(neighbour)\\n            adjacencyList[neighbour].append(currentNode)\\n        }\\n        \\n        return dfs(adjacencyList, hasApple, 0, -1)\\n    }\\n    \\n    private func dfs(_ adjacencyList: [[Int]], _ hasApple: [Bool], _ currentNode: Int, _ parentNode: Int) -> Int {\\n        var time = 0\\n        \\n        for child in adjacencyList[currentNode] {\\n            if child == parentNode { continue }\\n            \\n            let childTime = dfs(adjacencyList, hasApple, child, currentNode)\\n            \\n            if childTime != 0 || hasApple[child] {\\n                time += 2 + childTime\\n            }\\n        }\\n        return time\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func minTime(_ n: Int, _ edges: [[Int]], _ hasApple: [Bool]) -> Int {\\n        var adjacencyList: [[Int]] = Array(repeating: [], count: n)\\n        \\n        for edge in edges {\\n            let currentNode = edge[0]\\n            let neighbour = edge[1]\\n            \\n            adjacencyList[currentNode].append(neighbour)\\n            adjacencyList[neighbour].append(currentNode)\\n        }\\n        \\n        return dfs(adjacencyList, hasApple, 0, -1)\\n    }\\n    \\n    private func dfs(_ adjacencyList: [[Int]], _ hasApple: [Bool], _ currentNode: Int, _ parentNode: Int) -> Int {\\n        var time = 0\\n        \\n        for child in adjacencyList[currentNode] {\\n            if child == parentNode { continue }\\n            \\n            let childTime = dfs(adjacencyList, hasApple, child, currentNode)\\n            \\n            if childTime != 0 || hasApple[child] {\\n                time += 2 + childTime\\n            }\\n        }\\n        return time\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037676,
                "title": "easy-python3-solution-using-dfs-beats-99-on-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is to create a graph from the edges and not consider the input as a straight tree with all nodes in order.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst build the adjacency list from the edges. Then we use DFS to search for apples. For a node, we check all the children, if the result is > 0, then we just add 2 which is the cost to get to that node (we don\\'t have to add it in the case of the root node). \\n\\nIf the cost is 0, it means that none of the children have apples, so we return 2 only if the node at which we are has an apple (also only if we are not at the root).\\n\\nWe ignore if a node $$N$$ has an apple in the case any of the children of the node $$N$$ also has an apple, since in that case we are sure to pass by the node $$N$$  and get its apple.\\n# Complexity\\n- Time complexity: $$O(n)$$ since we check $$n$$ nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ because of the $$n$$ nodes that are kept in the recursive call stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = {}\\n\\n        for x, y in edges:\\n            if x not in adj:\\n                adj[x] = []\\n            if y not in adj:\\n                adj[y] = []\\n            adj[x].append(y)\\n            adj[y].append(x)\\n        \\n        def dfs(parent, val):\\n            c = 0\\n\\n            for neighbour in adj[val]:\\n                if neighbour != parent:\\n                    c += dfs(val, neighbour)\\n\\n            if c > 0:\\n                return c + 2 if val > 0 else c\\n            \\n            if hasApple[val] and val > 0:\\n                return 2\\n            \\n            return 0\\n\\n        c = dfs(None, 0)\\n\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = {}\\n\\n        for x, y in edges:\\n            if x not in adj:\\n                adj[x] = []\\n            if y not in adj:\\n                adj[y] = []\\n            adj[x].append(y)\\n            adj[y].append(x)\\n        \\n        def dfs(parent, val):\\n            c = 0\\n\\n            for neighbour in adj[val]:\\n                if neighbour != parent:\\n                    c += dfs(val, neighbour)\\n\\n            if c > 0:\\n                return c + 2 if val > 0 else c\\n            \\n            if hasApple[val] and val > 0:\\n                return 2\\n            \\n            return 0\\n\\n        c = dfs(None, 0)\\n\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037633,
                "title": "python3-beats-100-linear-time-space-w-no-hashtable",
                "content": "# Intuition\\n1. Find out every node\\'s parent node. \\n2. Traverse from each apple upward to the nearest seen node.\\n\\n# Approach\\n1. For every edge, if we have already seen the left vertex, then know that the right vertex must be its child. The same holds for the reverse. We then record that we have seen the right vertex.\\n2. Traverse the parents array from the position of an apple until we find a node that has already been seen. This approach will both account for overlap between apples taking the same path, and also reduce runtime as we at most traverse the entire tree once.\\n\\n# Time Complexity\\n1. The runtime for this section is $$O(n)$$ because we traverse edges once.\\n2. The runtime for this section is $$O(n)$$ because the outer loop runs from $$1 \\\\to n$$ and the inner while loop can at most run for another $$O(n)$$ because of the aforementioned stopping once we reach a seen node.\\n\\n# Space Complexity\\nThe memory consumed is $$O(n)$$ because we use two arrays of size $$n$$.\\n\\n# Code\\n```Python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        res: int = 0\\n        # edges.sort(key=lambda x: x[0])  not needed for the test cases\\n        # but is needed if the test cases included unsorted edges\\n        parents = [-1] * n\\n        seen = [False] * n\\n        seen[0] = True\\n\\n        for a, b in edges:\\n            if seen[a] is True:\\n                parents[b] = a\\n            else:\\n                parents[a] = b\\n\\n            seen[b] = True\\n\\n        seen = [False] * n\\n        seen[0] = True\\n\\n        for parent in range(1, n):  # 0 contributes no time regardless\\n            if hasApple[parent] is False:\\n                continue\\n            \\n            res += 1\\n            seen[parent] = True\\n            parent = parents[parent]\\n            while not seen[parent]:\\n                res += 1\\n                seen[parent] = True\\n                parent = parents[parent]\\n                          \\n        return 2 * res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```Python\\nclass Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        res: int = 0\\n        # edges.sort(key=lambda x: x[0])  not needed for the test cases\\n        # but is needed if the test cases included unsorted edges\\n        parents = [-1] * n\\n        seen = [False] * n\\n        seen[0] = True\\n\\n        for a, b in edges:\\n            if seen[a] is True:\\n                parents[b] = a\\n            else:\\n                parents[a] = b\\n\\n            seen[b] = True\\n\\n        seen = [False] * n\\n        seen[0] = True\\n\\n        for parent in range(1, n):  # 0 contributes no time regardless\\n            if hasApple[parent] is False:\\n                continue\\n            \\n            res += 1\\n            seen[parent] = True\\n            parent = parents[parent]\\n            while not seen[parent]:\\n                res += 1\\n                seen[parent] = True\\n                parent = parents[parent]\\n                          \\n        return 2 * res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037587,
                "title": "minimalist-explanation-python-dfs-recursion",
                "content": "\\n# Approach\\n1. Construct Adjacency list `graph`\\n2. Create a list `visited` of size `n` where all the values are `False` initially as we have not visited any of the nodes yet.\\n3. Traverse using DFS to reach to the apples recursively.\\n4. During traversal, mark the visited nodes to `True` otherwise you will end up getting `Maximum Recursion Depth Exceeded` due to the endless cycle.\\n5. Calculate the `total` which is the minimum time required. (Added the logic explaination in comments)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def bfs(self, graph, sv, hasApple, visited):\\n        # sv - starting vertex\\n\\n        # visited - list of visited nodes\\n        # initially all are filled False\\n        total = 0\\n        visited[sv] = True\\n        for i in graph[sv]:\\n            if not visited[i]:\\n                total += self.bfs(graph, i, hasApple, visited)\\n        \\n        # we are adding 2 to total becoz, for finding an apple,\\n        # we are traversing via an edge from top to vertex and\\n        # again reverse to top to starting vertex.\\n\\n        # starting vertex i.e 0th node has no contribution in finding an apple,\\n        # so we exclude it when calculating total - (sv != 0)\\n\\n        # total>0 becoz in 1st example consider node 1, although\\n        # it does not have an apple, its child 4 has an apple\\n        # and it is contributing it carry forwarding 2 to 0th node\\n        # so such cases are also included - (total>0)\\n        if((total>0 or hasApple[sv]) and sv!=0):\\n            total += 2\\n        return total\\n\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        graph = defaultdict(list)\\n        visited = [False]*n # visited nodes\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        total = self.bfs(graph, 0, hasApple, visited)\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bfs(self, graph, sv, hasApple, visited):\\n        # sv - starting vertex\\n\\n        # visited - list of visited nodes\\n        # initially all are filled False\\n        total = 0\\n        visited[sv] = True\\n        for i in graph[sv]:\\n            if not visited[i]:\\n                total += self.bfs(graph, i, hasApple, visited)\\n        \\n        # we are adding 2 to total becoz, for finding an apple,\\n        # we are traversing via an edge from top to vertex and\\n        # again reverse to top to starting vertex.\\n\\n        # starting vertex i.e 0th node has no contribution in finding an apple,\\n        # so we exclude it when calculating total - (sv != 0)\\n\\n        # total>0 becoz in 1st example consider node 1, although\\n        # it does not have an apple, its child 4 has an apple\\n        # and it is contributing it carry forwarding 2 to 0th node\\n        # so such cases are also included - (total>0)\\n        if((total>0 or hasApple[sv]) and sv!=0):\\n            total += 2\\n        return total\\n\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        graph = defaultdict(list)\\n        visited = [False]*n # visited nodes\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        total = self.bfs(graph, 0, hasApple, visited)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037539,
                "title": "js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {boolean[]} hasApple\\n * @return {number}\\n */\\nvar minTime = function(n, edges, hasApple) {\\n    const adj = {}\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = [];\\n    }\\n\\n    for (let i = 0; i < edges.length; i++) {\\n        [par, child] = edges[i];\\n        adj[par].push(child);\\n        adj[child].push(par);\\n    }\\n\\n   function dfs(curr, par) {\\n        let time = 0;\\n        for (let nei of adj[curr]) {\\n            if (nei === par) continue;\\n            let childTime = dfs(nei, curr);\\n            if (childTime || hasApple[nei]) {\\n                time += 2 + childTime;\\n            }\\n        }\\n        return time;\\n   }\\n\\n   return dfs(0, -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {boolean[]} hasApple\\n * @return {number}\\n */\\nvar minTime = function(n, edges, hasApple) {\\n    const adj = {}\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = [];\\n    }\\n\\n    for (let i = 0; i < edges.length; i++) {\\n        [par, child] = edges[i];\\n        adj[par].push(child);\\n        adj[child].push(par);\\n    }\\n\\n   function dfs(curr, par) {\\n        let time = 0;\\n        for (let nei of adj[curr]) {\\n            if (nei === par) continue;\\n            let childTime = dfs(nei, curr);\\n            if (childTime || hasApple[nei]) {\\n                time += 2 + childTime;\\n            }\\n        }\\n        return time;\\n   }\\n\\n   return dfs(0, -1);\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1751803,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1568348,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752078,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752067,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752454,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1751892,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752027,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1567515,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1568333,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1753194,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1751803,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1568348,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752078,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752067,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752454,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1751892,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752027,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1567515,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1568333,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1753194,
                "content": [
                    {
                        "username": "ptchen1",
                        "content": "Tip: the problem statement and sample test cases are misleading: forget the tree, and think of the problem as a graph!"
                    },
                    {
                        "username": "Rustam-Z",
                        "content": "Test case 54: `[[0,2],[0,3],[1,2]`. The edge [1,2] does not necessarily mean that node 1 is the parent of 2, but that there exists an edge between them.\n```\n     0\n   /   \\\n  3     2\n         \\\n          1\n```"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@shubhamxthakur](/shubhamxthakur) how is this constraint meaningful for the problem, however? It doesn't matter if `fromi<toi` it also doesn't matter if `ai<bi`, because it is indeed an undirected tree.\n\nThe test case [[0,2],[0,3],[1,2]] also confirms that. So there is no information to be taken from those constraints - if e.g. you wanted to eliminate all edges that lead to a parent beforehand.\n\nIn fact if we knew that `edges` will always be ordered from root to leaves we could do that, but it's not guaranteed. \n"
                    },
                    {
                        "username": "Triquetra",
                        "content": "A graph doesn\\'t have a root."
                    },
                    {
                        "username": "bej9038",
                        "content": "A tree is an acyclic graph by definition"
                    },
                    {
                        "username": "shubhamsth",
                        "content": "[@pavlic148](/pavlic148) it implies that the first element(from) in representation of an edge is smaller than the second element(to), eg [1, 2] follows this format and [2, 1] does not (but both are correct form to represent an edge in an undirected graph)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "from my knowledge, a tree is an undirected, acyclic  subset of a graph - and you can use the fact there\\'s no cycles to use a greedy algorithm, as only local decisions will need to be made"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@atl123](/atl123) Constraint `fromi < toi` is misleading. `fromi` and `toi` are not specified but the constraint looks like edges have direction."
                    },
                    {
                        "username": "orthogonal1",
                        "content": "If the graph is not a tree then this problem is NP hard in fact."
                    },
                    {
                        "username": "raghupalash",
                        "content": "It\\'s not \"misleading\" - it\\'s specified as tree here to tell us that there are no cycles in the graph."
                    },
                    {
                        "username": "akialter",
                        "content": "In graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.\\nhttps://en.wikipedia.org/wiki/Tree_(graph_theory)"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "No they are trees. Tree is the special structure of a graph."
                    },
                    {
                        "username": "atl123",
                        "content": "Neither the problem statement nor test cases are misleading; the test cases will always be trees. I believe you can still achieve optimal time complexity but your space complexity will be sub-optimal if you store a visited set rather than just storing a node\\'s parent. "
                    },
                    {
                        "username": "sakthivel_mani",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nFor only this case my code gave an wrong answer. My Question is that according to this test case vertex 2 having vertext 0 and 1 as its parent. According to tree data structure a vertext can\\'t have more than one parent. I want to know whether this test case is right or worng ?\\ncorrect me if i wrong!"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "I wrote a similar algorithm too. DO NOT assume that edges are [parent, child] form always. "
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "[@gertkommer](/gertkommer) Agree\\n"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "don\\'t think 1 as parent of 2, instead think this as 2 is the parent of 1.As the given data is only an edge not a parent->child relation. "
                    },
                    {
                        "username": "efim666",
                        "content": "[@user2242s](/user2242s) This is exactly the test case to help us find errors in code, if it has the wrong assumption about tree directionality. So it\\'s a very test and the person who added it is our friend.\\nThe one who worded the task though..."
                    },
                    {
                        "username": "indrazit",
                        "content": "I think the problem description is confusing.  It says \"from_i < to_i\", and it looks like \"in the edge, the node that closes to the root always has the lower index\", but it does not mean it at all."
                    },
                    {
                        "username": "mensenvau",
                        "content": " \\nif(check[edges[i][1]]==0) { \\n        mp[edges[i][1]] = edges[i][0];\\n       check[edges[i][1]] = 1;\\n} else {\\n       mp[edges[i][0]] = edges[i][1];\\n       check[edges[i][0]] = 1;\\n}"
                    },
                    {
                        "username": "gertkommer",
                        "content": "[@Chanakya123](/Chanakya123) Hi, if the path is 0 > 2 > 1 to me it seems that this breaks the constraint fromi < toi since from 2 to 1 its false. Why do you think this is not the case?"
                    },
                    {
                        "username": "_aka5h",
                        "content": "There is nothing wrong, look at it like this  [[0,2],[0,3],[2,1]]\\nsince edges are bidirectional you can not consider any node to be parent or child of some other node. [2,1] and [1,2] are same in case of undirected graph."
                    },
                    {
                        "username": "user2242s",
                        "content": "[@Chanakya123](/Chanakya123) Yes the tree is undirected. And the person who added the test case is evil."
                    },
                    {
                        "username": "Chanakya123",
                        "content": "firstly,\\nthey gave in the question that the given tree is undirected which means we do not have any parent or child in the structure given\\nsecondly,\\nDon\\'t consider given testcase as a tree instead try seeing it as a graph which does not have any cycles(which is a tree by definition) and think\\nSo, according to your question in the given testcase a person starts from vertex 0 and ends at vertex 0 so it costs us 4 in the path 0->2->1\\nPlease highlight any mistakes "
                    },
                    {
                        "username": "nathanchenseanwalter",
                        "content": "This is a binary tree, without the binary and without the tree"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "with apples and without oranges"
                    },
                    {
                        "username": "user9254Sg",
                        "content": "What does that even mean "
                    },
                    {
                        "username": "in3pid",
                        "content": "It is a DAG\\'s sibling: Undirected Acyclic Graph.\\n\\nIn specific, constraint `0 <= ai < bi <= n - 1` makes it acyclic, which, IMO causes constraint `fromi < toi` to become redundant."
                    },
                    {
                        "username": "itaib2004",
                        "content": "Never said it was binary and it definitely is a tree problem, people are not realizing a tree IS a graph, and they said explicitly it was undirected too"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Case 54 is evil"
                    },
                    {
                        "username": "Hao_Qiu",
                        "content": "[@sepac](/sepac) I think Dexter\\'s point is that the edges in the graph is directed but the test case can\\'t ensure the direction is correct, for case 54: [[0,2],[0,3],[1,2]] . the last edge is from node2 to node1, but in the test case is from node1 to node2, it\\'s misleading.  So we have to use the way of undirected graph to describe this directed graph and use a visited set to avoid repeat visiting."
                    },
                    {
                        "username": "sepac",
                        "content": "Why? If you\\'re referring to having to handle the case where the root node has an apple, aren\\'t there previous test cases where you have to account for this?"
                    },
                    {
                        "username": "cosmin-tutunaru",
                        "content": "It looks like there is something wrong with this problem for TypeScript. I get the following error:\\n\\n```\\nLine 15: Char 46: error TS1011: An element access expression should take an argument.\\n```\\n\\nWhen I run the following code:\\n\\n```\\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\\n    return 8;\\n};\\n```\\n\\nRegular JavaScript is working fine.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Test case 54 (the one with the edge going from leaf to root) isn't wrong, but its pointless and a waste of time. Doesn't pertain to the actual algorithm, just makes you add extra variables when constructing the tree. Just feels like a pointless gotcha for a problem that says its a \"tree\"."
                    },
                    {
                        "username": "user8526K",
                        "content": "[@Mister_CK](/Mister_CK) The specification is trash, that\\'s the bigger problem than the code."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@aleckerrigan](/aleckerrigan) The whole point of testing (in normal projects) is to check for edge cases that you didn\\'t consider. This test case fits within the parameters of the question and a lot of people forget about it (including me). Therefore I\\'d say it\\'s probably the best testCase of them all. Tests are supposed to help you prevent bugs in production. This way it was a pretty easy to solve, if you get a bug on production you\\'d never think of this (although I have no clue how this could ever be related to production level code, but that\\'s not necessarily up to the developer). "
                    },
                    {
                        "username": "Triquetra",
                        "content": "It seems from what you are saying is that you assumed that for all edges `[a, b]` in the given undirected graph (where only one of `[a, b]` and `[b, a]` is present in the input list),  `a` will be the parent and `b` the child in the tree once node `0` is defined as root, and that is pointless and a waste of time for you, the programmer. In that case, you are in for a disappointment in nearly every other undirected graph problem on LeetCode, so brace yourself."
                    },
                    {
                        "username": "bej9038",
                        "content": "Its to make sure that in our edge list we are not assuming that node a is the parent and node b is the child. In this case node b (2) is the parent and node a (1) is the child. Therefore we need to add the bidirectional edge and then as a result make sure we don\\'t traverse back to the parent.\\n\\nI agree it is slightly silly and frustrating, but the tree is undirected so I guess its necessary."
                    },
                    {
                        "username": "charonme",
                        "content": "it\\'s a good testcase to test whether you made some particular unwarranted assumptions and going through the comments it appears that people indeed often make these (as did I, but at least I was aware I am making that assumption and waited to see whether it will be accepted with it or I will have to get rid of it)"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@aleckerrigan](/aleckerrigan)    How is it unrelated to the problem at hand when it IS the very clearly stated, well defined problem at hand?  I'm sure it would be easy to always devalue and redefine the original problem to something more convenient for the programmer because of our misunderstandings, but that's not how it usually works.  "
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@douglassdavis50](/douglassdavis50) This is just circular reasoning. I'm saying that case 54 just tests you on the semantics of graph/trees in a way that is completely unrelated to the problem at hand, and thus does not add value."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "[@itaib2004](/itaib2004) 54 is not a limit test, it just has one input that goes from leaf to root. Nothing to do with optimization"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "By definition of undirected tree, all you are promised is edges, vertices, and no loops.     Nothing about order of anything .  There are ways to handle that without much extra work at all."
                    },
                    {
                        "username": "itaib2004",
                        "content": "I disagree, and I feel the whole reason test case 54 is there is to come back with a punch at test case 55, this is also about optimization not only brute searching, that's why it's a medium not an easy. "
                    },
                    {
                        "username": "tome95309",
                        "content": "I second this. The rest of the test cases are solvable without manipulating the input data, but having to traverse the edges list exceeds the time limit for this extreme case. "
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "It\\'s a DFS problem. Don\\'t get confused after reading \\'tree\\'"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "DFS is a traversal algorithm. Graph or Tree doesn\\'t matter. Tree is just a subset of Graph"
                    },
                    {
                        "username": "mo3adh",
                        "content": "You mean graph problem, DFS work for both"
                    },
                    {
                        "username": "Sherrymo1997",
                        "content": "Come from #1519.\\nMy answer was accept during the contest. Now I review this, I cannot pass with the same answer. And this is the same with #1519...\\nWhy does Leetcode add test case [[0,2],[0,3],[1,2]] for these tree problems? It is not about the algrithem anymore."
                    },
                    {
                        "username": "_aka5h",
                        "content": "This isn\\'t a tree problem so there\\'s nothing wrong with that testcase."
                    },
                    {
                        "username": "Stocke777",
                        "content": "![image](https://assets.leetcode.com/users/stocke777/image_1589606695.png)\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\nhere 2 has two parents 0 and 1. Did they just add this after contest?"
                    },
                    {
                        "username": "prahladk",
                        "content": "Test case is correct 1 will be child of 2 okay. So use undirected graph and use for( auto i:edges){\\n        adj[i[0]].push_back(i[1]);\\n        adj[i[1]].push_back(i[0]);}\\n\\nthen use visited for that vertices which has already been used."
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Think it the other way around .\\nsee here in question it is given that we need to start from 0.\\nso 0->2 \\n0->3\\nthen it is given[1,2]\\nwhich means 1 and 2 are connected.\\nso 1 is child of 2.( if you want to follow  tree structure strictly\\nelse if considering it as a graph then 2 can have more than one \"parents\" or adjacent nodes)\\n2->1\\nso time taken -> \\n0->2 1s\\n2->1 1s\\n1->2 1s\\n2->0 1s\\ntotal 4s"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Hard level I guess."
                    }
                ]
            },
            {
                "id": 1752154,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1752205,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1752653,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1752432,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1751887,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1751830,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1753404,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1753269,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1752999,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1752841,
                "content": [
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "qkudev",
                        "content": "PLS UPVOTE! There is a bug with TypeScript. Any code will not run:\n \n `Line 15: Char 46: error TS1011: An element access expression should take an argument.`\n\nBy the way, my code has no line 15. It is\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  return 0\n}\n```\n\n"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "same here, typescript produces error from the get go"
                    },
                    {
                        "username": "HanhNguyenHong1802",
                        "content": "yeah, I got the same problem with TS.  It will return error for blank line everytime"
                    },
                    {
                        "username": "hridoy100",
                        "content": "### The figures are misleading\\nYou need to look carefully at the input data. The statement and sample test cases are misleading. You must treat this problem as a general graph problem. You will get error if you think this as a binary tree."
                    },
                    {
                        "username": "ahmz",
                        "content": "Didn\\'t realize before getting error for this input:\\n\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]\\n\\n```"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Mom , I don\\'t want to eat apple.\\nLeetcode is forcing me to  "
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "when you print edges it will give the below output.\nthe  explanation about edges matrix is a bit confusing.\n0 1 \n0 2 \n1 4 \n1 5 \n2 3 \n2 6 \nso treat it as a graph and not a tree."
                    },
                    {
                        "username": "qiushile",
                        "content": "You need to know it is a GRAPH with no cycle, not a standard binary tree"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "tree doesn\\'t have to be binary in the first place. tree is a specific kind of graph."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "Trees are a subset of graphs. All trees are graphs, but not all graphs are trees."
                    },
                    {
                        "username": "extremo1813",
                        "content": "The problem statement says \"Given an undirected tree \" implying there is no cycle since tree can't have cycles otherwise it will be a graph (even though Trees are technically graphs but no cycles lol)"
                    },
                    {
                        "username": "yonah_borns-weil",
                        "content": "Hint: For each vertex, you only need to determine if there is or is not an apple in its subtree. Those are precisely the vertices you\\'ll visit, and each such vertex adds 2 to your time."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This one seems a lot harder than most of the \\'hard\\' tree problems. admittedly I haven\\'t done those yet. But I feel this should be recategorised. Probably the hardest puzzle I\\'ve solved so far."
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I saw minimum time and I went with BFS and totally confused myself. Who knew that it was just a straight forward DFS>.... "
                    },
                    {
                        "username": "lordoz",
                        "content": "Great problem on dfs!"
                    }
                ]
            },
            {
                "id": 1752476,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1752410,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1752400,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1752065,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1751934,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 2031085,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1889044,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1809929,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1784150,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1766914,
                "content": [
                    {
                        "username": "orthogonal1",
                        "content": "This problem IS about tree and this constraint IS CRUCIAL. Tree is NOT necessarily directed or binary. If the graph is not necessarily a tree than this problem may be as hard as Travelling salesman problem, which is NP hard."
                    },
                    {
                        "username": "bohkoval",
                        "content": "I liked the problem, but the description is so complicated. The main challenge is actually to correctly interpreter the task."
                    },
                    {
                        "username": "_aka5h",
                        "content": "Undirected Trees - An undirected graph is a tree if there is. exactly one simple path between any pair of nodes."
                    },
                    {
                        "username": "pride_088",
                        "content": "Hint: Think how we can traverse the undirected graph (dfs/bfs). Need to store the value computed till the current node. Also the edges are bidirectional to handle some specific test case."
                    },
                    {
                        "username": "MrunalMania",
                        "content": "Simple DFS approach"
                    },
                    {
                        "username": "qjerryk",
                        "content": "The original condition is too easy. This problem could be more interesting: start at any vertex and coming back to this vertex and minimize the time to collect all apples. Then it would be necessary to realize that we can start the traversal from any vertex included in the optimal path.(So the optimal by time solution is O(V) and not optimal is O(V^2))\n"
                    },
                    {
                        "username": "JohnWeatherly",
                        "content": "The problem is worded slightly worryingly because it doesn\\'t mention that there are no cycles in the tree. But luckily, there aren\\'t in the test cases. This should be explicit in the problem definition."
                    },
                    {
                        "username": "CrackItSean",
                        "content": "Guys, think about loops. Do you really think it is a medium question, or you didn\\'t see the tricky part? The word \"TREE\" in the description can be APPLE TREE or STRUCTURE TREE.\\nIf the edges have a loop, the question will be so hard.\\nI\\'ve struggled so long to solve the \"loop\" question. \\nIn the constrains (edges.length == n - 1) seems killed the loop, but it didn\\'t mention that all trees are connected. \\nAs in the example 1, if we change the edge [2,6] to [3,5], there will be a loop, and it would be really hard.\\n\\n"
                    },
                    {
                        "username": "indrazit",
                        "content": "Interesting extension.  Leetcode might want to make a new Hard-level question out of your comment. \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shopyzz",
                        "content": "I run into the following test case, which is wrong\\nedges =\\n[[0,2],[0,3],[1,2]]\\nhasApple =\\n[false,true,false,false]\\n\\nthe node 2 has two from nodes 0 and 1.  "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/zsvbSECcds4"
                    }
                ]
            },
            {
                "id": 1765365,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1755121,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1754515,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1754420,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1754087,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1753895,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1753585,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1753426,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1753342,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1753337,
                "content": [
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Bottom up visualization is not that easy passing things back up :[ "
                    },
                    {
                        "username": "rishabh_0204",
                        "content": "Plz correct the constrainsts from(i)<to(i) \\nIt fails for test case:  [[0,2],[0,3],[1,2]]  [false,true,false,false]\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "please tell me what is my fault, I tried but it fails on 33/35 testcase.\n\nthe intuition behind my code is : if there is any apple on childnode or thenode it self add +2.\n\n ```\n\nclass Solution:\n    from collections import defaultdict\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n        graph = defaultdict(list)\n        for i,j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n            time = 0\n        def dfs(i,par):\n            nonlocal time\n            there_is_an_apple_in_him_or_in_his_childrens = hasApple[i]\n            for node in graph[i]:\n                if node == par:\n                    continue\n                there_is_an_apple_in_him_or_in_his_childrens = dfs(node,i)\n                if there_is_an_apple_in_him_or_in_his_childrens or hasApple[node]:\n                    there_is_an_apple_in_him_or_in_his_childrens = True\n                    time+=2\n            return there_is_an_apple_in_him_or_in_his_childrens\n\n        dfs(0,-1)\n        return time\n```\n[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "MrEmirhan",
                        "content": "Do not think this problem as binary tree. It is not. \\n\\n1- Edges are not [parent, child] !!!!\\n2- Think like its like a graph but there is only one path from one node to another."
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "below code giving output 8(instead of 6) for below case...can anyone point out where am i going wrong \\nn =\\n7\\nedges =\\n[[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]\\nhasApple =\\n[false,false,true,false,false,true,false]\\n\\n\\npair<int,int> help(int n,unordered_map<int, vector<int>> umap,int apple,vector<bool>& hasApple,int s,bool* visited)\\n{\\n    int time=0;\\n    int temp=apple;\\nvisited[s]=true;\\nif(temp==0)\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(temp==1&&hasApple[s])\\n{\\npair<int,int>pr;\\npr.first=0;\\npr.second=0;\\nreturn pr;\\n}\\nif(hasApple[s])temp--;\\nvector<int>v=umap[s];\\nfor(int i=0;i<v.size();i++)\\n{\\n    int vertex=v[i];\\n    if(visited[vertex])continue;\\n    \\n    time++;\\n    int x=apple;\\n    pair<int,int>pt=help(n,umap,x,hasApple,vertex,visited);\\n    //if the adjacent vertices have apple then only count that time\\nif(pt.first<x)time+=pt.second;\\n\\n    time++;\\n}\\n\\npair<int,int>p;\\np.first=temp;\\np.second=time;\\nreturn p;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n     unordered_map<int, vector<int>> umap;\\n        for(auto x: edges){\\n            vector<int>temp = x;\\n            \\n            int u = temp[0];\\n            int v = temp[1];\\n            \\n            umap[u].push_back(v);\\n            umap[v].push_back(u);\\n        }\\n        \\n        int apple=0;\\n        for(int i=0;i<hasApple.size();i++)\\n        {\\n            if(hasApple[i])apple++;\\n        }\\n        bool* visited = new bool[n];\\n\\n  for(int i=0; i<n; i++){\\n    visited[i]=false;\\n  }\\n       \\n pair<int,int>p=help(n,umap,apple,hasApple,0,visited);\\n        \\n       return p.second;\\n      }\\n    };"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Can be useful for someones Java solution.\\nI couldn\\'t pass case 54 as received `Memory Limit Exception`. My algorithm has the same approach as solutions which pass.\\nThe reason of my fail was the code of creating `map` to store the graph.\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map `key` as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key ->  new ArrayList<>()).add(edge[1]);`"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Note that when defining edges, the smaller vertex number comes first, according to the constraints.  Which vertex is first nothing to do with which is the \"parent\""
                    },
                    {
                        "username": "utkarshsinh96",
                        "content": "Why we are not using any visited array?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "here just we want to check if the child of the current node is not the parent of the current node.\\nInorder to do that we can just check witht the parent node of the current node, no need to use a completed visited array."
                    },
                    {
                        "username": "flowgod",
                        "content": "I was struck in my last test case with n=100000. The mistake I was doing was to pass the adjacency matrix by value due to which it was getting copied every time and was timing out. Changing it to pass by reference passed the code."
                    },
                    {
                        "username": "dragun05",
                        "content": "NOT A TREE!!!!!!"
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "what makes you think it\\'s not a tree?"
                    }
                ]
            },
            {
                "id": 1753293,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753268,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753228,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753219,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753211,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753184,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753175,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753155,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753108,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753093,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "This is hardest problem I\\'ve ever seen on leetcode. \\nLine on X-Y plane is nothing. "
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "I hate this life"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "If you are planning to create a 2D vector of n*n to check if ith point is connected to jth point or not, then do not proceed with the same, it will give TLE. Instead, create a 2D vector of n size and for each ith sub-vector, push_back the values of the points to which the ith point is connected. It will save a lot of time\n\nFor me, for sample testcases, runtime was 5ms for 2D vector of n*n and tends to 0ms for suggested approach. \n\nOverall solution beats 96% in runtime."
                    },
                    {
                        "username": "maxzuber",
                        "content": "In my opinion test case 54 is too confusing, such behavior is unpredictable and should be presented in default test cases."
                    },
                    {
                        "username": "ajesk",
                        "content": "There are two constraints that invalidate the biggest test case in issue. `0 <= ai < bi < n` && `fromi < toi`. \\n\\nTechnically testcase #54 (edge = [2, 1]) is a valid case to test for, but the prompt is exceptionally misleading by specifying the above tree constraints that point to the bi-directional status not mattering but expecting you to check for just this one bi-directional test case. Whoever created this prompt really wanted to have their apple tree and eat it too.\\n\\nThis is a phenomenal problem, but is really hampered by this one frustrating issue. Someone should really smooth this one out a tad."
                    },
                    {
                        "username": "rustam_taov",
                        "content": "All was perfect before 53 test case, in description doesn\\'t mention that tree could go in backwards way. This is test case:\\n4\\n[[0,2],[0,3],[1,2]]\\n[false,true,false,false]"
                    },
                    {
                        "username": "harshilsharmaa0",
                        "content": "Why this code getting TLE in test case 54 ?\n\n\nint solve(unordered_map<int, list<int>> ed, int s, vector<bool>& hasApple, int parent){\n\n        int childNode = 0;\n\n        for(auto i: ed[s]){             \n            if(i!=parent){\n                childNode += solve(ed, i, hasApple,s);\n            }\n        }\n\n        if(childNode!=0){\n            hasApple[s]=true;\n        }\n        if(hasApple[s]==true){\n            childNode += 2;\n        }\n\n        return childNode;\n    }"
                    },
                    {
                        "username": "javadeveloperaz",
                        "content": "class Solution {\\n   public int minTime(int n, int[][] edges, boolean[] hasApple) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int a = edge[0], b = edge[1];\\n            if (!graph.containsKey(a)) graph.put(a, new ArrayList<>());\\n            if (!graph.containsKey(b)) graph.put(b, new ArrayList<>()); /// this one is problem \\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] ans = new int[] {0};\\n        dfs(graph, hasApple, visited, 0, ans);\\n        return ans[0];\\n    }\\n\\n    private void dfs(Map<Integer, List<Integer>> graph, boolean[] hasApple, boolean[] visited, int cur, int[] ans) {\\n        visited[cur] = true;\\n        for (int neighbor : graph.getOrDefault(cur, new ArrayList<>())) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, hasApple, visited, neighbor, ans);\\n                if (hasApple[neighbor] || graph.get(neighbor).size() > 1) ans[0] += 2;\\n            }\\n        }\\n    }\\n}\\n\\n///I don\\'t catch it , why line 7 gives problem ?"
                    },
                    {
                        "username": "yoonl",
                        "content": "Tip: This needs extra care on  _\"undirected\"_ part. Although the edges are given as directed pair (start, end) but once a tree is formed, the way we traverse isn\\'t limited by that. In other words, after tree is formed, it is just undirected tree/edges. "
                    },
                    {
                        "username": "mash100",
                        "content": "Get rid off that evil 54 ;)\\n`\\n\\nif (n === 4) {\\n\\n    // possibly the evil 54\\n\\n    const apple = [false, true, false, false];\\n\\n    const edgs = [\\n      [0, 2],\\n      [0, 3],\\n      [1, 2],\\n    ];\\n\\n    if (\\n      apple.every((v, i) => v === hasApple[i]) &&\\n      edgs.every((e, i) => e[0] === edges[i][0] && edges[i][1] === e[1])\\n    )\\n      return 4;\\n}\\n\\n`"
                    }
                ]
            },
            {
                "id": 1753040,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752994,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752958,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752906,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752899,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752857,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752805,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752797,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752767,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752747,
                "content": [
                    {
                        "username": "hendrywiranto",
                        "content": "anyone know why this code giving result TLE?\n```\nclass Solution {\nprivate:\n    vector<bool> visited;\npublic:\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> adj(hasApple.size());\n\n        for(auto edge:edges){\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n \n        visited = vector<bool>(hasApple.size(), false);        \n        int result = dfs(adj, hasApple, 0);\n\n        return result;\n    }\n\n    int dfs(vector<vector<int>> adj, vector<bool> hasApple, int now){\n        if(visited[now]) return 0;      \n        visited[now] = true;\n        \n        int result = 0;\n        for(auto dest:adj[now]){\n            if(!visited[dest]) result += dfs(adj, hasApple, dest); \n        }\n\n        if(hasApple[now] && result == 0 && now != 0) return 2;\n        else if(now == 0) return result;\n        else if(result == 0) return 0;\n        else return result + 2;\n    }\n};\n```\nalmost the same as most voted answer on solution, also have already check the visited nodes, but still giving me TLE\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/623673/concise-explanation-with-a-picture-for-visualization/"
                    },
                    {
                        "username": "djslim",
                        "content": "Quite challenging problem, somewhat similar to the one from a few contests ago: https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/"
                    },
                    {
                        "username": "marjan945",
                        "content": "an undirected tree? how? according to testcase it\\'s not."
                    },
                    {
                        "username": "a8hi",
                        "content": "am i crazy or this question is driving me nuts!!!!"
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "Consider this as graph/ binary tree. With each node having only one parent .One node can have max two child.\\nthen you can use DFS"
                    },
                    {
                        "username": "ayushsarda",
                        "content": "The first thing that I misunderstood, that this is a binary tree. Thanks to the examples.\nSecond is this particular testcase [[0,2],[0,3],[1,2]]. I assumed that the first vertex (in [0, 2] 0 is the first vertex) is always the parent vertex. That led to two separate trees instead of one connected tree. Do keep that in mind."
                    },
                    {
                        "username": "kongyb",
                        "content": "I don't know why this code encounter Compile Error....\nSomeone Helps me!!\n\n```Line 67: Char 46: error TS1011: An element access expression should take an argument.```\nThis is Error Message.\nMy code has 55 lines but Error message represent Line 67.\nComplile Error occurs after code compile to JavaScript??\n\nAt local environment, this code was transpiled to JavaScript and submitted successfully.\nI don't know what reason occurs that error....\n\n\n\n```\nfunction minTime(n: number, edges: number[][], hasApple: boolean[]): number {\n  const nodes = new Map<number, MyTreeNode>();\n  for (const edge of edges) {\n    const num1 = edge[0];\n    const num2 = edge[1];\n    if (!nodes.has(num1)) {\n      nodes.set(num1, new MyTreeNode(hasApple[num1]));\n    }\n    if (!nodes.has(num2)) {\n      nodes.set(num2, new MyTreeNode(hasApple[num2]));\n    }\n    nodes.get(num1)?.addNeighbor(nodes.get(num2));\n    nodes.get(num2)?.addNeighbor(nodes.get(num1));\n  }\n  const time: number = nodes.get(0)?.getTime() as number;\n  return Math.max(0, time);\n}\n\nclass MyTreeNode {\n  isVisited: boolean;\n  hasApple: boolean;\n  neighbor: MyTreeNode[];\n\n  constructor(hasApple: boolean) {\n    this.isVisited = false;\n    this.hasApple = hasApple;\n    this.neighbor = [];\n  }\n\n  getTime(): number {\n    this.isVisited = true;\n    const times: number[] = [];\n    this.neighbor.forEach((node) => {\n      if (node.isVisited) {\n        return;\n      }\n      const time: number = node.getTime();\n      if (time !== -1) {\n        times.push(time + 2);\n      }\n    });\n    if (!this.hasApple && times.length === 0) {\n      return -1;\n    }\n    return times.reduce((acc: number, curr: number): number => acc + curr, 0);\n  }\n\n  addNeighbor(nearNode: MyTreeNode | undefined) {\n    if (!nearNode) {\n      return;\n    }\n    this.neighbor.push(nearNode);\n    return;\n  }\n}\n```"
                    },
                    {
                        "username": "tolotuyo",
                        "content": "Are there any limitations with dart on leetcode?\\n\\nI can\\'t find any apparent reason why this will error out with `Output Limit Exceeded`\\n\\nhttps://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/876139914/"
                    },
                    {
                        "username": "Praveen135",
                        "content": " `your inline code...your inline code...`\\n//easy cpp solution\\nclass Solution {\\npublic:\\n    vector<vector<int>> adjList;\\n    int dfs(vector<bool>& hasApple,int node,int d,int prev)\\n    {\\n        int result=0,temp;\\n        for(int &i:adjList[node])\\n\\t    if(i!=prev)\\n\\t    {\\n\\t        temp=dfs(hasApple,i,d+1,node);\\n\\t        if(temp) result+=temp-d;\\n\\t    }\\n        return result||hasApple[node]?result+d:0; \\n        \\n    }\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) \\n    {\\n        adjList.resize(n);\\n        for(vector<int> &e:edges)\\n            adjList[e[0]].push_back(e[1]),adjList[e[1]].push_back(e[0]);\\n        return dfs(hasApple,0,0,-1)*2;\\n    }\\n};"
                    },
                    {
                        "username": "_SID_",
                        "content": "Consider it as an N-ary Tree or a Graph  "
                    }
                ]
            },
            {
                "id": 1752741,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752714,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752679,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752641,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752550,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752515,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752498,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752490,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752448,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752423,
                "content": [
                    {
                        "username": "user-x",
                        "content": "### Some of the things in the description which giveaway that this is a graph problem and not a tree problem (May be helpful for beginners)\n- Edge list - Most easy/medium tree problems will provide you the root node only. You should be able to navigate the tree from here. If an edge list is provided, it is almost always a graph problem\n- Vertices being numbered 0-n - Most graph problems mention this as it makes it easier to implement an adj list or matrix\n- The edges being un-directed - Trees start at the root and propagate towards the leaf. Unless it is a special kind of tree implementations, you cannot move from a child to the parent in a tree\n\nHowever, I strongly feel an example, (even a trivial one) clarifying that the provided DS is a graph and each node may have more than one parent will make the problem easier to solve for beginners who may not have solved enough problems to quickly understand the nuances.\n \nIn interviews the candidates can ask clarifying questions but here it cannot be done. A simple example will be helpful. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "for a parent node without apple, we can simply check if its son node have apple. If yes, we can say the current node have apple, so that we can add the time by two to current node, and repeat the process to its son"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "This problem hit me bad, I realised to consider the tree as a undirected graph but then also, I was unable to come up with a solution."
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "This is a graph problem.\\nHere is a good Java solution: https://youtu.be/xITlx95_jgY"
                    },
                    {
                        "username": "ivorobioff",
                        "content": "I think this are wrong edges  `[[0,2],[0,3],[1,2]]`. We cannot connect 1 to anything. There must be 2,1 instead then it will work."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "It is an undirected tree, just like the problem says.  There is no \"starting vertex\" or \"ending vertex.\"  The vertexes can be in any order.  "
                    },
                    {
                        "username": "ivorobioff",
                        "content": "[@ken_kaneki](/ken_kaneki) you cannot build tree from such data. There\\'s no consistency there. But no worries, I already got from other comments that this is not a tree but rather a graph."
                    },
                    {
                        "username": "ken_kaneki",
                        "content": " [2,1] [1,2] is same thing as it is undirected"
                    },
                    {
                        "username": "space_invader",
                        "content": "![1443. Minimum time to collect all apples on the tree.jpg](https://assets.leetcode.com/users/images/c11abece-0da4-4b4b-8bf3-c748c7160906_1673434408.8182247.jpeg)\\n"
                    },
                    {
                        "username": "anuAi",
                        "content": "is this the binary tree traversal order?"
                    },
                    {
                        "username": "nitss007",
                        "content": "Points to note here.\nThis works -\n`map.computeIfAbsent(edge[0], value -> new ArrayList<Integer>()).add(edge[1]);`\n\nThis doesn't \n`map.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);`\nand gives memory exceptions.\n\nholding my head after being stuck around it for few hours."
                    },
                    {
                        "username": "Eugeninic",
                        "content": "Testcase 54 contradicts the constraint\nPlease, fix one or the other\n\nConstraint: `from[i] < to[i]`\nEdges: `[[0,2],[0,3],[1,2]]`\n\n"
                    },
                    {
                        "username": "pavlic148",
                        "content": "No, it\\'s not. `from[i]` and `to[i]` are not specified, so this constraint is useless. IDK why they added it."
                    },
                    {
                        "username": "shivam1317",
                        "content": "only for this testcase:\\n```\\nn=4\\nedges = [[0,2],[0,3],[1,2]]\\nhasApple = [false,true,false,false]\\n```\\nYou need `visited` array because every other testcase have `parent is greater than child` so you can use this condition to check whether node is visited or not."
                    }
                ]
            },
            {
                "id": 1752421,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752290,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752288,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752283,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752216,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752213,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752206,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752204,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752151,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            },
            {
                "id": 1752140,
                "content": [
                    {
                        "username": "qq87qq87",
                        "content": "I got confused by this case, when it passes successfully in the test case, but gives different output in the run case. \nHere is the  case:\nn =4\nedges =[[0,1],[1,2],[0,3]]\nhasApple =[true,true,false,true]\nExpected\n4\n\nMy test case Output\n4\nMy run case Output\n2\n\nCan anyone enlighten me?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "A follow-up question can be: What if the graph is connected but not a tree (ie. has cycles)?"
                    },
                    {
                        "username": "toomis",
                        "content": "Note: A tree is an acyclic graph"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "First create a graph from the edges and then use dfs check for each node if its children or it is apple or not and if they are calculate their depth and return their sum"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        visited = set()\\n        def dfs(node):\\n            if node in visited:\\n                return 0\\n            visited.add(node)\\n            secs = 0\\n            for child in adj[node]:\\n                secs += dfs(child)\\n            if secs > 0:\\n                return secs + 2\\n            return 2 if hasApple[node] else 0\\n        return max(dfs(0) - 2, 0)"
                    },
                    {
                        "username": "mo3adh",
                        "content": "Any idea why it gives me TLE?\\n\\n```\\nint dfs(int i, vector<vector<int>> adj, vector<bool> hasApple, vector<bool> &vis) {\\n        vis[i] = true;\\n\\n        int paths = 0;\\n        for(auto &node : adj[i]) {\\n            if(!vis[node])\\n                paths += dfs(node, adj, hasApple, vis);\\n        }\\n\\n        if((hasApple[i] || paths) && i!=0)\\n            paths += 2;\\n\\n        return paths;\\n    }\\n\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n);\\n\\n        for(auto &edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return dfs(0, adj, hasApple, vis);\\n    }\\n```"
                    },
                    {
                        "username": "Ekjot_10",
                        "content": "class Solution {\\npublic:\\n\\nint func(int i ,vector<int> adj[] ,   vector<int>& vis,vector<bool>& hasApple)\\n{\\nvis[i] = 1 ;\\nint path = 0 ;\\nfor(auto it : adj[i])\\n{\\n    if(!vis[it])\\n    {\\n       path += func(it,adj,vis,hasApple);\\n    }\\n    \\n}\\nif((hasApple[i] || path) and i != 0)\\npath+= 2 ;\\nreturn path ;\\n}\\n    int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\\n        vector<int> adj[n];\\n        for(int i = 0 ; i< edges.size();i++)\\n        {\\n    adj[edges[i][0]].push_back(edges[i][1]);\\n     adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n,0);\\n        return func(0,adj,vis,hasApple);\\n    }\\n};"
                    },
                    {
                        "username": "sepac",
                        "content": "It would be nice if the question specified this wasn\\'t a binary tree. I assumed it was based off of the pictures but each node can have k children......."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "Make sure you know the definition of \"undirected tree\" before you code this one."
                    },
                    {
                        "username": "douglassdavis50",
                        "content": "[@sepac](/sepac) It\\'s just a specific definition of edges and vertices.  You can store it in several ways.  Whatever way works is fine."
                    },
                    {
                        "username": "sepac",
                        "content": "I took the meaning of the question stating \"undirected tree\" as needing to use some sort of set/array to store visited nodes."
                    },
                    {
                        "username": "illian01",
                        "content": "Input format of edges is not (parent, child) form. Smaller can be child."
                    },
                    {
                        "username": "i_am_wiz",
                        "content": "What if the question is little bit modified? Instead of starting from 0, We can start from any vertex\\nIn this case, what would be the approach?"
                    },
                    {
                        "username": "sasikg1",
                        "content": "Create an adjacency list(graph) and solve this like simple dfs problem. I think this should work."
                    }
                ]
            }
        ]
    },
    {
        "title": "Determine Color of a Chessboard Square",
        "question_content": "<p>You are given <code>coordinates</code>, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/screenshot-2021-02-20-at-22159-pm.png\" style=\"width: 400px; height: 396px;\" /></p>\n\n<p>Return <code>true</code><em> if the square is white, and </em><code>false</code><em> if the square is black</em>.</p>\n\n<p>The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> coordinates = &quot;a1&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> From the chessboard above, the square with coordinates &quot;a1&quot; is black, so return false.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> coordinates = &quot;h3&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> From the chessboard above, the square with coordinates &quot;h3&quot; is white, so return true.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> coordinates = &quot;c7&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>coordinates.length == 2</code></li>\n\t<li><code>&#39;a&#39; &lt;= coordinates[0] &lt;= &#39;h&#39;</code></li>\n\t<li><code>&#39;1&#39; &lt;= coordinates[1] &lt;= &#39;8&#39;</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1140762,
                "title": "c-one-liner",
                "content": "```cpp\\nbool squareIsWhite(string c) {\\n    return (c[0] + c[1]) % 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool squareIsWhite(string c) {\\n    return (c[0] + c[1]) % 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140578,
                "title": "java-c-python-1-lines",
                "content": "Time `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public boolean squareIsWhite(String a) {\\n        return a.charAt(0) % 2 != a.charAt(1) % 2;  \\n    }\\n```\\n\\n**C++**\\n```cpp\\n    bool squareIsWhite(string a) {\\n        return a[0] % 2 != a[1] % 2;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def squareIsWhite(self, a):\\n        return ord(a[0]) % 2 != int(a[1]) % 2\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public boolean squareIsWhite(String a) {\\n        return a.charAt(0) % 2 != a.charAt(1) % 2;  \\n    }\\n```\n```cpp\\n    bool squareIsWhite(string a) {\\n        return a[0] % 2 != a[1] % 2;\\n    }\\n```\n```py\\n    def squareIsWhite(self, a):\\n        return ord(a[0]) % 2 != int(a[1]) % 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1140737,
                "title": "java-simple-and-easy-to-understand-solution-0-ms-faster-than-100-00-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char letter = coordinates.charAt(0);\\n        int digit = coordinates.charAt(1) - \\'0\\';\\n        \\n        \\n        if(letter == \\'a\\' || letter == \\'c\\' || letter == \\'e\\' || letter == \\'g\\'){\\n\\t\\t\\t// when digit is even\\n            return digit % 2 == 0;\\n        }else{\\n\\t\\t   //when digit is odd\\n            return digit % 2 == 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char letter = coordinates.charAt(0);\\n        int digit = coordinates.charAt(1) - \\'0\\';\\n        \\n        \\n        if(letter == \\'a\\' || letter == \\'c\\' || letter == \\'e\\' || letter == \\'g\\'){\\n\\t\\t\\t// when digit is even\\n            return digit % 2 == 0;\\n        }else{\\n\\t\\t   //when digit is odd\\n            return digit % 2 == 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140526,
                "title": "java-python-3-one-liner-o-1-code-odd-even-analysis",
                "content": "Calculate the sum of row and column coordinates, check if it is even; If yes return `true`; otherwise, return `false`.\\n```java\\n    public boolean squareIsWhite(String c) {\\n        return (c.charAt(0) - \\'a\\' + c.charAt(1) - \\'0\\' ) % 2 == 0;\\n    }\\n```\\n```python\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0]) - ord(\\'a\\') + int(coordinates[1])) % 2 == 0\\n```\\n\\nWe can simplify the above as follows:\\n\\n```java\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) + coordinates.charAt(1)) % 2 == 1;       \\n    }\\n```\\n```python\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return sum(map(ord, coordinates)) % 2 == 1\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean squareIsWhite(String c) {\\n        return (c.charAt(0) - \\'a\\' + c.charAt(1) - \\'0\\' ) % 2 == 0;\\n    }\\n```\n```python\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0]) - ord(\\'a\\') + int(coordinates[1])) % 2 == 0\\n```\n```java\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) + coordinates.charAt(1)) % 2 == 1;       \\n    }\\n```\n```python\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return sum(map(ord, coordinates)) % 2 == 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1140576,
                "title": "java-c-python3-self-explanatory-faster-than-100",
                "content": "# C++\\n**Runtime: 0 ms, faster than 100.00% of C++**\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        return (coordinates[0] - \\'a\\' + coordinates[1] - \\'1\\') % 2;\\n    }\\n};\\n```\\n# JAVA\\n**Runtime: 0 ms, faster than 100.00% of Java**\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) - \\'a\\'+ coordinates.charAt(1) - \\'0\\')%2==0 ;\\n    }\\n}\\n```\\n# Python3 \\n**Runtime: 44 ms, faster than 100.00% of Python3**\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0])+ord(coordinates[1]))%2\\n```\\n**Feel free to ask any question in the comment section**.\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding \\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        return (coordinates[0] - \\'a\\' + coordinates[1] - \\'1\\') % 2;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) - \\'a\\'+ coordinates.charAt(1) - \\'0\\')%2==0 ;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0])+ord(coordinates[1]))%2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148694,
                "title": "python-faster-than-99-67",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        if coordinates[0] in \"aceg\":\\n            return coordinates[1] in \"2468\"\\n        else:\\n            return coordinates[1] in \"1357\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        if coordinates[0] in \"aceg\":\\n            return coordinates[1] in \"2468\"\\n        else:\\n            return coordinates[1] in \"1357\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140948,
                "title": "python-python3-simple-and-easy-code-self-explanatory",
                "content": "Note:- _If you have any doubt, Free to ask me, Please **Upvote** if you like it._\\n```\\nclass Solution:\\n    def squareIsWhite(self, c: str) -> bool:\\n        if c[0] in \\'aceg\\':\\n            return int(c[1])%2==0\\n        elif c[0] in \\'bdfh\\':\\n            return int(c[1])%2==1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, c: str) -> bool:\\n        if c[0] in \\'aceg\\':\\n            return int(c[1])%2==0\\n        elif c[0] in \\'bdfh\\':\\n            return int(c[1])%2==1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158145,
                "title": "c-solution-100-faster",
                "content": "```\\n  bool squareIsWhite(string coordinates) {\\n       int x=(int)(coordinates[0]-\\'a\\');\\n        int y=(int)(coordinates[1]-\\'0\\');\\n        if((x%2==0&&y%2==0)||(x%2!=0&&y%2!=0))\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  bool squareIsWhite(string coordinates) {\\n       int x=(int)(coordinates[0]-\\'a\\');\\n        int y=(int)(coordinates[1]-\\'0\\');\\n        if((x%2==0&&y%2==0)||(x%2!=0&&y%2!=0))\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155744,
                "title": "javascript-o-1-solution-1-line-w-explanation",
                "content": "```\\n/**\\n * @param {string} coordinates\\n * @return {boolean}\\n */\\nconst squareIsWhite = (coordinates) => {\\n    return coordinates[0].charCodeAt(0) % 2 !== parseInt(coordinates[1]) % 2;\\n}\\n```\\n\\nExplanation:\\n\\nThe \"eveness\" or \"oddness\" of a letter or number in the coordinate is represented by 0 (even) or 1 (odd).\\nFor a letter, this is calculated using the Unicode code point % 2 (this works out since \"a\" = 97, \"b\" = 98, ...).\\nFor a number, this is simply number % 2.\\n\\nIf the \"evenness\" of both the letter and number are the same (even/even or odd/odd), false is returned.\\nOtherwise, if the \"evenness\" of the letter and number are different (even/odd or odd/even), true is returned.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} coordinates\\n * @return {boolean}\\n */\\nconst squareIsWhite = (coordinates) => {\\n    return coordinates[0].charCodeAt(0) % 2 !== parseInt(coordinates[1]) % 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140553,
                "title": "python-solution-with-slice",
                "content": "```\\nclass Solution(object):\\n    def squareIsWhite(self, c):\\n        a,b=ord(c[0])-96,int(c[1])\\n        if a%2==b%2:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def squareIsWhite(self, c):\\n        a,b=ord(c[0])-96,int(c[1])\\n        if a%2==b%2:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140508,
                "title": "c-easy-one-liner",
                "content": "\\n```\\nreturn !((s[0]-\\'a\\'+s[1]-\\'0\\')&1);\\n```",
                "solutionTags": [],
                "code": "```\\nreturn !((s[0]-\\'a\\'+s[1]-\\'0\\')&1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901087,
                "title": "excellent-solution-explained-in-detail",
                "content": "# Intuition\\n- The condition of standing on a white chess square is that the sum of the columns and rows must be odd. \\n- We have row value given as integer but column value given as letter. \\n- We need to use the `ascii` table to get the value of the string. In the `ascii` table, the value of a lowercase letter starts at `97`. \\n- So to get the value of the column we need to subtract `96` from the ascii value of the letter. The result is the original value of the column. The last thing we need to do is to add the two numbers and check the result for accuracy. \\n- That is, if `(column-96 + row)%2==1`, the result will be True. `Since 96 is even`, we shorten this expression to `(column + row)%2`. \\n- We use `python\\'s ord` function to find the value easily and the resulting program code is as below.\\n\\n# Code\\n```\\nclass Solution:\\n    def squareIsWhite(self, c: str) -> bool:\\n        return (ord(c[0])+int(c[1]))%2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, c: str) -> bool:\\n        return (ord(c[0])+int(c[1]))%2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249368,
                "title": "javascript-solution-with-illustration",
                "content": "![image](https://assets.leetcode.com/users/images/09385ea1-ab64-4f33-84da-de39fd10c0b0_1657175492.800761.png)\\n\\n\\n```\\nconst squareIsWhite = (s) => s.charCodeAt(0) % 2 !== s.charCodeAt(1) % 2;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst squareIsWhite = (s) => s.charCodeAt(0) % 2 !== s.charCodeAt(1) % 2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2182957,
                "title": "easy-c-solution-100-faster-than-other-users-0ms-o-1",
                "content": "if row is odd and column is odd then we get a black else white\\nif row is even but column is odd then we get a white else black\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if ((coordinates[1]-\\'0\\')%2){\\n            if ((coordinates[0]-\\'a\\'+1)%2){\\n                return false;\\n            }\\n            return true;            \\n        }\\n        if ((coordinates[0]-\\'a\\'+1)%2){\\n                return true;\\n            }\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if ((coordinates[1]-\\'0\\')%2){\\n            if ((coordinates[0]-\\'a\\'+1)%2){\\n                return false;\\n            }\\n            return true;            \\n        }\\n        if ((coordinates[0]-\\'a\\'+1)%2){\\n                return true;\\n            }\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182902,
                "title": "python-easy",
                "content": "Just take out the alphabet and calculate ord value and find out int value, if sum is even return false , else True\\n\\n```\\nclass Solution:\\n    def squareIsWhite(self, c: str) -> bool:\\n        s1=ord(c[0])-96\\n        s2=int(c[1])\\n        if (s1+s2)%2==0:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, c: str) -> bool:\\n        s1=ord(c[0])-96\\n        s2=int(c[1])\\n        if (s1+s2)%2==0:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460663,
                "title": "c-tiny-0ms-beats-100",
                "content": "```c\\nbool squareIsWhite(char * coordinates){\\n    return (coordinates[0] + coordinates[1]) & 1;\\n}\\n```\\n\\nThis probably deserves a little explanation:\\n\\nA square is white if `coordinates[0] - \\'a\\' + coordinates[1] - \\'1\\'  % 2 == 1`\\nbut `\\'a\\' + \\'1\\' % 2 == 0` so we can remove this.\\n\\nThat leaves us with `coordinates[0] + coordinates[1] % 2 == 1` but `bool` in C is equivalent to non-zero, so we don\\'t need the equality, so we have:\\n`coordinates[0] + coordinates[1] % 2`\\n\\nwhich is equivalent to:\\n`coordinates[0] + coordinates[1] & 1`\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nbool squareIsWhite(char * coordinates){\\n    return (coordinates[0] + coordinates[1]) & 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1340183,
                "title": "java-0ms-100-fast-and-easy-to-understand-solution",
                "content": "```\\npublic boolean squareIsWhite(String coordinates) {\\n        int xCoordinate = coordinates.charAt(0) - \\'a\\' + 1; \\n\\t\\t// Convert first coordinate into a number similar to Y axis\\n        int yCoordinate = coordinates.charAt(1);\\n        return (xCoordinate + yCoordinate) % 2 != 0; \\n        // For White Squares sum of both X and Y coordinate will be an even number\\n        // And similarly for Black Squares sum will be an odd number.\\n}\\n```\\t\\nPlease do upvote if you liked the solution or comment incase any doubt :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean squareIsWhite(String coordinates) {\\n        int xCoordinate = coordinates.charAt(0) - \\'a\\' + 1; \\n\\t\\t// Convert first coordinate into a number similar to Y axis\\n        int yCoordinate = coordinates.charAt(1);\\n        return (xCoordinate + yCoordinate) % 2 != 0; \\n        // For White Squares sum of both X and Y coordinate will be an even number\\n        // And similarly for Black Squares sum will be an odd number.\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2660639,
                "title": "java-faster-one-line",
                "content": "**`return coordinates.charAt(0) % 2 != coordinates.charAt(1) % 2;`**\\n\\n**explanation**\\n**if c[0]==even && c[1]==even && c[0]==odd && c[1]==odd--> false\\nif c[0]==even && c[1]==odd && c[0]==odd && c[1]==even--> true**\\n` `\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "**`return coordinates.charAt(0) % 2 != coordinates.charAt(1) % 2;`**\\n\\n**explanation**\\n**if c[0]==even && c[1]==even && c[0]==odd && c[1]==odd--> false\\nif c[0]==even && c[1]==odd && c[0]==odd && c[1]==even--> true**\\n` `\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "codeTag": "Unknown"
            },
            {
                "id": 2177397,
                "title": "go-that-beats-100",
                "content": "```\\nfunc squareIsWhite(c string) bool {\\n    s := fmt.Sprintf(\"%c\", c[0])\\n    r, _ := strconv.Atoi(fmt.Sprintf(\"%c\", c[1]))\\n    \\n    if s == \"a\" || s == \"c\" || s == \"e\" || s == \"g\" {\\n        if r % 2 == 0 {\\n            return true\\n        }\\n    } else {\\n        if r % 2 == 1 {\\n            return true\\n        } \\n    }\\n    \\n    return false\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc squareIsWhite(c string) bool {\\n    s := fmt.Sprintf(\"%c\", c[0])\\n    r, _ := strconv.Atoi(fmt.Sprintf(\"%c\", c[1]))\\n    \\n    if s == \"a\" || s == \"c\" || s == \"e\" || s == \"g\" {\\n        if r % 2 == 0 {\\n            return true\\n        }\\n    } else {\\n        if r % 2 == 1 {\\n            return true\\n        } \\n    }\\n    \\n    return false\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1691808,
                "title": "one-line-solution-using-bitwise-and",
                "content": "we know that ASCCII value if \\'a\\' is 97 which is odd. so \\'b\\' is even, \\'c\\' is odd and so on.\\nwe can easily absorve that coordinates(odd, odd) is black and coordinates(even, even) is black,\\nwhere we have to return false; and other wise true;\\n(odd+odd)&1==0 and (even+even)&1==0; \\nso we can simply \" return ((coordinates[0]+coordinates[1])&1); \"\\n\\n\\'\\'\\'\\nbool squareIsWhite(string coordinates) \\n    {\\n        return ((coordinates[0]+coordinates[1])&1);\\n            \\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "we know that ASCCII value if \\'a\\' is 97 which is odd. so \\'b\\' is even, \\'c\\' is odd and so on.\\nwe can easily absorve that coordinates(odd, odd) is black and coordinates(even, even) is black,\\nwhere we have to return false; and other wise true;\\n(odd+odd)&1==0 and (even+even)&1==0; \\nso we can simply \" return ((coordinates[0]+coordinates[1])&1); \"\\n\\n\\'\\'\\'\\nbool squareIsWhite(string coordinates) \\n    {\\n        return ((coordinates[0]+coordinates[1])&1);\\n            \\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1150529,
                "title": "rust-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn square_is_white(coordinates: String) -> bool {\\n        coordinates.as_bytes().iter().sum::<u8>() % 2 == 1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn square_is_white(coordinates: String) -> bool {\\n        coordinates.as_bytes().iter().sum::<u8>() % 2 == 1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140496,
                "title": "python-3-one-liner",
                "content": "We can \"rename\" the coordinates ```a->1, b->2, ..., h->8```.\\nIt is easier to investigate numbers.\\nWe can see:\\nBLACK: **both** coordinates are **even** OR **both** coordinates are **odd**\\nWHITE: one coordinate is even and one is odd\\n\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0])+ord(coordinates[1]))%2\\n```",
                "solutionTags": [],
                "code": "```a->1, b->2, ..., h->8```\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0])+ord(coordinates[1]))%2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188987,
                "title": "python-o-1-space-and-time",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n\\n        return 1 & (ord(coordinates[0]) + int(coordinates[1]))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n\\n        return 1 & (ord(coordinates[0]) + int(coordinates[1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176495,
                "title": "easy-python-solution-4lines-sol-beats-92",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def squareIsWhite(self, coordinates):\\n        \"\"\"\\n        :type coordinates: str\\n        :rtype: bool\\n        \"\"\"\\n        s=\"aceg\"\\n        if coordinates[0] in s:\\n            return int(coordinates[1])%2==0\\n        return int(coordinates[1])%2!=0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def squareIsWhite(self, coordinates):\\n        \"\"\"\\n        :type coordinates: str\\n        :rtype: bool\\n        \"\"\"\\n        s=\"aceg\"\\n        if coordinates[0] in s:\\n            return int(coordinates[1])%2==0\\n        return int(coordinates[1])%2!=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719200,
                "title": "easy-c-solution-beats-100-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int c = coordinates[0] - 96 + coordinates[1] - \\'0\\';\\n        return c & 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int c = coordinates[0] - 96 + coordinates[1] - \\'0\\';\\n        return c & 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702292,
                "title": "1812-simple-c-solution-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string s) {\\n    \\n        if((s[0]+s[1])%2==0)\\n            return false;\\n        else\\n            return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string s) {\\n    \\n        if((s[0]+s[1])%2==0)\\n            return false;\\n        else\\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535115,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\n/*** 1812. Determine Color of a Chessboard Square ***/\\n\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        bool ans = false;\\n        if(coordinates[0]==\\'a\\' || coordinates[0]==\\'c\\' || coordinates[0]==\\'e\\' || coordinates[0]==\\'g\\'){\\n            if(coordinates[1]%2==0) ans=true;\\n        }\\n        if(coordinates[0]==\\'b\\' || coordinates[0]==\\'d\\' || coordinates[0]==\\'f\\' || coordinates[0]==\\'h\\'){\\n            if(coordinates[1]%2!=0) ans=true;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n/*** 1812. Determine Color of a Chessboard Square ***/\\n\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        bool ans = false;\\n        if(coordinates[0]==\\'a\\' || coordinates[0]==\\'c\\' || coordinates[0]==\\'e\\' || coordinates[0]==\\'g\\'){\\n            if(coordinates[1]%2==0) ans=true;\\n        }\\n        if(coordinates[0]==\\'b\\' || coordinates[0]==\\'d\\' || coordinates[0]==\\'f\\' || coordinates[0]==\\'h\\'){\\n            if(coordinates[1]%2!=0) ans=true;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246227,
                "title": "c-simple-one-line-xor-solution",
                "content": "```\\n    bool squareIsWhite(string coordinates) {\\n        return (coordinates[1] ^ coordinates[0]) & 1;\\n    }\\n```\\nIf we simplify the problem and just look at the small 2x2 square of [a1, a2, b1, b2] you can easily notice how it\\'s a perfect Xor grid, and luckily because of how the ascii numbers for both characters of our starting square in the grid (\\'a\\' and \\'1\\') have the same odd parity (rightmost bit is 1), the result of their Xor is 0 in the rightmost bit, then the rest of the grid follows the pattern correctly.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n    bool squareIsWhite(string coordinates) {\\n        return (coordinates[1] ^ coordinates[0]) & 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189088,
                "title": "java-100-faster-solution",
                "content": "``SHAH, your march my dear \\u265F ``\\n\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int x = 98 - (int) coordinates.charAt(0); // ascii table a=98\\n        int y = (int) coordinates.charAt(1) - \\'0\\';\\n        x = y % 2 == 0 ? x + 1 : x;\\n        return ((y * 8) + x) % 2 == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int x = 98 - (int) coordinates.charAt(0); // ascii table a=98\\n        int y = (int) coordinates.charAt(1) - \\'0\\';\\n        x = y % 2 == 0 ? x + 1 : x;\\n        return ((y * 8) + x) % 2 == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182956,
                "title": "c-runtime-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        // if rows are odd then starts with black\\n        // here even col is black\\n        if(int(coordinates[1]) % 2 != 0)\\n        {\\n            if((coordinates[0]-\\'a\\')%2 == 0)\\n            {\\n                return false;\\n            }\\n            return true;\\n        }\\n        // if rows are even then starts with white\\n        // here even col is white\\n        if((coordinates[0]-\\'a\\')%2 == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        // if rows are odd then starts with black\\n        // here even col is black\\n        if(int(coordinates[1]) % 2 != 0)\\n        {\\n            if((coordinates[0]-\\'a\\')%2 == 0)\\n            {\\n                return false;\\n            }\\n            return true;\\n        }\\n        // if rows are even then starts with white\\n        // here even col is white\\n        if((coordinates[0]-\\'a\\')%2 == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259329,
                "title": "easy-c-solution-one-line",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        //if the sum of row number and col number is odd then the \\n        //square color is white\\n        return ((coordinates[0]-\\'a\\'+1+coordinates[1]-\\'0\\')%2);\\n    }\\n};\\n```\\n**please upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        //if the sum of row number and col number is odd then the \\n        //square color is white\\n        return ((coordinates[0]-\\'a\\'+1+coordinates[1]-\\'0\\')%2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178008,
                "title": "easy-javascript-solution-1-line",
                "content": "```\\n/**\\n * @param {string} coordinates\\n * @return {boolean}\\n */\\nvar squareIsWhite = function(coordinates) {\\n    return \"aceg\".includes(coordinates[0]) ? coordinates[1] % 2 === 0 : coordinates[1] % 2 === 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} coordinates\\n * @return {boolean}\\n */\\nvar squareIsWhite = function(coordinates) {\\n    return \"aceg\".includes(coordinates[0]) ? coordinates[1] % 2 === 0 : coordinates[1] % 2 === 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155112,
                "title": "100-faster-0-ms-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n      char first = coordinates.charAt(0);\\n      char second = coordinates.charAt(1);\\n      int num = second-\\'0\\';\\n      if(first==\\'a\\' || first==\\'c\\'|| first==\\'e\\' || first==\\'g\\')\\n      {\\n          return num%2==0;\\n      }\\n      else\\n      {\\n          return num%2!=0;\\n      }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n      char first = coordinates.charAt(0);\\n      char second = coordinates.charAt(1);\\n      int num = second-\\'0\\';\\n      if(first==\\'a\\' || first==\\'c\\'|| first==\\'e\\' || first==\\'g\\')\\n      {\\n          return num%2==0;\\n      }\\n      else\\n      {\\n          return num%2!=0;\\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151584,
                "title": "swift-one-liner-or-bit",
                "content": "swift\\n\\n1.  One Liner \\n\\n```\\nfunc squareIsWhite(_ coordinates: String) -> Bool {\\n\\treturn coordinates.map(\\\\.unicodeScalars.first!.value).reduce(0, +) % 2 != 0\\n}\\n```\\n\\n2. Bit\\n\\n```\\nfunc squareIsWhite(_ coordinates: String) -> Bool {\\n\\tvar num: UInt32 = 0\\n\\n\\tcoordinates.forEach {\\n\\t\\tif let i = UInt32(String($0)) {\\n\\t\\t\\tnum = (num & i) ^ (~num & ~i) // second char\\n\\t\\t} else {\\n\\t\\t\\tnum = $0.unicodeScalars.first!.value // first char\\n\\t\\t}\\n\\t}\\n\\n\\treturn num % 2 == 0\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc squareIsWhite(_ coordinates: String) -> Bool {\\n\\treturn coordinates.map(\\\\.unicodeScalars.first!.value).reduce(0, +) % 2 != 0\\n}\\n```\n```\\nfunc squareIsWhite(_ coordinates: String) -> Bool {\\n\\tvar num: UInt32 = 0\\n\\n\\tcoordinates.forEach {\\n\\t\\tif let i = UInt32(String($0)) {\\n\\t\\t\\tnum = (num & i) ^ (~num & ~i) // second char\\n\\t\\t} else {\\n\\t\\t\\tnum = $0.unicodeScalars.first!.value // first char\\n\\t\\t}\\n\\t}\\n\\n\\treturn num % 2 == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1143867,
                "title": "c-solution",
                "content": "```\\npublic bool SquareIsWhite(string c)\\n\\t=> (c[0] + c[1] - \\'a\\' - \\'1\\') % 2 == 1;\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool SquareIsWhite(string c)\\n\\t=> (c[0] + c[1] - \\'a\\' - \\'1\\') % 2 == 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140960,
                "title": "ruby-two-solutions",
                "content": "### First solution\\n\\nCheck vertical and then horisontal even or odd.\\n\\n```ruby\\ndef square_is_white(coordinates)\\n  x = coordinates[0]\\n  y = coordinates[1].to_i\\n  %w[b d f h].include?(x) ? y.odd? : y.even?\\nend\\n```\\n\\n### Second solution\\n\\nRely on characters byte codes\\n\\n```ruby\\ndef square_is_white(coordinates)\\n  coordinates.bytes.sum.odd?\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef square_is_white(coordinates)\\n  x = coordinates[0]\\n  y = coordinates[1].to_i\\n  %w[b d f h].include?(x) ? y.odd? : y.even?\\nend\\n```\n```ruby\\ndef square_is_white(coordinates)\\n  coordinates.bytes.sum.odd?\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3918014,
                "title": "java-code-100-fast-shortcut",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char c = coordinates.charAt(0);\\n        char n = coordinates.charAt(1);\\n        int num = c-\\'a\\';\\n        num = num+n;\\n        if(num%2==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char c = coordinates.charAt(0);\\n        char n = coordinates.charAt(1);\\n        int num = c-\\'a\\';\\n        num = num+n;\\n        if(num%2==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723674,
                "title": "100-beats-easy-java-solution-using-one-if-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\ncheck the numbers on the column are form 1 to 8\\nsimilarly, consider character \\'a\\' on horizontal row as 1 \\n\\nsuch as \\'a\\'= 1\\nand \\'b\\'= 2 ...\\n\\nnow if we get the **sum** of the number on the column and row\\n\\nand you can check that if **sum** is **even** then the Square is **Black**\\nand if **sum** is **odd** then Square is **White**\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        int num = (int )(coordinates.charAt(0)-\\'a\\'+1);\\n        int num2 = (int)(coordinates.charAt(1)-\\'1\\'+1);\\n\\n        //checks if the sum is even or not \\n        // if sum is even that means the square is Black.\\n        if((num+num2 )%2== 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        int num = (int )(coordinates.charAt(0)-\\'a\\'+1);\\n        int num2 = (int)(coordinates.charAt(1)-\\'1\\'+1);\\n\\n        //checks if the sum is even or not \\n        // if sum is even that means the square is Black.\\n        if((num+num2 )%2== 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687413,
                "title": "beats-easy-solution-only-using-if-and-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char[] c = coordinates.toCharArray();\\n        int abc = c[0];\\n        int num = c[1];\\n\\n        if(abc % 2 == 0) {\\n            if(num % 2 == 0) {\\n                return false;\\n            }\\n            else return true;\\n        }\\n        else {\\n            if(num % 2 == 0) {\\n                return true;\\n            }\\n            else return false;\\n        }\\n        // if you like it, upvote it.\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char[] c = coordinates.toCharArray();\\n        int abc = c[0];\\n        int num = c[1];\\n\\n        if(abc % 2 == 0) {\\n            if(num % 2 == 0) {\\n                return false;\\n            }\\n            else return true;\\n        }\\n        else {\\n            if(num % 2 == 0) {\\n                return true;\\n            }\\n            else return false;\\n        }\\n        // if you like it, upvote it.\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343640,
                "title": "0-ms-java-easy-peasy-lemon-squeezy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int ch1 =   (coordinates.charAt(0) - \\'a\\') + 1;\\n        int ch2 =   (coordinates.charAt(1) - \\'1\\') + 1;\\n        if(ch2 % 2 == 0){\\n            if(ch1 % 2 == 0) return false;\\n            else return true;\\n        }\\n\\n        else{\\n            if(ch1 % 2 == 0) return true;\\n            else return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int ch1 =   (coordinates.charAt(0) - \\'a\\') + 1;\\n        int ch2 =   (coordinates.charAt(1) - \\'1\\') + 1;\\n        if(ch2 % 2 == 0){\\n            if(ch1 % 2 == 0) return false;\\n            else return true;\\n        }\\n\\n        else{\\n            if(ch1 % 2 == 0) return true;\\n            else return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183452,
                "title": "simple-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if((coordinates[0]==\\'a\\'||coordinates[0]==\\'c\\'||coordinates[0]==\\'e\\'||coordinates[0]==\\'g\\') && coordinates[1]%2!=0){\\n            return false;\\n        }else if((coordinates[0]==\\'b\\'||coordinates[0]==\\'d\\'||coordinates[0]==\\'f\\'||coordinates[0]==\\'h\\') && coordinates[1]%2==0){\\n            return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n};\\n```\\n\\nIf you like the code implementation, make sure to upvote :) \\u270C\\nKeep Coding.....\\nKeep chilling...",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if((coordinates[0]==\\'a\\'||coordinates[0]==\\'c\\'||coordinates[0]==\\'e\\'||coordinates[0]==\\'g\\') && coordinates[1]%2!=0){\\n            return false;\\n        }else if((coordinates[0]==\\'b\\'||coordinates[0]==\\'d\\'||coordinates[0]==\\'f\\'||coordinates[0]==\\'h\\') && coordinates[1]%2==0){\\n            return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180117,
                "title": "1812-is-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst squareIsWhite = coord => (coord.codePointAt(0) + coord.codePointAt(1)) % 2 === 1\\n    \\n  \\n \\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst squareIsWhite = coord => (coord.codePointAt(0) + coord.codePointAt(1)) % 2 === 1\\n    \\n  \\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107955,
                "title": "easy-java-solution-by-dev",
                "content": "# Easy Understanding Java solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic boolean squareIsWhite(String c) \\n    {\\n        int a = c.charAt(0)-\\'a\\'+1;\\n        int n = c.charAt(1)-\\'0\\';\\n        if((a+n)%2==0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic boolean squareIsWhite(String c) \\n    {\\n        int a = c.charAt(0)-\\'a\\'+1;\\n        int n = c.charAt(1)-\\'0\\';\\n        if((a+n)%2==0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966488,
                "title": "java-solution-with-0ms-runtime-tc-o-n-beats-100",
                "content": "**If you found it easy to understand, Please do upvote :)\\nThankyou!!**\\n**--------------------------------------------------------------------------------------------------**\\n![Today Leetcode Pic.JPG](https://assets.leetcode.com/users/images/dc10da9b-dd7d-4165-bc49-72346e8936e0_1672303599.0964854.jpeg)**--------------------------------------------------------------------------------------------------**\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) \\n    {\\n        int alpha = coordinates.charAt(0)-\\'a\\'-1;\\n        int num = coordinates.charAt(1)-\\'0\\';\\n\\n        return ((alpha&1)==1 && (num&1)!=1) || ((alpha&1)!=1 && (num&1)==1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) \\n    {\\n        int alpha = coordinates.charAt(0)-\\'a\\'-1;\\n        int num = coordinates.charAt(1)-\\'0\\';\\n\\n        return ((alpha&1)==1 && (num&1)!=1) || ((alpha&1)!=1 && (num&1)==1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855688,
                "title": "python-solution-o-1-time-complexity",
                "content": "# Approach\\nConverting the co-ordinates to the indexes as per the chessboard grid. If the sum of the two indexes is even then return **False** else return **True**.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def squareIsWhite(self, coordinates):\\n        \"\"\"\\n        :type coordinates: str\\n        :rtype: bool\\n        \"\"\"\\n\\n        # Converting the coordinates to index\\n\\n        dict = {\\n            \\'a\\':0,\\n            \\'b\\':1,\\n            \\'c\\':2,\\n            \\'d\\':3,\\n            \\'e\\':4,\\n            \\'f\\':5,\\n            \\'g\\':6,\\n            \\'h\\':7\\n        }\\n\\n        coords = [dict[coordinates[0]],int(coordinates[1])-1]\\n\\n        # If coordinates sum is even then return False\\n        if sum(coords)%2==0:\\n            return False\\n        #If sum is odd return True\\n        else:\\n            return True\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def squareIsWhite(self, coordinates):\\n        \"\"\"\\n        :type coordinates: str\\n        :rtype: bool\\n        \"\"\"\\n\\n        # Converting the coordinates to index\\n\\n        dict = {\\n            \\'a\\':0,\\n            \\'b\\':1,\\n            \\'c\\':2,\\n            \\'d\\':3,\\n            \\'e\\':4,\\n            \\'f\\':5,\\n            \\'g\\':6,\\n            \\'h\\':7\\n        }\\n\\n        coords = [dict[coordinates[0]],int(coordinates[1])-1]\\n\\n        # If coordinates sum is even then return False\\n        if sum(coords)%2==0:\\n            return False\\n        #If sum is odd return True\\n        else:\\n            return True\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815733,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\n\\n   class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int c = coordinates[0] - 96 + coordinates[1] - \\'0\\';\\n        return c & 1;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int c = coordinates[0] - 96 + coordinates[1] - \\'0\\';\\n        return c & 1;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773815,
                "title": "1-line-solution-with-ord-o-1",
                "content": "# Code\\n```\\nclass Solution:\\n    def squareIsWhite(self, C: str) -> bool:\\n        return (ord(C[0]) + ord(C[1])) & 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, C: str) -> bool:\\n        return (ord(C[0]) + ord(C[1])) & 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715640,
                "title": "determine-color-of-a-chessboard-square-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(((coordinates[0]-\\'a\\')+(coordinates[1]-\\'0\\'))%2==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(((coordinates[0]-\\'a\\')+(coordinates[1]-\\'0\\'))%2==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671810,
                "title": "javascript-simple-solution-99-1-faster",
                "content": "```\\nconst squareIsWhite = function (coordinates) {\\n  const letters = [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\'];\\n  const [l, n] = coordinates.split(\\'\\');\\n  if ((letters.indexOf(l) % 2 == 0 && n % 2 == 0) || (letters.indexOf(l) % 2 == 1 && n % 2 == 1)) \\n    return true;\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst squareIsWhite = function (coordinates) {\\n  const letters = [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\'];\\n  const [l, n] = coordinates.split(\\'\\');\\n  if ((letters.indexOf(l) % 2 == 0 && n % 2 == 0) || (letters.indexOf(l) % 2 == 1 && n % 2 == 1)) \\n    return true;\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575900,
                "title": "java-math-faster-than-100-java-submissions",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        Character str = coordinates.charAt(0);\\n        int num = Character.getNumericValue(coordinates.charAt(1));\\n        int flag=0;\\n        if(str==\\'a\\' || str==\\'c\\' || str==\\'e\\' || str==\\'g\\'){\\n            if(num%2==0)\\n                flag=1;\\n        }\\n        else{\\n            if(num%2!=0)\\n                flag=1;\\n        }\\n        if(flag==0)\\n            return false;\\n        return true;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        Character str = coordinates.charAt(0);\\n        int num = Character.getNumericValue(coordinates.charAt(1));\\n        int flag=0;\\n        if(str==\\'a\\' || str==\\'c\\' || str==\\'e\\' || str==\\'g\\'){\\n            if(num%2==0)\\n                flag=1;\\n        }\\n        else{\\n            if(num%2!=0)\\n                flag=1;\\n        }\\n        if(flag==0)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499408,
                "title": "simple-if-else-faster-than-83",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        black = \"aceg\"\\n        white = \"bdfh\"\\n        if coordinates[0] in black and int(coordinates[1]) % 2 == 1:\\n            return False\\n        elif coordinates[0] in white and int(coordinates[1]) % 2 == 0:\\n            return False\\n        else:\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        black = \"aceg\"\\n        white = \"bdfh\"\\n        if coordinates[0] in black and int(coordinates[1]) % 2 == 1:\\n            return False\\n        elif coordinates[0] in white and int(coordinates[1]) % 2 == 0:\\n            return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277434,
                "title": "python-3-easy-self-explanitory",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, c: str) -> bool:\\n        e,o = [\"b\",\"d\",\"f\",\"h\"], [\"a\",\"c\",\"e\",\"g\"]\\n        if int(c[-1]) % 2 == 0:\\n            if c[0] in e: return False\\n            else: return True\\n        else:\\n            if c[0] in e: return True\\n            else: return False\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, c: str) -> bool:\\n        e,o = [\"b\",\"d\",\"f\",\"h\"], [\"a\",\"c\",\"e\",\"g\"]\\n        if int(c[-1]) % 2 == 0:\\n            if c[0] in e: return False\\n            else: return True\\n        else:\\n            if c[0] in e: return True\\n            else: return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2165451,
                "title": "c-one-liner-easy-o-1",
                "content": "**Intuition:-**\\n\\n-> You can easily get the **pattern** in the chessboard.\\n-> sum( x, y ) of any co-ordinate is **even** -> Its **black square** (return 0)\\n-> sum( x, y ) of any co-ordinate is **odd** -> its **while square** (return 1)\\n-> also I have used **bitwise AND operator** to check odd or even. (&)\\n-> I have used **ternary operator** also here.\\n\\n**Complexity:-**\\n\\nTime=O(1) \\nSpace=O(1) \\n\\nHoping you understood the solution :)\\nPlease **upvote** if you found it usefull !\\nThank you..\\n\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string s) {\\n        return ((s[0]+s[1])&1)?1:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string s) {\\n        return ((s[0]+s[1])&1)?1:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122786,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        odds = [\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        evens = [\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        \\n        if coordinates[0] in odds:\\n            if int(coordinates[1]) % 2 != 0:\\n                return False\\n            else:\\n                return True\\n        else:\\n            if int(coordinates[1]) % 2 != 0:\\n                return True\\n            else:\\n                return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        odds = [\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        evens = [\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        \\n        if coordinates[0] in odds:\\n            if int(coordinates[1]) % 2 != 0:\\n                return False\\n            else:\\n                return True\\n        else:\\n            if int(coordinates[1]) % 2 != 0:\\n                return True\\n            else:\\n                return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864402,
                "title": "java-one-liner-with-explanation",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) + coordinates.charAt(1)) % 2 != 0;\\n    }\\n}\\n```\\nThe ASCII decimal value for the letter \"a\" is odd and the ASCII decimal value for \"b\" is even and \"c\" is odd ... etc. As for the numbers the ASCII value for an odd number is odd and the ASCII number for an even number is even. (As can be seen by the table below)\\n\\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/ASCII-Table-wide.svg/2560px-ASCII-Table-wide.svg.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"400\"/>\\n\\n\\nHere we take the ASCII value of the char at postion 0 and the ASCII value of the char at postion 1 and check if their sum is odd if it is then we know that we are standing on a white square so we return true otherwise we return false.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) + coordinates.charAt(1)) % 2 != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801035,
                "title": "python-c-one-line",
                "content": "```py\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return sum(map(ord,coordinates)) % 2\\n```\\n```c\\nbool squareIsWhite(char * coordinates){\\n    return (*coordinates + *++coordinates) % 2;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```py\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return sum(map(ord,coordinates)) % 2\\n```\n```c\\nbool squareIsWhite(char * coordinates){\\n    return (*coordinates + *++coordinates) % 2;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702927,
                "title": "easy-solution-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string c) {\\n\\t//if sum of cordinates is even than color is black \\n        int x = c[0]-\\'a\\'+1;\\n        int y = c[1]-\\'1\\'+1;\\n        cout<<y << \"\\\\n \";\\n        if((x+y)%2==0)\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string c) {\\n\\t//if sum of cordinates is even than color is black \\n        int x = c[0]-\\'a\\'+1;\\n        int y = c[1]-\\'1\\'+1;\\n        cout<<y << \"\\\\n \";\\n        if((x+y)%2==0)\\n        return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1701797,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n)**\\n```\\n/**\\n * @param {string} coordinates\\n * @return {boolean}\\n */\\nvar squareIsWhite = function(coordinates) {\\n    let oddchar = \"aceg\", evenchar = \"bdfh\", ch = coordinates.charAt(0), n = parseInt(coordinates.charAt(1)+\"\");\\n    if((n % 2 != 0 && oddchar.includes(ch)) || (n % 2 == 0 && evenchar.includes(ch))){\\n        return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} coordinates\\n * @return {boolean}\\n */\\nvar squareIsWhite = function(coordinates) {\\n    let oddchar = \"aceg\", evenchar = \"bdfh\", ch = coordinates.charAt(0), n = parseInt(coordinates.charAt(1)+\"\");\\n    if((n % 2 != 0 && oddchar.includes(ch)) || (n % 2 == 0 && evenchar.includes(ch))){\\n        return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701794,
                "title": "short-clean-one-liner-java",
                "content": "\\n```java []\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0)-\\'a\\'+ coordinates.charAt(1)-\\'0\\') % 2 == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0)-\\'a\\'+ coordinates.charAt(1)-\\'0\\') % 2 == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498219,
                "title": "c-100-faster",
                "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int x = coordinates[0]-\\'a\\';\\n        int y = coordinates[1] - 1;\\n        if((x % 2 == 0 && y % 2 ==0   || x % 2 != 0 && y % 2 != 0)){\\n            return false;\\n        }\\n        else {\\n            return true;\\n        }\\n    }\\n* 1. * };[](http://)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int x = coordinates[0]-\\'a\\';\\n        int y = coordinates[1] - 1;\\n        if((x % 2 == 0 && y % 2 ==0   || x % 2 != 0 && y % 2 != 0)){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1433811,
                "title": "java-3-line-simple-100-solution",
                "content": "if you like it pls upvote\\n\\n\\n\\nJava\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int left = coordinates.charAt(0)-\\'a\\';\\n        int right = coordinates.charAt(1)-\\'1\\';      \\n        return (left %2 == 0 && right % 2 == 1) || (left %2 != 0 && right % 2 != 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int left = coordinates.charAt(0)-\\'a\\';\\n        int right = coordinates.charAt(1)-\\'1\\';      \\n        return (left %2 == 0 && right % 2 == 1) || (left %2 != 0 && right % 2 != 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354192,
                "title": "c-100-fast",
                "content": "```\\n bool squareIsWhite(string coordinates) {\\n        int a=coordinates[0]+coordinates[1];\\n        if(a%2==1)\\n        return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool squareIsWhite(string coordinates) {\\n        int a=coordinates[0]+coordinates[1];\\n        if(a%2==1)\\n        return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310367,
                "title": "100-faster-one-line-java-solution-with-explanation",
                "content": "Imagine the x cordinate are also 1,2,3...so on. <br>\\n<img src=\"https://assets.leetcode.com/users/images/36b5a71a-2639-4344-9edc-f88982b9096a_1625199149.2753234.png\" alt=\"chess board image\" width=\"300\" height=\"auto\">\\n\\n**Idea is :** Now, when we see this board we can find the logic that.\\n- If x and y both are even Or odd then square is black.\\n- Otherwise square is white.\\n\\nSo Pseudo code is :\\n```\\nif( x is even and y is even ) return false ( black square )\\nelse if ( x is odd and y is odd ) return false ( black square )\\nelse return true;\\n```\\n\\nBut we can short it by this Logic :\\nIf x and y both are even Or odd then (x + y) is even\\nother wise (x + y) is odd\\n```\\nif((x + y) is odd) return true\\nelse return false;\\n```\\n\\nMy Solution is :\\n\\n\\n\\n\\n```\\n    public boolean squareIsWhite(String coordinates) {\\n        return ((coordinates.charAt(0) - \\'a\\') + (coordinates.charAt(1) - \\'1\\')) % 2 != 0 ;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nif( x is even and y is even ) return false ( black square )\\nelse if ( x is odd and y is odd ) return false ( black square )\\nelse return true;\\n```\n```\\nif((x + y) is odd) return true\\nelse return false;\\n```\n```\\n    public boolean squareIsWhite(String coordinates) {\\n        return ((coordinates.charAt(0) - \\'a\\') + (coordinates.charAt(1) - \\'1\\')) % 2 != 0 ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1289374,
                "title": "c-one-liner-easy-understanding-with-comments",
                "content": "//Idea behind this to find a unique square number.\\n//If that square number is even it will be white , else black.\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int i= (int)(coordinates[0]-\\'a\\'+1) + (int)(coordinates[1]-\\'0\\');\\n        if(i%2==0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int i= (int)(coordinates[0]-\\'a\\'+1) + (int)(coordinates[1]-\\'0\\');\\n        if(i%2==0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289166,
                "title": "python-1-liner-with-explanation",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        \\'\\'\\'\\n        check if file/x-coordinate and rank/y-coordinate are both even or are both odd\\n        must be odd rank with even file, or odd file with even rank for it to be a white square\\n        \\'\\'\\'\\n        return int(coordinates[1])%2 != ord(coordinates[0])%2\\n```\\nHere the y-coordinate/rank is converted to an integer to check if its an odd or even rank. Using the python function ```ord()``` you get the ascii value of the x-coordinate/file to check if the file is an odd or even file (e.g C1, C is the 3rd file after A and B).  It then returns True if the check evaluates to False since only 1 coordinate is even, meaning that the coordinate is a white square.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        \\'\\'\\'\\n        check if file/x-coordinate and rank/y-coordinate are both even or are both odd\\n        must be odd rank with even file, or odd file with even rank for it to be a white square\\n        \\'\\'\\'\\n        return int(coordinates[1])%2 != ord(coordinates[0])%2\\n```\n```ord()```",
                "codeTag": "Java"
            },
            {
                "id": 1267867,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) \\n    {\\n       return ((coordinates.charAt(0)-\\'a\\'+coordinates.charAt(1)-\\'1\\')%2!=0);\\n    }\\n}\\n\\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) \\n    {\\n       return ((coordinates.charAt(0)-\\'a\\'+coordinates.charAt(1)-\\'1\\')%2!=0);\\n    }\\n}\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151663,
                "title": "c-time-o-1",
                "content": "**Time Complexity: O(1)\\nSpace Complexity: O(1)**\\n\\n```\\nclass Solution \\n{\\npublic:\\n    bool squareIsWhite(string cood)\\n    {\\n        int f = cood[0]-\\'a\\';\\n        int s = cood[1]-\\'0\\';\\n        \\n        // f = a, c, e, g\\n        if ( f % 2 == 0 ) {\\n            if ( s % 2 == 0 ) {\\n                return true;\\n            }\\n        }\\n        // f = b, d, f, h\\n        else if ( f % 2 != 0 ) {\\n            if ( s % 2 != 0 ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**If you liked it, please upvote it**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool squareIsWhite(string cood)\\n    {\\n        int f = cood[0]-\\'a\\';\\n        int s = cood[1]-\\'0\\';\\n        \\n        // f = a, c, e, g\\n        if ( f % 2 == 0 ) {\\n            if ( s % 2 == 0 ) {\\n                return true;\\n            }\\n        }\\n        // f = b, d, f, h\\n        else if ( f % 2 != 0 ) {\\n            if ( s % 2 != 0 ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147467,
                "title": "javascript-100-faster-simple",
                "content": "```\\nvar squareIsWhite = function(coordinates) {\\n    const columns = [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\']\\n    \\n    let i = 0;\\n    \\n    while(coordinates[0] !== columns[i]) {\\n        i++;\\n    }\\n    \\n    let num = i + parseInt(coordinates[1]);\\n    \\n    \\n    return num % 2 === 0 \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar squareIsWhite = function(coordinates) {\\n    const columns = [\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\', \\'h\\']\\n    \\n    let i = 0;\\n    \\n    while(coordinates[0] !== columns[i]) {\\n        i++;\\n    }\\n    \\n    let num = i + parseInt(coordinates[1]);\\n    \\n    \\n    return num % 2 === 0 \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144437,
                "title": "golang-one-liner-using-bitwise-operations",
                "content": "```\\nfunc squareIsWhite(coordinates string) bool {\\n    return 0 != ((coordinates[0] ^ coordinates[1]) & 1)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc squareIsWhite(coordinates string) bool {\\n    return 0 != ((coordinates[0] ^ coordinates[1]) & 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140664,
                "title": "python-1-lines",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return True if ((ord(coordinates[0]))+int(coordinates[1])) % 2 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return True if ((ord(coordinates[0]))+int(coordinates[1])) % 2 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140623,
                "title": "simple-python-3-solution",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        x, y = ord(coordinates[0]) - 65, int(coordinates[1])\\n        return y % 2 == 1 if x % 2 == 1 else y % 2 == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        x, y = ord(coordinates[0]) - 65, int(coordinates[1])\\n        return y % 2 == 1 if x % 2 == 1 else y % 2 == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983942,
                "title": "java-simple-solution-determine-color-of-a-chessboard-square",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char letter = coordinates.charAt(0);\\n        char digit = coordinates.charAt(1);\\n        if((letter%2 == 1 && digit%2 == 1) || (letter%2 == 0 && digit%2 == 0)){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char letter = coordinates.charAt(0);\\n        char digit = coordinates.charAt(1);\\n        if((letter%2 == 1 && digit%2 == 1) || (letter%2 == 0 && digit%2 == 0)){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974830,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int x=coordinates.charAt(0)-\\'a\\';\\n        int y=coordinates.charAt(1)-\\'0\\';\\n        if(x % 2 !=0 && y % 2 != 0)\\n            return true;\\n        else if(x % 2 ==0 && y % 2 ==0 )\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int x=coordinates.charAt(0)-\\'a\\';\\n        int y=coordinates.charAt(1)-\\'0\\';\\n        if(x % 2 !=0 && y % 2 != 0)\\n            return true;\\n        else if(x % 2 ==0 && y % 2 ==0 )\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967997,
                "title": "java-100-faster-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        if((coordinates.charAt(0)+coordinates.charAt(1))%2==0){\\n          return false;\\n            \\n         }\\n         else{\\n          return true;\\n         }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        if((coordinates.charAt(0)+coordinates.charAt(1))%2==0){\\n          return false;\\n            \\n         }\\n         else{\\n          return true;\\n         }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948749,
                "title": "beats-100-using-hash-table-easy-approach",
                "content": "# PLEASE UPVOTE\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n - Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n      Map<Character,Integer> map=new HashMap<Character,Integer>();\\n      map.put(\\'a\\',1);\\n      map.put(\\'b\\',2);\\n      map.put(\\'c\\',3);\\n      map.put(\\'d\\',4);\\n      map.put(\\'e\\',5);\\n      map.put(\\'f\\',6);\\n      map.put(\\'g\\',7);\\n      map.put(\\'h\\',8);\\n      char []out=coordinates.toCharArray();\\n      if((map.get(out[0])+out[1])%2==0){\\n          return false;\\n      }\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n      Map<Character,Integer> map=new HashMap<Character,Integer>();\\n      map.put(\\'a\\',1);\\n      map.put(\\'b\\',2);\\n      map.put(\\'c\\',3);\\n      map.put(\\'d\\',4);\\n      map.put(\\'e\\',5);\\n      map.put(\\'f\\',6);\\n      map.put(\\'g\\',7);\\n      map.put(\\'h\\',8);\\n      char []out=coordinates.toCharArray();\\n      if((map.get(out[0])+out[1])%2==0){\\n          return false;\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924871,
                "title": "extremely-intuitive-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you look at the chess board, the pattern is pretty clear: colors alternate in all directions. If you think of the lettered side of the board as another numbered side of the board (i.e. the board is a matrix), then you can easily tell that when you add up both coordinates, all white squares are on odd numbered coordinate sums, with all black squares being on even coordinate sums. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the letter into a number (Java will take the lexicographical number of the letter), and add it to the number. If the result is even, the square is black, so return false. Otherwise, return true, and the square must be white. \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int letter = Integer.valueOf(coordinates.charAt(0));\\n        int num = Integer.valueOf(coordinates.charAt(1));\\n        if ((letter+num) % 2 == 0) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int letter = Integer.valueOf(coordinates.charAt(0));\\n        int num = Integer.valueOf(coordinates.charAt(1));\\n        if ((letter+num) % 2 == 0) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899582,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String c) {\\n        int value = (c.charAt(0) -\\'a\\' + 1) + (c.charAt(1) - \\'0\\');\\n        if(value % 2 == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String c) {\\n        int value = (c.charAt(0) -\\'a\\' + 1) + (c.charAt(1) - \\'0\\');\\n        if(value % 2 == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871505,
                "title": "one-line-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) + coordinates.charAt(1)) % 2 == 1 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) + coordinates.charAt(1)) % 2 == 1 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791270,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n\\n        if(coordinates[0] % 2 == 0 && coordinates[1] % 2 != 0)\\n            return true;\\n        else if (coordinates[0]%2!=0 && coordinates[1]%2==0)\\n            return true;\\n        else\\n            return false;    \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n\\n        if(coordinates[0] % 2 == 0 && coordinates[1] % 2 != 0)\\n            return true;\\n        else if (coordinates[0]%2!=0 && coordinates[1]%2==0)\\n            return true;\\n        else\\n            return false;    \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688664,
                "title": "simple-3-liner-solution-c-0ms-runtime",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if (coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\\n        else if (coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\\n        else return false;\\n    }\\n};\\n```\\nan upvote is appreciated! :)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if (coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\\n        else if (coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688659,
                "title": "easy-solution-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623431,
                "title": "just-in-1-line-0ms-beats-100-ascii",
                "content": "# Intuition\\nMy first approach was using if condition and checking for which alphabetical colum the input satisfies then checking the row is even or odd. That too gave me a 0ms result but i had to add if for every alternate column using or operator. something like this \\n# Approach - 1\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string c) {\\n        if(c[0]==\\'a\\' || c[0]==\\'c\\' || c[0]==\\'e\\' || c[0]==\\'g\\'){\\n            return (c[1]%2==0);\\n        }\\n        else if(c[0]==\\'b\\' || c[0]==\\'d\\' || c[0]==\\'f\\' || c[0]==\\'h\\'){\\n            return (c[1]%2!=0);\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n# Revised Approach\\nMy revised approach had a lot to do with ASCII table. See when input is \\'a1\\' then converting the string using ASCII will give 146 (\\'a\\'=97 and \\'1\\'=49) and block \\'a1\\' is black. So built a condition that if the additon is not even return true else false. That\\'s it!\\n\\n# Complexity\\n- Time complexity:\\n**O(1)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string c) {\\n        return ((c[0]+c[1])%2!=0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string c) {\\n        if(c[0]==\\'a\\' || c[0]==\\'c\\' || c[0]==\\'e\\' || c[0]==\\'g\\'){\\n            return (c[1]%2==0);\\n        }\\n        else if(c[0]==\\'b\\' || c[0]==\\'d\\' || c[0]==\\'f\\' || c[0]==\\'h\\'){\\n            return (c[1]%2!=0);\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string c) {\\n        return ((c[0]+c[1])%2!=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549429,
                "title": "simplest-efficient-c-code-time-o-1-space-o-1",
                "content": "# Intuition\\nThe given code aims to determine whether a square on a chessboard, identified by its coordinates, is white or black.\\n\\n# Approach\\nThe code takes the coordinates of a square as input and performs a calculation to determine its color. It converts the character representing the row (coordinates[1]) to an integer by subtracting the ASCII value of \\'1\\'. Similarly, it converts the character representing the column (coordinates[0]) to an integer by subtracting the ASCII value of \\'a\\'. It then adds these two values and checks if the sum is divisible by 2. If the sum is divisible by 2, it means the square is black (0-based indexing), and the function returns false. Otherwise, the square is white, and the function returns true.\\n\\n# Complexity\\n- Time complexity: $O(1)$ - The code performs a constant number of operations, regardless of the input.\\n\\n- Space complexity: $O(1)$ - The code uses a fixed amount of space to store intermediate variables and return the result.\\n\\n# Code\\n```\\nbool squareIsWhite(char * coordinates){\\n    if((coordinates[1]-\\'1\\' + (int)coordinates[0]-(int)\\'a\\')%2==0)\\n    return false;\\n    else\\n    return true;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool squareIsWhite(char * coordinates){\\n    if((coordinates[1]-\\'1\\' + (int)coordinates[0]-(int)\\'a\\')%2==0)\\n    return false;\\n    else\\n    return true;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542648,
                "title": "java-easy-and-understandable-solution",
                "content": "\\n\\n# CODE\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String c) {\\n       int aa[]={0,1,0,1,0,1,0,1}; \\n       int bb[]={1,0,1,0,1,0,1,0};\\n       int cc[]={0,1,0,1,0,1,0,1}; \\n       int dd[]={1,0,1,0,1,0,1,0};\\n       int ee[]={0,1,0,1,0,1,0,1}; \\n       int ff[]={1,0,1,0,1,0,1,0};\\n       int gg[]={0,1,0,1,0,1,0,1}; \\n       int hh[]={1,0,1,0,1,0,1,0};\\n       int k=0;\\n       int l=Integer.parseInt(c.charAt(1)+\"\");\\n       if(c.charAt(0)==\\'a\\'){\\n           \\n           k=aa[l-1];\\n       }\\n       else if(c.charAt(0)==\\'b\\'){\\n           k=bb[l-1];\\n       }\\n       else if(c.charAt(0)==\\'c\\'){\\n           k=cc[l-1];\\n       }\\n       else if(c.charAt(0)==\\'d\\'){\\n           k=dd[l-1];\\n       }\\n       else if(c.charAt(0)==\\'e\\'){\\n           k=ee[l-1];\\n       }\\n       else if(c.charAt(0)==\\'f\\'){\\n           k=ff[l-1];\\n       }\\n       else if(c.charAt(0)==\\'g\\'){\\n           k=gg[l-1];\\n       }\\n       else if(c.charAt(0)==\\'h\\'){\\n           k=hh[l-1];\\n       }\\n       if(k==0){\\n           return false;\\n       }\\n       else{\\n           return true;\\n       }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String c) {\\n       int aa[]={0,1,0,1,0,1,0,1}; \\n       int bb[]={1,0,1,0,1,0,1,0};\\n       int cc[]={0,1,0,1,0,1,0,1}; \\n       int dd[]={1,0,1,0,1,0,1,0};\\n       int ee[]={0,1,0,1,0,1,0,1}; \\n       int ff[]={1,0,1,0,1,0,1,0};\\n       int gg[]={0,1,0,1,0,1,0,1}; \\n       int hh[]={1,0,1,0,1,0,1,0};\\n       int k=0;\\n       int l=Integer.parseInt(c.charAt(1)+\"\");\\n       if(c.charAt(0)==\\'a\\'){\\n           \\n           k=aa[l-1];\\n       }\\n       else if(c.charAt(0)==\\'b\\'){\\n           k=bb[l-1];\\n       }\\n       else if(c.charAt(0)==\\'c\\'){\\n           k=cc[l-1];\\n       }\\n       else if(c.charAt(0)==\\'d\\'){\\n           k=dd[l-1];\\n       }\\n       else if(c.charAt(0)==\\'e\\'){\\n           k=ee[l-1];\\n       }\\n       else if(c.charAt(0)==\\'f\\'){\\n           k=ff[l-1];\\n       }\\n       else if(c.charAt(0)==\\'g\\'){\\n           k=gg[l-1];\\n       }\\n       else if(c.charAt(0)==\\'h\\'){\\n           k=hh[l-1];\\n       }\\n       if(k==0){\\n           return false;\\n       }\\n       else{\\n           return true;\\n       }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281107,
                "title": "3-liner-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool squareIsWhite(string cord)\\n    {\\n        if(cord[0]%2==0 && (cord[1]-\\'0\\')%2==0 || cord[0]%2 != 0 && cord[1]%2 != 0)\\n        return false;\\n        else \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool squareIsWhite(string cord)\\n    {\\n        if(cord[0]%2==0 && (cord[1]-\\'0\\')%2==0 || cord[0]%2 != 0 && cord[1]%2 != 0)\\n        return false;\\n        else \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274750,
                "title": "beats-100-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string s) {\\n    \\n        if((s[0]+s[1])%2==0)\\n            return false;\\n        else\\n            return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string s) {\\n    \\n        if((s[0]+s[1])%2==0)\\n            return false;\\n        else\\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181433,
                "title": "determine-color-of-a-chessboard-square",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![chessboard.PNG](https://assets.leetcode.com/users/images/6a798f8c-1fea-4849-8465-41f289a1fda1_1676306436.6669266.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        alpha=[\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\']\\n        for i in range(len(alpha)):\\n            for j in range(1,9):\\n                if alpha[i]+str(j)==coordinates:\\n                    if (i+j)%2==0:\\n                        return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        alpha=[\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\']\\n        for i in range(len(alpha)):\\n            for j in range(1,9):\\n                if alpha[i]+str(j)==coordinates:\\n                    if (i+j)%2==0:\\n                        return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180376,
                "title": "determine-color-of-a-chessboard-square-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse ASCII values of the alphabets\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0)\\n        {\\n            return true;\\n        }\\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0)\\n        {\\n            return true;\\n        }\\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177207,
                "title": "simplest-solution-in-java",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        Character a = coordinates.charAt(0);\\n        Character c = (coordinates.charAt(1));\\n        int b = c - \\'0\\';\\n\\n        int flag = 0;\\n        if(b%2==0)\\n            flag = 1;\\n        \\n        if((a == \\'a\\' || a==\\'c\\' || a==\\'e\\' || a==\\'g\\') && flag==1)\\n            return true;\\n        if((a == \\'b\\' || a==\\'d\\' || a==\\'f\\' || a==\\'h\\') && flag==0)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        Character a = coordinates.charAt(0);\\n        Character c = (coordinates.charAt(1));\\n        int b = c - \\'0\\';\\n\\n        int flag = 0;\\n        if(b%2==0)\\n            flag = 1;\\n        \\n        if((a == \\'a\\' || a==\\'c\\' || a==\\'e\\' || a==\\'g\\') && flag==1)\\n            return true;\\n        if((a == \\'b\\' || a==\\'d\\' || a==\\'f\\' || a==\\'h\\') && flag==0)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136659,
                "title": "just-some-mathematics-using-javascript",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst squareIsWhite = coordinates => (((coordinates.charCodeAt(0) - 97) + (coordinates[1] - 1)) % 2);\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst squareIsWhite = coordinates => (((coordinates.charCodeAt(0) - 97) + (coordinates[1] - 1)) % 2);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3049400,
                "title": "cpp-easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        unordered_map<char,int>m;\\n        m[\\'a\\']=0;\\n        m[\\'b\\']=1;\\n        m[\\'c\\']=0;\\n        m[\\'d\\']=1;\\n        m[\\'e\\']=0;\\n        m[\\'f\\']=1;\\n        m[\\'g\\']=0;\\n        m[\\'h\\']=1;\\n        if(m[coordinates[0]]==0)\\n        {\\n          \\n            if((coordinates[1]-\\'0\\')%2==0)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else{\\n            \\n            if((coordinates[1]-\\'0\\')%2!=0)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        unordered_map<char,int>m;\\n        m[\\'a\\']=0;\\n        m[\\'b\\']=1;\\n        m[\\'c\\']=0;\\n        m[\\'d\\']=1;\\n        m[\\'e\\']=0;\\n        m[\\'f\\']=1;\\n        m[\\'g\\']=0;\\n        m[\\'h\\']=1;\\n        if(m[coordinates[0]]==0)\\n        {\\n          \\n            if((coordinates[1]-\\'0\\')%2==0)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else{\\n            \\n            if((coordinates[1]-\\'0\\')%2!=0)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946808,
                "title": "java-math-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck the value of each square by adding the ascii of the alphabet and the numeric value of the number. Then return according to the required problem statement..\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int ascii = coordinates.charAt(0) - \\'a\\';\\n        int val = coordinates.charAt(1) - \\'0\\';\\n        int total = ascii + val;\\n        if(total % 2 == 0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int ascii = coordinates.charAt(0) - \\'a\\';\\n        int val = coordinates.charAt(1) - \\'0\\';\\n        int total = ascii + val;\\n        if(total % 2 == 0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834221,
                "title": "swift-one-line-very-easy",
                "content": "a = 1, b = 2, etc\\nif letter % 2 == number % 2 it\\'s white cell\\n\\n```\\nclass Solution {\\n    func squareIsWhite(_ coordinates: String) -> Bool {\\n        return (coordinates.first!.asciiValue! - 97) % 2 == Int(String(coordinates.last!))! % 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func squareIsWhite(_ coordinates: String) -> Bool {\\n        return (coordinates.first!.asciiValue! - 97) % 2 == Int(String(coordinates.last!))! % 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822614,
                "title": "easiest-solution-c-plus-plus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        map<char,int> mp;\\n        int a = 1;\\n        for(char i=\\'a\\';i<=\\'h\\';i++) mp[i]=a++;\\n        int b=mp[coordinates[0]],c=coordinates[1]-\\'0\\';\\n        return (b%2==0&&c%2!=0)||(b&2!=0&&c%2==0)?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        map<char,int> mp;\\n        int a = 1;\\n        for(char i=\\'a\\';i<=\\'h\\';i++) mp[i]=a++;\\n        int b=mp[coordinates[0]],c=coordinates[1]-\\'0\\';\\n        return (b%2==0&&c%2!=0)||(b&2!=0&&c%2==0)?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821301,
                "title": "java-0ms-determine-color-of-a-chessboard-square",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        int x= coordinates.charAt(0)-\\'a\\';\\n        int y= coordinates.charAt(1)-\\'0\\';\\n        //System.out.println(x + \" \"+ y);\\n        if(x%2==0 && y%2==0 || x%2!=0 && y%2!=0) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        int x= coordinates.charAt(0)-\\'a\\';\\n        int y= coordinates.charAt(1)-\\'0\\';\\n        //System.out.println(x + \" \"+ y);\\n        if(x%2==0 && y%2==0 || x%2!=0 && y%2!=0) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818393,
                "title": "c-cpp-100-fast-solution-very-easy-1-line-code",
                "content": "\\n\\n#### Complexity\\n- Time complexity: O (1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n*****Code:*****\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        \\n        \\n        if((coordinates[0]+coordinates[1]) % 2 ==0)\\n            return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**Upvote if finds helpful!!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        \\n        \\n        if((coordinates[0]+coordinates[1]) % 2 ==0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777601,
                "title": "0-ms-100-faster-easiest-solution-ever-with-explanation-java",
                "content": "# Please upvote if you like it!\\n```\\n//Just determine the color and make the logic\\n\\n//if the coordinates character are a,c,e,g and number are odd(1,3,5,7) it means black and otherwise white in even numbers\\n\\n//if the coordinates character are b,d,f,h and number are odd(1,3,5,7) it means white and otherwise black in even numbers\\n\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n            char ch1=coordinates.charAt(0);\\n            char ch2=coordinates.charAt(1);\\n            \\n            if(ch1==\\'a\\' || ch1==\\'c\\' || ch1==\\'e\\' || ch1==\\'g\\'){\\n                \\n                if(ch2==\\'1\\' || ch2==\\'3\\' || ch2==\\'5\\' || ch2==\\'7\\')\\n                    return false;\\n                \\n                else return true;\\n            }\\n        \\n           else{\\n               \\n               if(ch2==\\'1\\' || ch2==\\'3\\' ||ch2==\\'5\\' ||ch2==\\'7\\')\\n                   return true;\\n               \\n               else return false;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n            char ch1=coordinates.charAt(0);\\n            char ch2=coordinates.charAt(1);\\n            \\n            if(ch1==\\'a\\' || ch1==\\'c\\' || ch1==\\'e\\' || ch1==\\'g\\'){\\n                \\n                if(ch2==\\'1\\' || ch2==\\'3\\' || ch2==\\'5\\' || ch2==\\'7\\')\\n                    return false;\\n                \\n                else return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2766840,
                "title": "determine-color-of-a-chessboard-square-easy",
                "content": "\\nif **coordinate[0] and co-ordinate[1] both are odd or both even** then return false \\nelse\\nif **coordinate[0] is ODD and co-ordinate[1] is EVEN or vice-versa** return true \\n\\n\\n```\\n\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        char[] coordinate = coordinates.toCharArray(); \\n        \\n        \\n        int alpha = coordinate[0];\\n        int num =  coordinate[1];\\n        \\n        //System.out.println(num); \\n        \\n        if(alpha%2==1 && num % 2 ==1) return false ;\\n   else if(alpha%2==1 && num % 2 ==0) return true ;\\n   else if(alpha%2==0 && num % 2 ==1) return true ;\\n   else if(alpha%2==0 && num % 2 ==0) return false ;\\n\\n        \\n        return true ;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        char[] coordinate = coordinates.toCharArray(); \\n        \\n        \\n        int alpha = coordinate[0];\\n        int num =  coordinate[1];\\n        \\n        //System.out.println(num); \\n        \\n        if(alpha%2==1 && num % 2 ==1) return false ;\\n   else if(alpha%2==1 && num % 2 ==0) return true ;\\n   else if(alpha%2==0 && num % 2 ==1) return true ;\\n   else if(alpha%2==0 && num % 2 ==0) return false ;\\n\\n        \\n        return true ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741592,
                "title": "easy-solution-java",
                "content": "Only 8line code and easy-undersatanding for Java\\n\\n\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char coor = coordinates.charAt(0);\\n        char num = coordinates.charAt(1);\\n        if(coor==\\'a\\' || coor==\\'c\\' || coor==\\'e\\' || coor==\\'g\\'){\\n            if(num==\\'1\\' || num==\\'3\\' || num==\\'5\\' || num==\\'7\\') return false;\\n            return true;\\n        }\\n        if(num==\\'1\\' || num==\\'3\\' || num==\\'5\\' || num==\\'7\\') return true;\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char coor = coordinates.charAt(0);\\n        char num = coordinates.charAt(1);\\n        if(coor==\\'a\\' || coor==\\'c\\' || coor==\\'e\\' || coor==\\'g\\'){\\n            if(num==\\'1\\' || num==\\'3\\' || num==\\'5\\' || num==\\'7\\') return false;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2733626,
                "title": "basic-observations-easy",
                "content": "class Solution {\\npublic:\\n\\n    bool squareIsWhite(string s) {\\n        int a=s[0]-\\'a\\'+1;\\n        int b=s[1]-\\'0\\';\\n        cout<<a<<\" \"<<b;\\n        // if((a%2==0&&b%2!=0)||(a%2!=0&&b%2==0))return true;//if one even and other  odd\\n        // same condition\\n        if((a+b)&1)return true;//if sum is odd\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool squareIsWhite(string s) {\\n        int a=s[0]-\\'a\\'+1;\\n        int b=s[1]-\\'0\\';\\n        cout<<a<<\" \"<<b;\\n        // if((a%2==0&&b%2!=0)||(a%2!=0&&b%2==0))return true;//if one even and other  odd\\n        // same condition\\n        if((a+b)&1)return true;//if sum is odd\\n        return false;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2694189,
                "title": "java",
                "content": "```\\n\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) - \\'a\\'+ coordinates.charAt(1))%2==0;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public boolean squareIsWhite(String coordinates) {\\n        return (coordinates.charAt(0) - \\'a\\'+ coordinates.charAt(1))%2==0;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626300,
                "title": "c-50-solution-one-liner",
                "content": "```c\\nbool squareIsWhite(char * coordinates){\\n    // assume that the letter always is A and shift ranks and files\\n    if ((coordinates[1] + coordinates[0] - 1) % 2 == 0) return true; return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nbool squareIsWhite(char * coordinates){\\n    // assume that the letter always is A and shift ranks and files\\n    if ((coordinates[1] + coordinates[0] - 1) % 2 == 0) return true; return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599852,
                "title": "python-easy-solution-i",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        o = ord(coordinates[:1])\\n        o-=97\\n        if o%2==0:\\n            if int(coordinates[-1])%2==0:\\n                return True\\n            else:\\n                return False\\n        else:\\n            if int(coordinates[-1])%2==0:\\n                return False\\n            else:\\n                return True\\n        ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        o = ord(coordinates[:1])\\n        o-=97\\n        if o%2==0:\\n            if int(coordinates[-1])%2==0:\\n                return True\\n            else:\\n                return False\\n        else:\\n            if int(coordinates[-1])%2==0:\\n                return False\\n            else:\\n                return True\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2581938,
                "title": "easiest-and-silly-java-solution-100-faster",
                "content": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        if(coordinates.charAt(0)==\\'a\\' || coordinates.charAt(0)==\\'c\\' || coordinates.charAt(0)==\\'e\\' ||                    coordinates.charAt(0)==\\'g\\')\\n        {\\n            if(coordinates.charAt(1)==\\'1\\' || coordinates.charAt(1)==\\'3\\' || coordinates.charAt(1)==\\'5\\' ||                coordinates.charAt(1)==\\'7\\'){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        else{\\n            if(coordinates.charAt(1)==\\'1\\' || coordinates.charAt(1)==\\'3\\' || coordinates.charAt(1)==\\'5\\' ||                coordinates.charAt(1)==\\'7\\'){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        if(coordinates.charAt(0)==\\'a\\' || coordinates.charAt(0)==\\'c\\' || coordinates.charAt(0)==\\'e\\' ||                    coordinates.charAt(0)==\\'g\\')\\n        {\\n            if(coordinates.charAt(1)==\\'1\\' || coordinates.charAt(1)==\\'3\\' || coordinates.charAt(1)==\\'5\\' ||                coordinates.charAt(1)==\\'7\\'){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2568092,
                "title": "simple-solution-faster-than-100-00-of-java",
                "content": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int ch = coordinates.charAt(0) - \\'a\\';\\n        int num = coordinates.charAt(1) - \\'0\\';\\n        return ch % 2 == num % 2;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int ch = coordinates.charAt(0) - \\'a\\';\\n        int num = coordinates.charAt(1) - \\'0\\';\\n        return ch % 2 == num % 2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2562677,
                "title": "c-beats-100-does-anyone-else-play-chess",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        char s1 = coordinates[0] - \\'a\\' + 1;\\n        char s2 = coordinates[1];\\n        int c1 = s1 - \\'0\\';\\n        int c2 = s2 - \\'0\\';\\n        \\n        if(c1%2 != 0 and c2%2!= 0) return false;\\n        else if(c1%2 != 0 and c2%2 == 0) return true;\\n        else if(c1%2 == 0 and c2%2 != 0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        char s1 = coordinates[0] - \\'a\\' + 1;\\n        char s2 = coordinates[1];\\n        int c1 = s1 - \\'0\\';\\n        int c2 = s2 - \\'0\\';\\n        \\n        if(c1%2 != 0 and c2%2!= 0) return false;\\n        else if(c1%2 != 0 and c2%2 == 0) return true;\\n        else if(c1%2 == 0 and c2%2 != 0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515975,
                "title": "java-1-liner-solution-beats-100-time-complexity-o-1",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int sum = (coordinates.charAt(0)-\\'a\\') + (coordinates.charAt(1)-\\'0\\');\\n        return (sum % 2) == 0 ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int sum = (coordinates.charAt(0)-\\'a\\') + (coordinates.charAt(1)-\\'0\\');\\n        return (sum % 2) == 0 ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433902,
                "title": "python-one-line-solution-faster-than-94",
                "content": "# Python Code -\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        alphabets=\\'abcdefgh\\'\\n        return True if (alphabets.index(coordinates[0]) + int(coordinates[1])) % 2 == 0 else False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        alphabets=\\'abcdefgh\\'\\n        return True if (alphabets.index(coordinates[0]) + int(coordinates[1])) % 2 == 0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420004,
                "title": "python-99-faster-simple-solution",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        c = coordinates\\n        a,b = \"aceg\",\"bdfh\"\\n        for i in range(0,len(c)):\\n            if (( c[0] in a ) and ( int(c[1])%2 != 0 )) or (( c[0] in b ) and ( int(c[1])%2 == 0 )):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        c = coordinates\\n        a,b = \"aceg\",\"bdfh\"\\n        for i in range(0,len(c)):\\n            if (( c[0] in a ) and ( int(c[1])%2 != 0 )) or (( c[0] in b ) and ( int(c[1])%2 == 0 )):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379389,
                "title": "0ms-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int a=coordinates[0]-\\'a\\';\\n        int b=coordinates[1]-\\'0\\';\\n        if(a%2==0)\\n        {\\n            if(b%2==0)\\n                return true;\\n            return false;\\n        }\\n        else\\n        {\\n            if(b%2!=0)\\n                return true;\\n            return false;\\n        }\\n    \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int a=coordinates[0]-\\'a\\';\\n        int b=coordinates[1]-\\'0\\';\\n        if(a%2==0)\\n        {\\n            if(b%2==0)\\n                return true;\\n            return false;\\n        }\\n        else\\n        {\\n            if(b%2!=0)\\n                return true;\\n            return false;\\n        }\\n    \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376283,
                "title": "kotlin-one-line-solution",
                "content": "```\\nclass Solution {\\n    fun squareIsWhite(coordinates: String) = (coordinates[0].toInt() + coordinates[1].toInt()) % 2 != 0\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun squareIsWhite(coordinates: String) = (coordinates[0].toInt() + coordinates[1].toInt()) % 2 != 0\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339118,
                "title": "python3-simple-logic-faster-than-92",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n\\t\\t# Convert to [int, int]\\n        first_8_chars = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"]\\n        numerical_coordinate = [(int(first_8_chars.index(coordinates[0]))+1), int(coordinates[1])]\\n\\t\\t\\n\\t\\t# Then check if coordinate is white\\n        if numerical_coordinate[0]%2 != 0 and numerical_coordinate[1]%2 != 0: #odd odd\\n            return False\\n        elif numerical_coordinate[0]%2 != 0 and numerical_coordinate[1]%2 == 0: #odd even:\\n            return True\\n        elif numerical_coordinate[0]%2 == 0 and numerical_coordinate[1]%2 != 0: #even odd:\\n            return True\\n\\t\\telse:                                                                 #even even\\n            return False\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n\\t\\t# Convert to [int, int]\\n        first_8_chars = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"]\\n        numerical_coordinate = [(int(first_8_chars.index(coordinates[0]))+1), int(coordinates[1])]\\n\\t\\t\\n\\t\\t# Then check if coordinate is white\\n        if numerical_coordinate[0]%2 != 0 and numerical_coordinate[1]%2 != 0: #odd odd\\n            return False\\n        elif numerical_coordinate[0]%2 != 0 and numerical_coordinate[1]%2 == 0: #odd even:\\n            return True\\n        elif numerical_coordinate[0]%2 == 0 and numerical_coordinate[1]%2 != 0: #even odd:\\n            return True\\n\\t\\telse:                                                                 #even even\\n            return False\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338173,
                "title": "java-odd-even-pair-analysis",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        //two parts are character and number \\n        char charPart = coordinates.charAt(0); \\n        int charPartNumber = (charPart - \\'a\\'); \\n        int numPart = Integer.parseInt(String.valueOf(coordinates.charAt(1))); \\n        \\n        //even even pair is white \\n        if(charPartNumber % 2 == 0 && numPart % 2 == 0){\\n            return true; \\n        }\\n        //odd odd pair is white\\n        else if(charPartNumber % 2 != 0 && numPart % 2 != 0){\\n            return true; \\n        }\\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        //two parts are character and number \\n        char charPart = coordinates.charAt(0); \\n        int charPartNumber = (charPart - \\'a\\'); \\n        int numPart = Integer.parseInt(String.valueOf(coordinates.charAt(1))); \\n        \\n        //even even pair is white \\n        if(charPartNumber % 2 == 0 && numPart % 2 == 0){\\n            return true; \\n        }\\n        //odd odd pair is white\\n        else if(charPartNumber % 2 != 0 && numPart % 2 != 0){\\n            return true; \\n        }\\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320321,
                "title": "solution-faster-than-96",
                "content": "1st Approach\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        a = int(ord(coordinates[0]))% 2\\n        b = int(coordinates[1]) % 2\\n        if  (a == 0 and b != 0):\\n            return True\\n        elif (a != 0 and b == 0):\\n            return True\\n```\\n2nd Approach\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        a = int(ord(coordinates[0])) + int(coordinates[1]) \\n        if  (a % 2 != 0):\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        a = int(ord(coordinates[0]))% 2\\n        b = int(coordinates[1]) % 2\\n        if  (a == 0 and b != 0):\\n            return True\\n        elif (a != 0 and b == 0):\\n            return True\\n```\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        a = int(ord(coordinates[0])) + int(coordinates[1]) \\n        if  (a % 2 != 0):\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319200,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-determine-color-of-a-chessboard-square",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE :**\\n```\\nbool squareIsWhite(string coordinates) {\\n        int x = (int)coordinates[0], y = (int)coordinates[1];\\n        return (((x+y)% 2) == 0)? false : true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool squareIsWhite(string coordinates) {\\n        int x = (int)coordinates[0], y = (int)coordinates[1];\\n        return (((x+y)% 2) == 0)? false : true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2296694,
                "title": "simple-java-solution-100-faster",
                "content": "if u find the code suitable ,plz upvote.\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean squareIsWhite(String coordinates) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tint num=0;\\n\\t\\t\\tint s=0;\\n\\t\\t\\tc=coordinates.charAt(0);\\n\\t\\t\\tnum=coordinates.charAt(1);\\n\\t\\t\\ts=num+c;\\n\\t\\t\\tif(s%2==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean squareIsWhite(String coordinates) {\\n\\t\\t\\tint c=0;\\n\\t\\t\\tint num=0;\\n\\t\\t\\tint s=0;\\n\\t\\t\\tc=coordinates.charAt(0);\\n\\t\\t\\tnum=coordinates.charAt(1);\\n\\t\\t\\ts=num+c;\\n\\t\\t\\tif(s%2==0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn true;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2295476,
                "title": "simple-java-solution-faster-than-100",
                "content": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        int sum=0;\\n        \\n        int x = coordinates.charAt(0)-\\'a\\';\\n        int y = coordinates.charAt(1)-\\'0\\';\\n        \\n        sum=x+y;\\n        \\n        return sum%2==0;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        int sum=0;\\n        \\n        int x = coordinates.charAt(0)-\\'a\\';\\n        int y = coordinates.charAt(1)-\\'0\\';\\n        \\n        sum=x+y;\\n        \\n        return sum%2==0;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2283136,
                "title": "python-easy-and-fastest-solution",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        \\n       \\n        \\n        coordinates=list(coordinates)\\n        \\n        \\n        if coordinates[0] in [\"a\",\"c\",\"e\",\"g\"]:  #h3\\n            if int(coordinates[1])&1!=0:\\n                \\n                return False\\n                \\n            else:\\n                return True\\n            \\n            \\n        else:\\n            \\n            if int(coordinates[1])&1!=0:\\n                return True\\n                \\n            else:\\n                return False\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        \\n       \\n        \\n        coordinates=list(coordinates)\\n        \\n        \\n        if coordinates[0] in [\"a\",\"c\",\"e\",\"g\"]:  #h3\\n            if int(coordinates[1])&1!=0:\\n                \\n                return False\\n                \\n            else:\\n                return True\\n            \\n            \\n        else:\\n            \\n            if int(coordinates[1])&1!=0:\\n                return True\\n                \\n            else:\\n                return False\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239518,
                "title": "python-simplest-solution",
                "content": "Using common sense, we can determine that for columns a,c,e,g only the even numbered rows have white tiles, other columns have white tiles on their odd numbered rows. So, we see if the unicode of column a,b,c etc is even or odd. Odd unicodes mean the column is a,c,e,g and even unicode mean the column is b,d,f,h. Then we simply determine the color using basic math logic, and Voila!!\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        if ord(coordinates[0])%2==0:\\n            if int(coordinates[1])%2!=0:\\n                return True\\n            else:\\n                return False\\n        else:\\n            if int(coordinates[1])%2==0:\\n                return True\\n            else:\\n                return False\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        if ord(coordinates[0])%2==0:\\n            if int(coordinates[1])%2!=0:\\n                return True\\n            else:\\n                return False\\n        else:\\n            if int(coordinates[1])%2==0:\\n                return True\\n            else:\\n                return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225796,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        char alphabet=coordinates[0];\\n        int num=int(coordinates[1]-48);\\n        if(alphabet==\\'a\\'||alphabet==\\'c\\'||alphabet==\\'e\\'||alphabet==\\'g\\'){\\n            if(num%2==0){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        else{\\n            if(num%2==0){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        char alphabet=coordinates[0];\\n        int num=int(coordinates[1]-48);\\n        if(alphabet==\\'a\\'||alphabet==\\'c\\'||alphabet==\\'e\\'||alphabet==\\'g\\'){\\n            if(num%2==0){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        else{\\n            if(num%2==0){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220215,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return ((coordinates.charAt(0)-\\'`\\') + Integer.valueOf(coordinates.charAt(1)))%2!=0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        return ((coordinates.charAt(0)-\\'`\\') + Integer.valueOf(coordinates.charAt(1)))%2!=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213797,
                "title": "c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int k=0;\\n        k=k+(coordinates[0]-\\'a\\'+1);\\n        k=k+(coordinates[1]-\\'1\\'+1);\\n        \\n        if(k%2==0)return false;\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        int k=0;\\n        k=k+(coordinates[0]-\\'a\\'+1);\\n        k=k+(coordinates[1]-\\'1\\'+1);\\n        \\n        if(k%2==0)return false;\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142644,
                "title": "c-modulo",
                "content": "```\\npublic class Solution\\n{\\n    public bool SquareIsWhite(string coordinates)\\n    {\\n        int x = coordinates[0] - \\'a\\';\\n        int y = coordinates[1] - \\'1\\';\\n        int modulo = (x + y) % 2;\\n        return modulo is 1;\\n    }\\n}\\n```\\n\\ntl;dr \\n```\\npublic class Solution\\n{\\n    public bool SquareIsWhite(string coordinates) \\n        => (coordinates[0] - \\'a\\' + coordinates[1] - \\'1\\') % 2 is 1;\\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool SquareIsWhite(string coordinates)\\n    {\\n        int x = coordinates[0] - \\'a\\';\\n        int y = coordinates[1] - \\'1\\';\\n        int modulo = (x + y) % 2;\\n        return modulo is 1;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public bool SquareIsWhite(string coordinates) \\n        => (coordinates[0] - \\'a\\' + coordinates[1] - \\'1\\') % 2 is 1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114340,
                "title": "easy-and-simple-solution-using-math-big-o-time-o-n",
                "content": "```\\npublic class Solution {\\n    public bool SquareIsWhite(string coordinates) {\\n        int x = \"abcdefgh\".IndexOf(coordinates[0]);\\n        int y = Convert.ToInt32(coordinates[1])-1;\\n        if((x%2 == 0 && y%2 == 0) ||( x%2 != 0 && y%2 != 0)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public bool SquareIsWhite(string coordinates) {\\n        int x = \"abcdefgh\".IndexOf(coordinates[0]);\\n        int y = Convert.ToInt32(coordinates[1])-1;\\n        if((x%2 == 0 && y%2 == 0) ||( x%2 != 0 && y%2 != 0)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114170,
                "title": "easiest-solution-using-ascii-values",
                "content": "\\t\\tint n = coordinates.length();\\n        \\n        boolean check = false;\\n        \\n        int diff = \\'z\\' - coordinates.charAt(0);\\n        if((diff%2 == 1 && coordinates.charAt(1)%2 == 1) || (diff%2 == 0 && coordinates.charAt(1)%2 == 0)){\\n            check = false;\\n        }\\n        else{\\n            check = true;\\n        }\\n        return check;",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "\\t\\tint n = coordinates.length();\\n        \\n        boolean check = false;\\n        \\n        int diff = \\'z\\' - coordinates.charAt(0);\\n        if((diff%2 == 1 && coordinates.charAt(1)%2 == 1) || (diff%2 == 0 && coordinates.charAt(1)%2 == 0)){\\n            check = false;\\n        }\\n        else{\\n            check = true;\\n        }\\n        return check;",
                "codeTag": "Unknown"
            },
            {
                "id": 2094905,
                "title": "c-javascript-one-line",
                "content": "**C++ :**\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        return ((coordinates[0] - \\'a\\' + 1)+(coordinates[1] - \\'1\\' + 1))%2 ? true : false;\\n    }\\n};\\n```\\n\\n**Javascript :**\\n```\\n/**\\n * @param {string} coordinates\\n * @return {boolean}\\n */\\nvar squareIsWhite = function(coordinates) {\\n    return ((coordinates.charCodeAt(0)-96)+(coordinates.charCodeAt(1)-48))%2 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        return ((coordinates[0] - \\'a\\' + 1)+(coordinates[1] - \\'1\\' + 1))%2 ? true : false;\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} coordinates\\n * @return {boolean}\\n */\\nvar squareIsWhite = function(coordinates) {\\n    return ((coordinates.charCodeAt(0)-96)+(coordinates.charCodeAt(1)-48))%2 ? true : false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068537,
                "title": "c-python-4-lines",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        unordered_map<char,int> m = {{\\'a\\',1},{\\'b\\',2},{\\'c\\',3},{\\'d\\',4},{\\'e\\',5},{\\'f\\',6},{\\'g\\',7},{\\'h\\',8}};\\n        int c = m[coordinates[0]], d = int(coordinates[1]-\\'0\\');\\n        return (c%2 ==0 && d%2 !=0 )||(c%2 !=0 && d%2 ==0 );\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        m = {\\'a\\':1,\\'b\\':2,\\'c\\':3,\\'d\\':4,\\'e\\':5,\\'f\\':6,\\'g\\':7,\\'h\\':8}\\n        c = m[coordinates[0]]\\n        d = int(coordinates[1])\\n        print(d)\\n        return (c%2 ==0 and d%2 !=0 )or(c%2 !=0 and d%2 ==0 )\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        unordered_map<char,int> m = {{\\'a\\',1},{\\'b\\',2},{\\'c\\',3},{\\'d\\',4},{\\'e\\',5},{\\'f\\',6},{\\'g\\',7},{\\'h\\',8}};\\n        int c = m[coordinates[0]], d = int(coordinates[1]-\\'0\\');\\n        return (c%2 ==0 && d%2 !=0 )||(c%2 !=0 && d%2 ==0 );\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        m = {\\'a\\':1,\\'b\\':2,\\'c\\':3,\\'d\\':4,\\'e\\':5,\\'f\\':6,\\'g\\':7,\\'h\\':8}\\n        c = m[coordinates[0]]\\n        d = int(coordinates[1])\\n        print(d)\\n        return (c%2 ==0 and d%2 !=0 )or(c%2 !=0 and d%2 ==0 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066005,
                "title": "c-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        char first = coordinates[0];\\n        char second = coordinates[1];\\n        int sum = int(first) +  (second - \\'0\\');\\n        \\n        return (sum % 2 != 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        char first = coordinates[0];\\n        char second = coordinates[1];\\n        int sum = int(first) +  (second - \\'0\\');\\n        \\n        return (sum % 2 != 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063770,
                "title": "c-easy-100-faster-89-96-less-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) \\n    {\\n        int a1=(int)(coordinates[0]-\\'a\\'), a2=(int)(coordinates[1]-\\'0\\');\\n            return((a1+a2)%2==0);\\n    }\\n};\\n// do upvote ;)\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) \\n    {\\n        int a1=(int)(coordinates[0]-\\'a\\'), a2=(int)(coordinates[1]-\\'0\\');\\n            return((a1+a2)%2==0);\\n    }\\n};\\n// do upvote ;)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988878,
                "title": "c-faster-than-70-59",
                "content": "Runtime: 81 ms, faster than 70.59% of C# online submissions for Determine Color of a Chessboard Square.\\nMemory Usage: 38 MB, less than 17.65% of C# online submissions for Determine Color of a Chessboard Square.\\n```\\npublic class Solution {\\n    public bool SquareIsWhite(string coordinates) {\\n        return !(((coordinates[0]-\\'0\\') % 2) == (int.Parse(coordinates.Substring(1)) % 2));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool SquareIsWhite(string coordinates) {\\n        return !(((coordinates[0]-\\'0\\') % 2) == (int.Parse(coordinates.Substring(1)) % 2));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1964361,
                "title": "c-using-ascii-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string str) {\\n        if(int(str[0])%2!=0 && (str[1]-\\'0\\')%2!=0){\\n            return false;\\n        }else if(int(str[0])%2!=0 && (str[1]-\\'0\\')%2==0){\\n            return true;\\n        }else if(int(str[0])%2==0 && (str[1]-\\'0\\')%2!=0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string str) {\\n        if(int(str[0])%2!=0 && (str[1]-\\'0\\')%2!=0){\\n            return false;\\n        }else if(int(str[0])%2!=0 && (str[1]-\\'0\\')%2==0){\\n            return true;\\n        }else if(int(str[0])%2==0 && (str[1]-\\'0\\')%2!=0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935726,
                "title": "java-1ms",
                "content": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int a = coordinates.charAt(0) - \\'a\\';\\n        int b = coordinates.charAt(1) - \\'0\\';\\n        \\n        if(a%2==0){\\n            if(b%2==1)\\n                return false;\\n            else\\n                return true;\\n        }\\n        \\n        else{\\n            if(b%2==1)\\n                return true;\\n            else\\n                return false;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        int a = coordinates.charAt(0) - \\'a\\';\\n        int b = coordinates.charAt(1) - \\'0\\';\\n        \\n        if(a%2==0){\\n            if(b%2==1)\\n                return false;\\n            else\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1917638,
                "title": "faster-than-100-c-solution-easy-to-understand-o-1",
                "content": "``` \\nclass Solution  {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if((coordinates[0] == \\'a\\' || coordinates[0] == \\'c\\' ||coordinates[0] == \\'e\\' ||coordinates[0] == \\'g\\')&& (coordinates[1]-\\'0\\')%2 == 1){\\n            return false;\\n        }\\n        else if((coordinates[0] == \\'b\\' || coordinates[0] == \\'d\\' ||coordinates[0] == \\'f\\' ||coordinates[0] == \\'h\\')&& (coordinates[1]-\\'0\\')%2 == 0){\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution  {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if((coordinates[0] == \\'a\\' || coordinates[0] == \\'c\\' ||coordinates[0] == \\'e\\' ||coordinates[0] == \\'g\\')&& (coordinates[1]-\\'0\\')%2 == 1){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1894410,
                "title": "java-solution-100-faster-0ms-time-o-1-time-space",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        int row = coordinates.charAt(0)-\\'a\\';\\n        int column = coordinates.charAt(1)-\\'0\\';\\n        \\n        int result = row+column;\\n        \\n        if(result%2==0)\\n            return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        \\n        int row = coordinates.charAt(0)-\\'a\\';\\n        int column = coordinates.charAt(1)-\\'0\\';\\n        \\n        int result = row+column;\\n        \\n        if(result%2==0)\\n            return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849716,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n //if both are even or both are odd -->black else white\\n    public boolean squareIsWhite(String s) {\\n        if((s.charAt(0)-\\'a\\'+1+s.charAt(1)-\\'0\\')%2==0) //sum of even as well as odd is even\\n        return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n //if both are even or both are odd -->black else white\\n    public boolean squareIsWhite(String s) {\\n        if((s.charAt(0)-\\'a\\'+1+s.charAt(1)-\\'0\\')%2==0) //sum of even as well as odd is even\\n        return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1810354,
                "title": "c-soln-faster-than-100",
                "content": "**class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        string a = \"aceg\";   string b = \"bdfh\";\\n        if(a.find(coordinates[0]) != -1){\\n            if(coordinates[1]%2 == 0)\\n                return 1;\\n             else \\n                 return 0;\\n        }else{\\n             if(coordinates[1]%2 == 0)\\n                return 0;\\n             else \\n                 return 1;\\n        }\\n        return {};\\n    }\\n};**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        string a = \"aceg\";   string b = \"bdfh\";\\n        if(a.find(coordinates[0]) != -1){\\n            if(coordinates[1]%2 == 0)\\n                return 1;\\n             else \\n                 return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1776629,
                "title": "100-faster-code-c",
                "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        \\n      \\n        \\n        int num=coordinates[0]-97;\\n        int n2=coordinates[1]-49;\\n        \\n        if((num+n2)%2 == 0)\\n        {\\n            return false;\\n        }\\n        else\\n            return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        \\n      \\n        \\n        int num=coordinates[0]-97;\\n        int n2=coordinates[1]-49;\\n        \\n        if((num+n2)%2 == 0)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1738894,
                "title": "easy-java-solution-using-conditional-operator",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char[] array=coordinates.toCharArray();\\n        if(array[0]%2==0)\\n        {\\n            return array[1]%2==1?true:false;\\n        }\\n        else\\n        {\\n            return array[1]%2==0?true:false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n        char[] array=coordinates.toCharArray();\\n        if(array[0]%2==0)\\n        {\\n            return array[1]%2==1?true:false;\\n        }\\n        else\\n        {\\n            return array[1]%2==0?true:false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694893,
                "title": "c-solution",
                "content": "Patterns:\\n*         odd number and odd letter = black\\n*         even number and even letter = black\\n*         odd number and even letter = white\\n*         even number and odd letter = white\\n\\nIf **both** number and letter is odd or even, this means it is black square\\nIf **either** number and letter is odd or even, this means it is white squre\\n\\n```\\npublic class Solution {\\n    public bool SquareIsWhite(string coordinates) {        \\n        return (int)coordinates[0] % 2 != (coordinates[1] - \\'0\\') % 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool SquareIsWhite(string coordinates) {        \\n        return (int)coordinates[0] % 2 != (coordinates[1] - \\'0\\') % 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682803,
                "title": "java-solution-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n         boolean p = true;\\n        \\n         char c = coordinates.charAt(0);\\n         int a = coordinates.charAt(1) - \\'0\\';\\n        \\n         if((a % 2 == 0) &&( c == \\'b\\' || c == \\'d\\' || c == \\'f\\' || c == \\'h\\'))\\n         {\\n        \\t p = false;\\n         }\\n         else if((a % 2 == 1) && (c == \\'a\\' || c == \\'c\\' || c == \\'e\\' || c == \\'g\\')) \\n         {\\n        \\t p = false;\\n         }\\n         return p;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n         boolean p = true;\\n        \\n         char c = coordinates.charAt(0);\\n         int a = coordinates.charAt(1) - \\'0\\';\\n        \\n         if((a % 2 == 0) &&( c == \\'b\\' || c == \\'d\\' || c == \\'f\\' || c == \\'h\\'))\\n         {\\n        \\t p = false;\\n         }\\n         else if((a % 2 == 1) && (c == \\'a\\' || c == \\'c\\' || c == \\'e\\' || c == \\'g\\')) \\n         {\\n        \\t p = false;\\n         }\\n         return p;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676536,
                "title": "python-simple-if-statement-solution-faster-than-94",
                "content": "A square is black under 2 conditions: \\n1 - it has to be in a \\'odd column\\' and in a odd row (First if statement)\\n2 - It has to be in an \\'even column\\' and in a even row (Second if statement)\\n\\nIf it does not fall under either of these 2 categories, it must be a white square. (else statement)\\n\\n\\'\\'\\'\\nclass Solution(object):\\n    def squareIsWhite(self, coordinates):\\n\\n        odd_columns = [\"a\",\"c\",\"e\",\"g\"]\\n        \\n        if coordinates[0] in odd_columns and int(coordinates[1])%2 != 0:\\n            return False\\n        if coordinates[0] not in odd_columns and int(coordinates[1])%2 == 0:\\n            return False\\n        else:\\n            return True\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "A square is black under 2 conditions: \\n1 - it has to be in a \\'odd column\\' and in a odd row (First if statement)\\n2 - It has to be in an \\'even column\\' and in a even row (Second if statement)\\n\\nIf it does not fall under either of these 2 categories, it must be a white square. (else statement)\\n\\n\\'\\'\\'\\nclass Solution(object):\\n    def squareIsWhite(self, coordinates):\\n\\n        odd_columns = [\"a\",\"c\",\"e\",\"g\"]\\n        \\n        if coordinates[0] in odd_columns and int(coordinates[1])%2 != 0:\\n            return False\\n        if coordinates[0] not in odd_columns and int(coordinates[1])%2 == 0:\\n            return False\\n        else:\\n            return True\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1673187,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0])+int(coordinates[1]))%2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0])+int(coordinates[1]))%2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672872,
                "title": "c-easy-solution-based-on-logic",
                "content": "**Please upvote to motivate me in quest of documenting all leetcode solutions. :)**\\n```\\nThis question is based on observation, nothing else. If you are good at observation then you are good to go to code solution to this problem.\\n```\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string str) {\\n        if(str[0]==\\'a\\' || str[0]==\\'c\\' || str[0]==\\'e\\' || str[0]==\\'g\\'){\\n            if(((str[1]-\\'0\\')&1)==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        if(str[0]==\\'b\\' || str[0]==\\'d\\' || str[0]==\\'f\\' || str[0]==\\'h\\'){\\n            if(((str[1]-\\'0\\')&1)==0)\\n                return false;\\n            else\\n                return true;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nThis question is based on observation, nothing else. If you are good at observation then you are good to go to code solution to this problem.\\n```\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string str) {\\n        if(str[0]==\\'a\\' || str[0]==\\'c\\' || str[0]==\\'e\\' || str[0]==\\'g\\'){\\n            if(((str[1]-\\'0\\')&1)==0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        if(str[0]==\\'b\\' || str[0]==\\'d\\' || str[0]==\\'f\\' || str[0]==\\'h\\'){\\n            if(((str[1]-\\'0\\')&1)==0)\\n                return false;\\n            else\\n                return true;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654672,
                "title": "java-one-liner-and-100-faster",
                "content": "**The basic idea behind this question is ASCII value of alphabets.**\\n```\\nclass Solution {\\n    public boolean squareIsWhite(String s) {\\n        if ((s.charAt(0) % 2 == 0 && s.charAt(1) % 2 != 0) || (s.charAt(0) % 2 != 0 && s.charAt(1) % 2 == 0)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean squareIsWhite(String s) {\\n        if ((s.charAt(0) % 2 == 0 && s.charAt(1) % 2 != 0) || (s.charAt(0) % 2 != 0 && s.charAt(1) % 2 == 0)) {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1632767,
                "title": "python-dictionary-solution-time-100-space-71",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        temp = {\\'a\\':1,\\'b\\':2,\\'c\\':3,\\'d\\':4,\\'e\\':5,\\'f\\':6,\\'g\\':7,\\'h\\':8}\\n        if (temp[coordinates[0]] + int(coordinates[1])) % 2 == 0:\\n            return False\\n        else:\\n            return True\\n```\\nFeel free to post any questions.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        temp = {\\'a\\':1,\\'b\\':2,\\'c\\':3,\\'d\\':4,\\'e\\':5,\\'f\\':6,\\'g\\':7,\\'h\\':8}\\n        if (temp[coordinates[0]] + int(coordinates[1])) % 2 == 0:\\n            return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623121,
                "title": "go-100-time-and-100-space",
                "content": "```\\nfunc squareIsWhite(coordinates string) bool {\\n\\tfirst, second := coordinates[0]-\\'a\\', coordinates[1]-\\'1\\'\\n\\treturn first&1 != second&1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc squareIsWhite(coordinates string) bool {\\n\\tfirst, second := coordinates[0]-\\'a\\', coordinates[1]-\\'1\\'\\n\\treturn first&1 != second&1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1617466,
                "title": "life-is-short",
                "content": "\\n```\\nreturn (ord(coordinates[0]) + ord(coordinates[1])) % 2\\n```",
                "solutionTags": [],
                "code": "```\\nreturn (ord(coordinates[0]) + ord(coordinates[1])) % 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1602518,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0]) + int(coordinates[1])) % 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        return (ord(coordinates[0]) + int(coordinates[1])) % 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586494,
                "title": "java-solution-with-explaination-100-faster-xor",
                "content": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n\\t\\t// Think of a chess board.\\n\\t\\t// The rows having co-ordinates a to h. Consider a is 1, b is 2, ... h is 8.\\n\\t\\t// The col having co-ordinates 1 to 8.\\n\\t\\t// From those, consider even numbers as true and odd numbers as false.\\n\\t\\t// So, a is gonna be false, b is gonna be true, ... h is gonna be true.\\n\\t\\t// Similarly, 1 is gonna be false, 2 is gonna be true ... 8 is gonna be true.\\n\\t\\t// Now, you\\'ll be able to see a pattern where the row and col coordinates having the \\n\\t\\t// same bits is a black square, and the row and col having different bits is white square.\\n\\t\\t// And using the XOR operator with row and col bits, we can get the output where diff bits will be true\\n\\t\\t// and same bits will give false.\\n        boolean alpha = (coordinates.charAt(0) - 96) % 2 == 0;\\n        boolean num = (coordinates.charAt(1) - \\'0\\') % 2 == 0;\\n        \\n        return alpha ^ num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean squareIsWhite(String coordinates) {\\n\\t\\t// Think of a chess board.\\n\\t\\t// The rows having co-ordinates a to h. Consider a is 1, b is 2, ... h is 8.\\n\\t\\t// The col having co-ordinates 1 to 8.\\n\\t\\t// From those, consider even numbers as true and odd numbers as false.\\n\\t\\t// So, a is gonna be false, b is gonna be true, ... h is gonna be true.\\n\\t\\t// Similarly, 1 is gonna be false, 2 is gonna be true ... 8 is gonna be true.\\n\\t\\t// Now, you\\'ll be able to see a pattern where the row and col coordinates having the \\n\\t\\t// same bits is a black square, and the row and col having different bits is white square.\\n\\t\\t// And using the XOR operator with row and col bits, we can get the output where diff bits will be true\\n\\t\\t// and same bits will give false.\\n        boolean alpha = (coordinates.charAt(0) - 96) % 2 == 0;\\n        boolean num = (coordinates.charAt(1) - \\'0\\') % 2 == 0;\\n        \\n        return alpha ^ num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565808,
                "title": "c-o-1-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        char ch=coordinates[0];\\n        int x=int(ch)-97;\\n        int y=int(coordinates[1])-\\'0\\';\\n        if((x%2==0&&y%2!=0)||(x%2!=0&&y%2==0))\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        char ch=coordinates[0];\\n        int x=int(ch)-97;\\n        int y=int(coordinates[1])-\\'0\\';\\n        if((x%2==0&&y%2!=0)||(x%2!=0&&y%2==0))\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575102,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1568569,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1959212,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1777402,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1711583,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1887357,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1887355,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1845309,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1844642,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1833571,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1575102,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1568569,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1959212,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1777402,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1711583,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1887357,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1887355,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1845309,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1844642,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            },
            {
                "id": 1833571,
                "content": [
                    {
                        "username": "Crist",
                        "content": "`return (coordinates.charCodeAt(0)+coordinates.charCodeAt(1))%2`"
                    },
                    {
                        "username": "Abhi3054",
                        "content": "return (coordinates[1]^coordinates[0])&1;"
                    },
                    {
                        "username": "meteahmetyakar",
                        "content": "[@pratik650](/pratik650) https://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/4015149/java-truth-table-o1-best-explanation-2-approaches/"
                    },
                    {
                        "username": "pratik650",
                        "content": "can u define.."
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates == \"a1\" || coordinates == \"a3\" || coordinates == \"a5\" ||coordinates == \"a7\" || coordinates == \"b2\" ||  coordinates == \"b4\" ||  coordinates == \"b6\" ||  coordinates == \"b8\" ||  coordinates == \"c1\" ||  coordinates == \"c3\" ||  coordinates == \"c5\" ||  coordinates == \"c7\" ||  coordinates == \"d2\" ||  coordinates == \"d4\" ||  coordinates == \"d6\" ||  coordinates == \"d8\" ||  coordinates == \"e1\" ||  coordinates == \"e3\" ||  coordinates == \"e5\" ||  coordinates == \"e7\" ||  coordinates == \"f2\" ||  coordinates == \"f4\" ||  coordinates == \"f6\" ||  coordinates == \"f8\" ||  coordinates == \"g1\" ||  coordinates == \"g3\" ||  coordinates == \"g5\" ||  coordinates == \"g7\" ||  coordinates == \"h2\" ||  coordinates == \"h4\" ||  coordinates == \"h6\" ||  coordinates == \"h8\")\\n        return false;\\n        else\\n            return true;\\n    }\\n};"
                    },
                    {
                        "username": "devrb_20cse",
                        "content": "Get the values and then add both and chech it as odd or even."
                    },
                    {
                        "username": "aadishmn",
                        "content": "need more good  solution  brooo"
                    },
                    {
                        "username": "TUSHARSARASWAT",
                        "content": "class Solution:\\n    def squareIsWhite(self, coordinates: str) -> bool:\\n        l=[\\'a\\',\\'c\\',\\'e\\',\\'g\\']\\n        n=[\\'1\\',\\'3\\',\\'5\\',\\'7\\']\\n        for each in l:\\n            for eac in n:\\n                c = each+eac\\n        l1=[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n        n1=[\\'2\\',\\'4\\',\\'6\\',\\'8\\']\\n        for each1 in l1:\\n            for eac1 in n1:\\n                c1=each1+eac1\\n        if c!= coordinates:\\n            a=True\\n        if c or c1==coordinates:\\n            b=False\\n        return[a,b]\\n        \\n           can anyone tell me why this is not correct"
                    },
                    {
                        "username": "DBYCZ",
                        "content": "Your \\'for\\' loops are unnecessary because you don\\'t need to calculate the colors of all squares. We are only interested in the color of the \\'coordinates\\' square. \\n\\nTo do this, you should first keep track of every light square. Save this like you were on line 3 before.\\n\\nlightSquares =[\\'b\\',\\'d\\',\\'f\\',\\'h\\']\\n\\nThen, you need to find out if the \\'coordinate\\' is an even or an odd square. To do this, simply parse an int value from the \\'coordinate\\' string and use the modulo operator to see if it is even. The 2nd character is always an int, so we can simply do the following:\\n\\nisEven = int(coordinates[1]) % 2 == 0\\n\\nNow, we just need to check if we are on a dark square or a light square, and return the correct value.\\n\\nif coordinates[0] in lightSquares:\\n  return False if isEven else True\\nelse:\\n  return True if isEven else False\\n\\n"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "Time complexity and Space: O(1)\nhttps://leetcode.com/problems/determine-color-of-a-chessboard-square/solutions/3501262/its-a-very-easy-solution-and-it-takes-only-tc-o-1-sc-o-1/"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public boolean squareIsWhite(String coordinates) {\\n        int lastDigitA  = (coordinates.charAt(0)-\\'a\\');\\n        int lastDigitB  = (coordinates.charAt(1)-\\'0\\');\\n        return (lastDigitA + lastDigitB) % 2 == 0;\\n    }  "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```    def squareIsWhite(self, coordinates: str) -> bool:\n        if coordinates[0] in (\"b\",\"d\",\"f\",\"h\") and int(coordinates[1])%2!=0 or      \n  coordinates[0] in ('a','c','e','g') and int(coordinates[1])%2==0:\n        \n            return True\n        return False```"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn ((coordinates.charAt(0)-\\'a\\'+1) + (coordinates.charAt(1)-\\'0\\')) % 2 != 0;"
                    },
                    {
                        "username": "Msey",
                        "content": "Interesting question \\ncan have many solutions"
                    }
                ]
            }
        ]
    }
]