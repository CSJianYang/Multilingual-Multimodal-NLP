[
    {
        "title": "Maximum Product of the Length of Two Palindromic Substrings",
        "question_content": "You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized.\nMore formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive.\nReturn the maximum possible product of the lengths of the two non-intersecting palindromic substrings.\nA palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\n&nbsp;\nExample 1:\n\nInput: s = \"ababbb\"\nOutput: 9\nExplanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n\nExample 2:\n\nInput: s = \"zaaaxbbby\"\nOutput: 9\nExplanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n\n&nbsp;\nConstraints:\n\n\t2 <= s.length <= 105\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 1389958,
                "title": "manacher-and-queue",
                "content": "Finding the longest palindrome in `[i, j]` is trivial using quadratic DP. Then, we can just find the biggest product of `[0, i] * [i + 1, n)`, moving the split point `i` left-to-right. However, quadratic would be too slow for n = 100,000.\\n \\nManacher\\'s algorithm (easy to find online) can identify all palindromes in O(n). It has two flavors for finding odd and even palindromes. Fortunately, we only care about odd palindromes here,  which is the simpler case.\\n\\nFor each position as the center of the palindrome, the algorithm finds how far the palindrome extends left and right. For example, for string `\"aaabaaaba\"`, the result will be `[1, 2, 1, 4, 1, 2, 2]`. And true - from position `3`, the palindrome extends 4 characters (the initial character is included) left and right, giving us \"aaa**b**aaa\".\\n\\nThis output needs additional massaging to tell the longest palindrome in `[0, i]` and [`i + 1, n)`. Re-using the above example, we are looking for something like this:\\n- Left-to-right (`[0, i]`): `[1, 1, 3, 3, 3, 5, 7, 7, 7]`\\n- Right-to-left (`[i, n]`): `[7, 7, 7, 5, 3, 3, 3, 1, 1]`\\n\\nFor this example, the maximum product is 15, with parts being `[0, 2]` and `[3, 8]`: `3 * 5`.\\n\\nThis transformation was the hardest part for me. I tried a few simpler approaches, which work for some test cases but not for the others. I had to brush up a bit on how Manacher\\'s algorithm works to figure out the transformation using a queue (the front of the queue is the center of the engulfing palindrome).\\n\\n> Update: we can also modify Manacher\\'s algo to produce the output we need. In this case, we will run that algo twice - for the original and inverted string. See approach 2 below. The idea was proposed by [thin_k_ing](https://leetcode.com/thin_k_ing/).\\n\\n#### Approach 1: Manacher and Queue\\n**C++**\\n```cpp\\nlong long maxProduct(string s) {\\n    long long res = 0, l = 0, n = s.size();\\n    vector<int> m(n), r(n);\\n    // Manacher\\'s Algorithm (https://cp-algorithms.com/string/manacher.html)\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    queue<array<int, 2>> q, q1;\\n    // Right-to-left to track max palindrome in [i, n).\\n    for (int i = n - 1; i >= 0; --i) {\\n        while (!q.empty() && q.front()[0] - q.front()[1] > i - 1)\\n            q.pop();\\n        r[i] = 1 + (q.empty() ? 0 : (q.front()[0] - i) * 2);\\n        q.push({i, m[i]});\\n    }\\n    // Left-to-right to track max palindrome in [0, i].\\n    for (int i = 0; i < n - 1; i += 1) {\\n        while (!q1.empty() && q1.front()[0] + q1.front()[1] < i + 1)\\n            q1.pop();\\n        l = max(l, 1ll + (q1.empty() ? 0 : (i - q1.front()[0]) * 2));\\n        res = max(res, l * r[i + 1]);\\n        q1.push({i, m[i]});\\n    }\\n    return res;\\n}\\n```\\n#### Approach 2: Modified Manacher\\n**C++**\\n```cpp\\nvector<int> manachers(string s, int n) {\\n    vector<int> m(n), l2r(n, 1);\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            l2r[i + k] = 2 * k + 1;\\n            k++;\\n        }\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    for(int i = 1; i < n; i++) \\n        l2r[i] = max(l2r[i], l2r[i - 1]);\\n    return l2r;\\n}\\nlong long maxProduct(string s) {\\n    long long res = 1, n = s.size();\\n    auto l2r = manachers(s, n), r2l = manachers(string(rbegin(s), rend(s)), n);\\n    for (int i = 0, j = n - 2; i < n - 1; ++i, --j)\\n        res = max(res, (long long)l2r[i] * r2l[j]);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long maxProduct(string s) {\\n    long long res = 0, l = 0, n = s.size();\\n    vector<int> m(n), r(n);\\n    // Manacher\\'s Algorithm (https://cp-algorithms.com/string/manacher.html)\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    queue<array<int, 2>> q, q1;\\n    // Right-to-left to track max palindrome in [i, n).\\n    for (int i = n - 1; i >= 0; --i) {\\n        while (!q.empty() && q.front()[0] - q.front()[1] > i - 1)\\n            q.pop();\\n        r[i] = 1 + (q.empty() ? 0 : (q.front()[0] - i) * 2);\\n        q.push({i, m[i]});\\n    }\\n    // Left-to-right to track max palindrome in [0, i].\\n    for (int i = 0; i < n - 1; i += 1) {\\n        while (!q1.empty() && q1.front()[0] + q1.front()[1] < i + 1)\\n            q1.pop();\\n        l = max(l, 1ll + (q1.empty() ? 0 : (i - q1.front()[0]) * 2));\\n        res = max(res, l * r[i + 1]);\\n        q1.push({i, m[i]});\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> manachers(string s, int n) {\\n    vector<int> m(n), l2r(n, 1);\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            l2r[i + k] = 2 * k + 1;\\n            k++;\\n        }\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    for(int i = 1; i < n; i++) \\n        l2r[i] = max(l2r[i], l2r[i - 1]);\\n    return l2r;\\n}\\nlong long maxProduct(string s) {\\n    long long res = 1, n = s.size();\\n    auto l2r = manachers(s, n), r2l = manachers(string(rbegin(s), rend(s)), n);\\n    for (int i = 0, j = n - 2; i < n - 1; ++i, --j)\\n        res = max(res, (long long)l2r[i] * r2l[j]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389421,
                "title": "python-o-n-with-manacher-explained",
                "content": "In this problem we deal with palindromes, so it is good idea to think about Manachers algorithm, because the length of our string is quite big. For more details, you can go to wikipedia, imagine now that we have result already for manacher algorithm and now we want to work with results it gave to us. On leetcode contest you do not need to code it youself, you can find template online, and you should know how to use it. Let us consider string \\n\\n`abayabyxaba`, \\n\\nthen we have the following result:\\n\\n`[1, 3, 1, 5, 1, 1, 1, 1, 1, 3, 1]`\\n\\nThat is for index `0` we have palindrome `a`, for index `2` it is `aba`, then `a`, then `bayab` and so on. What we need to do with this information? Let us construct intervals:\\n`ints = [(0, 0), (0, 2), (2, 2), (1, 5), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (8, 10), (10, 10)]` it is the size of biggest intervals for each middle point.\\n\\nNow, we need to solve the following problem: let us fix point `i`, so all string `s` will be separated into two parts:\\n`----------|---------`.  What we want to find is the biggest length of palindrom on the left and the biggest length of palindrome on the right, multiply them and do it for every `i` we have. If we do it directly, we will have `O(n^2)`, so we need to think about something better.\\n\\nLet us ask the question: given `i`, what is the maximum length of palindrome, which we meet before `i`? \\n1. Create empty array `arr1 = [0]*n`\\n2. For `a, b in ints`, that is for all intervals we have, update `arr1[b]` with length of interval. It can happen, that we have several intervals ending on the same points, so we use `max` here. After this update we have `[1, 0, 3, 0, 1, 5, 1, 1, 1, 0, 3]`.\\n3. It is imortant, and I forgot it on contest, and was not able to do it on time: we need to check `arr1[i+1] - 2` for each element. Imagine, that we have `[1, 1, 3, 1, 3, 5, 1, 1, 1, 1, 3]`. Note for example that `arr1[4]` was equal to `1` because there is only one segment ending with it. However `arr1[5] = 5` and we have `.bayab...`, so we can be sure that length of palindrome ending with place `4` is at least `arr1[5] - 2 = 3`.\\n4. Finally, we need to evaluate cumulative maximums of `arr1`: `[1, 1, 3, 3, 3, 5, 5, 5, 5, 5, 5]`. Now what we have is answer for the question: given `i`, what is the maximum lengh of palindrome lying before `i`.\\n\\nNow, we need to do exaclty the same logic for question: `what is the maximum length of palindrome after i`? We can use exactly the same function `helper` and reverse results!\\n\\nFinally, when we have answer for two questions:  `what is the maximum length of palindrome after i`? and  `what is the maximum length of palindrome before i`? - we can iterate over all indexes `i` and return `max`.\\n\\n#### Complexity\\nIt is `O(n)` to apply manacher and then we have several `O(n)` passes, so total complexity is `O(n)` both for time and space.\\n\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        def manachers(S):\\n            A = \\'@#\\' + \\'#\\'.join(S) + \\'#$\\'\\n            Z = [0] * len(A)\\n            center = right = 0\\n            for i in range(1, len(A) - 1):\\n                if i < right:\\n                    Z[i] = min(right - i, Z[2 * center - i])\\n                while A[i + Z[i] + 1] == A[i - Z[i] - 1]:\\n                    Z[i] += 1\\n                if i + Z[i] > right:\\n                    center, right = i, i + Z[i]\\n            return Z[2:-2:2]\\n\\n        def helper(s):\\n            man, n = manachers(s), len(s)\\n            ints = [(i - man[i]//2, i + man[i]//2) for i in range(n)]\\n            arr = [0]*n\\n            for a, b in ints: \\n                arr[b] = max(arr[b], b - a + 1)\\n            for i in range(n-2, -1, -1):\\n                arr[i] = max(arr[i], arr[i + 1] - 2)\\n            return list(accumulate(arr, max))\\n        \\n        t1, t2 = helper(s), helper(s[::-1])[::-1][1:] + [0]   \\n        return max(x*y for x, y in zip(t1, t2))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        def manachers(S):\\n            A = \\'@#\\' + \\'#\\'.join(S) + \\'#$\\'\\n            Z = [0] * len(A)\\n            center = right = 0\\n            for i in range(1, len(A) - 1):\\n                if i < right:\\n                    Z[i] = min(right - i, Z[2 * center - i])\\n                while A[i + Z[i] + 1] == A[i - Z[i] - 1]:\\n                    Z[i] += 1\\n                if i + Z[i] > right:\\n                    center, right = i, i + Z[i]\\n            return Z[2:-2:2]\\n\\n        def helper(s):\\n            man, n = manachers(s), len(s)\\n            ints = [(i - man[i]//2, i + man[i]//2) for i in range(n)]\\n            arr = [0]*n\\n            for a, b in ints: \\n                arr[b] = max(arr[b], b - a + 1)\\n            for i in range(n-2, -1, -1):\\n                arr[i] = max(arr[i], arr[i + 1] - 2)\\n            return list(accumulate(arr, max))\\n        \\n        t1, t2 = helper(s), helper(s[::-1])[::-1][1:] + [0]   \\n        return max(x*y for x, y in zip(t1, t2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390099,
                "title": "java-rolling-hash-solution-o-n-c-and-python-versions-in-comments",
                "content": "Prepare rolling hash for the string and its reverse. A substring is palindromic if its hash and hash for it\\'s reversion are equal.\\nThis solution don\\'t check possible collisions. Also it uses fact that if maximum palindrome has end at i and its length is L, then there\\'s a palindrome of length L-2 with end at position i-1. Same fact for beginnings of palindromes. Also we don\\'t need to find the longest plaindrome for each position if its length is less than previously found.\\n\\nTime complexity - O(n), space compelxity - O(n).\\n\\nAlso you can see my solution using Manacher\\'s algorithm there\\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389859/Java-Manacher-algorithm-O(n)\\n\\n```\\npublic class Solution {\\n    private static final long base = 29L;\\n    private static final long mod = Integer.MAX_VALUE;\\n\\n    private static boolean isPalindromic(int l, int r, long[] lh, long[] rh, long[] pow) {\\n        return lh(l, r, lh, pow) == rh(l, r, rh, pow);\\n    }\\n\\n    private static long lh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[r] - hash[l] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    private static long rh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[l] - hash[r] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = pow[i - 1] * base % mod;\\n\\n        long[] lh = new long[n + 1]; // hash[i] is hash value from str[0..i)\\n        for (int i = 1; i <= n; i++) lh[i] = (lh[i - 1] * base + s.charAt(i - 1) - \\'a\\') % mod;\\n\\n        long[] rh = new long[n + 1]; // hash[i] is hash value from str[i..n)\\n        for (int i = n - 1; i >= 0; i--) rh[i] = (rh[i + 1] * base + s.charAt(i) - \\'a\\') % mod;\\n\\n        int[] left = new int[n];\\n        for (int i = 0, max = 1; i < n; i++) {\\n            if (max < i && isPalindromic(i - max - 1, i + 1, lh, rh, pow)) max += 2;\\n            left[i] = max;\\n        }\\n\\n        int[] right = new int[n];\\n        for (int i = n - 1, max = 1; i >= 0; i--) {\\n            if (i + max + 2 <= n && isPalindromic(i, i + max + 2, lh, rh, pow)) max += 2;\\n            right[i] = max;\\n        }\\n\\n        long ans = 1;\\n        for (int i = 1; i < n; i++) ans = Math.max(ans, (long) left[i - 1] * right[i]);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Rolling Hash"
                ],
                "code": "```\\npublic class Solution {\\n    private static final long base = 29L;\\n    private static final long mod = Integer.MAX_VALUE;\\n\\n    private static boolean isPalindromic(int l, int r, long[] lh, long[] rh, long[] pow) {\\n        return lh(l, r, lh, pow) == rh(l, r, rh, pow);\\n    }\\n\\n    private static long lh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[r] - hash[l] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    private static long rh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[l] - hash[r] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = pow[i - 1] * base % mod;\\n\\n        long[] lh = new long[n + 1]; // hash[i] is hash value from str[0..i)\\n        for (int i = 1; i <= n; i++) lh[i] = (lh[i - 1] * base + s.charAt(i - 1) - \\'a\\') % mod;\\n\\n        long[] rh = new long[n + 1]; // hash[i] is hash value from str[i..n)\\n        for (int i = n - 1; i >= 0; i--) rh[i] = (rh[i + 1] * base + s.charAt(i) - \\'a\\') % mod;\\n\\n        int[] left = new int[n];\\n        for (int i = 0, max = 1; i < n; i++) {\\n            if (max < i && isPalindromic(i - max - 1, i + 1, lh, rh, pow)) max += 2;\\n            left[i] = max;\\n        }\\n\\n        int[] right = new int[n];\\n        for (int i = n - 1, max = 1; i >= 0; i--) {\\n            if (i + max + 2 <= n && isPalindromic(i, i + max + 2, lh, rh, pow)) max += 2;\\n            right[i] = max;\\n        }\\n\\n        long ans = 1;\\n        for (int i = 1; i < n; i++) ans = Math.max(ans, (long) left[i - 1] * right[i]);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389706,
                "title": "python3-hashing-nlogn-accepted",
                "content": "Idea:\\n1. We can compute hash for all prefixes and suffixes in linear time.\\n2. Then we can find if `a[i-k:i +k]` is palindrome in costant time.\\n3. So we can find the longest palindrome in logarithmic time by applying binary search.\\n4. Then we can find the longest for all `i` in linearithmic time.\\n5. Then just iterate over the finding to get the final result (similar to all other solutions).\\n\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        alphabet_size = 26\\n        mod = 10 ** 9 + 7\\n        straight_hash = [0] * len(s)\\n        reverse_hash = [0] * len(s)\\n        for i in range(len(s)):\\n            straight_hash[i] = (straight_hash[i - 1] * alphabet_size + ord(s[i]) - ord(\"a\")) % mod\\n            reverse_hash[~i] = (reverse_hash[~i + 1] * alphabet_size + ord(s[~i]) - ord(\"a\")) % mod\\n        straight_hash.append(0)\\n        reverse_hash.append(0)\\n\\n        longest_palindrome_from_left = [0] * len(s)\\n        longest_palindrome_from_right = [0] * len(s)\\n        for i in range(len(s)):\\n            low = 1\\n            high = min(i + 1, len(s) - i)\\n            \\n            if 0 < i < len(s) - 1 and s[i - 1] == s[i + 1]:     # hack (otherwise TLE): don\\'t run binary search if adjecent letters are different\\n                while low < high:\\n                    mid = (low + high + 1) // 2\\n                    m = pow(alphabet_size, mid, mod)\\n                    if (straight_hash[i] - straight_hash[i - mid] * m) % mod == (reverse_hash[i] - reverse_hash[i + mid] * m) % mod:\\n                        low = mid\\n                    else:\\n                        high = mid - 1\\n            longest_palindrome_from_left[i + low - 1] = max(low * 2 - 1, longest_palindrome_from_left[i + low - 1])\\n            longest_palindrome_from_right[i - low + 1] = max(low * 2 - 1, longest_palindrome_from_right[i - low + 1])\\n\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[i] = max(longest_palindrome_from_left[i], longest_palindrome_from_left[i - 1])\\n            longest_palindrome_from_right[~i] = max(longest_palindrome_from_right[~i], longest_palindrome_from_right[~i + 1])\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[~i] = max(longest_palindrome_from_left[~i], longest_palindrome_from_left[~i + 1] - 2)\\n            longest_palindrome_from_right[i] = max(longest_palindrome_from_right[i], longest_palindrome_from_right[i - 1] - 2)\\n\\n        res = 0\\n        for i in range(1, len(s)):\\n            res = max(res, longest_palindrome_from_left[i - 1] * longest_palindrome_from_right[i])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        alphabet_size = 26\\n        mod = 10 ** 9 + 7\\n        straight_hash = [0] * len(s)\\n        reverse_hash = [0] * len(s)\\n        for i in range(len(s)):\\n            straight_hash[i] = (straight_hash[i - 1] * alphabet_size + ord(s[i]) - ord(\"a\")) % mod\\n            reverse_hash[~i] = (reverse_hash[~i + 1] * alphabet_size + ord(s[~i]) - ord(\"a\")) % mod\\n        straight_hash.append(0)\\n        reverse_hash.append(0)\\n\\n        longest_palindrome_from_left = [0] * len(s)\\n        longest_palindrome_from_right = [0] * len(s)\\n        for i in range(len(s)):\\n            low = 1\\n            high = min(i + 1, len(s) - i)\\n            \\n            if 0 < i < len(s) - 1 and s[i - 1] == s[i + 1]:     # hack (otherwise TLE): don\\'t run binary search if adjecent letters are different\\n                while low < high:\\n                    mid = (low + high + 1) // 2\\n                    m = pow(alphabet_size, mid, mod)\\n                    if (straight_hash[i] - straight_hash[i - mid] * m) % mod == (reverse_hash[i] - reverse_hash[i + mid] * m) % mod:\\n                        low = mid\\n                    else:\\n                        high = mid - 1\\n            longest_palindrome_from_left[i + low - 1] = max(low * 2 - 1, longest_palindrome_from_left[i + low - 1])\\n            longest_palindrome_from_right[i - low + 1] = max(low * 2 - 1, longest_palindrome_from_right[i - low + 1])\\n\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[i] = max(longest_palindrome_from_left[i], longest_palindrome_from_left[i - 1])\\n            longest_palindrome_from_right[~i] = max(longest_palindrome_from_right[~i], longest_palindrome_from_right[~i + 1])\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[~i] = max(longest_palindrome_from_left[~i], longest_palindrome_from_left[~i + 1] - 2)\\n            longest_palindrome_from_right[i] = max(longest_palindrome_from_right[i], longest_palindrome_from_right[i - 1] - 2)\\n\\n        res = 0\\n        for i in range(1, len(s)):\\n            res = max(res, longest_palindrome_from_left[i - 1] * longest_palindrome_from_right[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396545,
                "title": "python-rolling-hash-binary-search-with-code-comments",
                "content": "Got the idea from post \\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389706/Python3.-Hashing.-NlogN.-Accepted.\\nand added more explanations.\\n\\nThe idea is to decompose the problem into subproblems:\\n1. Create rolling hash from left and from right. This is O(n).\\n2. Judge if it is a palindrome with a given center and given radius in O(1) time. This is done by comparing hash value.\\n3. Use each position as center, find the longest parlindrome extension. This is done by binary search, with step 2 as a subproblem, in total O (n log(n) ).\\n4. Now we know the max len parlindrome ending at a position from both left and right, apply next array type idea to get the final answer: to get the max len till a position (not necessarily ending with it), it has two cases to consider, see code comments..\\n\\nOverall, the time limit is pretty tight, guess applying Manacher is faster (O(n) ) but I don\\'t have that knowledge.\\n\\n```\\nclass Solution:\\n    \\n    def maxProduct(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        base = 27\\n        n = len(s)\\n        forward_hash = [0] * (len(s) + 1)\\n        backward_hash = [0] * (len(s) + 1)\\n        for i in range(1, n+1):\\n            forward_hash[i] = (forward_hash[i-1] * base + (ord(s[i-1]) - ord(\\'a\\'))) % mod\\n        for i in range(n-1, -1, -1):\\n            backward_hash[i] = (backward_hash[i+1] * base + (ord(s[i]) - ord(\\'a\\'))) % mod\\n            \\n        def is_parlin(s, center, l):\\n            # check if it is a palin, with l being the radius\\n            # [left, center-1] vs [center+1, right]\\n            p = pow(base, l, mod)\\n            left_hash = (forward_hash[center] - forward_hash[center-l] * p) % mod\\n            right_hash = (backward_hash[center+1] - backward_hash[center+l+1] * p) % mod\\n            return left_hash == right_hash\\n        \\n        # inclusive\\n        before_idx_max_len = [1] * n\\n        after_idx_max_len = [1] * n\\n        \\n        # for each center, expand\\n        for i in range(1, n-1):\\n            max_radius = 1\\n            if s[i-1] != s[i+1]: # radius = 1 fails\\n                continue\\n            # find the largest extention so that [center+1, right] is the same as [left, center-1]\\n            start, end = 1, min(i, n-i)\\n            while start + 1 < end:\\n                mid = (start + end) // 2\\n                if is_parlin(s, i, mid):\\n                    start = mid\\n                else:\\n                    end = mid\\n            if i + end < n and is_parlin(s, i, end):\\n                max_radius = end\\n            else:\\n                max_radius = start\\n                \\n            left = i - max_radius\\n            right = i + max_radius\\n            before_idx_max_len[right] = max(before_idx_max_len[right], 2*max_radius+1)\\n            after_idx_max_len[left] = max(after_idx_max_len[left], 2*max_radius+1)\\n        \\n        # handle trick case1: if ending with i is palin with len, then end with i-1 should be parlin with at least len-2!\\n        for i in range(n-2, -1, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i], before_idx_max_len[i+1]-2)\\n        for i in range(1, n):\\n            after_idx_max_len[i] = max(after_idx_max_len[i], after_idx_max_len[i-1]-2)\\n        \\n        # case2: find max till now using next array\\n        for i in range(n-1, 0, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i-1], before_idx_max_len[i])\\n        for i in range(n-2, -1, -1):\\n            after_idx_max_len[i] = max(after_idx_max_len[i+1], after_idx_max_len[i])\\n        \\n        # print(before_idx_max_len, after_idx_max_len)\\n        # find the best possible\\n        res = 1\\n        for i in range(n-1):\\n            res = max(res, before_idx_max_len[i] * after_idx_max_len[i+1])\\n            \\n        return res\\n",
                "solutionTags": [],
                "code": "Got the idea from post \\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389706/Python3.-Hashing.-NlogN.-Accepted.\\nand added more explanations.\\n\\nThe idea is to decompose the problem into subproblems:\\n1. Create rolling hash from left and from right. This is O(n).\\n2. Judge if it is a palindrome with a given center and given radius in O(1) time. This is done by comparing hash value.\\n3. Use each position as center, find the longest parlindrome extension. This is done by binary search, with step 2 as a subproblem, in total O (n log(n) ).\\n4. Now we know the max len parlindrome ending at a position from both left and right, apply next array type idea to get the final answer: to get the max len till a position (not necessarily ending with it), it has two cases to consider, see code comments..\\n\\nOverall, the time limit is pretty tight, guess applying Manacher is faster (O(n) ) but I don\\'t have that knowledge.\\n\\n```\\nclass Solution:\\n    \\n    def maxProduct(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        base = 27\\n        n = len(s)\\n        forward_hash = [0] * (len(s) + 1)\\n        backward_hash = [0] * (len(s) + 1)\\n        for i in range(1, n+1):\\n            forward_hash[i] = (forward_hash[i-1] * base + (ord(s[i-1]) - ord(\\'a\\'))) % mod\\n        for i in range(n-1, -1, -1):\\n            backward_hash[i] = (backward_hash[i+1] * base + (ord(s[i]) - ord(\\'a\\'))) % mod\\n            \\n        def is_parlin(s, center, l):\\n            # check if it is a palin, with l being the radius\\n            # [left, center-1] vs [center+1, right]\\n            p = pow(base, l, mod)\\n            left_hash = (forward_hash[center] - forward_hash[center-l] * p) % mod\\n            right_hash = (backward_hash[center+1] - backward_hash[center+l+1] * p) % mod\\n            return left_hash == right_hash\\n        \\n        # inclusive\\n        before_idx_max_len = [1] * n\\n        after_idx_max_len = [1] * n\\n        \\n        # for each center, expand\\n        for i in range(1, n-1):\\n            max_radius = 1\\n            if s[i-1] != s[i+1]: # radius = 1 fails\\n                continue\\n            # find the largest extention so that [center+1, right] is the same as [left, center-1]\\n            start, end = 1, min(i, n-i)\\n            while start + 1 < end:\\n                mid = (start + end) // 2\\n                if is_parlin(s, i, mid):\\n                    start = mid\\n                else:\\n                    end = mid\\n            if i + end < n and is_parlin(s, i, end):\\n                max_radius = end\\n            else:\\n                max_radius = start\\n                \\n            left = i - max_radius\\n            right = i + max_radius\\n            before_idx_max_len[right] = max(before_idx_max_len[right], 2*max_radius+1)\\n            after_idx_max_len[left] = max(after_idx_max_len[left], 2*max_radius+1)\\n        \\n        # handle trick case1: if ending with i is palin with len, then end with i-1 should be parlin with at least len-2!\\n        for i in range(n-2, -1, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i], before_idx_max_len[i+1]-2)\\n        for i in range(1, n):\\n            after_idx_max_len[i] = max(after_idx_max_len[i], after_idx_max_len[i-1]-2)\\n        \\n        # case2: find max till now using next array\\n        for i in range(n-1, 0, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i-1], before_idx_max_len[i])\\n        for i in range(n-2, -1, -1):\\n            after_idx_max_len[i] = max(after_idx_max_len[i+1], after_idx_max_len[i])\\n        \\n        # print(before_idx_max_len, after_idx_max_len)\\n        # find the best possible\\n        res = 1\\n        for i in range(n-1):\\n            res = max(res, before_idx_max_len[i] * after_idx_max_len[i+1])\\n            \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2017147,
                "title": "manachers-algo-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long max(long long x,long long y)\\n    {\\n        if(x>y)\\n            return x;\\n        return y;\\n    }\\n    \\n    long long maxProduct(string t) {\\n        int n=t.length();\\n        vector<int> left(n,0),lpso(n,0);\\n        int r=0,c=0;\\n\\t    // Manachar\\'s algo\\n        for(int i=0;i<n;i++)\\n        {\\n            int m=2*c-i;\\n            if(i<r)\\n                lpso[i]= min(lpso[m],r-i);\\n            while(i-lpso[i]-1 >=0 && i+lpso[i]+1<n && t[i-lpso[i]-1] == t[i+lpso[i]+1])\\n                lpso[i]++;\\n            if(r<i+lpso[i])\\n                r=i+lpso[i],c=i;\\n        }\\n\\t\\t// Finding the longest palindrome ending before ith index or at ith index \\n        left[0] = 1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=1;i<=n-1;i++)\\n        {\\n            if(lpso[i]>0)\\n                pq.push({i,lpso[i]}),left[i]=1;\\n            if(!pq.empty())\\n            {\\n\\t\\t\\t    // Number of elements between the ith position and the center of palindrome\\n                while(!pq.empty() && pq.top().first+pq.top().second<i)\\n                    pq.pop();\\n                if(!pq.empty())\\n                    left[i]= 2*(i-pq.top().first)+1;\\n                else\\n                    left[i]=1;\\n            }\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n\\t\\t\\n\\t\\t// Finding the longest palindrome ending after ith index or at ith index \\n        priority_queue<pair<int,int>> pql;\\n        int m=1,l=1;\\n        long long ans=0;\\n        ans = max(ans,1LL*left[n-2]*m);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(lpso[i]>0)\\n                pql.push({i,lpso[i]}),l=1;\\n            if(!pql.empty())\\n            {\\n\\t\\t    \\t// Number of elements between the ith position and the center of palindrome\\n                while(!pql.empty() && pql.top().first-pql.top().second>i)\\n                    pql.pop();\\n                if(!pql.empty())\\n                    l= 2*(pql.top().first-i)+1;\\n                else\\n                    l=1;\\n            }\\n            m=max(m,l);\\n\\t\\t\\t// Directly calculating by multiplying (ending before ith) * (ending after or at ith)\\n            if(i>0)\\n                ans= max(ans, 1LL*left[i-1]*m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long max(long long x,long long y)\\n    {\\n        if(x>y)\\n            return x;\\n        return y;\\n    }\\n    \\n    long long maxProduct(string t) {\\n        int n=t.length();\\n        vector<int> left(n,0),lpso(n,0);\\n        int r=0,c=0;\\n\\t    // Manachar\\'s algo\\n        for(int i=0;i<n;i++)\\n        {\\n            int m=2*c-i;\\n            if(i<r)\\n                lpso[i]= min(lpso[m],r-i);\\n            while(i-lpso[i]-1 >=0 && i+lpso[i]+1<n && t[i-lpso[i]-1] == t[i+lpso[i]+1])\\n                lpso[i]++;\\n            if(r<i+lpso[i])\\n                r=i+lpso[i],c=i;\\n        }\\n\\t\\t// Finding the longest palindrome ending before ith index or at ith index \\n        left[0] = 1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=1;i<=n-1;i++)\\n        {\\n            if(lpso[i]>0)\\n                pq.push({i,lpso[i]}),left[i]=1;\\n            if(!pq.empty())\\n            {\\n\\t\\t\\t    // Number of elements between the ith position and the center of palindrome\\n                while(!pq.empty() && pq.top().first+pq.top().second<i)\\n                    pq.pop();\\n                if(!pq.empty())\\n                    left[i]= 2*(i-pq.top().first)+1;\\n                else\\n                    left[i]=1;\\n            }\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n\\t\\t\\n\\t\\t// Finding the longest palindrome ending after ith index or at ith index \\n        priority_queue<pair<int,int>> pql;\\n        int m=1,l=1;\\n        long long ans=0;\\n        ans = max(ans,1LL*left[n-2]*m);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(lpso[i]>0)\\n                pql.push({i,lpso[i]}),l=1;\\n            if(!pql.empty())\\n            {\\n\\t\\t    \\t// Number of elements between the ith position and the center of palindrome\\n                while(!pql.empty() && pql.top().first-pql.top().second>i)\\n                    pql.pop();\\n                if(!pql.empty())\\n                    l= 2*(pql.top().first-i)+1;\\n                else\\n                    l=1;\\n            }\\n            m=max(m,l);\\n\\t\\t\\t// Directly calculating by multiplying (ending before ith) * (ending after or at ith)\\n            if(i>0)\\n                ans= max(ans, 1LL*left[i-1]*m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393832,
                "title": "python3-manacher",
                "content": "\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Manacher\\'s algo\\n        hlen = [0]*n # half-length\\n        center = right = 0 \\n        for i in range(n): \\n            if i < right: hlen[i] = min(right - i, hlen[2*center - i])\\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \\n                hlen[i] += 1\\n            if right < i+hlen[i]: center, right = i, i+hlen[i]\\n        \\n        prefix = [0]*n\\n        suffix = [0]*n\\n        for i in range(n): \\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)\\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)\\n        \\n        for i in range(1, n): \\n            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)\\n            suffix[i] = max(suffix[i], suffix[i-1]-2)\\n        \\n        for i in range(1, n): \\n            prefix[i] = max(prefix[i-1], prefix[i])\\n            suffix[~i] = max(suffix[~i], suffix[~i+1])\\n        \\n        return max(prefix[i-1]*suffix[i] for i in range(1, n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Manacher\\'s algo\\n        hlen = [0]*n # half-length\\n        center = right = 0 \\n        for i in range(n): \\n            if i < right: hlen[i] = min(right - i, hlen[2*center - i])\\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \\n                hlen[i] += 1\\n            if right < i+hlen[i]: center, right = i, i+hlen[i]\\n        \\n        prefix = [0]*n\\n        suffix = [0]*n\\n        for i in range(n): \\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)\\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)\\n        \\n        for i in range(1, n): \\n            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)\\n            suffix[i] = max(suffix[i], suffix[i-1]-2)\\n        \\n        for i in range(1, n): \\n            prefix[i] = max(prefix[i-1], prefix[i])\\n            suffix[~i] = max(suffix[~i], suffix[~i+1])\\n        \\n        return max(prefix[i-1]*suffix[i] for i in range(1, n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389279,
                "title": "o-n-with-manacher-s-algorithm",
                "content": "n is in the order of 10^5, so I think O(n^2) will TLE. We need to use Manacher\\'s algorithm to get the longest palindrome substring at each index, which is O(n).\\n\\nFor Manacher\\'s algorithm, go to wiki\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring\\n```\\n    def maxProduct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        T = \\'$#\\' + \\'#\\'.join(s) + \\'#@\\'\\n        P = [0] * len(T) # store the length at each index\\n        right, center = 0, 0\\n        for i in range(1,len(T)-1):\\n            if i < right:\\n                P[i] = min(P[2 * center - i], right - i)\\n            while T[i+(P[i]+1)] == T[i-(P[i]+1)]:\\n                P[i] += 1\\n            if P[i] + i > right:\\n                right = P[i] + i\\n                center = i\\n                \\n        arr = []#the longest length centering at each index of original array, odd length\\n        for i in range(len(T)):\\n            if T[i].isalpha():\\n                arr.append(P[i])\\n                \\n        pre = [1 for _ in range(len(s))]\\n        for i in range(len(s)):# the ending point of each longest substring\\n            pre[i+(arr[i]-1)//2] = max(pre[i+(arr[i]-1)//2],arr[i])\\n        for i in range(len(s)-2,-1,-1):# the end can be shorter, like \"aba\" is a substring of \"cabac\"\\n            pre[i] = max(pre[i],pre[i+1]-2)\\n        for i in range(len(pre)-1):#the maximum length before and at i\\n            pre[i+1] = max(pre[i],pre[i+1])\\n\\n        post = [1 for _ in range(len(s))]#do it again for the suffix array\\n        for i in range(len(s)-1,-1,-1):\\n            post[i-(arr[i]-1)//2] = max(post[i-(arr[i]-1)//2],arr[i])\\n        for i in range(1,len(s)):\\n            post[i] = max(post[i],post[i-1]-2)    \\n        post = post[1:]+[0]\\n        for i in range(len(s)-1,0,-1):#the maximum length after i\\n            post[i-1] = max(post[i-1],post[i])\\n            \\n        res = 0\\n        for i in range(len(pre)):\\n            res = max(res,pre[i]*post[i])\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProduct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        T = \\'$#\\' + \\'#\\'.join(s) + \\'#@\\'\\n        P = [0] * len(T) # store the length at each index\\n        right, center = 0, 0\\n        for i in range(1,len(T)-1):\\n            if i < right:\\n                P[i] = min(P[2 * center - i], right - i)\\n            while T[i+(P[i]+1)] == T[i-(P[i]+1)]:\\n                P[i] += 1\\n            if P[i] + i > right:\\n                right = P[i] + i\\n                center = i\\n                \\n        arr = []#the longest length centering at each index of original array, odd length\\n        for i in range(len(T)):\\n            if T[i].isalpha():\\n                arr.append(P[i])\\n                \\n        pre = [1 for _ in range(len(s))]\\n        for i in range(len(s)):# the ending point of each longest substring\\n            pre[i+(arr[i]-1)//2] = max(pre[i+(arr[i]-1)//2],arr[i])\\n        for i in range(len(s)-2,-1,-1):# the end can be shorter, like \"aba\" is a substring of \"cabac\"\\n            pre[i] = max(pre[i],pre[i+1]-2)\\n        for i in range(len(pre)-1):#the maximum length before and at i\\n            pre[i+1] = max(pre[i],pre[i+1])\\n\\n        post = [1 for _ in range(len(s))]#do it again for the suffix array\\n        for i in range(len(s)-1,-1,-1):\\n            post[i-(arr[i]-1)//2] = max(post[i-(arr[i]-1)//2],arr[i])\\n        for i in range(1,len(s)):\\n            post[i] = max(post[i],post[i-1]-2)    \\n        post = post[1:]+[0]\\n        for i in range(len(s)-1,0,-1):#the maximum length after i\\n            post[i-1] = max(post[i-1],post[i])\\n            \\n        res = 0\\n        for i in range(len(pre)):\\n            res = max(res,pre[i]*post[i])\\n        return res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1393288,
                "title": "java-100-o-n-time-o-n-space-using-manacher-s-algorithm",
                "content": "```\\n// using manachers algorithm\\n\\nclass Solution {\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n        if (n == 2) return 1;\\n        int[] len = manachers(s);               // get lengths of palindromes at each element\\n        \\n        long left[] = new long[n];                // stores the max length of palindrome to left of each index\\n        \\n        int max = 1;\\n        left[0] = max;\\n        for (int i = 1; i <= n - 1; i++) {\\n            // does any palindrome end at i with length greater than max\\n            if (len[(i - max - 1 + i)/2] > max) max += 2;\\n            left[i] = max;\\n        }\\n        max = 1;\\n        long[] right = new long[n];             // stores the max length of palindrome to right of each index\\n        right[n - 1] = max;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            // does any palindrome start at i with length greater than max\\n            if (len[(i + max + 1 + i)/2] > max) max += 2;\\n            right[i] = max;\\n        }\\n        \\n        long res = 1;\\n        \\n        for (int i = 1; i < n; i++) {            \\n            res = Math.max(res, left[i - 1] * right[i]);\\n        }\\n        return res;\\n    }\\n    \\n\\t// credit : https://hackernoon.com/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f\\n\\tprivate int[] manachers(String s) {\\n        \\n        int len = s.length();\\n        int[] P = new int[len];\\n        int c = 0; //stores the center of the longest palindromic substring until now\\n        int r = 0; //stores the right boundary of the longest palindromic substring until now\\n        int maxLen = 0;\\n       \\n        for(int i = 0; i < len; i++) {\\n            //get mirror index of i\\n            int mirror = (2 * c) - i;\\n            \\n            //see if the mirror of i is expanding beyond the left boundary of current longest palindrome at center c\\n            //if it is, then take r - i as P[i]\\n            //else take P[mirror] as P[i]\\n            if(i < r) {\\n                P[i] = Math.min(r - i, P[mirror]);\\n            }\\n            \\n            //expand at i\\n            int a = i + (1 + P[i]);\\n            int b = i - (1 + P[i]);\\n            while(a < len && b >= 0 && s.charAt(a) == s.charAt(b)) {\\n                P[i]++;\\n                a++;\\n                b--;\\n            }\\n            \\n            //check if the expanded palindrome at i is expanding beyond the right boundary of current longest palindrome at center c\\n            //if it is, the new center is i\\n            if(i + P[i] > r) {\\n                c = i;\\n                r = i + P[i];\\n            }\\n        }\\n        for (int i = 0; i < len; i++) P[i] = 1 + 2*P[i];\\n        return P;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// using manachers algorithm\\n\\nclass Solution {\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n        if (n == 2) return 1;\\n        int[] len = manachers(s);               // get lengths of palindromes at each element\\n        \\n        long left[] = new long[n];                // stores the max length of palindrome to left of each index\\n        \\n        int max = 1;\\n        left[0] = max;\\n        for (int i = 1; i <= n - 1; i++) {\\n            // does any palindrome end at i with length greater than max\\n            if (len[(i - max - 1 + i)/2] > max) max += 2;\\n            left[i] = max;\\n        }\\n        max = 1;\\n        long[] right = new long[n];             // stores the max length of palindrome to right of each index\\n        right[n - 1] = max;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            // does any palindrome start at i with length greater than max\\n            if (len[(i + max + 1 + i)/2] > max) max += 2;\\n            right[i] = max;\\n        }\\n        \\n        long res = 1;\\n        \\n        for (int i = 1; i < n; i++) {            \\n            res = Math.max(res, left[i - 1] * right[i]);\\n        }\\n        return res;\\n    }\\n    \\n\\t// credit : https://hackernoon.com/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f\\n\\tprivate int[] manachers(String s) {\\n        \\n        int len = s.length();\\n        int[] P = new int[len];\\n        int c = 0; //stores the center of the longest palindromic substring until now\\n        int r = 0; //stores the right boundary of the longest palindromic substring until now\\n        int maxLen = 0;\\n       \\n        for(int i = 0; i < len; i++) {\\n            //get mirror index of i\\n            int mirror = (2 * c) - i;\\n            \\n            //see if the mirror of i is expanding beyond the left boundary of current longest palindrome at center c\\n            //if it is, then take r - i as P[i]\\n            //else take P[mirror] as P[i]\\n            if(i < r) {\\n                P[i] = Math.min(r - i, P[mirror]);\\n            }\\n            \\n            //expand at i\\n            int a = i + (1 + P[i]);\\n            int b = i - (1 + P[i]);\\n            while(a < len && b >= 0 && s.charAt(a) == s.charAt(b)) {\\n                P[i]++;\\n                a++;\\n                b--;\\n            }\\n            \\n            //check if the expanded palindrome at i is expanding beyond the right boundary of current longest palindrome at center c\\n            //if it is, the new center is i\\n            if(i + P[i] > r) {\\n                c = i;\\n                r = i + P[i];\\n            }\\n        }\\n        for (int i = 0; i < len; i++) P[i] = 1 + 2*P[i];\\n        return P;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389320,
                "title": "c-manacher-set-priority-queue-to-build-maxl-and-maxr",
                "content": "I got WA at last second because i forgot to cast to long long, got accepted after 1 second of contest end ;(\\n\\nAnyway the idea here is to just use manacher\\'s algorithm and then build the prefix and suffix max palindrome length, by using a priority queue (set here is used to quickly make a min priority queue instead of max priority queue).\\n\\nThen at every index just update the result if we find a new best product.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961860,
                "title": "c-manacher-and-queue-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        vector<int> d1(s.size());\\n        int n=s.size();\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n        cout<<d1[i]<<\\' \\';\\n    }\\n        vector<int> l(s.size(),1),r(s.size(),1);\\n        queue<int> q;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                l[i] = max(l[i], l[i - 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() + d1[q.front()] - 1 < i)\\n            {\\n                q.pop();\\n            }\\n\\n            l[i] = max(l[i], ((i - q.front()) * 2) + 1);\\n        }\\n        while(!q.empty()) q.pop();\\n      \\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                r[i] = max(r[i], r[i + 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() - d1[q.front()] + 1 > i)\\n            {\\n                q.pop();\\n            }\\n\\n            r[i] = max(r[i], ((q.front() - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) l[i] * (long long)r[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        vector<int> d1(s.size());\\n        int n=s.size();\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n        cout<<d1[i]<<\\' \\';\\n    }\\n        vector<int> l(s.size(),1),r(s.size(),1);\\n        queue<int> q;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                l[i] = max(l[i], l[i - 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() + d1[q.front()] - 1 < i)\\n            {\\n                q.pop();\\n            }\\n\\n            l[i] = max(l[i], ((i - q.front()) * 2) + 1);\\n        }\\n        while(!q.empty()) q.pop();\\n      \\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                r[i] = max(r[i], r[i + 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() - d1[q.front()] + 1 > i)\\n            {\\n                q.pop();\\n            }\\n\\n            r[i] = max(r[i], ((q.front() - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) l[i] * (long long)r[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2127513,
                "title": "manacher-algorithm-prefix-suffix-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> build_pal(string &s) // Manacher\\'s algo\\n    {\\n        int n=s.length();\\n        vector<long long> d1(n);   // [ i-d1[i]+1 , i+d1[i]-1 ];  length = 2*d1[i] - 1   \\n        for (long long i=0,l=0,r=-1; i<n; i++) \\n        {\\n            long long k = (i>r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i-k && i+k < n && s[i-k] == s[i+k]) k++;\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i-k;\\n                r = i+k;\\n            }\\n        }\\n        return d1;\\n    }\\n\\n\\n    long long maxProduct(string s) \\n    {\\n        int n=s.length();\\n        vector<long long> d1=build_pal(s);\\n        long long l[n+5],r[n+5],ans=0;\\n        memset(l,0,sizeof(l)); memset(r,0,sizeof(r));\\n        for(int i=0;i<n;i++)\\n        {\\n            r[i-d1[i]+1]=max(r[i-d1[i]+1],2*d1[i]-1);\\n            l[i+d1[i]-1]=max(l[i+d1[i]-1],2*d1[i]-1);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            r[i]=max(r[i],r[i-1]-2);\\n        for(int i=n-2;i>=0;i--)\\n            l[i]=max(l[i],l[i+1]-2);\\n        \\n        for(int i=1;i<n;i++)\\n            l[i]=max(l[i],l[i-1]);\\n        for(int i=n-2;i>=0;i--)\\n            r[i]=max(r[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n            ans=max(ans,l[i]*r[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> build_pal(string &s) // Manacher\\'s algo\\n    {\\n        int n=s.length();\\n        vector<long long> d1(n);   // [ i-d1[i]+1 , i+d1[i]-1 ];  length = 2*d1[i] - 1   \\n        for (long long i=0,l=0,r=-1; i<n; i++) \\n        {\\n            long long k = (i>r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i-k && i+k < n && s[i-k] == s[i+k]) k++;\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i-k;\\n                r = i+k;\\n            }\\n        }\\n        return d1;\\n    }\\n\\n\\n    long long maxProduct(string s) \\n    {\\n        int n=s.length();\\n        vector<long long> d1=build_pal(s);\\n        long long l[n+5],r[n+5],ans=0;\\n        memset(l,0,sizeof(l)); memset(r,0,sizeof(r));\\n        for(int i=0;i<n;i++)\\n        {\\n            r[i-d1[i]+1]=max(r[i-d1[i]+1],2*d1[i]-1);\\n            l[i+d1[i]-1]=max(l[i+d1[i]-1],2*d1[i]-1);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            r[i]=max(r[i],r[i-1]-2);\\n        for(int i=n-2;i>=0;i--)\\n            l[i]=max(l[i],l[i+1]-2);\\n        \\n        for(int i=1;i<n;i++)\\n            l[i]=max(l[i],l[i-1]);\\n        for(int i=n-2;i>=0;i--)\\n            r[i]=max(r[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n            ans=max(ans,l[i]*r[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601474,
                "title": "go-manachers-prefixmax",
                "content": "This problem is a mouthful.. I sure do hate palindromes.\\n\\nAs with many other solutions here, I use Manacher\\'s algorithm to find the maximum palindrome for each position in the input string. For more info on Manacher\\'s, please see\\nhttps://cp-algorithms.com/string/manacher.html\\n\\nWe only need to consider odd-length palindromes for this exercise.\\n\\nOnce a palindrome has been found by Manacher\\'s, store the size of the paindrome just outside the right boundary of the palindrome to the right. This will be used to form a prefix-max.\\n\\nTo get the prefix-max for left-to-right, reverse the string and the result.\\n\\nFinally, find the maximum product by combining the max palindrome to the left/right of each position in the input string.\\n\\n<iframe src=\"https://leetcode.com/playground/HvuT3KuH/shared\" frameBorder=\"0\" width=\"700\" height=\"1200\"></iframe>",
                "solutionTags": [
                    "Go"
                ],
                "code": "This problem is a mouthful.. I sure do hate palindromes.\\n\\nAs with many other solutions here, I use Manacher\\'s algorithm to find the maximum palindrome for each position in the input string. For more info on Manacher\\'s, please see\\nhttps://cp-algorithms.com/string/manacher.html\\n\\nWe only need to consider odd-length palindromes for this exercise.\\n\\nOnce a palindrome has been found by Manacher\\'s, store the size of the paindrome just outside the right boundary of the palindrome to the right. This will be used to form a prefix-max.\\n\\nTo get the prefix-max for left-to-right, reverse the string and the result.\\n\\nFinally, find the maximum product by combining the max palindrome to the left/right of each position in the input string.\\n\\n<iframe src=\"https://leetcode.com/playground/HvuT3KuH/shared\" frameBorder=\"0\" width=\"700\" height=\"1200\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2203333,
                "title": "here-is-simple-o-n-approach-self-explanatory-c-dp",
                "content": "class Solution {\\npublic:\\n    long long int maxProduct(string s) {\\n        long long int n = s.size();\\n        \\n        vector<long long int> dp(n + 1, 1);\\n        vector<long long int> udp(n + 1, 1);\\n        \\n        for (long long int i = 2; i < n; i++) {\\n            // cout << \"i = \" << i << \" i2 = \" << i - dp[i - 1] - 1 <<  endl;\\n            if (i - dp[i - 1] - 1 >= 0 && s[i] == s[i - dp[i - 1] - 1]) {\\n                dp[i] = dp[i - 1] + 2;\\n            }\\n            else\\n                dp[i] = 1;\\n            // cout << \"dpi = \" << dp[i] << endl;\\n        }\\n        \\n        \\n        for (long long int i = n - 3; i >= 0; i--) {\\n            if (i + udp[i + 1] + 1 < n && s[i] == s[i + udp[i + 1] + 1])\\n                udp[i] = udp[i + 1]  + 2;\\n            else\\n                udp[i] = 1;\\n        }\\n        \\n        \\n        vector<long long int> pl(n + 1, 1), pr(n + 1, 1);\\n        \\n        for (int i = 1; i < n; i++) {\\n            pl[i] = max(pl[i - 1], dp[i]);\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            pr[i] = max(pr[i + 1], udp[i]);\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for (long long int i = 0; i < n - 1; i++) {\\n            ans = max(ans, pl[i] * pr[i + 1]);\\n            if (ans < pl[i] * pr[i + 1])\\n                ans = pl[i] * pr[i + 1];\\n            // long long int t1 = pl[i], t2 = pr[i + 1];\\n            // if (t1 * t2 > 2147385345)\\n            //     cout << t1 * t2 << endl;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long int maxProduct(string s) {\\n        long long int n = s.size();\\n        \\n        vector<long long int> dp(n + 1, 1);\\n        vector<long long int> udp(n + 1, 1);\\n        \\n        for (long long int i = 2; i < n; i++) {\\n            // cout << \"i = \" << i << \" i2 = \" << i - dp[i - 1] - 1 <<  endl;\\n            if (i - dp[i - 1] - 1 >= 0 && s[i] == s[i - dp[i - 1] - 1]) {\\n                dp[i] = dp[i - 1] + 2;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1427632,
                "title": "c-manacher-o-n-103-ms-49-34-26-2-mb-57-73",
                "content": "It is known that the Manacher\\'s algorithm can obtain each maximum palindromic sequence with the odd length at different centers.\\nFrom an array of the maximum length of the given sequence, the maximum length in the interval [0, i] is easily derived.\\nTo derive the maxiimum length in the interval [j, s.size()-1], the desired array is derived when the given string is reversed.\\n\\n```\\nclass Solution {\\npublic:\\ntypedef long long int ll;\\nstd::vector<int> manacher(std::string& s){\\n  std::vector<int> R(s.size());\\n  int i = 0, j = 0;\\n  while (i < s.size()) {\\n    while (i-j >= 0 && i+j < s.size() && s[i-j] == s[i+j]) ++j;\\n    R[i] = j;\\n    int k = 1;\\n    while (i-k >= 0 && k+R[i-k] < j) R[i+k] = R[i-k], ++k;\\n    i += k; j -= k;\\n  }\\n  return std::move(R);\\n}\\n\\n  vector<int> maxlength(string &s){\\n    vector<int> center_l = manacher(s);\\n    vector<int> ans(s.size());\\n    int num = 1;\\n    int maxv = 1;\\n    for(int i=0;i<s.size()-1;i++){\\n        int len = 2 * (center_l[i] - 1) + 1;\\n        int loc = center_l[i] - 1;\\n        ans[i+loc] = max(ans[i+loc], len);\\n    }\\n    int tmp = 0;\\n    for(int i=0;i<s.size();i++){\\n        if(tmp < ans[i])\\n            tmp = ans[i];\\n        ans[i] = tmp;\\n    }\\n    int cnt = ans[s.size()-1];\\n    for(int i=s.size()-2;i>=0;i--){\\n        if(ans[i] < cnt)\\n            cnt = cnt - 2;\\n        ans[i] = cnt;\\n    }\\n    return std::move(ans);\\n  }\\n    \\n  long long maxProduct(string s) {\\n    vector<int> left = maxlength(s);\\n    reverse(s.begin(), s.end());\\n    vector<int> right = maxlength(s);\\n    ll ans = 0;\\n    for(int i=0;i<s.size()-1;i++){\\n        ll l = left[i];\\n        ll r = right[s.size() - i -2];\\n        if(ans < l * r)\\n            ans = l * r;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long int ll;\\nstd::vector<int> manacher(std::string& s){\\n  std::vector<int> R(s.size());\\n  int i = 0, j = 0;\\n  while (i < s.size()) {\\n    while (i-j >= 0 && i+j < s.size() && s[i-j] == s[i+j]) ++j;\\n    R[i] = j;\\n    int k = 1;\\n    while (i-k >= 0 && k+R[i-k] < j) R[i+k] = R[i-k], ++k;\\n    i += k; j -= k;\\n  }\\n  return std::move(R);\\n}\\n\\n  vector<int> maxlength(string &s){\\n    vector<int> center_l = manacher(s);\\n    vector<int> ans(s.size());\\n    int num = 1;\\n    int maxv = 1;\\n    for(int i=0;i<s.size()-1;i++){\\n        int len = 2 * (center_l[i] - 1) + 1;\\n        int loc = center_l[i] - 1;\\n        ans[i+loc] = max(ans[i+loc], len);\\n    }\\n    int tmp = 0;\\n    for(int i=0;i<s.size();i++){\\n        if(tmp < ans[i])\\n            tmp = ans[i];\\n        ans[i] = tmp;\\n    }\\n    int cnt = ans[s.size()-1];\\n    for(int i=s.size()-2;i>=0;i--){\\n        if(ans[i] < cnt)\\n            cnt = cnt - 2;\\n        ans[i] = cnt;\\n    }\\n    return std::move(ans);\\n  }\\n    \\n  long long maxProduct(string s) {\\n    vector<int> left = maxlength(s);\\n    reverse(s.begin(), s.end());\\n    vector<int> right = maxlength(s);\\n    ll ans = 0;\\n    for(int i=0;i<s.size()-1;i++){\\n        ll l = left[i];\\n        ll r = right[s.size() - i -2];\\n        if(ans < l * r)\\n            ans = l * r;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394034,
                "title": "c-1960-maximum-product-of-the-length-of-two-palindromic-substrings",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.size(), center = 0, right = 0; \\n        vector<int> hlen(n, 0), prefix(n, 0), suffix(n, 0); \\n        for (int i = 0; i < n; ++i) {\\n            if (i < right) hlen[i] = min(right - i, hlen[2*center - i]); \\n            while (0 <= i-1-hlen[i] && i+1+hlen[i] < n && s[i-1-hlen[i]] == s[i+1+hlen[i]]) ++hlen[i]; \\n            if (right < i + hlen[i]) {\\n                center = i; \\n                right = i + hlen[i]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i] + 1); \\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i] + 1); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[n-1-i] = max(prefix[n-1-i], prefix[n-i]-2); \\n            suffix[i] = max(suffix[i], suffix[i-1]-2); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[i] = max(prefix[i-1], prefix[i]); \\n            suffix[n-1-i] = max(suffix[n-1-i], suffix[n-i]); \\n        }\\n        \\n        long long ans = 0ll; \\n        for (int i = 1; i < n; ++i) ans = max(ans, (long long) prefix[i-1] * suffix[i]); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.size(), center = 0, right = 0; \\n        vector<int> hlen(n, 0), prefix(n, 0), suffix(n, 0); \\n        for (int i = 0; i < n; ++i) {\\n            if (i < right) hlen[i] = min(right - i, hlen[2*center - i]); \\n            while (0 <= i-1-hlen[i] && i+1+hlen[i] < n && s[i-1-hlen[i]] == s[i+1+hlen[i]]) ++hlen[i]; \\n            if (right < i + hlen[i]) {\\n                center = i; \\n                right = i + hlen[i]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i] + 1); \\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i] + 1); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[n-1-i] = max(prefix[n-1-i], prefix[n-i]-2); \\n            suffix[i] = max(suffix[i], suffix[i-1]-2); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[i] = max(prefix[i-1], prefix[i]); \\n            suffix[n-1-i] = max(suffix[n-1-i], suffix[n-i]); \\n        }\\n        \\n        long long ans = 0ll; \\n        for (int i = 1; i < n; ++i) ans = max(ans, (long long) prefix[i-1] * suffix[i]); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391003,
                "title": "c-o-n-manacher-s-algorithm",
                "content": "```csharp\\npublic int[] helper(string s)\\n{\\n\\t// Manacher\\'s Algorithm\\n\\tint[] d = new int[s.Length];\\n\\tint left = 0, right = -1;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tint k = (i > right) ? 1 : Math.Min(d[left + right - i], right - i + 1);\\n\\t\\twhile (0 <= i - k && i + k < s.Length && s[i - k] == s[i + k])\\n\\t\\t{\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\n\\t\\td[i] = k;\\n\\t\\tk--;\\n\\t\\tif (i + k > right)\\n\\t\\t{\\n\\t\\t\\tleft = i - k;\\n\\t\\t\\tright = i + k;\\n\\t\\t}\\n\\t}\\n\\n\\t// Find max range for given element and find max palindrome upto i\\n\\tint[] maxRange = new int[s.Length];\\n\\tint n = s.Length;\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmaxRange[i - d[i] + 1] = i;\\n\\t}\\n\\n\\tint max = 0;\\n\\tint[] maxL = new int[n];\\n\\tArray.Fill(maxL, 1);\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmax = Math.Max(maxRange[i], max);\\n\\t\\tmaxL[i] = Math.Max((max - i) * 2 + 1, maxL[i]);\\n\\t}\\n\\n\\tfor (int i = n - 2; i >= 0; i--)\\n\\t{\\n\\t\\tmaxL[i] = Math.Max(maxL[i + 1], maxL[i]);\\n\\t}\\n\\n\\treturn maxL;\\n}\\n\\npublic long MaxProduct(string s)\\n{\\n\\tint[] left = helper(s);\\n\\tint[] right = helper(new string(s.Reverse().ToArray()));\\n\\n\\tlong result = 0L;\\n\\tfor (int i = 1; i < s.Length; i++)\\n\\t{\\n\\t\\tresult = Math.Max(result, 1L * left[i] * right[s.Length - i]);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] helper(string s)\\n{\\n\\t// Manacher\\'s Algorithm\\n\\tint[] d = new int[s.Length];\\n\\tint left = 0, right = -1;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tint k = (i > right) ? 1 : Math.Min(d[left + right - i], right - i + 1);\\n\\t\\twhile (0 <= i - k && i + k < s.Length && s[i - k] == s[i + k])\\n\\t\\t{\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\n\\t\\td[i] = k;\\n\\t\\tk--;\\n\\t\\tif (i + k > right)\\n\\t\\t{\\n\\t\\t\\tleft = i - k;\\n\\t\\t\\tright = i + k;\\n\\t\\t}\\n\\t}\\n\\n\\t// Find max range for given element and find max palindrome upto i\\n\\tint[] maxRange = new int[s.Length];\\n\\tint n = s.Length;\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmaxRange[i - d[i] + 1] = i;\\n\\t}\\n\\n\\tint max = 0;\\n\\tint[] maxL = new int[n];\\n\\tArray.Fill(maxL, 1);\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmax = Math.Max(maxRange[i], max);\\n\\t\\tmaxL[i] = Math.Max((max - i) * 2 + 1, maxL[i]);\\n\\t}\\n\\n\\tfor (int i = n - 2; i >= 0; i--)\\n\\t{\\n\\t\\tmaxL[i] = Math.Max(maxL[i + 1], maxL[i]);\\n\\t}\\n\\n\\treturn maxL;\\n}\\n\\npublic long MaxProduct(string s)\\n{\\n\\tint[] left = helper(s);\\n\\tint[] right = helper(new string(s.Reverse().ToArray()));\\n\\n\\tlong result = 0L;\\n\\tfor (int i = 1; i < s.Length; i++)\\n\\t{\\n\\t\\tresult = Math.Max(result, 1L * left[i] * right[s.Length - i]);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389963,
                "title": "rolling-hash-preprocessing-and-binary-search-at-each-position-o-n-log-n",
                "content": "```\\ntypedef long long ll;\\nll H = 1000000007;\\n\\n\\nclass RollingHash {\\npublic:\\n    RollingHash(const string& s) {\\n        int n = s.length();\\n        pre.resize(n + 1);\\n        for (int i = 0; i < n; i++) {\\n            pre[i + 1] = (pre[i] * 26 + s[i]) % H;\\n        }\\n        b.resize(n + 1);\\n        b[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            b[i] = (b[i - 1] * 26) % H;\\n        }\\n    }\\n\\n    // [start, limit)\\n    ll Query(int start, int limit) const {\\n        int len = limit - start;\\n        ll res = (pre[limit] - pre[start] * b[len]) % H;\\n        if (res < 0) res += H;\\n        return res;\\n    }\\n    \\n    private:\\n    vector<ll> pre;\\n    vector<ll> b;\\n};\\n\\nint FindMaxPalLen(int i, int n, const RollingHash& left_rolling, const RollingHash& right_rolling) {\\n    int l = 1;\\n    int r = min<int>(i + 1, n - i);\\n    while (l <= r) {\\n        int m = (l + r) / 2;\\n        ll h1 = left_rolling.Query(i, i + m);\\n        ll h2 = right_rolling.Query(n - 1 - i, n - 1 - i + m);\\n        if (h1 == h2) {\\n            l = m + 1;\\n        } else {\\n            r = m - 1;\\n        }\\n    }\\n    return r;\\n}\\n\\nvector<int> PrefixMaxPalLen(const vector<int>& v) {\\n    int n = v.size();\\n    vector<int> res(n, 1);\\n    for (int i = 0; i < n; i++) {\\n        int& tar = res[i + v[i] - 1];\\n        tar = max(tar, v[i] * 2 - 1);\\n    }\\n    for (int i = 1; i < n; i++) {\\n        res[i] = max(res[i - 1], res[i]);\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n        res[i] = max(res[i], res[i + 1] - 2);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        RollingHash left_rolling(s);\\n\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        RollingHash right_rolling(r);\\n        \\n        vector<int> g(n);\\n        for (int i = 0; i < n; i++) {\\n            g[i] = FindMaxPalLen(i, n, left_rolling, right_rolling);\\n        }\\n        \\n        auto vl = PrefixMaxPalLen(g);\\n\\n        vector<int> gr = g;\\n        reverse(gr.begin(), gr.end());\\n        auto vr = PrefixMaxPalLen(gr);\\n\\n        ll res = 0;\\n        for (int i = 1; i < n; i++) {\\n            ll t = vl[i - 1];\\n            t *= vr[n - i - 1];\\n            res = max(res, t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nll H = 1000000007;\\n\\n\\nclass RollingHash {\\npublic:\\n    RollingHash(const string& s) {\\n        int n = s.length();\\n        pre.resize(n + 1);\\n        for (int i = 0; i < n; i++) {\\n            pre[i + 1] = (pre[i] * 26 + s[i]) % H;\\n        }\\n        b.resize(n + 1);\\n        b[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            b[i] = (b[i - 1] * 26) % H;\\n        }\\n    }\\n\\n    // [start, limit)\\n    ll Query(int start, int limit) const {\\n        int len = limit - start;\\n        ll res = (pre[limit] - pre[start] * b[len]) % H;\\n        if (res < 0) res += H;\\n        return res;\\n    }\\n    \\n    private:\\n    vector<ll> pre;\\n    vector<ll> b;\\n};\\n\\nint FindMaxPalLen(int i, int n, const RollingHash& left_rolling, const RollingHash& right_rolling) {\\n    int l = 1;\\n    int r = min<int>(i + 1, n - i);\\n    while (l <= r) {\\n        int m = (l + r) / 2;\\n        ll h1 = left_rolling.Query(i, i + m);\\n        ll h2 = right_rolling.Query(n - 1 - i, n - 1 - i + m);\\n        if (h1 == h2) {\\n            l = m + 1;\\n        } else {\\n            r = m - 1;\\n        }\\n    }\\n    return r;\\n}\\n\\nvector<int> PrefixMaxPalLen(const vector<int>& v) {\\n    int n = v.size();\\n    vector<int> res(n, 1);\\n    for (int i = 0; i < n; i++) {\\n        int& tar = res[i + v[i] - 1];\\n        tar = max(tar, v[i] * 2 - 1);\\n    }\\n    for (int i = 1; i < n; i++) {\\n        res[i] = max(res[i - 1], res[i]);\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n        res[i] = max(res[i], res[i + 1] - 2);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        RollingHash left_rolling(s);\\n\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        RollingHash right_rolling(r);\\n        \\n        vector<int> g(n);\\n        for (int i = 0; i < n; i++) {\\n            g[i] = FindMaxPalLen(i, n, left_rolling, right_rolling);\\n        }\\n        \\n        auto vl = PrefixMaxPalLen(g);\\n\\n        vector<int> gr = g;\\n        reverse(gr.begin(), gr.end());\\n        auto vr = PrefixMaxPalLen(gr);\\n\\n        ll res = 0;\\n        for (int i = 1; i < n; i++) {\\n            ll t = vl[i - 1];\\n            t *= vr[n - i - 1];\\n            res = max(res, t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389276,
                "title": "c-57-60",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n    \\n     int n=s.length();\\n       \\n      vector<int> d1(n);\\n       for (int i = 0, l = 0, r = -1; i < n; i++) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            k++;\\n        }\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n           \\n           \\n    }\\n\\n       \\n        vector<int>right(n,0);\\n        vector<int>left(n,0);\\n       \\n        for(int i=n-1;i>=0;i--){\\n            right[i-d1[i]+1]=max(2*d1[i]-1,right[i-d1[i]+1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            left[i+d1[i]-1]=max(2*d1[i]-1,left[i+d1[i]-1]);\\n        }\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i],right[i+1]);\\n        }\\n        int i=0;\\n       long long  int ans=0;\\n        while(i<n){\\n            \\n            long long int x=d1[i];\\n            while(x){\\n                if(i-x>=0){\\n                ans=max(ans,left[i-x]*1ll*(2*1ll*x-1ll));\\n                }\\n                if(i+x<n){\\n                ans=max(ans,right[i+x]*1ll*(2*1ll*x-1ll));\\n                }\\n                x--;\\n            }\\n            i+=d1[i];\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n    \\n     int n=s.length();\\n       \\n      vector<int> d1(n);\\n       for (int i = 0, l = 0, r = -1; i < n; i++) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            k++;\\n        }\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n           \\n           \\n    }\\n\\n       \\n        vector<int>right(n,0);\\n        vector<int>left(n,0);\\n       \\n        for(int i=n-1;i>=0;i--){\\n            right[i-d1[i]+1]=max(2*d1[i]-1,right[i-d1[i]+1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            left[i+d1[i]-1]=max(2*d1[i]-1,left[i+d1[i]-1]);\\n        }\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i],right[i+1]);\\n        }\\n        int i=0;\\n       long long  int ans=0;\\n        while(i<n){\\n            \\n            long long int x=d1[i];\\n            while(x){\\n                if(i-x>=0){\\n                ans=max(ans,left[i-x]*1ll*(2*1ll*x-1ll));\\n                }\\n                if(i+x<n){\\n                ans=max(ans,right[i+x]*1ll*(2*1ll*x-1ll));\\n                }\\n                x--;\\n            }\\n            i+=d1[i];\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886037,
                "title": "o-n-manacher-dp-easy-to-understand-link-to-manacher-blog",
                "content": "Before checking out the solution please check out this blog(https://cp-algorithms.com/string/manacher.html#implementation-of-manachers-algorithm)for manacher algorithm.\\nJust used manacher to find odd palindromes and then use dp to store the length of palindrome and compute the value of ans at each step.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxProduct(string str) {\\n        int n = str.length();\\n        ll ans = 1;\\n\\n        str = \"!\" + str + \"?\";\\n        vector<ll > p(n + 2, 1);\\n        vector<ll > dp(n + 1, 0);\\n        dp[2] = 1;\\n        ll l = 1; ll r = 1;\\n        for(ll i = 1; i <= n; i++)\\n        {\\n            p[i] = max(0LL, min(r - i, p[l + (r - i)]));\\n            while(str[i - p[i]] == str[i + p[i]])\\n            {\\n                p[i]++;\\n                dp[i + p[i] - 1] = max(dp[i + p[i] - 1], (2 * p[i] - 1));\\n                ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            }\\n            ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            dp[i] = max(dp[i], dp[i - 1]);\\n            if(i + p[i] > r){r = i + p[i], l = i - p[i];}\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxProduct(string str) {\\n        int n = str.length();\\n        ll ans = 1;\\n\\n        str = \"!\" + str + \"?\";\\n        vector<ll > p(n + 2, 1);\\n        vector<ll > dp(n + 1, 0);\\n        dp[2] = 1;\\n        ll l = 1; ll r = 1;\\n        for(ll i = 1; i <= n; i++)\\n        {\\n            p[i] = max(0LL, min(r - i, p[l + (r - i)]));\\n            while(str[i - p[i]] == str[i + p[i]])\\n            {\\n                p[i]++;\\n                dp[i + p[i] - 1] = max(dp[i + p[i] - 1], (2 * p[i] - 1));\\n                ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            }\\n            ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            dp[i] = max(dp[i], dp[i - 1]);\\n            if(i + p[i] > r){r = i + p[i], l = i - p[i];}\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808911,
                "title": "manachers-s-algo-beats-90-time",
                "content": "# Complexity\\n- Time complexity:\\n4 * O(N)\\n\\n- Space complexity:\\n3 * O(N)\\n\\n# Code\\n```\\nclass Solution {\\n  public long maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }\\n\\n    long[] starts = new long[s.length()];\\n    long[] ends = new long[s.length()];\\n    long[] lps = new long[s.length()];\\n    Arrays.fill(starts, 1);\\n    Arrays.fill(ends, 1);\\n    int center = 0, r = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      int cl = i - 1;\\n      int cr = i + 1;\\n      if (i != center && i < r) {\\n        int mirrEl = center - (i - center);\\n        if (lps[mirrEl] < r - i) {\\n          lps[i] = lps[mirrEl];\\n          starts[i - (int)lps[i]] = Math.max(starts[i - (int)lps[i]], 2 * lps[i] + 1);\\n          continue;\\n        }\\n\\n        cl = 2 * i  - r - 1;\\n        cr = r + 1;\\n        lps[i] = r - i;\\n        starts[cl + 1] = Math.max(starts[cl + 1], 2 * lps[i] + 1);\\n      }\\n\\n      center = i;\\n      while (cl >= 0 && cr < s.length() &&\\n        s.charAt(cl) == s.charAt(cr)) {\\n        lps[i]++;\\n        starts[cl] = 2 * lps[i] + 1;\\n        ends[cr] = 2 * lps[i] + 1;\\n        cl--;\\n        cr++;\\n      }\\n      \\n      r = cr - 1;\\n    }\\n\\n    long maxProd = 1;\\n    for (int i = 1; i < s.length(); i++) {\\n      if (starts[i - 1] > 1 && starts[i] == 1) {\\n        starts[i] = starts[i - 1] - 2;\\n      }\\n\\n      ends[i] = Math.max(ends[i - 1], ends[i]);\\n    }\\n\\n    for (int j = s.length() - 2; j >= 0; j--) {\\n      starts[j] = Math.max(starts[j + 1], starts[j]);\\n      maxProd = Math.max(maxProd, ends[j] * starts[j + 1]);\\n    }\\n\\n    return maxProd;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }\\n\\n    long[] starts = new long[s.length()];\\n    long[] ends = new long[s.length()];\\n    long[] lps = new long[s.length()];\\n    Arrays.fill(starts, 1);\\n    Arrays.fill(ends, 1);\\n    int center = 0, r = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      int cl = i - 1;\\n      int cr = i + 1;\\n      if (i != center && i < r) {\\n        int mirrEl = center - (i - center);\\n        if (lps[mirrEl] < r - i) {\\n          lps[i] = lps[mirrEl];\\n          starts[i - (int)lps[i]] = Math.max(starts[i - (int)lps[i]], 2 * lps[i] + 1);\\n          continue;\\n        }\\n\\n        cl = 2 * i  - r - 1;\\n        cr = r + 1;\\n        lps[i] = r - i;\\n        starts[cl + 1] = Math.max(starts[cl + 1], 2 * lps[i] + 1);\\n      }\\n\\n      center = i;\\n      while (cl >= 0 && cr < s.length() &&\\n        s.charAt(cl) == s.charAt(cr)) {\\n        lps[i]++;\\n        starts[cl] = 2 * lps[i] + 1;\\n        ends[cr] = 2 * lps[i] + 1;\\n        cl--;\\n        cr++;\\n      }\\n      \\n      r = cr - 1;\\n    }\\n\\n    long maxProd = 1;\\n    for (int i = 1; i < s.length(); i++) {\\n      if (starts[i - 1] > 1 && starts[i] == 1) {\\n        starts[i] = starts[i - 1] - 2;\\n      }\\n\\n      ends[i] = Math.max(ends[i - 1], ends[i]);\\n    }\\n\\n    for (int j = s.length() - 2; j >= 0; j--) {\\n      starts[j] = Math.max(starts[j + 1], starts[j]);\\n      maxProd = Math.max(maxProd, ends[j] * starts[j + 1]);\\n    }\\n\\n    return maxProd;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776217,
                "title": "lines-sweep-on-largest-pall-from-center",
                "content": "# Intuition\\nyou must be clear with the concept that we can check weather string is pallindrome or not by matching string\\'s hash and it\\'s reverse hash. After then we can use computation of largest pallindrome possible from any index as center to get desired solution \\n\\n# Approach\\nfirst find hashes for string and it\\'s reverse, such that we can find hash of any substring in O(1) and hence check for pallindrome of some substring becomes O(1). \\n    After then find largest pallindrome that is possible taking every index as center, this can be optimized using binary search. \\n    Now we are required to find largest pallindrome possible for some prefix starting at i , and for some suffix starting from i, this is required to make computation of product by considering each breaking point (i,i+1)th indexes. \\n    These computations are performed using something like line sweep which can be easily understood by implementation, basically idea is to remove elements from our set when they have gone out of bound, and use elements in our set to make computation. \\n    After then we can find largest pallindromic string possible in some prefix i/suffix i (not necessarily ending at i), that will make product computation faster as shown in implemenation \\n\\n# Complexity\\n- Time complexity:\\nNlogN\\n\\n- Space complexity:\\nN\\n\\n# Code\\n```\\n#define ll long long\\nclass Hashing{\\n    int prime = 35, MOD = 1e9+7; \\n    vector<ll> power, left, right;\\n    long long lhash(int l, int r){\\n        return (left[r+1] - (left[l]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    long long rhash(int l, int r){\\n        return (right[l] - (right[r+1]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    public: \\n    bool isPalindrome(int l, int r){\\n        return lhash(l,r) == rhash(l,r);\\n    }\\n    Hashing(string &s): power(s.length()+1,1),left(s.length()+1),right(s.length()+1){\\n        int n = s.length();\\n        for(int i=1;i<n;i+=1) power[i] = (power[i-1]*prime)%MOD; \\n        left[0] = right[n] = 1; \\n        for(int i=0; i<n; i++){\\n            left[i+1] = (prime*left[i] + s[i] - \\'a\\')%MOD;\\n        }\\n        for(int i=n-1;i>=0;i-=1){\\n            right[i] = (right[i+1]*prime + s[i] - \\'a\\')%MOD; \\n        }\\n    }\\n}; \\nint search(Hashing &hash,string &s,int i){\\n    // find index after which increasing length will result in non pall string\\n    int left = 0,right = s.length(); \\n    while(left < right){\\n        int mid = (left + right+1)/2; \\n        if(i-mid >=0 and i+mid < s.length() and hash.isPalindrome(i-mid,i + mid)){\\n            // then try to increase it further \\n            left = mid; \\n        }\\n        else{\\n            right = mid-1; \\n        }\\n    }\\n    return left;  \\n}\\nvector<int> findSuffix(vector<int> &centers){\\n    int n = centers.size(); \\n    vector<int> left(n); \\n    set<pair<int,int> > end; \\n    set<int> center; \\n    for(int i=0;i<n;i+=1){\\n        // insertion time \\n        end.insert({i + centers[i],i}); \\n        center.insert(i); \\n        // removal time \\n        while(end.begin()->first < i) center.erase(end.begin()->second),end.erase(end.begin()); \\n\\n        // value finding time \\n        int minLeftCenter = *center.begin(); \\n        left[i] = 2*(i - minLeftCenter) + 1; \\n\\n        // one of important step \\n        if(i) left[i] = max(left[i],left[i-1]); \\n    }\\n    return left; \\n}\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(); \\n        Hashing hash(s);  // creates hash of string and reverseString then tells weather l,r is pall or not\\n        vector<int> centers(n,1);\\n        for(int i=0;i<n;i+=1) centers[i] = search(hash,s,i);\\n        vector<int> left = findSuffix(centers); \\n        reverse(centers.begin(),centers.end()); \\n        vector<int> right = findSuffix(centers); \\n        reverse(right.begin(),right.end());\\n        ll ans =0 ; \\n        for(int i=0;i<n-1;i+=1){\\n            ans = max(ans,left[i]*1ll*right[i+1]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Hashing{\\n    int prime = 35, MOD = 1e9+7; \\n    vector<ll> power, left, right;\\n    long long lhash(int l, int r){\\n        return (left[r+1] - (left[l]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    long long rhash(int l, int r){\\n        return (right[l] - (right[r+1]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    public: \\n    bool isPalindrome(int l, int r){\\n        return lhash(l,r) == rhash(l,r);\\n    }\\n    Hashing(string &s): power(s.length()+1,1),left(s.length()+1),right(s.length()+1){\\n        int n = s.length();\\n        for(int i=1;i<n;i+=1) power[i] = (power[i-1]*prime)%MOD; \\n        left[0] = right[n] = 1; \\n        for(int i=0; i<n; i++){\\n            left[i+1] = (prime*left[i] + s[i] - \\'a\\')%MOD;\\n        }\\n        for(int i=n-1;i>=0;i-=1){\\n            right[i] = (right[i+1]*prime + s[i] - \\'a\\')%MOD; \\n        }\\n    }\\n}; \\nint search(Hashing &hash,string &s,int i){\\n    // find index after which increasing length will result in non pall string\\n    int left = 0,right = s.length(); \\n    while(left < right){\\n        int mid = (left + right+1)/2; \\n        if(i-mid >=0 and i+mid < s.length() and hash.isPalindrome(i-mid,i + mid)){\\n            // then try to increase it further \\n            left = mid; \\n        }\\n        else{\\n            right = mid-1; \\n        }\\n    }\\n    return left;  \\n}\\nvector<int> findSuffix(vector<int> &centers){\\n    int n = centers.size(); \\n    vector<int> left(n); \\n    set<pair<int,int> > end; \\n    set<int> center; \\n    for(int i=0;i<n;i+=1){\\n        // insertion time \\n        end.insert({i + centers[i],i}); \\n        center.insert(i); \\n        // removal time \\n        while(end.begin()->first < i) center.erase(end.begin()->second),end.erase(end.begin()); \\n\\n        // value finding time \\n        int minLeftCenter = *center.begin(); \\n        left[i] = 2*(i - minLeftCenter) + 1; \\n\\n        // one of important step \\n        if(i) left[i] = max(left[i],left[i-1]); \\n    }\\n    return left; \\n}\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(); \\n        Hashing hash(s);  // creates hash of string and reverseString then tells weather l,r is pall or not\\n        vector<int> centers(n,1);\\n        for(int i=0;i<n;i+=1) centers[i] = search(hash,s,i);\\n        vector<int> left = findSuffix(centers); \\n        reverse(centers.begin(),centers.end()); \\n        vector<int> right = findSuffix(centers); \\n        reverse(right.begin(),right.end());\\n        ll ans =0 ; \\n        for(int i=0;i<n-1;i+=1){\\n            ans = max(ans,left[i]*1ll*right[i+1]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721119,
                "title": "c-manacher-s-algorithm-easy-to-understand-well-documented",
                "content": "# Intuition\\nUse Recursion and DP will still be too slow to solve the question.\\n\\nInstead, use Manacher\\'s algorithm to solve this.\\nManacher\\'s algorithm finds the odd palindrome length on different s[i]\\n\\nAnd then we can calculate the max palindrome len when cutting the string on different s[i].\\n\\n# Approach\\n1. Find all odd palindrome on different s[i]\\n2. Calculate all the max palindrome len on different cut on the left\\n3. Calculate all the max palindrome len on different cut on the right\\n4. For each cut i, times the max len on both side\\n5. Return the max product\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n``` C++\\nclass Solution {\\npublic:\\n\\n    long long maxProduct(string s) {\\n        vector<int> result = getOddPalindromeManacher(s, 0, s.size()-1);\\n        vector<int> left_result = maxLeftOnDifferentCut(result);\\n        vector<int> right_result = maxRightOnDifferentCut(result);\\n\\n        long long max_product = 0;\\n        for(int i=0; i<s.size()-1; i++){\\n            long long product = (long long)left_result[i] * right_result[i+1];\\n            if(product>max_product)\\n                max_product = product;\\n        }\\n        return max_product;\\n    }\\n\\n    vector<int> getOddPalindromeManacher(string& s, int f, int t){\\n        \\n        vector<int> result(s.size(), 1);\\n\\n        int previous_center = -1;\\n        int previous_left = -1;\\n        int previous_right = -1;\\n        for(int i=f; i<=t; i++){\\n            int temp_l = i;\\n            int temp_r = i;\\n            if(previous_right > i){\\n                int mirror_i = previous_center - (i-previous_center);\\n                int mirror_len = result[mirror_i];\\n                int mirror_left = mirror_i - mirror_len/2;\\n                if(mirror_left > previous_left){\\n                    result[i] = mirror_len;\\n                    continue;\\n                }\\n                temp_r = previous_right;\\n                temp_l = i - (previous_right - i);\\n            }\\n\\n            auto [l, r] = getPalindromeRange(s, f, t, i, temp_l, temp_r);\\n            previous_center = i;\\n            previous_left = l;\\n            previous_right = r;\\n            result[i] = r-l+1;\\n\\n        }\\n        return result;\\n    }\\n\\n    inline tuple<int, int> getPalindromeRange(string& s, int f, int t, int i, int l, int r){\\n        l--; r++;\\n\\n        while(l>=f && r<=t){\\n            if(s[l]!=s[r])\\n                break;\\n\\n            l--; r++;\\n        }\\n\\n        l++; r--;\\n        return {l, r};\\n    }\\n\\n    vector<int> maxLeftOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the left on different cut\\n        left_result[i] = the max palindrome len when cutting the array into [0, i] (i, result.size()-1] two slices\\n                         the max_len on the [0, i] side\\n\\n        left_result[i] means the max palindrome len on the left side when s[i] is included in the left side\\n        */\\n        vector<int> left_result = vector<int>(result.size());\\n\\n        left_result[0] = 1;\\n        int limit = 1;\\n        int max_len = 1;\\n        for (int center = 0; center < left_result.size(); center++) {\\n            int most_right = center + ( result[center]-1 ) / 2;\\n\\n            while (limit <= most_right) {\\n                int len = ( limit - center ) * 2 + 1;\\n                if(len>max_len)\\n                    max_len = len;\\n                left_result[limit++] = max_len;\\n            }\\n        }\\n        return left_result;\\n    }\\n\\n    vector<int> maxRightOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the right on different cut\\n        right_result[i] = the max palindrome len when cutting the array into [0, i) [i, result.size()-1] two slices\\n                          the max_len on the [i, result.size()-1] side\\n        \\n        right_result[i] means the max palindrome len on the right side when s[i] is included in the right side\\n        */\\n        vector<int> right_result = vector<int>(result.size());\\n\\n        right_result[result.size()-1] = 1;\\n        int limit = result.size()-2;\\n        int max_len = 1;\\n        for (int center = right_result.size()-1; center >= 0; center--) {\\n            int most_left = center - ( result[center]-1 ) / 2;\\n            \\n            while (most_left <= limit) {\\n                int len = ( center - limit ) * 2 + 1;\\n                if(len > max_len){\\n                    max_len = len;\\n                }\\n                right_result[limit--] = max_len;\\n            }\\n        }\\n        return right_result;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++\\nclass Solution {\\npublic:\\n\\n    long long maxProduct(string s) {\\n        vector<int> result = getOddPalindromeManacher(s, 0, s.size()-1);\\n        vector<int> left_result = maxLeftOnDifferentCut(result);\\n        vector<int> right_result = maxRightOnDifferentCut(result);\\n\\n        long long max_product = 0;\\n        for(int i=0; i<s.size()-1; i++){\\n            long long product = (long long)left_result[i] * right_result[i+1];\\n            if(product>max_product)\\n                max_product = product;\\n        }\\n        return max_product;\\n    }\\n\\n    vector<int> getOddPalindromeManacher(string& s, int f, int t){\\n        \\n        vector<int> result(s.size(), 1);\\n\\n        int previous_center = -1;\\n        int previous_left = -1;\\n        int previous_right = -1;\\n        for(int i=f; i<=t; i++){\\n            int temp_l = i;\\n            int temp_r = i;\\n            if(previous_right > i){\\n                int mirror_i = previous_center - (i-previous_center);\\n                int mirror_len = result[mirror_i];\\n                int mirror_left = mirror_i - mirror_len/2;\\n                if(mirror_left > previous_left){\\n                    result[i] = mirror_len;\\n                    continue;\\n                }\\n                temp_r = previous_right;\\n                temp_l = i - (previous_right - i);\\n            }\\n\\n            auto [l, r] = getPalindromeRange(s, f, t, i, temp_l, temp_r);\\n            previous_center = i;\\n            previous_left = l;\\n            previous_right = r;\\n            result[i] = r-l+1;\\n\\n        }\\n        return result;\\n    }\\n\\n    inline tuple<int, int> getPalindromeRange(string& s, int f, int t, int i, int l, int r){\\n        l--; r++;\\n\\n        while(l>=f && r<=t){\\n            if(s[l]!=s[r])\\n                break;\\n\\n            l--; r++;\\n        }\\n\\n        l++; r--;\\n        return {l, r};\\n    }\\n\\n    vector<int> maxLeftOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the left on different cut\\n        left_result[i] = the max palindrome len when cutting the array into [0, i] (i, result.size()-1] two slices\\n                         the max_len on the [0, i] side\\n\\n        left_result[i] means the max palindrome len on the left side when s[i] is included in the left side\\n        */\\n        vector<int> left_result = vector<int>(result.size());\\n\\n        left_result[0] = 1;\\n        int limit = 1;\\n        int max_len = 1;\\n        for (int center = 0; center < left_result.size(); center++) {\\n            int most_right = center + ( result[center]-1 ) / 2;\\n\\n            while (limit <= most_right) {\\n                int len = ( limit - center ) * 2 + 1;\\n                if(len>max_len)\\n                    max_len = len;\\n                left_result[limit++] = max_len;\\n            }\\n        }\\n        return left_result;\\n    }\\n\\n    vector<int> maxRightOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the right on different cut\\n        right_result[i] = the max palindrome len when cutting the array into [0, i) [i, result.size()-1] two slices\\n                          the max_len on the [i, result.size()-1] side\\n        \\n        right_result[i] means the max palindrome len on the right side when s[i] is included in the right side\\n        */\\n        vector<int> right_result = vector<int>(result.size());\\n\\n        right_result[result.size()-1] = 1;\\n        int limit = result.size()-2;\\n        int max_len = 1;\\n        for (int center = right_result.size()-1; center >= 0; center--) {\\n            int most_left = center - ( result[center]-1 ) / 2;\\n            \\n            while (most_left <= limit) {\\n                int len = ( center - limit ) * 2 + 1;\\n                if(len > max_len){\\n                    max_len = len;\\n                }\\n                right_result[limit--] = max_len;\\n            }\\n        }\\n        return right_result;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669026,
                "title": "rolling-hash-binary-search",
                "content": "We have to do hashing of string and its reverse string so that we can compare two strings by their hash value.\\nIf string and its reverse have same hashed value, then are palindrome.\\nWe will continue expanding from each center to left and right and apply binary search to find maximum length.\\nYou can read about string hashing from here: https://cp-algorithms.com/string/string-hashing.html#search-for-duplicate-strings-in-an-array-of-strings\\n\\nNote: We having followed rolling hash algorithm which itself is deterministic algorithm. \\n\\n**BUT WHO CARES AS LONG AS WE GET AC AND WE DON\\'T WANT TO DEAL WITH GARBAGE ALGORITHM SUCH AS MANACHER WHICH IS NOT INTUITIVE AT ALL.\\nREMEMBER, ANY INTERVIEWER WHO ASKS MANACHER IS PURE EVIL AND DON\\'T WANT YOU IN THEIR COMPANY. **\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    const ll mod=1e9+7;\\n    const ll p=31;\\n    ll n;\\n    \\n    vector<ll> p_pow;\\n    vector<ll> p_inv;\\n    vector<ll> hash,rev_hash;\\n    \\n    \\n    ll fpm(ll x,ll y,ll mod){\\n        ll ans=1;\\n        while(y>0){\\n            if(y&1){\\n                ans=(ans*x)%mod;\\n            }\\n            y>>=1;\\n            x=(x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    ll substr_hash(ll l,ll r,vector<ll> &h){\\n        ll ans=0;\\n        ans+=h[r];\\n        if(l-1>=0){\\n            ans-=h[l-1];\\n        }\\n        if(ans<0){\\n            ans+=mod;\\n        }\\n        ans%=mod;\\n        ans*=p_inv[l];\\n        ans%=mod;\\n        return ans;\\n    }\\n    \\n    // asdsahjkl\\n    // _____\\n    \\n    // lkjhasdsa\\n    //     _____  \\n    \\n    bool pal(ll idx,ll len){\\n        return substr_hash(idx-len,idx,hash)==substr_hash(n-1-idx-len,n-1-idx,rev_hash);\\n    }\\n        \\n    long long maxProduct(string s) {\\n        this->n=s.size();\\n        \\n        p_pow.resize(n);\\n        p_inv.resize(n);\\n        p_pow[0]=1;\\n        p_inv[0]=1;\\n        for(ll i=1;i<n;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%mod;\\n            p_inv[i]=fpm(p_pow[i],mod-2,mod);\\n        }\\n        \\n        hash.resize(n);\\n        hash[0]=(s[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            hash[i]=(hash[i-1]+((s[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        string t=s;\\n        reverse(t.begin(),t.end());\\n        rev_hash.resize(n);\\n        rev_hash[0]=(t[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            rev_hash[i]=(rev_hash[i-1]+((t[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        vector<ll> pref(n,1),suff(n,1);\\n        \\n        for(ll i=0;i<n;i++){\\n            ll l=0, r=min(i,n-i-1);\\n            ll len=0;\\n            while(l<=r){\\n                ll mid=(l+r)/2;\\n                if(pal(i,mid)){\\n                    len=mid;\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n            pref[i+len]=max(pref[i+len],2*len+1);\\n            suff[i-len]=max(suff[i-len],2*len+1);\\n        }\\n        \\n        for(ll i=n-2;i>=0;i--){\\n            pref[i]=max(pref[i],pref[i+1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            suff[i]=max(suff[i],suff[i-1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            pref[i]=max(pref[i],pref[i-1]);\\n        }\\n        for(ll i=n-2;i>=0;i--){\\n            suff[i]=max(suff[i],suff[i+1]);\\n        }\\n        \\n        ll ans=1;\\n        for(ll i=1;i<n;i++){\\n            ans=max(ans,pref[i-1]*suff[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    const ll mod=1e9+7;\\n    const ll p=31;\\n    ll n;\\n    \\n    vector<ll> p_pow;\\n    vector<ll> p_inv;\\n    vector<ll> hash,rev_hash;\\n    \\n    \\n    ll fpm(ll x,ll y,ll mod){\\n        ll ans=1;\\n        while(y>0){\\n            if(y&1){\\n                ans=(ans*x)%mod;\\n            }\\n            y>>=1;\\n            x=(x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    ll substr_hash(ll l,ll r,vector<ll> &h){\\n        ll ans=0;\\n        ans+=h[r];\\n        if(l-1>=0){\\n            ans-=h[l-1];\\n        }\\n        if(ans<0){\\n            ans+=mod;\\n        }\\n        ans%=mod;\\n        ans*=p_inv[l];\\n        ans%=mod;\\n        return ans;\\n    }\\n    \\n    // asdsahjkl\\n    // _____\\n    \\n    // lkjhasdsa\\n    //     _____  \\n    \\n    bool pal(ll idx,ll len){\\n        return substr_hash(idx-len,idx,hash)==substr_hash(n-1-idx-len,n-1-idx,rev_hash);\\n    }\\n        \\n    long long maxProduct(string s) {\\n        this->n=s.size();\\n        \\n        p_pow.resize(n);\\n        p_inv.resize(n);\\n        p_pow[0]=1;\\n        p_inv[0]=1;\\n        for(ll i=1;i<n;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%mod;\\n            p_inv[i]=fpm(p_pow[i],mod-2,mod);\\n        }\\n        \\n        hash.resize(n);\\n        hash[0]=(s[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            hash[i]=(hash[i-1]+((s[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        string t=s;\\n        reverse(t.begin(),t.end());\\n        rev_hash.resize(n);\\n        rev_hash[0]=(t[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            rev_hash[i]=(rev_hash[i-1]+((t[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        vector<ll> pref(n,1),suff(n,1);\\n        \\n        for(ll i=0;i<n;i++){\\n            ll l=0, r=min(i,n-i-1);\\n            ll len=0;\\n            while(l<=r){\\n                ll mid=(l+r)/2;\\n                if(pal(i,mid)){\\n                    len=mid;\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n            pref[i+len]=max(pref[i+len],2*len+1);\\n            suff[i-len]=max(suff[i-len],2*len+1);\\n        }\\n        \\n        for(ll i=n-2;i>=0;i--){\\n            pref[i]=max(pref[i],pref[i+1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            suff[i]=max(suff[i],suff[i-1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            pref[i]=max(pref[i],pref[i-1]);\\n        }\\n        for(ll i=n-2;i>=0;i--){\\n            suff[i]=max(suff[i],suff[i+1]);\\n        }\\n        \\n        ll ans=1;\\n        for(ll i=1;i<n;i++){\\n            ans=max(ans,pref[i-1]*suff[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485021,
                "title": "manchter-algo-c-solution-with-intitution",
                "content": "# Intuition\\n\\nFirst i figure that it is a string question . \\nSo generally people may know only kmp and rabin carp . \\nAfter 20-30 min you may figure that both cannot be used to find palindromes in o(n) ;\\nNow there should another algo , \\nthat is :  manchter algo to find maximum length string centered at i for whole string from (i = 1 to n ) in o(n) time . \\nand the rest is manchter algo theory .\\nYou may refer cp algorithm for this . \\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nTC = o(n) .\\nas outer loop from 1 to n . \\nfor inner while loop . if statement will overcome that \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> manacher_odd(string s ){\\n        int n = s.length();\\n        s = \"^\" + s + \"$\" ; \\n        vector<int> p(n+2 , 1);\\n        vector<int> lr(n+2 , 1 );\\n        int l = 1 , r = 1 ;\\n        for(int i = 1 ; i<= n ; ++i ){\\n        \\n            if( r >= i )p[i] = max(p[i] , min( 2*(r-i) + 1 , p[l+(r-i)] )) ;\\n            int c = (p[i] + 1 ) / 2  ;\\n            while(s[i-c] == s[c+i]){\\n                p[i] += 2 ;\\n                lr[i + c] = p[i] ;\\n                ++c ;\\n            } \\n            --c;\\n            if(i+c > r ){\\n                l = i-c ;\\n                r = i+c ;\\n            }\\n        }\\n        for(int i = 1 ; i<= n ; ++i ){\\n            lr[i] = max( lr[i] , lr[i-1] ) ;\\n        }\\n        return vector<int>(begin(lr) +1 , end(lr) -1) ;\\n    }\\n\\n    long long maxProduct(string s) {\\n        vector<int> pre = manacher_odd(s) ;\\n        reverse(s.begin() , s.end() ) ; \\n        vector<int> suff = manacher_odd(s) ;\\n        reverse(suff.begin() , suff.end() ) ;\\n        int n = pre.size() ;\\n        \\n        long long res = 1 ;\\n        for(int i = 0 ; i< n-1 ; ++i ){\\n            res = max( pre[i] * 1LL * suff[i+1] , res ) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> manacher_odd(string s ){\\n        int n = s.length();\\n        s = \"^\" + s + \"$\" ; \\n        vector<int> p(n+2 , 1);\\n        vector<int> lr(n+2 , 1 );\\n        int l = 1 , r = 1 ;\\n        for(int i = 1 ; i<= n ; ++i ){\\n        \\n            if( r >= i )p[i] = max(p[i] , min( 2*(r-i) + 1 , p[l+(r-i)] )) ;\\n            int c = (p[i] + 1 ) / 2  ;\\n            while(s[i-c] == s[c+i]){\\n                p[i] += 2 ;\\n                lr[i + c] = p[i] ;\\n                ++c ;\\n            } \\n            --c;\\n            if(i+c > r ){\\n                l = i-c ;\\n                r = i+c ;\\n            }\\n        }\\n        for(int i = 1 ; i<= n ; ++i ){\\n            lr[i] = max( lr[i] , lr[i-1] ) ;\\n        }\\n        return vector<int>(begin(lr) +1 , end(lr) -1) ;\\n    }\\n\\n    long long maxProduct(string s) {\\n        vector<int> pre = manacher_odd(s) ;\\n        reverse(s.begin() , s.end() ) ; \\n        vector<int> suff = manacher_odd(s) ;\\n        reverse(suff.begin() , suff.end() ) ;\\n        int n = pre.size() ;\\n        \\n        long long res = 1 ;\\n        for(int i = 0 ; i< n-1 ; ++i ){\\n            res = max( pre[i] * 1LL * suff[i+1] , res ) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450051,
                "title": "find-the-maximum-product-of-two-non-intersecting-palindromic-substrings-in-javascript",
                "content": "# Intuition\\nThe code uses dynamic programming to solve the problem of finding the maximum product of the lengths of two non-intersecting palindromic substrings of odd length in a given string.\\n\\nThe approach is to first calculate the longest palindrome centered at each index of the string using Manacher\\'s algorithm. This is done by maintaining two pointers c and r that keep track of the center and right boundary of the palindrome, respectively. For each index i, we check if it is within the current palindrome (i.e., i <= r). If it is, we can take advantage of the palindrome\\'s symmetry to determine the length of the palindrome centered at i. Otherwise, we start a new palindrome centered at i and expand it until it can no longer be extended.\\n\\nOnce we have computed the length of the longest palindrome centered at each index, we can use this information to calculate the length of the longest palindrome to the left and right of each index. This is done by iterating through the string and keeping track of the maximum length of palindrome seen so far to the left and right of each index.\\n\\nFinally, we iterate through the string and calculate the product of the lengths of the two non-intersecting palindromic substrings of odd length that can be formed using the palindromes to the left and right of each index. We keep track of the maximum product seen so far and return it as the result.\\n\\n# Approach\\nThe approach used in the code is to find all the palindromic substrings in the given string and then choose two non-intersecting palindromic substrings of odd length such that their product of lengths is maximized.\\n\\nThe algorithm uses Manacher\\'s algorithm to find all palindromic substrings in the given string. Manacher\\'s algorithm is a linear time algorithm that finds all palindromic substrings in a given string.\\n\\nThe algorithm uses three arrays to keep track of information about each character in the string:\\n\\n1. dp[i]: the length of the longest palindromic substring centered at i.\\n\\n2. before[i]: the length of the longest palindromic substring to the left of i.\\n\\n3. after[i]: the length of the longest palindromic substring to the right of i.\\n\\nTo find the palindromic substrings, the algorithm iterates through the string and uses two pointers, p and q, to expand around each character in the string. It checks if the characters at positions p and q are equal, and if they are, it updates the before and after arrays accordingly. It also updates the dp array to keep track of the longest palindromic substring centered at each character.\\n\\nOnce the algorithm has found all the palindromic substrings in the string, it iterates through the string again and computes the product of the lengths of the two non-intersecting palindromic substrings of odd length that have the maximum product. It does this by computing the maximum product for each position in the string and keeping track of the maximum product seen so far.\\n\\nFinally, the algorithm returns the maximum product of the lengths of the two non-intersecting palindromic substrings of odd length.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Title: Maximum Product of the Length of Two Palindromic Substrings\\n * Description: You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\\n * Author: Hasibul Islam\\n * Date: 24/04/2023\\n */\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction maxProduct(s) {\\n    let n = s.length;\\n\\n    let dp = new Array(n).fill(0);\\n    let before = new Array(n).fill(0);\\n    let after = new Array(n).fill(0);\\n\\n    let c = -1;\\n    let r = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        let k = i <= r ? Math.min(dp[2 * c - i], r - i) : 0;\\n        let p = i - k;\\n        let q = i + k;\\n\\n        while (p >= 0 && q < n && s[p] === s[q]) {\\n            before[q] = Math.max(before[q], q - p + 1);\\n            after[p] = Math.max(after[p], q - p + 1);\\n            p--;\\n            q++;\\n        }\\n\\n        dp[i] = q - i - 1;\\n\\n        if (q - 1 > r) {\\n            c = i;\\n            r = q - 1;\\n        }\\n    }\\n\\n    for (let i = 1; i < n; i++) {\\n        before[i] = Math.max(before[i - 1], before[i]);\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        after[i] = Math.max(after[i + 1], after[i]);\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 1; i < n; i++) {\\n        result = Math.max(result, before[i - 1] * after[i]);\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Title: Maximum Product of the Length of Two Palindromic Substrings\\n * Description: You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\\n * Author: Hasibul Islam\\n * Date: 24/04/2023\\n */\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction maxProduct(s) {\\n    let n = s.length;\\n\\n    let dp = new Array(n).fill(0);\\n    let before = new Array(n).fill(0);\\n    let after = new Array(n).fill(0);\\n\\n    let c = -1;\\n    let r = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        let k = i <= r ? Math.min(dp[2 * c - i], r - i) : 0;\\n        let p = i - k;\\n        let q = i + k;\\n\\n        while (p >= 0 && q < n && s[p] === s[q]) {\\n            before[q] = Math.max(before[q], q - p + 1);\\n            after[p] = Math.max(after[p], q - p + 1);\\n            p--;\\n            q++;\\n        }\\n\\n        dp[i] = q - i - 1;\\n\\n        if (q - 1 > r) {\\n            c = i;\\n            r = q - 1;\\n        }\\n    }\\n\\n    for (let i = 1; i < n; i++) {\\n        before[i] = Math.max(before[i - 1], before[i]);\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        after[i] = Math.max(after[i + 1], after[i]);\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 1; i < n; i++) {\\n        result = Math.max(result, before[i - 1] * after[i]);\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442147,
                "title": "python-simple-manacher-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n\\n        dp, before, after = [0]*n, [0]*n, [0]*n\\n\\n        c, r = -1, -1\\n\\n        for i in range(n):\\n            k = min(dp[2*c-i],r-i) if i<=r else 0\\n            p, q = i-k, i+k\\n\\n            while p>=0 and q<n and s[p] == s[q]:\\n                before[q] = max(before[q],q-p+1)\\n                after[p] = max(after[p],q-p+1)\\n                p -= 1\\n                q += 1\\n\\n            dp[i] = q-i-1\\n\\n            if q-1 > r: c, r = i, q-1\\n\\n        for i in range(1,n):\\n            before[i] = max(before[i-1],before[i])\\n\\n        for i in range(n-2,-1,-1):\\n            after[i] = max(after[i+1],after[i])\\n\\n        return max([before[i-1]*after[i] for i in range(1,n)])\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n\\n        dp, before, after = [0]*n, [0]*n, [0]*n\\n\\n        c, r = -1, -1\\n\\n        for i in range(n):\\n            k = min(dp[2*c-i],r-i) if i<=r else 0\\n            p, q = i-k, i+k\\n\\n            while p>=0 and q<n and s[p] == s[q]:\\n                before[q] = max(before[q],q-p+1)\\n                after[p] = max(after[p],q-p+1)\\n                p -= 1\\n                q += 1\\n\\n            dp[i] = q-i-1\\n\\n            if q-1 > r: c, r = i, q-1\\n\\n        for i in range(1,n):\\n            before[i] = max(before[i-1],before[i])\\n\\n        for i in range(n-2,-1,-1):\\n            after[i] = max(after[i+1],after[i])\\n\\n        return max([before[i-1]*after[i] for i in range(1,n)])\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357650,
                "title": "c-manacher-s-prefix-max-array",
                "content": "# Approach\\nFirst we need to find Longest Palindromic Substring using Manacher\\'s.\\n\\nWhen expanding palindroms in Manacher\\'s, we also update `L` and `R`\\n- `L[i]`: the max length of palindrom that ends at `i`\\n- `R[i]`: the max length of palindrom that starts at `i`\\n\\nThen we compute a prefix for `R` from right to left, and try to combine it with `L` to find the answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxProduct(string s0) {\\n      int n = s0.size();\\n      string s(n*2+1, \\'-\\');\\n      for (int i = 0; i < n; ++i) s[2*i+1] = s0[i];\\n      vector<int> DP(s.size(), 0), L(n, 0), R(n, 0);\\n      auto update = [&](int i, int len) {\\n        int j = (i-1)/2, h = len/2;\\n        int l = j-h, r = j+h;\\n        if (s[i] != \\'-\\') L[r] = max(L[r], len), R[l] = max(R[l], len);\\n        DP[i] = len;\\n      };\\n      for (int i = 0, r = 0, c = 0; i < s.size(); ++i) {\\n        auto& len = DP[i];\\n        if (i < r) update(i, min(DP[2*c-i], r-i));\\n        while (i+len+1 < s.size() && i-len-1 >= 0 && s[i+len+1] == s[i-len-1]) {\\n          update(i, len+1);\\n        }\\n        if (i+len > r) c = i, r = i+len;\\n      }\\n      for (int i = R.size()-2; i >= 0; --i) {\\n        R[i] = max(R[i], R[i+1]);\\n      }\\n      ll res = 0;\\n      for (int i = 1; i < n; ++i) {\\n        res = max(res, (ll)L[i-1]*R[i]);\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxProduct(string s0) {\\n      int n = s0.size();\\n      string s(n*2+1, \\'-\\');\\n      for (int i = 0; i < n; ++i) s[2*i+1] = s0[i];\\n      vector<int> DP(s.size(), 0), L(n, 0), R(n, 0);\\n      auto update = [&](int i, int len) {\\n        int j = (i-1)/2, h = len/2;\\n        int l = j-h, r = j+h;\\n        if (s[i] != \\'-\\') L[r] = max(L[r], len), R[l] = max(R[l], len);\\n        DP[i] = len;\\n      };\\n      for (int i = 0, r = 0, c = 0; i < s.size(); ++i) {\\n        auto& len = DP[i];\\n        if (i < r) update(i, min(DP[2*c-i], r-i));\\n        while (i+len+1 < s.size() && i-len-1 >= 0 && s[i+len+1] == s[i-len-1]) {\\n          update(i, len+1);\\n        }\\n        if (i+len > r) c = i, r = i+len;\\n      }\\n      for (int i = R.size()-2; i >= 0; --i) {\\n        R[i] = max(R[i], R[i+1]);\\n      }\\n      ll res = 0;\\n      for (int i = 1; i < n; ++i) {\\n        res = max(res, (ll)L[i-1]*R[i]);\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141405,
                "title": "python-manacher",
                "content": "```\\n    def maxProduct(self, s: str) -> int:\\n        dp, before, after = [0] * len(s), [0] * len(s), [0] * len(s)\\n        c, r = -1, -1\\n        for i in range(len(s)):\\n            k = min(dp[2 * c - i], r - i) if i <= r else 0\\n            p, q = i - k, i + k\\n            while p >= 0 and q < len(s) and s[p] == s[q]:\\n                before[q] = max(before[q], q - p + 1)\\n                after[p] = max(after[p], q - p + 1)\\n                p -= 1; q += 1\\n            dp[i] = q - i - 1\\n            if q - 1 > r: c, r = i, q - 1\\n        for i in range(1, len(s)): before[i] = max(before[i - 1], before[i])\\n        for i in range(len(s) - 2, -1, -1): after[i] = max(after[i + 1], after[i])\\n        return max(before[i - 1] * after[i] for i in range(1, len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProduct(self, s: str) -> int:\\n        dp, before, after = [0] * len(s), [0] * len(s), [0] * len(s)\\n        c, r = -1, -1\\n        for i in range(len(s)):\\n            k = min(dp[2 * c - i], r - i) if i <= r else 0\\n            p, q = i - k, i + k\\n            while p >= 0 and q < len(s) and s[p] == s[q]:\\n                before[q] = max(before[q], q - p + 1)\\n                after[p] = max(after[p], q - p + 1)\\n                p -= 1; q += 1\\n            dp[i] = q - i - 1\\n            if q - 1 > r: c, r = i, q - 1\\n        for i in range(1, len(s)): before[i] = max(before[i - 1], before[i])\\n        for i in range(len(s) - 2, -1, -1): after[i] = max(after[i + 1], after[i])\\n        return max(before[i - 1] * after[i] for i in range(1, len(s)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3099551,
                "title": "premium-limited-explained-solution",
                "content": "\\n```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854992,
                "title": "o-n-log-n-rolling-hash-binary-search-dp-w-priority-queue",
                "content": "The idea is that we treat every `i` as the center of the palindrome and do a binary search on the side length of the palindrome. To make comparing the sides of the palindrome O(1), we precompute the rolling hash for the string in both directions (because palindrome mirrors each other at the center). We store for every `i` the width of the side length of the longest palindrome when `i` is the center.\\n\\nAfter that, we\\'d like a DP to tell us the longest palindrome to either the left or the right of the current position, so that in the end we can do `left_dp[i] * right_dp[i + 1]`. To do this, we\\'ll take `left_dp` as an example. We want to keep track of the **leftmost center of the palindrome that can reach the current position**, because that\\'d give us the longest palindrome that can reach the current position. Let\\'s keep track of that via a priority queue, and we\\'ll pop off the palindromes that can\\'t reach here. What if the longest palindrome to the left isn\\'t directly reaching the current `i`? well we\\'ll just take the maximum answer so far from the left, via `left_dp[i - 1]`. This way, the longest palindrome will be carried over and updated at a certain point if necessary. Then, we use this logic for `right_dp` too.\\n\\n---\\n\\n```cpp\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\n\\ntemplate <int MOD = 1\\'000\\'000\\'007> struct mod_int {\\n  long long v{};\\n  mod_int() = default;\\n  mod_int(long long vx) : v((vx + MOD) % MOD) {}\\n  mod_int &operator=(long long vx) {\\n    v = (vx + MOD) % MOD;\\n    return *this;\\n  }\\n  friend mod_int operator+(const mod_int &a, const mod_int &b) { return (a.v + b.v) % MOD; }\\n  friend mod_int operator+(long long a, const mod_int &b) { return ((a + MOD) % MOD + b.v) % MOD; }\\n  friend mod_int operator+(const mod_int &a, long long b) { return (a.v + (b + MOD) % MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, const mod_int &b) { return (a.v - b.v + MOD) % MOD; }\\n  friend mod_int operator-(long long a, const mod_int &b) { return ((a + MOD) % MOD - b.v + MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, long long b) { return (a.v - (b + MOD) % MOD + MOD) % MOD; }\\n  friend mod_int operator*(const mod_int &a, const mod_int &b) { return (a.v * b.v) % MOD; }\\n  friend mod_int operator*(long long a, const mod_int &b) { return (((a + MOD) % MOD) * b.v) % MOD; }\\n  friend mod_int operator*(const mod_int &a, long long b) { return (a.v * ((b + MOD) % MOD)) % MOD; }\\n  friend bool operator==(const mod_int &a, const mod_int &b) { return a.v == b.v; }\\n  friend bool operator!=(const mod_int &a, const mod_int &b) { return a.v != b.v; }\\n};\\n\\nclass Solution {\\npublic:\\n  long long maxProduct(string s) {\\n    int n = s.size();\\n    constexpr int P1 = 31, P2 = 33, M1 = 1e9 + 7, M2 = 1e9 + 9;\\n\\n    using num1 = mod_int<M1>;\\n    using num2 = mod_int<M2>;\\n\\n    vector<pair<num1, num2>> powers(n + 1, {1, 1});\\n    for (int i = 1; i <= n; i++) {\\n      powers[i].first = powers[i - 1].first * P1;\\n      powers[i].second = powers[i - 1].second * P2;\\n    }\\n\\n    vector<pair<num1, num2>> fwd_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      fwd_hash[i + 1].first = fwd_hash[i].first + (s[i] - \\'a\\' + 1) * powers[i].first;\\n      fwd_hash[i + 1].second = fwd_hash[i].second + (s[i] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<pair<num1, num2>> back_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      back_hash[i + 1].first = back_hash[i].first + (s[n - i - 1] - \\'a\\' + 1) * powers[i].first;\\n      back_hash[i + 1].second = back_hash[i].second + (s[n - i - 1] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<int> center_width(n);\\n    for (int i = 0; i < n; i++) {\\n      int l = 1, r = min(n - i, n - (n - i - 1)), res = 1;\\n      while (l <= r) {\\n        int m = (l + r) / 2;\\n\\n        num1 fwd_hash1 = fwd_hash[i + m].first - fwd_hash[i].first;\\n        num2 fwd_hash2 = fwd_hash[i + m].second - fwd_hash[i].second;\\n        num1 back_hash1 = back_hash[n - i - 1 + m].first - back_hash[n - i - 1].first;\\n        num2 back_hash2 = back_hash[n - i - 1 + m].second - back_hash[n - i - 1].second;\\n\\n        num1 fwd_hash1_exp = 1;\\n        num2 fwd_hash2_exp = 1;\\n        num1 back_hash1_exp = 1;\\n        num2 back_hash2_exp = 1;\\n        int dist1 = i + 1, dist2 = n - i;\\n        if (dist1 > dist2) {\\n          back_hash1_exp = powers[dist1 - dist2].first;\\n          back_hash2_exp = powers[dist1 - dist2].second;\\n        } else if (dist1 < dist2) {\\n          fwd_hash1_exp = powers[dist2 - dist1].first;\\n          fwd_hash2_exp = powers[dist2 - dist1].second;\\n        }\\n\\n        if (fwd_hash1 * fwd_hash1_exp == back_hash1 * back_hash1_exp &&\\n            fwd_hash2 * fwd_hash2_exp == back_hash2 * back_hash2_exp) {\\n          l = m + 1;\\n          res = m;\\n        } else {\\n          r = m - 1;\\n        }\\n      }\\n      center_width[i] = res;\\n    }\\n\\n    using T = pair<int, int>; // [center, end]\\n\\n    priority_queue<T, vector<T>, greater<T>> min_centers;\\n    vector<int> left_dp(n + 1, 1);\\n    for (int i = 0; i < n; i++) {\\n      left_dp[i + 1] = left_dp[i];\\n\\n      min_centers.emplace(i, i + center_width[i] - 1);\\n      while (!min_centers.empty() && min_centers.top().second < i) {\\n        min_centers.pop();\\n      }\\n      if (!min_centers.empty()) {\\n        amax(left_dp[i + 1], (i - min_centers.top().first) * 2 + 1);\\n      }\\n    }\\n\\n    priority_queue<T> max_centers;\\n    vector<int> right_dp(n + 1, 1);\\n    for (int i = 0, j = n - 1; i < n; i++, j--) {\\n      right_dp[i + 1] = right_dp[i];\\n\\n      max_centers.emplace(j, j - center_width[j] + 1);\\n      while (!max_centers.empty() && max_centers.top().second > j) {\\n        max_centers.pop();\\n      }\\n      if (!max_centers.empty()) {\\n        amax(right_dp[i + 1], (max_centers.top().first - j) * 2 + 1);\\n      }\\n    }\\n\\n    long long ans = 1;\\n    for (int i = 1, j = n - 1; i < n; i++, j--) {\\n      amax(ans, (long long)left_dp[i] * (long long)right_dp[j]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Rolling Hash",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\n\\ntemplate <int MOD = 1\\'000\\'000\\'007> struct mod_int {\\n  long long v{};\\n  mod_int() = default;\\n  mod_int(long long vx) : v((vx + MOD) % MOD) {}\\n  mod_int &operator=(long long vx) {\\n    v = (vx + MOD) % MOD;\\n    return *this;\\n  }\\n  friend mod_int operator+(const mod_int &a, const mod_int &b) { return (a.v + b.v) % MOD; }\\n  friend mod_int operator+(long long a, const mod_int &b) { return ((a + MOD) % MOD + b.v) % MOD; }\\n  friend mod_int operator+(const mod_int &a, long long b) { return (a.v + (b + MOD) % MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, const mod_int &b) { return (a.v - b.v + MOD) % MOD; }\\n  friend mod_int operator-(long long a, const mod_int &b) { return ((a + MOD) % MOD - b.v + MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, long long b) { return (a.v - (b + MOD) % MOD + MOD) % MOD; }\\n  friend mod_int operator*(const mod_int &a, const mod_int &b) { return (a.v * b.v) % MOD; }\\n  friend mod_int operator*(long long a, const mod_int &b) { return (((a + MOD) % MOD) * b.v) % MOD; }\\n  friend mod_int operator*(const mod_int &a, long long b) { return (a.v * ((b + MOD) % MOD)) % MOD; }\\n  friend bool operator==(const mod_int &a, const mod_int &b) { return a.v == b.v; }\\n  friend bool operator!=(const mod_int &a, const mod_int &b) { return a.v != b.v; }\\n};\\n\\nclass Solution {\\npublic:\\n  long long maxProduct(string s) {\\n    int n = s.size();\\n    constexpr int P1 = 31, P2 = 33, M1 = 1e9 + 7, M2 = 1e9 + 9;\\n\\n    using num1 = mod_int<M1>;\\n    using num2 = mod_int<M2>;\\n\\n    vector<pair<num1, num2>> powers(n + 1, {1, 1});\\n    for (int i = 1; i <= n; i++) {\\n      powers[i].first = powers[i - 1].first * P1;\\n      powers[i].second = powers[i - 1].second * P2;\\n    }\\n\\n    vector<pair<num1, num2>> fwd_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      fwd_hash[i + 1].first = fwd_hash[i].first + (s[i] - \\'a\\' + 1) * powers[i].first;\\n      fwd_hash[i + 1].second = fwd_hash[i].second + (s[i] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<pair<num1, num2>> back_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      back_hash[i + 1].first = back_hash[i].first + (s[n - i - 1] - \\'a\\' + 1) * powers[i].first;\\n      back_hash[i + 1].second = back_hash[i].second + (s[n - i - 1] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<int> center_width(n);\\n    for (int i = 0; i < n; i++) {\\n      int l = 1, r = min(n - i, n - (n - i - 1)), res = 1;\\n      while (l <= r) {\\n        int m = (l + r) / 2;\\n\\n        num1 fwd_hash1 = fwd_hash[i + m].first - fwd_hash[i].first;\\n        num2 fwd_hash2 = fwd_hash[i + m].second - fwd_hash[i].second;\\n        num1 back_hash1 = back_hash[n - i - 1 + m].first - back_hash[n - i - 1].first;\\n        num2 back_hash2 = back_hash[n - i - 1 + m].second - back_hash[n - i - 1].second;\\n\\n        num1 fwd_hash1_exp = 1;\\n        num2 fwd_hash2_exp = 1;\\n        num1 back_hash1_exp = 1;\\n        num2 back_hash2_exp = 1;\\n        int dist1 = i + 1, dist2 = n - i;\\n        if (dist1 > dist2) {\\n          back_hash1_exp = powers[dist1 - dist2].first;\\n          back_hash2_exp = powers[dist1 - dist2].second;\\n        } else if (dist1 < dist2) {\\n          fwd_hash1_exp = powers[dist2 - dist1].first;\\n          fwd_hash2_exp = powers[dist2 - dist1].second;\\n        }\\n\\n        if (fwd_hash1 * fwd_hash1_exp == back_hash1 * back_hash1_exp &&\\n            fwd_hash2 * fwd_hash2_exp == back_hash2 * back_hash2_exp) {\\n          l = m + 1;\\n          res = m;\\n        } else {\\n          r = m - 1;\\n        }\\n      }\\n      center_width[i] = res;\\n    }\\n\\n    using T = pair<int, int>; // [center, end]\\n\\n    priority_queue<T, vector<T>, greater<T>> min_centers;\\n    vector<int> left_dp(n + 1, 1);\\n    for (int i = 0; i < n; i++) {\\n      left_dp[i + 1] = left_dp[i];\\n\\n      min_centers.emplace(i, i + center_width[i] - 1);\\n      while (!min_centers.empty() && min_centers.top().second < i) {\\n        min_centers.pop();\\n      }\\n      if (!min_centers.empty()) {\\n        amax(left_dp[i + 1], (i - min_centers.top().first) * 2 + 1);\\n      }\\n    }\\n\\n    priority_queue<T> max_centers;\\n    vector<int> right_dp(n + 1, 1);\\n    for (int i = 0, j = n - 1; i < n; i++, j--) {\\n      right_dp[i + 1] = right_dp[i];\\n\\n      max_centers.emplace(j, j - center_width[j] + 1);\\n      while (!max_centers.empty() && max_centers.top().second > j) {\\n        max_centers.pop();\\n      }\\n      if (!max_centers.empty()) {\\n        amax(right_dp[i + 1], (max_centers.top().first - j) * 2 + 1);\\n      }\\n    }\\n\\n    long long ans = 1;\\n    for (int i = 1, j = n - 1; i < n; i++, j--) {\\n      amax(ans, (long long)left_dp[i] * (long long)right_dp[j]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783052,
                "title": "c-manacher",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        auto t = s;\\n        reverse(t.begin(), t.end());\\n        auto v =prefixLen(s), u = prefixLen(t);\\n        long long res = 0;\\n        for(int i=0, n = s.size();i<n-1;i++){\\n            res = max(res, (long long)v[i] * u[n-i-2]);\\n        }\\n        return res;\\n    }\\n    \\n    //https://cp-algorithms.com/string/manacher.html#solution\\n    vector<int> manacher_odd(string s) {\\n        int n = s.size();\\n        s = \"$\" + s + \"^\";\\n        vector<int> p(n + 2);\\n        int l = 1, r = 1;\\n        for(int i = 1; i <= n; i++) {\\n            p[i] = max(0, min(r - i, p[l + (r - i)]));\\n            while(s[i - p[i]] == s[i + p[i]]) {\\n                p[i]++;\\n            }\\n            if(i + p[i] > r) {\\n                l = i - p[i], r = i + p[i];\\n            }\\n        }\\n        return vector<int>(begin(p) + 1, end(p) - 1);\\n    }\\n    \\n    vector<int> prefixLen(const string& s){\\n        int maxLen = 0;\\n        auto manacher = manacher_odd(s);\\n        const int n = s.size();\\n        vector<int> res(n, 1);\\n        for(int i=0, j=0;i<n;i++){\\n            int len = manacher[i]-1;\\n            for(; j <= i+len; j++){\\n                maxLen = max(maxLen, 1+2*(j-i));\\n                res[j] = maxLen;\\n            } \\n        }\\n        return res;\\n    }   \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        auto t = s;\\n        reverse(t.begin(), t.end());\\n        auto v =prefixLen(s), u = prefixLen(t);\\n        long long res = 0;\\n        for(int i=0, n = s.size();i<n-1;i++){\\n            res = max(res, (long long)v[i] * u[n-i-2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2664337,
                "title": "rust-solution-using-manacher-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt needs something no worse than O(NLogN) since N could be as  big as 100000. Manacher algorithm is a good candidate since it calculates all odd length palindromic substrings in O(N) time.      \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce we the length vector of palindromic substrings  calculated using Manacher algorithm, we can use VecDeque to calculate the max lengths of odd length palindromic substrings for two groups [..i] &  [i+1..].\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn max_product(s: String) -> i64 {\\n        let data = Self::manacher_odd(&s);\\n        //for d in v { println![\"{}\", d]; } \\n        \\n        let n = data.len();\\n        let mut q = VecDeque::<(i32, i32)>::new();\\n        let mut right= vec![1; n];\\n\\n        for i in (0..n).rev() {\\n            while let Some(a) = q.front() {\\n                if a.0 - a.1 <= i as i32 { break }\\n                q.pop_front();\\n            }\\n            \\n            if let Some(a) = q.front() {\\n                right[i] += (a.0 - i as i32) * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n        }\\n\\n        while q.is_empty() == false { q.pop_front(); } \\n        let (mut ret, mut mx_left) = (1, 1);\\n        for i in 0..n - 1 {\\n            let mut temp = 1;\\n\\n            while let Some(a) = q.front() {\\n                if a.0 + a.1 >= i as i32 { break }\\n                q.pop_front();\\n            }\\n\\n            if let Some(a) = q.front() {\\n                temp += (i as i32 - a.0) as i64 * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n\\n            mx_left = mx_left.max(temp);\\n            ret = ret.max(mx_left * right[i + 1] as i64);\\n        }\\n\\n        ret\\n    }\\n\\n    // Adapted from:   https://cp-algorithms.com/string/manacher.html\\n    fn manacher_odd(s: &String) -> Vec<i32> {\\n        let n = s.len();\\n        let s = String::from(\"$\") + s + &String::from(\"^\");\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut p = vec![0; n + 2];\\n        \\n        let (mut l, mut r) = (1, 1);\\n\\n        for i in 1..=n {\\n            p[i] = i32::max(0, i32::min(r - i as i32, p[(l + (r - i as i32)) as usize]));\\n            while (s[i - p[i] as usize] == s[i + p[i] as usize]) {\\n                p[i] += 1;\\n            }\\n\\n            if i as i32 + p[i] > r {\\n                l = i as i32 - p[i];\\n                r = i as i32 + p[i];\\n            }\\n        }\\n\\n         p.pop();\\n         p.remove(0);         \\n         p\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn max_product(s: String) -> i64 {\\n        let data = Self::manacher_odd(&s);\\n        //for d in v { println![\"{}\", d]; } \\n        \\n        let n = data.len();\\n        let mut q = VecDeque::<(i32, i32)>::new();\\n        let mut right= vec![1; n];\\n\\n        for i in (0..n).rev() {\\n            while let Some(a) = q.front() {\\n                if a.0 - a.1 <= i as i32 { break }\\n                q.pop_front();\\n            }\\n            \\n            if let Some(a) = q.front() {\\n                right[i] += (a.0 - i as i32) * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n        }\\n\\n        while q.is_empty() == false { q.pop_front(); } \\n        let (mut ret, mut mx_left) = (1, 1);\\n        for i in 0..n - 1 {\\n            let mut temp = 1;\\n\\n            while let Some(a) = q.front() {\\n                if a.0 + a.1 >= i as i32 { break }\\n                q.pop_front();\\n            }\\n\\n            if let Some(a) = q.front() {\\n                temp += (i as i32 - a.0) as i64 * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n\\n            mx_left = mx_left.max(temp);\\n            ret = ret.max(mx_left * right[i + 1] as i64);\\n        }\\n\\n        ret\\n    }\\n\\n    // Adapted from:   https://cp-algorithms.com/string/manacher.html\\n    fn manacher_odd(s: &String) -> Vec<i32> {\\n        let n = s.len();\\n        let s = String::from(\"$\") + s + &String::from(\"^\");\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut p = vec![0; n + 2];\\n        \\n        let (mut l, mut r) = (1, 1);\\n\\n        for i in 1..=n {\\n            p[i] = i32::max(0, i32::min(r - i as i32, p[(l + (r - i as i32)) as usize]));\\n            while (s[i - p[i] as usize] == s[i + p[i] as usize]) {\\n                p[i] += 1;\\n            }\\n\\n            if i as i32 + p[i] > r {\\n                l = i as i32 - p[i];\\n                r = i as i32 + p[i];\\n            }\\n        }\\n\\n         p.pop();\\n         p.remove(0);         \\n         p\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2216044,
                "title": "manachers-algo-without-queue-with-explanation",
                "content": "We need to find a place to split the string so that we can use the max lengths of the palindrom of the two substrings to multiply. The manachers algo can give us the longest palindrom at each center location. So the idea becomes how to convert the center to its left and right boundary, then we can scan the boundaries to find the largest palindrom on the left or right of a particular index.\\n\\nAs a starting point, below is the original manachers algo code with some explanation for reference.\\n\\n```\\n    int longestPalindrom(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1);\\n        \\n        int lp = 0;   // the index of the center position of previous longer palindrom, used as mirror\\n\\t\\tint ans = 1;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {                                   // check if a mirrored version exists.\\n                int j = lp - (i - lp);                                // this is the mirror of the current number\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;  // using the portion contained within the longer palindrom\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {                              // try to extend the new palindrom over the longer palindrom\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n\\t\\t\\tans = max(l, ans);\\n        }\\n        return ans;\\n\\t}\\n```\\n\\nNow, we need to add some statements to keep track of the boundaries of the palindroms.\\n\\n```\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1), lb(n,1), rb(n,1); // two more array to keep track of the size at left and right boundaries\\n        \\n        int lp = 0;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {\\n                int j = lp - (i - lp);\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    rb[i+l/2+1] = max(rb[i+l/2+1], l+2);                     // store the size at the right boundary of the palingdrom\\n                    lb[i-l/2-1] = max(lb[i-l/2-1], l+2);                     // now on the left boundary\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n            lb[i-p[i]/2] = max(lb[i-p[i]/2], p[i]);              // in case we dont get to store it during the extending part\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // why do we only fix the left boundaries here? think about it \\n        }\\n\\n\\t\\t// ...\\n\\t\\t// to be continued\\n\\t\\t// ...\\n\\t}\\n```\\n\\nNow, aggregate on the boundaries to get the maxmum on each side of each indices.\\n\\n```\\n        for(int i=1;i<n;i++) rb[i] = max(rb[i],rb[i-1]);  // each position now stores the largest size of palingroms on its left side\\n        for(int i=n-2;i>=0;i--) lb[i] = max(lb[i], lb[i+1]);  // same on the right side\\n```\\n\\nIn the end, get the max products.\\n\\n```\\n        long long product = 0;\\n        for(int i=0;i<n-1;i++) {\\n            product = max(product, (long long)rb[i]*lb[i+1]); // max palindrom to the left of i is rb[i] (inclusive), and\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // max palindrom to the right of i is lb[i+1](exclusive)\\n        }\\n        return product;\\n```\\nPlease vote if you feel this is helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int longestPalindrom(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1);\\n        \\n        int lp = 0;   // the index of the center position of previous longer palindrom, used as mirror\\n\\t\\tint ans = 1;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {                                   // check if a mirrored version exists.\\n                int j = lp - (i - lp);                                // this is the mirror of the current number\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;  // using the portion contained within the longer palindrom\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {                              // try to extend the new palindrom over the longer palindrom\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n\\t\\t\\tans = max(l, ans);\\n        }\\n        return ans;\\n\\t}\\n```\n```\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1), lb(n,1), rb(n,1); // two more array to keep track of the size at left and right boundaries\\n        \\n        int lp = 0;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {\\n                int j = lp - (i - lp);\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    rb[i+l/2+1] = max(rb[i+l/2+1], l+2);                     // store the size at the right boundary of the palingdrom\\n                    lb[i-l/2-1] = max(lb[i-l/2-1], l+2);                     // now on the left boundary\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n            lb[i-p[i]/2] = max(lb[i-p[i]/2], p[i]);              // in case we dont get to store it during the extending part\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // why do we only fix the left boundaries here? think about it \\n        }\\n\\n\\t\\t// ...\\n\\t\\t// to be continued\\n\\t\\t// ...\\n\\t}\\n```\n```\\n        for(int i=1;i<n;i++) rb[i] = max(rb[i],rb[i-1]);  // each position now stores the largest size of palingroms on its left side\\n        for(int i=n-2;i>=0;i--) lb[i] = max(lb[i], lb[i+1]);  // same on the right side\\n```\n```\\n        long long product = 0;\\n        for(int i=0;i<n-1;i++) {\\n            product = max(product, (long long)rb[i]*lb[i+1]); // max palindrom to the left of i is rb[i] (inclusive), and\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // max palindrom to the right of i is lb[i+1](exclusive)\\n        }\\n        return product;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2193011,
                "title": "manacher-algorithm-dp-90-100",
                "content": "```\\nclass Solution {\\n    public long maxProduct(String s) {\\n        return this.maxP(s);\\n    }\\n    int[] left(int[] ps) {\\n        int[] ret = new int[ps.length];\\n        ret[0] = 1;\\n        int j = 1;\\n        for (int i = 0; i < ps.length; i++) {\\n            int r = i + (ps[i]-1)/2;\\n            while (j <= r) {\\n                ret[j] = (j-i)*2+1;\\n                j++;\\n            }\\n        }\\n        return ret;\\n    }\\n    long maxP(String s) {\\n        int[] ps = this.computePalindrome(s);\\n        int[] ls = this.left(ps);\\n        //System.out.println(Arrays.toString(ls));\\n        long c = 0, maxr = 0;\\n        int j = s.length()-1;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            int l = i - (ps[i]-1)/2;\\n            while (j >= l) {\\n                int k = (i - j)*2 + 1;\\n                if (j > 0) {\\n                    maxr = Math.max(maxr, k);\\n                    c = Math.max(c, maxr * ls[j-1]);\\n                }\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n    int[] computePalindrome(String s) {\\n        int j = 0, l = 0, r = 0;\\n        int[] ret = new int[s.length()];\\n        ret[0] = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (i > r) {\\n                j = i; \\n                l=r=i;\\n                while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                    l--; r++;\\n                }\\n                l++; r--;\\n                ret[i] = r -l + 1;\\n            } else {\\n                int k = l + r -i;\\n                if ((ret[k] -1)/2 < (r-i)) {\\n                    ret[i] = ret[k];\\n                } else {\\n                    ret[i] = 1 + 2*(r-i);\\n                    l = i - (r-i);\\n                    r = i + (r-i);\\n                    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                        l--;r++;\\n                    }\\n                    l++; r--;\\n                    ret[i] = r -l +1;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxProduct(String s) {\\n        return this.maxP(s);\\n    }\\n    int[] left(int[] ps) {\\n        int[] ret = new int[ps.length];\\n        ret[0] = 1;\\n        int j = 1;\\n        for (int i = 0; i < ps.length; i++) {\\n            int r = i + (ps[i]-1)/2;\\n            while (j <= r) {\\n                ret[j] = (j-i)*2+1;\\n                j++;\\n            }\\n        }\\n        return ret;\\n    }\\n    long maxP(String s) {\\n        int[] ps = this.computePalindrome(s);\\n        int[] ls = this.left(ps);\\n        //System.out.println(Arrays.toString(ls));\\n        long c = 0, maxr = 0;\\n        int j = s.length()-1;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            int l = i - (ps[i]-1)/2;\\n            while (j >= l) {\\n                int k = (i - j)*2 + 1;\\n                if (j > 0) {\\n                    maxr = Math.max(maxr, k);\\n                    c = Math.max(c, maxr * ls[j-1]);\\n                }\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n    int[] computePalindrome(String s) {\\n        int j = 0, l = 0, r = 0;\\n        int[] ret = new int[s.length()];\\n        ret[0] = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (i > r) {\\n                j = i; \\n                l=r=i;\\n                while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                    l--; r++;\\n                }\\n                l++; r--;\\n                ret[i] = r -l + 1;\\n            } else {\\n                int k = l + r -i;\\n                if ((ret[k] -1)/2 < (r-i)) {\\n                    ret[i] = ret[k];\\n                } else {\\n                    ret[i] = 1 + 2*(r-i);\\n                    l = i - (r-i);\\n                    r = i + (r-i);\\n                    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                        l--;r++;\\n                    }\\n                    l++; r--;\\n                    ret[i] = r -l +1;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863436,
                "title": "incorrected-expected-output",
                "content": "\"rofcjxfkbzcvvlbkgcwtcjctwcgkblvvczbkfxjcfor\" is a of length 43 which is a palendrome but expected output is 41 , any reason why?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1428950,
                "title": "using-manacher-and-queue",
                "content": "```\\nclass Solution {\\n    vector<int> pref, suf, lps;\\n    int sz;\\npublic:\\n    long long maxProduct(string s) {\\n        sz = s.size();\\n        lps.resize(sz); \\n        pref.resize(sz, 1);\\n        suf.resize(sz, 1);\\n        manacher(s);\\n        construct();\\n        \\n        for(int i =1 ; i<sz; i++){\\n            pref[i] = max(pref[i-1], pref[i]);\\n        }\\n        for(int i =sz-2 ; i>-1; i--){\\n            suf[i] = max(suf[i+1], suf[i]);\\n        }\\n        long long ret = 1;\\n        \\n        \\n        for(int i= 0; i< sz-1; i++){\\n            ret = max(ret, 1LL*pref[i]*suf[i+1]);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    void construct(){\\n        queue<int> bag1, bag2;\\n        \\n        for(int i = 0 ;i < sz; i++){\\n            bag1.push(i);\\n            while(bag1.front() + lps[bag1.front()] < i){\\n                bag1.pop();\\n            }\\n            if(i!=0) pref[i] = max(pref[i-1], 2*(i - bag1.front()) + 1); \\n        }\\n        \\n        for(int i = sz-1; i > -1; i--){\\n            bag2.push(i);\\n            while(bag2.front() - lps[bag2.front()] > i){\\n                bag2.pop();\\n            }\\n            if(i!=sz-1) suf[i] = max(suf[i+1], 2*(bag2.front() - i) + 1); \\n        }\\n    }\\n    \\n    \\n    void manacher(string & s){\\n        int center = -1, right  = -1;\\n        for(int i = 0; i<sz; i++){\\n            int d = (i>right? 1:min(lps[2*center - i] + 1, right+1- i));\\n            while(i+d< sz && i-d >-1 && s[i-d] == s[i+d]) d++;\\n            lps[i] = d - 1;\\n            if(i+d-1 > right){\\n                center = i, right = i + d - 1 ;\\n            }  \\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> pref, suf, lps;\\n    int sz;\\npublic:\\n    long long maxProduct(string s) {\\n        sz = s.size();\\n        lps.resize(sz); \\n        pref.resize(sz, 1);\\n        suf.resize(sz, 1);\\n        manacher(s);\\n        construct();\\n        \\n        for(int i =1 ; i<sz; i++){\\n            pref[i] = max(pref[i-1], pref[i]);\\n        }\\n        for(int i =sz-2 ; i>-1; i--){\\n            suf[i] = max(suf[i+1], suf[i]);\\n        }\\n        long long ret = 1;\\n        \\n        \\n        for(int i= 0; i< sz-1; i++){\\n            ret = max(ret, 1LL*pref[i]*suf[i+1]);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    void construct(){\\n        queue<int> bag1, bag2;\\n        \\n        for(int i = 0 ;i < sz; i++){\\n            bag1.push(i);\\n            while(bag1.front() + lps[bag1.front()] < i){\\n                bag1.pop();\\n            }\\n            if(i!=0) pref[i] = max(pref[i-1], 2*(i - bag1.front()) + 1); \\n        }\\n        \\n        for(int i = sz-1; i > -1; i--){\\n            bag2.push(i);\\n            while(bag2.front() - lps[bag2.front()] > i){\\n                bag2.pop();\\n            }\\n            if(i!=sz-1) suf[i] = max(suf[i+1], 2*(bag2.front() - i) + 1); \\n        }\\n    }\\n    \\n    \\n    void manacher(string & s){\\n        int center = -1, right  = -1;\\n        for(int i = 0; i<sz; i++){\\n            int d = (i>right? 1:min(lps[2*center - i] + 1, right+1- i));\\n            while(i+d< sz && i-d >-1 && s[i-d] == s[i+d]) d++;\\n            lps[i] = d - 1;\\n            if(i+d-1 > right){\\n                center = i, right = i + d - 1 ;\\n            }  \\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426256,
                "title": "how-do-you-get-a-length-product-of-45-for-this-input-string",
                "content": "LeetCode has 45 as the answer for this input: \"ggbswiymmlevedhkbdhntnhdbkhdevelmmyiwsbgg\"\\nWhat two odd-length palindrome lengths form that product? I use a brute-force palidrome algoirithm which comes up with only 3 odd-length palidromes that aren\\'t single letter:\\n\\n(center at index, total length)\\n(11,3)\\n(20,41)\\n(29,3)\\n\\nMy algo therefore says the max product is 9\\n",
                "solutionTags": [],
                "code": "LeetCode has 45 as the answer for this input: \"ggbswiymmlevedhkbdhntnhdbkhdevelmmyiwsbgg\"\\nWhat two odd-length palindrome lengths form that product? I use a brute-force palidrome algoirithm which comes up with only 3 odd-length palidromes that aren\\'t single letter:\\n\\n(center at index, total length)\\n(11,3)\\n(20,41)\\n(29,3)\\n\\nMy algo therefore says the max product is 9\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1402462,
                "title": "c-28-ms-faster-than-98-10-5-mb-less-space-than-100",
                "content": "class Solution {\\npublic:\\n    long long maxProduct(string &s) {\\n        \\n        int n = s.size(),c=0,r=0,mx=1,p[n],left[100000]={0};\\n        left[0]=1;\\n        for(int i=0;i<n;i++){\\n            p[i]=1;\\n            if(i<r)\\n                p[i] = min((r-i)*2+1,p[c-(i-c)]);\\n            \\n            int dist=p[i]/2 + 1;\\n            while(i+dist<n && i-dist>=0 && s[i+dist]==s[i-dist])\\n                p[i]+=2, dist++;\\n            \\n            if(i+dist-1>r)\\n                c=i, r= i + dist-1;\\n            for(int val = p[i],x=i+p[i]/2;left[x]==0;x--,val-=2)\\n                left[x]=max(mx,val);\\n            mx = max(mx,p[i]);\\n        }\\n        mx=1;\\n        long long ans = 1;\\n        int lefti = n;\\n        for(int i=n-1;i>=1;i--){\\n            int l, r, x=i-p[i]/2, val=p[i];\\n            \\n            if(i-p[i]/2 <1)\\n                x++,val-=2;\\n\\t\\t\\tr = left[x-1];\\n\\t\\t\\t\\n            for(;x<lefti ; x++,val-=2){\\n                l = r, r = left[x], left[x]=max(mx,val);\\n                ans = max(ans,1ll*l*left[x]);\\n            }\\n            mx = max(mx,p[i]);\\n            lefti = min(lefti,i-p[i]/2);\\n        }\\n        return ans;\\n    }                                               \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxProduct(string &s) {\\n        \\n        int n = s.size(),c=0,r=0,mx=1,p[n],left[100000]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1399400,
                "title": "c-manacher",
                "content": "```\\nclass Solution {\\npublic:\\n\\tlong long maxProduct(string s) {\\n\\t\\tvector<long long> len(s.size());\\n\\t\\tint mx = 0;\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tif (i < mx + len[mx]) {\\n\\t\\t\\t\\tlen[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (i - len[i] >= 0 && i + len[i] < s.size() && s[i - len[i]] == s[i + len[i]]) {\\n\\t\\t\\t\\tlen[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (mx + len[mx] < i + len[i]) {\\n\\t\\t\\t\\tmx = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> left(s.size()) , right(s.size());\\n\\n\\t\\tleft[0] = 1;\\n\\t\\tfor (int i = 1, p = 0; i < s.size(); ++i) {\\n\\t\\t\\twhile (p + len[p] - 1 < i) ++p;\\n\\t\\t\\tleft[i] = max(left[i - 1], 2 * (i - p) + 1);\\n\\t\\t}\\n\\n\\t\\tright[s.size() - 1] = 1;\\n\\t\\tfor (int i = s.size() - 2, p = s.size() - 1; i >= 0; --i) {\\n\\t\\t\\twhile (p - len[p] + 1 > i) --p;\\n\\t\\t\\tright[i] = max(right[i + 1], 2 * (p - i) + 1);\\n\\t\\t}\\n\\n\\t\\tlong long ret = 0;\\n\\t\\tfor (int i = 0; i + 1 < s.size(); ++i)\\n\\t\\t\\tret = max(ret, 1ll * left[i] * right[i + 1]);\\n\\t\\treturn ret;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long maxProduct(string s) {\\n\\t\\tvector<long long> len(s.size());\\n\\t\\tint mx = 0;\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tif (i < mx + len[mx]) {\\n\\t\\t\\t\\tlen[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (i - len[i] >= 0 && i + len[i] < s.size() && s[i - len[i]] == s[i + len[i]]) {\\n\\t\\t\\t\\tlen[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (mx + len[mx] < i + len[i]) {\\n\\t\\t\\t\\tmx = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> left(s.size()) , right(s.size());\\n\\n\\t\\tleft[0] = 1;\\n\\t\\tfor (int i = 1, p = 0; i < s.size(); ++i) {\\n\\t\\t\\twhile (p + len[p] - 1 < i) ++p;\\n\\t\\t\\tleft[i] = max(left[i - 1], 2 * (i - p) + 1);\\n\\t\\t}\\n\\n\\t\\tright[s.size() - 1] = 1;\\n\\t\\tfor (int i = s.size() - 2, p = s.size() - 1; i >= 0; --i) {\\n\\t\\t\\twhile (p - len[p] + 1 > i) --p;\\n\\t\\t\\tright[i] = max(right[i + 1], 2 * (p - i) + 1);\\n\\t\\t}\\n\\n\\t\\tlong long ret = 0;\\n\\t\\tfor (int i = 0; i + 1 < s.size(); ++i)\\n\\t\\t\\tret = max(ret, 1ll * left[i] * right[i + 1]);\\n\\t\\treturn ret;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399080,
                "title": "java-o-n-modified-odd-manacher",
                "content": "Didn\\'t know anything about Manacher algorithm so far.\\nhttps://cp-algorithms.com/string/manacher.html#toc-tgt-6\\n\\n```\\n    public long maxProduct(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        int len = sb.length();\\n        int[] dpl = new int[len];\\n        int[] dpr = new int[len];\\n        modifiedOddManacher(sb.toString(), dpl);\\n        modifiedOddManacher(sb.reverse().toString(), dpr);\\n        long max=1;\\n        for(int i=0;i<len-1;i++)\\n            max=Math.max(max, (1+(dpl[i]-1)*2L)*(1+(dpr[len-(i+1)-1]-1)*2L));\\n        return max;\\n    }\\n    private void modifiedOddManacher(String str, int[] dp){\\n        int len = str.length();\\n        int[] center = new int[len];\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n               while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) {\\n                  dp[i+radius] = radius+1;\\n                  radius++;\\n               }\\n            center[i] = radius--;\\n            if(i+radius>r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n        for(int i=0, max=1;i<len;i++){\\n            max = Math.max(max, dp[i]);\\n            dp[i] = max;\\n        }\\n    }\\n```\\n\\nJust comapare with basic odd Manacher for better understanding.\\n```\\n   private void oddManacher(String str){\\n        int len = str.length();\\n        int[] center = new int[len];\\n\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n            while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) \\n                radius++;\\n\\n            center[i] = radius--;\\n            if(i+radius > r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long maxProduct(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        int len = sb.length();\\n        int[] dpl = new int[len];\\n        int[] dpr = new int[len];\\n        modifiedOddManacher(sb.toString(), dpl);\\n        modifiedOddManacher(sb.reverse().toString(), dpr);\\n        long max=1;\\n        for(int i=0;i<len-1;i++)\\n            max=Math.max(max, (1+(dpl[i]-1)*2L)*(1+(dpr[len-(i+1)-1]-1)*2L));\\n        return max;\\n    }\\n    private void modifiedOddManacher(String str, int[] dp){\\n        int len = str.length();\\n        int[] center = new int[len];\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n               while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) {\\n                  dp[i+radius] = radius+1;\\n                  radius++;\\n               }\\n            center[i] = radius--;\\n            if(i+radius>r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n        for(int i=0, max=1;i<len;i++){\\n            max = Math.max(max, dp[i]);\\n            dp[i] = max;\\n        }\\n    }\\n```\n```\\n   private void oddManacher(String str){\\n        int len = str.length();\\n        int[] center = new int[len];\\n\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n            while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) \\n                radius++;\\n\\n            center[i] = radius--;\\n            if(i+radius > r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1396294,
                "title": "java-dp-bottom-up-easy-to-understand-beats-100",
                "content": "- cost[i][j] denotes the minimum space wasted between index i to j\\n- dp[i][k] denotes the minumum space wasted between index 0 to i with k resizing operations\\n```\\npublic int minSpaceWastedKResizing(int[] nums, int K) {\\n\\tfinal int n = nums.length;\\n\\tint[][] cost = new int[n][n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint max = nums[i];\\n\\t\\tint sum = 0;\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tsum += nums[j];\\n\\t\\t\\tmax = Math.max(max, nums[j]);\\n\\t\\t\\tcost[i][j] = max * (j - i + 1) - sum;\\n\\t\\t}\\n\\t}\\n\\tint[][] dp = new int[n][K+1];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i][0] = cost[0][i];\\n\\t}\\n\\tfor (int k = 1; k <= K; k++) {\\n\\t\\tdp[0][k] = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tdp[i][k] = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tdp[i][k] = Math.min(dp[i][k], dp[j][k-1] + cost[j+1][i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n-1][K];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSpaceWastedKResizing(int[] nums, int K) {\\n\\tfinal int n = nums.length;\\n\\tint[][] cost = new int[n][n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint max = nums[i];\\n\\t\\tint sum = 0;\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tsum += nums[j];\\n\\t\\t\\tmax = Math.max(max, nums[j]);\\n\\t\\t\\tcost[i][j] = max * (j - i + 1) - sum;\\n\\t\\t}\\n\\t}\\n\\tint[][] dp = new int[n][K+1];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i][0] = cost[0][i];\\n\\t}\\n\\tfor (int k = 1; k <= K; k++) {\\n\\t\\tdp[0][k] = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tdp[i][k] = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tdp[i][k] = Math.min(dp[i][k], dp[j][k-1] + cost[j+1][i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n-1][K];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395341,
                "title": "c-kmp-like-without-manacher-o-n-time-o-n-space",
                "content": "1. Let\\'s go left ot right and remember all palindroms ends on position and hold in in allpals = std::vector<std::vector<int>>. So    allpals[5] == {1,3,5} means we have 3 palindroms size 1 (subsbring [5,5]), 3 ([3,5]) and 5 ([1,5])\\n2. allpals[0] == {1}\\n3. On position pos > 1 we could check all palindroms allpals[pos - 1] and for palindrom p_i we check if s[pos] == s[pos - p_i - 1]. This is enough for add new palindrom with len (p_i + 2) to allpals[pos]\\n\\n```\\n\\n....?PPPPPPPPC\\nc - is current position,\\n(P) - is palindrome with len = p_i\\n\\n```\\n4. But this it require O(n* n) mem &time.\\n6.  Lets see closer to all palindroms, end on pos = pos.   \\np_1...p_n\\n```\\nour string\\n............................\\n...........PPPPPPPPP    -first palindrome\\n.............DDDDDDD   -second palindrome\\n...........DDDDDDD..   -second palindrome reverse (because P - is palindrome)\\n```\\n8.    As we see below, d* and D* also palindrome\\n9.    all palindrome which less than d for pos = pos, are alse palindrome for (pos - 2) (in this example.\\n10.    So, we just need take largest palindrome P, and second appropriate (D). and store position, when D is holds. (in this example pos - 2)\\n11.    Idea is the same, as for prefix-function KMP algo or Aho\\u2013Corasick (for backlinks)\\n12. so, we need to store largest palindrom. and link to previous. So, jump to this links we can enumerate all palindroms, ends on position.\\n13. for this task there is smaxforw array for max palindrome, end no far than pos\\n14. This algo works good for odd & even palindroms. (rather than manacher ;)\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        const int nsize = s.size();\\n        \\n        using vi = std::vector<long long>;\\n        \\n        auto make_buf = [&]() {\\n            vi maxforw(nsize, 1);\\n            vi smaxforw(nsize, 1);\\n            vi prevpos(nsize, -1);\\n\\n\\n            maxforw[0] = 1;\\n            smaxforw[0] = 1;\\n            prevpos[0] = -1;\\n\\n            for (int pos = 1; pos < nsize; ++pos) {\\n                int prev = pos - 1;\\n                int curmax = 1;\\n                while (prev >= 0) {\\n                    int prevlen = maxforw[prev];\\n                    int pp = pos - prevlen - 1;\\n                    if (pp >= 0 && s[pos] == s[pp]) {\\n                        curmax = prevlen + 2;\\n                        break;\\n                    }\\n                    prev = prevpos[prev];\\n                }\\n                prevpos[pos] = prev;\\n                maxforw[pos] = curmax;\\n                smaxforw[pos] = std::max(smaxforw[pos - 1], maxforw[pos]);\\n            }\\n            return std::move(smaxforw);\\n        };\\n        \\n        auto&& forw = make_buf();\\n        std::reverse(s.begin(), s.end());\\n        auto&& rev = make_buf();\\n        \\n        long long best = 1;\\n        \\n        for (int pos = 1; pos < nsize; ++pos) {\\n            best = std::max(best, forw[pos - 1] * rev[nsize - 1 - pos]);\\n        }\\n        return best;\\n    }\\n};\\n```\\n\\nalgo need  2 * n memorty. (value + prev position for each posigion)",
                "solutionTags": [],
                "code": "```\\n\\n....?PPPPPPPPC\\nc - is current position,\\n(P) - is palindrome with len = p_i\\n\\n```\n```\\nour string\\n............................\\n...........PPPPPPPPP    -first palindrome\\n.............DDDDDDD   -second palindrome\\n...........DDDDDDD..   -second palindrome reverse (because P - is palindrome)\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        const int nsize = s.size();\\n        \\n        using vi = std::vector<long long>;\\n        \\n        auto make_buf = [&]() {\\n            vi maxforw(nsize, 1);\\n            vi smaxforw(nsize, 1);\\n            vi prevpos(nsize, -1);\\n\\n\\n            maxforw[0] = 1;\\n            smaxforw[0] = 1;\\n            prevpos[0] = -1;\\n\\n            for (int pos = 1; pos < nsize; ++pos) {\\n                int prev = pos - 1;\\n                int curmax = 1;\\n                while (prev >= 0) {\\n                    int prevlen = maxforw[prev];\\n                    int pp = pos - prevlen - 1;\\n                    if (pp >= 0 && s[pos] == s[pp]) {\\n                        curmax = prevlen + 2;\\n                        break;\\n                    }\\n                    prev = prevpos[prev];\\n                }\\n                prevpos[pos] = prev;\\n                maxforw[pos] = curmax;\\n                smaxforw[pos] = std::max(smaxforw[pos - 1], maxforw[pos]);\\n            }\\n            return std::move(smaxforw);\\n        };\\n        \\n        auto&& forw = make_buf();\\n        std::reverse(s.begin(), s.end());\\n        auto&& rev = make_buf();\\n        \\n        long long best = 1;\\n        \\n        for (int pos = 1; pos < nsize; ++pos) {\\n            best = std::max(best, forw[pos - 1] * rev[nsize - 1 - pos]);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391496,
                "title": "rolling-hash-cpp-nlogn-solution",
                "content": "First we find the longest palindrome we can get from each point, for this we can use [Manacher\\'s Algorithm](https://cp-algorithms.com/string/manacher.html) or we can use [polynomial hashing](https://codeforces.com/blog/entry/60445) .\\n\\\\\\nHere we used polynomial hashing with binary search to optimise our palindrome search\\n\\n```\\nvector<long long> pows;\\nlong long hash = 3137;\\nbool done = true;\\nconst int mod = 1e9 + 7;\\nlong long LeftHash[100005], RightHash[100005];\\nvoid init() {\\n    done = false;\\n    pows.resize(100005, 1);\\n    for(int i = 1; i < 100005; i++){\\n        pows[i] = (1LL*pows[i-1]*(::hash)) % mod;\\n    }\\n}\\nlong long HashValue(int ind, int len, long long a[100005]) {\\n    long long retval =  a[ind + len] - a[ind]*pows[len];\\n    retval %= mod;\\n    if(retval < 0) retval += mod;\\n    return retval;\\n}\\n\\nlong long Find_Longest_Palindrome_From_Current_Index(string &str, int i) {\\n    int n = str.length();\\n    int s = 0, e = min(i , n - i - 1);\\n    while(s < e) {\\n        int lens = (s + e + 1) >> 1;\\n        if(HashValue(i - lens, lens, LeftHash) ==  HashValue(n - i - lens - 1, lens, RightHash)) {\\n            s = lens;\\n        } else {\\n            e = lens - 1;\\n        }\\n    }\\n    return s;\\n }\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        if(done) init();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            LeftHash[i+1] = (LeftHash[i]* ::hash + s[i]) % mod;\\n            RightHash[i+1] = (RightHash[i]*::hash + s[n - i - 1]) % mod;\\n        }\\n        vector<long long> left(n, 1), right(n,1);\\n        for(int i = 0; i < n; i++) {\\n            int get =  Find_Longest_Palindrome_From_Current_Index(s,i);\\n            left[i + get] = max<long long>(left[i + get], 2*get + 1);\\n            right[i - get] = max<long long>(right[i - get], 2*get + 1);\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            left[i] = max<long long>(left[i], left[i+1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            right[i] = max<long long>(right[i], right[i-1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            left[i] = max<long long>(left[i-1], left[i]);\\n            right[n-i-1] = max<long long>(right[n-i], right[n-i-1]);\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            ans = max<long long>(ans, left[i-1]*right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> pows;\\nlong long hash = 3137;\\nbool done = true;\\nconst int mod = 1e9 + 7;\\nlong long LeftHash[100005], RightHash[100005];\\nvoid init() {\\n    done = false;\\n    pows.resize(100005, 1);\\n    for(int i = 1; i < 100005; i++){\\n        pows[i] = (1LL*pows[i-1]*(::hash)) % mod;\\n    }\\n}\\nlong long HashValue(int ind, int len, long long a[100005]) {\\n    long long retval =  a[ind + len] - a[ind]*pows[len];\\n    retval %= mod;\\n    if(retval < 0) retval += mod;\\n    return retval;\\n}\\n\\nlong long Find_Longest_Palindrome_From_Current_Index(string &str, int i) {\\n    int n = str.length();\\n    int s = 0, e = min(i , n - i - 1);\\n    while(s < e) {\\n        int lens = (s + e + 1) >> 1;\\n        if(HashValue(i - lens, lens, LeftHash) ==  HashValue(n - i - lens - 1, lens, RightHash)) {\\n            s = lens;\\n        } else {\\n            e = lens - 1;\\n        }\\n    }\\n    return s;\\n }\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        if(done) init();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            LeftHash[i+1] = (LeftHash[i]* ::hash + s[i]) % mod;\\n            RightHash[i+1] = (RightHash[i]*::hash + s[n - i - 1]) % mod;\\n        }\\n        vector<long long> left(n, 1), right(n,1);\\n        for(int i = 0; i < n; i++) {\\n            int get =  Find_Longest_Palindrome_From_Current_Index(s,i);\\n            left[i + get] = max<long long>(left[i + get], 2*get + 1);\\n            right[i - get] = max<long long>(right[i - get], 2*get + 1);\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            left[i] = max<long long>(left[i], left[i+1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            right[i] = max<long long>(right[i], right[i-1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            left[i] = max<long long>(left[i-1], left[i]);\\n            right[n-i-1] = max<long long>(right[n-i], right[n-i-1]);\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            ans = max<long long>(ans, left[i-1]*right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390752,
                "title": "c-manacher-no-queue-o-n",
                "content": "Manacher algorithm with a small patch: every time we find a new palindrome, we record it in two arrays: left and right.\\nleft(x) means there is a palindrome on the left side of x ending at x, right(x) means there is a palindrome on the right side of x.\\nThe arrays hold the radii of the respective palindromes.\\nIf a few palindromes end at the same x, we store the largest radius only.\\n\\nIn the end, we do two passes over the arrays to find for each x the largest palindrome ending at x or before, and starting at x or later.\\n\\nThen we consider all pairs (left(x-1)\\\\*2+1) * (right(x)\\\\*2+1) to find the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(), c = 0, r = 0;\\n        vector<int> rr(n), left(n), right(n);\\n        while(c < n)\\n        {\\n            // grow the palindrome\\n            while(c-(r+1)>=0 && c+(r+1)<n && s[c-(r+1)]==s[c+(r+1)])\\n            {\\n                r++;\\n                // record palindrome radius r ending at c+r and c-r\\n                left [c+r] = max(left [c+r],r);\\n                right[c-r] = max(right[c-r],r);\\n            }\\n\\n            // done at c, move on\\n            int c_old = c, r_old = r;\\n            rr[c++] = r;\\n            r = 0;\\n            \\n            // Manacher\\'s mirror\\n            for(;c-c_old <= r_old && c-c_old <= c_old;c++)\\n            {\\n                int c_mirr = c_old - (c-c_old);\\n                int r_mirr = r_old - (c-c_old);\\n                if(rr[c_mirr]==r_mirr) {r = r_mirr; break;}\\n                rr[c] = min(r_mirr,rr[c_mirr]);\\n                \\n                // record palindrom radius rr[c] ending at c+rr[c], c-rr[c]\\n                left [c+rr[c]] = max(left [c+rr[c]],rr[c]);\\n                right[c-rr[c]] = max(right[c-rr[c]],rr[c]);\\n            }\\n        }\\n        \\n\\t\\t// process the arrays to track the best palindromes found on the left and the right side\\n        int mx = 0; for(int i = 0;   i <  n; i++) left[i]  = max( left [i], mx = max(mx,left [i]) );\\n            mx = 0; for(int i = n-1; i >= 0; i--) right[i] = max( right[i], mx = max(mx,right[i]) );\\n\\n        // consider all left[x-1] * right[x] pairs, but remember to convert radii to lengths\\n        long long o = 0;\\n        for(int i = 1; i < n; i++) o = max(o, (left[i-1]*2+1)*(long long)(right[i]*2+1));\\n        return o;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(), c = 0, r = 0;\\n        vector<int> rr(n), left(n), right(n);\\n        while(c < n)\\n        {\\n            // grow the palindrome\\n            while(c-(r+1)>=0 && c+(r+1)<n && s[c-(r+1)]==s[c+(r+1)])\\n            {\\n                r++;\\n                // record palindrome radius r ending at c+r and c-r\\n                left [c+r] = max(left [c+r],r);\\n                right[c-r] = max(right[c-r],r);\\n            }\\n\\n            // done at c, move on\\n            int c_old = c, r_old = r;\\n            rr[c++] = r;\\n            r = 0;\\n            \\n            // Manacher\\'s mirror\\n            for(;c-c_old <= r_old && c-c_old <= c_old;c++)\\n            {\\n                int c_mirr = c_old - (c-c_old);\\n                int r_mirr = r_old - (c-c_old);\\n                if(rr[c_mirr]==r_mirr) {r = r_mirr; break;}\\n                rr[c] = min(r_mirr,rr[c_mirr]);\\n                \\n                // record palindrom radius rr[c] ending at c+rr[c], c-rr[c]\\n                left [c+rr[c]] = max(left [c+rr[c]],rr[c]);\\n                right[c-rr[c]] = max(right[c-rr[c]],rr[c]);\\n            }\\n        }\\n        \\n\\t\\t// process the arrays to track the best palindromes found on the left and the right side\\n        int mx = 0; for(int i = 0;   i <  n; i++) left[i]  = max( left [i], mx = max(mx,left [i]) );\\n            mx = 0; for(int i = n-1; i >= 0; i--) right[i] = max( right[i], mx = max(mx,right[i]) );\\n\\n        // consider all left[x-1] * right[x] pairs, but remember to convert radii to lengths\\n        long long o = 0;\\n        for(int i = 1; i < n; i++) o = max(o, (left[i-1]*2+1)*(long long)(right[i]*2+1));\\n        return o;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566188,
                "content": [
                    {
                        "username": "megaspazz",
                        "content": "I was unable to come up with any alternatives, and ended up using Manacher\\'s Algorithm, but I had thought that this was typically out of the scope of LeetCode problems.\\n\\nIt is mentioned in [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/solution/), which I\\'d consider to be the most direct application / use of Manacher\\'s Algorithm, but even for that problem, it was optional as an O(N^2) solution was accepted due to the smaller constraints.\\n\\nIn my memory, this is the first problem to actually need Manacher\\'s Algorithm to pass all test cases, but was wondering if this isn\\'t the first one and/or if there were alternate solutions to this problem.\\n\\nHas LeetCode has raised the bar of difficulty on contest problems?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check If String Is a Prefix of Array",
        "question_content": "<p>Given a string <code>s</code> and an array of strings <code>words</code>, determine whether <code>s</code> is a <strong>prefix string</strong> of <code>words</code>.</p>\n\n<p>A string <code>s</code> is a <strong>prefix string</strong> of <code>words</code> if <code>s</code> can be made by concatenating the first <code>k</code> strings in <code>words</code> for some <strong>positive</strong> <code>k</code> no larger than <code>words.length</code>.</p>\n\n<p>Return <code>true</code><em> if </em><code>s</code><em> is a <strong>prefix string</strong> of </em><code>words</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;iloveleetcode&quot;, words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;apples&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\ns can be made by concatenating &quot;i&quot;, &quot;love&quot;, and &quot;leetcode&quot; together.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;iloveleetcode&quot;, words = [&quot;apples&quot;,&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;]\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\nIt is impossible to make s using a prefix of arr.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> and <code>s</code> consist of only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1390325,
                "title": "java-simple-append-and-check-algorithmic-explanation",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**Algorithm:**\\n\\n1.\\tKeep appending the strings in the array 1-by-1.\\n2.\\tIf the appended string matches the given string, return true.\\n3.\\tIf the given string does not contain the appended string, return false.\\n4.\\tIf the loop terminates, return false.\\n\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder res = new StringBuilder (\"\");\\n        for (String word : words) {\\n            res.append (word);\\n            if (s.equals (res.toString()))\\n                return true;\\n            if (s.indexOf (res.toString()) == -1)\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder res = new StringBuilder (\"\");\\n        for (String word : words) {\\n            res.append (word);\\n            if (s.equals (res.toString()))\\n                return true;\\n            if (s.indexOf (res.toString()) == -1)\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390619,
                "title": "tricky-description",
                "content": "I missed few conditions and got 2 WA. Embarassing.\\n\\nSo, first catch is that we need to match the entire string `s`. The second catch is that we cannot stop in the middle of a word, only in between.\\n\\n**C++**\\n```cpp\\nbool isPrefixString(string s, vector<string>& words) {\\n    int i = 0;\\n    for (int j = 0; j < words.size() && i < s.size(); ++j)\\n        for (auto ch : words[j])\\n            if (i == s.size() || s[i++] != ch)\\n                return false;\\n    return i == s.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool isPrefixString(string s, vector<string>& words) {\\n    int i = 0;\\n    for (int j = 0; j < words.size() && i < s.size(); ++j)\\n        for (auto ch : words[j])\\n            if (i == s.size() || s[i++] != ch)\\n                return false;\\n    return i == s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390199,
                "title": "python3-move-along-s",
                "content": "\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        i = 0\\n        for word in words: \\n            if s[i:i+len(word)] != word: return False \\n            i += len(word)\\n            if i == len(s): return True \\n        return False \\n```\\n\\nThe solutions for weekly 255 can be found in this [commit](https://github.com/gaosanyong/leetcode/commit/312849ed66e5ad76fa278cbb34dd57772fb3ceeb).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        i = 0\\n        for word in words: \\n            if s[i:i+len(word)] != word: return False \\n            i += len(word)\\n            if i == len(s): return True \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390270,
                "title": "c-simple",
                "content": "```\\n/*\\n    straight forward, just keep appending the string and \\n    checking at the same time if it matches \\'s\\'\\n\\tWe can break earlier when the length exceeds the length of \\'s\\'. Thanks to @MSR_Yang\\n*/\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string check = \"\";\\n        \\n        for(const string &word : words) {\\n            check += word;\\n            \\n\\t\\t\\tif(check == s)                   return true;\\n\\t\\t\\tif(check.length() >= s.length()) return false;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    straight forward, just keep appending the string and \\n    checking at the same time if it matches \\'s\\'\\n\\tWe can break earlier when the length exceeds the length of \\'s\\'. Thanks to @MSR_Yang\\n*/\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string check = \"\";\\n        \\n        for(const string &word : words) {\\n            check += word;\\n            \\n\\t\\t\\tif(check == s)                   return true;\\n\\t\\t\\tif(check.length() >= s.length()) return false;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390509,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        a = \\'\\'\\n    \\n        for i in words:\\n            \\n            a += i\\n            \\n            if a == s:\\n                return True\\n            if not s.startswith(a):\\n                break\\n                     \\n        return False \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        a = \\'\\'\\n    \\n        for i in words:\\n            \\n            a += i\\n            \\n            if a == s:\\n                return True\\n            if not s.startswith(a):\\n                break\\n                     \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390332,
                "title": "javascript-direct-way-117ms",
                "content": "```\\nconst isPrefixString = (s, w) => {\\n    let tmp = \\'\\';\\n    for (const e of w) {\\n        tmp += e;\\n        if (tmp == s) return true; \\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPrefixString = (s, w) => {\\n    let tmp = \\'\\';\\n    for (const e of w) {\\n        tmp += e;\\n        if (tmp == s) return true; \\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1393474,
                "title": "c-easy-peasy-simple-solution-4-short-lines",
                "content": "Append each word to `res` and check if it equals to s.\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string res = \"\";\\n        for (auto w : words) {\\n            res += w;\\n            if (res == s) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string res = \"\";\\n        for (auto w : words) {\\n            res += w;\\n            if (res == s) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390473,
                "title": "python-brute-force-o-mn",
                "content": "Start from an empty string and build the prefix string word by word. Every time we build the prefix string, check if it\\'s equal to `s`.\\n\\nLet `n` be length of `s` and `m` be length of all words combined. Then in the worst case we check equality `m` times for length of string `n`.\\n\\nO(mn) time complexity.\\n\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        cur_prefix = \"\"\\n        for i in range(len(words)):\\n            cur_prefix += words[i]\\n            if s == cur_prefix:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        cur_prefix = \"\"\\n        for i in range(len(words)):\\n            cur_prefix += words[i]\\n            if s == cur_prefix:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003861,
                "title": "python-most-simple-solution-one-liner",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def isPrefixString(self, s, words):\\n        return s in accumulate(words)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s, words):\\n        return s in accumulate(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390260,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int n = s.size();\\n        string res;\\n        int m = words.size();\\n        for(int i = 0;i<m && res.size()<n;i++){\\n            if(res == s)return true;\\n            res += words[i];\\n        }\\n        return res == s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int n = s.size();\\n        string res;\\n        int m = words.size();\\n        for(int i = 0;i<m && res.size()<n;i++){\\n            if(res == s)return true;\\n            res += words[i];\\n        }\\n        return res == s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390248,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string n=\"\";\\n        for(string str:words){\\n            for(char ch:str){\\n                n+=ch;\\n            }\\n            if(n==s){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string n=\"\";\\n        for(string str:words){\\n            for(char ch:str){\\n                n+=ch;\\n            }\\n            if(n==s){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390161,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int count = 0; \\n        char[] chars = s.toCharArray(); \\n        for (String word : words) {\\n            for (char c : word.toCharArray()) {\\n                if (count == chars.length) {\\n                    return false; \\n                }\\n                if (chars[count++] != c) {\\n                    return false; \\n                }\\n            }\\n            if (count == chars.length) {\\n                return true; \\n            }\\n        }\\n        return count == chars.length; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int count = 0; \\n        char[] chars = s.toCharArray(); \\n        for (String word : words) {\\n            for (char c : word.toCharArray()) {\\n                if (count == chars.length) {\\n                    return false; \\n                }\\n                if (chars[count++] != c) {\\n                    return false; \\n                }\\n            }\\n            if (count == chars.length) {\\n                return true; \\n            }\\n        }\\n        return count == chars.length; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039081,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words):\\n        subresult = [\\'\\'.join(words[:i+1]) for i in range(len(words))]\\n        for substr in subresult:\\n            if substr == s: return True\\n        return False\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/69e6c757-a27b-4e78-b050-9d0864b66d3c_1673506636.7428927.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words):\\n        subresult = [\\'\\'.join(words[:i+1]) for i in range(len(words))]\\n        for substr in subresult:\\n            if substr == s: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745414,
                "title": "java-solution-using-stringbuilder",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String w: words){\\n            sb.append(w);\\n            if (s.equals(sb.toString())) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String w: words){\\n            sb.append(w);\\n            if (s.equals(sb.toString())) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733030,
                "title": "c-2-different-approaches-fast-0ms-clean-code",
                "content": "I was slighlty confused with the problem description. At first I though we need to try all possible combinations to see if we can build the target string ```s```, but it turns out we just need to see if the first ```k``` words in ```words``` concatenated yield the string ```s```.\\n\\n# Approach 1: concatenate (9ms)\\n\\n```cpp\\n    static bool isPrefixString(const string& s, const vector<string>& words) {\\n        string prefix;\\n        prefix.reserve(size(s));\\n        for (const string& word : words) {\\n            if (size(prefix) < size(s)) {\\n                prefix += word;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s == prefix;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of the string ```s``` then the\\n  * Time complexity is $$O(n)$$ for copying and then comparing the string, and the\\n  * Space complexity is $$O(n)$$ as we need to extra space for the ```prefix``` string.\\n\\n\\n# Approach 2: compare piecewise (0ms)\\n\\nTo avoid stiching the string together we can just compare them piece by piece.\\n\\n```cpp\\n    static bool isPrefixString(const string& s, const vector<string>& words) {\\n        int pos = 0;\\n        for (int i = 0; pos < size(s) && i < size(words); ++i) {\\n            if (s.compare(pos, size(words[i]), words[i]) != 0) return false;\\n            pos += size(words[i]);\\n        }\\n        return pos == size(s);\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of the string ```s``` then the\\n  * Time complexity is $$O(n)$$ as we are comparing up to the length of ```s``` and the\\n  * Space complexity is $$O(1)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```s```\n```k```\n```words```\n```s```\n```cpp\\n    static bool isPrefixString(const string& s, const vector<string>& words) {\\n        string prefix;\\n        prefix.reserve(size(s));\\n        for (const string& word : words) {\\n            if (size(prefix) < size(s)) {\\n                prefix += word;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s == prefix;\\n    }\\n```\n```s```\n```prefix```\n```cpp\\n    static bool isPrefixString(const string& s, const vector<string>& words) {\\n        int pos = 0;\\n        for (int i = 0; pos < size(s) && i < size(words); ++i) {\\n            if (s.compare(pos, size(words[i]), words[i]) != 0) return false;\\n            pos += size(words[i]);\\n        }\\n        return pos == size(s);\\n    }\\n```\n```s```\n```s```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130015,
                "title": "j",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }\\n            st+=words[i];\\n            if(s.equals(st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }\\n            st+=words[i];\\n            if(s.equals(st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221696,
                "title": "python-solution-for-beginners-by-beginner",
                "content": "\\nRuntime: 36 ms, faster than 91.08% of Python3 online submissions for Check If String Is a Prefix of Array.\\nMemory Usage: 13.8 MB, less than 97.53% of Python3 online submissions for Check If String Is a Prefix of Array.\\n\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        ans = \\'\\'\\n        for i in words:\\n            ans += i\\n            if ans == s :\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        ans = \\'\\'\\n        for i in words:\\n            ans += i\\n            if ans == s :\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390401,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        ans=\"\"\\n        for x in words:\\n            ans+=x\\n            if ans==s:\\n                return True\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        ans=\"\"\\n        for x in words:\\n            ans+=x\\n            if ans==s:\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390221,
                "title": "java-easy-code",
                "content": "```\\nclass Solution {\\n  \\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0;i<words.length;i++){\\n            for(int j = 0;j<words[i].length();j++){\\n                sb.append(words[i].charAt(j));\\n            }\\n             if(s.equals(sb.toString())){\\n            return true;\\n        }\\n        }\\n       \\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  \\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0;i<words.length;i++){\\n            for(int j = 0;j<words[i].length();j++){\\n                sb.append(words[i].charAt(j));\\n            }\\n             if(s.equals(sb.toString())){\\n            return true;\\n        }\\n        }\\n       \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492602,
                "title": "check-if-string-is-a-prefix-of-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOPTIMIZED APPROACH\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string s1;\\n        for(i=0;i<words.size();i++)\\n        {\\n            s1 += words[i];\\n            if(s1==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBRUTE FORCE APPROACH\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string s1;\\n        for(i=0;i<words.size();i++)\\n        {\\n            s1 += words[i];\\n            if(s1==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/f815a80b-3468-473c-862a-b3e4e1f73abb_1683366660.2016609.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string s1;\\n        for(i=0;i<words.size();i++)\\n        {\\n            s1 += words[i];\\n            if(s1==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string s1;\\n        for(i=0;i<words.size();i++)\\n        {\\n            s1 += words[i];\\n            if(s1==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442078,
                "title": "short-and-easy-to-understand-c",
                "content": "`Please Upvote the solution`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string ans;\\n        for(auto &w : words) {\\n            ans += w;\\n\\t\\t\\tif(ans == s) return true;\\n\\t\\t\\tif(ans.length() >= s.length()) return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string ans;\\n        for(auto &w : words) {\\n            ans += w;\\n\\t\\t\\tif(ans == s) return true;\\n\\t\\t\\tif(ans.length() >= s.length()) return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848210,
                "title": "c-simple-code-88",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n       string ns=words[0];\\n        int i=1;\\n        while(ns.length()<s.length() && i<words.size())\\n        {\\n            ns+=words[i];\\n            i++;\\n        }\\n        if(ns==s)\\n        {\\n          return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n       string ns=words[0];\\n        int i=1;\\n        while(ns.length()<s.length() && i<words.size())\\n        {\\n            ns+=words[i];\\n            i++;\\n        }\\n        if(ns==s)\\n        {\\n          return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447093,
                "title": "javascript-tc-o-n-sc-o-1",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let i = 0;\\n    \\n    for (const word of words) {\\n        if (!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if (i === s.length) return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let i = 0;\\n    \\n    for (const word of words) {\\n        if (!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if (i === s.length) return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019399,
                "title": "o-n-with-o-1-space-complexity-solution-two-pointer-approach-with-explanation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i=0,j=0,c=0;\\n        while(i<s.length() && j<words.size())\\n        {\\n            if(s[i]!=words[j][c])\\n                return false;\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n            if(c==words[j].length())\\n            {\\n                j++;\\n                c=0;\\n            }\\n        }\\n        if(c==0 && i==s.length())\\n            return true;\\n        else\\n            return false;\\n    }\\n};/*we compare every letter of the strings in the words vector in order and if it doesn\\'t match, we return false.\\n//* c==0 condition :\\n\"a\" [\"aa\",\"aaaa\",\"banana\"]\\na should be a proper full word concentations.\\n//*i==s.length()\\nHence, we need to ensure that the strings are fully matched\\n\"ccccccccc\" [\"c\",\"cc\"]\\nWe need to ensure that the string s is fully iterated. This happens when the word vector is shorter when c is equal to the length of string, one string in word is iterated completelely and now move to another string.*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i=0,j=0,c=0;\\n        while(i<s.length() && j<words.size())\\n        {\\n            if(s[i]!=words[j][c])\\n                return false;\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n            if(c==words[j].length())\\n            {\\n                j++;\\n                c=0;\\n            }\\n        }\\n        if(c==0 && i==s.length())\\n            return true;\\n        else\\n            return false;\\n    }\\n};/*we compare every letter of the strings in the words vector in order and if it doesn\\'t match, we return false.\\n//* c==0 condition :\\n\"a\" [\"aa\",\"aaaa\",\"banana\"]\\na should be a proper full word concentations.\\n//*i==s.length()\\nHence, we need to ensure that the strings are fully matched\\n\"ccccccccc\" [\"c\",\"cc\"]\\nWe need to ensure that the string s is fully iterated. This happens when the word vector is shorter when c is equal to the length of string, one string in word is iterated completelely and now move to another string.*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012833,
                "title": "easy-java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder build = new StringBuilder();\\n        int i = 0;\\n        while(build.length() < s.length() && i < words.length){\\n            build.append(words[i]);\\n            i++;\\n        }\\n        return build.toString().equals(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder build = new StringBuilder();\\n        int i = 0;\\n        while(build.length() < s.length() && i < words.length){\\n            build.append(words[i]);\\n            i++;\\n        }\\n        return build.toString().equals(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770175,
                "title": "javascript-easy-accepted-solution-100-faster-runtime-56-ms",
                "content": "![image](https://assets.leetcode.com/users/images/fb90c4d2-8d24-4d57-952c-af2076d11244_1644827795.4958742.png)\\n\\n```\\nvar isPrefixString = function(s, words) {\\n    let w = \"\";\\n    for (let i = 0; i < words.length; i++) {\\n        w += words[i];\\n        if(s === w){\\n            return true;\\n        }\\n    }\\n    return false;\\n};",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/fb90c4d2-8d24-4d57-952c-af2076d11244_1644827795.4958742.png)\\n\\n```\\nvar isPrefixString = function(s, words) {\\n    let w = \"\";\\n    for (let i = 0; i < words.length; i++) {\\n        w += words[i];\\n        if(s === w){\\n            return true;\\n        }\\n    }\\n    return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1766438,
                "title": "go-solution-100-space-and-time",
                "content": "```\\nfunc isPrefixString(s string, words []string) bool {\\n  pos := 0 // holds the position in string s\\n  for i := 0; i < len(words) && pos < len(s); i++ {\\n    // If the next prefix word is bigger than the remaining characters, it is not a prefix\\n    if len(s)-pos < len(words[i]) {\\n      return false\\n    }\\n    for j := 0; j < len(words[i]) && pos < len(s); j++ {\\n      if s[pos] != words[i][j] {\\n        return false\\n      }\\n      pos++\\n    }\\n  }\\n  return pos == len(s)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPrefixString(s string, words []string) bool {\\n  pos := 0 // holds the position in string s\\n  for i := 0; i < len(words) && pos < len(s); i++ {\\n    // If the next prefix word is bigger than the remaining characters, it is not a prefix\\n    if len(s)-pos < len(words[i]) {\\n      return false\\n    }\\n    for j := 0; j < len(words[i]) && pos < len(s); j++ {\\n      if s[pos] != words[i][j] {\\n        return false\\n      }\\n      pos++\\n    }\\n  }\\n  return pos == len(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401926,
                "title": "java-linear-explained",
                "content": "Keep pointer of where we are in String, check each word and for each word check characters in word and in the string by moving pointers in both. On first mismatch return false\\nCatch:\\n- check if with next word we are not going over the string\\n\\nO(len(s)) time - scan every char in string at max\\nO(1) space - using just few variables to keep state\\n\\n```\\n    public boolean isPrefixString(String s, String[] words) {\\n        int sPointer = 0;\\n        for (String word : words) {\\n            if (s.length() - sPointer < word.length()) {\\n                return false;\\n            }\\n            for (int i = 0; i < word.length(); i++) {\\n                if (s.charAt(sPointer++) != word.charAt(i)) {\\n                    return false;\\n                }\\n            }\\n            if (sPointer >= s.length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isPrefixString(String s, String[] words) {\\n        int sPointer = 0;\\n        for (String word : words) {\\n            if (s.length() - sPointer < word.length()) {\\n                return false;\\n            }\\n            for (int i = 0; i < word.length(); i++) {\\n                if (s.charAt(sPointer++) != word.charAt(i)) {\\n                    return false;\\n                }\\n            }\\n            if (sPointer >= s.length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392365,
                "title": "java-easy-solution-using-stringbuilder-beats-66",
                "content": "```\\nclass Solution { \\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            sb.append(words[i]);\\n            if (sb.toString().equals(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution { \\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            sb.append(words[i]);\\n            if (sb.toString().equals(s)) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1392339,
                "title": "easy-to-understand-c-runtime-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        bool sIsPrefixString = false;\\n        int numberOfWords = words.size();\\n        int sLength = s.length(), sIterator = 0, sRemaining = s.length();\\n        \\n        for (int i = 0; i < numberOfWords; i++)\\n        {\\n            string word = words[i];\\n            int wordSize = word.size();\\n            \\n\\t\\t\\t// first check if word is smaller than remaining string or not\\n            if (wordSize > sRemaining)\\n                return false;\\n            \\n            for (int j = 0; j < wordSize; j++)\\n            {\\n                sRemaining--;\\n                if (s[sIterator++] != word[j])\\n                    return false;\\n            }\\n            \\n\\t\\t\\t// if last word extinguished the string\\n            if (sRemaining == 0)\\n                return true;\\n        }        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        bool sIsPrefixString = false;\\n        int numberOfWords = words.size();\\n        int sLength = s.length(), sIterator = 0, sRemaining = s.length();\\n        \\n        for (int i = 0; i < numberOfWords; i++)\\n        {\\n            string word = words[i];\\n            int wordSize = word.size();\\n            \\n\\t\\t\\t// first check if word is smaller than remaining string or not\\n            if (wordSize > sRemaining)\\n                return false;\\n            \\n            for (int j = 0; j < wordSize; j++)\\n            {\\n                sRemaining--;\\n                if (s[sIterator++] != word[j])\\n                    return false;\\n            }\\n            \\n\\t\\t\\t// if last word extinguished the string\\n            if (sRemaining == 0)\\n                return true;\\n        }        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390370,
                "title": "prefix-string-o-n",
                "content": "```\\n// n = words.length\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& arr)\\n\\t{\\n        int n = arr.size() ;\\n        vector<string> prefix(n,\"\");\\n        prefix[0]=arr[0];\\n     \\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+arr[i];\\n        \\n        for(int i=0;i<n;i++) {\\n            if(prefix[i]==s)  return 1 ;\\n        }\\n        return 0 ;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n// n = words.length\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& arr)\\n\\t{\\n        int n = arr.size() ;\\n        vector<string> prefix(n,\"\");\\n        prefix[0]=arr[0];\\n     \\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+arr[i];\\n        \\n        for(int i=0;i<n;i++) {\\n            if(prefix[i]==s)  return 1 ;\\n        }\\n        return 0 ;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390285,
                "title": "5-liner-solution-self-explanatory-c",
                "content": "```\\nbool isPrefixString(string s, vector<string>& words) {\\n        string a=\"\";\\n        if(s==\"\")return true;\\n        for(int i=0;i<words.size();i++){\\n            a+=words[i];\\n            if(a==s)return true;\\n            if(a.size()>s.size())return false;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPrefixString(string s, vector<string>& words) {\\n        string a=\"\";\\n        if(s==\"\")return true;\\n        for(int i=0;i<words.size();i++){\\n            a+=words[i];\\n            if(a==s)return true;\\n            if(a.size()>s.size())return false;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390284,
                "title": "simplest-c-solution",
                "content": "```\\nbool isPrefixString(string s, vector<string>& words) {\\n        int n=words.size();\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n            str+=words[i];\\n            if(s==str)\\n                return true;\\n        }\\n        return false;\\n    }\\n```\\nTime complexity: O(n)\\nSpace complexity : O(n)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nbool isPrefixString(string s, vector<string>& words) {\\n        int n=words.size();\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n            str+=words[i];\\n            if(s==str)\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390233,
                "title": "c-1961-check-if-string-is-a-prefix-of-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i = 0; \\n        for (auto& word : words) {\\n            if (s.substr(i, word.size()) != word) return false; \\n            i += word.size(); \\n            if (i == s.size()) return true; \\n        }\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i = 0; \\n        for (auto& word : words) {\\n            if (s.substr(i, word.size()) != word) return false; \\n            i += word.size(); \\n            if (i == s.size()) return true; \\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390195,
                "title": "java-o-n-space-o-1",
                "content": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n\\tfor(int i=0, k=0;k<words.length;k++) {\\n\\t\\tfor(int j =0;j<words[k].length();j++,i++)\\n\\t\\t\\tif(i == s.length() || words[k].charAt(j) !=s.charAt(i)) return false;\\n\\t\\tif(i == s.length()) return true;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n\\tfor(int i=0, k=0;k<words.length;k++) {\\n\\t\\tfor(int j =0;j<words[k].length();j++,i++)\\n\\t\\t\\tif(i == s.length() || words[k].charAt(j) !=s.charAt(i)) return false;\\n\\t\\tif(i == s.length()) return true;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390156,
                "title": "a-few-solutions",
                "content": "Perform a linear scan of each `i`<sup>th</sup> character of the input string `s` while simultaneously traversing each `k`<sup>th</sup> word\\'s `j`<sup>th</sup> chactacter for each `k`<sup>th</sup> word of the input array `A`.  Return `true` if and only if the string `s` was fully traversed at the end of at least `k = 1` words.\\n\\n---\\n   \\n*Kotlin*\\n```\\nclass Solution {\\n    fun isPrefixString(s: String, A: Array<String>): Boolean {\\n        var (i, j, k) = listOf(0, 0, 0)\\n        while (i < s.length && k < A.size && s[i] == A[k][j]) {\\n            ++i; ++j\\n            if (j == A[k].length) {\\n                j = 0; ++k\\n            }\\n        }\\n        return i == s.length && j == 0 && 0 < k\\n    }\\n}\\n```\\n    \\n*Javascript*\\n```\\nlet isPrefixString = (s, A) => {\\n    let [i, j, k] = [0, 0, 0];\\n    while (i < s.length && k < A.length && s[i] == A[k][j]) {\\n        ++i, ++j;\\n        if (j == A[k].length)\\n            j = 0, ++k;\\n    }\\n    return i == s.length && !j && k;\\n};\\n```\\n    \\n*Python3*\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, A: List[str]) -> bool:\\n        i, j, k = 0, 0, 0\\n        while i < len(s) and k < len(A) and s[i] == A[k][j]:\\n            i += 1; j += 1\\n            if j == len(A[k]):\\n                j = 0; k += 1\\n        return i == len(s) and not j and k\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    bool isPrefixString(string s, VS& A) {\\n        auto i = 0,\\n             j = 0,\\n             k = 0;\\n        while (i < s.size() && k < A.size() && s[i] == A[k][j]) {\\n            ++i, ++j;\\n            if (j == A[k].size())\\n                j = 0, ++k;\\n        }\\n        return i == s.size() && !j && k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun isPrefixString(s: String, A: Array<String>): Boolean {\\n        var (i, j, k) = listOf(0, 0, 0)\\n        while (i < s.length && k < A.size && s[i] == A[k][j]) {\\n            ++i; ++j\\n            if (j == A[k].length) {\\n                j = 0; ++k\\n            }\\n        }\\n        return i == s.length && j == 0 && 0 < k\\n    }\\n}\\n```\n```\\nlet isPrefixString = (s, A) => {\\n    let [i, j, k] = [0, 0, 0];\\n    while (i < s.length && k < A.length && s[i] == A[k][j]) {\\n        ++i, ++j;\\n        if (j == A[k].length)\\n            j = 0, ++k;\\n    }\\n    return i == s.length && !j && k;\\n};\\n```\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, A: List[str]) -> bool:\\n        i, j, k = 0, 0, 0\\n        while i < len(s) and k < len(A) and s[i] == A[k][j]:\\n            i += 1; j += 1\\n            if j == len(A[k]):\\n                j = 0; k += 1\\n        return i == len(s) and not j and k\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    bool isPrefixString(string s, VS& A) {\\n        auto i = 0,\\n             j = 0,\\n             k = 0;\\n        while (i < s.size() && k < A.size() && s[i] == A[k][j]) {\\n            ++i, ++j;\\n            if (j == A[k].size())\\n                j = 0, ++k;\\n        }\\n        return i == s.size() && !j && k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835050,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        \\n        string str = \"\";\\n        for(int i=0; i<words.size(); i++){\\n            str += words[i];\\n            if(str == s){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        \\n        string str = \"\";\\n        for(int i=0; i<words.size(); i++){\\n            str += words[i];\\n            if(str == s){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794132,
                "title": "brute-force-approach-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nADD and CHECK formula\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.) Simply make a empty string named = prefix;\\n2.) simply iterate through the string words and start pushing the strings that you encounter;\\n3.) similarly check whether it is equal to the string (s);\\n4.) If it is equal then return true\\n5.) also check if the length of prefix exceeds the length of the string (s) because if it is then the string is not the prefix,simply return false.\\n\\nHope you Understood!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string prefix  = \"\";\\n        for(int i=0;i<words.size();i++){\\n            prefix += words[i];\\n            if(prefix == s){\\n                return true;\\n            }\\n            else if(prefix.length() > s.length()){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string prefix  = \"\";\\n        for(int i=0;i<words.size();i++){\\n            prefix += words[i];\\n            if(prefix == s){\\n                return true;\\n            }\\n            else if(prefix.length() > s.length()){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504054,
                "title": "javascript-easy-to-understand-simple-solution-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe can iterate the `words` array and start building a string with the words in it in order. Each time we add a new word to our string, we compare it to `s`, and if they\\'re the same, we return true. If, at the end of the iteration, the strings don\\'t match, we return false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let compareStr = \\'\\';\\n\\n    for (let i = 0; i < words.length; i++) {\\n        compareStr = compareStr + words[i];\\n        if (compareStr === s) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let compareStr = \\'\\';\\n\\n    for (let i = 0; i < words.length; i++) {\\n        compareStr = compareStr + words[i];\\n        if (compareStr === s) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450420,
                "title": "100-beginner-solution-easy-to-understand",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        add to string t and then check if it matches with String s \\n        then return true and return false after completing \\n        the whole addition of word present in words\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n    StringBuilder t=new StringBuilder();\\n\\n    for(String word: words){\\n         t.append(word);\\n        if(s.equals(t.toString())) return true;\\n           \\n        \\n    }\\n    return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n    StringBuilder t=new StringBuilder();\\n\\n    for(String word: words){\\n         t.append(word);\\n        if(s.equals(t.toString())) return true;\\n           \\n        \\n    }\\n    return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130014,
                "title": "j",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }\\n            st+=words[i];\\n            if(s.equals(st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }\\n            st+=words[i];\\n            if(s.equals(st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056907,
                "title": "1961-java-2-approach",
                "content": "# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 1 ms\\n- Beats : 94.20%\\n- Memory : 41.8 MB\\n- Beats : 92.70%\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        for(String s1 : words){\\n            if(s.length() == 0) return true;\\n            if(s.indexOf(s1) == 0) s = s.substring(s1.length());\\n            else return false;\\n        }\\n        return s.length() > 0? false : true;\\n    }\\n}\\n```\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 1 ms\\n- Beats : 94.20%\\n- Memory : 42.2 MB\\n- Beats : 78.44%\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String temp = \"\";\\n        for(String s1 : words){\\n            temp += s1;\\n            if(temp.length() == s.length()){\\n                if(temp.equals(s))return true;\\n                return false;\\n            }\\n            else if(temp.length() > s.length()) return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        for(String s1 : words){\\n            if(s.length() == 0) return true;\\n            if(s.indexOf(s1) == 0) s = s.substring(s1.length());\\n            else return false;\\n        }\\n        return s.length() > 0? false : true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String temp = \"\";\\n        for(String s1 : words){\\n            temp += s1;\\n            if(temp.length() == s.length()){\\n                if(temp.equals(s))return true;\\n                return false;\\n            }\\n            else if(temp.length() > s.length()) return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979379,
                "title": "check-if-string-is-a-prefix-of-array-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int length = s.length();\\n        int arrLength = words.length;\\n        int index = 0;\\n        for (int i = 0; i < arrLength && index < length; i++) {\\n            String word = words[i];\\n            int wordLength = word.length();\\n            int j = 0;\\n            while (j < wordLength && index < length) {\\n                if (s.charAt(index) == word.charAt(j)) {\\n                    index++;\\n                    j++;\\n                } else\\n                    return false;\\n            }\\n            if (index == length && j < wordLength)\\n                return false;\\n        }\\n        return index == length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int length = s.length();\\n        int arrLength = words.length;\\n        int index = 0;\\n        for (int i = 0; i < arrLength && index < length; i++) {\\n            String word = words[i];\\n            int wordLength = word.length();\\n            int j = 0;\\n            while (j < wordLength && index < length) {\\n                if (s.charAt(index) == word.charAt(j)) {\\n                    index++;\\n                    j++;\\n                } else\\n                    return false;\\n            }\\n            if (index == length && j < wordLength)\\n                return false;\\n        }\\n        return index == length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845747,
                "title": "java-simple-approach-using-stringbuilder",
                "content": "\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder res = new StringBuilder (\"\");\\n        for(String w : words){\\n            res.append (w);\\n            if(s.equals(res.toString())) return true;\\n        }\\n        return false;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder res = new StringBuilder (\"\");\\n        for(String w : words){\\n            res.append (w);\\n            if(s.equals(res.toString())) return true;\\n        }\\n        return false;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2705482,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) \\n    {\\n       int sidx=0;\\n       for(int i=0;i<words.size();i++)\\n       {\\n          string currstr = words[i];\\n          int temp=0;\\n\\n          while(sidx<s.length() and temp<currstr.length())\\n          {\\n              if(s[sidx]!=currstr[temp])\\n              {\\n                return false;\\n              }\\n              sidx++;\\n              temp++; \\t\\n          }\\t\\n          if(sidx>=s.length() and temp>=currstr.length())\\n          return true;\\n          else if(sidx>=s.length() and temp<currstr.length())\\n          return false;\\n       }\\n       if(sidx >= s.length())\\n       return true;\\n        \\n       return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) \\n    {\\n       int sidx=0;\\n       for(int i=0;i<words.size();i++)\\n       {\\n          string currstr = words[i];\\n          int temp=0;\\n\\n          while(sidx<s.length() and temp<currstr.length())\\n          {\\n              if(s[sidx]!=currstr[temp])\\n              {\\n                return false;\\n              }\\n              sidx++;\\n              temp++; \\t\\n          }\\t\\n          if(sidx>=s.length() and temp>=currstr.length())\\n          return true;\\n          else if(sidx>=s.length() and temp<currstr.length())\\n          return false;\\n       }\\n       if(sidx >= s.length())\\n       return true;\\n        \\n       return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672534,
                "title": "java-stringbuilder-easy",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < words.length && sb.length() < s.length(); i++) {\\n            sb.append(words[i]);\\n        }\\n        \\n        return s.equals(sb.toString());\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < words.length && sb.length() < s.length(); i++) {\\n            sb.append(words[i]);\\n        }\\n        \\n        return s.equals(sb.toString());\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618824,
                "title": "c-solution-in-linear-complexity",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string p;\\n        for(int i=0;i<words.size();i++){\\n            p+=words[i];\\n             if(p==s)\\n            return true ;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string p;\\n        for(int i=0;i<words.size();i++){\\n            p+=words[i];\\n             if(p==s)\\n            return true ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2559144,
                "title": "simple-java-string-solution",
                "content": "We need to basically check whether the given string in words array starts with the prefix string or not. If not, we need to keep appending the next strings in words array and check the same condition again.\\n\\n\\nThe edge case would be a prefix string like \"a\" and words array as [\"aa\",\"aaaa\",\"banana\"] where we need to check the prefix string has atleast the length of the words.\\n\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for (String str : words) {\\n            sb.append(str);\\n            if (sb.toString().startsWith(s) && s.length()>=sb.toString().length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for (String str : words) {\\n            sb.append(str);\\n            if (sb.toString().startsWith(s) && s.length()>=sb.toString().length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448622,
                "title": "check-if-string-is-a-prefix-of-array-java-simple",
                "content": "4ms solution\\uD83D\\uDC47\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String res=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            res=res+words[i];\\n            \\n            if(s.equals(res))\\n                return true;\\n            \\n            else\\n                continue;\\n            \\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n    }\\n}\\n```\\n3 ms Solution\\uD83D\\uDC47\\n\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String res=\"\";\\n        for(int i=0;i<words.length&&!(s.equals(res));i++)\\n        {\\n            res=res+words[i];\\n\\n        }\\n\\n\\n        if(res.length()>s.length() || res.length()<s.length())\\n            return false;\\n\\n        else if(res.length()==s.length())\\n        {\\n            if(s.equals(res)==false)\\n                return false;\\n        }\\n\\n        return true;\\n\\n\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String res=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            res=res+words[i];\\n            \\n            if(s.equals(res))\\n                return true;\\n            \\n            else\\n                continue;\\n            \\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String res=\"\";\\n        for(int i=0;i<words.length&&!(s.equals(res));i++)\\n        {\\n            res=res+words[i];\\n\\n        }\\n\\n\\n        if(res.length()>s.length() || res.length()<s.length())\\n            return false;\\n\\n        else if(res.length()==s.length())\\n        {\\n            if(s.equals(res)==false)\\n                return false;\\n        }\\n\\n        return true;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415849,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) \\n    {\\n        for (int i= words.Length-1; i>=0; i--)\\n        {\\n\\t\\t\\tif (s == String.Join(\"\", string.Join(\"\", words.Take(i+1).ToArray())))\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) \\n    {\\n        for (int i= words.Length-1; i>=0; i--)\\n        {\\n\\t\\t\\tif (s == String.Join(\"\", string.Join(\"\", words.Take(i+1).ToArray())))\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339750,
                "title": "python-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        cur_idx = 0\\n        for w in words:\\n            if s.startswith(w, cur_idx):\\n                cur_idx += len(w)\\n            else:\\n                break\\n            if cur_idx == len(s): return True\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        cur_idx = 0\\n        for w in words:\\n            if s.startswith(w, cur_idx):\\n                cur_idx += len(w)\\n            else:\\n                break\\n            if cur_idx == len(s): return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2328982,
                "title": "check-if-string-is-a-prefix-of-array-with-python",
                "content": "\\tclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        text = \"\"\\n        for i in range(len(words)):\\n            text += words[i]\\n            if text == s:\\n                return True\\n        return False",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        text = \"\"\\n        for i in range(len(words)):\\n            text += words[i]\\n            if text == s:\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2324003,
                "title": "kotlin",
                "content": "```\\nfun isPrefixString(s: String, words: Array<String>): Boolean {\\n    words.fold(\"\") { acc, string ->\\n        val sum = acc + string\\n        if (sum == s) return true else sum\\n    }\\n    return false\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfun isPrefixString(s: String, words: Array<String>): Boolean {\\n    words.fold(\"\") { acc, string ->\\n        val sum = acc + string\\n        if (sum == s) return true else sum\\n    }\\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2253922,
                "title": "c-string-concatenation-3-line-code",
                "content": "![image](https://assets.leetcode.com/users/images/cdc6215d-6f90-41be-b7b9-1d61cb65e1a8_1657266608.746967.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPrefixString(string s, vector<string>& words) {\\n\\t\\t\\tstring str=\"\";\\n\\t\\t\\tfor(int i=0;i<words.size();i++){\\n\\t\\t\\t\\tstr+=words[i];\\n\\t\\t\\t\\tif(s==str)return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isPrefixString(string s, vector<string>& words) {\\n\\t\\t\\tstring str=\"\";\\n\\t\\t\\tfor(int i=0;i<words.size();i++){\\n\\t\\t\\t\\tstr+=words[i];\\n\\t\\t\\t\\tif(s==str)return true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2143639,
                "title": "c-easy-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n       string ans=\"\";\\n        map<string,int>harsh;\\n        harsh[s]++;\\n        for(auto val : words )\\n        {\\n            ans+=val;\\n            if(harsh.find(ans) != harsh.end())\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n       string ans=\"\";\\n        map<string,int>harsh;\\n        harsh[s]++;\\n        for(auto val : words )\\n        {\\n            ans+=val;\\n            if(harsh.find(ans) != harsh.end())\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966796,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        return any([s == \\'\\'.join(words[:i]) for i in range(len(words)+1)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        return any([s == \\'\\'.join(words[:i]) for i in range(len(words)+1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959466,
                "title": "java-100-pointer-and-indexof",
                "content": "Using String.indexOf\\n\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int index=0;\\n        for(String w:words){\\n            int index2=s.indexOf(w,index);\\n            if(index2!=index){\\n                return false;\\n            }\\n            index+=w.length();\\n            if(index==s.length()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nUsing pointer\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int index=0;\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(j==words[index].length()){\\n                index++;\\n                j=0;\\n            }\\n            if(index==words.length){\\n                return false;\\n            }\\n            if(s.charAt(i)!=words[index].charAt(j++)){\\n                return false;\\n            }\\n        }\\n        return words[index].length()==j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int index=0;\\n        for(String w:words){\\n            int index2=s.indexOf(w,index);\\n            if(index2!=index){\\n                return false;\\n            }\\n            index+=w.length();\\n            if(index==s.length()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int index=0;\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(j==words[index].length()){\\n                index++;\\n                j=0;\\n            }\\n            if(index==words.length){\\n                return false;\\n            }\\n            if(s.charAt(i)!=words[index].charAt(j++)){\\n                return false;\\n            }\\n        }\\n        return words[index].length()==j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953215,
                "title": "simple-python-solution-faster-than-91-76",
                "content": "```\\ndef isPrefixString(self, s, words):\\n\\ttester = []\\n\\tfor w in words :\\n\\t\\ttester.append(w)\\n\\t\\tif \"\".join(tester) == s :\\n\\t\\t\\treturn True\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isPrefixString(self, s, words):\\n\\ttester = []\\n\\tfor w in words :\\n\\t\\ttester.append(w)\\n\\t\\tif \"\".join(tester) == s :\\n\\t\\t\\treturn True\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1931666,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int j=0;\\n        for(int i=0;i<words.length&&j<s.length();i++)\\n        {\\n            if(j+words[i].length()>s.length())\\n                return false;\\n            if(!s.substring(j,j+words[i].length()).equals(words[i]))\\n                return false;\\n            j+=words[i].length();\\n        }\\n        if(j<s.length())\\n            return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int j=0;\\n        for(int i=0;i<words.length&&j<s.length();i++)\\n        {\\n            if(j+words[i].length()>s.length())\\n                return false;\\n            if(!s.substring(j,j+words[i].length()).equals(words[i]))\\n                return false;\\n            j+=words[i].length();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1866923,
                "title": "java-using-stringbuilder",
                "content": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb=new StringBuilder();\\n     for(String str:words){\\n         sb.append(str);\\n         if(sb.toString().equals(s))\\n             return true;\\n     }   \\n        return false;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb=new StringBuilder();\\n     for(String str:words){\\n         sb.append(str);\\n         if(sb.toString().equals(s))\\n             return true;\\n     }   \\n        return false;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1827253,
                "title": "easy-c-solution-using-vector",
                "content": "```\\nbool isPrefixString(string s, vector<string>& w) {\\n        vector<string> v;\\n        int k=0,fl=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int q=w[i].length();\\n            fl+=w[i].length();\\n            if(k<s.length())\\n            {\\n                string x;\\n                int r=0;\\n                while(k<s.length() && r<q )\\n                {\\n                    x+=s[k];\\n                    k++;\\n                    r++;\\n                }\\n                v.push_back(x);\\n            }\\n        }\\n        if(fl<s.length())\\n            return false;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]!=w[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isPrefixString(string s, vector<string>& w) {\\n        vector<string> v;\\n        int k=0,fl=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int q=w[i].length();\\n            fl+=w[i].length();\\n            if(k<s.length())\\n            {\\n                string x;\\n                int r=0;\\n                while(k<s.length() && r<q )\\n                {\\n                    x+=s[k];\\n                    k++;\\n                    r++;\\n                }\\n                v.push_back(x);\\n            }\\n        }\\n        if(fl<s.length())\\n            return false;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]!=w[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1739796,
                "title": "python-add-up-words-to-s",
                "content": "Add up the word in words till we get s, if we can\\'t get s, return False\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        sentence = \\'\\'\\n        for word in words:\\n            sentence += word\\n            if sentence == s:\\n                return True\\n        return False",
                "solutionTags": [],
                "code": "Add up the word in words till we get s, if we can\\'t get s, return False\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        sentence = \\'\\'\\n        for word in words:\\n            sentence += word\\n            if sentence == s:\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1647589,
                "title": "java-efficient-soultion",
                "content": "int i=0;\\n        for(String word: words)\\n        {\\n            if(s.startsWith(word,i))\\n                i+=word.length();\\n            else\\n                return false;\\n            if(i==s.length())\\n                return true;\\n        }\\n        return i==s.length();\\n    }\\n}\\n// this is another solution\\n// StringBuffer sb=new StringBuffer();\\n//         for(int i=0;i<words.length;i++)\\n//         {\\n//             sb.append(words[i]);\\n//             if(sb.toString().equals(s))\\n//                 return true;\\n//         }\\n//         return false;",
                "solutionTags": [
                    "Java"
                ],
                "code": "int i=0;\\n        for(String word: words)\\n        {\\n            if(s.startsWith(word,i))\\n                i+=word.length();\\n            else\\n                return false;\\n            if(i==s.length())\\n                return true;\\n        }\\n        return i==s.length();\\n    }\\n}\\n// this is another solution\\n// StringBuffer sb=new StringBuffer();\\n//         for(int i=0;i<words.length;i++)\\n//         {\\n//             sb.append(words[i]);\\n//             if(sb.toString().equals(s))\\n//                 return true;\\n//         }\\n//         return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 1625729,
                "title": "java-100-faster-simple-length-check-with-startswith-string-function",
                "content": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n        int i=0;\\n        for(String word : words){\\n            if(s.startsWith(word,i)){\\n                i+=word.length();\\n            }else{\\n                return false;\\n            }\\n            if(i==s.length()) return true;\\n        }\\n        return i==s.length();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n        int i=0;\\n        for(String word : words){\\n            if(s.startsWith(word,i)){\\n                i+=word.length();\\n            }else{\\n                return false;\\n            }\\n            if(i==s.length()) return true;\\n        }\\n        return i==s.length();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624335,
                "title": "2-line-0ms-100-faster-than-c-easy-clean-explained",
                "content": "**C++ solutions :**\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& w) {\\n        string str;\\n        for(auto &i:w)\\n        {\\n            str+=i;\\n            if(str==s) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**if you like this solutions , please upvote for me\\nany doubt ---> comment \\nThank you .**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& w) {\\n        string str;\\n        for(auto &i:w)\\n        {\\n            str+=i;\\n            if(str==s) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550291,
                "title": "runtime-1-ms-faster-than-96-31-of-java",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1 = \"\";\\n        for(int i = 0;i<words.length;i++){\\n            s1 += String.valueOf(words[i]);\\n            if(s1.equals(s)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1 = \"\";\\n        for(int i = 0;i<words.length;i++){\\n            s1 += String.valueOf(words[i]);\\n            if(s1.equals(s)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520120,
                "title": "c-1-liner-stl-accumulate",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n            if(accumulate(words.begin(),words.begin()+i+1,string(\"\"))==s)return true;\\n        return false;\\n    }\\n};\\n```\\nAccumulate will sum up each element to 3rd parameter. For the case of strings, it will do the concatenation operation.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n            if(accumulate(words.begin(),words.begin()+i+1,string(\"\"))==s)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472678,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function (s, words) {\\n  const result = [];\\n\\n  for (const word of words) {\\n    result.push(word);\\n    if (result.join(\"\") === s) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function (s, words) {\\n  const result = [];\\n\\n  for (const word of words) {\\n    result.push(word);\\n    if (result.join(\"\") === s) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461826,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n        \\n        for(int i=0;i<words.length; i++){\\n            str += words[i];\\n            if(str.equals(s))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n        \\n        for(int i=0;i<words.length; i++){\\n            str += words[i];\\n            if(str.equals(s))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447305,
                "title": "c-simple-solution-with-explanation",
                "content": "\"just loop through array and take a empty string,\\nadd words to string if at any point size of our empty string is equal to given string and both are also same then we return TRUE,\\notherwise if at any moment our empty string size is greater than given string we can return immediately FALSE. \"\\n\\t\\n\\there is my code :\\n\\t\\n\\t\\n\\tbool isPrefixString(string s, vector<string>& words) {\\n        \\n        int n = words.size();\\n        string ss=\"\"; // our empty string\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ss+=words[i]; // adding words to string\\n            \\n            if(ss.size() == s.size() and ss == s) return true; // as mentioned above\\n            else if(ss.size() > s.size()) return false; \\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "\"just loop through array and take a empty string,\\nadd words to string if at any point size of our empty string is equal to given string and both are also same then we return TRUE,\\notherwise if at any moment our empty string size is greater than given string we can return immediately FALSE. \"\\n\\t\\n\\there is my code :\\n\\t\\n\\t\\n\\tbool isPrefixString(string s, vector<string>& words) {\\n        \\n        int n = words.size();\\n        string ss=\"\"; // our empty string\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ss+=words[i]; // adding words to string\\n            \\n            if(ss.size() == s.size() and ss == s) return true; // as mentioned above\\n            else if(ss.size() > s.size()) return false; \\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1445993,
                "title": "fast-concise-scala-solution",
                "content": "String `s` is a prefix string if its length is in the prefix lengths and the first `s.length` characters of the flattened iterator of `words` has the same elements as the characters in `s.iterator`.\\n\\n```Scala\\nobject Solution {\\n    def isPrefixString(s: String, words: Array[String]): Boolean = {\\n        words.scanLeft(0)(_ + _.length).drop(1).contains(s.length) &&\\n            words.iterator.flatMap(_.toIterator).take(s.length).sameElements(s.iterator)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n    def isPrefixString(s: String, words: Array[String]): Boolean = {\\n        words.scanLeft(0)(_ + _.length).drop(1).contains(s.length) &&\\n            words.iterator.flatMap(_.toIterator).take(s.length).sameElements(s.iterator)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1439729,
                "title": "himesh",
                "content": "class Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        x = \\'\\'\\n        for i in words :\\n            x += i\\n            if x == s :\\n                return True\\n            if len(x) > len(s) : \\n                return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        x = \\'\\'\\n        for i in words :\\n            x += i\\n            if x == s :\\n                return True\\n            if len(x) > len(s) : \\n                return False",
                "codeTag": "Java"
            },
            {
                "id": 1421624,
                "title": "java-o-n-runtime-o-1-space-using-indexof-with-explanation",
                "content": "```\\n// We keep track of the index of given string as we check if the current word in words matches starting from current index of s\\npublic boolean isPrefixString(String s, String[] words) {\\n\\tint sIndex = 0;\\n\\tfor (int i = 0; i < words.length && sIndex < s.length(); i++) {\\n\\t\\t// indexOf(stringToLookFor, startingIndexToLookFrom), if it doesn\\'t map to the starting point it\\'s not a match\\n\\t\\tif(s.indexOf(words[i], sIndex) != sIndex) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsIndex += words[i].length();\\n\\t}    \\n\\n\\t// words might not of had enough words to complete s, \"ilovecoding\", [\"i\",\"love\"]\\n\\t// so check if we ended because sIndex == s.length()\\n\\treturn (sIndex == s.length());\\n}",
                "solutionTags": [],
                "code": "```\\n// We keep track of the index of given string as we check if the current word in words matches starting from current index of s\\npublic boolean isPrefixString(String s, String[] words) {\\n\\tint sIndex = 0;\\n\\tfor (int i = 0; i < words.length && sIndex < s.length(); i++) {\\n\\t\\t// indexOf(stringToLookFor, startingIndexToLookFrom), if it doesn\\'t map to the starting point it\\'s not a match\\n\\t\\tif(s.indexOf(words[i], sIndex) != sIndex) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsIndex += words[i].length();\\n\\t}    \\n\\n\\t// words might not of had enough words to complete s, \"ilovecoding\", [\"i\",\"love\"]\\n\\t// so check if we ended because sIndex == s.length()\\n\\treturn (sIndex == s.length());\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1416722,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i = 0;\\n        for(auto el : words)\\n        {\\n            if(i == s.size())\\n                break;\\n            if(s.substr(i,el.size()) == el)\\n                i += el.size();\\n            else\\n                return false;\\n            \\n        }\\n        if(i<s.size())\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i = 0;\\n        for(auto el : words)\\n        {\\n            if(i == s.size())\\n                break;\\n            if(s.substr(i,el.size()) == el)\\n                i += el.size();\\n            else\\n                return false;\\n            \\n        }\\n        if(i<s.size())\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403347,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        x = \\'\\'\\n        for i in words :\\n            x += i\\n            if x == s : return True\\n            if len(x) > len(s) : return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        x = \\'\\'\\n        for i in words :\\n            x += i\\n            if x == s : return True\\n            if len(x) > len(s) : return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403184,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string ans=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            ans=ans+words[i];\\n            if(ans.length()!=s.length())\\n            {\\n                continue;\\n            }\\n            else{\\n                break;\\n            }\\n            \\n            \\n        }\\n        if(ans==s)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string ans=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            ans=ans+words[i];\\n            if(ans.length()!=s.length())\\n            {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1402845,
                "title": "straightforward-o-n-approach",
                "content": "The idea is simple: Traverse the list and concat to the string `prefix` and check if it is the same as string `s`. If the length of `prefix` is greater than that of `s`, return `False`.\\nTime Complexity: O(n)\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        prefix = \"\"\\n        n = len(s)\\n        for w in words:\\n            prefix+=w\\n            if(prefix==s):\\n                return True\\n            elif(len(prefix)>n):\\n                return False\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        prefix = \"\"\\n        n = len(s)\\n        for w in words:\\n            prefix+=w\\n            if(prefix==s):\\n                return True\\n            elif(len(prefix)>n):\\n                return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400451,
                "title": "c-o-n",
                "content": "Runtime: 76 ms, faster than 100.00% of C# online submissions for Check If String Is a Prefix of Array.\\n```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        StringBuilder sb = new StringBuilder();\\n            \\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            sb.Append(words[i]);\\n            if(s==sb.ToString())\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        StringBuilder sb = new StringBuilder();\\n            \\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            sb.Append(words[i]);\\n            if(s==sb.ToString())\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1397819,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public boolean isPrefixString(String s, String[] w) {\\n        int i=0,k=s.length(),l=0;\\n        String p=\"\";\\n        while(l!=k&&i<w.length)\\n        {\\n            l=l+w[i].length();\\n            p=p+w[i];\\n            i++;\\n        }\\n        System.out.println(p);\\n        return p.equals(s) ? true : false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isPrefixString(String s, String[] w) {\\n        int i=0,k=s.length(),l=0;\\n        String p=\"\";\\n        while(l!=k&&i<w.length)\\n        {\\n            l=l+w[i].length();\\n            p=p+w[i];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1397000,
                "title": "easy-python-solution-faster-than-98",
                "content": "# Easy Python Solution | Faster than 98%\\n**Runtime: 28 ms, faster than 98% of Python3 online submissions for Check If String Is a Prefix of Array.\\nMemory Usage: 14.2 MB**\\n\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        for word in words:\\n            if s:\\n                if s.startswith(word):\\n                    s = s[len(word):]\\n                else:\\n                    return False\\n\\n        if not s:\\n\\t\\t    # for the case when len(s) > len(len(words[0])......len(words[n-1])\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        for word in words:\\n            if s:\\n                if s.startswith(word):\\n                    s = s[len(word):]\\n                else:\\n                    return False\\n\\n        if not s:\\n\\t\\t    # for the case when len(s) > len(len(words[0])......len(words[n-1])\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395782,
                "title": "java-faster-than-100-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tint n = s.length(),n1 = words.length;\\n\\t\\t\\tString temp = \"\";\\n\\t\\t\\tfor(int i=0;i<n1;i++){\\n\\t\\t\\t\\ttemp+=words[i];\\n\\t\\t\\t\\tif(temp.length()==n) return s.equals(temp);\\n\\t\\t\\t}\\n\\t\\t\\treturn s.equals(temp);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tint n = s.length(),n1 = words.length;\\n\\t\\t\\tString temp = \"\";\\n\\t\\t\\tfor(int i=0;i<n1;i++){\\n\\t\\t\\t\\ttemp+=words[i];\\n\\t\\t\\t\\tif(temp.length()==n) return s.equals(temp);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1395527,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        data = \"\"\\n        for i in words:\\n            data += i\\n            if not s.startswith(data):break\\n            if data == s:return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        data = \"\"\\n        for i in words:\\n            data += i\\n            if not s.startswith(data):break\\n            if data == s:return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390693,
                "title": "simple-java-solution",
                "content": "```\\n\\tStringBuilder str = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = str.toString();\\n            str.append(words[i]);\\n            if (str.toString().length() > s.length()) {\\n                if (temp.isEmpty()) {\\n                    temp = str.toString();\\n                }\\n                return s.equals(temp);\\n            }\\n        }\\n        return s.equals(str.toString());\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\tStringBuilder str = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = str.toString();\\n            str.append(words[i]);\\n            if (str.toString().length() > s.length()) {\\n                if (temp.isEmpty()) {\\n                    temp = str.toString();\\n                }\\n                return s.equals(temp);\\n            }\\n        }\\n        return s.equals(str.toString());\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390663,
                "title": "my-javascript-solution-using-indexof-80-ms",
                "content": "```\\nvar isPrefixString = function(s, words) {\\n    for (let i = 0; i < words.length; ++i) {\\n        if (s.indexOf(words[i]) === 0) s = s.substring(words[i].length);\\n        else break;\\n    }\\n    \\n    return s === \"\";\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPrefixString = function(s, words) {\\n    for (let i = 0; i < words.length; ++i) {\\n        if (s.indexOf(words[i]) === 0) s = s.substring(words[i].length);\\n        else break;\\n    }\\n    \\n    return s === \"\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390437,
                "title": "basic-c-string-solution-in-o-n",
                "content": "**Idea** : \\n\\nLogic is simple. We need to check if a string can be made concatenating initial elements of words. \\nThis string formed should be of size equal to size of given string s. And both string should be equal.\\nIf yes then return true otherwise false. \\n\\nBelow code is self-explainatory. In case of any doubt feel free to ask.\\n```\\n    bool isPrefixString(string s, vector<string>& words) {\\n        \\n        int n = s.size(), m = words.size();\\n        string t = \"\";\\n        int i=0;\\n        while(t.size() <= n && i<m)\\n        {\\n            t += words[i++];\\n            if(t == s) return true;\\n        }\\n        return false;\\n    }\\n```\\nIf you understood the solution, please upvote !!!",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n    bool isPrefixString(string s, vector<string>& words) {\\n        \\n        int n = s.size(), m = words.size();\\n        string t = \"\";\\n        int i=0;\\n        while(t.size() <= n && i<m)\\n        {\\n            t += words[i++];\\n            if(t == s) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390380,
                "title": "my-solution",
                "content": "\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tStringBuffer sb = new StringBuffer(\"\");\\n\\t\\t\\tif(!s.contains(words[0])) return false;\\n\\t\\t\\tfor(int i=0;i<words.length;i++){\\n\\t\\t\\t\\tsb.append(words[i]);\\n\\t\\t\\t\\tif(sb.length()==s.length() && sb.toString().equals(s)){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tStringBuffer sb = new StringBuffer(\"\");\\n\\t\\t\\tif(!s.contains(words[0])) return false;\\n\\t\\t\\tfor(int i=0;i<words.length;i++){\\n\\t\\t\\t\\tsb.append(words[i]);\\n\\t\\t\\t\\tif(sb.length()==s.length() && sb.toString().equals(s)){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1390368,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(String word : words) {\\n            sb.append(word);\\n            if(sb.toString().equals(s))\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(String word : words) {\\n            sb.append(word);\\n            if(sb.toString().equals(s))\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1390362,
                "title": "java-o-n-time",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n      String result=\"\";\\n      for(String i:words){\\n      result+=i;\\n      if(s.length()==result.length())\\n      return s.equals(result);\\n      } \\n      return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n      String result=\"\";\\n      for(String i:words){\\n      result+=i;\\n      if(s.length()==result.length())\\n      return s.equals(result);\\n      } \\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390246,
                "title": "check-if-string-is-a-prefix-of-array-weekly-contest-253-editorial-java",
                "content": "\\tclass Solution {\\n\\t\\t//    Weekly Contest 253 Solutions\\n\\n\\t\\t//    Guyz do mention if you\\'ve some better solution approach. Below are the implementation I used during contest\\n\\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que - 1\\n\\n\\t\\t// I did the brute force approach. I think solution is self explanatory.\\n\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tStringBuilder strb = new StringBuilder();\\n\\t\\t\\tfor(String st : words) {\\n\\t\\t\\t\\tstrb.append(st);\\n\\t\\t\\t\\tif(strb.toString().equals(s)) return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// In each and every iteration we\\'ll change the maximum element to x-x/2 where x is the maximum element in current iteration.\\n\\t\\t// For getting maximum element in every iteration we\\'ll make use of priority queue    \\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que-2 Medium\\n\\t\\tpublic int minStoneSum(int[] piles, int k) {\\n\\t\\t\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\t\\tfor(int val : piles) pq.add(val);\\n\\t\\t\\twhile(k-- != 0) {\\n\\t\\t\\t\\tint x = pq.remove();\\n\\t\\t\\t\\tpq.add(x-x/2);\\n\\t\\t\\t}\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\twhile(!pq.isEmpty()) {\\n\\t\\t\\t\\tsum+=pq.remove();\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\n\\t\\t// After removing the balanced part our string comes aut of like (a*[)(b*]). I did some test cases and we can balance string of such types using following number of steps\\n\\t\\t// min steps = (l+2)/4 steps\\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que-3 Medium\\n\\t\\tpublic int minSwaps(String s) {\\n\\t\\t\\tStack<Character> st = new Stack();\\n\\t\\t\\tfor(char c : s.toCharArray()) {\\n\\t\\t\\t\\tif(c == \\'[\\') st.push(c);\\n\\t\\t\\t\\telse if(c == \\']\\') {\\n\\t\\t\\t\\t\\tif(!st.isEmpty() && st.peek() == \\'[\\') st.pop();\\n\\t\\t\\t\\t\\telse st.push(c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn (st.size()+2)/4;\\n\\t\\t}\\n\\n\\t\\t// This is a variation of Longest increasing subsequence. At an index i We just need to store the max length of longest increasing subsequence we can create whose last index element will be ith element\\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que-4\\n\\t\\tpublic static int bs(ArrayList<Integer> list, int val) {\\n\\t\\t\\tint start = 0, end = list.size();\\n\\t\\t\\twhile (start < end) {\\n\\t\\t\\t\\tint mid = start + (end-start)/2;\\n\\t\\t\\t\\tif(list.get(mid) <= val) {\\n\\t\\t\\t\\t\\tstart = mid+1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tend = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn start;\\n\\t\\t}\\n\\n\\n\\t\\tpublic int[] longestObstacleCourseAtEachPosition(int[] arr) {\\n\\t\\t\\tint n = arr.length;\\n\\t\\t\\tint[] res = new int[arr.length];\\n\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\tint maxv = 1;\\n\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\tint idx = bs(list, arr[i]);\\n\\t\\t\\t\\tif(idx == list.size()){\\n\\t\\t\\t\\t\\tlist.add(arr[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tlist.set(idx, arr[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres[i] = idx+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\t//    **********************************************************************************\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t//    Weekly Contest 253 Solutions\\n\\n\\t\\t//    Guyz do mention if you\\'ve some better solution approach. Below are the implementation I used during contest\\n\\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que - 1\\n\\n\\t\\t// I did the brute force approach. I think solution is self explanatory.\\n\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tStringBuilder strb = new StringBuilder();\\n\\t\\t\\tfor(String st : words) {\\n\\t\\t\\t\\tstrb.append(st);\\n\\t\\t\\t\\tif(strb.toString().equals(s)) return true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4087936,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String word:words){\\n            sb.append(word);\\n            if(s.equals(sb.toString())) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String word:words){\\n            sb.append(word);\\n            if(s.equals(sb.toString())) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084777,
                "title": "python3-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        res=\\'\\'\\n        for word in words:\\n            res+=word\\n            if res==s:\\n                return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        res=\\'\\'\\n        for word in words:\\n            res+=word\\n            if res==s:\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078501,
                "title": "ruby-66ms-adding-one-word-at-a-time",
                "content": "```\\ndef is_prefix_string(s, words)\\n  sentence = \"\"\\n  for w in words\\n    sentence << w\\n    return true if s == sentence\\n  end\\n  return false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_prefix_string(s, words)\\n  sentence = \"\"\\n  for w in words\\n    sentence << w\\n    return true if s == sentence\\n  end\\n  return false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4063970,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/87db82a8-3a12-4af0-8b3c-3c06344596b3_1695120265.33186.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int ind = 0, len = s.length();\\n        int r = words.size();\\n        for(int i=0; i<r; i++){\\n            int sz = words[i].length();\\n            if(s.substr(ind, sz) != words[i]) return false;\\n            else ind += sz;\\n            if(ind == len) break;\\n        }\\n        \\n        return ind == len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int ind = 0, len = s.length();\\n        int r = words.size();\\n        for(int i=0; i<r; i++){\\n            int sz = words[i].length();\\n            if(s.substr(ind, sz) != words[i]) return false;\\n            else ind += sz;\\n            if(ind == len) break;\\n        }\\n        \\n        return ind == len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053388,
                "title": "simple-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        for word in words:\\n            if not s.startswith(word):\\n                return False\\n            s = s.removeprefix(word)\\n            if not s:\\n                return True         \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        for word in words:\\n            if not s.startswith(word):\\n                return False\\n            s = s.removeprefix(word)\\n            if not s:\\n                return True         \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046002,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int wordIdx = 0;\\n        int charIdx = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (wordIdx >= words.size())\\n            {\\n                return false;\\n            }\\n            if (s[i] != words[wordIdx][charIdx])\\n            {\\n                return false;\\n            }\\n            charIdx++;\\n            if (charIdx >= words[wordIdx].length())\\n            {\\n                charIdx = 0;\\n                wordIdx++;\\n            }\\n        }\\n        return (charIdx == 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int wordIdx = 0;\\n        int charIdx = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (wordIdx >= words.size())\\n            {\\n                return false;\\n            }\\n            if (s[i] != words[wordIdx][charIdx])\\n            {\\n                return false;\\n            }\\n            charIdx++;\\n            if (charIdx >= words[wordIdx].length())\\n            {\\n                charIdx = 0;\\n                wordIdx++;\\n            }\\n        }\\n        return (charIdx == 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044279,
                "title": "easy-java-solution-foreach-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n     int idx = 0;\\n          for(String x : words){\\n            if(s.length() == idx){\\n                return true;\\n            }\\n            if(s.length() - idx < x.length()){\\n                return false;\\n            }\\n            for(int i=0;i<x.length();i++){\\n              if(s.charAt(idx) != x.charAt(i)){\\n                return false;\\n              }\\n              idx++;\\n            }\\n          }\\n\\n          if(idx < s.length()){\\n            return false;\\n          }\\n  \\n          return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n     int idx = 0;\\n          for(String x : words){\\n            if(s.length() == idx){\\n                return true;\\n            }\\n            if(s.length() - idx < x.length()){\\n                return false;\\n            }\\n            for(int i=0;i<x.length();i++){\\n              if(s.charAt(idx) != x.charAt(i)){\\n                return false;\\n              }\\n              idx++;\\n            }\\n          }\\n\\n          if(idx < s.length()){\\n            return false;\\n          }\\n  \\n          return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018922,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string a = \"\";\\n        for(int i = 0;i < words.size();i++){\\n            a+=words[i];\\n            if(a == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string a = \"\";\\n        for(int i = 0;i < words.size();i++){\\n            a+=words[i];\\n            if(a == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007157,
                "title": "simple-java-solution-1-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1=\"\";\\n        for(int i=0;i<words.length;i++){\\n            s1+=words[i];\\n            if(s1.equals(s))\\n                return true;\\n        } \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1=\"\";\\n        for(int i=0;i<words.length;i++){\\n            s1+=words[i];\\n            if(s1.equals(s))\\n                return true;\\n        } \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002077,
                "title": "beats-100-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->First we have done the summing of length of words element so that we need to match this at end.\\nThen we combine all words into one and sliced into as length of s to compare.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![beats 100%.jpg](https://assets.leetcode.com/users/images/df114170-4ce3-4b8d-9a4e-21c9e5795827_1693844822.279736.jpeg)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        c=0\\n        arr = [ (c := c+len(i)) for i in words]\\n        n = len(s)\\n        words = \"\".join(i for i in words)[:n]\\n        return s==words and len(s) in arr\\n                \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        c=0\\n        arr = [ (c := c+len(i)) for i in words]\\n        n = len(s)\\n        words = \"\".join(i for i in words)[:n]\\n        return s==words and len(s) in arr\\n                \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998486,
                "title": "java-simple-and-easy-to-understand-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code constructs a string str by concatenating words from the array until str is at least as long as s.\\nThen it checks if the constructed string str is equal to s.\\n\\nExplanation:\\nAppend the String until either of the two conditions are not true:\\n1) If the length of the str becomes greater than the given string s.(if it exceeds the length of given string it can not be equal)\\n2) If we come out of the array of given string words\\n\\nnow, if our string matches the given string then answer will be true otherwise false.\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        // short index =0;\\n        // int i=0;\\n        // while(index<s.length()&&i<words.length)\\n        // {\\n        //     if(words[i]!=s.substring(index,index+words[i].length()))\\n        //     {\\n        //         return false;\\n        //     }\\n        //     index+= words[i].length();\\n        //     i++;\\n        // }\\n        // if(index<s.length())\\n        //     {return false;}\\n        // else\\n        // {return true;}\\n\\n\\n\\n        int i=0;\\n        StringBuilder str = new StringBuilder();\\n        while(str.length()<s.length()&&i<words.length)\\n        {\\n            str = str.append(words[i]);\\n            i++;\\n        }\\n\\n        if(str.toString().equals(s))\\n        return true;\\n\\n        else\\n        return false;\\n        \\n    }\\n}\\n\\n\\n\\n```\\n\\nPlease upvote if you feel the code to be easy. \\nIt means a lot to me...",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        // short index =0;\\n        // int i=0;\\n        // while(index<s.length()&&i<words.length)\\n        // {\\n        //     if(words[i]!=s.substring(index,index+words[i].length()))\\n        //     {\\n        //         return false;\\n        //     }\\n        //     index+= words[i].length();\\n        //     i++;\\n        // }\\n        // if(index<s.length())\\n        //     {return false;}\\n        // else\\n        // {return true;}\\n\\n\\n\\n        int i=0;\\n        StringBuilder str = new StringBuilder();\\n        while(str.length()<s.length()&&i<words.length)\\n        {\\n            str = str.append(words[i]);\\n            i++;\\n        }\\n\\n        if(str.toString().equals(s))\\n        return true;\\n\\n        else\\n        return false;\\n        \\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962547,
                "title": "beats-100-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string concat;\\n        for(int i=0;i<words.size();i++){\\n            concat += words[i];\\n            if(concat == s){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n}; // please upvote if you like it\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string concat;\\n        for(int i=0;i<words.size();i++){\\n            concat += words[i];\\n            if(concat == s){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n}; // please upvote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952006,
                "title": "easy-travers-to-beat-98-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        left_idx=0\\n        right_idx=0\\n        total_l=0\\n        for w in words:\\n            right_idx+=len(w)\\n            total_l+=len(w)\\n            if s[left_idx:right_idx]!=w:\\n                return False\\n            left_idx=right_idx\\n            \\n            if right_idx>=len(s):\\n                break\\n                \\n        if len(s)>total_l:\\n            return False\\n        return True\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        left_idx=0\\n        right_idx=0\\n        total_l=0\\n        for w in words:\\n            right_idx+=len(w)\\n            total_l+=len(w)\\n            if s[left_idx:right_idx]!=w:\\n                return False\\n            left_idx=right_idx\\n            \\n            if right_idx>=len(s):\\n                break\\n                \\n        if len(s)>total_l:\\n            return False\\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946469,
                "title": "beats-92-54-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let str=\\'\\';\\n    for (let index = 0; index < words.length; index++) {str += words[index]; if (str === s) return true;}\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let str=\\'\\';\\n    for (let index = 0; index < words.length; index++) {str += words[index]; if (str === s) return true;}\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937176,
                "title": "check-if-string-is-a-prefix-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isPrefixString(s: string, words: string[]): boolean {\\n    let i= 0;\\n    for(const word  of words ){\\n        if(!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if(i === s.length) return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrefixString(s: string, words: string[]): boolean {\\n    let i= 0;\\n    for(const word  of words ){\\n        if(!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if(i === s.length) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936204,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def isPrefixString(self, s, words):\\n        output = \\'\\'\\n        for i in range(len(words)):\\n            output += words[i]\\n            if output == s:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrefixString(self, s, words):\\n        output = \\'\\'\\n        for i in range(len(words)):\\n            output += words[i]\\n            if output == s:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923763,
                "title": "easy-solution-c-code-beats-82",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string s1 = \"\";\\n        for(int i=0; i<words.size(); i++){\\n            s1 += words[i];\\n            if(s == s1)return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string s1 = \"\";\\n        for(int i=0; i<words.size(); i++){\\n            s1 += words[i];\\n            if(s == s1)return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922132,
                "title": "beats-95-with-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        w=0\\n        for i in words:\\n            if s[w:]==\\'\\':\\n                return True\\n            if s[w:].startswith(i):\\n                w+=len(i)\\n            else:\\n                return False\\n        if s[w:]:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        w=0\\n        for i in words:\\n            if s[w:]==\\'\\':\\n                return True\\n            if s[w:].startswith(i):\\n                w+=len(i)\\n            else:\\n                return False\\n        if s[w:]:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919832,
                "title": "easy-solution",
                "content": "\\n```\\nclass Solution(object):\\n    def isPrefixString(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        prefix = \\'\\'\\n        for w in words:\\n            prefix = prefix + w\\n            if prefix == s:\\n                return True\\n            if not s.startswith(prefix):\\n                break  \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrefixString(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        prefix = \\'\\'\\n        for w in words:\\n            prefix = prefix + w\\n            if prefix == s:\\n                return True\\n            if not s.startswith(prefix):\\n                break  \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900589,
                "title": "with-and-without-using-space-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2), O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1), O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int w=0;\\n        for(int i=0; i < words.size(); i++){\\n            for(int j=0; j < words[i].size(); j++){\\n                if(words[i][j]!=s[w++]) return 0;\\n            }\\n            if(w >= s.size()) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = \"\";\\n        for(int i=0; i < words.size(); i++){\\n            str+=words[i];\\n            if(s==str) return 1;\\n            if(s.size() < str.size()) return 0;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int w=0;\\n        for(int i=0; i < words.size(); i++){\\n            for(int j=0; j < words[i].size(); j++){\\n                if(words[i][j]!=s[w++]) return 0;\\n            }\\n            if(w >= s.size()) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = \"\";\\n        for(int i=0; i < words.size(); i++){\\n            str+=words[i];\\n            if(s==str) return 1;\\n            if(s.size() < str.size()) return 0;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890032,
                "title": "c-two-pointers-time-o-n2-space-o-1",
                "content": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n          if(words[i].Length > s.Length - count) return false;\\n          for(int j = 0; j < words[i].Length; j++)\\n          {\\n            if(words[i][j] != s[count]) return false;\\n            if(s.Length == ++count) return true;\\n          }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n          if(words[i].Length > s.Length - count) return false;\\n          for(int j = 0; j < words[i].Length; j++)\\n          {\\n            if(words[i][j] != s[count]) return false;\\n            if(s.Length == ++count) return true;\\n          }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889013,
                "title": "java-easy-solution-using-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1=\"\";\\n        for(int i=0;i<words.length;i++){\\n            s1+=words[i];\\n            if(s.equals(s1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1=\"\";\\n        for(int i=0;i<words.length;i++){\\n            s1+=words[i];\\n            if(s.equals(s1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888183,
                "title": "python3-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        string = \\'\\'\\n        for i in words:\\n            string+=i\\n\\n        if len(s) > len(string):\\n            return False\\n        elif len(s) < len(words[0]):\\n            return False\\n        else:\\n            if len(s) <= len(string):\\n                count = 0\\n                k = 0\\n                while count < len(s):\\n                    count+= len(words[k])\\n                    k+=1\\n                if count != len(s):\\n                    return False\\n                elif s == string[:len(s)]:\\n                    return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        string = \\'\\'\\n        for i in words:\\n            string+=i\\n\\n        if len(s) > len(string):\\n            return False\\n        elif len(s) < len(words[0]):\\n            return False\\n        else:\\n            if len(s) <= len(string):\\n                count = 0\\n                k = 0\\n                while count < len(s):\\n                    count+= len(words[k])\\n                    k+=1\\n                if count != len(s):\\n                    return False\\n                elif s == string[:len(s)]:\\n                    return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886382,
                "title": "jav-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words)\\n\\t\\t \\n\\t\\t {\\n\\t\\t\\t  \\n\\t\\t\\t\\t\\n\\t\\t\\t StringBuilder sb = new StringBuilder(\"\");\\n        for (String str : words) {\\n            sb.append(str);\\n            if (sb.toString().startsWith(s) && s.length()>=sb.toString().length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\t\\t\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words)\\n\\t\\t \\n\\t\\t {\\n\\t\\t\\t  \\n\\t\\t\\t\\t\\n\\t\\t\\t StringBuilder sb = new StringBuilder(\"\");\\n        for (String str : words) {\\n            sb.append(str);\\n            if (sb.toString().startsWith(s) && s.length()>=sb.toString().length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\t\\t\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886296,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = \"\";\\n        for (auto i : words){\\n            str += i;\\n            if (str == s)\\n                return true;\\n        }         \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = \"\";\\n        for (auto i : words){\\n            str += i;\\n            if (str == s)\\n                return true;\\n        }         \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881325,
                "title": "1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        if(s.length() < words[0].length()){ return false;}\\n        StringBuilder stringBuilder = new StringBuilder();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            stringBuilder.append(words[i]);\\n            if(stringBuilder.toString().equals(s)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        if(s.length() < words[0].length()){ return false;}\\n        StringBuilder stringBuilder = new StringBuilder();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            stringBuilder.append(words[i]);\\n            if(stringBuilder.toString().equals(s)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880582,
                "title": "easy-and-simple-java-solution-stringbuilder-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb= new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            sb.append(words[i]);\\n            if(sb.toString().equals(s)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb= new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            sb.append(words[i]);\\n            if(sb.toString().equals(s)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876309,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) \\n    {\\n        String str=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            str=str+words[i];\\n            if(str.equals(s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) \\n    {\\n        String str=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            str=str+words[i];\\n            if(str.equals(s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869735,
                "title": "check-if-string-is-a-prefix-of-array-100-beats-easy-approach-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string s1=\"\",a=\"\";\\n        for(int i=0;i<words.size() && a.size()<s.size();i++){\\n            s1=s1+words[i];\\n            int b=s1.size();\\n            a=s.substr(0,b);\\n            cout<<b<<\":\"<<a.size()<<endl;\\n            if(a.size()!=b || a!=s1){\\n                return 0;\\n            }\\n        }\\n        if(s.size()!=s1.size()){\\n            return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string s1=\"\",a=\"\";\\n        for(int i=0;i<words.size() && a.size()<s.size();i++){\\n            s1=s1+words[i];\\n            int b=s1.size();\\n            a=s.substr(0,b);\\n            cout<<b<<\":\"<<a.size()<<endl;\\n            if(a.size()!=b || a!=s1){\\n                return 0;\\n            }\\n        }\\n        if(s.size()!=s1.size()){\\n            return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3851057,
                "title": "runtime-memory-42ms-16-42mb-beats-93-84-11-27-of-users-with-python3",
                "content": "# Intuition\\n1. Only need the count from `0` to `len(s)` for comparing.\\n# Approach\\n1. Get `s` length.\\n2. Extract and concatenate utils `s_len > 0`.\\n3. Compare `s` to `word_str`.\\n# Complexity\\n- Time complexity: N/A.\\n- Space complexity: N/A.\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        # 12:11.\\n        \\n        s_len = len(s)\\n        word_str = \\'\\'\\n\\n        for i in words:\\n            if s_len > 0:\\n                word_str += i\\n                s_len -= len(i)\\n            else:\\n                break\\n        \\n        if s == word_str:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        # 12:11.\\n        \\n        s_len = len(s)\\n        word_str = \\'\\'\\n\\n        for i in words:\\n            if s_len > 0:\\n                word_str += i\\n                s_len -= len(i)\\n            else:\\n                break\\n        \\n        if s == word_str:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851048,
                "title": "easy-to-under-stand-runtime-97-7-line",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : words) {\\n            sb.append(word);\\n            if (sb.length() == s.length()) break;\\n            else if (sb.length() > s.length()) return false;\\n        }\\n        return sb.toString().equals(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : words) {\\n            sb.append(word);\\n            if (sb.length() == s.length()) break;\\n            else if (sb.length() > s.length()) return false;\\n        }\\n        return sb.toString().equals(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841949,
                "title": "java-1ms-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n        int k = s.length();\\n        for(int i=0; i<words.length; i++){\\n            if(str.length() != k){\\n                str += words[i];\\n            }\\n        }\\n        if(str.equals(s)) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n        int k = s.length();\\n        for(int i=0; i<words.length; i++){\\n            if(str.length() != k){\\n                str += words[i];\\n            }\\n        }\\n        if(str.equals(s)) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835140,
                "title": "stringbuilder-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int sLength = s.length();\\n        int wLength = 0;\\n        int count = -1;\\n        StringBuilder sb = new StringBuilder();\\n        while (sLength > wLength && count < words.length -  1){\\n            wLength += words[++count].length();\\n            sb.append(words[count]);\\n        }\\n    return s.contentEquals(sb);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int sLength = s.length();\\n        int wLength = 0;\\n        int count = -1;\\n        StringBuilder sb = new StringBuilder();\\n        while (sLength > wLength && count < words.length -  1){\\n            wLength += words[++count].length();\\n            sb.append(words[count]);\\n        }\\n    return s.contentEquals(sb);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833976,
                "title": "easy-solution-in-cpp-beats-100",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        /*string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n        }\\n        string sub=str.substr(0,s.length());\\n        return sub==s;*/\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n            if(str==s)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        /*string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n        }\\n        string sub=str.substr(0,s.length());\\n        return sub==s;*/\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n            if(str==s)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824058,
                "title": "build-string-following-each-letter-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        string w = \"\";\\n\\n            foreach (string word in words)\\n            {\\n                w += word;\\n\\n                if (w == s)\\n                {\\n                    return true;\\n                }\\n\\n                if (w.Length > s.Length)\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        string w = \"\";\\n\\n            foreach (string word in words)\\n            {\\n                w += word;\\n\\n                if (w == s)\\n                {\\n                    return true;\\n                }\\n\\n                if (w.Length > s.Length)\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809449,
                "title": "click-on-this-solution-if-u-r-not-gay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n\\n        for(int i = 0; i < words.length; i++) {\\n            if(s.indexOf(words[i]) == -1) return false;\\n            str = str + words[i];\\n            if(s.equals(str)) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n\\n\\nUPVOTE IF YOU ARE NOT GAY",
                "solutionTags": [
                    "Java",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n\\n        for(int i = 0; i < words.length; i++) {\\n            if(s.indexOf(words[i]) == -1) return false;\\n            str = str + words[i];\\n            if(s.equals(str)) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808181,
                "title": "python-simple-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isPrefixString(self, s: str, words: List[str]) -> bool:\\n    concatenated_word = \\'\\'\\n    for word in words:\\n        concatenated_word += word\\n        if concatenated_word == s:\\n            return True\\n    return concatenated_word == s\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def isPrefixString(self, s: str, words: List[str]) -> bool:\\n    concatenated_word = \\'\\'\\n    for word in words:\\n        concatenated_word += word\\n        if concatenated_word == s:\\n            return True\\n    return concatenated_word == s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805837,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        //main string forming\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            str+=words[i];\\n            if(str==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        //main string forming\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            str+=words[i];\\n            if(str==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802806,
                "title": "check-if-string-is-a-prefix-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n       String str = new String();\\n       for(int i=0;i<words.length;i++)\\n       {\\n           str=str+words[i];\\n           if(s.equals(str))\\n           return true;\\n       }\\n       return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n       String str = new String();\\n       for(int i=0;i<words.length;i++)\\n       {\\n           str=str+words[i];\\n           if(s.equals(str))\\n           return true;\\n       }\\n       return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796551,
                "title": "easy-brute-force-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExample:\\n```\\ns = \"xyzabcdef\"\\nwords = {\"xyz\", \"abc\", \"def\"}\\n```\\n\\nTracing the code step-by-step:\\n\\n1. Initialize `comp` to an empty string, `i = 0`, `j = 0`, and `k = 0`.\\n2. Enter the `for` loop with `i = 0` and `k = 0`.\\n3. Set `size = words[0].size() - 1 = 2`.\\n4. Enter the `while` loop with `j = 0`.\\n5. Compare `s[k]` and `words[0][j]`, both are \\'x\\'.\\n6. Increment `k` and `j`.\\n7. Compare `s[k]` and `words[0][j]`, both are \\'y\\'.\\n8. Increment `k` and `j`.\\n9. Compare `s[k]` and `words[0][j]`, both are \\'z\\'.\\n10. Increment `k` and `j`.\\n\\nAt this point, the while loop ends because `j` becomes `3`, which is equal to `size + 1`. The first word \"xyz\" matches the prefix of the string `s`. The updated value of `k` is `3`.\\n\\n11. Continue with the next word.\\n12. Set `size = words[1].size() - 1 = 2`.\\n13. Enter the `while` loop with `j = 0`.\\n14. Compare `s[k]` and `words[1][j]`, `s[k]` is \\'a\\', and `words[1][j]` is \\'a\\'.\\n**...........**\\nThis will continue till either of the string\\'s end.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string comp = \"\";\\n        int i = 0, j = 0,k = 0; \\n\\n        for(;i < words.size() && k < s.size(); i++){\\n            int size = words[i].size() - 1;\\n            j = 0;\\n            if(s.size() - k < words[i].size())\\n                return false;\\n            while(j <= size){\\n                if(s[k] != words[i][j] ){\\n                    cout<<\"val = \"<<s[k]<<\" == \"<<words[i][j]<<endl;\\n                    return false;\\n                }\\n                k++;\\n                j++;\\n            }\\n        }\\n        if(k < s.size())\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ns = \"xyzabcdef\"\\nwords = {\"xyz\", \"abc\", \"def\"}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string comp = \"\";\\n        int i = 0, j = 0,k = 0; \\n\\n        for(;i < words.size() && k < s.size(); i++){\\n            int size = words[i].size() - 1;\\n            j = 0;\\n            if(s.size() - k < words[i].size())\\n                return false;\\n            while(j <= size){\\n                if(s[k] != words[i][j] ){\\n                    cout<<\"val = \"<<s[k]<<\" == \"<<words[i][j]<<endl;\\n                    return false;\\n                }\\n                k++;\\n                j++;\\n            }\\n        }\\n        if(k < s.size())\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3794443,
                "title": "basic-java-soln-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        if(s.charAt(0)!=words[0].charAt(0)||s.length()<words[0].length())\\n            return false;\\n        StringBuilder str=new StringBuilder();\\n        for(String i:words){\\n            str.append(i);\\n            if(s.indexOf(str.toString())!=0)\\n                return false;\\n            if(s.equals(str.toString()))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        if(s.charAt(0)!=words[0].charAt(0)||s.length()<words[0].length())\\n            return false;\\n        StringBuilder str=new StringBuilder();\\n        for(String i:words){\\n            str.append(i);\\n            if(s.indexOf(str.toString())!=0)\\n                return false;\\n            if(s.equals(str.toString()))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790361,
                "title": "c-beats-100-in-time-space-characterwise-comparision",
                "content": "# Complexity\\n- Time complexity: O(min(n, N))\\nwhere n = length of string s\\nand N = sum of length of all words in the given array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i,j,n, k=0, N=s.length();\\n        for(i=0; i<words.size() && k<N; i++){\\n            n = words[i].length();\\n            for(j=0; j<n && k<N; j++){\\n                if(s[k++] != words[i][j])\\n                    return false;\\n            }\\n            if(j<n)\\n                return false;\\n        }\\n        return k==N;\\n    } \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i,j,n, k=0, N=s.length();\\n        for(i=0; i<words.size() && k<N; i++){\\n            n = words[i].length();\\n            for(j=0; j<n && k<N; j++){\\n                if(s[k++] != words[i][j])\\n                    return false;\\n            }\\n            if(j<n)\\n                return false;\\n        }\\n        return k==N;\\n    } \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765221,
                "title": "c-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& w) {\\n        string s1;\\n        for(int i=0;i<w.size();i++){\\n            s1 += w[i];\\n            if(s1==s)return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& w) {\\n        string s1;\\n        for(int i=0;i<w.size();i++){\\n            s1 += w[i];\\n            if(s1==s)return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755964,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder prefix = new StringBuilder();\\n\\n        for(String word: words )\\n        {\\n            prefix.append(word);\\n\\n            if(prefix.toString().equals(s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder prefix = new StringBuilder();\\n\\n        for(String word: words )\\n        {\\n            prefix.append(word);\\n\\n            if(prefix.toString().equals(s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750622,
                "title": "java-easy-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n       String arr=\"\";\\n       for(String word:words)\\n       {\\n           arr+=word;\\n           if(s.equals(arr))\\n           {\\n               return true;\\n           }\\n       }\\n       return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n       String arr=\"\";\\n       for(String word:words)\\n       {\\n           arr+=word;\\n           if(s.equals(arr))\\n           {\\n               return true;\\n           }\\n       }\\n       return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748023,
                "title": "java-solution-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.length() == 0) return true;\\n            if (s.startsWith(words[i])) {\\n                s = s.substring(words[i].length());\\n            } else {\\n                break;\\n            }\\n        }\\n        if (s.length() != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.length() == 0) return true;\\n            if (s.startsWith(words[i])) {\\n                s = s.substring(words[i].length());\\n            } else {\\n                break;\\n            }\\n        }\\n        if (s.length() != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741888,
                "title": "python-bruteforce-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        sub_str = \"\"\\n        sum = 0\\n        for i in range(len(words)):\\n            word = words[i]\\n            sub_str += word\\n            sum += len(word)\\n            if sum == len(s):\\n                break\\n        if sub_str == s:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        sub_str = \"\"\\n        sum = 0\\n        for i in range(len(words)):\\n            word = words[i]\\n            sub_str += word\\n            sum += len(word)\\n            if sum == len(s):\\n                break\\n        if sub_str == s:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737663,
                "title": "dead-easy-ts-js-o-n-solution-no-need-for-o-n-2",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First and foremost, check if the first word in the array is actually a substring of the provided string. If not, return early.\\n- Initialize a variable that holds our comparison word to an empty string\\n- initialize a loop\\n  - Concatenate to our comparison string\\n  - Check if our current comparison string is equal to our provided string\\n  - If true, return true early.\\n\\nThe advantage of this is that we save some **computational power** when we return early, as opposed to `words.join(\\'\\')` which runs through the entire words array as it performs a join operation.\\n>NB: accessing an index in an array is $$O(1)$$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\nfunction isPrefixString(s: string, words: string[]): boolean {\\n    // check if first word in array is an actual prefix of the word\\n    if(words[0] !== s.substring(0, words[0].length)) {\\n        return false;\\n    }\\n\\n    let conWord = \\'\\'\\n    for(let i=0; i<words.length; i++) {\\n        conWord += words[i];\\n\\n        // check if s is equal to the current concatenated string\\n        if(s === conWord) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrefixString(s: string, words: string[]): boolean {\\n    // check if first word in array is an actual prefix of the word\\n    if(words[0] !== s.substring(0, words[0].length)) {\\n        return false;\\n    }\\n\\n    let conWord = \\'\\'\\n    for(let i=0; i<words.length; i++) {\\n        conWord += words[i];\\n\\n        // check if s is equal to the current concatenated string\\n        if(s === conWord) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730197,
                "title": "simple-c-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code checks if the concatenation of the words in the vector \"words\" forms the given string \"s\" as a prefix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code iteratively concatenates the strings from the vector \"words\" and checks if the resulting sentence matches the given string \"s\" as a prefix.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    \\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int count = 0;\\n        string sentence;\\n        for(int i = 0; i < words.size(); i++){\\n            sentence += words[i];\\n            if(sentence == s){\\n                return true;\\n            }\\n        }    \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int count = 0;\\n        string sentence;\\n        for(int i = 0; i < words.size(); i++){\\n            sentence += words[i];\\n            if(sentence == s){\\n                return true;\\n            }\\n        }    \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729977,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        // \\n        String res = \"\";\\n        for(String word : words){\\n            res += word;\\n            if(s.equals(res)){\\n                return true;\\n            }\\n            if(s.indexOf(res)==-1){\\n                return false;\\n            }\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        // \\n        String res = \"\";\\n        for(String word : words){\\n            res += word;\\n            if(s.equals(res)){\\n                return true;\\n            }\\n            if(s.indexOf(res)==-1){\\n                return false;\\n            }\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728097,
                "title": "solution-using-the-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is an Quite easy approach which can be understand by anyone\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        b=len(s)\\n        c=\\'\\'\\n        for x in words:\\n            if len(c)==len(s):\\n                break\\n            else:\\n                c+=x\\n        return c==s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        b=len(s)\\n        c=\\'\\'\\n        for x in words:\\n            if len(c)==len(s):\\n                break\\n            else:\\n                c+=x\\n        return c==s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716840,
                "title": "cpp-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOPTIMIZED SOLUTION\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string str=\"\";\\n        for(i=0; i<words.size(); i++){\\n            str+=words[i];\\n            if(str==s){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string str=\"\";\\n        for(i=0; i<words.size(); i++){\\n            str+=words[i];\\n            if(str==s){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698083,
                "title": "c-beginner-friendly-solution-only-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n            if(s==str){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n            if(s==str){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696804,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& arr) {\\n        unordered_map<char, bool> m;\\n        for(int i = 0; i < s.length(); i++){\\n            m[s[i]] = true;\\n        }\\n        string ans = \"\";\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < arr[i].length(); j++){\\n                if(!m[arr[i][j]]) return false;\\n                else ans += arr[i][j];\\n            }\\n            if(s == ans) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& arr) {\\n        unordered_map<char, bool> m;\\n        for(int i = 0; i < s.length(); i++){\\n            m[s[i]] = true;\\n        }\\n        string ans = \"\";\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < arr[i].length(); j++){\\n                if(!m[arr[i][j]]) return false;\\n                else ans += arr[i][j];\\n            }\\n            if(s == ans) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684736,
                "title": "100-runtime-beats-easiest-solution",
                "content": "\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = words[0];\\n        if(str==s){\\n            return true;\\n        }\\n       \\n        for(int i=1;i<words.size();i++){\\n            if(str==s){\\n                return true;\\n            }\\n            for(int j=0;j<words[i].length();j++){\\n                str.push_back(words[i][j]);\\n            }\\n        }\\n        if(str==s){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = words[0];\\n        if(str==s){\\n            return true;\\n        }\\n       \\n        for(int i=1;i<words.size();i++){\\n            if(str==s){\\n                return true;\\n            }\\n            for(int j=0;j<words[i].length();j++){\\n                str.push_back(words[i][j]);\\n            }\\n        }\\n        if(str==s){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683942,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n  let compStr = \"\";\\n  for(let i=0;i<words.length;i++){\\n    compStr += words[i]\\n    if(compStr===s){\\n      return true\\n    }\\n  }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n  let compStr = \"\";\\n  for(let i=0;i<words.length;i++){\\n    compStr += words[i]\\n    if(compStr===s){\\n      return true\\n    }\\n  }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678017,
                "title": "0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int n = words.size(), m = s.length(), k = 0;\\n        if(m < words[0].length()) return false;  \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < words[i].length();){\\n                if(k < m && s[k++]!=words[i][j++]){\\n                    cout << words[i][j] << endl;\\n                    cout << j << \" \" << k << endl;\\n                return false;\\n                } \\n                if(k==m && (j > 0 && j < words[i].length())){\\n                    return false;\\n                } \\n                if(k==m) break;\\n            }\\n        }\\n        if(k < m) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int n = words.size(), m = s.length(), k = 0;\\n        if(m < words[0].length()) return false;  \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < words[i].length();){\\n                if(k < m && s[k++]!=words[i][j++]){\\n                    cout << words[i][j] << endl;\\n                    cout << j << \" \" << k << endl;\\n                return false;\\n                } \\n                if(k==m && (j > 0 && j < words[i].length())){\\n                    return false;\\n                } \\n                if(k==m) break;\\n            }\\n        }\\n        if(k < m) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3677253,
                "title": "c-easy-solution-runtime-0ms-beats-100",
                "content": "# Please UPVOTE this!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind all possible pairs and simultaneously verify that our string is similar to given string or not.\\nIf yes then return true, otherwise return false.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {       \\n        for(int i=0; i<words.size(); i++){\\n            string str=\"\";\\n            for(int j=0; j<=i; j++){\\n                str+=words[j];\\n            }\\n            if(str==s)  return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {       \\n        for(int i=0; i<words.size(); i++){\\n            string str=\"\";\\n            for(int j=0; j<=i; j++){\\n                str+=words[j];\\n            }\\n            if(str==s)  return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665401,
                "title": "python-easy-solution-tracking-current-prefix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        target_char_set = len(s)\\n        current_prefix = \"\"\\n\\n        for word in words:\\n            current_prefix += word\\n            if current_prefix == s:\\n                return True\\n            if len(current_prefix) >= target_char_set:\\n                return False\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        target_char_set = len(s)\\n        current_prefix = \"\"\\n\\n        for word in words:\\n            current_prefix += word\\n            if current_prefix == s:\\n                return True\\n            if len(current_prefix) >= target_char_set:\\n                return False\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656588,
                "title": "easy-solution-with-understandable-explanation",
                "content": "# Complexity\\n![image.png](https://assets.leetcode.com/users/images/88dc1249-247b-4340-9d1b-056b8006efca_1687173193.369893.png)\\n\\n# Approach\\nFirst I try by simply join the array and compare it from start to length. Its cleared the initial testcase but failed at this case:\\n\"a\";\\n{\"aa\", \"aaaa\", \"banana\"}\\n\\nthen I understand that have to check it on each append of array\\'s element.\\n\\n# Upvote Plz\\n\\n# Code\\n```\\npublic class Solution {\\n  public bool IsPrefixString(string s, string[] words)\\n    {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0; i<words.Count();i++)\\n            {\\n                sb.Append(words[i]);\\n                if (s == sb.ToString())return true;\\n            }\\n            return false;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public bool IsPrefixString(string s, string[] words)\\n    {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0; i<words.Count();i++)\\n            {\\n                sb.Append(words[i]);\\n                if (s == sb.ToString())return true;\\n            }\\n            return false;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646126,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string temp;\\n        for(int i=0;i<words.size();i++){\\n            temp+=words[i];\\n            if(temp.length()>s.length()){\\n                return false;\\n            }\\n            else if(temp==s){\\n                return true;\\n            }\\n            else{continue;}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string temp;\\n        for(int i=0;i<words.size();i++){\\n            temp+=words[i];\\n            if(temp.length()>s.length()){\\n                return false;\\n            }\\n            else if(temp==s){\\n                return true;\\n            }\\n            else{continue;}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1853624,
                "content": [
                    {
                        "username": "Gangeswaran",
                        "content": "Don\\'t underestimate easy problems, Problem looks easy but missed to read the question properly which caused a bit more time than usual.."
                    },
                    {
                        "username": "anacmartins",
                        "content": "i cannot get why s = \"ccccccccc\" and words = [\"c\",\"cc\"] is false."
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I guess we got confused by termin `prefix`, actually while concatenating through the array at some point concatenated string should be exactly equal to `s` string"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "same here"
                    },
                    {
                        "username": "anacmartins",
                        "content": "is it false because in the end there are some characters left on s with no match in words?"
                    },
                    {
                        "username": "youngaryan",
                        "content": "why it expects these two to return false?\\n {\\n\"fajsldfsa\"\\n[\"faj\",\"s\",\"ldfs\",\"afdfs\",\"jfkdlsj\",\"f\"]\\n}\\n{\\n\"aaa\"\\n[\"aa\",\"aaa\",\"fjaklfj\"]\\n}"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "[@youngaryan](/youngaryan) How i am not able to get it \\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "I approched in a wrong way, i fixed it"
                    }
                ]
            },
            {
                "id": 1862180,
                "content": [
                    {
                        "username": "Gangeswaran",
                        "content": "Don\\'t underestimate easy problems, Problem looks easy but missed to read the question properly which caused a bit more time than usual.."
                    },
                    {
                        "username": "anacmartins",
                        "content": "i cannot get why s = \"ccccccccc\" and words = [\"c\",\"cc\"] is false."
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I guess we got confused by termin `prefix`, actually while concatenating through the array at some point concatenated string should be exactly equal to `s` string"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "same here"
                    },
                    {
                        "username": "anacmartins",
                        "content": "is it false because in the end there are some characters left on s with no match in words?"
                    },
                    {
                        "username": "youngaryan",
                        "content": "why it expects these two to return false?\\n {\\n\"fajsldfsa\"\\n[\"faj\",\"s\",\"ldfs\",\"afdfs\",\"jfkdlsj\",\"f\"]\\n}\\n{\\n\"aaa\"\\n[\"aa\",\"aaa\",\"fjaklfj\"]\\n}"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "[@youngaryan](/youngaryan) How i am not able to get it \\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "I approched in a wrong way, i fixed it"
                    }
                ]
            },
            {
                "id": 2005444,
                "content": [
                    {
                        "username": "Gangeswaran",
                        "content": "Don\\'t underestimate easy problems, Problem looks easy but missed to read the question properly which caused a bit more time than usual.."
                    },
                    {
                        "username": "anacmartins",
                        "content": "i cannot get why s = \"ccccccccc\" and words = [\"c\",\"cc\"] is false."
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I guess we got confused by termin `prefix`, actually while concatenating through the array at some point concatenated string should be exactly equal to `s` string"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "same here"
                    },
                    {
                        "username": "anacmartins",
                        "content": "is it false because in the end there are some characters left on s with no match in words?"
                    },
                    {
                        "username": "youngaryan",
                        "content": "why it expects these two to return false?\\n {\\n\"fajsldfsa\"\\n[\"faj\",\"s\",\"ldfs\",\"afdfs\",\"jfkdlsj\",\"f\"]\\n}\\n{\\n\"aaa\"\\n[\"aa\",\"aaa\",\"fjaklfj\"]\\n}"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "[@youngaryan](/youngaryan) How i am not able to get it \\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "I approched in a wrong way, i fixed it"
                    }
                ]
            }
        ]
    }
]