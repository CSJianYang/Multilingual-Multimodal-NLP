[
    {
        "title": "Sum of Root To Leaf Binary Numbers",
        "question_content": "You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\n\tFor example, if the path is 0 -> 1 -> 1 -> 0 -> 1, then this could represent 01101 in binary, which is 13.\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.\nThe test cases are generated so that the answer fits in a 32-bits integer.\n&nbsp;\nExample 1:\n\nInput: root = [1,0,1,0,1,0,1]\nOutput: 22\nExplanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\nExample 2:\n\nInput: root = [0]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 1000].\n\tNode.val is 0 or 1.",
        "solutions": [
            {
                "id": 270025,
                "title": "java-c-python-recursive-solution",
                "content": "## **Intuition**\\nEasily decompose this problem into 2 sub-problem:\\n1. Find all path from root to leaves. DFS recursion should help do that.\\n2. Transform a path from base to base 10.\\n\\nYou can do this separately, and it will be a `O(N^2)` solution.\\nIn my solution, I combine them together.\\n\\n\\n## **Explanation**:\\nWe recursively pass the current value of path to the children.\\nIf `root == null`, no value, return 0.\\nIf `root != null`,\\nwe double the value from its parent and add the node\\'s value,\\nlike the process of transforming base 2 to base 10.\\n\\nIn the end of recursion,\\nif `root.left == root.right == null`,\\nreturn the current `val`.\\n<br>\\n\\n## **Complexity**:\\nTime `O(N)`\\nSpace `O(H)` for recursion.\\n<br>\\n\\n**Java:**\\n```\\n    public int sumRootToLeaf(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    public int dfs(TreeNode root, int val) {\\n        if (root == null) return 0;\\n        val = val * 2 + root.val;\\n        return root.left == root.right ? val : dfs(root.left, val) + dfs(root.right, val);\\n    }\\n```\\n\\n**C++:**\\n```\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n    }\\n```\\n\\n**Python:**\\n```\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0\\n        val = val * 2 + root.val\\n        if root.left == root.right: return val\\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val)\\n```\\n\\n**Update 2019-04-08**\\nIn the previous version of problem,\\nthe length of path may exceed 32 and it will be a huge integer.\\nSo it request to return the number mod by 10^9+7.\\nNow it notes that The \"answer will not exceed 2^31 - 1.\"\\nNow it removes this condition to keep this problem as a easy one.",
                "solutionTags": [],
                "code": "```\\n    public int sumRootToLeaf(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    public int dfs(TreeNode root, int val) {\\n        if (root == null) return 0;\\n        val = val * 2 + root.val;\\n        return root.left == root.right ? val : dfs(root.left, val) + dfs(root.right, val);\\n    }\\n```\n```\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n    }\\n```\n```\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0\\n        val = val * 2 + root.val\\n        if root.left == root.right: return val\\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1681682,
                "title": "well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n\\n\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\nSo, here in this problem what we have to do all the nodes will have either **0** or **1**. So, starting from **root node** and traverse the tree, when you traverse the tree and you reach **leaf node** return the **sum** in binary from root to leaf in & return in **decimal numbers**\\n\\n**Approach Explained :**\\n\\n**Summary :**\\nLet us traverse our tree and change values of nodes, so when we reach leaf we will have in this leaf exactly the number we need to add to total sum. Imagine, we have path 10110, then let us look at sequence: 1, 10, 101, 1011, 10110, which is equivalent to 1, 2, 5, 11, 22.\\n\\n* If we reached leaf, add value of this leaf to total sum.\\n* Check left and right children and if they exist, update their values; run dfs for these children.\\n\\n**Detailed Explanation :**\\nLet\\'s understand with an example tree,\\n\\n![image](https://assets.leetcode.com/users/images/29584bd5-5449-4147-92d3-18ec1067f27a_1641864447.0021555.png)\\n\\n\\nIf we go from **1 to 0** i.e **left child** & similar for **1 to 1** i.e. **right child** and similar till leaf node. Overall there are 4 leafs path. So, we will have **4 root to leaf path**. So, one is **1 -> 0 -> 0** this left most path, second is **1 -> 0 -> 1** this is 2nd path, then **1 -> 1 -> 0** this is 3rd path & the last **1 -> 1 -> 1** 4th path. \\nSo, these all are the root to leaf path we have and these are **binary representation**. So, if we **convert** them to **decimal** they will become **4, 5, 6, 7**. And **sum** them up which is **22**. and we have to **return 22** as the answer.\\n\\nSo,  first of all when we are converting **binary** no **to** the **decimal**, what we will do we will start from the least significant bit & multiply it with **2^0** with **whatever** **no**. present there, then **2^1 with whatever no**. there & then **2^2** **with whatever no** and **add** them. So, this is how it become **1 * 4 + 2 * 0 + 1 * 0** which is equals to **4** and similar for other as well. So, this is the basic idea what we  have & we use this idea over here.\\n`Let me show you in a diagram, what i mean`\\n![image](https://assets.leetcode.com/users/images/29517c99-2b04-4ebc-b707-89a37c56e335_1641865327.2959735.png)\\n\\n\\nOne of the **brute force idea to solve this** is like, 1st generate all the binary representation root to leaf path. Either store it as a list of list of integer or list of string & then convert after finding all the root to leaf path & convert each path to the decimal and then accumulate the sum and return. So, this is like a brute force solution.\\n\\nBut, we will make use of **recursion** to solve this problem.\\nAnd for traversing on each nodes we will use help of **PreOrder traversal**. Which states **\"n l r\"** i.e. **node - left - right**\\n\\nI hope all point\\'s are clear,\\n**Now let\\'s code it:**\\n\\n*code each n every line explain :* `Similar for C++. Java. Python` **{Only Syntax Difference}** approach same\\n\\nStep 1 :\\n```\\n{// call to a preorder traversal function & passing the value root node & sum variable intialize with 0;\\n        return sumRootToLeaf(root, 0); \\n```\\nStep 2 :\\n```\\nint sumRootToLeaf(TreeNode root, int sum){ // calling the helper method\\n        // base condition\\n        if(root == null) return 0; // first we will check if root is null, then there is no node, simply return 0;\\n        sum = (2 * sum) + root.val; // calculate sum of binary no.s into decimal no.s\\n        // checking if, current node we are processing is leaf & both left & right child node are null, if that\\'s the case return sum;\\n        if(root.left == null && root.right == null) return sum;\\n        // and finally we will call both left subtree & right subtree and add them up\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n```\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    public int sumRootToLeaf(TreeNode root, int sum){\\n        if(root == null) return 0;\\n        sum = (2 * sum) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\n    int sumRootToLeaf(TreeNode* root, int sum){\\n        if(!root) return 0;\\n        sum = (2 * sum) + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumRootToLeaf(root->left, sum) + sumRootToLeaf(root->right, sum);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    \\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def sumRootToLeaf(root, res): # here; \"res\" is \"sum\"\\n            if root == None: return 0\\n            res = (2 * res) + root.val\\n            if root.left == None and root.right == None: return res\\n            return sumRootToLeaf(root.left, res) + sumRootToLeaf(root.right, res)\\n        \\n        return sumRootToLeaf(root, 0)\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N) where N is a number of nodes, since one has to visit each node.\\n\\n* **Space Complexity :-** BigO(H) where H is height of tree, Considering recursion stack it in O(H), if we dont consider it. Then O(1)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n{// call to a preorder traversal function & passing the value root node & sum variable intialize with 0;\\n        return sumRootToLeaf(root, 0); \\n```\n```\\nint sumRootToLeaf(TreeNode root, int sum){ // calling the helper method\\n        // base condition\\n        if(root == null) return 0; // first we will check if root is null, then there is no node, simply return 0;\\n        sum = (2 * sum) + root.val; // calculate sum of binary no.s into decimal no.s\\n        // checking if, current node we are processing is leaf & both left & right child node are null, if that\\'s the case return sum;\\n        if(root.left == null && root.right == null) return sum;\\n        // and finally we will call both left subtree & right subtree and add them up\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n```\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    public int sumRootToLeaf(TreeNode root, int sum){\\n        if(root == null) return 0;\\n        sum = (2 * sum) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int sumRootToLeaf(TreeNode* root, int sum){\\n        if(!root) return 0;\\n        sum = (2 * sum) + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumRootToLeaf(root->left, sum) + sumRootToLeaf(root->right, sum);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n    \\n};\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def sumRootToLeaf(root, res): # here; \"res\" is \"sum\"\\n            if root == None: return 0\\n            res = (2 * res) + root.val\\n            if root.left == None and root.right == None: return res\\n            return sumRootToLeaf(root.left, res) + sumRootToLeaf(root.right, res)\\n        \\n        return sumRootToLeaf(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270600,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    \\n    int ans = 0;\\n    void dfs(TreeNode root, int val){\\n        if(root == null) return;\\n        val = val << 1 | root.val;\\n        if(root.left == null && root.right == null) ans += val;\\n        dfs(root.left, val);\\n        dfs(root.right, val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    \\n    int ans = 0;\\n    void dfs(TreeNode root, int val){\\n        if(root == null) return;\\n        val = val << 1 | root.val;\\n        if(root.left == null && root.right == null) ans += val;\\n        dfs(root.left, val);\\n        dfs(root.right, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835906,
                "title": "c-2-solutions-recursive-iterative-dfs-explained-left-shift-and-simple-math",
                "content": "**Explanation**\\nThe key here is tree traversal and generating the numbers as we go from the root towards the leaves.\\nUsing shift operators, we can always keep the current value, `cur_val` in base 10 and as soon as we reach any leaf, we add this current value to the running answer.\\n\\n`cur_val = (cur_val << 1) | rt->val;`\\n`cur_val << 1` means we\\'re shifting the bits of `cur_val` to the left by 1 place, which is equivalent to multiplying `cur_val` by 2 (in base 10). Bitwise OR is used to set a particular bit. Let\\'s take an example!\\nSuppose, the root-to-leaf path is `1->0->1`.\\nThen, at the root, initially `cur_val` is 0. We multiply it by 2 and perform bitwise OR with 1 which makes `cur_val` 1.\\nNext, `cur_val` is 1. We multiply it by 2 and perform bitwise OR with 0 which makes `cur_val` 2.\\nLast, at the leaf, `cur_val` is 2. We multiply it by 2 and perform bitwise OR with 1 which makes `cur_val` 5.\\n101 (base 2) is 5 (base 10).\\n\\n----------------------------------------------\\n\\n**Recursive Code (using Left Shift operator)**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeafHelper(TreeNode* rt, int cur_val) {\\n        if(! rt) return 0;\\n        \\n        cur_val = (cur_val << 1) | rt->val;\\n        \\n        if(!rt->left && !rt->right)\\n\\t\\t\\treturn cur_val;\\n\\t\\t\\t\\n        return sumRootToLeafHelper(rt->left, cur_val) + sumRootToLeafHelper(rt->right, cur_val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* rt) {\\n        return sumRootToLeafHelper(rt, 0);\\n    }\\n};\\n```\\n\\n-------------\\n\\nWe can also combine these two functions in the same given function using a default argument to get an even more compact solution (Credits to [@guybrush2323](https://leetcode.com/guybrush2323/ )):\\n\\n```\\nstatic int sumRootToLeaf(const TreeNode* r, uint32_t sum = 0) {\\n        if (!r) return 0;\\n        sum |= r->val;\\n        if (!r->left && !r->right) return sum; // leaf\\n        sum <<= 1;\\n        return sumRootToLeaf(r->left, sum) + sumRootToLeaf(r->right, sum);\\n}\\n```\\n\\n------------------------------------------------------\\n\\n**Iterative Code (using Simple Math)**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* rt) {\\n        if(! rt) return 0;\\n        \\n        int ans = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        st.push({rt,0});\\n        \\n        while(! st.empty()) {\\n            auto curp = st.top(); st.pop();\\n            TreeNode* cur = curp.first;\\n            int cur_val = curp.second;\\n            \\n            // Equivalent to left shift by 1 and then ORing by cur->val.\\n            cur_val = cur_val*2 + cur->val;\\n            \\n            if(!cur->left && !cur->right)\\n                ans += cur_val;\\n            \\n            if(cur->left) st.push({cur->left, cur_val});\\n            if(cur->right) st.push({cur->right, cur_val});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n----------------------------------------\\nPlease feel free to ask your doubts in the comments. Please **Upvote** to help others!\\nHave a great day!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeafHelper(TreeNode* rt, int cur_val) {\\n        if(! rt) return 0;\\n        \\n        cur_val = (cur_val << 1) | rt->val;\\n        \\n        if(!rt->left && !rt->right)\\n\\t\\t\\treturn cur_val;\\n\\t\\t\\t\\n        return sumRootToLeafHelper(rt->left, cur_val) + sumRootToLeafHelper(rt->right, cur_val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* rt) {\\n        return sumRootToLeafHelper(rt, 0);\\n    }\\n};\\n```\n```\\nstatic int sumRootToLeaf(const TreeNode* r, uint32_t sum = 0) {\\n        if (!r) return 0;\\n        sum |= r->val;\\n        if (!r->left && !r->right) return sum; // leaf\\n        sum <<= 1;\\n        return sumRootToLeaf(r->left, sum) + sumRootToLeaf(r->right, sum);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* rt) {\\n        if(! rt) return 0;\\n        \\n        int ans = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        st.push({rt,0});\\n        \\n        while(! st.empty()) {\\n            auto curp = st.top(); st.pop();\\n            TreeNode* cur = curp.first;\\n            int cur_val = curp.second;\\n            \\n            // Equivalent to left shift by 1 and then ORing by cur->val.\\n            cur_val = cur_val*2 + cur->val;\\n            \\n            if(!cur->left && !cur->right)\\n                ans += cur_val;\\n            \\n            if(cur->left) st.push({cur->left, cur_val});\\n            if(cur->right) st.push({cur->right, cur_val});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681811,
                "title": "c-simple-intuitive-dfs-solution-w-explanation",
                "content": "* We are given a binary tree with all node values as ```0```s and ```1```s.\\n* For all leaves in the tree, we need to sum the numbers represented by the path from the root to that leaf and return the sum of these numbers.\\n\\n**Explanation :**\\nIf we\\'re given a binary number, say ```num = 11010```, we know how to convert it into decimal form while traversing from right to left.\\nWe can do this while traversing from left to right also. \\nWe start with  x=0, as long as we have bits left, repeat the following : \\n      1. Double the number  x . Remove the first bit (most significant) and add it to x . \\n      2. When this ends, return  x .\\nExample : \\n```\\nn = \\'100110\\',    x = 0\\nn =  \\'00110\\',    x = 0*2 + 1 = 1\\nn =   \\'0110\\',    x = 1*2 + 0 = 2\\nn =    \\'110\\',    x = 2*2 + 0 = 4\\nn =     \\'10\\',    x = 4*2 + 1 = 9\\nn =      \\'0\\',    x = 9*2 + 1 = 19\\nn =      \\' \\',    x = 19*2 +0 = 38\\n```\\n\\nKnowing this, this problem can be solved using simple DFS.\\n\\n**ALGORITHM :**\\n* Initialize ```ans = 0``` and ```buff=0```.\\n* The integer ```buff``` is passed as an argument to the function ```bfs(root, buff)``` and whenever we reach a leaf node, the decimal number stored by buffer is added to ```ans``` and we traverse for the next node (ie., parent\\'s right node).\\n* After we\\'ve traversed the whole tree, we return the ```ans```.\\n\\nTime Complexity : O(N) (Each node is visited at most 3 times, one while calling the method on the root and 2 visits when returning from the root\\u2019s left and right recursion calls. So overall time complexity will be linear only.)\\n\\nSpace Complexity : O(1) (Exclusing the recursive stack space)\\n\\n**Code :**\\n```\\nclass Solution {\\n    int ans=0;\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int buff = 0;\\n        dfs(root, buff);\\n        return ans;    \\n    }\\n    \\n    void dfs(TreeNode *root, int buff){\\n        buff = buff*2 + root->val;\\n        if(!root->left && !root->right){\\n            ans += buff;\\n            return;\\n        }\\n        if(root->left) dfs(root->left, buff);\\n        if(root->right) dfs(root->right, buff);\\n    }\\n};\\n```\\n\\n**If you like my solution & explanation, please upvote my post :)**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```0```\n```1```\n```num = 11010```\n```\\nn = \\'100110\\',    x = 0\\nn =  \\'00110\\',    x = 0*2 + 1 = 1\\nn =   \\'0110\\',    x = 1*2 + 0 = 2\\nn =    \\'110\\',    x = 2*2 + 0 = 4\\nn =     \\'10\\',    x = 4*2 + 1 = 9\\nn =      \\'0\\',    x = 9*2 + 1 = 19\\nn =      \\' \\',    x = 19*2 +0 = 38\\n```\n```ans = 0```\n```buff=0```\n```buff```\n```bfs(root, buff)```\n```ans```\n```ans```\n```\\nclass Solution {\\n    int ans=0;\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int buff = 0;\\n        dfs(root, buff);\\n        return ans;    \\n    }\\n    \\n    void dfs(TreeNode *root, int buff){\\n        buff = buff*2 + root->val;\\n        if(!root->left && !root->right){\\n            ans += buff;\\n            return;\\n        }\\n        if(root->left) dfs(root->left, buff);\\n        if(root->right) dfs(root->right, buff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339306,
                "title": "python-iterative-and-recursive-with-comments",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Logic 1: Recursive traverse - 100 pass 63% faster\\n        \\n        # Collect all the path in binary in a list\\n        self.path_to_leaf = []\\n        # Track total binary sum and return result\\n        self.total_binary_sum = 0\\n        \\n        # Traverse tree function\\n        def traverse(node, path):\\n            # If not leaf node, record the path left or right\\n            if node.left:\\n                traverse(node.left, path+str(node.val))\\n            if node.right:\\n                traverse(node.right, path+str(node.val))\\n            \\n            # Leaf node detect and record path\\n            if not node.left and not node.right:\\n                path += str(node.val)\\n                self.path_to_leaf.append(path)\\n                self.total_binary_sum += int(path, 2)\\n        \\n        traverse(root, \"\")\\n        print(self.path_to_leaf)\\n        return self.total_binary_sum\\n```\\n\\n```python\\n        # Logic 2: Iterative method - 100 pass 83 percent faster\\n        # * Each element of the list has the node and the path to it\\n        \\n        stack = [[root, \"\"]] # iteration to keep track\\n        result = 0 # result holder\\n        \\n        # Traverse nodes by stacking them\\n        while stack:\\n            # current node and path tracking\\n            current, path = stack.pop(0)\\n            \\n            # traverse with path \\n            if current.left:\\n                stack.append([current.left, path+str(current.val)])\\n            if current.right:\\n                stack.append([current.right, path+str(current.val)])\\n            \\n            # leaf node condition when we update result\\n            if not current.left and not current.right:\\n                path += str(current.val)\\n                result += int(path, 2)\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Logic 1: Recursive traverse - 100 pass 63% faster\\n        \\n        # Collect all the path in binary in a list\\n        self.path_to_leaf = []\\n        # Track total binary sum and return result\\n        self.total_binary_sum = 0\\n        \\n        # Traverse tree function\\n        def traverse(node, path):\\n            # If not leaf node, record the path left or right\\n            if node.left:\\n                traverse(node.left, path+str(node.val))\\n            if node.right:\\n                traverse(node.right, path+str(node.val))\\n            \\n            # Leaf node detect and record path\\n            if not node.left and not node.right:\\n                path += str(node.val)\\n                self.path_to_leaf.append(path)\\n                self.total_binary_sum += int(path, 2)\\n        \\n        traverse(root, \"\")\\n        print(self.path_to_leaf)\\n        return self.total_binary_sum\\n```\n```python\\n        # Logic 2: Iterative method - 100 pass 83 percent faster\\n        # * Each element of the list has the node and the path to it\\n        \\n        stack = [[root, \"\"]] # iteration to keep track\\n        result = 0 # result holder\\n        \\n        # Traverse nodes by stacking them\\n        while stack:\\n            # current node and path tracking\\n            current, path = stack.pop(0)\\n            \\n            # traverse with path \\n            if current.left:\\n                stack.append([current.left, path+str(current.val)])\\n            if current.right:\\n                stack.append([current.right, path+str(current.val)])\\n            \\n            # leaf node condition when we update result\\n            if not current.left and not current.right:\\n                path += str(current.val)\\n                result += int(path, 2)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628160,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nFirst for this question u should be able to print all paths from root to leaf\\nCuz only after this do we convert it to decimal and proceed\\nI would suggest u guys to solve this first and then jump into gfg and try print root to leaf paths\\n\\nSo instead of printing the solution we call a funcion called convert to decimal.\\nNote that when u have been pushing elements into ur array the one with 0 index is ur most significant bit.\\n\\nSo to covert it all we have to do is n=n*2+v[i] where i is from 0 to v.size()-1\\n\\nCode:-\\n\\n    int ans=0;\\n    int convert_decimal(vector<int> v)\\n    {\\n        int n=0;\\n        for(int i=0;i<v.size();i++)\\n            n=n*2+v[i];\\n        return n;\\n    }\\n    void findpath(TreeNode* root,vector<int> t)\\n    {\\n        if(!root)return;\\n        t.push_back(root->val);\\n        if(!root->left && !root->right)ans+=convert_decimal(t);\\n        findpath(root->left,t);\\n        findpath(root->right,t);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)return 0;\\n        vector<int> t;\\n        findpath(root,t);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nFirst for this question u should be able to print all paths from root to leaf\\nCuz only after this do we convert it to decimal and proceed\\nI would suggest u guys to solve this first and then jump into gfg and try print root to leaf paths\\n\\nSo instead of printing the solution we call a funcion called convert to decimal.\\nNote that when u have been pushing elements into ur array the one with 0 index is ur most significant bit.\\n\\nSo to covert it all we have to do is n=n*2+v[i] where i is from 0 to v.size()-1\\n\\nCode:-\\n\\n    int ans=0;\\n    int convert_decimal(vector<int> v)\\n    {\\n        int n=0;\\n        for(int i=0;i<v.size();i++)\\n            n=n*2+v[i];\\n        return n;\\n    }\\n    void findpath(TreeNode* root,vector<int> t)\\n    {\\n        if(!root)return;\\n        t.push_back(root->val);\\n        if(!root->left && !root->right)ans+=convert_decimal(t);\\n        findpath(root->left,t);\\n        findpath(root->right,t);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)return 0;\\n        vector<int> t;\\n        findpath(root,t);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681647,
                "title": "python3-5-lines-explained",
                "content": "We use the recursive Depth First Search here to build all binary numbers from the root-to-leaf path and sum them together. When a leaf node is reached, the function returns the built number. For the rest of the nodes, the function simply sums results from recursive calls. For building the binary number in the path we use a binary operation `(path << 1)` which shifts all bits to the left by one bit to free space for the current bit which we simply add to the path. Example:\\n\\n`path=0  => (path<<1) + 1 = 01`\\n`path=01 => (path<<1) + 1 = 11`\\n`path=11 => (path<<1) + 0 = 110`\\n`path=110 => (path<<1) + 1 = 1101`\\n\\nTime: **O(N)** - for DFS\\nSpace: **O(N)** - recursive stack for binary tree is equal to the tree height\\n\\nRuntime: 36 ms, faster than **80.51%** of Python3 online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 14.4 MB, less than **96.20%** of Python3 online submissions for Sum of Root To Leaf Binary Numbers.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, path):\\n            if not node: return 0\\n\\n            path = (path << 1) + node.val\\n\\t\\t\\t\\n            if not node.left and not node.right:\\n                return path\\n            \\n            return dfs(node.left, path) + dfs(node.right, path)\\n            \\n        return dfs(root, 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, path):\\n            if not node: return 0\\n\\n            path = (path << 1) + node.val\\n\\t\\t\\t\\n            if not node.left and not node.right:\\n                return path\\n            \\n            return dfs(node.left, path) + dfs(node.right, path)\\n            \\n        return dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835958,
                "title": "python-2-easy-recursion-solutions-explained",
                "content": "Let us traverse our tree and change values of nodes, so when we reach leaf we will have in this leaf exactly the number we need to add to total sum. Imagine, we have path `10110`, then let us look at sequence: `1, 10, 101, 1011, 10110`, which is equivalent to `1, 2, 5, 11, 22`. \\n\\n1. If we reached leaf, add value of this leaf to total sum.\\n2. Check left and right children and if they exist, update their values; run dfs for these children.\\n\\n**Complexity**: time complexity is `O(n)`: to traverse our tree. Space complexity is `O(h)` for dfs stack. Note, that we change our tree in process, but it can be easily avoided: instead of changing values we can return value for `dfs` function.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node):\\n            if not node.left and not node.right: self.sum += node.val\\n            for child in filter(None, [node.left, node.right]):\\n                child.val += node.val * 2\\n                dfs(child)\\n          \\n        self.sum = 0\\n        dfs(root)\\n        return self.sum\\n```\\n\\n### Solution 2: without changing tree\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node, Q):\\n            if not node.left and not node.right: self.sum += Q\\n            for child in filter(None, [node.left, node.right]):\\n                dfs(child, Q*2 + child.val)\\n          \\n        self.sum = 0\\n        dfs(root, root.val)\\n        return self.sum\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node):\\n            if not node.left and not node.right: self.sum += node.val\\n            for child in filter(None, [node.left, node.right]):\\n                child.val += node.val * 2\\n                dfs(child)\\n          \\n        self.sum = 0\\n        dfs(root)\\n        return self.sum\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root):\\n        def dfs(node, Q):\\n            if not node.left and not node.right: self.sum += Q\\n            for child in filter(None, [node.left, node.right]):\\n                dfs(child, Q*2 + child.val)\\n          \\n        self.sum = 0\\n        dfs(root, root.val)\\n        return self.sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387149,
                "title": "java-100-beats-time-and-space-detailed-explanation",
                "content": "The key insight (or the AHA moment!) to this problem lies in the fact that the path shares nodes and so computation required to calculate the sum can be shared. By avoiding repeated computation, we can significantly bring down the runtime *O(n)* and space time *O(h)* complexity of this solution, where n is the number of total nodes in the tree and h is the height of the tree.\\n\\nThe computation we are optimizing is the conversion of base-2 number to base-10 number. The way you would usually convert a base-2 to base-10 number is with the formula below:\\n\\n` \\n2^n * nth bit + 2^n-1 * n-1th bit + ... + 2^0 * 0th bit\\n`\\n\\nSo in a brute force solution, we would calculate the path from root to leaf and then apply the formula above. Then we would sum up all the results to reach the final sum. BUT WE ARE SMARTER THAN THAT, SO WE CAN DO BETTER!\\n\\nIf you observe the formula above, we are multiplying the Most Significant Bit, i.e. n, n times by 2 and the Least Significant Bit 0 times by 2. If we are to share this computation as we iterate through the tree paths from Most Significant Bit to the Least Significant Bit, we can multiply each bit by 2 on every call of this function. This means that when we have reached a leaf, which will contain the 0th bit, we would\\'ve have multiplied each preceding bit (n,n-1,n-2)th times by 2, respectively. The result will be equivalent to the formula we have described above. \\n\\n**VOILA**! We have optimized the solution!\\n\\nThe code below uses `parentNodeSum` to keep track of the sum calculated until the `nth node` and then multiplies that sum by 2. Then it adds the value of the current node (i.e. `n-1th node` ) to the product of that.\\n\\nIn conclusion:\\n\\n` \\n2^n * nth bit + 2^n-1 * n-1th bit + ... + 2^0 * 0th bit\\n`\\n\\nWill be equivalent to \\n\\n`[2 * (parentSumNode) + Current Bit] //executed every time the function iterates from root to leaf.`\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return pathSumRootToLeaf(root, 0);\\n    }\\n    \\n    private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        \\n        return pathSumRootToLeaf(root.left, parentNodeSum) + pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return pathSumRootToLeaf(root, 0);\\n    }\\n    \\n    private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        \\n        return pathSumRootToLeaf(root.left, parentNodeSum) + pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420459,
                "title": "java-simple-dfs-solution",
                "content": "```\\nint sum = 0;\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tdfs(root,\"\");\\n\\treturn sum;\\n}\\n\\npublic void dfs(TreeNode root, String curr) {\\n\\tif(root==null) return;\\n\\tif(root.right==null && root.left==null)\\n\\t\\tsum += Integer.parseInt(curr+root.val,2);\\n\\tdfs(root.right, curr+root.val);\\n\\tdfs(root.left, curr+root.val);    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint sum = 0;\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tdfs(root,\"\");\\n\\treturn sum;\\n}\\n\\npublic void dfs(TreeNode root, String curr) {\\n\\tif(root==null) return;\\n\\tif(root.right==null && root.left==null)\\n\\t\\tsum += Integer.parseInt(curr+root.val,2);\\n\\tdfs(root.right, curr+root.val);\\n\\tdfs(root.left, curr+root.val);    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681710,
                "title": "c-java-python-1-line-2-solutions-image-explanation-top-down-and-bottom-up",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* Key Point\\n\\t* `pre` is the sum of prefix of path from root to current node **NOT Inclusive**\\n* Top-Down\\n\\t* DFS Traverse the tree from root to every leaf, once we arrived at a leaf, add the sum of path from root to leaf to the final answer\\n* Bottom-Up\\n\\t* After arriving at a leaf, return the sum of path bottom-up to the root.\\n\\n![image](https://assets.leetcode.com/users/images/2686b5d7-bc15-42c6-96ac-55d95119c67e_1641884337.480884.png)\\n\\n\\n\\n**Top-Down**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void search(TreeNode* node, int pre=0) {    \\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // this->ans += pre << 1 | node->val; // also work\\n            this->ans += pre * 2 + node->val;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // search(node->left, pre << 1 | node->val); // also work\\n            search(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // search(node->right, pre << 1 | node->val); // also work\\n            search(node->right, pre * 2 + node->val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        search(root);\\n        return this->ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.ans = 0\\n\\n    def search(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, add the path sum to final answer\\n            # self.ans += pre << 1 | node.val  # also work\\n            self.ans += pre * 2 + node.val\\n            \\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # self.search(node.left, pre << 1 | node.val)  # also work\\n            self.search(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # self.search(node.right, pre << 1 | node.val)  # also work\\n            self.search(node.right, pre * 2 + node.val)\\n\\n    def sumRootToLeaf(self, root):\\n        self.search(root, 0)\\n        return self.ans\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int ans = 0;\\n    \\n    public void search(TreeNode node, int pre) {\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // this.ans += pre << 1 | node.val; // also work\\n            this.ans += pre * 2 + node.val; \\n            \\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // search(node.left, pre << 1 | node.val); // also work\\n            search(node.left, pre * 2 + node.val);\\n        \\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // search(node.right, pre << 1 | node.val); // also work\\n            search(node.right, pre * 2 + node.val);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        search(root, 0);\\n        return this.ans;\\n    }\\n}\\n```\\n**Bottom-Up**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* node, int pre=0) { // pre is sum of path from root to parent of node\\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node->val; // also work\\n\\t\\t\\treturn pre * 2 + node->val;\\n        int ans = 0;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->left, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->right, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->right, pre * 2 + node->val);\\n        return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, return the sum of path from root to node\\n            # return pre << 1 | node.val  # also work\\n\\t\\t\\treturn pre * 2 + node.val\\n        ans = 0\\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.left, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.right, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.right, pre * 2 + node.val) \\n        return ans\\n```\\n\\n**Python One-liner**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # modified from the above one, don\\'t take it seriously\\n        return pre * 2 + node.val if node.left is None and node.right is None else (\\n                    self.sumRootToLeaf(node.left, pre * 2 + node.val) if node.left else 0\\n                                                                                   ) + (\\n                            self.sumRootToLeaf(node.right, pre * 2 + node.val) if node.right else 0\\n                                                                                       )\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode node, int pre) { // pre is sum of path from root to parent of node\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node.val; // also work\\n            return pre * 2 + node.val;\\n        int ans = 0;\\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.left, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.left, pre * 2 + node.val);\\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.right, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.right, pre * 2 + node.val);\\n        return ans;\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    void search(TreeNode* node, int pre=0) {    \\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // this->ans += pre << 1 | node->val; // also work\\n            this->ans += pre * 2 + node->val;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // search(node->left, pre << 1 | node->val); // also work\\n            search(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // search(node->right, pre << 1 | node->val); // also work\\n            search(node->right, pre * 2 + node->val);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        search(root);\\n        return this->ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.ans = 0\\n\\n    def search(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, add the path sum to final answer\\n            # self.ans += pre << 1 | node.val  # also work\\n            self.ans += pre * 2 + node.val\\n            \\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # self.search(node.left, pre << 1 | node.val)  # also work\\n            self.search(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # self.search(node.right, pre << 1 | node.val)  # also work\\n            self.search(node.right, pre * 2 + node.val)\\n\\n    def sumRootToLeaf(self, root):\\n        self.search(root, 0)\\n        return self.ans\\n```\n```\\nclass Solution {\\n    public int ans = 0;\\n    \\n    public void search(TreeNode node, int pre) {\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // this.ans += pre << 1 | node.val; // also work\\n            this.ans += pre * 2 + node.val; \\n            \\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // search(node.left, pre << 1 | node.val); // also work\\n            search(node.left, pre * 2 + node.val);\\n        \\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // search(node.right, pre << 1 | node.val); // also work\\n            search(node.right, pre * 2 + node.val);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        search(root, 0);\\n        return this.ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* node, int pre=0) { // pre is sum of path from root to parent of node\\n        if (!node->left and !node->right) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node->val; // also work\\n\\t\\t\\treturn pre * 2 + node->val;\\n        int ans = 0;\\n        if (node->left) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->left, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->left, pre * 2 + node->val);\\n        if (node->right) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node->right, pre << 1 | node->val); // also work\\n\\t\\t\\tans += sumRootToLeaf(node->right, pre * 2 + node->val);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # pre is sum of path from root to parent of node\\n        if node.left is None and node.right is None:  # node is a leaf node, return the sum of path from root to node\\n            # return pre << 1 | node.val  # also work\\n\\t\\t\\treturn pre * 2 + node.val\\n        ans = 0\\n        if node.left:  # node.left is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.left, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.left, pre * 2 + node.val)\\n        if node.right:  # node.right is not None, recursively find the sum node to leaf\\n            # ans += self.sumRootToLeaf(node.right, pre << 1 | node.val)  # also work\\n\\t\\t\\tans += self.sumRootToLeaf(node.right, pre * 2 + node.val) \\n        return ans\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, node, pre=0):  # modified from the above one, don\\'t take it seriously\\n        return pre * 2 + node.val if node.left is None and node.right is None else (\\n                    self.sumRootToLeaf(node.left, pre * 2 + node.val) if node.left else 0\\n                                                                                   ) + (\\n                            self.sumRootToLeaf(node.right, pre * 2 + node.val) if node.right else 0\\n                                                                                       )\\n```\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode node, int pre) { // pre is sum of path from root to parent of node\\n        if (node.left == null && node.right == null) // node is a leaf node, return the sum of path from root to node\\n            // return pre << 1 | node.val; // also work\\n            return pre * 2 + node.val;\\n        int ans = 0;\\n        if (node.left != null) // node.left is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.left, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.left, pre * 2 + node.val);\\n        if (node.right != null) // node.right is not None, recursively find the sum node to leaf\\n            // ans += sumRootToLeaf(node.right, pre << 1 | node.val); // also work\\n            ans += sumRootToLeaf(node.right, pre * 2 + node.val);\\n        return ans;\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500851,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\n    const binaries = [];\\n    const traverse = (node, str) => {\\n        if (node === null) {\\n            return;\\n        }\\n        // compose the binary string for the next node\\n        const binary = `${str}${node.val}`;\\n        // when visiting a leaf, add binary string to the array\\n        if (node.left === null && node.right === null) {\\n            binaries.push(binary);\\n        }\\n        \\n        traverse(node.left, binary);\\n        traverse(node.right, binary);\\n    }\\n    \\n    traverse(root, \\'\\');\\n    \\n    return binaries.reduce((sum, binary) => {\\n        sum += parseInt(binary, 2);\\n        return sum;\\n    }, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\n    const binaries = [];\\n    const traverse = (node, str) => {\\n        if (node === null) {\\n            return;\\n        }\\n        // compose the binary string for the next node\\n        const binary = `${str}${node.val}`;\\n        // when visiting a leaf, add binary string to the array\\n        if (node.left === null && node.right === null) {\\n            binaries.push(binary);\\n        }\\n        \\n        traverse(node.left, binary);\\n        traverse(node.right, binary);\\n    }\\n    \\n    traverse(root, \\'\\');\\n    \\n    return binaries.reduce((sum, binary) => {\\n        sum += parseInt(binary, 2);\\n        return sum;\\n    }, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681770,
                "title": "c-python-easy-to-solve-with-different-approaches",
                "content": "Hello Everyone !! \\n**let\\'s get the question rolling ...**\\n***\\nSo we are given the root of a binary tree where every node has a value of `0 or 1`. We need to travel each path from root to leaf and convert it to decimal from binary and do summation of all paths .\\n\\n* Just a small detail given in the question **we all should remember :)**\\n> Each root-to-leaf path represents a binary number **starting with the most significant bit.**\\n***\\n**Intuition:-**\\n* So the majority of us got the intuition to find every path of binary tree by dfs and convert that path to decimal base from binary base but wait, is that a feasible way ?\\n* Nope, don\\'t thinks so. why ? Becuase, To make so many travels to find path and then take separate time to convert to Binary. Hence we are *compromsing both time and space* i.e `time complexity will be O(n^2) and space O(n) !!!!!`\\n**So lesss go and understand an optimal solution :)**\\n* So what if we traverse each node... convert..... and at the same time form its binary! While you are making a recursive call when traversing each node, You form the binary number by adding to previously found binary of that number and at the end which is when the node is a leaf node i.e both left and right are NULL then we know that our number has successfully formed and we add it to our ans. Booom!!! we got the optimization.\\n* **Let\\'s see how the space and time is reduced ^_^ :-** The recursion call is done for all nodes in `O(n)` both number formation and binary conversion are done in `O(1)`. and the space used will be `O(h)` for recursion ,where `h` is the height of the tree. \\n***\\n**Code:-**\\n*DFS call will be like :0*\\n```\\nif(root->left == root->right) \\n    val ;\\nelse\\n    sumRootToLeaf(root->left, val) + sumRootToleaf(root->right, val) ;\\n```\\n*Wan\\'t to do some fun?!! let\\'s do this using ternary operator ~0~*\\n```\\nreturn (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n```\\n\\n**C++ Final Code:-**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;//base condition\\n        //val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        val = (val * 2 + root->val); //using Normal math\\n        return (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));//dfs call\\n    }\\n};\\n```\\n**Python Final Code:-**\\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0  #base case\\n        val = val * 2 + root.val  #val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        if not root.left and not root.right: return val \\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val) #dfs call\\n```\\n**Time Complexity :** *`O(n)`*\\n**Space Complexity:** *`O(1)`*\\n***\\n***\\n**Not a pro in coding just doing it for the fun because I like it ;)) , If I can improve anywhere please comment below or if you have any doubt feel free to ask.**\\n***",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nif(root->left == root->right) \\n    val ;\\nelse\\n    sumRootToLeaf(root->left, val) + sumRootToleaf(root->right, val) ;\\n```\n```\\nreturn (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));\\n```\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (!root) return 0;//base condition\\n        //val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        val = (val * 2 + root->val); //using Normal math\\n        return (root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val));//dfs call\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def sumRootToLeaf(self, root, val=0):\\n        if not root: return 0  #base case\\n        val = val * 2 + root.val  #val = val << 1 | root->val; //Both are same it\\'s just the bit manipulation way  \\n        if not root.left and not root.right: return val \\n        return self.sumRootToLeaf(root.left, val) + self.sumRootToLeaf(root.right, val) #dfs call\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340184,
                "title": "c-dfs-solution-super-op-to-understand-descriptive",
                "content": "\\uD83D\\uDC49 Most solutions have directly done using BITS, Which makes it more difficult to understand. So, I will explain simply using Maths both logic and code. \\n\\n\\u274C Someone can simply think to first find the path and make a string to form the number and then convert it to Binary, **But is it feasible ? No !** Becuase, To make so many travels to find path and then take separate time to convert to Binary. Compromsing both time and space !\\n\\n\\u2714 What if we traverse each node covert and at the same time form its binary! While you are making a recursive call when traversing each node, You form the binary number by adding to previously found binary of that number and at the end which is when the **node is a leaf node** i.e both left and right are NULL then we know that our number **has successfully formed and we add it to our ans**.\\n\\n\\u2716\\u2795 Refer to below diagram for reference. At each level you pass the binary formed. But how is it formed ?\\nSee, Imagine a path 1->0->0 , Its decimal equivalent is 4. So you just take that digit multiply it with 2 and add the previous known bit, Since we dont know thw prev. bit here we add 0 *(Passed in func call)*. Once, we get the digit we add to our next digit and keep it doing recursively and once its a leaf node, **We add it our number. \\nAnd the same in recursion call is done for all nodes in O(n) both number formation and binary conversion are done in O(1).**\\n\\n![image](https://assets.leetcode.com/users/images/d2b292f7-7e8b-48c0-9ad9-0a831301ea51_1626371835.6485362.png)\\n\\n**\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Now here is the code, For the sake of explanation I have made another function and done some extra work. You can just optimise a little more like combining statements, etc**\\n\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void readTree(TreeNode* root, int val)\\n    {\\n        if(!root)\\n            return;\\n\\n        // val = val^2 + root->val;     // Normal Math\\n        val = val << 1 | root->val;     // Same thing in BITS\\n\\t\\t\\n\\t\\t// You can study this concept of bits from GFG ! Internal working of bitwise shift left and OR Operator.\\n        \\n        readTree(root->left, val);\\n        readTree(root->right, val);\\n        \\n        if(root->left == NULL && root->right == NULL)   //When leaf Node then add to Sum\\n            sum += val;\\n    }\\n\\n    int sumRootToLeaf(TreeNode* root) \\n    {\\n        readTree(root, 0);\\n        return sum;\\n    }\\n};\\n```\\n\\n\\u2728 I am not a pro just a begineer, If I can improve anywhere please comment below or if you have any doubt feel free to ask.\\n\\n[Github](http://github.com/winoffrg) \\u2022 Jai Shree Ram !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void readTree(TreeNode* root, int val)\\n    {\\n        if(!root)\\n            return;\\n\\n        // val = val^2 + root->val;     // Normal Math\\n        val = val << 1 | root->val;     // Same thing in BITS\\n\\t\\t\\n\\t\\t// You can study this concept of bits from GFG ! Internal working of bitwise shift left and OR Operator.\\n        \\n        readTree(root->left, val);\\n        readTree(root->right, val);\\n        \\n        if(root->left == NULL && root->right == NULL)   //When leaf Node then add to Sum\\n            sum += val;\\n    }\\n\\n    int sumRootToLeaf(TreeNode* root) \\n    {\\n        readTree(root, 0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332712,
                "title": "java-easy-approach-with-explanation-recursive",
                "content": "```\\nclass Solution \\n{//Revise left and right shift operator from GFG (recommended)\\n    public int sumRootToLeaf(TreeNode root)\\n    {\\n        if(root == null)//base case for null graph \\n            return 0;\\n        \\n        return sum(root, 0);//sum is passed because it has a cyclic dependency  in Recursion for calculating the sum \\n    }\\n    public int sum(TreeNode root, int sum)\\n    {\\n        if(root == null)//base case 1//we we reach an null node we return 0, no shifting operation is done \\n            return 0;\\n        \\n        sum= (sum<<1) + root.val;//in binary addition 0 + 1= 1 && 0 + 0= 0, so only the last place will change by 0 or 1//doing left shift will append zero at the end \\n        \\n        if(root.left == null && root.right == null)//base case 2\\n            return sum;//when we got the desired result(Binary Number in integer) at the leaf node returning it to get the total sum and the traverse if any subtree is left \\n        return sum(root.left, sum) + sum(root.right, sum);//calculating the left and right sum recursively //bactracking helps a lot in leaf node sum \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{//Revise left and right shift operator from GFG (recommended)\\n    public int sumRootToLeaf(TreeNode root)\\n    {\\n        if(root == null)//base case for null graph \\n            return 0;\\n        \\n        return sum(root, 0);//sum is passed because it has a cyclic dependency  in Recursion for calculating the sum \\n    }\\n    public int sum(TreeNode root, int sum)\\n    {\\n        if(root == null)//base case 1//we we reach an null node we return 0, no shifting operation is done \\n            return 0;\\n        \\n        sum= (sum<<1) + root.val;//in binary addition 0 + 1= 1 && 0 + 0= 0, so only the last place will change by 0 or 1//doing left shift will append zero at the end \\n        \\n        if(root.left == null && root.right == null)//base case 2\\n            return sum;//when we got the desired result(Binary Number in integer) at the leaf node returning it to get the total sum and the traverse if any subtree is left \\n        return sum(root.left, sum) + sum(root.right, sum);//calculating the left and right sum recursively //bactracking helps a lot in leaf node sum \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552531,
                "title": "c-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    int sumRootToLeaf(TreeNode* root,int num=0) {\\n        if(!root)return 0;\\n        num *= 2;\\n        num+=root->val;\\n        if(!root->left&&!root->right)sol+=num;\\n        sumRootToLeaf(root->left,num);\\n        sumRootToLeaf(root->right,num);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol=0;\\n    int sumRootToLeaf(TreeNode* root,int num=0) {\\n        if(!root)return 0;\\n        num *= 2;\\n        num+=root->val;\\n        if(!root->left&&!root->right)sol+=num;\\n        sumRootToLeaf(root->left,num);\\n        sumRootToLeaf(root->right,num);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836946,
                "title": "very-easy-dfs-python-solution",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        total=0\\n        \\n        stack=[(root,str(root.val))]\\n        \\n        while stack:\\n            node,binVal=stack.pop()\\n            \\n            if node.left:\\n                stack.append((node.left,binVal+str(node.left.val)))\\n                \\n            if node.right:\\n                stack.append((node.right,binVal+str(node.right.val)))\\n\\n            if not node.left and not node.right:\\n                total+=int(binVal,2)\\n        return total     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        total=0\\n        \\n        stack=[(root,str(root.val))]\\n        \\n        while stack:\\n            node,binVal=stack.pop()\\n            \\n            if node.left:\\n                stack.append((node.left,binVal+str(node.left.val)))\\n                \\n            if node.right:\\n                stack.append((node.right,binVal+str(node.right.val)))\\n\\n            if not node.left and not node.right:\\n                total+=int(binVal,2)\\n        return total     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 328033,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1681890,
                "title": "c-recursive-solution-with-backtracking",
                "content": "The main idea of Backtracting:\\n\\n**1. choose\\n2. explore\\n3. unchoose**\\n\\nThe approach is almost straight forward.  Just explore the nodes using dfs, we choosing the current node and push to the BinaryVector.  After processing(while returning back) we unchoose the node by poping from the BinaryVector.\\n\\nWhen we reach the leaf node, we get a BinaryVector(from root to leaf) then we convert the BinaryVector to an Decimal Equivalent and adding to the Total, then we backtract again, and repeat the same process.\\n\\n**C++:**\\n```\\nclass Solution {\\nprivate:\\n    int binaToDeci(vector<int> s){\\n        int res = 0, p = 1;\\n        for (int i = s.size()-1; i >= 0; i--)\\n        {\\n            int c = s[i];\\n            if(c == 1) res += p;\\n            p <<= 1;\\n        }\\n        return res;\\n    }\\n    void dfs(TreeNode* root, vector<int>&BinaryVector, int& Total){\\n        if(root == NULL) return;\\n        if(root->left == NULL && root-> right == NULL){ // left node\\n            BinaryVector.push_back(root->val);  // choose\\n            Total += binaToDeci(BinaryVector); // Converts the Binary to Decimal and add it. \\n            BinaryVector.pop_back();  // unchoose\\n            return ;\\n        }\\n\\n        BinaryVector.push_back(root->val);   // choose \\n        dfs(root->left, BinaryVector, Total); // explore\\n        dfs(root->right, BinaryVector, Total);\\n        BinaryVector.pop_back();             // unchoose\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int Total = 0;\\n        vector<int> BinaryVector;\\n        dfs(root, BinaryVector, Total);\\n        return Total;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int binaToDeci(vector<int> s){\\n        int res = 0, p = 1;\\n        for (int i = s.size()-1; i >= 0; i--)\\n        {\\n            int c = s[i];\\n            if(c == 1) res += p;\\n            p <<= 1;\\n        }\\n        return res;\\n    }\\n    void dfs(TreeNode* root, vector<int>&BinaryVector, int& Total){\\n        if(root == NULL) return;\\n        if(root->left == NULL && root-> right == NULL){ // left node\\n            BinaryVector.push_back(root->val);  // choose\\n            Total += binaToDeci(BinaryVector); // Converts the Binary to Decimal and add it. \\n            BinaryVector.pop_back();  // unchoose\\n            return ;\\n        }\\n\\n        BinaryVector.push_back(root->val);   // choose \\n        dfs(root->left, BinaryVector, Total); // explore\\n        dfs(root->right, BinaryVector, Total);\\n        BinaryVector.pop_back();             // unchoose\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int Total = 0;\\n        vector<int> BinaryVector;\\n        dfs(root, BinaryVector, Total);\\n        return Total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936585,
                "title": "dfs-easy-js-solution",
                "content": "```\\n/*\\nUse DFS to find every possible path\\nKeep track of binary number in path. When leaf is reached, convert it to an integer and add it\\nto a global variable.\\n*/\\nvar sumRootToLeaf = function(root) {\\n    let sum = 0;\\n    dfs(root, \"\");\\n    return sum;\\n    function dfs(root, path) {\\n        if (!root) {\\n            return;\\n        }\\n        if (!root.left && !root.right) {\\n            sum += parseInt(path + root.val, 2);\\n            return;\\n        }\\n        dfs(root.left, path + root.val);\\n        dfs(root.right, path + root.val);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nUse DFS to find every possible path\\nKeep track of binary number in path. When leaf is reached, convert it to an integer and add it\\nto a global variable.\\n*/\\nvar sumRootToLeaf = function(root) {\\n    let sum = 0;\\n    dfs(root, \"\");\\n    return sum;\\n    function dfs(root, path) {\\n        if (!root) {\\n            return;\\n        }\\n        if (!root.left && !root.right) {\\n            sum += parseInt(path + root.val, 2);\\n            return;\\n        }\\n        dfs(root.left, path + root.val);\\n        dfs(root.right, path + root.val);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681998,
                "title": "java-0ms-with-explanation",
                "content": "We declare sum=0 as global variable.\\n\\nNow in main method we make a check method which computes sumRoottoLeaf calculation.\\n\\nHere preorder traversal will work. As we need root first.\\n\\nMy logic is that if root.val==0 then the computed value earlier will become`` x * 2 else x*2+1;\\n\\nHow???\\nlike first take example with 110=6;\\nNow if next node is 0 which make (1100) =12\\nAnd if next node is 1 which make (1101)=13\\n\\nUsing this approach i recursive called root.left and root.right .\\nAnd included one condtion which is if it is leaf Node then add in global variable sum.\\n\\n**Please Upvote if found UsefuL**\\nComments if any doubts or any more good approach.**Thank You!!**\\n\\n```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        check(root,0);\\n        return sum;\\n    }\\n    void check(TreeNode root,int x)\\n    {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.left==null && root.right==null)\\n        {\\n            sum+=root.val==0?x*2:x*2+1;\\n            return;\\n        }\\n        check(root.left,root.val==0?x*2:x*2+1);\\n        check(root.right,root.val==0?x*2:x*2+1);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        check(root,0);\\n        return sum;\\n    }\\n    void check(TreeNode root,int x)\\n    {\\n        if(root==null)\\n        {\\n            return;\\n        }\\n        if(root.left==null && root.right==null)\\n        {\\n            sum+=root.val==0?x*2:x*2+1;\\n            return;\\n        }\\n        check(root.left,root.val==0?x*2:x*2+1);\\n        check(root.right,root.val==0?x*2:x*2+1);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836834,
                "title": "python-easy-to-understand-dfs",
                "content": "\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def helper(root,nums):\\n            if not root.left and not root.right:\\n                nums += str(root.val)\\n                self.total += int(nums,2)\\n                return    \\n            \\n            nums += str(root.val)\\n            if root.left:\\n                helper(root.left,nums)\\n            if root.right:\\n                helper(root.right,nums)\\n\\n        helper(root, \"\")\\n        return self.total",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def helper(root,nums):\\n            if not root.left and not root.right:\\n                nums += str(root.val)\\n                self.total += int(nums,2)\\n                return    \\n            \\n            nums += str(root.val)\\n            if root.left:\\n                helper(root.left,nums)\\n            if root.right:\\n                helper(root.right,nums)\\n\\n        helper(root, \"\")\\n        return self.total",
                "codeTag": "Python3"
            },
            {
                "id": 836179,
                "title": "java-easy-to-understand-w-explanation-dfs-solution-beats-100",
                "content": "Every level of the tree describes the weight as we do in the Base-10.\\nFor example, 123 can be represented as 123 = 1 * 100 + 2 * 10 + 3\\nSimilarly\\n\\n              1 ----- Level 0 represents weight 2 raise to power 0\\n             / \\\\\\n           0    1 ----- Level 1 represents weight 2 raise to power 1\\n         /  \\\\\\n        1    0 ----- Level 2 represents weight 2 raise to power 2\\nRoot to Leaf Paths - 1 0 1 = 1 * (2^2) + 0 * (2^1) + 1 * (2^0) = 4 + 0 + 1 = 5,\\nSimilarly for 1 0 0 and 1 1.\\n\\nIn Short words, with every level down, we are shifting bits to the left and thereby increasing their weight by k (where k is the base in which we\\'re in, in this case k = 2)\\n\\nFor Path -> 1 0 1\\nAt Level 0, curr = 0 + 1 = 1\\nAt Level 1, curr = (0 + 1) * 2 + 0 = 2\\nAt Level 2, curr = ((0 + 1) * 2 + 0) * 2 + 1 = 2 * 2 + 1 = 5\\n\\nHope it helps!!\\n\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    \\n    private void dfs(TreeNode root, int curr) {\\n        if (root == null) return;\\n        \\n        curr = curr * 2 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += curr;\\n        }\\n        \\n        dfs(root.left, curr);\\n        dfs(root.right, curr);\\n        \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root, 0);\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    \\n    private void dfs(TreeNode root, int curr) {\\n        if (root == null) return;\\n        \\n        curr = curr * 2 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += curr;\\n        }\\n        \\n        dfs(root.left, curr);\\n        dfs(root.right, curr);\\n        \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root, 0);\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835894,
                "title": "c-simple-recursive-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    // recursive helper function to add to vector all binary numbers\\n    void traverse(TreeNode* node, string sum) {\\n        if (!node)\\n            return;\\n        sum = sum + to_string(node->val);\\n        if (!node->left && !node->right)\\n        {\\n            vec.push_back(sum);\\n        }\\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        int res = 0;\\n        for(auto x:vec)\\n            res += stoi(x, nullptr, 2);\\n        return res;\\n    }\\n    vector<string> vec;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // recursive helper function to add to vector all binary numbers\\n    void traverse(TreeNode* node, string sum) {\\n        if (!node)\\n            return;\\n        sum = sum + to_string(node->val);\\n        if (!node->left && !node->right)\\n        {\\n            vec.push_back(sum);\\n        }\\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        int res = 0;\\n        for(auto x:vec)\\n            res += stoi(x, nullptr, 2);\\n        return res;\\n    }\\n    vector<string> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270895,
                "title": "python-happy-dfs-solution",
                "content": "DFS with preorder trasvering\\n# method 1\\n        # it\\'s quite similar to find and return all the root-to-leaf paths\\n        # But this time we just need to return the decimal\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(n) for additional space\\n        def dfs(node, path=None):\\n            if path == None:\\n                path = \\'\\'\\n            if node:\\n                path += str(node.val)\\n                if node.left or node.right:\\n                    return dfs(node.left, path) + dfs(node.right, path)\\n                else:\\n                    return int(path, 2)\\n            else:\\n                return 0\\n\\t\\t\\t\\t\\n# method 2 (recommended)\\n        # very similar to the implementation of method 1\\n\\t\\t# but this time, we directly pass the parent sum instead of \\n\\t\\t# only calculate the decimal presentation in the leaf\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(1) for additional space\\n        def dfs2(node, parent_sum=None):\\n            if parent_sum == None:\\n                parent_sum = 0\\n            if node:\\n                parent_sum = parent_sum * 2 + node.val\\n                if node.left or node.right:\\n                    return dfs2(node.left, parent_sum) + dfs2(node.right, parent_sum)\\n                else:\\n                    return parent_sum\\n            else:\\n                return 0",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "DFS with preorder trasvering\\n# method 1\\n        # it\\'s quite similar to find and return all the root-to-leaf paths\\n        # But this time we just need to return the decimal\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(n) for additional space\\n        def dfs(node, path=None):\\n            if path == None:\\n                path = \\'\\'\\n            if node:\\n                path += str(node.val)\\n                if node.left or node.right:\\n                    return dfs(node.left, path) + dfs(node.right, path)\\n                else:\\n                    return int(path, 2)\\n            else:\\n                return 0\\n\\t\\t\\t\\t\\n# method 2 (recommended)\\n        # very similar to the implementation of method 1\\n\\t\\t# but this time, we directly pass the parent sum instead of \\n\\t\\t# only calculate the decimal presentation in the leaf\\n\\t\\t# O(logn) for time\\n\\t\\t# and without taking the recursion space into account\\n\\t\\t# we will have O(1) for additional space\\n        def dfs2(node, parent_sum=None):\\n            if parent_sum == None:\\n                parent_sum = 0\\n            if node:\\n                parent_sum = parent_sum * 2 + node.val\\n                if node.left or node.right:\\n                    return dfs2(node.left, parent_sum) + dfs2(node.right, parent_sum)\\n                else:\\n                    return parent_sum\\n            else:\\n                return 0",
                "codeTag": "Python3"
            },
            {
                "id": 695744,
                "title": "simplest-recursive-solution-o-n-and-100-time-with-explaination",
                "content": "Idea is simple, do normal traversal, at every step just store the value from previous to current node,\\nexample : traversing 1->0->1 :-\\nwhen we start with 1(1 is root), then value 1 to binary is 2^0 * 1 === 1,\\nwhen we traverses to 1->0 (from 1 to 0), then it is 2^1 * 1 + 2^0 * 0 == 2   note : the previous node value just get doubled and we just the current node since 2\\'s power 0 is 1 only, so 1*2 + 1 * 0 = 2\\nwhen we traverses to 1->0->1, then ->  2 * (value of 1->0) + 1 = (2 * 2 )+ 1\\nso 1->0->1 = 5\\n we uses same thing in our logic\\n\\n```\\nint sum = 0;  // final sum\\n    public int sumRootToLeaf(TreeNode root) {\\n        recur(root,0);\\n        return sum;\\n    }\\n   void recur(TreeNode root, int num) {\\n        if(root == null) {\\n            return;\\n        }\\n        num = num*2 + root.val;  // at every node it will return the value of binary in decimal from root \\n        recur(root.left,num);  \\n        recur(root.right,num);\\n        if(root.left == null && root.right == null) {\\n            sum +=num;   // when every time we reaches the leaf node, we add the num to sum\\n        }\\n    }\\n```\\n\\n**I hope this helps!!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nint sum = 0;  // final sum\\n    public int sumRootToLeaf(TreeNode root) {\\n        recur(root,0);\\n        return sum;\\n    }\\n   void recur(TreeNode root, int num) {\\n        if(root == null) {\\n            return;\\n        }\\n        num = num*2 + root.val;  // at every node it will return the value of binary in decimal from root \\n        recur(root.left,num);  \\n        recur(root.right,num);\\n        if(root.left == null && root.right == null) {\\n            sum +=num;   // when every time we reaches the leaf node, we add the num to sum\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308071,
                "title": "python-99-depth-first-search",
                "content": "\\n\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def dfs(node, prefix):\\n            if node:\\n                new_prefix = node.val + (prefix << 1)\\n                \\n                if node.left or node.right:\\n                    return dfs(node.left, new_prefix) + dfs(node.right, new_prefix)\\n                else:\\n                    return new_prefix\\n            else:\\n                return 0\\n            \\n        return dfs(root, 0)",
                "solutionTags": [],
                "code": "\\n\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def dfs(node, prefix):\\n            if node:\\n                new_prefix = node.val + (prefix << 1)\\n                \\n                if node.left or node.right:\\n                    return dfs(node.left, new_prefix) + dfs(node.right, new_prefix)\\n                else:\\n                    return new_prefix\\n            else:\\n                return 0\\n            \\n        return dfs(root, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 269967,
                "title": "c-3-lines",
                "content": "# Solution\\nCalculate the number top-to-bottom, stop at the leaf and return the result.\\n\\nSum results for all leaves; make sure we handle parents with only one child (return 0 for the missing child).\\n```\\nint sumRootToLeaf(TreeNode* r, int val = 0) {\\n  if (r == nullptr) return 0;\\n  val = ((val << 1) + r->val) % 1000000007;\\n  return (r->left == r->right ? val : sumRootToLeaf(r->left, val) + sumRootToLeaf(r->right, val)) % 1000000007;\\n}\\n```\\n# Complexity Analysis\\nRuntime: *O(n)*; we process each node once. \\nMemory: *O(h)*, where *h* is the height of the tree.",
                "solutionTags": [],
                "code": "```\\nint sumRootToLeaf(TreeNode* r, int val = 0) {\\n  if (r == nullptr) return 0;\\n  val = ((val << 1) + r->val) % 1000000007;\\n  return (r->left == r->right ? val : sumRootToLeaf(r->left, val) + sumRootToLeaf(r->right, val)) % 1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682476,
                "title": "c-java-simple-and-clean-recursive-solutions-explained",
                "content": "**Idea:**\\nWe treaverse the tree, and concatenate the binary numbers to one string in `sum`.\\nWhen we reach a leaf node, we calculate the value of the binary string and add to `res`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1) without considering recursive stack, O(height) with recursive call stack.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    \\n    void traverse(TreeNode* node, string sum) {\\n        if (!node) return;\\n        \\n        sum = sum + to_string(node->val);\\n        \\n        if (!node->left && !node->right) res += stoi(sum, nullptr, 2);\\n        \\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n};\\n```\\n****\\n**Java:**\\n```\\nclass Solution {\\n    int res = 0;\\n    \\n    void traverse(TreeNode node, String sum) {\\n        if (node == null) return;\\n        \\n        sum = sum + String.valueOf(node.val);\\n        \\n        if (node.left == null && node.right == null) \\n            res += Integer.parseInt(sum, 2);\\n   \\n        traverse(node.left, sum);\\n        traverse(node.right, sum); \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    \\n    void traverse(TreeNode* node, string sum) {\\n        if (!node) return;\\n        \\n        sum = sum + to_string(node->val);\\n        \\n        if (!node->left && !node->right) res += stoi(sum, nullptr, 2);\\n        \\n        traverse(node->left, sum);\\n        traverse(node->right, sum); \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int res = 0;\\n    \\n    void traverse(TreeNode node, String sum) {\\n        if (node == null) return;\\n        \\n        sum = sum + String.valueOf(node.val);\\n        \\n        if (node.left == null && node.right == null) \\n            res += Integer.parseInt(sum, 2);\\n   \\n        traverse(node.left, sum);\\n        traverse(node.right, sum); \\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root, \"\");\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481832,
                "title": "recursive-dfs-soln-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*2 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\\n\\nsimilar question https://leetcode.com/problems/sum-root-to-leaf-numbers/\\nwith answer https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/1481784/c%2B%2B-soln-faster-than-100",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*2 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990406,
                "title": "c-no-bitwise-operators-recursive-simple",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, ll num){\\n        if(!root)\\n            return 0;\\n        if(!root->left && !root->right)\\n            return num + root->val;\\n        num += root->val;\\n        return solve(root->left, num * 2) + solve(root->right, num * 2);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return solve(root,0);\\n    }\\n};\\n```\\n\\nThe reason for using long long instead of int is there could be a potential overflow since I am multiplying the numbers rather than shifting bits.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, ll num){\\n        if(!root)\\n            return 0;\\n        if(!root->left && !root->right)\\n            return num + root->val;\\n        num += root->val;\\n        return solve(root->left, num * 2) + solve(root->right, num * 2);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return solve(root,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843907,
                "title": "java-recursion-dfs-and-iteration-morris-traversal-with-video-explaination",
                "content": "DFS version\\n[https://www.youtube.com/watch?v=HBAJqf5cRis](https://www.youtube.com/watch?v=HBAJqf5cRis)\\n```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return helper(root, 0);\\n    }\\n    \\n    private int helper(TreeNode node, int value){\\n        if(node == null) return 0;\\n        \\n        value = value * 2 + node.val;\\n        if(node.left == null && node.right == null){\\n            return value;\\n        }\\n        return helper(node.left, value) + helper(node.right, value);\\n    }\\n}\\n\\n```\\n\\nMorris Traversal Version\\n[https://www.youtube.com/watch?v=2zGxbvIqDGI](https://www.youtube.com/watch?v=2zGxbvIqDGI)\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        int result = 0;\\n        int carry = 0;\\n        while(root != null){\\n            if(root.left != null){\\n                TreeNode predecessor = root.left;\\n                int level = 1;\\n                \\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    level++;\\n                }\\n                \\n                if(predecessor.right == null){\\n                    carry = carry * 2 + root.val;\\n                    predecessor.right = root;\\n                    root = root.left;\\n                }else{\\n                    if(predecessor.left == null){\\n                        result += carry;\\n                    }\\n                    \\n                    for(int i = 0; i < level; i++){\\n                        carry = carry / 2;\\n                    }\\n                    \\n                    predecessor.right = null;\\n                    root = root.right;\\n                }\\n            }else{\\n                // root.left == null\\n                carry = carry * 2 + root.val;\\n                \\n                // right-most leaf node\\n                if(root.right == null){\\n                    result += carry;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return helper(root, 0);\\n    }\\n    \\n    private int helper(TreeNode node, int value){\\n        if(node == null) return 0;\\n        \\n        value = value * 2 + node.val;\\n        if(node.left == null && node.right == null){\\n            return value;\\n        }\\n        return helper(node.left, value) + helper(node.right, value);\\n    }\\n}\\n\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        int result = 0;\\n        int carry = 0;\\n        while(root != null){\\n            if(root.left != null){\\n                TreeNode predecessor = root.left;\\n                int level = 1;\\n                \\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    level++;\\n                }\\n                \\n                if(predecessor.right == null){\\n                    carry = carry * 2 + root.val;\\n                    predecessor.right = root;\\n                    root = root.left;\\n                }else{\\n                    if(predecessor.left == null){\\n                        result += carry;\\n                    }\\n                    \\n                    for(int i = 0; i < level; i++){\\n                        carry = carry / 2;\\n                    }\\n                    \\n                    predecessor.right = null;\\n                    root = root.right;\\n                }\\n            }else{\\n                // root.left == null\\n                carry = carry * 2 + root.val;\\n                \\n                // right-most leaf node\\n                if(root.right == null){\\n                    result += carry;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836211,
                "title": "javascript-clean-recursive-solution",
                "content": "```javascript\\nvar sumRootToLeaf = function(root) {\\n    \\n    function callDFS(node, str) {\\n        if(!node) return 0;\\n        str += node.val\\n        if(!node.left && !node.right) return parseInt(str, 2);\\n        return callDFS(node.right, str) + callDFS(node.left, str);\\n    }\\n    return callDFS(root, \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar sumRootToLeaf = function(root) {\\n    \\n    function callDFS(node, str) {\\n        if(!node) return 0;\\n        str += node.val\\n        if(!node.left && !node.right) return parseInt(str, 2);\\n        return callDFS(node.right, str) + callDFS(node.left, str);\\n    }\\n    return callDFS(root, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836047,
                "title": "java-dfs-video-solution-with-complexity-as-o-n",
                "content": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/7zNNdbeSz-I\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nLink https://www.youtube.com/embed/7zNNdbeSz-I\\n\\nAlgorithm DFS /Post order traversal\\n1) At each level multiply the running sum with 2 and add the node val. \\n2) At leaves add running sum to your result\\n\\nclass Solution { \\nint totalSum = 0; // For storing the result\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        preOrderTraversal(root, 0);\\n        return totalSum;\\n    }\\n    // O(n), where n is the no of nodes in the tree\\n    private void preOrderTraversal(TreeNode root, int currVal){\\n        if(root==null){\\n            return ;\\n        }\\n        currVal = currVal + root.val;\\n        \\n        // leaf node or not\\n        if(root.left == null && root.right==null){\\n            totalSum += currVal;\\n            return ;\\n        }\\n        preOrderTraversal(root.left , currVal* 2);\\n        preOrderTraversal(root.right , currVal* 2);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nLink https://www.youtube.com/embed/7zNNdbeSz-I\\n\\nAlgorithm DFS /Post order traversal\\n1) At each level multiply the running sum with 2 and add the node val. \\n2) At leaves add running sum to your result\\n\\nclass Solution { \\nint totalSum = 0; // For storing the result\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        preOrderTraversal(root, 0);\\n        return totalSum;\\n    }\\n    // O(n), where n is the no of nodes in the tree\\n    private void preOrderTraversal(TreeNode root, int currVal){\\n        if(root==null){\\n            return ;\\n        }\\n        currVal = currVal + root.val;\\n        \\n        // leaf node or not\\n        if(root.left == null && root.right==null){\\n            totalSum += currVal;\\n            return ;\\n        }\\n        preOrderTraversal(root.left , currVal* 2);\\n        preOrderTraversal(root.right , currVal* 2);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835950,
                "title": "sum-of-root-to-leaf-binary-numbers-c-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    static int count(TreeNode* node, int path = 0) { // save path as bits in int\\n        if (!node) return 0;\\n\\t\\t// update path by adding new point to the right to get answer quickly\\n        path <<= 1;\\n \\xA0 \\xA0 \\xA0 \\xA0path += node->val;\\n\\t\\t// if leaf return answer\\n        if (!node->left && !node->right) {\\n            return path;\\n        } else { // if not leaf continue pathing\\n            return count(node->left, path) + count(node->right, path);\\n        }\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return count(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int count(TreeNode* node, int path = 0) { // save path as bits in int\\n        if (!node) return 0;\\n\\t\\t// update path by adding new point to the right to get answer quickly\\n        path <<= 1;\\n \\xA0 \\xA0 \\xA0 \\xA0path += node->val;\\n\\t\\t// if leaf return answer\\n        if (!node->left && !node->right) {\\n            return path;\\n        } else { // if not leaf continue pathing\\n            return count(node->left, path) + count(node->right, path);\\n        }\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        return count(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760466,
                "title": "go-recursive-solution",
                "content": "You\\'ve got to press it on you, you\\'ve just been thinking.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sumRootToLeaf(root *TreeNode) int {\\n    return dfs(root, 0)\\n}\\n\\nfunc dfs(root *TreeNode, currSum int) int {\\n    currSum = (currSum << 1) | root.Val\\n    \\n    if root.Left == nil && root.Right == nil {\\n        return currSum\\n    }\\n    \\n    total := 0\\n    if root.Left != nil {\\n        total += dfs(root.Left, currSum)\\n    }\\n    \\n    if root.Right != nil {\\n        total += dfs(root.Right, currSum)\\n    }\\n    \\n    return total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sumRootToLeaf(root *TreeNode) int {\\n    return dfs(root, 0)\\n}\\n\\nfunc dfs(root *TreeNode, currSum int) int {\\n    currSum = (currSum << 1) | root.Val\\n    \\n    if root.Left == nil && root.Right == nil {\\n        return currSum\\n    }\\n    \\n    total := 0\\n    if root.Left != nil {\\n        total += dfs(root.Left, currSum)\\n    }\\n    \\n    if root.Right != nil {\\n        total += dfs(root.Right, currSum)\\n    }\\n    \\n    return total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455682,
                "title": "java-100-time-and-memory-bit-operations-concise",
                "content": "``` \\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, 0);\\n    }\\n    \\n    public int dfs(TreeNode n, int x) {\\n        if (n == null) return 0;\\n        x = (x << 1) | n.val;\\n        if (n.left == null && n.right == null) return x;\\n        return dfs(n.left, x) + dfs(n.right, x);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2246488,
                "title": "fast-and-easy-c-solution-using-preorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    void getsum(TreeNode* root,long long data){\\n        if(root==NULL){\\n            return;\\n        }\\n        data=2*data+root->val;\\n        if(root->left==NULL && root->right==NULL){\\n            ans+=data;\\n        }\\n        getsum(root->left,data);\\n        getsum(root->right,data);\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        getsum(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    void getsum(TreeNode* root,long long data){\\n        if(root==NULL){\\n            return;\\n        }\\n        data=2*data+root->val;\\n        if(root->left==NULL && root->right==NULL){\\n            ans+=data;\\n        }\\n        getsum(root->left,data);\\n        getsum(root->right,data);\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        getsum(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737312,
                "title": "simple-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        findRootToLeaf(root,\"\");\\n        return sum;\\n    }\\n    void findRootToLeaf(TreeNode root,String prev){\\n        if(root==null)\\n            return;\\n            prev=prev+String.valueOf(root.val);\\n        if(root.left==null && root.right==null)\\n            sum+=Integer.parseInt(prev,2);\\n        findRootToLeaf(root.left,prev);\\n        findRootToLeaf(root.right,prev);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        findRootToLeaf(root,\"\");\\n        return sum;\\n    }\\n    void findRootToLeaf(TreeNode root,String prev){\\n        if(root==null)\\n            return;\\n            prev=prev+String.valueOf(root.val);\\n        if(root.left==null && root.right==null)\\n            sum+=Integer.parseInt(prev,2);\\n        findRootToLeaf(root.left,prev);\\n        findRootToLeaf(root.right,prev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682840,
                "title": "c-recursion-backtracking-using-string-o-n-time",
                "content": "```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* root, string &s, int &ans){\\n        if(!root) return;\\n        s+=to_string(root->val);\\n        if(!root->left && !root->right) ans+=stoi(s, 0, 2);\\n        dfs(root->left, s, ans);\\n        dfs(root->right, s, ans);\\n        s.pop_back();\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s = \"\";\\n        int ans = 0;\\n        dfs(root, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(TreeNode* root, string &s, int &ans){\\n        if(!root) return;\\n        s+=to_string(root->val);\\n        if(!root->left && !root->right) ans+=stoi(s, 0, 2);\\n        dfs(root->left, s, ans);\\n        dfs(root->right, s, ans);\\n        s.pop_back();\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s = \"\";\\n        int ans = 0;\\n        dfs(root, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681921,
                "title": "c-short-code-8-lines-fast-easy-to-understand-recursion",
                "content": "**Please Upvote If You Like**\\n```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (root==NULL) return 0;//base case\\n        val=val*2+(root->val);\\n        if(root->left==root->right)  return val;\\n        return sumRootToLeaf(root->left,val)+sumRootToLeaf(root->right,val); //DFS Calls\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int val = 0) {\\n        if (root==NULL) return 0;//base case\\n        val=val*2+(root->val);\\n        if(root->left==root->right)  return val;\\n        return sumRootToLeaf(root->left,val)+sumRootToLeaf(root->right,val); //DFS Calls\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681814,
                "title": "python-simple-dfs-approach",
                "content": "This problem is pretty straight forward. Do a Depth first search (DFS) traversal and keep track of the pervious bits values. \\n\\n**Approach  1: Conversion on the go**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar = soFar * 2 + node.val\\n            if not node.left and not node.right: self.ans += soFar\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, 0)\\n        return self.ans\\n```\\n\\n**Approach 2: Convert when you reach the leaf**\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar += str(node.val)\\n            if not node.left and not node.right: self.ans += int(soFar, 2)\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, \"\")\\n        return self.ans\\n```\\n\\n***Time Complexity: O(N) \\nSpace Complexity: O(H)  - for recursive stack***",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar = soFar * 2 + node.val\\n            if not node.left and not node.right: self.ans += soFar\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, 0)\\n        return self.ans\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        def dfs(node, soFar):\\n            soFar += str(node.val)\\n            if not node.left and not node.right: self.ans += int(soFar, 2)\\n            if node.left: dfs(node.left, soFar)\\n            if node.right: dfs(node.right, soFar)\\n        \\n        dfs(root, \"\")\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681609,
                "title": "c-simple-and-sweet",
                "content": "Simple Recursion:\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    void Ans(TreeNode *R, int cur, int &ret)\\n    {\\n            cur=cur*2+R->val;\\n            if(R->left!=NULL) Ans(R->left,cur,ret);\\n            if(R->right!=NULL) Ans(R->right,cur,ret);\\n            if(R->left==NULL && R->right==NULL) ret+=cur;\\n    }        \\n    int sumRootToLeaf(TreeNode* R) {\\n        int ret=0,cur=0;\\n        Ans(R,cur,ret);\\n        return(ret);\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void Ans(TreeNode *R, int cur, int &ret)\\n    {\\n            cur=cur*2+R->val;\\n            if(R->left!=NULL) Ans(R->left,cur,ret);\\n            if(R->right!=NULL) Ans(R->right,cur,ret);\\n            if(R->left==NULL && R->right==NULL) ret+=cur;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1399748,
                "title": "c-recursion-well-commented",
                "content": "**Do upvote if found useful**\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void topdown(TreeNode* node,int path){\\n        if(!node)\\n            return;\\n        path*=2;    //multiplying with 2 adds 0 to the binary number\\n        path+=node->val;    //adding whatever value is there in node ie, 0 or 1\\n        if(!node->left && !node->right){    //node is a leaf node\\n            sum+=path;  //add path to the sum\\n        }\\n        if(node->left)  //if left subtree exists\\n            topdown(node->left,path);\\n        \\n        if(node->right)  //if right subtree exists\\n            topdown(node->right,path);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        topdown(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void topdown(TreeNode* node,int path){\\n        if(!node)\\n            return;\\n        path*=2;    //multiplying with 2 adds 0 to the binary number\\n        path+=node->val;    //adding whatever value is there in node ie, 0 or 1\\n        if(!node->left && !node->right){    //node is a leaf node\\n            sum+=path;  //add path to the sum\\n        }\\n        if(node->left)  //if left subtree exists\\n            topdown(node->left,path);\\n        \\n        if(node->right)  //if right subtree exists\\n            topdown(node->right,path);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        topdown(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043156,
                "title": "python3-simple-solution-using-bfs-traversal",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        bfs = [root]\\n        l = []\\n        while bfs:\\n            node = bfs.pop(0)\\n            if node.left:\\n                x = node.left.val\\n                node.left.val = str(node.val) + str(x)\\n                bfs.append(node.left)\\n            if node.right:\\n                x = node.right.val\\n                node.right.val = str(node.val) + str(x)\\n                bfs.append(node.right)\\n            if not node.left and not node.right:\\n                l.append(str(node.val))\\n        return sum([int(i,2) for i in l])\\n```\\nIf you like the solution, please vote for this.",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        bfs = [root]\\n        l = []\\n        while bfs:\\n            node = bfs.pop(0)\\n            if node.left:\\n                x = node.left.val\\n                node.left.val = str(node.val) + str(x)\\n                bfs.append(node.left)\\n            if node.right:\\n                x = node.right.val\\n                node.right.val = str(node.val) + str(x)\\n                bfs.append(node.right)\\n            if not node.left and not node.right:\\n                l.append(str(node.val))\\n        return sum([int(i,2) for i in l])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837027,
                "title": "python-w-explanation",
                "content": "This question is identical to [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/). The only difference is that we construct a decimal number while traversing the tree while here, we construct a binary number. \\n([Solution](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/706013/Python-Recursion-w-Explanation) to  [Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/))\\n\\nThe idea is to recurse in a somewhat \\'preorder\\' manner such that at each valid node, we update the value and then recurse on left subtree and then on right.\\n\\n```\\nclass Solution:\\n        \\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self._helper(root, 0)\\n    \\n    def _helper(self, node: TreeNode, val: int):\\n        if node is None:\\n            return 0\\n\\n        # Keep building the \\'binary number\\' along the way\\n        # Identical to building \\'decimal number\\' : number_till_now * 10 + current_number\\n        val = val * 2 + node.val\\n        \\n        if not node.left and not node.right:\\n            return val\\n        \\n        return self._helper(node.left, val) + self._helper(node.right, val)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n        \\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self._helper(root, 0)\\n    \\n    def _helper(self, node: TreeNode, val: int):\\n        if node is None:\\n            return 0\\n\\n        # Keep building the \\'binary number\\' along the way\\n        # Identical to building \\'decimal number\\' : number_till_now * 10 + current_number\\n        val = val * 2 + node.val\\n        \\n        if not node.left and not node.right:\\n            return val\\n        \\n        return self._helper(node.left, val) + self._helper(node.right, val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836978,
                "title": "c-oneliner-dfs-solution-explained-100-time-85-space",
                "content": "And today too I enjoyed giving myself the extra challenge of solving it in one line, recursively.\\n\\nOur function has basically 3 conditions:\\n* empty tree (`!root`) => we return `res` (set to its default value, `0`);\\n* the node is a leaf (`!root->left && !root->right`) => we return the updated value in `res` with the current value in the node (`res * 2 + root->val`);\\n* at least one branch is still present, so we call recursively the function on that branch with updated value of `res` (see above), or return `0` is the branch is not there.\\n\\nThe code, first iteration:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return !root ? res : !root->left && !root->right ? res * 2 + root->val : (root->left ? sumRootToLeaf(root->left, res * 2 + root->val) : 0) + (root->right ? sumRootToLeaf(root->right, res * 2 + root->val) : 0); \\n    }\\n};\\n```\\n\\nFurther ninjaed version, using the comma operator to compute `res` only once:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), !root || !root->left && !root->right ? res : (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0)); \\n    }\\n};\\n```\\n\\nThird iteration, swapping the conditionals from the above, to save at least a couple of boolean negations (would the compiler do that for me?):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), root && (root->left || root->right) ?  (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0) : res); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return !root ? res : !root->left && !root->right ? res * 2 + root->val : (root->left ? sumRootToLeaf(root->left, res * 2 + root->val) : 0) + (root->right ? sumRootToLeaf(root->right, res * 2 + root->val) : 0); \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), !root || !root->left && !root->right ? res : (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0)); \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root, int res = 0) {\\n        return (res = res * 2 + (root ? root->val : 0), root && (root->left || root->right) ?  (root->left ? sumRootToLeaf(root->left, res) : 0) + (root->right ? sumRootToLeaf(root->right, res) : 0) : res); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450928,
                "title": "python-3-dfs-clean-version",
                "content": "\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n\\t\\t\\tdef dfs(node, previous):\\n\\t\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\t\\tyield 2*previous+node.val\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tyield from dfs(node.left, 2*previous+node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tyield from dfs(node.right, 2*previous+node.val)\\n\\n\\t\\t\\treturn sum(dfs(root, 0))",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n\\t\\t\\tdef dfs(node, previous):\\n\\t\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\t\\tyield 2*previous+node.val\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tyield from dfs(node.left, 2*previous+node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tyield from dfs(node.right, 2*previous+node.val)\\n\\n\\t\\t\\treturn sum(dfs(root, 0))",
                "codeTag": "Java"
            },
            {
                "id": 270055,
                "title": "easy-to-understand-python",
                "content": "```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def rec(node,cbuf = \"\"):\\n            if not node:\\n                return \\n            if not node.left and not node.right:\\n                cval = cbuf + str(node.val)\\n                self.total+=int(cval,2)\\n            else:\\n                tmp = cbuf + str(node.val)\\n                rec(node.left,tmp)\\n                rec(node.right,tmp)        \\n        rec(root)\\n        return self.total % (10**9 +7)\\n```",
                "solutionTags": [],
                "code": "```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.total = 0\\n        def rec(node,cbuf = \"\"):\\n            if not node:\\n                return \\n            if not node.left and not node.right:\\n                cval = cbuf + str(node.val)\\n                self.total+=int(cval,2)\\n            else:\\n                tmp = cbuf + str(node.val)\\n                rec(node.left,tmp)\\n                rec(node.right,tmp)        \\n        rec(root)\\n        return self.total % (10**9 +7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3209144,
                "title": "simple-easy-to-understand-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string s, vector<string>&num){\\n        if(root->left==NULL && root->right==NULL){\\n            s.push_back(root->val + \\'0\\');\\n            num.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        s.push_back(root->val + \\'0\\');\\n        if(root->left)\\n            solve(root->left,s,num);\\n        if(root->right)\\n            solve(root->right,s,num);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        vector<string>num;\\n        string s=\"\";\\n        solve(root,s,num);\\n        for(int i=0;i<num.size();i++){\\n            sum+= stoi(num[i],0,2);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string s, vector<string>&num){\\n        if(root->left==NULL && root->right==NULL){\\n            s.push_back(root->val + \\'0\\');\\n            num.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        s.push_back(root->val + \\'0\\');\\n        if(root->left)\\n            solve(root->left,s,num);\\n        if(root->right)\\n            solve(root->right,s,num);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        vector<string>num;\\n        string s=\"\";\\n        solve(root,s,num);\\n        for(int i=0;i<num.size();i++){\\n            sum+= stoi(num[i],0,2);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031949,
                "title": "c-easy-recursive-approach-dfs",
                "content": "TC: O(N)\\nSC: Auxiliary Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    long sum=0;\\n    void solve(TreeNode* &root,long val){\\n        //base case\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            sum+= (val*2 + root->val);\\n            return;\\n        }\\n        solve(root->left,val*2+root->val);\\n        solve(root->right,val*2+root->val);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        solve(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long sum=0;\\n    void solve(TreeNode* &root,long val){\\n        //base case\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            sum+= (val*2 + root->val);\\n            return;\\n        }\\n        solve(root->left,val*2+root->val);\\n        solve(root->right,val*2+root->val);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        solve(root,0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467041,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint ans = 0;\\n\\t\\tvoid solve(TreeNode *root, int buff){\\n\\n\\t\\t\\tbuff = buff*2 + root->val;\\n\\n\\t\\t\\tif(!root->left && !root->right){\\n\\n\\t\\t\\t\\tans += buff;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root->left) solve(root->left, buff);\\n\\t\\t\\tif(root->right) solve(root->right, buff);\\n\\t\\t}\\n\\n\\t\\tint sumRootToLeaf(TreeNode* root) {\\n\\n\\t\\t\\tint buff = 0;\\n\\t\\t\\tsolve(root, buff);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint ans = 0;\\n\\t\\tvoid solve(TreeNode *root, int buff){\\n\\n\\t\\t\\tbuff = buff*2 + root->val;\\n\\n\\t\\t\\tif(!root->left && !root->right){\\n\\n\\t\\t\\t\\tans += buff;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2345249,
                "title": "dfs",
                "content": "```\\nclass Solution {\\n  int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root,\"\");\\n        return sum;\\n        }\\n    public void traverse(TreeNode root,String prev)\\n    {\\n        if(root==null)\\n            return;\\n        if(root.left==null&&root.right==null)\\n        {\\n             prev=Integer.toString(root.val)+prev;\\n            ANS(prev);\\n            return;\\n        }\\n        prev=Integer.toString(root.val)+prev;\\n        traverse(root.left,prev);\\n        traverse(root.right,prev);\\n        return;\\n        \\n    }\\n    public void ANS(String s)\\n    {\\n        int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            String s1= Character.toString(s.charAt(i));\\n            res=res+(1<<i)*Integer.parseInt(s1);\\n        }\\n        sum=sum+res;\\n    }\\n    \\n}",
                "solutionTags": [
                    "String",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n  int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        traverse(root,\"\");\\n        return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1682249,
                "title": "c-using-vectors",
                "content": "\\n\\t\\tvoid getPath(TreeNode* root,vector<vector<int>> &allpath,vector<int> path){\\n        if(!root) return;\\n        \\n        path.push_back(root->val);\\n\\t\\t\\n        if(root->left==NULL && root->right==NULL){\\n            allpath.push_back(path);\\n        }\\n        getPath(root->left,allpath,path);\\n        getPath(root->right,allpath,path);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<vector<int>> allpath;\\n        vector<int> path;\\n        getPath(root,allpath,path);\\n        int sum=0;\\n        for(int i=0;i<allpath.size();i++){\\n            int cur=0;\\n            int n=allpath[i].size()-1;\\n            for(int j=allpath[i].size()-1;j>=0;j--){\\n                if(allpath[i][j]==0) continue;\\n                cur+=pow(2,n-j);\\n            }\\n            sum+=cur;\\n        }\\n        \\n        return sum;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n\\t\\tvoid getPath(TreeNode* root,vector<vector<int>> &allpath,vector<int> path){\\n        if(!root) return;\\n        \\n        path.push_back(root->val);\\n\\t\\t\\n        if(root->left==NULL && root->right==NULL){\\n            allpath.push_back(path);\\n        }\\n        getPath(root->left,allpath,path);\\n        getPath(root->right,allpath,path);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<vector<int>> allpath;\\n        vector<int> path;\\n        getPath(root,allpath,path);\\n        int sum=0;\\n        for(int i=0;i<allpath.size();i++){\\n            int cur=0;\\n            int n=allpath[i].size()-1;\\n            for(int j=allpath[i].size()-1;j>=0;j--){\\n                if(allpath[i][j]==0) continue;\\n                cur+=pow(2,n-j);\\n            }\\n            sum+=cur;\\n        }\\n        \\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1626645,
                "title": "c-single-pass-solution-0-n-less-than-5-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(TreeNode* root,int val){\\n        if(!root)\\n            return(0);\\n        if(!root->right&&!root->left){\\n            return((root->val)+val*2);\\n        }\\n        val=(root->val)+val*2;\\n        return(f(root->left,val)+f(root->right,val));\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n    return(f(root,0));\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(TreeNode* root,int val){\\n        if(!root)\\n            return(0);\\n        if(!root->right&&!root->left){\\n            return((root->val)+val*2);\\n        }\\n        val=(root->val)+val*2;\\n        return(f(root->left,val)+f(root->right,val));\\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n    return(f(root,0));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586855,
                "title": "easy-to-learn-for-beginer-c",
                "content": "```\\nclass Solution {\\n    int ri=0; //define a universal   variable\\n\\npublic: \\n    \\n    void util(TreeNode* root,int ans){\\n        if(!root)\\n        {\\n            return;\\n        }\\n        //converting binary to real number\\n        ans=ans*2+root->val;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ri+=ans;\\n        }\\n        util(root->left,ans);\\n        util(root->right,ans);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans=0;\\n        util(root,ans);\\n        return ri;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int ri=0; //define a universal   variable\\n\\npublic: \\n    \\n    void util(TreeNode* root,int ans){\\n        if(!root)\\n        {\\n            return;\\n        }\\n        //converting binary to real number\\n        ans=ans*2+root->val;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ri+=ans;\\n        }\\n        util(root->left,ans);\\n        util(root->right,ans);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans=0;\\n        util(root,ans);\\n        return ri;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431470,
                "title": "c-easy-solution-with-explanation",
                "content": "Firstly I am using preOrder traverslal to get the nodes and pushing them in a vector. As a leaf node is reached the vector is being sent to the function \\'add\\' where its bieng converted to the Decimal equivalent. Through backtracking we are storing each value according into the vector. PLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic:\\n   int res;\\n    int add(vector<int>s)\\n    {\\n        int c=0;int k=0;\\n        while(!s.empty())\\n        {\\n            k=k+(s.back()*pow(2,c));\\n            c++;\\n            s.pop_back();\\n        }\\n        return k;\\n    }\\n    void calc(TreeNode *root,vector<int>s,int c)\\n    {\\n      \\n         if(root==nullptr)\\n             return;\\n       // cout<<root->val<<\" \";\\n       s.push_back(root->val);\\n        calc(root->left,s,c);\\n         calc(root->right,s,c);\\n    \\n        if(root->left==nullptr&&root->right==nullptr)\\n        {\\n          int m=add(s);\\n        res=res+m;\\n        }\\n             \\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int>s;\\n        calc(root,s,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int res;\\n    int add(vector<int>s)\\n    {\\n        int c=0;int k=0;\\n        while(!s.empty())\\n        {\\n            k=k+(s.back()*pow(2,c));\\n            c++;\\n            s.pop_back();\\n        }\\n        return k;\\n    }\\n    void calc(TreeNode *root,vector<int>s,int c)\\n    {\\n      \\n         if(root==nullptr)\\n             return;\\n       // cout<<root->val<<\" \";\\n       s.push_back(root->val);\\n        calc(root->left,s,c);\\n         calc(root->right,s,c);\\n    \\n        if(root->left==nullptr&&root->right==nullptr)\\n        {\\n          int m=add(s);\\n        res=res+m;\\n        }\\n             \\n        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int>s;\\n        calc(root,s,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1191997,
                "title": "python-python3-sum-of-root-to-leaf-binary-numbers",
                "content": "***ShamelessSelfPromotion***: My other leetcode [solutions](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts) to various questions can be found [here](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts)\\n\\nTime: O(N)\\nSpace: O(1)\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def calc(node, temp):\\n            if not node:\\n                return 0\\n            \\n            temp = temp*2 + node.val\\n            if (node.left is None) and (node.right is None):\\n                return temp\\n            \\n            return (calc(node.left, temp) + calc(node.right, temp))\\n        \\n        return calc(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def calc(node, temp):\\n            if not node:\\n                return 0\\n            \\n            temp = temp*2 + node.val\\n            if (node.left is None) and (node.right is None):\\n                return temp\\n            \\n            return (calc(node.left, temp) + calc(node.right, temp))\\n        \\n        return calc(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835986,
                "title": "easy-cpp-basic-dfs-o-n-beats-100",
                "content": "The idea is simple, keep adding the current node\\'s value in our temporary sum all the while left shifting it (multiplying by 2).\\nThen we run dfs for its left and right children. When we are done with this node\\'s children, then subtract the node\\'s value from our temporary sum and then right shift it (divide by 2). \\nWhen we reach a leaf node, we add this temporary sum obtained so far to our answer variable. This way, whenever we reach a leaf node, we have found the (temporary) sum of that line of numbers in base 10.\\nTime Complexity - O(N)\\nSpace Complexity - O(1) ~ excluding the recursion stack\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long ans=0;\\n    long sum=0;\\n    void dfs(TreeNode* root){\\n        if(root==NULL){\\n            // ans+=sum;\\n            return;\\n        }\\n        sum=(sum*2)+root->val; //left shift and add current node\\'s value\\n        if(!root->left&&!root->right){ // if leaf add temporary sum in ans\\n            ans+=sum;\\n            \\n            sum-=root->val; //subtract current node\\'s value\\n            sum=sum/2; //right shift\\n            return;\\n        }\\n        //if not leaf then continue dfs for its children\\n        dfs(root->left);\\n        dfs(root->right);\\n        sum-=root->val;\\n        sum=sum/2;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        ans=0;\\n        sum=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long ans=0;\\n    long sum=0;\\n    void dfs(TreeNode* root){\\n        if(root==NULL){\\n            // ans+=sum;\\n            return;\\n        }\\n        sum=(sum*2)+root->val; //left shift and add current node\\'s value\\n        if(!root->left&&!root->right){ // if leaf add temporary sum in ans\\n            ans+=sum;\\n            \\n            sum-=root->val; //subtract current node\\'s value\\n            sum=sum/2; //right shift\\n            return;\\n        }\\n        //if not leaf then continue dfs for its children\\n        dfs(root->left);\\n        dfs(root->right);\\n        sum-=root->val;\\n        sum=sum/2;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        ans=0;\\n        sum=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679980,
                "title": "scala-solution",
                "content": "```\\ndef sumRootToLeaf(root: TreeNode): Int = {\\n        def dfs(root: TreeNode, v: Int):Int = {\\n          if(root == null) return 0;\\n          val ret= v*2 + root.value\\n          if(root.left == null && root.right == null) return ret\\n          return dfs(root.left, ret) + dfs(root.right, ret)\\n        }\\n        return dfs(root, 0)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\ndef sumRootToLeaf(root: TreeNode): Int = {\\n        def dfs(root: TreeNode, v: Int):Int = {\\n          if(root == null) return 0;\\n          val ret= v*2 + root.value\\n          if(root.left == null && root.right == null) return ret\\n          return dfs(root.left, ret) + dfs(root.right, ret)\\n        }\\n        return dfs(root, 0)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 475737,
                "title": "easy-c-dfs",
                "content": "```\\npublic class Solution\\n{\\n    private void Helper(TreeNode node, ref int sum, int current)\\n    {\\n        if (node == null)\\n        {\\n            return;\\n        }\\n\\n        current *= 2;\\n        current += node.val;\\n\\n        if (node.left == null && node.right == null)\\n        {\\n            sum += current;\\n            return;\\n        }\\n\\n        Helper(node.left, ref sum, current);\\n        Helper(node.right, ref sum, current);\\n    }\\n\\n    public int SumRootToLeaf(TreeNode root)\\n    {\\n        int sum = 0;\\n        Helper(root, ref sum, 0);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private void Helper(TreeNode node, ref int sum, int current)\\n    {\\n        if (node == null)\\n        {\\n            return;\\n        }\\n\\n        current *= 2;\\n        current += node.val;\\n\\n        if (node.left == null && node.right == null)\\n        {\\n            sum += current;\\n            return;\\n        }\\n\\n        Helper(node.left, ref sum, current);\\n        Helper(node.right, ref sum, current);\\n    }\\n\\n    public int SumRootToLeaf(TreeNode root)\\n    {\\n        int sum = 0;\\n        Helper(root, ref sum, 0);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433129,
                "title": "javascript-recursive-99",
                "content": "```\\nvar sumRootToLeaf = function(root) {\\n    const numbers = [];\\n    \\n    const bst = (node, binary) => {\\n        if (!node.left && !node.right) {\\n            numbers.push(binary + node.val);\\n        } else if (!node.left || !node.right) {\\n            if (node.left)\\n                bst(node.left, binary + node.val);\\n            else\\n                bst(node.right, binary + node.val);\\n        } else {\\n            bst(node.left, binary + node.val);\\n            bst(node.right, binary + node.val);\\n        }\\n    };\\n    \\n    bst(root, \\'\\');\\n    \\n    let answer = 0;\\n    for (const num of numbers) {\\n        let parsed = parseInt(num, 2);\\n        answer += parsed;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar sumRootToLeaf = function(root) {\\n    const numbers = [];\\n    \\n    const bst = (node, binary) => {\\n        if (!node.left && !node.right) {\\n            numbers.push(binary + node.val);\\n        } else if (!node.left || !node.right) {\\n            if (node.left)\\n                bst(node.left, binary + node.val);\\n            else\\n                bst(node.right, binary + node.val);\\n        } else {\\n            bst(node.left, binary + node.val);\\n            bst(node.right, binary + node.val);\\n        }\\n    };\\n    \\n    bst(root, \\'\\');\\n    \\n    let answer = 0;\\n    for (const num of numbers) {\\n        let parsed = parseInt(num, 2);\\n        answer += parsed;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350078,
                "title": "c-binary-to-decimal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint res = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n    \\tvector<int> bin;\\n        dfs(root, bin);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode *curr, vector<int> &bin) {\\n    \\tif(!curr) return;\\n    \\tbin.push_back(curr->val);\\n    \\tif(!curr->left && !curr->right) res += binaryToDecimal(bin);\\n    \\tdfs(curr->left, bin);\\n    \\tdfs(curr->right, bin);\\n\\t\\tbin.pop_back();\\t\\n\\t}\\n\\t\\n\\tint binaryToDecimal(vector<int> &bin) {\\n\\t\\tint sum = 0;\\n\\t\\tfor(int i=0; i<bin.size(); i++) sum += (bin[i])*(pow(2, bin.size()-1-i));\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint res = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n    \\tvector<int> bin;\\n        dfs(root, bin);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode *curr, vector<int> &bin) {\\n    \\tif(!curr) return;\\n    \\tbin.push_back(curr->val);\\n    \\tif(!curr->left && !curr->right) res += binaryToDecimal(bin);\\n    \\tdfs(curr->left, bin);\\n    \\tdfs(curr->right, bin);\\n\\t\\tbin.pop_back();\\t\\n\\t}\\n\\t\\n\\tint binaryToDecimal(vector<int> &bin) {\\n\\t\\tint sum = 0;\\n\\t\\tfor(int i=0; i<bin.size(); i++) sum += (bin[i])*(pow(2, bin.size()-1-i));\\n\\t\\treturn sum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273229,
                "title": "java-runtime-0-ms-faster-than-100-00-memory-usage-37-4-mb-less-than-100-00",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 37.4 MB, less than 100.00% of Java online submissions for Sum of Root To Leaf Binary Numbers.\\n```class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSumForAllRootToLeaf(root, 0, 0);\\n\\n    }\\n    public int getSumForAllRootToLeaf(TreeNode root, int total, int curSum) {\\n        if (root == null) return total;\\n\\t\\t\\n        curSum = curSum * 2  + root.val;\\n        if (root.left == null && root.right == null) {\\n            total += curSum;\\n            return total;\\n        }\\n        total = getSumForAllRootToLeaf(root.left, total, curSum);\\n        return getSumForAllRootToLeaf(root.right, total, curSum);\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSumForAllRootToLeaf(root, 0, 0);\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3489755,
                "title": "java-beats-100-recursive-shifting-bits-with-deep-explanation",
                "content": "Dont forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# Intuition\\nThe problem asks for the sum of all root-to-leaf binary numbers in a binary tree. A key insight is that the binary number represented by the path from the root to any node is simply the binary number of its parent shifted left by one bit, plus the value of the current node. \\n\\n# Approach\\nWe perform a depth-first search (DFS) traversal on the binary tree, passing the binary number represented by the path from the root to the current node to each recursive call. At each node, we calculate the total sum by shifting the current sum to the left by one bit and adding the value of the current node.\\n\\nIf the current node is a leaf node (both left and right subtrees are `null`), we return the total sum calculated at this node. Otherwise, we return the sum of the sums calculated from the left and right subtrees.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity is $$O(n)$$, where n is the number of nodes in the binary tree. This is because we visit each node exactly once.\\n- Space complexity: The space complexity is $$O(h)$$, where h is the height of the binary tree. This is because the maximum amount of space is utilized by the recursion stack in the case of a skewed binary tree, which could be $$h$$ levels deep.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return calculateSum(root, 0);\\n    }\\n\\n    private static int calculateSum(TreeNode node, int currentSum) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        int totalSum = (currentSum << 1) + node.val;\\n        int leftSubTreeSum = calculateSum(node.left, totalSum);\\n        int rightSubTreeSum = calculateSum(node.right, totalSum);\\n        if (leftSubTreeSum == 0 && rightSubTreeSum == 0) {\\n            return totalSum;\\n        } else {\\n            return leftSubTreeSum + rightSubTreeSum;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return calculateSum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3483729,
                "title": "simple-recursive-solution-using-stoi",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root,string a){\\n        if(!root)return;\\n        a.push_back(\\'0\\'+(root->val));\\n        if(!root->left && !root->right) solve(a);\\n        dfs(root->left,a);\\n        dfs(root->right,a);\\n    }\\n    void solve(string a){\\n        int dec = stoi(a, nullptr, 2);\\n        ans=ans+dec;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string a=\"\";\\n        dfs(root,a);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root,string a){\\n        if(!root)return;\\n        a.push_back(\\'0\\'+(root->val));\\n        if(!root->left && !root->right) solve(a);\\n        dfs(root->left,a);\\n        dfs(root->right,a);\\n    }\\n    void solve(string a){\\n        int dec = stoi(a, nullptr, 2);\\n        ans=ans+dec;\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string a=\"\";\\n        dfs(root,a);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340817,
                "title": "recursive-preorder-traversal-complexity-analysis",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe traverse the Tree, And keep a Global Answer Variable. We keep a current empty number and traverse the tree, incrementing it accordingly as we traverse the tree. When we reach the leaf node, it indicates end of the current number and needs to be added into the final answer variable. We just do this process for the entire tree and return the answer. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity Analysis\\n# Time Complexity : O(N)\\nHere N is the Number of Nodes in the Binary Tree.\\n(Since we traverse all the Nodes in the Binary Tree)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Complexity : O(H)\\nHere, H is the height of the Binary Tree.\\n(Since Recursion Stack Space used is of the order of the height of tree).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    long number = 0;\\n    void traverse(TreeNode* root, int curr)\\n    {\\n        if(root==NULL) return;\\n        curr = (curr<<1) | root->val;\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            number += curr;\\n        }\\n        traverse(root->left,curr);\\n        traverse(root->right,curr);\\n    }\\n    long long int sumRootToLeaf(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        traverse(root,0);\\n        return number;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    long number = 0;\\n    void traverse(TreeNode* root, int curr)\\n    {\\n        if(root==NULL) return;\\n        curr = (curr<<1) | root->val;\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            number += curr;\\n        }\\n        traverse(root->left,curr);\\n        traverse(root->right,curr);\\n    }\\n    long long int sumRootToLeaf(TreeNode* root) \\n    {\\n        if(root == NULL) return 0;\\n        traverse(root,0);\\n        return number;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167220,
                "title": "c-backtrack-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we can always take backTrack solution into consideration while encountering N-ary tree problems.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\neach node would be traversaled only once, so O(n);\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> res;\\n        backTrack(root, res);\\n        return ans;\\n    }\\n    void backTrack(TreeNode* root, vector<int>& res) {\\n        if (!root) return;\\n        // if leaf node now, we calculate the pathSum\\n        if (!root->left && !root->right) {  \\n            res.push_back(root->val);\\n            int N = res.size();\\n            for (int i = N-1; i >= 0; --i) {\\n                ans += res[i] * std::pow(2, N-1-i);\\n            }\\n            res.pop_back();\\n            return;\\n        }\\n        // backTrack\\n        res.push_back(root->val);\\n        backTrack(root->left, res);\\n        backTrack(root->right, res);\\n        res.pop_back();\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> res;\\n        backTrack(root, res);\\n        return ans;\\n    }\\n    void backTrack(TreeNode* root, vector<int>& res) {\\n        if (!root) return;\\n        // if leaf node now, we calculate the pathSum\\n        if (!root->left && !root->right) {  \\n            res.push_back(root->val);\\n            int N = res.size();\\n            for (int i = N-1; i >= 0; --i) {\\n                ans += res[i] * std::pow(2, N-1-i);\\n            }\\n            res.pop_back();\\n            return;\\n        }\\n        // backTrack\\n        res.push_back(root->val);\\n        backTrack(root->left, res);\\n        backTrack(root->right, res);\\n        res.pop_back();\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868440,
                "title": "without-using-mod-20line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust add each path value to the list as we reach at end of path and each value is converted to decimal number and added to total sum;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd each path value to the list as we reach at end of path\\nbut while adding if we reached at root which is null it will add to list value getting from both left and right path as we this will make duplicate addition to tackle this just add value before reaching null which is when left and right is null which avoids duplicates.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        _sum(root, \"\");\\n        int count = 0;\\n        for(String s : res){\\n            System.out.println(s);\\n            count+=Integer.parseInt(s, 2);\\n        }\\n        \\n        return count;\\n    }\\n    private void _sum(TreeNode root, String str){\\n        if(root == null){\\n            \\n            return;\\n        }\\n        if(root.left == null && root.right == null) {\\n            str += root.val;\\n            res.add(str);\\n            return;\\n        }\\n        str += \"\"+ root.val;\\n        _sum(root.left, str);\\n        _sum(root.right, str);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        _sum(root, \"\");\\n        int count = 0;\\n        for(String s : res){\\n            System.out.println(s);\\n            count+=Integer.parseInt(s, 2);\\n        }\\n        \\n        return count;\\n    }\\n    private void _sum(TreeNode root, String str){\\n        if(root == null){\\n            \\n            return;\\n        }\\n        if(root.left == null && root.right == null) {\\n            str += root.val;\\n            res.add(str);\\n            return;\\n        }\\n        str += \"\"+ root.val;\\n        _sum(root.left, str);\\n        _sum(root.right, str);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675357,
                "title": "top-down-approach-dfs-beats-100",
                "content": "//Top down approach, similar to  leetcode problem [https://leetcode.com/problems/sum-root-to-leaf-numbers/]()\\n\\n```\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        return dfs(root,0);\\n    }\\n    public int dfs(TreeNode root,int s)\\n    {\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return root.val+s*2;\\n        else\\n            return dfs(root.left,root.val+s*2)+\\n                   dfs(root.right,root.val+s*2);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        return dfs(root,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2666573,
                "title": "c-solution-sum-of-root-to-leaf-binary-numbers",
                "content": "```\\nclass Solution {\\nprivate:\\n    int binarytoInteger(vector<int> bin){\\n        int ans = 0;\\n        int size = bin.size()-1;\\n        for(int i = 0 ; i < bin.size() ; i++){\\n            if(bin[i] == 1){\\n            ans += pow(2,size);\\n            }\\n            size--;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root , vector<int> path , int &sum){\\n        //base case\\n        if(root == NULL)\\n            return;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int x = binarytoInteger(path);\\n            sum += x;\\n        }\\n        \\n        solve(root->left , path , sum);\\n        solve(root->right , path , sum);\\n        \\n        path.pop_back();\\n    }\\n    \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> path;\\n        int sum = 0;\\n        solve(root , path , sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int binarytoInteger(vector<int> bin){\\n        int ans = 0;\\n        int size = bin.size()-1;\\n        for(int i = 0 ; i < bin.size() ; i++){\\n            if(bin[i] == 1){\\n            ans += pow(2,size);\\n            }\\n            size--;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root , vector<int> path , int &sum){\\n        //base case\\n        if(root == NULL)\\n            return;\\n        \\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int x = binarytoInteger(path);\\n            sum += x;\\n        }\\n        \\n        solve(root->left , path , sum);\\n        solve(root->right , path , sum);\\n        \\n        path.pop_back();\\n    }\\n    \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<int> path;\\n        int sum = 0;\\n        solve(root , path , sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635118,
                "title": "python-iterative-dfs-solution",
                "content": "\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n  \\n        res  = 0\\n        stack = [(root, \"\")]\\n        \\n        while(stack):\\n            node, path = stack.pop()\\n            if node:\\n                path += str(node.val)\\n\\n                if not(node.left or node.right):\\n                    res += int(path, 2)\\n                else:\\n                    stack.append((node.left, path))\\n                    stack.append((node.right,path))\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n  \\n        res  = 0\\n        stack = [(root, \"\")]\\n        \\n        while(stack):\\n            node, path = stack.pop()\\n            if node:\\n                path += str(node.val)\\n\\n                if not(node.left or node.right):\\n                    res += int(path, 2)\\n                else:\\n                    stack.append((node.left, path))\\n                    stack.append((node.right,path))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2555788,
                "title": "everything-explained-using-comment-java-c-tree",
                "content": "```\\n/* Java Solution */\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root,int sum)\\n    {\\n\\t\\t// Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(root == null) return 0;\\n        \\n        sum = (2*sum) + root.val;      // To convert binary to decimal.\\n        \\n        if(root.left == null && root.right == null) return sum;   // If only root is present.\\n        \\n        return sumRootToLeaf(root.left,sum) + sumRootToLeaf(root.right,sum);\\n    }\\n    \\n    \\n    public int sumRootToLeaf(TreeNode root) \\n    {\\n        return sumRootToLeaf(root,0);\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode *root,int sum)\\n    {\\n        // Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(!root) return 0;\\n        \\n        sum = (2*sum) + root->val;  // To convert binary to decimal.\\n        \\n        if(!root->left && !root->right) return sum;  // If only root is present.\\n        \\n        return sumRootToLeaf(root->left,sum) + sumRootToLeaf(root->right,sum);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/* Java Solution */\\nclass Solution {\\n    \\n    public int sumRootToLeaf(TreeNode root,int sum)\\n    {\\n\\t\\t// Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(root == null) return 0;\\n        \\n        sum = (2*sum) + root.val;      // To convert binary to decimal.\\n        \\n        if(root.left == null && root.right == null) return sum;   // If only root is present.\\n        \\n        return sumRootToLeaf(root.left,sum) + sumRootToLeaf(root.right,sum);\\n    }\\n    \\n    \\n    public int sumRootToLeaf(TreeNode root) \\n    {\\n        return sumRootToLeaf(root,0);\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode *root,int sum)\\n    {\\n        // Base Cases Think only root is present and construct the base cases.Recursion will handle the other cases.\\n        if(!root) return 0;\\n        \\n        sum = (2*sum) + root->val;  // To convert binary to decimal.\\n        \\n        if(!root->left && !root->right) return sum;  // If only root is present.\\n        \\n        return sumRootToLeaf(root->left,sum) + sumRootToLeaf(root->right,sum);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549506,
                "title": "100-t-c-90-s-c-easy-short-fast-solutions",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    public int sumRootToLeaf(TreeNode root) {\\n        sumRootToLeafRecur(root, 0);\\n        return ans;\\n    }\\n    int ans = 0;\\n    private void sumRootToLeafRecur(TreeNode root, int b){\\n        if (root == null) return;\\n        b = (b *= 2) + root.val;\\n        if (root.left == null && root.right == null) ans += b;\\n\\n        sumRootToLeafRecur(root.left, b);\\n        sumRootToLeafRecur(root.right, b);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317936,
                "title": "beginner-friendly-c-with-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n  int sum=0;\\n\\n \\n  void rec(TreeNode* root,string s)\\n    \\n  {\\n if(root==NULL )\\n {\\n   return ;\\n }\\n    \\n    if(root->right==NULL && root->left==NULL)\\n      \\n    {\\n     \\n      s+=to_string(root->val);\\n       \\n      //sum=sum+stoi(s);\\n      sum=sum+stoi(s,nullptr,2);\\n  }\\n      \\n      \\n    \\n    s+=to_string(root->val);\\n    rec(root->left,s);\\n    rec(root->right,s);\\n    \\n  }\\n  \\n    \\n    \\n    \\n  \\n    int sumRootToLeaf(TreeNode* root) {\\n      //int n;\\n    string s=\"\";\\n      rec(root,s);\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int sum=0;\\n\\n \\n  void rec(TreeNode* root,string s)\\n    \\n  {\\n if(root==NULL )\\n {\\n   return ;\\n }\\n    \\n    if(root->right==NULL && root->left==NULL)\\n      \\n    {\\n     \\n      s+=to_string(root->val);\\n       \\n      //sum=sum+stoi(s);\\n      sum=sum+stoi(s,nullptr,2);\\n  }\\n      \\n      \\n    \\n    s+=to_string(root->val);\\n    rec(root->left,s);\\n    rec(root->right,s);\\n    \\n  }\\n  \\n    \\n    \\n    \\n  \\n    int sumRootToLeaf(TreeNode* root) {\\n      //int n;\\n    string s=\"\";\\n      rec(root,s);\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297499,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        sumRootToLeafAux(root, \"\", arr);\\n        int ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            ans+=Integer.parseInt(arr.get(i), 2);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void sumRootToLeafAux(TreeNode node, String temp, List<String> arr) {\\n        if(node!=null){\\n            temp += node.val;\\n            if(node.left == null && node.right == null){\\n                arr.add(temp);\\n            }\\n            else{\\n                sumRootToLeafAux( node.left,  temp,  arr);\\n                sumRootToLeafAux( node.right,  temp,  arr);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        sumRootToLeafAux(root, \"\", arr);\\n        int ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            ans+=Integer.parseInt(arr.get(i), 2);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void sumRootToLeafAux(TreeNode node, String temp, List<String> arr) {\\n        if(node!=null){\\n            temp += node.val;\\n            if(node.left == null && node.right == null){\\n                arr.add(temp);\\n            }\\n            else{\\n                sumRootToLeafAux( node.left,  temp,  arr);\\n                sumRootToLeafAux( node.right,  temp,  arr);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227161,
                "title": "c-easy-dfs-preorder-approach",
                "content": "**APPROACH :**\\n* In order to track path from root to leaf we ne to transverse using DFS-Preorder method.\\n* And instead of using string we can use shift operator.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// Recurssive function\\n    void helper(TreeNode*root, int &ans, int p){\\n        // If root is a NULL\\n\\t\\tif(!root) return;\\n        \\n\\t\\t// Update the path value\\n        p = (p<<1)+root->val;\\n\\t\\t\\n\\t\\t// update the ans if the root is a leaf.\\n        if(root->left == NULL && root->right == NULL)\\n            ans += p;\\n        \\n\\t\\t// DFS Preorder transversal\\n        helper(root->left, ans, p);\\n        helper(root->right, ans, p);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n\\t\\tint ans=0;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you  find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\t// Recurssive function\\n    void helper(TreeNode*root, int &ans, int p){\\n        // If root is a NULL\\n\\t\\tif(!root) return;\\n        \\n\\t\\t// Update the path value\\n        p = (p<<1)+root->val;\\n\\t\\t\\n\\t\\t// update the ans if the root is a leaf.\\n        if(root->left == NULL && root->right == NULL)\\n            ans += p;\\n        \\n\\t\\t// DFS Preorder transversal\\n        helper(root->left, ans, p);\\n        helper(root->right, ans, p);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n\\t\\tint ans=0;\\n        helper(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148522,
                "title": "python-3-easy-solution",
                "content": "```\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        stack = []\\n        def dfs(root, s):\\n            \\n            if not root:\\n                return\\n            each_val = str(root.val)\\n            if not root.left and not root.right:\\n                stack.append(int(s+each_val, 2))\\n                return\\n            \\n            dfs(root.left, s+each_val) \\n            \\n            dfs(root.right, s+each_val) \\n\\n        dfs(root, \"\")\\n        return(sum(stack))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        stack = []\\n        def dfs(root, s):\\n            \\n            if not root:\\n                return\\n            each_val = str(root.val)\\n            if not root.left and not root.right:\\n                stack.append(int(s+each_val, 2))\\n                return\\n            \\n            dfs(root.left, s+each_val) \\n            \\n            dfs(root.right, s+each_val) \\n\\n        dfs(root, \"\")\\n        return(sum(stack))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2093508,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>>ans=new ArrayList<>();\\n    ArrayList<Integer>temp=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        createlist(root);\\n        int tsum = 0;\\n        for(int i=0;i<ans.size();i++){\\n            tsum= tsum + sum(ans.get(i));\\n        }\\n        return tsum;\\n    }\\n    public static int sum(ArrayList<Integer>temp){\\n        int sum = 0;\\n        int x = 0;\\n        for(int i=temp.size()-1;i>=0;i--){\\n            sum+=temp.get(i)*Math.pow(2,x);\\n            x++;\\n        }\\n        return sum;\\n    }\\n    \\n     public void createlist(TreeNode root){\\n        if(root == null ){\\n            return ;\\n        }\\n        temp.add(root.val);\\n        if(root.left==null && root.right == null){\\n            ans.add(new ArrayList<Integer>(temp));\\n        }\\n        createlist(root.left);\\n        createlist(root.right);\\n        temp.remove(temp.size()-1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>>ans=new ArrayList<>();\\n    ArrayList<Integer>temp=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        createlist(root);\\n        int tsum = 0;\\n        for(int i=0;i<ans.size();i++){\\n            tsum= tsum + sum(ans.get(i));\\n        }\\n        return tsum;\\n    }\\n    public static int sum(ArrayList<Integer>temp){\\n        int sum = 0;\\n        int x = 0;\\n        for(int i=temp.size()-1;i>=0;i--){\\n            sum+=temp.get(i)*Math.pow(2,x);\\n            x++;\\n        }\\n        return sum;\\n    }\\n    \\n     public void createlist(TreeNode root){\\n        if(root == null ){\\n            return ;\\n        }\\n        temp.add(root.val);\\n        if(root.left==null && root.right == null){\\n            ans.add(new ArrayList<Integer>(temp));\\n        }\\n        createlist(root.left);\\n        createlist(root.right);\\n        temp.remove(temp.size()-1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958546,
                "title": "python-eli5-a-solution-that-used-dfs-and-backtracing",
                "content": "A lot of the solutions for this question use something other than DFS or Backtracking. I guarantee that if you pull bitwise operators during an interview in which the interviewer is looking for your knowledge of DFS / Backtracking, you won\\'t get the job. so lets look at how this is supposed to be solved, even if it\\'s not the fastest way to do it.\\n\\nThe problem states that we need to get the binary number from the root to **all** the leaves in the tree. This phrase alone tells us that we need DFS with Backtracking. \\n\\nFor general reference, any problem that needs Backtracking will have a solution that looks like the following pseudocode:\\n\\n```python\\ndef dfs(node, state):\\n\\tif state is a solution:\\n\\t\\trecord(state)\\n\\t\\treturn\\n\\t\\n\\tfor child in children:\\n\\t\\tif child is part of solution:\\n\\t\\t\\tstate.add(child)\\n\\t\\t\\tdfs(child, state)\\n\\t\\t\\tstate.remove(child)\\n```\\n\\nFollow this format for permutation questions.\\n\\nLet\\'s look at the first part: If the current state is a solution. We\\'ll know we\\'ve got a solution for this problem once we\\'ve reached a leaf node. Therefore our if statement should look like this:\\n\\n```python\\n\\tif node.left is None and node.right is None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tanswer.append(\\'\\'.join(path))\\n\\t\\tpath.pop()\\n\\t\\treturn\\n```\\n\\nWe will add the current node to our current state, then save it to our collection of answers, then pop it before backtracking.\\n\\nNow we need to think about what to do if we\\'re not currently at a leaf node. Well, we need to append to the current state and go down both left and right until we reach a leaf node! So the second part of our format will look like this:\\n\\n```python\\n\\tif node.left is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.left, path)\\n\\t\\tpath.pop()\\n\\t\\n\\tif node.right is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.right, path)\\n\\t\\tpath.pop()\\n```\\n\\nNow we just put it all together and add a data structure to keep our potential answers with:\\n\\n```python\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        answer = []\\n        def dfs(node, path):\\n            if node.left is None and node.right is None:\\n                path.append(str(node.val))\\n                answer.append(\\'\\'.join(path))\\n                path.pop()\\n                return\\n\\n            if node.left is not None:\\n                path.append(str(node.val))\\n                dfs(node.left, path)\\n                path.pop()\\n            if node.right is not None:\\n                path.append(str(node.val))\\n                dfs(node.right, path)\\n                path.pop()\\n                \\n        dfs(root, [])\\n```\\n\\nNow our `answer` array has the string representations of each root-to-leaf branch in our tree. It\\'s a simple matter of converting these binary strings to integers and adding them up:\\n\\n```python\\n\\tvalue = 0\\n\\tfor digits in answer:\\n\\t\\tvalue += int(digits, 2)\\n\\treturn value\\n```\\n\\nThis is not the fastest answer, but if you\\'re actually doing an interview, this is at least closer to what they will expect from you, and it is also much easier to explain during your interview.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```python\\ndef dfs(node, state):\\n\\tif state is a solution:\\n\\t\\trecord(state)\\n\\t\\treturn\\n\\t\\n\\tfor child in children:\\n\\t\\tif child is part of solution:\\n\\t\\t\\tstate.add(child)\\n\\t\\t\\tdfs(child, state)\\n\\t\\t\\tstate.remove(child)\\n```\n```python\\n\\tif node.left is None and node.right is None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tanswer.append(\\'\\'.join(path))\\n\\t\\tpath.pop()\\n\\t\\treturn\\n```\n```python\\n\\tif node.left is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.left, path)\\n\\t\\tpath.pop()\\n\\t\\n\\tif node.right is not None:\\n\\t\\tpath.append(str(node.val))\\n\\t\\tdfs(node.right, path)\\n\\t\\tpath.pop()\\n```\n```python\\ndef sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        answer = []\\n        def dfs(node, path):\\n            if node.left is None and node.right is None:\\n                path.append(str(node.val))\\n                answer.append(\\'\\'.join(path))\\n                path.pop()\\n                return\\n\\n            if node.left is not None:\\n                path.append(str(node.val))\\n                dfs(node.left, path)\\n                path.pop()\\n            if node.right is not None:\\n                path.append(str(node.val))\\n                dfs(node.right, path)\\n                path.pop()\\n                \\n        dfs(root, [])\\n```\n```python\\n\\tvalue = 0\\n\\tfor digits in answer:\\n\\t\\tvalue += int(digits, 2)\\n\\treturn value\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1951065,
                "title": "simplest-solution-easiest-to-understand-0ms-runtime-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        return preorder(root,0);\\n\\n    }\\n    \\n    public int preorder(TreeNode root, int sum) {\\n    \\n        if(root==null)\\n            return 0;\\n        \\n        sum= (2*sum) + root.val;\\n        \\n        if(root.left==null && root.right==null)\\n            return sum;\\n        \\n       return preorder(root.left,sum) + preorder(root.right,sum); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        return preorder(root,0);\\n\\n    }\\n    \\n    public int preorder(TreeNode root, int sum) {\\n    \\n        if(root==null)\\n            return 0;\\n        \\n        sum= (2*sum) + root.val;\\n        \\n        if(root.left==null && root.right==null)\\n            return sum;\\n        \\n       return preorder(root.left,sum) + preorder(root.right,sum); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682872,
                "title": "recursive-approach-o-n-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root , int val = 0) {\\n        // recursive approach\\n        // TC-> O(N)  SC-> O(H)\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root , int val = 0) {\\n        // recursive approach\\n        // TC-> O(N)  SC-> O(H)\\n        if (!root) return 0;\\n        val = (val * 2 + root->val);\\n        return root->left == root->right ? val : sumRootToLeaf(root->left, val) + sumRootToLeaf(root->right, val);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682782,
                "title": "c-solution-beginner-friendly-recursion-backtracking",
                "content": "*Please upvote if you find helpful :)*\\n```\\nclass Solution {\\npublic:\\n    int bintodecimal(string s) {\\n        int len = s.length(), ans=0;\\n        for(int i=0;s[i];i++)\\n            ans += (s[i]-\\'0\\')*pow(2, len-i-1);\\n        return ans;\\n    }\\n    void allPaths(TreeNode* root, string &v1, vector<string> &v) {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL && root->right==NULL) {\\n            v1+=(to_string(root->val));\\n            v.push_back(v1);\\n            v1.pop_back();\\n            return;\\n        }\\n        v1+=(to_string(root->val));\\n        allPaths(root->left, v1, v);\\n        allPaths(root->right, v1, v);\\n        v1.pop_back();\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string v1=\"\";\\n        vector<string> v;\\n        allPaths(root, v1, v);\\n        int ans=0;\\n        for(auto x: v) {\\n            int d = bintodecimal(x);\\n            ans += d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bintodecimal(string s) {\\n        int len = s.length(), ans=0;\\n        for(int i=0;s[i];i++)\\n            ans += (s[i]-\\'0\\')*pow(2, len-i-1);\\n        return ans;\\n    }\\n    void allPaths(TreeNode* root, string &v1, vector<string> &v) {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL && root->right==NULL) {\\n            v1+=(to_string(root->val));\\n            v.push_back(v1);\\n            v1.pop_back();\\n            return;\\n        }\\n        v1+=(to_string(root->val));\\n        allPaths(root->left, v1, v);\\n        allPaths(root->right, v1, v);\\n        v1.pop_back();\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string v1=\"\";\\n        vector<string> v;\\n        allPaths(root, v1, v);\\n        int ans=0;\\n        for(auto x: v) {\\n            int d = bintodecimal(x);\\n            ans += d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681853,
                "title": "recursion-java-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int sumRootToLeaf(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n        sum = (sum << 1) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root){\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int sumRootToLeaf(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n        sum = (sum << 1) + root.val;\\n        if(root.left == null && root.right == null) return sum;\\n        return sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root){\\n        return sumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681847,
                "title": "javascript-bitwise-operation",
                "content": "```js\\nfunction sumRootToLeaf(node, cur = 0) {\\n  if (!node) {\\n    return 0;\\n  }\\n  cur = (cur << 1) | node.val;\\n  return node.left === node.right ? cur : sumRootToLeaf(node.left, cur) + sumRootToLeaf(node.right, cur);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction sumRootToLeaf(node, cur = 0) {\\n  if (!node) {\\n    return 0;\\n  }\\n  cur = (cur << 1) | node.val;\\n  return node.left === node.right ? cur : sumRootToLeaf(node.left, cur) + sumRootToLeaf(node.right, cur);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681578,
                "title": "python3-dfs-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        # defining a global variable for recursive helper to modify\\n        ret = [0]\\n        def helper(curr, currpath):\\n            if curr is None:\\n                return\\n            \\n            # case where leaf node has been reached\\n            if curr.left is None and curr.right is None:\\n                currpath.append(curr.val)\\n                bin_str = \"\".join(map(str, currpath))\\n                ret[0] += int(bin_str, 2)\\n                currpath.pop()\\n                return\\n            \\n            # append the current node\\'s value to the array before processing children\\n            currpath.append(curr.val)\\n            helper(curr.left, currpath)\\n            helper(curr.right, currpath)\\n            \\n            # remove the current node\\'s value before returning to callee\\n            currpath.pop()\\n            \\n        helper(root, [])\\n        return ret[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        \\n        # defining a global variable for recursive helper to modify\\n        ret = [0]\\n        def helper(curr, currpath):\\n            if curr is None:\\n                return\\n            \\n            # case where leaf node has been reached\\n            if curr.left is None and curr.right is None:\\n                currpath.append(curr.val)\\n                bin_str = \"\".join(map(str, currpath))\\n                ret[0] += int(bin_str, 2)\\n                currpath.pop()\\n                return\\n            \\n            # append the current node\\'s value to the array before processing children\\n            currpath.append(curr.val)\\n            helper(curr.left, currpath)\\n            helper(curr.right, currpath)\\n            \\n            # remove the current node\\'s value before returning to callee\\n            currpath.pop()\\n            \\n        helper(root, [])\\n        return ret[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664685,
                "title": "c-recursion",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void fun(TreeNode *root, int sum){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            sum=sum*2+root->val;\\n            ans+=sum;\\n            return;\\n        }\\n        if(root) sum=sum*2+(root->val);\\n        fun(root->left, sum);\\n        fun(root->right, sum);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        fun(root, sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void fun(TreeNode *root, int sum){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            sum=sum*2+root->val;\\n            ans+=sum;\\n            return;\\n        }\\n        if(root) sum=sum*2+(root->val);\\n        fun(root->left, sum);\\n        fun(root->right, sum);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int sum=0;\\n        fun(root, sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514309,
                "title": "python-recursive",
                "content": "```\\n\\tdef sumRootToLeaf(self, root):\\n        return self.recursive(root, \"\")\\n        \\n    def recursive(self, root, binary_str):\\n        left = right = 0\\n        binary_str += str(root.val)\\n        \\n        if not root.left and not root.right:\\n            return int(binary_str, 2)\\n        \\n        if root.left:\\n            left = self.recursive(root.left, binary_str)\\n        if root.right:\\n            right = self.recursive(root.right, binary_str)\\n        \\n        return left + right",
                "solutionTags": [],
                "code": "```\\n\\tdef sumRootToLeaf(self, root):\\n        return self.recursive(root, \"\")\\n        \\n    def recursive(self, root, binary_str):\\n        left = right = 0\\n        binary_str += str(root.val)\\n        \\n        if not root.left and not root.right:\\n            return int(binary_str, 2)\\n        \\n        if root.left:\\n            left = self.recursive(root.left, binary_str)\\n        if root.right:\\n            right = self.recursive(root.right, binary_str)\\n        \\n        return left + right",
                "codeTag": "Python3"
            },
            {
                "id": 1506898,
                "title": "java-basic-approach",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        helper(root, new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(TreeNode root, List<Integer> ls) {\\n        if (root == null) return;\\n        ls.add(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            int size = ls.size();\\n            int i = 0;\\n            for (int j = size - 1; j >= 0; j--) {\\n                ans += ls.get(j) * Math.pow(2, i);\\n                i++;\\n            }\\n        } else {\\n            helper(root.left, ls);\\n            helper(root.right, ls);\\n        }\\n        ls.remove(ls.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        helper(root, new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(TreeNode root, List<Integer> ls) {\\n        if (root == null) return;\\n        ls.add(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            int size = ls.size();\\n            int i = 0;\\n            for (int j = size - 1; j >= 0; j--) {\\n                ans += ls.get(j) * Math.pow(2, i);\\n                i++;\\n            }\\n        } else {\\n            helper(root.left, ls);\\n            helper(root.right, ls);\\n        }\\n        ls.remove(ls.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381894,
                "title": "explained-code-c-dfs",
                "content": "we are adding the value of the path in a variable named t. for every new node we are multiplying the **t** with 2 and adding the value of that particular node. (why multiplying it by 2?)\\nlets say we have a number in decimal say :5678\\nwe can write it as num=5 * 10+6;\\nnum+=num * 10+7;\\nnum+=num*10+8\\n\\nin the same way we can write the binary value say \"10110\" as\\nbin=bin * 2+1;\\nbin+=bin * 2+0;\\nbin+=bin * 2+1;\\nbin+=bin * 2+1;\\nbin+=bin * 2+0;\\n\\nand when even i am encountering a leaf node i am just adding the value in sum.\\n\\n**I hope i made you understand my approach.\\nplease upvote if you liked my solution**\\n\\n\\n#happy_coding\\n\\n```\\nint sum=0;\\n    void helper(TreeNode* root,int t)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        t*=2;\\n        t+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            sum+=t;\\n        }\\n        if(root->left)\\n        {\\n            helper(root->left,t);\\n        }\\n        if(root->right)\\n        {\\n            helper(root->right,t);\\n        }\\n        return;\\n    }\\n    \\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root,0);\\n        return sum; \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint sum=0;\\n    void helper(TreeNode* root,int t)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        t*=2;\\n        t+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            sum+=t;\\n        }\\n        if(root->left)\\n        {\\n            helper(root->left,t);\\n        }\\n        if(root->right)\\n        {\\n            helper(root->right,t);\\n        }\\n        return;\\n    }\\n    \\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root,0);\\n        return sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343704,
                "title": "python-solution-using-strings-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\ndef sum_root(root, parent_string):\\n    total = 0\\n    \\n    if root is None:\\n        return total\\n\\n    if root.left is None and root.right is None:\\n        total += int(parent_string + str(root.val), 2)\\n\\n    else:\\n        if root.right:\\n            total += sum_root(root.right, parent_string + str(root.val))\\n\\n        if root.left:\\n            total += sum_root(root.left, parent_string + str(root.val))\\n    \\n    return total\\n    \\n    \\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return sum_root(root, \\'\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\ndef sum_root(root, parent_string):\\n    total = 0\\n    \\n    if root is None:\\n        return total\\n\\n    if root.left is None and root.right is None:\\n        total += int(parent_string + str(root.val), 2)\\n\\n    else:\\n        if root.right:\\n            total += sum_root(root.right, parent_string + str(root.val))\\n\\n        if root.left:\\n            total += sum_root(root.left, parent_string + str(root.val))\\n    \\n    return total\\n    \\n    \\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return sum_root(root, \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256676,
                "title": "easy-to-understand-c-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int sum=0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        inorder(root);\\n        return sum;\\n        \\n    }\\n    \\n    void inorder(TreeNode* node){\\n        if(!node)\\n            return;\\n        \\n        v.push_back(node->val);\\n        \\n        inorder(node->left);\\n        inorder(node->right);\\n        if(!node->left && !node->right){\\n         int r=v.size();\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i]*pow(2,r-1);\\n            r--;\\n          }\\n        }\\n        v.pop_back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int sum=0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        if(!root)\\n            return 0;\\n        inorder(root);\\n        return sum;\\n        \\n    }\\n    \\n    void inorder(TreeNode* node){\\n        if(!node)\\n            return;\\n        \\n        v.push_back(node->val);\\n        \\n        inorder(node->left);\\n        inorder(node->right);\\n        if(!node->left && !node->right){\\n         int r=v.size();\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i]*pow(2,r-1);\\n            r--;\\n          }\\n        }\\n        v.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230775,
                "title": "c-simple-and-easily-understandable-solution",
                "content": "```\\nstring s=\"\";\\n    int Supersum = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        help(root, 0);\\n        return Supersum;\\n    }\\n    void help(TreeNode* root, int sum)\\n    {\\n        if(root == NULL) { return; }\\n        s += to_string(root->val);\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            Supersum += stoi(s, 0, 2);\\n            // cout<<\"Sum added\"<<endl;\\n        }\\n        if(root->left) { help(root->left, Supersum); }\\n        if(root->right) { help(root->right, Supersum); }\\n        s.erase(s.end()-1);\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nstring s=\"\";\\n    int Supersum = 0;\\n    int sumRootToLeaf(TreeNode* root) {\\n        help(root, 0);\\n        return Supersum;\\n    }\\n    void help(TreeNode* root, int sum)\\n    {\\n        if(root == NULL) { return; }\\n        s += to_string(root->val);\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            Supersum += stoi(s, 0, 2);\\n            // cout<<\"Sum added\"<<endl;\\n        }\\n        if(root->left) { help(root->left, Supersum); }\\n        if(root->right) { help(root->right, Supersum); }\\n        s.erase(s.end()-1);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1211525,
                "title": "java-recursion-0ms-beats-100-t-c-o-n-s-c-o-n",
                "content": "\\n    // O(n) O(n)\\n\\tpublic int sumRootToLeaf(TreeNode root) {\\n\\t\\treturn sumRootToLeafHelper(root, 0);\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\tpublic int sumRootToLeafHelper(TreeNode root, int dec) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (root.left == null && root.right == null)\\n\\t\\t\\treturn (dec << 1) | root.val;\\n\\n\\t\\tint temp = dec;\\n\\t\\ttemp = (temp << 1) | root.val;\\n\\t\\tint left = sumRootToLeafHelper(root.left, temp);\\n\\t\\tint right = sumRootToLeafHelper(root.right, temp);\\n\\n\\t\\treturn left + right;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(n) O(n)\\n\\tpublic int sumRootToLeaf(TreeNode root) {\\n\\t\\treturn sumRootToLeafHelper(root, 0);\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\tpublic int sumRootToLeafHelper(TreeNode root, int dec) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (root.left == null && root.right == null)\\n\\t\\t\\treturn (dec << 1) | root.val;\\n\\n\\t\\tint temp = dec;\\n\\t\\ttemp = (temp << 1) | root.val;\\n\\t\\tint left = sumRootToLeafHelper(root.left, temp);\\n\\t\\tint right = sumRootToLeafHelper(root.right, temp);\\n\\n\\t\\treturn left + right;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1164720,
                "title": "weeb-does-python-bfs",
                "content": "Step 1: use bfs to get from root to leaf\\nStep 2: use the curpath to get the sum of each binary digit\\n\\nPlease note that my solution requires a basic understanding of how to get the value of a binary digit\\nif u dont know then here is an example:\\n\\nlet curpath == [1, 0, 0]. This means my binary digit is 100 according to my code below\\nSo, to convert it to a value it should be done like this:\\n100 == 2 ** 2 + 0 + 0 == 4  so 100 binary digit is 4 in integer value\\n\\nif binary digit is 0 then we ignore it\\nif binary digit is 1 then we 2 ** of current position of digit(0 indexed btw).\\n\\nanother example: let curpath == [1, 0, 1, 0, 1] so binary digit is 10101\\n10101 == 2 ** 4 + 0 + 2 ** 2 + 0 + 2 ** 0 == 21 so 10101 in binary digit is 21 in integer value\\n\\nhope u understand it cuz if u dont then u probably wont understand my code\\n\\n\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\t\\t\\tqueue, total = deque([(root, [root.val], 0)]), 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurNode, curpath, length = queue.popleft()\\n\\n\\t\\t\\t\\tif not curNode.left and not curNode.right:\\n\\t\\t\\t\\t\\tfor val in curpath:\\n\\t\\t\\t\\t\\t\\tif val == 1: \\n\\t\\t\\t\\t\\t\\t\\ttotal += 2 ** length \\n\\t\\t\\t\\t\\t\\tlength -= 1\\n\\n\\t\\t\\t\\tif curNode.left:\\n\\t\\t\\t\\t\\tqueue.append((curNode.left, curpath + [curNode.left.val], length + 1))\\n\\n\\t\\t\\t\\tif curNode.right:\\n\\t\\t\\t\\t\\tqueue.append((curNode.right, curpath + [curNode.right.val], length + 1))\\n\\n\\t\\t\\treturn total\\n\\nAnyways, now its time for some anime recommendations\\n# Hurry up and watch ***Golden Time***\\n\\n## Genre: Romantic comedy\\n## Episodes: 24\\n\\n**Best romcom of all time**, The plot was good and the character development in this show is amazing.\\nI highly recommend you to watch it\\nNow stop coding, get a snicker, a sprite and slack off cuz its anime time.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "Step 1: use bfs to get from root to leaf\\nStep 2: use the curpath to get the sum of each binary digit\\n\\nPlease note that my solution requires a basic understanding of how to get the value of a binary digit\\nif u dont know then here is an example:\\n\\nlet curpath == [1, 0, 0]. This means my binary digit is 100 according to my code below\\nSo, to convert it to a value it should be done like this:\\n100 == 2 ** 2 + 0 + 0 == 4  so 100 binary digit is 4 in integer value\\n\\nif binary digit is 0 then we ignore it\\nif binary digit is 1 then we 2 ** of current position of digit(0 indexed btw).\\n\\nanother example: let curpath == [1, 0, 1, 0, 1] so binary digit is 10101\\n10101 == 2 ** 4 + 0 + 2 ** 2 + 0 + 2 ** 0 == 21 so 10101 in binary digit is 21 in integer value\\n\\nhope u understand it cuz if u dont then u probably wont understand my code\\n\\n\\tclass Solution:\\n\\t\\tdef sumRootToLeaf(self, root: TreeNode) -> int:\\n\\t\\t\\tqueue, total = deque([(root, [root.val], 0)]), 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurNode, curpath, length = queue.popleft()\\n\\n\\t\\t\\t\\tif not curNode.left and not curNode.right:\\n\\t\\t\\t\\t\\tfor val in curpath:\\n\\t\\t\\t\\t\\t\\tif val == 1: \\n\\t\\t\\t\\t\\t\\t\\ttotal += 2 ** length \\n\\t\\t\\t\\t\\t\\tlength -= 1\\n\\n\\t\\t\\t\\tif curNode.left:\\n\\t\\t\\t\\t\\tqueue.append((curNode.left, curpath + [curNode.left.val], length + 1))\\n\\n\\t\\t\\t\\tif curNode.right:\\n\\t\\t\\t\\t\\tqueue.append((curNode.right, curpath + [curNode.right.val], length + 1))\\n\\n\\t\\t\\treturn total\\n\\nAnyways, now its time for some anime recommendations\\n# Hurry up and watch ***Golden Time***\\n\\n## Genre: Romantic comedy\\n## Episodes: 24\\n\\n**Best romcom of all time**, The plot was good and the character development in this show is amazing.\\nI highly recommend you to watch it\\nNow stop coding, get a snicker, a sprite and slack off cuz its anime time.\\n",
                "codeTag": "Java"
            },
            {
                "id": 1052127,
                "title": "simple-java-solution-100-recursion",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        List<Integer> nums = new ArrayList<>();\\n        return search(root, 0);\\n    }\\n\\n    public int search(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n\\n        sum = sum*2 + root.val;\\n        if(root.left == null && root.right == null) return sum; // reached out leaf node.\\n        return search(root.left, sum) + search(root.right, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        List<Integer> nums = new ArrayList<>();\\n        return search(root, 0);\\n    }\\n\\n    public int search(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n\\n        sum = sum*2 + root.val;\\n        if(root.left == null && root.right == null) return sum; // reached out leaf node.\\n        return search(root.left, sum) + search(root.right, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024541,
                "title": "python-recursive-preorder-with-binary-string-to-decimal-conversion",
                "content": "##### Implementing a simple recursive pre-order function with an array for strings made by traversing till each leaf-node.\\nWith each recursion-call check if current-node is a leaf:\\n\\tIf yes, then append currently created string value to the res-array.\\n\\tIf no, then push left and right child nodes onto the stack.\\n\\nFinally just convert your string arrays into decimal using the int function and sum up the res-array.\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(root: TreeNode, res: str):\\n            if root:\\n                if root.left is None and root.right is None:\\n                    arr.append(res+str(root.val))\\n                else:\\n                    dfs(root.left, res+str(root.val))\\n                    dfs(root.right, res+str(root.val))\\n\\n        arr=[]\\n        dfs(root, \\'\\')\\n        return sum([int(i,2) for i in arr])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(root: TreeNode, res: str):\\n            if root:\\n                if root.left is None and root.right is None:\\n                    arr.append(res+str(root.val))\\n                else:\\n                    dfs(root.left, res+str(root.val))\\n                    dfs(root.right, res+str(root.val))\\n\\n        arr=[]\\n        dfs(root, \\'\\')\\n        return sum([int(i,2) for i in arr])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888559,
                "title": "python-a-clear-and-simple-dfs-implementation-time-o-n-space-o-h",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, num):\\n            if not node:\\n                return\\n            \\n            num = 2*num + node.val                        \\n            if not node.left and not node.right:\\n                self.sum_ += num\\n                return            \\n            dfs(node.left, num)                \\n            dfs(node.right, num)\\n            \\n        self.sum_ = 0\\n        dfs(root, 0)\\n        return self.sum_\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, num):\\n            if not node:\\n                return\\n            \\n            num = 2*num + node.val                        \\n            if not node.left and not node.right:\\n                self.sum_ += num\\n                return            \\n            dfs(node.left, num)                \\n            dfs(node.right, num)\\n            \\n        self.sum_ = 0\\n        dfs(root, 0)\\n        return self.sum_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836878,
                "title": "rust-dfs-100-bitshift-and-bitwise-or",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let int = 0;\\n        let mut sum = 0;\\n        if let Some(n) = root {\\n            Self::dfs(n, int, &mut sum);\\n        }\\n        sum\\n    }\\n    fn dfs(n: Rc<RefCell<TreeNode>>, int: i32, sum: &mut i32) {\\n        let next_int = (int << 1) | n.borrow().val;\\n        if n.borrow().left.is_none() && n.borrow().right.is_none() {\\n            *sum += next_int;\\n        } else {\\n            if let Some(l) = n.borrow().left.clone() {\\n                Self::dfs(l, next_int, sum);\\n            }\\n            if let Some(r) = n.borrow().right.clone() {\\n                Self::dfs(r, next_int, sum);           \\n            }          \\n        }\\n\\n    }\\n}\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let int = 0;\\n        let mut sum = 0;\\n        if let Some(n) = root {\\n            Self::dfs(n, int, &mut sum);\\n        }\\n        sum\\n    }\\n    fn dfs(n: Rc<RefCell<TreeNode>>, int: i32, sum: &mut i32) {\\n        let next_int = (int << 1) | n.borrow().val;\\n        if n.borrow().left.is_none() && n.borrow().right.is_none() {\\n            *sum += next_int;\\n        } else {\\n            if let Some(l) = n.borrow().left.clone() {\\n                Self::dfs(l, next_int, sum);\\n            }\\n            if let Some(r) = n.borrow().right.clone() {\\n                Self::dfs(r, next_int, sum);           \\n            }          \\n        }\\n\\n    }\\n}\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836445,
                "title": "sum-of-root-to-leaf-binary-numbers",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n        def sum_leafs(node, path=[]):\\n            if node is None:\\n                return 0\\n            if node.left is None and node.right is None:\\n                path.append(node.val)\\n                return int(\\'\\'.join(map(str, path)), 2) \\n            return (\\n                sum_leafs(node.right, path + [node.val]) +\\n                sum_leafs(node.left, path + [node.val]))\\n\\n        return sum_leafs(root)\\n```\\n\\nEdit:\\nBasicaly the idea is memoizing path (a list of integers) while travesing the tree and detect when we reach a leaf node and then sum up all of them.\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n\\n        def sum_leafs(node, path=[]):\\n            if node is None:\\n                return 0\\n            if node.left is None and node.right is None:\\n                path.append(node.val)\\n                return int(\\'\\'.join(map(str, path)), 2) \\n            return (\\n                sum_leafs(node.right, path + [node.val]) +\\n                sum_leafs(node.left, path + [node.val]))\\n\\n        return sum_leafs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836385,
                "title": "c-dfs-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int &ans, int k) {\\n        if(root==NULL) {\\n            return ;\\n        }\\n        k = (k<<1)|(root->val);\\n        if(!root->left && !root->right) {\\n            ans+=k;\\n            return;\\n        }\\n        solve(root->left,ans, k);\\n        solve(root->right, ans, k);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int ans=0,k=0;\\n        solve(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int &ans, int k) {\\n        if(root==NULL) {\\n            return ;\\n        }\\n        k = (k<<1)|(root->val);\\n        if(!root->left && !root->right) {\\n            ans+=k;\\n            return;\\n        }\\n        solve(root->left,ans, k);\\n        solve(root->right, ans, k);\\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int ans=0,k=0;\\n        solve(root, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836246,
                "title": "python-easy-solution",
                "content": "```\\ndef sumRootToLeaf(self, root):\\n\\t\"\"\"\\n\\t:type root: TreeNode\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tnums = []\\n\\tdef dfs(node, s):\\n\\t\\ts += str(node.val)\\n\\t\\tif node.left:\\n\\t\\t\\tdfs(node.left, s)\\n\\t\\tif node.right:\\n\\t\\t\\tdfs(node.right, s)\\n\\t\\tif not node.left and not node.right:\\n\\t\\t\\tnums.append(s)\\n\\tdfs(root, \\'\\')\\n\\treturn sum(int(s, 2) for s in nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef sumRootToLeaf(self, root):\\n\\t\"\"\"\\n\\t:type root: TreeNode\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tnums = []\\n\\tdef dfs(node, s):\\n\\t\\ts += str(node.val)\\n\\t\\tif node.left:\\n\\t\\t\\tdfs(node.left, s)\\n\\t\\tif node.right:\\n\\t\\t\\tdfs(node.right, s)\\n\\t\\tif not node.left and not node.right:\\n\\t\\t\\tnums.append(s)\\n\\tdfs(root, \\'\\')\\n\\treturn sum(int(s, 2) for s in nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 836224,
                "title": "python-solution-explanation-o-n-4-lines-only",
                "content": "In order to solve the problem we traverse the tree in a **Preorder Traversal** i.e. Root -> Left ->Right. We first calculate sum value calaculate upto the given node and then traverse for the subsequent left and right sub tree and then add them\\n\\n**Basic Formula Used:** \\nn << 1 | root.value\\nWhen we left shift a binary number say 11, the result is 110 and then OR the root value, we get our required sum for the given node. Time Complexity is O(N) since all nodes are visted only once.\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self.calcSum(root, 0)\\n    \\n    def calcSum(self, root: TreeNode, n: int) -> int:\\n        \\n        if(root == None): return 0\\n        n = n << 1 | root.val\\n        if(root.left == None and root.right == None): return n\\n        return ( self.calcSum(root.left,n) + self.calcSum(root.right,n) )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        return self.calcSum(root, 0)\\n    \\n    def calcSum(self, root: TreeNode, n: int) -> int:\\n        \\n        if(root == None): return 0\\n        n = n << 1 | root.val\\n        if(root.left == None and root.right == None): return n\\n        return ( self.calcSum(root.left,n) + self.calcSum(root.right,n) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835893,
                "title": "python-very-easy-to-understand-runtime-beats-94-python-submissions",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.res = 0\\n        def traverse(root,s):\\n            if root:\\n                s += str(root.val)\\n                if not root.left and not root.right:\\n                    self.res += int(s,2)    #Binary to Decimal Conversion and value addition\\n                    return\\n                traverse(root.left,s)\\n                traverse(root.right,s)\\n            return\\n        traverse(root,\\'\\')\\n        return(self.res)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please Upvote!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        self.res = 0\\n        def traverse(root,s):\\n            if root:\\n                s += str(root.val)\\n                if not root.left and not root.right:\\n                    self.res += int(s,2)    #Binary to Decimal Conversion and value addition\\n                    return\\n                traverse(root.left,s)\\n                traverse(root.right,s)\\n            return\\n        traverse(root,\\'\\')\\n        return(self.res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754275,
                "title": "kotlin-shift-left-of-bits",
                "content": "```\\n    private var sum = 0\\n    fun sumRootToLeaf(root: TreeNode?): Int {\\n        if (root == null) return sum\\n        paths(root, root.`val`)\\n        return sum\\n    }\\n    \\n    private fun paths(root: TreeNode, path: Int) {\\n        if (root.left == null && root.right == null) { // we have reached a leaf\\n            sum += path\\n            return\\n        }\\n        root.left?.let {\\n            val leftPath = (path shl 1) + it.`val` // shift left the current path and add the left node value\\n            paths(it, leftPath)\\n        }\\n        root.right?.let {\\n            val rightPath = (path shl 1) + it.`val`\\n            paths(it, rightPath)\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    private var sum = 0\\n    fun sumRootToLeaf(root: TreeNode?): Int {\\n        if (root == null) return sum\\n        paths(root, root.`val`)\\n        return sum\\n    }\\n    \\n    private fun paths(root: TreeNode, path: Int) {\\n        if (root.left == null && root.right == null) { // we have reached a leaf\\n            sum += path\\n            return\\n        }\\n        root.left?.let {\\n            val leftPath = (path shl 1) + it.`val` // shift left the current path and add the left node value\\n            paths(it, leftPath)\\n        }\\n        root.right?.let {\\n            val rightPath = (path shl 1) + it.`val`\\n            paths(it, rightPath)\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751960,
                "title": "java-bfs-solution",
                "content": "Not as good as DFS due to space complexity.\\n\\n```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int sum = 0;\\n        \\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(root, root.val));\\n        int newValue = 0;\\n        while (!q.isEmpty()) {\\n            Pair<TreeNode, Integer> current = q.poll();\\n            TreeNode node = current.getKey();\\n            int value = current.getValue();\\n            if (node.left == null && node.right == null) {\\n                sum = sum + value;\\n                continue;\\n            }\\n            \\n            if (node.left != null) {\\n                newValue = (value << 1) + node.left.val;\\n                q.add(new Pair(node.left, newValue));\\n            }\\n            \\n            if (node.right != null) {\\n                newValue = (value << 1) + node.right.val;\\n                q.add(new Pair(node.right, newValue));\\n            }            \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int sum = 0;\\n        \\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(root, root.val));\\n        int newValue = 0;\\n        while (!q.isEmpty()) {\\n            Pair<TreeNode, Integer> current = q.poll();\\n            TreeNode node = current.getKey();\\n            int value = current.getValue();\\n            if (node.left == null && node.right == null) {\\n                sum = sum + value;\\n                continue;\\n            }\\n            \\n            if (node.left != null) {\\n                newValue = (value << 1) + node.left.val;\\n                q.add(new Pair(node.left, newValue));\\n            }\\n            \\n            if (node.right != null) {\\n                newValue = (value << 1) + node.right.val;\\n                q.add(new Pair(node.right, newValue));\\n            }            \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729767,
                "title": "c-simple-n-short-bit-twiddling",
                "content": "```\\nvoid trav(struct TreeNode *root, int *i, int *s){\\n    if (root) {\\n        *i = (*i << 1) | root->val;\\n        !root->left && !root->right ? *s += *i : 0;\\n        trav(root->left, i, s);\\n        trav(root->right, i, s);\\n        *i >>= 1;        \\n    }\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    int i = 0, s = 0;\\n    trav(root, &i, &s);\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid trav(struct TreeNode *root, int *i, int *s){\\n    if (root) {\\n        *i = (*i << 1) | root->val;\\n        !root->left && !root->right ? *s += *i : 0;\\n        trav(root->left, i, s);\\n        trav(root->right, i, s);\\n        *i >>= 1;        \\n    }\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    int i = 0, s = 0;\\n    trav(root, &i, &s);\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 668687,
                "title": "java-100-efficient-solution-and-easy-to-understand",
                "content": "```\\nint sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        sumRootToLeaf(root, 0);\\n        return sum;\\n    }\\n\\n    public void sumRootToLeaf(TreeNode root, int sum) {\\n        if (root == null) return;\\n\\n        sum = (sum * 2) + root.val;\\n        sumRootToLeaf(root.left, sum);\\n        sumRootToLeaf(root.right, sum);\\n        if (root.left == null && root.right == null) {\\n            this.sum += sum;\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\nint sum = 0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        if (root == null) return 0;\\n        sumRootToLeaf(root, 0);\\n        return sum;\\n    }\\n\\n    public void sumRootToLeaf(TreeNode root, int sum) {\\n        if (root == null) return;\\n\\n        sum = (sum * 2) + root.val;\\n        sumRootToLeaf(root.left, sum);\\n        sumRootToLeaf(root.right, sum);\\n        if (root.left == null && root.right == null) {\\n            this.sum += sum;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 640967,
                "title": "python-2-recursive-methods",
                "content": "### Method 1: Build a string of \\'1\\' and \\'0\\' for each root to leaf path\\n\\n1) Start at root node with a string of \\'0b\\' denoting the start of a binary string.  At every node, add the node value to the end of the string.  \\n\\n2) When a leaf node is reached add the path to reach that node (i.e. \\'1010\\') to self.res\\n\\n3) Convert each path from binary to an integer using int(path, 2) and return the sum.  \\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = []\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #2\\n                self.res.append(path + str(node.val))\\n                return\\n            \\n            if node.left: #1\\n                helper(node.left, path + str(node.val))\\n            \\n            if node.right: #1\\n                helper(node.right, path + str(node.val))\\n            \\n        \\n        helper(root, \\'0b\\')\\n        \\n        return sum([int(path,2) for path in self.res]) #3\\n```\\n\\n### Method 2: Manually increase result at at each leaf\\n\\n1) Start with a path of []\\n2) At every node append the node value to the beginning of the path\\n    * So the path (root = 1, to leaf = 0, [1,0,1,0]) looks like [0,1,0,1]\\n3) When a leaf node is reached, increase the result by value * (2 ** index) for each index in the reversed path.  This is equivalent to calculating the integer that the binary number represents.  For the example above this is 0 * 2 ** 0 + 1 * 2 ** 1 + 0 * 2 ** 2 + 1 * 2 ** 3 = 0 + 2 + 0 + 8 = 10\\n4) Once the helper function finishes the final node, res will be the sum of all of the root to leaf paths.  \\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = 0\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #3\\n                self.res += node.val\\n                for idx,val in enumerate(path):\\n                    self.res += val*(2**(idx+1))\\n                return\\n            \\n            if node.left:\\n                helper(node.left, [node.val] + path) #2\\n            \\n            if node.right:\\n                helper(node.right, [node.val] + path) #2 \\n            \\n        \\n        helper(root, []) #1\\n        \\n        return self.res #4\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = []\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #2\\n                self.res.append(path + str(node.val))\\n                return\\n            \\n            if node.left: #1\\n                helper(node.left, path + str(node.val))\\n            \\n            if node.right: #1\\n                helper(node.right, path + str(node.val))\\n            \\n        \\n        helper(root, \\'0b\\')\\n        \\n        return sum([int(path,2) for path in self.res]) #3\\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        if not root:\\n            return 0\\n        \\n        self.res = 0\\n        \\n        def helper(node, path):\\n            \\n            if not node.left and not node.right: #3\\n                self.res += node.val\\n                for idx,val in enumerate(path):\\n                    self.res += val*(2**(idx+1))\\n                return\\n            \\n            if node.left:\\n                helper(node.left, [node.val] + path) #2\\n            \\n            if node.right:\\n                helper(node.right, [node.val] + path) #2 \\n            \\n        \\n        helper(root, []) #1\\n        \\n        return self.res #4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609443,
                "title": "java-iterative-solution",
                "content": "use two stacks pop and push synchronously. one stack store node, another stack store value\\n```java\\npublic int sumRootToLeaf(TreeNode root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n\\n    int result = 0;\\n    Stack<TreeNode> nodeStack = new Stack<TreeNode>();\\n    Stack<Integer> valueStack = new Stack<Integer>();\\n    nodeStack.push(root);\\n    valueStack.push(root.val);\\n    while (!nodeStack.isEmpty()) {\\n        TreeNode node = nodeStack.pop();\\n        int value = valueStack.pop();\\n        if (node.left == null && node.right == null) {\\n            result += value;\\n        }\\n        if (node.left != null) {\\n            nodeStack.push(node.left);\\n            valueStack.push(value * 2 + node.left.val);\\n        } \\n        if (node.right != null) {\\n            nodeStack.push(node.right);\\n            valueStack.push(value * 2 + node.right.val);\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int sumRootToLeaf(TreeNode root) {\\n    if (root == null) {\\n        return 0;\\n    }\\n\\n    int result = 0;\\n    Stack<TreeNode> nodeStack = new Stack<TreeNode>();\\n    Stack<Integer> valueStack = new Stack<Integer>();\\n    nodeStack.push(root);\\n    valueStack.push(root.val);\\n    while (!nodeStack.isEmpty()) {\\n        TreeNode node = nodeStack.pop();\\n        int value = valueStack.pop();\\n        if (node.left == null && node.right == null) {\\n            result += value;\\n        }\\n        if (node.left != null) {\\n            nodeStack.push(node.left);\\n            valueStack.push(value * 2 + node.left.val);\\n        } \\n        if (node.right != null) {\\n            nodeStack.push(node.right);\\n            valueStack.push(value * 2 + node.right.val);\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594779,
                "title": "javascript-99-5-time-100-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\nlet sum=[];\\n     sumRoot(root,sum,0);\\n    return sum.reduce((acc,curr)=>acc+ curr,0)\\n};\\n\\n function sumRoot(root,sum,curr){\\n     curr=curr*2+root.val;\\nif(!root.left&&!root.right)sum.push(curr)\\n     \\n     if (root.left)sumRoot(root.left,sum,curr) ;\\n     if (root.right) sumRoot(root.right,sum,curr);\\n     \\n     \\n }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumRootToLeaf = function(root) {\\nlet sum=[];\\n     sumRoot(root,sum,0);\\n    return sum.reduce((acc,curr)=>acc+ curr,0)\\n};\\n\\n function sumRoot(root,sum,curr){\\n     curr=curr*2+root.val;\\nif(!root.left&&!root.right)sum.push(curr)\\n     \\n     if (root.left)sumRoot(root.left,sum,curr) ;\\n     if (root.right) sumRoot(root.right,sum,curr);\\n     \\n     \\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550735,
                "title": "python-99-32-recursive-explained-with-tips",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:       \\n        self.s = 0\\n        def preOrder(r,v):                      \\n            if r:           \\n                v = (v << 1) + r.val            \\n                if(r.left or r.right):\\n                    preOrder(r.left,v)\\n                    preOrder(r.right,v)\\n                else:\\n                    self.s += v    \\n                \\n        preOrder(root,0)\\n        return self.s \\n```\\n\\nThe idea is simple. We traverse the tree and every time we go lower, we push the current value down. Once we hit a leaf with no childred, we add the current value to a globa variable self.s.\\n\\nSo the tips part.\\n\\nVisually it is easier to see the value as a string with 0s and 1s, but to avoid unnessesary conversion, it\\'s better to keep everything as integers. A simple way to add the current value to the existing number is `v = (v << 1) + r.val ` - we shift bits to the left to free up space for the current bit. If you don\\'t like bit logic, you can do `v = v*2 + r.val` . \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:       \\n        self.s = 0\\n        def preOrder(r,v):                      \\n            if r:           \\n                v = (v << 1) + r.val            \\n                if(r.left or r.right):\\n                    preOrder(r.left,v)\\n                    preOrder(r.right,v)\\n                else:\\n                    self.s += v    \\n                \\n        preOrder(root,0)\\n        return self.s \\n```",
                "codeTag": "Java"
            },
            {
                "id": 543666,
                "title": "100-fast-and-memory",
                "content": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int ans = 0;\\n\\n    void helper(TreeNode *root, int pSum)\\n    {\\n        if (!root) return;\\n        int t = pSum * 2 + root->val;\\n        if (root->left == nullptr && root->right == nullptr)\\n        {\\n            ans += t;\\n            return;\\n        }\\n        helper(root->left, t);\\n        helper(root->right, t);\\n    }\\n\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root, 0);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int ans = 0;\\n\\n    void helper(TreeNode *root, int pSum)\\n    {\\n        if (!root) return;\\n        int t = pSum * 2 + root->val;\\n        if (root->left == nullptr && root->right == nullptr)\\n        {\\n            ans += t;\\n            return;\\n        }\\n        helper(root->left, t);\\n        helper(root->right, t);\\n    }\\n\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        helper(root, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493622,
                "title": "c-faster-than-94-05-less-than-100-mem-o-n",
                "content": "Runtime: 88 ms\\nMemory Usage: 24.8 MB\\n\\n```\\n    public int SumRootToLeaf(TreeNode root) {        \\n        return Traverse(root, 0);\\n    }\\n    \\n    private int Traverse(TreeNode root, int number)\\n    {\\n        if (root == null) { return 0; }\\n              \\n        number <<= 1; \\n        number += root.val;\\n        \\n        if (root.left == null && root.right == null) {  return number; }\\n        \\n        return Traverse(root.left, number) + Traverse(root.right, number);\\n    }\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public int SumRootToLeaf(TreeNode root) {        \\n        return Traverse(root, 0);\\n    }\\n    \\n    private int Traverse(TreeNode root, int number)\\n    {\\n        if (root == null) { return 0; }\\n              \\n        number <<= 1; \\n        number += root.val;\\n        \\n        if (root.left == null && root.right == null) {  return number; }\\n        \\n        return Traverse(root.left, number) + Traverse(root.right, number);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483603,
                "title": "rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        Self::h(&root, &mut res, &mut vec![]);\\n        res\\n    }\\n\\n    fn h(t: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32, p: &mut Vec<i32>) {\\n        if let Some(t) = t {\\n            let t = t.borrow();\\n            p.push(t.val);\\n            if t.left.is_none() && t.right.is_none() {\\n                let mut c = 0;\\n                p.iter().for_each(|x| c = (c << 1) | x);\\n                *res += c;\\n            } else {\\n                Self::h(&t.left, res, &mut p.clone());\\n                Self::h(&t.right, res, &mut p.clone());\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn sum_root_to_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        Self::h(&root, &mut res, &mut vec![]);\\n        res\\n    }\\n\\n    fn h(t: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32, p: &mut Vec<i32>) {\\n        if let Some(t) = t {\\n            let t = t.borrow();\\n            p.push(t.val);\\n            if t.left.is_none() && t.right.is_none() {\\n                let mut c = 0;\\n                p.iter().for_each(|x| c = (c << 1) | x);\\n                *res += c;\\n            } else {\\n                Self::h(&t.left, res, &mut p.clone());\\n                Self::h(&t.right, res, &mut p.clone());\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460062,
                "title": "c-0ms-dfs",
                "content": "```\\ntypedef struct TreeNode TreeNode;\\n\\nint dfs(TreeNode* root, int val) {\\n    if (root == NULL)\\n        return 0;\\n    \\n    val = (val << 1) + root->val;\\n    \\n    if (root->left == NULL && root->right == NULL) \\n        return val;\\n    \\n    return dfs(root->left,  val) + \\n           dfs(root->right, val);\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    return dfs(root, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct TreeNode TreeNode;\\n\\nint dfs(TreeNode* root, int val) {\\n    if (root == NULL)\\n        return 0;\\n    \\n    val = (val << 1) + root->val;\\n    \\n    if (root->left == NULL && root->right == NULL) \\n        return val;\\n    \\n    return dfs(root->left,  val) + \\n           dfs(root->right, val);\\n}\\n\\nint sumRootToLeaf(struct TreeNode* root){\\n    return dfs(root, 0);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 443666,
                "title": "java-iterating-method",
                "content": "\\t//   iterating method\\n\\t\\tpublic int sumRootToLeaf(TreeNode root) { \\n\\t\\t\\tif ( root == null ) return 0 ;\\n\\t\\t\\tStack<TreeNode> s = new Stack<>();\\n\\t\\t\\ts.push(root);\\n\\t\\t\\tint res = 0 ;\\n\\t\\t\\twhile( !s.empty() ){\\n\\t\\t\\t\\tTreeNode tmp = s.pop();\\n\\t\\t\\t\\tif (tmp.left != null) {\\n\\t\\t\\t\\t\\ttmp.left.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tmp.right != null) {\\n\\t\\t\\t\\t\\ttmp.right.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( tmp.left  == null && tmp.right == null ) res += tmp.val;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t//   iterating method\\n\\t\\tpublic int sumRootToLeaf(TreeNode root) { \\n\\t\\t\\tif ( root == null ) return 0 ;\\n\\t\\t\\tStack<TreeNode> s = new Stack<>();\\n\\t\\t\\ts.push(root);\\n\\t\\t\\tint res = 0 ;\\n\\t\\t\\twhile( !s.empty() ){\\n\\t\\t\\t\\tTreeNode tmp = s.pop();\\n\\t\\t\\t\\tif (tmp.left != null) {\\n\\t\\t\\t\\t\\ttmp.left.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tmp.right != null) {\\n\\t\\t\\t\\t\\ttmp.right.val += 2 * tmp.val;\\n\\t\\t\\t\\t\\ts.push(tmp.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( tmp.left  == null && tmp.right == null ) res += tmp.val;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 411429,
                "title": "python-iterative-dfs-98-19",
                "content": "This is a typical tree traversal problem. Both DFS and BFS should work in this setting. The only trick is that one needs to keep track of the value (binary value) up to the node that is being traversed. Below is a iterative implementation of DFS. \\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 2*val + node.val \\n            if node.left is node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\\n\\nEdited on 9/8/2020\\nAdding a recursive solution \\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node): \\n            \"\"\"Pre-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            nonlocal ans\\n            if not node: return \\n            stack.append(node.val)\\n            if node.left is node.right is None: ans += int(\"\".join(map(str, stack)), 2)\\n            fn(node.left) or fn(node.right)\\n            stack.pop()\\n        \\n        ans, stack = 0, []\\n        fn(root)\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node, x=0): \\n            \"\"\"Post-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            if not node: return 0 \\n            x = 2*x + node.val \\n            if node.left is node.right: return x\\n            return fn(node.left, x) + fn(node.right, x)\\n        \\n        return fn(root)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 2*val + node.val \\n            if node.left is node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node): \\n            \"\"\"Pre-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            nonlocal ans\\n            if not node: return \\n            stack.append(node.val)\\n            if node.left is node.right is None: ans += int(\"\".join(map(str, stack)), 2)\\n            fn(node.left) or fn(node.right)\\n            stack.pop()\\n        \\n        ans, stack = 0, []\\n        fn(root)\\n        return ans \\n```\n```\\nclass Solution:\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        \\n        def fn(node, x=0): \\n            \"\"\"Post-order traverse the tree and add root-to-leaf numbers.\"\"\"\\n            if not node: return 0 \\n            x = 2*x + node.val \\n            if node.left is node.right: return x\\n            return fn(node.left, x) + fn(node.right, x)\\n        \\n        return fn(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399469,
                "title": "easy-c-solution-4ms-beats-94",
                "content": "Runtime: 4 ms, faster than 94.22% of C++ online submissions for Sum of Root To Leaf Binary Numbers.\\nMemory Usage: 17 MB, less than 100.00% of C++ online submissions for Sum of Root To Leaf Binary Numbers.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        return sum(root, 0);\\n    }\\n    \\n    int sum(TreeNode* root, int parentSum)\\n    {\\n        int doubleParent = parentSum*2;\\n        \\n        if(root->left == nullptr && root->right == nullptr)\\n            return doubleParent + root->val;\\n        \\n        int leftSum = (root->left != nullptr) ? sum(root->left, doubleParent+root->val) : 0;\\n        int rightSum = (root->right != nullptr) ? sum(root->right, doubleParent+root->val) : 0;\\n        \\n        return leftSum+rightSum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        return sum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 392519,
                "title": "c-84-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public int SumRootToLeaf(TreeNode root)\\n            => Sum(root, 0);\\n\\n        private int Sum(TreeNode node, int number)\\n        {\\n            if (node == null)\\n            {\\n                return 0;\\n            }\\n            number = number * 2 + node.val;\\n            return\\n                node.left == null && node.right == null ?\\n                number :\\n                Sum(node.left, number) + Sum(node.right, number);\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int SumRootToLeaf(TreeNode root)\\n            => Sum(root, 0);\\n\\n        private int Sum(TreeNode node, int number)\\n        {\\n            if (node == null)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 367391,
                "title": "java-100-100",
                "content": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root , int sum){\\n        sum=sum*2+root.val;\\n        if(root.left==null&&root.right==null){\\n            return sum;\\n        }else if(root.left==null){\\n            return sumRootToLeaf(root.right,sum);\\n        }else if(root.right==null){\\n            return sumRootToLeaf(root.left,sum);\\n        }else{\\n            return sumRootToLeaf(root.right,sum)+sumRootToLeaf(root.left,sum);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return sumRootToLeaf(root,0);\\n    }\\n    \\n    public int sumRootToLeaf(TreeNode root , int sum){\\n        sum=sum*2+root.val;\\n        if(root.left==null&&root.right==null){\\n            return sum;\\n        }else if(root.left==null){\\n            return sumRootToLeaf(root.right,sum);\\n        }else if(root.right==null){\\n            return sumRootToLeaf(root.left,sum);\\n        }else{\\n            return sumRootToLeaf(root.right,sum)+sumRootToLeaf(root.left,sum);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354667,
                "title": "python-quick-recursive-1-way-down-no-shifting",
                "content": "```\\ndef sumRootToLeaf(self, root):\\n\\tdef dfe(root, binary):\\n\\t\\tif root == None:\\n\\t\\t\\treturn 0\\n\\t\\tbinary = binary+str(root.val)\\n\\t\\tif root.left == None and root.right == None:\\n\\t\\t\\ta.append(binary)\\n\\t\\t\\treturn 0\\n\\t\\tdfe(root.left, binary)\\n\\t\\tdfe(root.right, binary)\\n\\n\\n\\ta = []\\n\\tbinary = \\'\\'\\n\\tdfe(root, binary)\\n\\tres = 0\\n\\tfor b in a:\\n\\t\\tres = res + int(b, 2)\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndef sumRootToLeaf(self, root):\\n\\tdef dfe(root, binary):\\n\\t\\tif root == None:\\n\\t\\t\\treturn 0\\n\\t\\tbinary = binary+str(root.val)\\n\\t\\tif root.left == None and root.right == None:\\n\\t\\t\\ta.append(binary)\\n\\t\\t\\treturn 0\\n\\t\\tdfe(root.left, binary)\\n\\t\\tdfe(root.right, binary)\\n\\n\\n\\ta = []\\n\\tbinary = \\'\\'\\n\\tdfe(root, binary)\\n\\tres = 0\\n\\tfor b in a:\\n\\t\\tres = res + int(b, 2)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 321139,
                "title": "java-2-methods-reuse-lc-129",
                "content": "**Idea:** Swap 10 with 2 (base of digits) in [LC 129: Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/1555892/Java-or-DFS-or-Time-beats-100)\\n>**T/S:** O(n)/O(d), n = number of nodes, d = depth\\n ```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\treturn sumRootToLeaf(root, 0);\\n}\\n\\npublic int sumRootToLeaf(TreeNode root, int sum) {\\n\\tif (root == null)\\n\\t\\treturn 0;\\n\\t\\t\\n\\tsum = (sum * 2) + root.val;\\n\\t\\n\\treturn (root.left == null && root.right == null) ? \\n\\t\\t\\t   sum : \\n\\t\\t\\t   sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n}\\n```\\n\\n**Method 2:** Build the number\\n>**T/S:** O(n)/O(d), n = number of nodes, d = depth\\n```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tint[] sum = {0};\\n\\tsumRootToLeaf(root, new StringBuffer(), sum);\\n\\treturn sum[0];\\n}\\n\\nprivate void sumRootToLeaf(TreeNode root, StringBuffer sb, int[] sum) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\n\\tsb.append(root.val);\\n\\n\\tif (root.left == null && root.right == null) { // leaf node\\n\\t\\tsum[0] += Integer.parseInt(sb.toString(), 2);\\n\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t} else {\\n\\t\\tsumRootToLeaf(root.left, sb, sum);\\n\\t\\tsumRootToLeaf(root.right, sb, sum);\\n\\t\\tif (sb.length() != 0)\\n\\t\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\treturn sumRootToLeaf(root, 0);\\n}\\n\\npublic int sumRootToLeaf(TreeNode root, int sum) {\\n\\tif (root == null)\\n\\t\\treturn 0;\\n\\t\\t\\n\\tsum = (sum * 2) + root.val;\\n\\t\\n\\treturn (root.left == null && root.right == null) ? \\n\\t\\t\\t   sum : \\n\\t\\t\\t   sumRootToLeaf(root.left, sum) + sumRootToLeaf(root.right, sum);\\n}\\n```\n```\\npublic int sumRootToLeaf(TreeNode root) {\\n\\tint[] sum = {0};\\n\\tsumRootToLeaf(root, new StringBuffer(), sum);\\n\\treturn sum[0];\\n}\\n\\nprivate void sumRootToLeaf(TreeNode root, StringBuffer sb, int[] sum) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\n\\tsb.append(root.val);\\n\\n\\tif (root.left == null && root.right == null) { // leaf node\\n\\t\\tsum[0] += Integer.parseInt(sb.toString(), 2);\\n\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t} else {\\n\\t\\tsumRootToLeaf(root.left, sb, sum);\\n\\t\\tsumRootToLeaf(root.right, sb, sum);\\n\\t\\tif (sb.length() != 0)\\n\\t\\t\\tsb.deleteCharAt(sb.length() - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311653,
                "title": "javascript",
                "content": "```\\nvar sumRootToLeaf = function(root) {\\n    let res = 0;\\n    let DFS = (root, S) => {\\n        if(!root) return;\\n        S += root.val;\\n        if(!root.left && !root.right) {\\n            res += parseInt(S, 2);\\n            return;\\n        }\\n        DFS(root.left, S);\\n        DFS(root.right, S);\\n    }\\n    DFS(root, \\'\\');\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sumRootToLeaf = function(root) {\\n    let res = 0;\\n    let DFS = (root, S) => {\\n        if(!root) return;\\n        S += root.val;\\n        if(!root.left && !root.right) {\\n            res += parseInt(S, 2);\\n            return;\\n        }\\n        DFS(root.left, S);\\n        DFS(root.right, S);\\n    }\\n    DFS(root, \\'\\');\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271127,
                "title": "java-recursion-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        sum = sum * 2 + root.val;\\n        if(root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        int leftSum = root.left != null ? dfs(root.left, sum) : 0;\\n        int rightSum = root.right != null ? dfs(root.right, sum) : 0;\\n        return leftSum + rightSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        sum = sum * 2 + root.val;\\n        if(root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        int leftSum = root.left != null ? dfs(root.left, sum) : 0;\\n        int rightSum = root.right != null ? dfs(root.right, sum) : 0;\\n        return leftSum + rightSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680091,
                "title": "easy-java-100-global-variables-method-pre-order-traversal-dfs-explained",
                "content": "# Approach\\n- There are two approaches to this question - one with a numerical variable that stores the current bit values and the other one is a string variable that stores the bit values at a particular leaf node.\\n- The problem with the numerical variable is that, there\\'s a limit to how many bit values it can store and thus gives an error after the critical value. Hence we use the String variable to record the bit values.\\n- The problem is divided into two classes - main and helper\\n\\n# Global Variables\\n- number (String type)\\n- arr (Arraylist String type)\\n\\n# Helper Class\\n- The helper class takes a node as an input\\n- if node is null, returns to the parent node\\n- adds the node bit value to number\\n- checks if the node is leaf node, if yes, the current number value is appended in arr\\n- calls itself on current node left child\\n- calls itself on current node right child\\n- deletes the last character of number\\n\\n# Main class\\n- calls the helper class on root node\\n- arr is created and full of leaf node bit values but in string format\\n- create int variable sum = 0\\n- set a for loop to iterate thorugh the array\\n- convert each string bit value to integer and add it to the sum.\\n- return sum\\n\\n# Complexity\\n- Time complexity: O(V) V  is the number of nodes\\n\\n- Space complexity: O(L) L is the number of leaf nodes\\n\\n# Code\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public String number = \"\";\\n\\n    public List<String> arr = new ArrayList<>();\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        tree(root);\\n        int sum = 0;\\n        for(String i: arr){\\n            int a = Integer.parseInt(i, 2);\\n            System.out.println(a);\\n            sum += a;\\n        }\\n        return sum;\\n    }\\n\\n    public void tree(TreeNode x){\\n        if(x == null){\\n            return;\\n        }\\n\\n        number = number + String.valueOf(x.val);\\n\\n        if(x.left == null && x.right == null){\\n            arr.add(number);\\n        }\\n\\n        tree(x.left);\\n        tree(x.right);\\n\\n        number = number.substring(0,number.length()-1);\\n\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/4c993713-be95-4251-b6b5-2bfbd911fbac_1687678864.5214777.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public String number = \"\";\\n\\n    public List<String> arr = new ArrayList<>();\\n    \\n    public int sumRootToLeaf(TreeNode root) {\\n        tree(root);\\n        int sum = 0;\\n        for(String i: arr){\\n            int a = Integer.parseInt(i, 2);\\n            System.out.println(a);\\n            sum += a;\\n        }\\n        return sum;\\n    }\\n\\n    public void tree(TreeNode x){\\n        if(x == null){\\n            return;\\n        }\\n\\n        number = number + String.valueOf(x.val);\\n\\n        if(x.left == null && x.right == null){\\n            arr.add(number);\\n        }\\n\\n        tree(x.left);\\n        tree(x.right);\\n\\n        number = number.substring(0,number.length()-1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594435,
                "title": "c-very-rare-solution-super-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solver(TreeNode* root, int value){\\n        if(root == nullptr) return 0;\\n        \\n        value = value * 2 + root->val;\\n        if(root->left == nullptr && root->right == nullptr){\\n            return value;\\n        }\\n        return solver(root->left,value) + solver(root->right,value);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return solver(root,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solver(TreeNode* root, int value){\\n        if(root == nullptr) return 0;\\n        \\n        value = value * 2 + root->val;\\n        if(root->left == nullptr && root->right == nullptr){\\n            return value;\\n        }\\n        return solver(root->left,value) + solver(root->right,value);\\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        return solver(root,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3551124,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root, int val, int& res){\\n    if(!root) return;\\n\\n    val = val | root->val;\\n    if(!root->left && !root->right){\\n        res+=val;\\n        return;\\n    }\\n    helper(root->left,  val<<1, res);\\n    helper(root->right, val<<1, res);\\n}\\nvoid helper1(TreeNode* root,  int out, int& res){\\n    if(!root) return;\\n\\n    out = (out<<1) + root->val;\\n    if(!root->left && !root->right){\\n        res+=out;\\n        return;\\n    }\\n    helper1(root->left,out,res);\\n    helper1(root->right,out,res);\\n}\\nint sumRootToLeaf(TreeNode* root) {\\n        int res = 0;\\n        helper1(root,0,res);\\n        return res;    \\n}\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        result = 0\\n        if not root:\\n            return 0\\n        def dfs(node, slate):\\n            nonlocal result\\n            if not node.left and not node.right:\\n                slate.append(str(node.val))\\n                result += int(\"\".join(slate), 2)\\n            \\n            if node.left: dfs(node.left, slate + [str(node.val)])\\n            if node.right: dfs(node.right, slate + [str(node.val)])\\n        \\n        dfs(root, [])\\n        return result\\n```\\n\\n```Java []\\nclass Solution {\\n     private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        return pathSumRootToLeaf(root.left, parentNodeSum) +            pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n          return pathSumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nvoid helper(TreeNode* root, int val, int& res){\\n    if(!root) return;\\n\\n    val = val | root->val;\\n    if(!root->left && !root->right){\\n        res+=val;\\n        return;\\n    }\\n    helper(root->left,  val<<1, res);\\n    helper(root->right, val<<1, res);\\n}\\nvoid helper1(TreeNode* root,  int out, int& res){\\n    if(!root) return;\\n\\n    out = (out<<1) + root->val;\\n    if(!root->left && !root->right){\\n        res+=out;\\n        return;\\n    }\\n    helper1(root->left,out,res);\\n    helper1(root->right,out,res);\\n}\\nint sumRootToLeaf(TreeNode* root) {\\n        int res = 0;\\n        helper1(root,0,res);\\n        return res;    \\n}\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        result = 0\\n        if not root:\\n            return 0\\n        def dfs(node, slate):\\n            nonlocal result\\n            if not node.left and not node.right:\\n                slate.append(str(node.val))\\n                result += int(\"\".join(slate), 2)\\n            \\n            if node.left: dfs(node.left, slate + [str(node.val)])\\n            if node.right: dfs(node.right, slate + [str(node.val)])\\n        \\n        dfs(root, [])\\n        return result\\n```\n```Java []\\nclass Solution {\\n     private int pathSumRootToLeaf(TreeNode root, int parentNodeSum){\\n        if(root == null) return 0;\\n        \\n        parentNodeSum = 2 * parentNodeSum + root.val;\\n        if(root.left == null && root.right == null){\\n            return parentNodeSum;\\n        }\\n        return pathSumRootToLeaf(root.left, parentNodeSum) +            pathSumRootToLeaf(root.right, parentNodeSum);\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n          return pathSumRootToLeaf(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507123,
                "title": "faster-than-100-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n\\n    void bin(string s) {\\n        int ans = 0;\\n        int n = s.size() - 1;\\n        for (auto i: s) {\\n            ans += (i - 48) * pow(2, n);\\n            n--;\\n        }\\n        sum += ans;\\n    }\\n\\n    void func(TreeNode *root, string s) {\\n        if (root == nullptr) {\\n            return bin(s);\\n        }\\n        s += std::to_string(root->val);\\n        if (root->right == nullptr && root->left == nullptr){\\n            return bin(s);\\n        } else {\\n            if (root->left == nullptr || root->right == nullptr){\\n                if (root->left != nullptr){\\n                    return func(root->left, s);\\n                } else {\\n                    return func(root->right, s);\\n                }\\n            } else {\\n                func(root->left, s);\\n                func(root->right, s);\\n            }\\n        }\\n\\n    }\\n\\n    int sumRootToLeaf(TreeNode *root) {\\n        func(root, \"\");\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n\\n    void bin(string s) {\\n        int ans = 0;\\n        int n = s.size() - 1;\\n        for (auto i: s) {\\n            ans += (i - 48) * pow(2, n);\\n            n--;\\n        }\\n        sum += ans;\\n    }\\n\\n    void func(TreeNode *root, string s) {\\n        if (root == nullptr) {\\n            return bin(s);\\n        }\\n        s += std::to_string(root->val);\\n        if (root->right == nullptr && root->left == nullptr){\\n            return bin(s);\\n        } else {\\n            if (root->left == nullptr || root->right == nullptr){\\n                if (root->left != nullptr){\\n                    return func(root->left, s);\\n                } else {\\n                    return func(root->right, s);\\n                }\\n            } else {\\n                func(root->left, s);\\n                func(root->right, s);\\n            }\\n        }\\n\\n    }\\n\\n    int sumRootToLeaf(TreeNode *root) {\\n        func(root, \"\");\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443812,
                "title": "multiple-cpp-solution-using-preorder-traversal-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void sum(TreeNode* root, int ans, set<int>& s){\\n        if(root == nullptr) {\\n            s.insert(ans);\\n            return;\\n        };\\n        int elem = root -> val;\\n        ans = ans * 10 + elem;\\n\\n        sum(root -> left, ans, s);\\n        sum(root -> right, ans, s);\\n    }\\n\\n    int sumOne(TreeNode* root, int ans){\\n\\n        if(root == nullptr) return 0;\\n\\n        int elem = root -> val;\\n        ans = ans * 2 + elem;\\n\\n        if(root -> left == NULL && root -> right == NULL){\\n            return ans;\\n        }\\n\\n        int leftSum = sumOne(root -> left, ans);\\n        int rightSum = sumOne(root -> right, ans);\\n\\n        return leftSum + rightSum;\\n\\n    }\\n \\n  \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        // set<int> s;\\n        // sum(root, 0, s);\\n\\n        // int ans = 0;\\n\\n        // for(auto& i: s){\\n        //     ans += binaryToDecimal(i);\\n        // }\\n\\n        // return ans;\\n\\n        return sumOne(root, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void sum(TreeNode* root, int ans, set<int>& s){\\n        if(root == nullptr) {\\n            s.insert(ans);\\n            return;\\n        };\\n        int elem = root -> val;\\n        ans = ans * 10 + elem;\\n\\n        sum(root -> left, ans, s);\\n        sum(root -> right, ans, s);\\n    }\\n\\n    int sumOne(TreeNode* root, int ans){\\n\\n        if(root == nullptr) return 0;\\n\\n        int elem = root -> val;\\n        ans = ans * 2 + elem;\\n\\n        if(root -> left == NULL && root -> right == NULL){\\n            return ans;\\n        }\\n\\n        int leftSum = sumOne(root -> left, ans);\\n        int rightSum = sumOne(root -> right, ans);\\n\\n        return leftSum + rightSum;\\n\\n    }\\n \\n  \\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        // set<int> s;\\n        // sum(root, 0, s);\\n\\n        // int ans = 0;\\n\\n        // for(auto& i: s){\\n        //     ans += binaryToDecimal(i);\\n        // }\\n\\n        // return ans;\\n\\n        return sumOne(root, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089328,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int solve(string a)\\n    {\\n        int ans=0;\\n        int t=a.length()-1;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]==\\'1\\')\\n            {\\n                ans+=pow(2,t);\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }\\n    void helper(TreeNode* root,string x,vector<string>&s)\\n    {\\n        if(root==NULL)return;\\n        if(root->left==NULL &&root->right==NULL)\\n        {\\n            x+=to_string(root->val);\\n            s.push_back(x);\\n        }\\n        x+=to_string(root->val);\\n        helper(root->left,x,s);\\n        helper(root->right,x,s);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<string>s;\\n        string x=\"\";\\n        helper(root,x,s);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans+=solve(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int solve(string a)\\n    {\\n        int ans=0;\\n        int t=a.length()-1;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]==\\'1\\')\\n            {\\n                ans+=pow(2,t);\\n            }\\n            t--;\\n        }\\n        return ans;\\n    }\\n    void helper(TreeNode* root,string x,vector<string>&s)\\n    {\\n        if(root==NULL)return;\\n        if(root->left==NULL &&root->right==NULL)\\n        {\\n            x+=to_string(root->val);\\n            s.push_back(x);\\n        }\\n        x+=to_string(root->val);\\n        helper(root->left,x,s);\\n        helper(root->right,x,s);\\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        vector<string>s;\\n        string x=\"\";\\n        helper(root,x,s);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans+=solve(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880444,
                "title": "c-very-easy-to-understand-tree-traversal",
                "content": "\\n\\n       /**\\n     * Definition for a binary tree node.\\n    * struct TreeNode {\\n    *     int val;\\n    *     TreeNode *left;\\n    *     TreeNode *right;\\n    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n    * };\\n    */\\n    class Solution {\\n    public:\\n         void dfs(TreeNode* node, int &ans ,string &str){\\n         \\n            if(node==NULL)\\n                 return;\\n         if(node->left==nullptr && node->right==nullptr){\\n               string s=str+to_string(node->val);\\n                 for(int i=0;i<s.size();++i){\\n                   ans+=pow(2,i)*(s[s.size()-i-1]-\\'0\\');\\n             }\\n                 return;\\n         }\\n         \\n         \\n         str+=to_string(node->val);\\n         dfs(node->left,ans,str);\\n         dfs(node->right,ans,str);\\n          str.pop_back();\\n                \\n     }\\n     \\n    int sumRootToLeaf(TreeNode* root) {\\n         int ans=0; \\n        string str;\\n        dfs(root,ans,str);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\n    public:\\n         void dfs(TreeNode* node, int &ans ,string &str){\\n         \\n            if(node==NULL)\\n                 return;\\n         if(node->left==nullptr && node->right==nullptr){\\n               string s=str+to_string(node->val);\\n                 for(int i=0;i<s.size();++i){\\n                   ans+=pow(2,i)*(s[s.size()-i-1]-\\'0\\');\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2673967,
                "title": "simple-solution",
                "content": "Here Idea is simple we can write binary 100 to decimal as   (2*(2*1)+0)+0=4.\\n\\nMultiply first digit with base and add the next bit to it and then with the result multiply it with base and add the next bit. Do the same procedure until there is no bit available to add.\\n\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        {\\n           return sum(root,0); \\n        }\\n    }\\n    int sum(TreeNode* root ,int till)\\n    {  \\n        till=till+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            return till;\\n        }\\n        if(root->left && root->right)\\n        {\\n            return sum(root->left,2*till)+sum(root->right,2*till);\\n        }\\n        if(root->right)\\n            return sum(root->right,2*till);\\n        if(root->left)\\n            return sum(root->left,2*till);\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        {\\n           return sum(root,0); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2517156,
                "title": "simple-recursive-solution",
                "content": "```\\nclass Solution {\\n    int total =0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        sumBinary(root, 0);\\n        return total;\\n    }\\n    \\n    public void sumBinary(TreeNode root, int sum){\\n        if(root==null)  return;        \\n        sum = sum * 2 + root.val;\\n        if(root.left==null && root.right==null){   \\n            total += sum;\\n            return;\\n        }             \\n        sumBinary(root.left,sum);\\n        sumBinary(root.right,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int total =0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        \\n        sumBinary(root, 0);\\n        return total;\\n    }\\n    \\n    public void sumBinary(TreeNode root, int sum){\\n        if(root==null)  return;        \\n        sum = sum * 2 + root.val;\\n        if(root.left==null && root.right==null){   \\n            total += sum;\\n            return;\\n        }             \\n        sumBinary(root.left,sum);\\n        sumBinary(root.right,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428079,
                "title": "no-title-just-kiidding-easy-java-soln",
                "content": "```\\nclass Solution {\\n    int res=0;\\n    void go(TreeNode node,int num){\\n        num=(num<<1)|node.val;\\n        if(node.left==null && node.right==null)res+=num;\\n        else{\\n            if(node. left!=null)go(node.left,num);\\n            if(node.right!=null)go(node.right,num);\\n        }\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n        go(root,0);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    void go(TreeNode node,int num){\\n        num=(num<<1)|node.val;\\n        if(node.left==null && node.right==null)res+=num;\\n        else{\\n            if(node. left!=null)go(node.left,num);\\n            if(node.right!=null)go(node.right,num);\\n        }\\n    }\\n    public int sumRootToLeaf(TreeNode root) {\\n        go(root,0);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415522,
                "title": "easy-to-understand-backtracking-cpp",
                "content": "class Solution {\\npublic:\\n    int sum;\\n    void dfs(TreeNode* root , string &s )\\n    {\\n        if(root == NULL)\\n            return ;\\n        \\n        s += to_string(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            sum = sum + stoi(s , 0 , 2);\\n            s.pop_back(); \\n            return ;\\n        }      \\n        \\n        dfs(root->left ,s); \\n        dfs(root->right ,s);\\n        s.pop_back(); \\n        \\n    }\\n    \\n    int sumRootToLeaf(TreeNode* root) {\\n        \\n        sum = 0;\\n        string s =\"\";\\n        dfs(root , s);\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int sum;\\n    void dfs(TreeNode* root , string &s )\\n    {\\n        if(root == NULL)\\n            return ;\\n        \\n        s += to_string(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            sum = sum + stoi(s , 0 , 2);\\n            s.pop_back(); \\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2353547,
                "title": "c-solution-easy-recursive-solution-tc-o-n-sc-o-1",
                "content": "```\\n// IF it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root,int &ans,int num){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left==NULL && root->right==NULL){\\n           num = (num << 1) + root->val;\\n           ans += num;\\n           return;\\n        }\\n\\n        // preorder traversal\\n        num = (num << 1) + root->val;\\n\\n        solve(root->left,ans,num);\\n        solve(root->right,ans,num);\\n    \\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        int num = 0;\\n        solve(root,ans,num);\\n        return ans;\\n    }\\n};\\n\\n// IF it helps plz upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n// IF it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root,int &ans,int num){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left==NULL && root->right==NULL){\\n           num = (num << 1) + root->val;\\n           ans += num;\\n           return;\\n        }\\n\\n        // preorder traversal\\n        num = (num << 1) + root->val;\\n\\n        solve(root->left,ans,num);\\n        solve(root->right,ans,num);\\n    \\n    }\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        int num = 0;\\n        solve(root,ans,num);\\n        return ans;\\n    }\\n};\\n\\n// IF it helps plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321687,
                "title": "c-fast-easy-commented-picture",
                "content": "![image](https://assets.leetcode.com/users/images/80abde06-c585-4ec7-be9c-ceca7a054fe3_1658580276.606866.png)\\n![image](https://assets.leetcode.com/users/images/57871122-a0f2-49da-b934-c1658a0f46ee_1658580356.3314888.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/80abde06-c585-4ec7-be9c-ceca7a054fe3_1658580276.606866.png)\\n![image](https://assets.leetcode.com/users/images/57871122-a0f2-49da-b934-c1658a0f46ee_1658580356.3314888.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2281298,
                "title": "java-solution-using-parseint",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String s)\\n    {\\n        s=s+Integer.toString(root.val);\\n        if(root.left==null && root.right==null)\\n        {\\n            sum=sum+Integer.parseInt(s,2);\\n            return ;\\n        }\\n        if(root.left!=null)\\n            helper(root.left,s);\\n        if(root.right!=null)\\n            helper(root.right,s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumRootToLeaf(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String s)\\n    {\\n        s=s+Integer.toString(root.val);\\n        if(root.left==null && root.right==null)\\n        {\\n            sum=sum+Integer.parseInt(s,2);\\n            return ;\\n        }\\n        if(root.left!=null)\\n            helper(root.left,s);\\n        if(root.right!=null)\\n            helper(root.right,s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245552,
                "title": "easy-python-recursive-solution-beats-95",
                "content": "\\t def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = []\\n        def solve(root, s):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                ans.append(s+str(root.val))\\n                return\\n            s += str(root.val)\\n            solve(root.left, s)\\n            solve(root.right,s)\\n        \\n        solve(root, \"\")\\n        res = 0\\n        for i in ans:\\n            res += int(i,2)\\n        return res",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\t def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        ans = []\\n        def solve(root, s):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                ans.append(s+str(root.val))\\n                return\\n            s += str(root.val)\\n            solve(root.left, s)\\n            solve(root.right,s)\\n        \\n        solve(root, \"\")\\n        res = 0\\n        for i in ans:\\n            res += int(i,2)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2222603,
                "title": "1022-sum-of-root-to-leaf-binary-numbers-100-faster-0ms",
                "content": "Simple Solution :-\\n\\n*Just Traverse from root to leaf and store the vale in an int value and use recursive calls to return answer.\\n\\nCODE ------------>\\n\\nclass Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSum(root, 0);\\n    }\\n    \\n    public int getSum(TreeNode root, int data){\\n        if (root==null) return 0;\\n        \\n        data = root.val+data*2;\\n        \\n        if (root.left==null && root.right==null){\\n            return data;\\n        }\\n        \\n        return getSum(root.left, data) + getSum(root.right, data);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int sumRootToLeaf(TreeNode root) {\\n        return getSum(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2220178,
                "title": "94-better-solution",
                "content": "```\\ndef f(root, ans):\\n    if root:\\n        ans = (2*ans) + root.val\\n        if not (root.left or root.right):\\n            return ans\\n        return f(root.left, ans) + f(root.right, ans)\\n    return 0\\n\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        return f(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef f(root, ans):\\n    if root:\\n        ans = (2*ans) + root.val\\n        if not (root.left or root.right):\\n            return ans\\n        return f(root.left, ans) + f(root.right, ans)\\n    return 0\\n\\n\\nclass Solution(object):\\n    def sumRootToLeaf(self, root):\\n        return f(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200281,
                "title": "easy-and-efficient-cpp-solution",
                "content": "//Please Upvote if Like \\n```\\n int sumRootToLeaf(TreeNode* root) {\\n         \\n        return sum_util(root,0);        \\n    }\\n    int sum_util(TreeNode* root,int sum)\\n    {\\n       if(root==nullptr)\\n           return 0;\\n        \\n      sum=2*sum+root->val;\\n      if(root->left==nullptr&&root->right==nullptr)\\n          return sum;\\n      return sum_util(root->left,sum)+sum_util(root->right,sum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int sumRootToLeaf(TreeNode* root) {\\n         \\n        return sum_util(root,0);        \\n    }\\n    int sum_util(TreeNode* root,int sum)\\n    {\\n       if(root==nullptr)\\n           return 0;\\n        \\n      sum=2*sum+root->val;\\n      if(root->left==nullptr&&root->right==nullptr)\\n          return sum;\\n      return sum_util(root->left,sum)+sum_util(root->right,sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2183880,
                "title": "c-easiest-approach-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>v; //to strore all binary strings\\n    int convert(string s) //function to convert binary string to integer\\n    {\\n        int sum=0;\\n        int n=s.length()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                sum+=pow(2,n-i);\\n        }\\n        return sum;\\n    }\\n    void helper(TreeNode* root,string s)//recursive function to gather all the the binary digits from root to leaf \\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(!root->left and !root->right)\\n        {\\n            v.push_back(s);\\n            s=\"\";\\n        }\\n        \\n        helper(root->left,s);\\n        helper(root->right,s);        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        helper(root,s);\\n        for(auto x:v)   //converting and adding all binary strings\\n            ans+=convert(x);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v; //to strore all binary strings\\n    int convert(string s) //function to convert binary string to integer\\n    {\\n        int sum=0;\\n        int n=s.length()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                sum+=pow(2,n-i);\\n        }\\n        return sum;\\n    }\\n    void helper(TreeNode* root,string s)//recursive function to gather all the the binary digits from root to leaf \\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(!root->left and !root->right)\\n        {\\n            v.push_back(s);\\n            s=\"\";\\n        }\\n        \\n        helper(root->left,s);\\n        helper(root->right,s);        \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        helper(root,s);\\n        for(auto x:v)   //converting and adding all binary strings\\n            ans+=convert(x);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175813,
                "title": "easy-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        findSumRootToLeaf(root, \"\");\\n        for(String binaryVal: list){\\n            sum+=Integer.parseInt(binaryVal,2);\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumRootToLeaf(TreeNode root, String binaryVal){\\n        if(root.left==null && root.right==null){\\n            binaryVal+=root.val;\\n            list.add(binaryVal);\\n            return;\\n        }\\n        if(root.left!=null)\\n            findSumRootToLeaf(root.left, binaryVal+root.val);\\n        if(root.right!=null)\\n            findSumRootToLeaf(root.right, binaryVal+root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> list=new ArrayList<>();\\n    public int sumRootToLeaf(TreeNode root) {\\n        int sum=0;\\n        if(root==null)\\n            return 0;\\n        findSumRootToLeaf(root, \"\");\\n        for(String binaryVal: list){\\n            sum+=Integer.parseInt(binaryVal,2);\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumRootToLeaf(TreeNode root, String binaryVal){\\n        if(root.left==null && root.right==null){\\n            binaryVal+=root.val;\\n            list.add(binaryVal);\\n            return;\\n        }\\n        if(root.left!=null)\\n            findSumRootToLeaf(root.left, binaryVal+root.val);\\n        if(root.right!=null)\\n            findSumRootToLeaf(root.right, binaryVal+root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168021,
                "title": "python-dfs-stack-list",
                "content": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        total=0\\n        Q=[]\\n        stack=[]\\n        def DFS(r):\\n            if r:\\n                stack.append(str(r.val))\\n                if r.left:\\n                    DFS(r.left)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if r.right:\\n                    DFS(r.right)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if not (r.left or r.right):\\n                    Q.append(int(\\'\\'.join(stack),2))\\n                    \\n        DFS(root)\\n        return sum(Q)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\\n        total=0\\n        Q=[]\\n        stack=[]\\n        def DFS(r):\\n            if r:\\n                stack.append(str(r.val))\\n                if r.left:\\n                    DFS(r.left)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if r.right:\\n                    DFS(r.right)\\n                    \\n                    if stack: \\n                        stack.pop()\\n                if not (r.left or r.right):\\n                    Q.append(int(\\'\\'.join(stack),2))\\n                    \\n        DFS(root)\\n        return sum(Q)",
                "codeTag": "Java"
            },
            {
                "id": 2158600,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        PreOrder(root,0,ans);\\n        return ans;\\n    }\\n    private:\\n    void PreOrder(TreeNode* root,int sum,int &ans)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        PreOrder(root->left,2*sum+root->val,ans);\\n        PreOrder(root->right,2*sum+root->val,ans);\\n        if(!root->left && !root->right)\\n        {\\n            ans += 2*sum+root->val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root) {\\n        int ans = 0;\\n        PreOrder(root,0,ans);\\n        return ans;\\n    }\\n    private:\\n    void PreOrder(TreeNode* root,int sum,int &ans)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        PreOrder(root->left,2*sum+root->val,ans);\\n        PreOrder(root->right,2*sum+root->val,ans);\\n        if(!root->left && !root->right)\\n        {\\n            ans += 2*sum+root->val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140175,
                "title": "c-easy-solution",
                "content": "```\\nint sum=0;\\n    void summation(TreeNode*root,int num)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        num=num*2+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            sum+=num;\\n        }\\n        summation(root->left,num);\\n        summation(root->right,num);\\n    \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int num=0;\\n        summation(root,num);\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\nint sum=0;\\n    void summation(TreeNode*root,int num)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        num=num*2+root->val;\\n        if(!root->left && !root->right)\\n        {\\n            sum+=num;\\n        }\\n        summation(root->left,num);\\n        summation(root->right,num);\\n    \\n    }\\n    int sumRootToLeaf(TreeNode* root) {\\n        int num=0;\\n        summation(root,num);\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089995,
                "title": "easy-100-working-c-solution-using-recusrion-with-3-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root,int sum=0) {\\n        //if root is null we return null\\n        if(!root) return 0;\\n        //then here we correspondingly calculate convert the binary to decimal\\n        sum=2*sum+root->val;\\n    //then here we check if we have the leaf nodes its the least significant bit we return the same value  and call the left func and right func\\n        return root->left==root->right?sum : sumRootToLeaf(root->left,sum)+sumRootToLeaf(root->right,sum);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumRootToLeaf(TreeNode* root,int sum=0) {\\n        //if root is null we return null\\n        if(!root) return 0;\\n        //then here we correspondingly calculate convert the binary to decimal\\n        sum=2*sum+root->val;\\n    //then here we check if we have the leaf nodes its the least significant bit we return the same value  and call the left func and right func\\n        return root->left==root->right?sum : sumRootToLeaf(root->left,sum)+sumRootToLeaf(root->right,sum);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565577,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1566694,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1565864,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1574348,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1994738,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1856259,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1728246,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1728244,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            },
            {
                "id": 1718028,
                "content": [
                    {
                        "username": "exitcisco",
                        "content": "The bit shifting logic isn\\'t that obvious. I find this as medium level problem instead of easy. \\n\\nPlease upvote if you feel the same. We can request LC Admins to change this to Medium"
                    },
                    {
                        "username": "jhaharsh03",
                        "content": "true"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "amsukdu",
                        "content": "I was trapped too :) YEAH !!!\\nIs there a way to prevent this? \\nI\\'m pretty sure this MODULO thing is not a good algorithmic problem."
                    },
                    {
                        "username": "chhabraashish123",
                        "content": "[https://youtu.be/A9XzJ9moZxY](http://)\\n\\nFor Detailed Explanation\\nRecursion 100% time\\nEasy Solution \\nSupport the channel if you like the video"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "HINT : use DFS algorithm :)"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Tip:\n1. We can preorder transversal through the tree and collect the values of the nodes [as a string].\n         we start with a empty string at root and keep on adding `curr_node->val` to string as `s=s+to_string(curr_node->val)`\n         we push it into array when we reach leaf nodes.\n2. Then we can just convert this strings into integers and add 'em up.\n\nHope It Helps..!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "aarzoo_1437",
                        "content": "class Solution {\\npublic:\\n    // function to return decimal from binary \\n    int toDecimal(string s){\\n        if(s == \"\"){\\n            return 0;\\n        }\\n\\n        int x = 0;\\n        int res = 0;\\n        for(int i=s.length()-1; i>=0; i--){\\n            res = res + (s[i] - \\'0\\') * pow(2, x);\\n            x++;\\n        }\\n        return res;\\n    }\\n    // defining our ans globally to store every path ans\\n    int ans = 0;\\n    // define your own string that would store the path from root to leaf node..\\n    int sumRootToLeaf(TreeNode* root, string num = \"\") {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        // addign each node value to string \\n        num += to_string(root->val);\\n\\n        if(root->left == NULL && root->right == NULL){\\n            // when reached at leaf node ensure to convert to decimal and store the ans\\n            ans += toDecimal(num);\\n            return ans;\\n        }\\n\\n        // recursively do for left and right nodes\\n        sumRootToLeaf(root->left, num);\\n        sumRootToLeaf(root->right, num);\\n\\n        // return ans\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Bro, use \"Solutions Tab\" to showcase your solution & keep the \"Discussions Tab\" free of solutions..!!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Days to Make m Bouquets",
        "question_content": "<p>You are given an integer array <code>bloomDay</code>, an integer <code>m</code> and an integer <code>k</code>.</p>\n\n<p>You want to make <code>m</code> bouquets. To make a bouquet, you need to use <code>k</code> <strong>adjacent flowers</strong> from the garden.</p>\n\n<p>The garden consists of <code>n</code> flowers, the <code>i<sup>th</sup></code> flower will bloom in the <code>bloomDay[i]</code> and then can be used in <strong>exactly one</strong> bouquet.</p>\n\n<p>Return <em>the minimum number of days you need to wait to be able to make </em><code>m</code><em> bouquets from the garden</em>. If it is impossible to make m bouquets return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> bloomDay = [1,10,3,10,2], m = 3, k = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> bloomDay = [1,10,3,10,2], m = 3, k = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: [x, x, x, x, _, x, x]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: [x, x, x, x, x, x, x]\nIt is obvious that we can make two bouquets in different ways.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>bloomDay.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= bloomDay[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 686316,
                "title": "java-c-python-binary-search",
                "content": "# **Intuition**\\nIf `m * k > n`, it impossible, so return -1.\\nOtherwise, it\\'s possible, we can binary search the result.\\n`left = 1` is the smallest days,\\n`right = 1e9` is surely big enough to get m bouquests.\\nSo we are going to binary search in range `[left, right]`.\\n<br>\\n\\n# **Explanation**\\nGiven `mid` days, we can know which flowers blooms.\\nNow the problem is, given an array of `true` and `false`,\\nfind out how many adjacent `true`  bouquest in total.\\n\\nIf `bouq < m`, `mid` is still small for `m` bouquest.\\nSo we turn `left = mid + 1`\\n\\nIf `bouq >= m`, `mid` is big enough for `m` bouquest.\\nSo we turn `right = mid`\\n<br>\\n\\n# **Complexity**\\nTime `O(Nlog(maxA))`\\nSpace `O(1)`\\n\\nNote that the result must be one `A[i]`,\\nso actually we can sort A in `O(NlogK)`,\\nWhere `K` is the number of different values.\\nand then binary search the index of different values.\\n\\nThough I don\\'t thik worth doing that.\\n<br>\\n\\n**Java:**\\n```java\\n    public int minDays(int[] A, int m, int k) {\\n        int n = A.length, left = 1, right = (int)1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def minDays(self, A, m, k):\\n        if m * k > len(A): return -1\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            flow = bouq = 0\\n            for a in A:\\n                flow = 0 if a > mid else flow + 1\\n                if flow >= k:\\n                    flow = 0\\n                    bouq += 1\\n                    if bouq == m: break\\n            if bouq == m:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 5455. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search/578488)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search/401806)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/351188?page=3)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n\\n# Solution 2:\\nNote that the result must be one `A[i]`,\\nso actually we can sort A in `O(NlogK)`,\\nWhere `K` is the number of different values.\\nand then binary search the index of different values.\\n\\nI notcied many mentioned that.\\nI didn\\'t do that for the 2 main reasons,\\n1. this didn\\'t change the main idea of binary search,\\nand save just O(log1000) in time complexity,\\nin sacrifice much of writing complexity.\\n2. If we already sort `A` out,\\nwe don\\'t even need `O(NlogN)` binary search at all.\\nThe problem can be already solved in `O(N)`\\n\\nThe idea of `O(N)` is that,\\nOne pass the bloom days from in ascending order,\\nmark the bloomed flower,\\ncalculate the the continous flowers connnected,\\nupdate the bouquets and compared with `m`.\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minDays(int[] A, int m, int k) {\\n        int n = A.length, left = 1, right = (int)1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def minDays(self, A, m, k):\\n        if m * k > len(A): return -1\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            flow = bouq = 0\\n            for a in A:\\n                flow = 0 if a > mid else flow + 1\\n                if flow >= k:\\n                    flow = 0\\n                    bouq += 1\\n                    if bouq == m: break\\n            if bouq == m:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 769703,
                "title": "python-clear-explanation-powerful-ultimate-binary-search-template-solved-many-problems",
                "content": "First thing first, here is the code:\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nI have built a powerful generalized binary search template and used it to solve many problems easily. Below is the detailed and clear introduction to this template. I believe it will be worth your time :)\\n\\n****\\n\\n# Intro\\n\\nBinary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). But when it comes to implementation, it\\'s rather difficult to write a bug-free code in just a few minutes. Some of the most common problems include:\\n\\n- When to exit the loop? Should we use `left < right` or `left <= right` as the while loop condition?\\n- How to initialize the boundary variable `left` and `right`?\\n- How to update the boundary? How to choose the appropriate combination from `left = mid `, `left = mid + 1` and  `right = mid`, `right = mid - 1`?\\n\\nA rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like \"Given a sorted array, find a specific value in it\". As a matter of fact, it can be applied to much more complicated situations.\\n\\nAfter a lot of practice in LeetCode, I\\'ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I\\'ll share the template with you guys in this post. I don\\'t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems. Hopefully, after reading this post, people wouldn\\'t be pissed off any more when LeetCoding, \"Holy sh*t! This problem could be solved with binary search! Why didn\\'t I think of that before!\"\\n\\n\\n\\n****\\n\\n\\n\\n# Most Generalized Binary Search\\n\\nSuppose we have a search space. It could be an array, a range, etc. Usually it\\'s sorted in ascend order. For most tasks, we can transform the requirement into the following generalized form:\\n\\n**Minimize k ,    s.t.  condition(k) is True**\\n\\nThe following code is the most generalized binary search template:\\n\\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nWhat\\'s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:\\n\\n- Correctly initialize the boundary variables `left` and `right`. Only one rule: set up the boundary to **include all possible elements**;\\n- Decide return value. Is it `return left` or `return left - 1`? Remember this: **after exiting the while loop, `left` is the minimal k\\u200B satisfying the `condition ` function**;\\n- Design the `condition` function. This is the most difficult and most beautiful part. Needs lots of practice.\\n\\nBelow I\\'ll show you guys how to apply this powerful template to many LeetCode problems.\\n\\n\\n\\n****\\n\\n\\n\\n# Basic Application\\n\\n## [278. First Bad Version [Easy]](https://leetcode.com/problems/first-bad-version/)\\n\\nYou are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API `bool isBadVersion(version)` which will return whether `version` is bad.\\n\\n**Example:**\\n\\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\\n\\nFirst, we initialize `left = 1` and `right = n` to include all possible values. Then we notice that we don\\'t even need to design the `condition` function. It\\'s already given by the `isBadVersion` API. Finding the first bad version is equivalent to finding the minimal k satisfying `isBadVersion(k) is True`. Our template can fit in very nicely:\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n****\\n\\n\\n\\n## [69. Sqrt(x) [Easy]](https://leetcode.com/problems/sqrtx/)\\n\\nImplement `int sqrt(int x)`. Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\\n\\n**Example:**\\n\\n```scala\\nInput: 4\\nOutput: 2\\n```\\n\\n```scala\\nInput: 8\\nOutput: 2\\n```\\n\\nQuite an easy problem. We need to search for maximal k satisfying `k^2 <= x`, so we can easily come up with the solution:\\n\\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\\n\\nThere\\'s one thing I\\'d like to point out. Remember I say that **we usually look for the minimal k value satisfying certain condition**? But in this problem we are searching for maximal k value instead. Feeling confused? Don\\'t be. Actually, the maximal k satisfying `condition(k) is False` is just equal to the minimal k satisfying `condition(k) is True` minus one. This is why I mentioned earlier that we need to decide which value to return, `left` or `left - 1`.\\n\\n\\n\\n****\\n\\n\\n\\n## [35. Search Insert Position [Easy]](https://leetcode.com/problems/search-insert-position/)\\n\\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\\n\\n**Example:**\\n\\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\\n\\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\\n\\nVery classic application of binary search. We are looking for the minimal k value satisfying `nums[k] >= target`, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array `nums` has duplicates. Also notice that the input  `target` might be larger than all elements in `nums` and therefore needs to placed at the end of the array. That\\'s why we should initialize `right = len(nums)` instead of `right = len(nums) - 1`.\\n\\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# Advanced Application\\n\\nThe above problems are quite easy to solve, because they already give us the array to be searched. We\\'d know that we should use binary search to solve them at first glance.  However, more often are the situations where the search space and search target are not so readily available. Sometimes we won\\'t even realize that the problem should be solved with binary search -- we might just turn to dynamic programming or DFS and get stuck for a very long time.\\n\\nAs for the question \"When can we use binary search?\", my answer is that, **If we can discover some kind of monotonicity, for example, if `condition(k) is True` then `condition(k + 1) is True`, then we can consider binary search**.\\n\\n## [1011. Capacity To Ship Packages Within D Days [Medium]](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\ndays. The `i`-th package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. \\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.\\n\\n**Example :**\\n\\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\\n\\nBinary search probably would not come to our mind when we first meet this problem. We might automatically treat `weights` as search space and then realize we\\'ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within `D` days with capacity `m`, then we can definitely ship them all with any capacity larger than `m`. Now we can design a `condition` function, let\\'s call it `feasible`, given an input `capacity`, it returns whether it\\'s possible to ship all packages within `D` days. This can run in a greedy way: if there\\'s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds `D`, we return `False`, otherwise we return `True`.\\n\\nNext, we need to initialize our boundary correctly. Obviously `capacity` should be at least `max(weights)`, otherwise the conveyor belt couldn\\'t ship the heaviest package. On the other hand, `capacity` need not be more than`sum(weights)`, because then we can ship all packages in just one day.\\n\\nNow we\\'ve got all we need to apply our binary search template:\\n\\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [410. Split Array Largest Sum [Hard]](https://leetcode.com/problems/split-array-largest-sum/)\\n\\nGiven an array which consists of non-negative integers and an integer *m*, you can split the array into *m* non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these *m* subarrays.\\n\\n**Example:**\\n\\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\\n\\nIf you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a `feasible` function: given an input `threshold`, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to `threshold`. In this way, we discover the monotonicity of the problem: if `feasible(m)` is `True`, then all inputs larger than `m` can satisfy `feasible` function. You can see that the solution code is exactly the same as LC 1011.\\n\\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nBut we probably would have doubts: It\\'s true that `left` returned by our solution is the minimal value satisfying `feasible`, but how can we know that we can split the original array to **actually get this subarray-sum**? For example, let\\'s say `nums = [7,2,5,10,8]` and `m = 2`. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: `25:[[7], [2,5,10,8]]`, `23:[[7,2], [5,10,8]]`, `18:[[7,2,5], [10,8]]`, `24:[[7,2,5,10], [8]]`. Only 4 values. But our search space `[max(nums), sum(nums)] = [10, 32]` has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.\\n\\nLet\\'s say `k` is the minimal value satisfying `feasible` function. We can prove the correctness of our solution with proof by contradiction. Assume that no subarray\\'s sum is equal to `k`, that is, every subarray sum is less than `k`. The variable `total` inside `feasible` function keeps track of the total weights of current load. If our assumption is correct, then `total` would always be less than `k`. As a result, `feasible(k - 1)` must be `True`, because `total` would at most be equal to `k - 1` and would never trigger the if-clause `if total > threshold`, therefore `feasible(k - 1)` must have the same output as `feasible(k)`, which is `True`. But we already know that `k`  is the minimal value satisfying `feasible` function, so `feasible(k - 1)` has to be `False`, which is a contradiction. So our assumption is incorrect. Now we\\'ve proved that our algorithm is correct.\\n\\n\\n\\n****\\n\\n\\n\\n## [875. Koko Eating Bananas [Medium]](https://leetcode.com/problems/koko-eating-bananas/)\\n\\nKoko loves to eat bananas. There are `N` piles of bananas, the `i`-th pile has `piles[i]` bananas. The guards have gone and will come back in `H` hours. Koko can decide her bananas-per-hour eating speed of `K`. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than `K` bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour. \\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. **Return the minimum integer `K` such that she can eat all the bananas within `H` hours**.\\n\\n**Example :**\\n\\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\\n\\nVery similar to LC 1011 and LC 410 mentioned above. Let\\'s design a `feasible` function, given an input `speed`, determine whether Koko can finish all bananas within `H` hours with hourly eating speed `speed`. Obviously, the lower bound of the search space is 1, and upper bound is `max(piles)`, because Koko can only choose one pile of bananas to eat every hour.\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1482. Minimum Number of Days to Make m Bouquets [Medium]](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n\\nGiven an integer array `bloomDay`, an integer `m` and an integer `k`. We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return *the minimum number of days* you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.\\n\\n**Examples:**\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\\n\\nNow that we\\'ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make `m` bouquets after waiting for `d` days, then we can definitely finish that as well if we wait more than `d` days.\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [668. Kth Smallest Number in Multiplication Table [Hard]](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n\\nNearly every one have used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). But could you find out the `k-th` smallest number quickly from the multiplication table? Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.\\n\\n**Example :**\\n\\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\\n\\nFor Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can  maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn\\'t work out in this problem. We don\\'t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these `m * n` values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing `condition` function is the most difficult part? In order to find the k-th smallest value in the table, we can design an `enough` function, given an input `num`, determine whether there\\'re at least k values less than or equal to `num`. **The minimal `num` satisfying `enough` function is the answer we\\'re looking for**. Recall that the key to binary search is discovering monotonicity. In this problem, if `num` satisfies `enough`, then of course any value larger than `num` can satisfy. This monotonicity is the fundament of our binary search algorithm.\\n\\nLet\\'s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is `m * n`, then we have search space `[1, m * n]`. The overwhelming advantage of binary search solution to heap solution is that it doesn\\'t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply `enough` function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.\\n\\nNext let\\'s consider how to implement `enough` function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row `[3,6,9,12,15...]` are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input `num`. Following is the complete solution.\\n\\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\\n\\nIn LC 410 above, we have doubt \"Is the result from binary search actually a subarray sum?\". Here we have a similar doubt: \"Is the result from binary search actually in the Multiplication Table?\". The answer is yes, and we also can apply proof by contradiction. Denote `num` as the minimal input that satisfies `enough` function. Let\\'s assume that `num` is not in the table, which means that `num` is not divisible by any `val` in `[1, m]`, that is, `num % val > 0`. Therefore, changing the input from `num` to `num - 1` doesn\\'t have any effect on the expression `add = min(num // val, n)`. So `enough(num)` would also return `True`,  just like `enough(num)`. But we already know `num` is the minimal input satisfying `enough` function, so `enough(num - 1)` has to be `False`. Contradiction! The opposite of our original assumption is true: `num` is actually in the table.\\n\\n\\n\\n****\\n\\n\\n\\n## [719. Find K-th Smallest Pair Distance [Hard]](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n\\nGiven an integer array, return the k-th smallest **distance** among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\\n\\n**Example :**\\n\\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\\n\\nVery similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an `enough` function, given an input `distance`, determine whether there\\'re at least k pairs whose distances are less than or equal to `distance`. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to `distance`, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:\\n\\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\\n\\nObviously, our search space should be `[0, max(nums) - min(nums)]`. Now we are ready to copy-paste our template:\\n\\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1201. Ugly Number III [Medium]](https://leetcode.com/problems/ugly-number-iii/)\\n\\nWrite a program to find the `n`-th ugly number. Ugly numbers are **positive integers** which are divisible by `a` **or** `b` **or** `c`.\\n\\n**Example :**\\n\\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\\n\\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\\n\\nNothing special. Still finding the Kth-Smallest. We need to design an `enough` function, given an input `num`, determine whether there are at least n ugly numbers less than or equal to `num`. Since `a` might be a multiple of `b` or `c`, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.\\n\\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1283. Find the Smallest Divisor Given a Threshold [Medium]](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n\\nGiven an array of integers `nums` and an integer `threshold`, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the **smallest** divisor such that the result mentioned above is less than or equal to `threshold`.\\n\\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.\\n\\n**Example :**\\n\\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\\n\\nAfter so many problems introduced above, this one should be a piece of cake. We don\\'t even need to bother to design a `condition` function, because the problem has already told us explicitly what condition we need to satisfy.\\n\\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# End\\n\\nWow, thank you so much for making it to the end, really appreciate that. As you can see from the python codes above, they all look very similar to each other. That\\'s because I copy-pasted my template all the time. No exception. This is the strong proof of my template\\'s powerfulness. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful `condition` function.\\n\\nHope this helps.\\n\\n**Reference**\\n\\n- [[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search](https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search)\\n- [Approach the problem using the \"trial and error\" algorithm](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-\"trial-and-error\"-algorithm)\\n- [Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)\\n- [ugly-number-iii Binary Search with picture & Binary Search Template - LeetCode](https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: 4\\nOutput: 2\\n```\n```scala\\nInput: 8\\nOutput: 2\\n```\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686237,
                "title": "c-binary-search",
                "content": "**Observation**\\n\\nCan we get the number of bouquets that can form at day `d` ?\\nYes we can, just run a simple count to get the number adjacent bloomed flowers that are greater than or equal to `k` by checking if the day they bloom is less than or equal to `d`(be careful of continuous flowers that can make 2 bouquets eg 2*k bloomed flowers).\\n\\nOnce we have the previous logic, we can simply run binary search on the range `min` and `max` days from the input and try to minimize the day where we can get atleast `m` bouquets.\\nIn the end we only need to check if the minimized `day` has atleast `m` bouquets. This is our answer.\\n\\n**Solution**\\n```c++\\nclass Solution {\\npublic:\\n    int getBouq(vector<int>& bloomDay,int day,int k)\\t//Get the number of bouquets of size k at a certain day.\\n    {\\n        int result=0,count=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i]<=day)\\n                count++;\\n            else\\n                count=0;\\n            if(count==k)    //Reset the window size to 0 to consider the case with 2*k or more continous bloomed flowers.\\n                result++,count=0;\\n        }\\n        return result;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n        auto p=minmax_element(bloomDay.begin(),bloomDay.end());\\n        int j=*p.second,i=*p.first;\\n        int mid;\\n        while(i<j)\\t\\t\\t\\t//Binary search on the range to get the minimum day where we may get `m` bouquets.\\n        {\\n            mid=(i+j)>>1;\\n            if(getBouq(bloomDay,mid,k)<m)\\n                i=mid+1;\\n            else\\n                j=mid;\\n        }\\n        return getBouq(bloomDay,i,k)>=m?i:-1;\\t\\t//Final check if the result day can have atleast `m` bouquets.\\n    }\\n};\\n```\\n**Complexity**\\nTime: `O(nlog(max(bloomDay)-min(bloomDay))` where `max(bloomDay)` is the maximum value and `min(bloomDay)` is the minimum value of the `bloomDay` input.\\nSpace: `O(1)`.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int getBouq(vector<int>& bloomDay,int day,int k)\\t//Get the number of bouquets of size k at a certain day.\\n    {\\n        int result=0,count=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i]<=day)\\n                count++;\\n            else\\n                count=0;\\n            if(count==k)    //Reset the window size to 0 to consider the case with 2*k or more continous bloomed flowers.\\n                result++,count=0;\\n        }\\n        return result;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n        auto p=minmax_element(bloomDay.begin(),bloomDay.end());\\n        int j=*p.second,i=*p.first;\\n        int mid;\\n        while(i<j)\\t\\t\\t\\t//Binary search on the range to get the minimum day where we may get `m` bouquets.\\n        {\\n            mid=(i+j)>>1;\\n            if(getBouq(bloomDay,mid,k)<m)\\n                i=mid+1;\\n            else\\n                j=mid;\\n        }\\n        return getBouq(bloomDay,i,k)>=m?i:-1;\\t\\t//Final check if the result day can have atleast `m` bouquets.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686529,
                "title": "java-binary-search-with-detailed-explanation-runtime-o-nlog-maxdays-100",
                "content": "This approach is to do a Hit or miss, starting from min days to max days.\\nTime Complexity: O(nLog(maxdays))\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\n\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if (bloomDay.length < m * k) return -1;\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i : bloomDay) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n//        Take the boundary starting from 1 to the max day in the bloomDay.\\n        while (min < max) {\\n            int mid = min + (max - min) / 2;\\n            int possibleBookies = getPossibleBookies(bloomDay, mid, k);\\n//            The\\n            if (possibleBookies < m) {\\n                min = mid + 1;\\n            } else {\\n                max = mid;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    private int getPossibleBookies(int[] bloomDay, int day, int k) {\\n//        This method is to find the number of bouquets that can be formed on a given day.\\n        int bouquets = 0, flowersCollected = 0;\\n        for (int value : bloomDay) {\\n            if (value <= day) {\\n//                If the current flower can be taken with in days then increase the flower flowersCollected.\\n                flowersCollected++;\\n            } else {\\n//                If there is a flower in between that takes more number of days then the given day, then resent the counter.\\n                flowersCollected = 0;\\n            }\\n//            If the flowersCollected is same as the required flower per bookie, then increase the bouquets count;\\n            if (flowersCollected == k) {\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n        return bouquets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if (bloomDay.length < m * k) return -1;\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i : bloomDay) {\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n//        Take the boundary starting from 1 to the max day in the bloomDay.\\n        while (min < max) {\\n            int mid = min + (max - min) / 2;\\n            int possibleBookies = getPossibleBookies(bloomDay, mid, k);\\n//            The\\n            if (possibleBookies < m) {\\n                min = mid + 1;\\n            } else {\\n                max = mid;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    private int getPossibleBookies(int[] bloomDay, int day, int k) {\\n//        This method is to find the number of bouquets that can be formed on a given day.\\n        int bouquets = 0, flowersCollected = 0;\\n        for (int value : bloomDay) {\\n            if (value <= day) {\\n//                If the current flower can be taken with in days then increase the flower flowersCollected.\\n                flowersCollected++;\\n            } else {\\n//                If there is a flower in between that takes more number of days then the given day, then resent the counter.\\n                flowersCollected = 0;\\n            }\\n//            If the flowersCollected is same as the required flower per bookie, then increase the bouquets count;\\n            if (flowersCollected == k) {\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n        return bouquets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686240,
                "title": "binary-search",
                "content": "My first though was to use a sliding window. In a linear time, we can find the maximum bloom days for consecutive  groups of `k` flowers. Then, we can run a top-down DP to search for `m` non-overlapping groups. With memoisation, this approach will take O(n * m). \\n\\nAt this point in the contest, I was thinking that it\\'s a bit of too complex for a medium problem. That was my first hint. \\n\\nThen, I realized that, with `n` and `m` up to 10^5 each and O(n * m), we are looking to 10^10 memory and time operations (well `m` is 10^6 in the description, but it does not make sense). This is a recipe for TLE/MLE. Therefore, I turned back and started considering other patterns that would give us a O(n log n) solution (O(n) seemed unlikely).\\n\\nA second hint was that we need to process the input in the original order (flowers has to be adjacent), and return a minimum value to satisfy some criteria. This sounded very similar these problems that can be solved using binary search:\\n- [Koko eating bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n- [Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\nFinally, I confirmed that function `bouquets = f(days)` is non-decreasing, so we can use a binary search to find the minimum `days`. \\n\\n**C++**\\n```cpp\\nbool canHarvest(vector<int>& bDay, int harvestDay, int m, int k) {\\n    int adjacent = 0;\\n    for (auto bloomDay : bDay) {\\n        adjacent = bloomDay <= harvestDay ? adjacent + 1 : 0;\\n        if (adjacent == k) {\\n            adjacent = 0;\\n            --m;\\n        }\\n    }\\n    return m <= 0;\\n}\\nint minDays(vector<int>& bDay, int m, int k) {\\n    if ((long long)m * k > bDay.size())\\n        return -1;\\n    auto lo = 1, hi = 1000000000;\\n    while (lo < hi) {\\n        auto mid = (hi + lo) / 2;\\n        if (canHarvest(bDay, mid, m, k))\\n            hi = mid;\\n        else\\n            lo = mid + 1;\\n    }\\n    return lo;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool canHarvest(vector<int>& bDay, int harvestDay, int m, int k) {\\n    int adjacent = 0;\\n    for (auto bloomDay : bDay) {\\n        adjacent = bloomDay <= harvestDay ? adjacent + 1 : 0;\\n        if (adjacent == k) {\\n            adjacent = 0;\\n            --m;\\n        }\\n    }\\n    return m <= 0;\\n}\\nint minDays(vector<int>& bDay, int m, int k) {\\n    if ((long long)m * k > bDay.size())\\n        return -1;\\n    auto lo = 1, hi = 1000000000;\\n    while (lo < hi) {\\n        auto mid = (hi + lo) / 2;\\n        if (canHarvest(bDay, mid, m, k))\\n            hi = mid;\\n        else\\n            lo = mid + 1;\\n    }\\n    return lo;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686337,
                "title": "c-binary-search-more-similar-problems-listed",
                "content": "**Solution:**\\n\\n```\\nclass Solution {\\n    bool isValid(vector<int>& bloomDay, int m, int k, int mid) {\\n        \\n        int count = 0, size = 0;\\n        for (int i = 0; i < bloomDay.size(); i++) {\\n            size = (bloomDay[i] <= mid) ? size+1 : 0;\\n            if (size == k) size = 0, count++;\\n            if (count == m)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n\\t\\tif(bloomDay.size() == 0 || m == 0 || k == 0) return 0;\\n\\t\\tif (m * k > bloomDay.size()) return -1;\\n\\t\\t\\n\\t\\tint l = INT_MAX, r = INT_MIN;\\n\\t\\tfor (int i = 0; i < bloomDay.size(); i++) {\\n\\t\\t\\tl = min(l, bloomDay[i]);\\n\\t\\t\\tr = max(r, bloomDay[i]);\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if (isValid(bloomDay, m, k, mid))\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```\\n\\n**Similar Binary Search problems:**\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/koko-eating-bananas/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/sum-of-mutated-array-closest-to-target/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isValid(vector<int>& bloomDay, int m, int k, int mid) {\\n        \\n        int count = 0, size = 0;\\n        for (int i = 0; i < bloomDay.size(); i++) {\\n            size = (bloomDay[i] <= mid) ? size+1 : 0;\\n            if (size == k) size = 0, count++;\\n            if (count == m)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n\\t\\tif(bloomDay.size() == 0 || m == 0 || k == 0) return 0;\\n\\t\\tif (m * k > bloomDay.size()) return -1;\\n\\t\\t\\n\\t\\tint l = INT_MAX, r = INT_MIN;\\n\\t\\tfor (int i = 0; i < bloomDay.size(); i++) {\\n\\t\\t\\tl = min(l, bloomDay[i]);\\n\\t\\t\\tr = max(r, bloomDay[i]);\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if (isValid(bloomDay, m, k, mid))\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731921,
                "title": "simple-c-explanation",
                "content": "### INTUITION\\nHow we can get the idea that we can use binary search??? \\nWe see thet the the answer will lie between the minimum and the maximum of the bloomsDay array i.e the day on which first flower blooms and the day when all the flowers will bloom. For eg. if min = 10 and max = 25 then our answer will be sime number between 10 and 25 [ 10 , 11 ,12 ,13, ... , 24 , 25 ].\\nWe can either tranverse from 10 to 25 to find the minimum possible value when our condition is met which will take lenear time O(n).  But and efficient way would be to use binary search (since the answer range is already sorted).  This would reduce the time complexity to O ( log ( max - min) );\\n\\n## The check function.\\nSuppose the present day is X . So we need to firstly calculate how many bouquets we can make till present day. If the number of bouquets that we can make is greater than the required number of bouquets than we return true or else we return false. Have a look at the code to see how we are calculating this.\\n ```\\n class Solution {\\npublic:\\n      bool check(int present_day, vector<int> bloomDay, int required_bouquet, int required_flower)\\n{\\n\\tint flower_count=0;\\n\\tint bouquet_count =0;\\n\\tfor(int i=0;i<bloomDay.size(); i++)\\n\\t{\\n\\t\\t// when this flower is already blossomed so we can include this   flower.\\n\\t\\tif(bloomDay[i] <= present_day)\\n\\t\\t{\\n\\t\\t\\tflower_count++;\\n\\t\\t\\tif(flower_count == required_flower)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbouquet_count++;\\n\\t\\t\\t\\tflower_count =0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// when the flower has not blosssomed we can not include\\n\\t\\t// so it breaks the chain.\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tflower_count = 0;\\n\\n\\t\\t}\\n\\t}\\n\\n\\tif(bouquet_count >= required_bouquet) return true;\\n\\telse return false;\\n\\n}\\n\\nint minDays(vector<int>& bloomDay, int m, int k) {\\n    \\n    if(m*k > bloomDay.size()) return -1;\\n    \\n    \\n        int lower = *min_element(bloomDay.begin(), bloomDay.end());\\n        int upper = *max_element(bloomDay.begin(), bloomDay.end());\\n\\n        while(lower < upper)\\n        {\\n        \\tint mid = lower + (upper - lower)/2;\\n\\n        \\tif(check(mid , bloomDay , m , k)) upper = mid;\\n        \\telse lower = mid +1;\\n\\n        }\\n\\n        return lower;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n      bool check(int present_day, vector<int> bloomDay, int required_bouquet, int required_flower)\\n{\\n\\tint flower_count=0;\\n\\tint bouquet_count =0;\\n\\tfor(int i=0;i<bloomDay.size(); i++)\\n\\t{\\n\\t\\t// when this flower is already blossomed so we can include this   flower.\\n\\t\\tif(bloomDay[i] <= present_day)\\n\\t\\t{\\n\\t\\t\\tflower_count++;\\n\\t\\t\\tif(flower_count == required_flower)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbouquet_count++;\\n\\t\\t\\t\\tflower_count =0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// when the flower has not blosssomed we can not include\\n\\t\\t// so it breaks the chain.\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tflower_count = 0;\\n\\n\\t\\t}\\n\\t}\\n\\n\\tif(bouquet_count >= required_bouquet) return true;\\n\\telse return false;\\n\\n}\\n\\nint minDays(vector<int>& bloomDay, int m, int k) {\\n    \\n    if(m*k > bloomDay.size()) return -1;\\n    \\n    \\n        int lower = *min_element(bloomDay.begin(), bloomDay.end());\\n        int upper = *max_element(bloomDay.begin(), bloomDay.end());\\n\\n        while(lower < upper)\\n        {\\n        \\tint mid = lower + (upper - lower)/2;\\n\\n        \\tif(check(mid , bloomDay , m , k)) upper = mid;\\n        \\telse lower = mid +1;\\n\\n        }\\n\\n        return lower;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327257,
                "title": "template-one-code-works-for-all-problems",
                "content": "Check the code. Can easily identify the pattern. All questions are related to binary search\\n1) https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/\\n\\n````\\npublic class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low  = Arrays.stream(bloomDay).min().getAsInt();\\n        int high =  Arrays.stream(bloomDay).max().getAsInt();\\n\\n        int  ans = -1;\\n\\n        while (low<=high){\\n            int mid = low+(high-low)/2;\\n\\n            if(isPossible(bloomDay,mid,k,m)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else {\\n\\n                low=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] bloomDay, int mid, int k,int booket) {\\n        int bouquets = 0, flowersCollected = 0;\\n        for (int value : bloomDay) {\\n            if (value <= mid) {\\n//                If the current flower can be taken with in days then increase the flower flowersCollected.\\n                flowersCollected++;\\n            } else {\\n//                If there is a flower in between that takes more number of days then the given day, then resent the counter.\\n                flowersCollected = 0;\\n            }\\n//            If the flowersCollected is same as the required flower per bookie, then increase the bouquets count;\\n            if (flowersCollected == k) {\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n\\n        return bouquets>=booket;\\n\\n    }\\n}\\n\\n````\\n\\n2) https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\n````\\n public int shipWithinDays(int[] weights, int days) {\\n\\n        int capacity = 0;\\n        int start = Arrays.stream(weights).max().getAsInt();\\n        int end = Arrays.stream(weights).sum();\\n\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if( isPossible(weights, mid,days)){\\n                capacity = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return capacity;\\n\\n    }\\n\\n    private boolean isPossible(int[] weights, int mid, int days) {\\n        int currentDay = 1;\\n        long currentWeight=0;\\n        for(int weight:weights){\\n\\n            currentWeight+=weight;\\n            if(currentWeight>mid){\\n                currentDay++;\\n                currentWeight=weight;\\n            }\\n\\n        }\\n        return currentDay<=days;\\n\\n    }\\n````\\n\\n3)https://leetcode.com/problems/divide-chocolate/\\n````\\n public int maximizeSweetness(int[] sweetness, int k) {\\n        int min = Arrays.stream(sweetness).min().getAsInt();\\n        int max = Arrays.stream(sweetness).sum();\\n        int ans=min;\\n        while(min<=max){\\n            int mid = min+(max-min)/2;\\n            if(isPossible(sweetness,mid,k)){\\n                ans=mid;\\n                max=mid-1;\\n            }\\n            else {min=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] sweetness, int mid, int k) {\\n        int currSweet=0;\\n        int division=0;\\n        for(int swt: sweetness){\\n            currSweet+=swt;\\n            // because can not have < mid and cut has to be done\\n            if(currSweet>mid){\\n                currSweet=0;\\n                division++;\\n            }\\n        }\\n\\n        return division<=k;\\n    }\\n````\\n\\n4) https://leetcode.com/problems/split-array-largest-sum/\\n\\n````\\npublic class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int low = Arrays.stream(nums).max().getAsInt();;\\n        int high = Arrays.stream(nums).sum();;\\n        int ans = 0;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(nums,mid,m)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] nums, int mid, int m) {\\n        int split = 1;\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            if(sum > mid){\\n                split ++;\\n                sum = nums[i];\\n            }\\n        }\\n        return split<=m;\\n    }\\n\\n}\\n````",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "````\\npublic class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low  = Arrays.stream(bloomDay).min().getAsInt();\\n        int high =  Arrays.stream(bloomDay).max().getAsInt();\\n\\n        int  ans = -1;\\n\\n        while (low<=high){\\n            int mid = low+(high-low)/2;\\n\\n            if(isPossible(bloomDay,mid,k,m)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else {\\n\\n                low=mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] bloomDay, int mid, int k,int booket) {\\n        int bouquets = 0, flowersCollected = 0;\\n        for (int value : bloomDay) {\\n            if (value <= mid) {\\n//                If the current flower can be taken with in days then increase the flower flowersCollected.\\n                flowersCollected++;\\n            } else {\\n//                If there is a flower in between that takes more number of days then the given day, then resent the counter.\\n                flowersCollected = 0;\\n            }\\n//            If the flowersCollected is same as the required flower per bookie, then increase the bouquets count;\\n            if (flowersCollected == k) {\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n\\n        return bouquets>=booket;\\n\\n    }\\n}\\n\\n```\n````\\n public int shipWithinDays(int[] weights, int days) {\\n\\n        int capacity = 0;\\n        int start = Arrays.stream(weights).max().getAsInt();\\n        int end = Arrays.stream(weights).sum();\\n\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if( isPossible(weights, mid,days)){\\n                capacity = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return capacity;\\n\\n    }\\n\\n    private boolean isPossible(int[] weights, int mid, int days) {\\n        int currentDay = 1;\\n        long currentWeight=0;\\n        for(int weight:weights){\\n\\n            currentWeight+=weight;\\n            if(currentWeight>mid){\\n                currentDay++;\\n                currentWeight=weight;\\n            }\\n\\n        }\\n        return currentDay<=days;\\n\\n    }\\n```\n````\\n public int maximizeSweetness(int[] sweetness, int k) {\\n        int min = Arrays.stream(sweetness).min().getAsInt();\\n        int max = Arrays.stream(sweetness).sum();\\n        int ans=min;\\n        while(min<=max){\\n            int mid = min+(max-min)/2;\\n            if(isPossible(sweetness,mid,k)){\\n                ans=mid;\\n                max=mid-1;\\n            }\\n            else {min=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] sweetness, int mid, int k) {\\n        int currSweet=0;\\n        int division=0;\\n        for(int swt: sweetness){\\n            currSweet+=swt;\\n            // because can not have < mid and cut has to be done\\n            if(currSweet>mid){\\n                currSweet=0;\\n                division++;\\n            }\\n        }\\n\\n        return division<=k;\\n    }\\n```\n````\\npublic class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int low = Arrays.stream(nums).max().getAsInt();;\\n        int high = Arrays.stream(nums).sum();;\\n        int ans = 0;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(nums,mid,m)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPossible(int[] nums, int mid, int m) {\\n        int split = 1;\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            if(sum > mid){\\n                split ++;\\n                sum = nums[i];\\n            }\\n        }\\n        return split<=m;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317010,
                "title": "java-binary-search-13ms-beats-99-45-t-c-o-n-log-max-bloomday-s-c-o-1",
                "content": "\\n\\t// Binary Search\\n\\t// O(bloomDay.length*log(max(bloomDay))) O(1)\\n\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n\\n\\t\\tint max = Integer.MIN_VALUE, len = bloomDay.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (bloomDay[i] > max)\\n\\t\\t\\t\\tmax = bloomDay[i];\\n\\t\\t}\\n\\n\\t\\tint lo = 1, hi = max, ans = -1;\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\tif (isPossible(bloomDay, m, k, mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(bloomDay.length) O(1)\\n\\tpublic boolean isPossible(int[] bloomDay, int m, int k, int days) {\\n\\n\\t\\tint len = bloomDay.length, count = 0, adjacent = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (bloomDay[i] <= days) {\\n\\t\\t\\t\\tadjacent++;\\n\\t\\t\\t\\tif (adjacent == k) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif (count == m)\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\tadjacent = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else\\n\\t\\t\\t\\tadjacent = 0;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Binary Search\\n\\t// O(bloomDay.length*log(max(bloomDay))) O(1)\\n\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n\\n\\t\\tint max = Integer.MIN_VALUE, len = bloomDay.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (bloomDay[i] > max)\\n\\t\\t\\t\\tmax = bloomDay[i];\\n\\t\\t}\\n\\n\\t\\tint lo = 1, hi = max, ans = -1;\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\tif (isPossible(bloomDay, m, k, mid)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(bloomDay.length) O(1)\\n\\tpublic boolean isPossible(int[] bloomDay, int m, int k, int days) {\\n\\n\\t\\tint len = bloomDay.length, count = 0, adjacent = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (bloomDay[i] <= days) {\\n\\t\\t\\t\\tadjacent++;\\n\\t\\t\\t\\tif (adjacent == k) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif (count == m)\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\tadjacent = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else\\n\\t\\t\\t\\tadjacent = 0;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 686521,
                "title": "python2-unionfind-to-merge-adjacent-flowers",
                "content": "\\n```\\nclass Solution(object):\\n    def minDays(self, bloomDay, m, k):\\n        def find(x):\\n            if group[x] != x:\\n                group[x] = find(group[x])\\n            return group[x]\\n        \\n        def union(x, y):\\n            rx = find(x)\\n            ry = find(y)\\n            \\n            group[rx] = ry\\n            groupSize[ry] += groupSize[rx]\\n            return ry\\n            \\n        cnt = len(bloomDay)\\n        groupSize = [1] * cnt\\n        group = range(cnt)\\n        bloomed = [False] * cnt\\n        \\n        \\n        for day, flower in sorted(map(lambda x: list(reversed(x)) , enumerate(bloomDay))):\\n            bloomed[flower] = True\\n            leftsize = rightsize = 0\\n            if flower > 0 and bloomed[flower - 1]:\\n                leftsize = groupSize[find(flower - 1)]\\n                union(flower, flower - 1)\\n            if flower < cnt - 1 and bloomed[flower + 1]:\\n                rightsize = groupSize[find(flower + 1)]\\n                union(flower, flower + 1)\\n            m -= (leftsize + 1 + rightsize) / k - leftsize / k - rightsize / k\\n            if m <= 0:\\n                return day\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDays(self, bloomDay, m, k):\\n        def find(x):\\n            if group[x] != x:\\n                group[x] = find(group[x])\\n            return group[x]\\n        \\n        def union(x, y):\\n            rx = find(x)\\n            ry = find(y)\\n            \\n            group[rx] = ry\\n            groupSize[ry] += groupSize[rx]\\n            return ry\\n            \\n        cnt = len(bloomDay)\\n        groupSize = [1] * cnt\\n        group = range(cnt)\\n        bloomed = [False] * cnt\\n        \\n        \\n        for day, flower in sorted(map(lambda x: list(reversed(x)) , enumerate(bloomDay))):\\n            bloomed[flower] = True\\n            leftsize = rightsize = 0\\n            if flower > 0 and bloomed[flower - 1]:\\n                leftsize = groupSize[find(flower - 1)]\\n                union(flower, flower - 1)\\n            if flower < cnt - 1 and bloomed[flower + 1]:\\n                rightsize = groupSize[find(flower + 1)]\\n                union(flower, flower + 1)\\n            m -= (leftsize + 1 + rightsize) / k - leftsize / k - rightsize / k\\n            if m <= 0:\\n                return day\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691031,
                "title": "python3-binary-search-elif5-explained-like-i-m-5-years-old",
                "content": "```\\nclass Solution:\\n    \\n    def minDays(self, listOfFlowerBloomDays: List[int], targetNumberOfBouquets: int, flowersPerBouquet: int) -> int:\\n        \\n        def numberOfBouquetsWeCanMakeOnThisDay(dayThatWeAreChecking):\\n            \\n            currentListOfAdjacentBloomedFlowers = []\\n            numberOfBouquetsWeCanMakeOnThisDay = 0\\n            \\n            for dayThatFlowerBlooms in listOfFlowerBloomDays:\\n                \\n                # check if the flower has bloomed on this day \\n                if dayThatFlowerBlooms <= dayThatWeAreChecking:\\n                    \\n                    # add to the list an adjacent bloomed flowers, I use \\'x\\' because the description uses an \\'x\\'\\n                    currentListOfAdjacentBloomedFlowers.append(\\'x\\')\\n                    \\n                else:\\n                    # we\\'ve hit a day where we don\\'t have a bloomed flower, so the list of adjacent bloomed flowers has to be reset\\n                    # BUT FIRST figure out how many bouquets we can make with this list of adjacent bloomed flowers\\n                    numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\\n                    \\n                    # RESET list of adjacent bloomed flowers cause we\\'re on a day where the a flower has not bloomed yet\\n                    currentListOfAdjacentBloomedFlowers = []\\n            \\n            # we\\'ve gone through the entire listOfFlowerBloomDays list and need to check if the \"residual\" current list \\n            # of adjacent bloomed flowers can make a bouquet ... so handle it here\\n            numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\\n                    \\n            return numberOfBouquetsWeCanMakeOnThisDay\\n        \\n        \\n        # if the TOTAL amount of flowers we need doesn\\'t match the number of possible flowers we can grow,\\n        # then the given inputs are impossible for making enough bouquets (we don\\'t have enough flowers)\\n        totalNumberOfFlowersNeeded = targetNumberOfBouquets*flowersPerBouquet\\n        numberOfFlowersWeCanGrow = len(listOfFlowerBloomDays)\\n        if numberOfFlowersWeCanGrow < totalNumberOfFlowersNeeded: \\n            return -1\\n        \\n        # no need to go past the day of the flower with the longest bloom date\\n        leftDay = 0\\n        rightDay = max(listOfFlowerBloomDays)\\n        \\n        while leftDay < rightDay:\\n            \\n            # currentDay is functioning as the \"mid\" of a binary search\\n            currentDay = leftDay + (rightDay-leftDay)//2\\n            \\n            # as in most binary searches, we check if the mid (which I\\'m calling \\'currentDay\\') satisfies the constraint\\n            # that is, if we can make the target amount of bouquets on this day\\n            if numberOfBouquetsWeCanMakeOnThisDay(currentDay) < targetNumberOfBouquets:\\n                \\n                # womp womp, we can\\'t make enough bouquets on this day, so set up for next iteration\\n                # the \"correct day\" is on the right side, so we get rid of all the \"incorrect days\" on the left side\\n                # by updating the left to the currentDay+1\\n                leftDay = currentDay+1\\n            else:\\n                \\n                # yay, we can make enough bouquets on this day, but we don\\'t know if this is the \"minimum day\"\\n                # we discard the right side to keep searching\\n                rightDay = currentDay\\n        \\n        # leftDay >= rightDay, so we\\'ve found the \"minimum day\"\\n        return leftDay\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def minDays(self, listOfFlowerBloomDays: List[int], targetNumberOfBouquets: int, flowersPerBouquet: int) -> int:\\n        \\n        def numberOfBouquetsWeCanMakeOnThisDay(dayThatWeAreChecking):\\n            \\n            currentListOfAdjacentBloomedFlowers = []\\n            numberOfBouquetsWeCanMakeOnThisDay = 0\\n            \\n            for dayThatFlowerBlooms in listOfFlowerBloomDays:\\n                \\n                # check if the flower has bloomed on this day \\n                if dayThatFlowerBlooms <= dayThatWeAreChecking:\\n                    \\n                    # add to the list an adjacent bloomed flowers, I use \\'x\\' because the description uses an \\'x\\'\\n                    currentListOfAdjacentBloomedFlowers.append(\\'x\\')\\n                    \\n                else:\\n                    # we\\'ve hit a day where we don\\'t have a bloomed flower, so the list of adjacent bloomed flowers has to be reset\\n                    # BUT FIRST figure out how many bouquets we can make with this list of adjacent bloomed flowers\\n                    numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\\n                    \\n                    # RESET list of adjacent bloomed flowers cause we\\'re on a day where the a flower has not bloomed yet\\n                    currentListOfAdjacentBloomedFlowers = []\\n            \\n            # we\\'ve gone through the entire listOfFlowerBloomDays list and need to check if the \"residual\" current list \\n            # of adjacent bloomed flowers can make a bouquet ... so handle it here\\n            numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\\n                    \\n            return numberOfBouquetsWeCanMakeOnThisDay\\n        \\n        \\n        # if the TOTAL amount of flowers we need doesn\\'t match the number of possible flowers we can grow,\\n        # then the given inputs are impossible for making enough bouquets (we don\\'t have enough flowers)\\n        totalNumberOfFlowersNeeded = targetNumberOfBouquets*flowersPerBouquet\\n        numberOfFlowersWeCanGrow = len(listOfFlowerBloomDays)\\n        if numberOfFlowersWeCanGrow < totalNumberOfFlowersNeeded: \\n            return -1\\n        \\n        # no need to go past the day of the flower with the longest bloom date\\n        leftDay = 0\\n        rightDay = max(listOfFlowerBloomDays)\\n        \\n        while leftDay < rightDay:\\n            \\n            # currentDay is functioning as the \"mid\" of a binary search\\n            currentDay = leftDay + (rightDay-leftDay)//2\\n            \\n            # as in most binary searches, we check if the mid (which I\\'m calling \\'currentDay\\') satisfies the constraint\\n            # that is, if we can make the target amount of bouquets on this day\\n            if numberOfBouquetsWeCanMakeOnThisDay(currentDay) < targetNumberOfBouquets:\\n                \\n                # womp womp, we can\\'t make enough bouquets on this day, so set up for next iteration\\n                # the \"correct day\" is on the right side, so we get rid of all the \"incorrect days\" on the left side\\n                # by updating the left to the currentDay+1\\n                leftDay = currentDay+1\\n            else:\\n                \\n                # yay, we can make enough bouquets on this day, but we don\\'t know if this is the \"minimum day\"\\n                # we discard the right side to keep searching\\n                rightDay = currentDay\\n        \\n        # leftDay >= rightDay, so we\\'ve found the \"minimum day\"\\n        return leftDay\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686234,
                "title": "c-nlog-max-bloom-day",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        const int N = bloomDay.size();\\n        if (m*k > N) return -1; //not enough flowers for the given requirement\\n        \\n        int low = 1, high = INT_MIN, ans = -1;\\n        for (const auto &n : bloomDay) high = max(high, n);\\n        \\n        while (low <= high) { //try possible bloom days in range [1, max(bloomDay..)]\\n            int mid = low + (high - low)/2; \\n            int cnt = 0, parts = 0; //cnt = continuous valid flowers for bouquets, parts = no. of such valid partitions \\n            for (int i = 0; i < N; ++i) {\\n                if (bloomDay[i] <= mid) cnt++;\\n                else cnt = 0;\\n                if (cnt == k) {\\n                    parts++;\\n                    cnt = 0;\\n                }\\n            }\\n            if (parts < m) {\\n                low = mid + 1;\\n            } else {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        const int N = bloomDay.size();\\n        if (m*k > N) return -1; //not enough flowers for the given requirement\\n        \\n        int low = 1, high = INT_MIN, ans = -1;\\n        for (const auto &n : bloomDay) high = max(high, n);\\n        \\n        while (low <= high) { //try possible bloom days in range [1, max(bloomDay..)]\\n            int mid = low + (high - low)/2; \\n            int cnt = 0, parts = 0; //cnt = continuous valid flowers for bouquets, parts = no. of such valid partitions \\n            for (int i = 0; i < N; ++i) {\\n                if (bloomDay[i] <= mid) cnt++;\\n                else cnt = 0;\\n                if (cnt == k) {\\n                    parts++;\\n                    cnt = 0;\\n                }\\n            }\\n            if (parts < m) {\\n                low = mid + 1;\\n            } else {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525107,
                "title": "why-we-are-applying-binary-search-here-explanation",
                "content": "On 1st day ,we are checking how many flowers are bloomed and then we will make bouquets of adjacent flowers.Again on 2nd day we are doing same.Again on 3rd day we are doing same.Means we are checking on every next day how many adjacent flowers are bloomed and then we will make bouquets. This will take O(n^2) time .Here our days range is increasing monotonically. We can opotimise it by applying the binary search on the answer itself. We will take range of days from 1 to 1e9 that is given in constraint.Then we will check on day \\'mid\\' how many flowers are bloomed and will make bouquets of adjacent flowers.If we cannot make bouquets equal to m that means we have to increase the day, so we will move to right of range and then again find it.If bouquets are greater than or equal to m then we will try to minimize the days and move toward the left of range.In this way, we can apply binary search .\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& v,int m,int k,int mid){\\n        int adj=0,bough=0;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]>mid){\\n                adj=0;\\n            }\\n            else if(++adj>=k){\\n                bough++;\\n                adj=0;\\n            }\\n        }\\n        if(bough>=m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k>bloomDay.size()) return -1;\\n        int low=1,high=1e9;\\n        int result=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                result=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& v,int m,int k,int mid){\\n        int adj=0,bough=0;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]>mid){\\n                adj=0;\\n            }\\n            else if(++adj>=k){\\n                bough++;\\n                adj=0;\\n            }\\n        }\\n        if(bough>=m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k>bloomDay.size()) return -1;\\n        int low=1,high=1e9;\\n        int result=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                result=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204477,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        int l=1,r=1000000000;\\n        int ans=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            int c=0;\\n            int tt=0;\\n            for(int i=0;i<n;i++){\\n                if(bloomDay[i]<=mid)c++;\\n                else c=0;\\n                if(c==k){\\n                    tt++;\\n                    c=0;\\n                }\\n            }\\n            if(tt>=m){\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/cf05b327-df2f-401d-9ded-b4b1489870b5_1676786992.604219.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        int l=1,r=1000000000;\\n        int ans=-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            int c=0;\\n            int tt=0;\\n            for(int i=0;i<n;i++){\\n                if(bloomDay[i]<=mid)c++;\\n                else c=0;\\n                if(c==k){\\n                    tt++;\\n                    c=0;\\n                }\\n            }\\n            if(tt>=m){\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993479,
                "title": "super-easy-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(vector<int>& bloomDay, int m, int k,int mid){\\n    int c=0;int total=0;\\n    for(int i=0;i<bloomDay.size();i++){\\n        if(bloomDay[i]<=mid){\\n            c++;\\n            if(c==k){\\n                total++;\\n                c=0;\\n            }\\n        }else c=0;\\n    }\\n    if(total>=m){\\n        return true;\\n    }return false;\\n}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int st=0;int end=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(check(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(vector<int>& bloomDay, int m, int k,int mid){\\n    int c=0;int total=0;\\n    for(int i=0;i<bloomDay.size();i++){\\n        if(bloomDay[i]<=mid){\\n            c++;\\n            if(c==k){\\n                total++;\\n                c=0;\\n            }\\n        }else c=0;\\n    }\\n    if(total>=m){\\n        return true;\\n    }return false;\\n}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int st=0;int end=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(check(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003760,
                "title": "python-very-beginner-s-bianary-search-solution",
                "content": "Here simply searching for our answer(min days) to want to make `m` bouquets for that we do **Binary Search**\\n\\n1. our ans must exist between the range 1 to `max(A)`\\n threfore we have` l = 1` and `r = max(A`)  left and right pointers\\n 2. then we calculate `mid = (l+r)//2` and check whethere it is feasible or not for our answer (`isFeasible` function do the job here), \\n\\t\\t if it is then we again search for minimum answer by moving right pointer by `r = mid - 1`\\n\\t\\t else we dont find the feasible answer so move our left pointer by `l = mid + 1`\\n\\t\\t we do it untill` l<=r` (while for reason)\\n3. so after end of the loop we simply  return` l` left pointer\\n\\n \\n```\\nclass Solution:\\n    def minDays(self, A: List[int], m: int, k: int) -> int:\\n        def isFeasible(x):\\n            aj_flw = count_flw =0\\n            \\n            for i in A:\\n                if x>=i:\\n                    aj_flw += 1\\n                else:\\n                    aj_flw = 0\\n                if aj_flw == k:\\n                    count_flw += 1 \\n                    aj_flw = 0\\n            return count_flw >=m\\n                    \\n        if len(A)<m*k: return -1 \\n        l,r = 1,max(A) \\n        \\n        while l<=r:\\n            mid = l+(r-l)//2 \\n            if isFeasible(mid):\\n                r = mid - 1 \\n            else:\\n                l = mid + 1\\n                 \\n        return l\\n                \\n```\\n\\nplz **upvote**  you if find atleast something from it",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, A: List[int], m: int, k: int) -> int:\\n        def isFeasible(x):\\n            aj_flw = count_flw =0\\n            \\n            for i in A:\\n                if x>=i:\\n                    aj_flw += 1\\n                else:\\n                    aj_flw = 0\\n                if aj_flw == k:\\n                    count_flw += 1 \\n                    aj_flw = 0\\n            return count_flw >=m\\n                    \\n        if len(A)<m*k: return -1 \\n        l,r = 1,max(A) \\n        \\n        while l<=r:\\n            mid = l+(r-l)//2 \\n            if isFeasible(mid):\\n                r = mid - 1 \\n            else:\\n                l = mid + 1\\n                 \\n        return l\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714075,
                "title": "simple-python-binary-search-similar-problem-listed",
                "content": "Please see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T...TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\n```\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        def cannotMakeBouquets(guess, m, k):\\n            bouquets = 0\\n            prev_open = 0\\n            for d in bloomDay:\\n                if d <= guess:\\n                    prev_open += 1\\n                else:\\n                    bouquets += prev_open // k\\n                    prev_open = 0\\n            bouquets += prev_open // k\\n            return bouquets < m\\n        \\n        n = len(bloomDay)\\n        if n < m * k:\\n            return -1\\n        low, high = 1, max(bloomDay)\\n        while low < high:\\n            guess = low + (high - low) // 2\\n            if cannotMakeBouquets(guess, m, k):\\n                low = guess + 1\\n            else:\\n                high = guess\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        def cannotMakeBouquets(guess, m, k):\\n            bouquets = 0\\n            prev_open = 0\\n            for d in bloomDay:\\n                if d <= guess:\\n                    prev_open += 1\\n                else:\\n                    bouquets += prev_open // k\\n                    prev_open = 0\\n            bouquets += prev_open // k\\n            return bouquets < m\\n        \\n        n = len(bloomDay)\\n        if n < m * k:\\n            return -1\\n        low, high = 1, max(bloomDay)\\n        while low < high:\\n            guess = low + (high - low) // 2\\n            if cannotMakeBouquets(guess, m, k):\\n                low = guess + 1\\n            else:\\n                high = guess\\n        return low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3713813,
                "title": "python-3-binary-search-beats-95",
                "content": "```python3 []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n\\n        def isEnoughDays(days):\\n            flowers, bouquets = 0, 0\\n            for d in bloomDay:\\n                flowers = flowers + 1 if d <= days else 0\\n                if flowers == k:\\n                    bouquets += 1\\n                    if bouquets == m: break\\n                    flowers = 0\\n            \\n            return bouquets == m\\n\\n        l, r = 1, max(bloomDay)\\n        while l < r:\\n            days = l + (r-l)//2\\n            if isEnoughDays(days):\\n                r = days\\n            else:\\n                l = days + 1\\n        \\n        return l\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n\\n        def isEnoughDays(days):\\n            flowers, bouquets = 0, 0\\n            for d in bloomDay:\\n                flowers = flowers + 1 if d <= days else 0\\n                if flowers == k:\\n                    bouquets += 1\\n                    if bouquets == m: break\\n                    flowers = 0\\n            \\n            return bouquets == m\\n\\n        l, r = 1, max(bloomDay)\\n        while l < r:\\n            days = l + (r-l)//2\\n            if isEnoughDays(days):\\n                r = days\\n            else:\\n                l = days + 1\\n        \\n        return l\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740154,
                "title": "javascript-binary-search",
                "content": "This binary search solution is based on Zhijun Liao\\'s fantastic post on binary searches:\\nhttps://leetcode.com/discuss/study-guide/786126/python-powerful-ultimate-binary-search-template-solved-many-problems/1087827\\n\\nIf you find any improvements or corrections please comment below!\\n\\nT: O (N * logM) Where M is the greatest value in BloomDay and N is the length of BloomDay\\nS: O (1)\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // Must have bloomDay.length >= (m * k) in order for bouquets to be at all possible\\n    if (bloomDay.length < m * k) return - 1;\\n    \\n    // Helper function returns boolean indicating whether m bouquets can be made after \"days\" days.\\n    const canMake = days => {  // Helper: T: O(N) (length of bloomDay)\\n        let numBouquets = 0; // tracks bouquets made\\n        let prevFlower = 0; // tracks start of current bouquet\\n        \\n        for (let i = 0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] > days) { // can\\'t use current flower\\n                prevFlower = i + 1; // reset start of current bouquet\\n            } else { // flower is in bloom and is usable\\n                if (i - prevFlower + 1 == k) { \\n                    numBouquets++;\\n                    prevFlower = i + 1;\\n                }\\n            }\\n        }\\n        return numBouquets >= m;\\n    }\\n    \\n    // Find min acceptable days to wait. // T: O(logM) (M is greatest val in bloomDay)\\n    let l = 0;\\n    let r = Math.max(...bloomDay);\\n    while (l < r) {\\n        let mid = l + Math.floor((r - l) / 2);\\n        if (canMake (mid)) r = mid;\\n        else l = mid + 1;\\n    }\\n    return l;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDays = function(bloomDay, m, k) {\\n    // Must have bloomDay.length >= (m * k) in order for bouquets to be at all possible\\n    if (bloomDay.length < m * k) return - 1;\\n    \\n    // Helper function returns boolean indicating whether m bouquets can be made after \"days\" days.\\n    const canMake = days => {  // Helper: T: O(N) (length of bloomDay)\\n        let numBouquets = 0; // tracks bouquets made\\n        let prevFlower = 0; // tracks start of current bouquet\\n        \\n        for (let i = 0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] > days) { // can\\'t use current flower\\n                prevFlower = i + 1; // reset start of current bouquet\\n            } else { // flower is in bloom and is usable\\n                if (i - prevFlower + 1 == k) { \\n                    numBouquets++;\\n                    prevFlower = i + 1;\\n                }\\n            }\\n        }\\n        return numBouquets >= m;\\n    }\\n    \\n    // Find min acceptable days to wait. // T: O(logM) (M is greatest val in bloomDay)\\n    let l = 0;\\n    let r = Math.max(...bloomDay);\\n    while (l < r) {\\n        let mid = l + Math.floor((r - l) / 2);\\n        if (canMake (mid)) r = mid;\\n        else l = mid + 1;\\n    }\\n    return l;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200608,
                "title": "easy-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& a, int m, int k) {\\n        int n=a.size();\\n        if(n<m*k)return -1;\\n        \\n        int left=*min_element(a.begin(),a.end());\\n        int right=*max_element(a.begin(),a.end());\\n        \\n        while(left<right)\\n        {\\n            int c=0,bouquet=0;\\n\\n            int mid=(left+right)/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]<=mid)c++;\\n                else c=0;\\n                \\n                if(c==k)\\n                {\\n                    bouquet++;\\n                    c=0;\\n                }\\n            }\\n            \\n            if(bouquet<m)left=mid+1;\\n            else right=mid;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& a, int m, int k) {\\n        int n=a.size();\\n        if(n<m*k)return -1;\\n        \\n        int left=*min_element(a.begin(),a.end());\\n        int right=*max_element(a.begin(),a.end());\\n        \\n        while(left<right)\\n        {\\n            int c=0,bouquet=0;\\n\\n            int mid=(left+right)/2;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]<=mid)c++;\\n                else c=0;\\n                \\n                if(c==k)\\n                {\\n                    bouquet++;\\n                    c=0;\\n                }\\n            }\\n            \\n            if(bouquet<m)left=mid+1;\\n            else right=mid;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693984,
                "title": "c-binary-search-similar-to-painter-s-partition-problem-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/submissions/\\n    \\n    We can use binary search here on the search space of days req to make req. bouquets.\\n    We check for a given days, is it possible to make the bouquets, if yes then search for \\n    an even smaller time duration(days) else make the duration more.\\n    \\n    \\n    TC: O(nlog(INT_MAX))\\n*/\\n\\nclass Solution {\\npublic:\\n    // Whether it is possible required bouquets with given max time\\n    bool bouquetPossible(vector<int>& bloom_days, int bloom_day, int m, int k) {\\n        int bouquets = 0, flowers = 0;\\n        for(const int& day: bloom_days) {\\n            if(day <= bloom_day)\\n                ++flowers;\\n            else\\n                flowers = 0;\\n            if(flowers == k)\\n                ++bouquets, flowers = 0;\\n        }\\n        \\n        return bouquets >= m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        // No. of flowers req more than available\\n        if(m * k > bloomDay.size())\\n            return -1;\\n        \\n        int low = 0, high = INT_MAX;\\n        while(low < high) {\\n            // Candidate bloom date for making req bouquets\\n            int bloom_day = low + (high - low) / 2;\\n            if(bouquetPossible(bloomDay, bloom_day, m, k))\\n                high = bloom_day;\\n            else\\n                low = bloom_day + 1;\\n        }\\n        \\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/submissions/\\n    \\n    We can use binary search here on the search space of days req to make req. bouquets.\\n    We check for a given days, is it possible to make the bouquets, if yes then search for \\n    an even smaller time duration(days) else make the duration more.\\n    \\n    \\n    TC: O(nlog(INT_MAX))\\n*/\\n\\nclass Solution {\\npublic:\\n    // Whether it is possible required bouquets with given max time\\n    bool bouquetPossible(vector<int>& bloom_days, int bloom_day, int m, int k) {\\n        int bouquets = 0, flowers = 0;\\n        for(const int& day: bloom_days) {\\n            if(day <= bloom_day)\\n                ++flowers;\\n            else\\n                flowers = 0;\\n            if(flowers == k)\\n                ++bouquets, flowers = 0;\\n        }\\n        \\n        return bouquets >= m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        // No. of flowers req more than available\\n        if(m * k > bloomDay.size())\\n            return -1;\\n        \\n        int low = 0, high = INT_MAX;\\n        while(low < high) {\\n            // Candidate bloom date for making req bouquets\\n            int bloom_day = low + (high - low) / 2;\\n            if(bouquetPossible(bloomDay, bloom_day, m, k))\\n                high = bloom_day;\\n            else\\n                low = bloom_day + 1;\\n        }\\n        \\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882469,
                "title": "most-optimal-solution-with-explanation-using-binary-search",
                "content": "\\n\\n# Approach\\nThe solution uses binary search to find the minimum number of days needed to make m bouquets using k adjacent flowers from the garden. The key idea is to perform a binary search on the possible days within which the flowers can bloom, and then check whether it\\'s possible to make at least m bouquets using those bloomed flowers.\\n\\n- The possible function takes the list of bloom days, a specific day day, the required number of bouquets m, and the number of flowers needed for a bouquet k.\\n\\n- It iterates through the bloomDay list and counts how many flowers have bloomed within the day limit. When a flower\\'s bloom day is greater than day, it resets the cnt (count) and adds the count of complete bouquets that can be formed from the flowers that bloomed before this day.\\n\\n- After the loop, it calculates the total number of bouquets that can be formed using the remaining flowers.\\n\\n- The minDays function takes the bloomDay list, the required number of bouquets m, and the number of flowers needed for a bouquet k.\\n\\n- It calculates the val as the minimum number of flowers required to make m bouquets.\\n\\n- It finds the lowest and highest bloom days in the bloomDay list.\\n\\n- The binary search is performed within the range of bloom days from low to high. Inside the loop, it checks if it\\'s possible to make m bouquets with k flowers each, using flowers that bloom within the mid day. If possible, it updates high to mid-1, else it updates low to mid+1.\\n\\n- Finally, it returns the low value, which represents the minimum number of days needed to make m bouquets using k adjacent flowers.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(max-min))\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& nums, int day, int m, int k) {\\n        int cnt = 0, num = 0;\\n        for(int i = 0; i< nums.size(); i++) {\\n            if(nums[i] <= day) cnt++;\\n            else {\\n                num += cnt/k;\\n                cnt = 0;\\n            }\\n        }\\n        num += cnt/k;\\n        return num>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        long long val = m * 1ll * k * 1ll;\\n        if(val>n) return -1;\\n        int low = INT_MAX, high = INT_MIN;\\n        for(int i = 0; i< n; i++) {\\n            low = min(bloomDay[i], low);\\n            high = max(bloomDay[i], high);\\n        }\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(possible(bloomDay, mid, m, k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        n = len(bloomDay)\\n        val = m * k\\n        if val > n:\\n            return -1\\n        \\n        low = float(\\'inf\\')\\n        high = float(\\'-inf\\')\\n        for day in bloomDay:\\n            low = min(day, low)\\n            high = max(day, high)\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if self.possible(bloomDay, mid, m, k):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        \\n        return low\\n    \\n    def possible(self, bloomDay, day, m, k):\\n        cnt = 0\\n        num = 0\\n        for bd in bloomDay:\\n            if bd <= day:\\n                cnt += 1\\n            else:\\n                num += cnt // k\\n                cnt = 0\\n        num += cnt // k\\n        return num >= m\\n\\n```\\n```JAVA []\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        long val = (long) m * k;\\n        if (val > n) return -1;\\n        \\n        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\\n        for (int day : bloomDay) {\\n            low = Math.min(day, low);\\n            high = Math.max(day, high);\\n        }\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (possible(bloomDay, mid, m, k)) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n    \\n    private boolean possible(int[] bloomDay, int day, int m, int k) {\\n        int cnt = 0, num = 0;\\n        for (int i = 0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] <= day) {\\n                cnt++;\\n            } else {\\n                num += cnt / k;\\n                cnt = 0;\\n            }\\n        }\\n        num += cnt / k;\\n        return num >= m;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& nums, int day, int m, int k) {\\n        int cnt = 0, num = 0;\\n        for(int i = 0; i< nums.size(); i++) {\\n            if(nums[i] <= day) cnt++;\\n            else {\\n                num += cnt/k;\\n                cnt = 0;\\n            }\\n        }\\n        num += cnt/k;\\n        return num>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        long long val = m * 1ll * k * 1ll;\\n        if(val>n) return -1;\\n        int low = INT_MAX, high = INT_MIN;\\n        for(int i = 0; i< n; i++) {\\n            low = min(bloomDay[i], low);\\n            high = max(bloomDay[i], high);\\n        }\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(possible(bloomDay, mid, m, k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        n = len(bloomDay)\\n        val = m * k\\n        if val > n:\\n            return -1\\n        \\n        low = float(\\'inf\\')\\n        high = float(\\'-inf\\')\\n        for day in bloomDay:\\n            low = min(day, low)\\n            high = max(day, high)\\n        \\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if self.possible(bloomDay, mid, m, k):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        \\n        return low\\n    \\n    def possible(self, bloomDay, day, m, k):\\n        cnt = 0\\n        num = 0\\n        for bd in bloomDay:\\n            if bd <= day:\\n                cnt += 1\\n            else:\\n                num += cnt // k\\n                cnt = 0\\n        num += cnt // k\\n        return num >= m\\n\\n```\n```JAVA []\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        long val = (long) m * k;\\n        if (val > n) return -1;\\n        \\n        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;\\n        for (int day : bloomDay) {\\n            low = Math.min(day, low);\\n            high = Math.max(day, high);\\n        }\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (possible(bloomDay, mid, m, k)) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n    \\n    private boolean possible(int[] bloomDay, int day, int m, int k) {\\n        int cnt = 0, num = 0;\\n        for (int i = 0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] <= day) {\\n                cnt++;\\n            } else {\\n                num += cnt / k;\\n                cnt = 0;\\n            }\\n        }\\n        num += cnt / k;\\n        return num >= m;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751751,
                "title": "best-c-solution-list-of-8-similar-very-imp-binary-search-questions",
                "content": "# List of similar binary search questions \\n- [Find the Smallest Divisor Given a Threshold - Leetcode](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/solutions/3746201/best-c-solution-pure-binary-search-approach-beats-98-84/)\\n- [Koko Eating bananas - Leetcode](https://leetcode.com/problems/koko-eating-bananas/solutions/3750804/best-c-solution-list-of-7-similar-very-imp-binary-search-questions/)\\n- [Capacity To Ship Packages Within D Days - Leetcode](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3751752/best-c-solution-list-of-similar-very-imp-binary-search-questions/)\\n- [Minimum Time to Repair Cars - Leetcode](https://leetcode.com/problems/minimum-time-to-repair-cars/solutions/3753730/best-c-solution-list-of-8-similar-very-imp-binary-search-questions/)\\n- [Minimized Maximum of Products Distributed to Any Store - Leetcode](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/solutions/3750918/best-c-solution-list-of-similar-very-imp-binary-search-questions/) \\n- [Book Allocation - Coding Ninjas](https://www.codingninjas.com/studio/problems/ayush-and-ninja-test_1097574?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n- [Aggressive cows - Coding Ninjas](https://www.codingninjas.com/studio/problems/aggressive-cows_1082559?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=1)\\n- [Painter\\'s partition - Coding Ninjas](https://www.codingninjas.com/studio/problems/painter\\'s-partition-problem_1089557?source=youtube&campaign=love_babbar_codestudio2&leftPanelTab=0)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if ((long)m * (long)k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid)\\n                    flow = 0;\\n                else if (++flow >= k)\\n                    bouq++, flow = 0;\\n            }\\n            if (bouq < m)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if ((long)m * (long)k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid)\\n                    flow = 0;\\n                else if (++flow >= k)\\n                    bouq++, flow = 0;\\n            }\\n            if (bouq < m)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204253,
                "title": "4ms-c-binary-search-easy",
                "content": "\\n# Approach\\nThe Code is explained line by line wherever required\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool helper(long long int &mid,vector<int>& bloomDay, int &m, int &k){\\n        int n = bloomDay.size();\\n        int bouq = 0;\\n        int total=0;\\n        for(int i=0;i<n;i++){\\n            if(bloomDay[i] <= mid){ //mid is the particular time, if values below the time are less then mid then it means that the flower has bloomed because it is less than mid\\n            total++;\\n            }\\n            else{\\n                if(total >= k){ //if values in total are greater it means we can forma bouquet\\n                    bouq++;\\n                }\\n                total = 0; //we reset to form a new streak\\n            }\\n            if(total>=k) //if at any point this condn satisfy\\n            {\\n                bouq++;\\n                total = 0;\\n            }\\n        }\\n        if(total >=k) bouq++;\\n        return (bouq >=m);\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < (long long)m*k) return -1; //garden has flowers less than required\\n        long long int left = 1;\\n        long long int right = *max_element(bloomDay.begin(), bloomDay.end());\\n        while(left<right){\\n            long long int mid = (left+right)/2;\\n            if(helper(mid,bloomDay,m,k)){\\n                right = mid;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool helper(long long int &mid,vector<int>& bloomDay, int &m, int &k){\\n        int n = bloomDay.size();\\n        int bouq = 0;\\n        int total=0;\\n        for(int i=0;i<n;i++){\\n            if(bloomDay[i] <= mid){ //mid is the particular time, if values below the time are less then mid then it means that the flower has bloomed because it is less than mid\\n            total++;\\n            }\\n            else{\\n                if(total >= k){ //if values in total are greater it means we can forma bouquet\\n                    bouq++;\\n                }\\n                total = 0; //we reset to form a new streak\\n            }\\n            if(total>=k) //if at any point this condn satisfy\\n            {\\n                bouq++;\\n                total = 0;\\n            }\\n        }\\n        if(total >=k) bouq++;\\n        return (bouq >=m);\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < (long long)m*k) return -1; //garden has flowers less than required\\n        long long int left = 1;\\n        long long int right = *max_element(bloomDay.begin(), bloomDay.end());\\n        while(left<right){\\n            long long int mid = (left+right)/2;\\n            if(helper(mid,bloomDay,m,k)){\\n                right = mid;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529845,
                "title": "c-binary-search-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isFeasible(vector<int>& bloomDay,int mid,int k,int required){\\n        int n = bloomDay.size();\\n        \\n        int boquets = 0;\\n        int subArraySize = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t//if anywhere in between if we found any element that is greater than mid then\\n\\t\\t\\t//we cant use this subarray for creating a boquet within mid time\\n            if(bloomDay[i] > mid){\\n                subArraySize = 0;\\n            }\\n\\t\\t\\t//it means we have found k elements which are <= mid\\n\\t\\t\\t//and we can form a boquet with this subarray within mid time\\n            else if(++subArraySize == k){\\n                subArraySize = 0;\\n                boquets++;\\n            }\\n        }\\n        // cout<<endl;\\n        return boquets >= required;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        int total = 1ll * m * k;\\n        \\n        if(total > n) return -1;\\n        \\n        int low = 1;\\n        int high = *max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        \\n        int res = 1e9;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(isFeasible(bloomDay,mid,k,m)){\\n                res = min(res,mid);\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nDo upvote if you find it helpful :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFeasible(vector<int>& bloomDay,int mid,int k,int required){\\n        int n = bloomDay.size();\\n        \\n        int boquets = 0;\\n        int subArraySize = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t//if anywhere in between if we found any element that is greater than mid then\\n\\t\\t\\t//we cant use this subarray for creating a boquet within mid time\\n            if(bloomDay[i] > mid){\\n                subArraySize = 0;\\n            }\\n\\t\\t\\t//it means we have found k elements which are <= mid\\n\\t\\t\\t//and we can form a boquet with this subarray within mid time\\n            else if(++subArraySize == k){\\n                subArraySize = 0;\\n                boquets++;\\n            }\\n        }\\n        // cout<<endl;\\n        return boquets >= required;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        int total = 1ll * m * k;\\n        \\n        if(total > n) return -1;\\n        \\n        int low = 1;\\n        int high = *max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        \\n        int res = 1e9;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(isFeasible(bloomDay,mid,k,m)){\\n                res = min(res,mid);\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2277318,
                "title": "don-t-understand-the-question-here-s-a-detailed-explanation-with-example-and-java-solution",
                "content": "1. bloomDay is an array of int values. Each value represents 1 flower. The value itself is the day this flower will bloom on. Heres an example, lets say bloomDay = {1,10,2}. That means there are 3 flowers that can bloom. The first flower will bloom on day 1, the second on day 10, and the third on day 2.\\n\\n2. \\'int m\\' is the number of bouquets that need to be made. \\'int k\\' is the number of flowers required to make a bouquet. For example if m = 4 and k = 2; then that means we will need to make 4 bouquets that each have 2 flowers in them. That also means the length of the array bloomDay must be 8 or greater since you won\\'t be able to make 4 bouquets with 7 or less flowers.\\n\\n3. You can only make bouquets with flowers that have bloomed and are adjacent to other bloomed flowers. For example, lets say \\n\\t* bloomDay = {1,10,2,9,3,8,4,7,5,6}\\n\\t* m = 4\\n\\t* k = 2\\n\\n* If it was day 8 then we could only make 3 bouquets due to adjacency. We can pick flowers 3,8,4,7,5,6. We can\\'t pick flowers 10 and 9 since they haven\\'t bloomed yet. We can\\'t pick flower 2 since flower 9 comes after it which prevents it from being adjacent to 3,8,4,7,5,6. We can\\'t pick flower 1 since 10 comes after. 3,8,4,7,5,6 contains 6 flowers which means we can make 3 bouquets since each bouquet requires 2 flowers.\\n\\n* If it was day 9 then we can make 4 bouquets and get the correct answer by picking flowers 2,9,3,8,4,7,5,6.\\n---------------------------\\nTo solve this problem, you need an algorithm that can get the number of bouquets on a specific day. Then you can place this algorithm inside a binary search and use the midpoint of the binary search as the day you want this algorithm to look at efficently. \\n\\n```\\nint length = bloomDay.length;\\nif (m * k > length)          return -1;      // Not enough flowers to make m bouquets.\\nint left = 1; \\nint right = 0;\\nfor (int bd : bloomDay)     right = Math.max(bd,right);  \\n\\n// Binary search\\nwhile(left<right)  {\\n\\tint mid = left+(right-left)/2;\\n\\tint adjacentFlower = 0;\\n\\tint bouqCount = 0;\\n\\t\\n\\t// Algorithm to get the number of bouquets on a specific day (mid).\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tif (mid<bloomDay[i])    adjacentFlower = 0;\\n\\t\\telse if (++adjacentFlower == k)   {\\n\\t\\t\\tbouqCount++;\\n\\t\\t\\tadjacentFlower = 0;\\n\\t\\t}\\n\\t}\\n\\t// END of bouquet counting algorithm.\\n\\t\\n\\tif (bouqCount>=m)       right = mid;         \\n\\telse                    left = mid+1;\\n}\\nreturn left;\\n```\\n\\n\\t\\t\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint length = bloomDay.length;\\nif (m * k > length)          return -1;      // Not enough flowers to make m bouquets.\\nint left = 1; \\nint right = 0;\\nfor (int bd : bloomDay)     right = Math.max(bd,right);  \\n\\n// Binary search\\nwhile(left<right)  {\\n\\tint mid = left+(right-left)/2;\\n\\tint adjacentFlower = 0;\\n\\tint bouqCount = 0;\\n\\t\\n\\t// Algorithm to get the number of bouquets on a specific day (mid).\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tif (mid<bloomDay[i])    adjacentFlower = 0;\\n\\t\\telse if (++adjacentFlower == k)   {\\n\\t\\t\\tbouqCount++;\\n\\t\\t\\tadjacentFlower = 0;\\n\\t\\t}\\n\\t}\\n\\t// END of bouquet counting algorithm.\\n\\t\\n\\tif (bouqCount>=m)       right = mid;         \\n\\telse                    left = mid+1;\\n}\\nreturn left;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981509,
                "title": "java-c-binary-search-clean",
                "content": "### Java\\n\\n```\\npublic int minDays(int[] bloomDay, int m, int k) {\\n        if (m * k > bloomDay.length)\\n            return -1;\\n\\n        int left = 1;\\n        int right = (int) 1e9;\\n\\n        while (left < right) {\\n            int middle = (right + left) / 2;\\n            if (makeBouquets(bloomDay, m, k, middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n\\n        return right;\\n    }\\n\\n    private boolean makeBouquets(int[] bloomDay, int bouquets, int inOneBouquet, int day) {\\n        int adjacentCount = 0;\\n\\n        for (int daysNeeded : bloomDay) {\\n            if (daysNeeded <= day) {\\n                if (++adjacentCount == inOneBouquet) {\\n                    adjacentCount = 0;\\n                    if (--bouquets == 0)\\n                        return true;\\n                }\\n            } else {\\n                adjacentCount = 0;\\n            }\\n        }\\n        return bouquets == 0;\\n    }\\n```\\n\\n\\n### C++\\n\\n```\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (m * k > bloomDay.size())\\n            return -1;\\n\\n        int left = 1;\\n        int right = 1e9;\\n\\n        while (left < right) {\\n            int middle = (right + left) / 2;\\n            if (makeBouquets(bloomDay, m, k, middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n\\n        return right;\\n    }\\n    \\nprivate: bool makeBouquets(vector<int>& bloomDay, int bouquets, int inOneBouquet, int day) {\\n        int adjacentCount = 0;\\n\\n        for (int daysNeeded : bloomDay) {\\n            if (daysNeeded <= day) {\\n                if (++adjacentCount == inOneBouquet) {\\n                    adjacentCount = 0;\\n                    if (--bouquets == 0)\\n                        return true;\\n                }\\n            } else {\\n                adjacentCount = 0;\\n            }\\n        }\\n        return bouquets == 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic int minDays(int[] bloomDay, int m, int k) {\\n        if (m * k > bloomDay.length)\\n            return -1;\\n\\n        int left = 1;\\n        int right = (int) 1e9;\\n\\n        while (left < right) {\\n            int middle = (right + left) / 2;\\n            if (makeBouquets(bloomDay, m, k, middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n\\n        return right;\\n    }\\n\\n    private boolean makeBouquets(int[] bloomDay, int bouquets, int inOneBouquet, int day) {\\n        int adjacentCount = 0;\\n\\n        for (int daysNeeded : bloomDay) {\\n            if (daysNeeded <= day) {\\n                if (++adjacentCount == inOneBouquet) {\\n                    adjacentCount = 0;\\n                    if (--bouquets == 0)\\n                        return true;\\n                }\\n            } else {\\n                adjacentCount = 0;\\n            }\\n        }\\n        return bouquets == 0;\\n    }\\n```\n```\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (m * k > bloomDay.size())\\n            return -1;\\n\\n        int left = 1;\\n        int right = 1e9;\\n\\n        while (left < right) {\\n            int middle = (right + left) / 2;\\n            if (makeBouquets(bloomDay, m, k, middle))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n\\n        return right;\\n    }\\n    \\nprivate: bool makeBouquets(vector<int>& bloomDay, int bouquets, int inOneBouquet, int day) {\\n        int adjacentCount = 0;\\n\\n        for (int daysNeeded : bloomDay) {\\n            if (daysNeeded <= day) {\\n                if (++adjacentCount == inOneBouquet) {\\n                    adjacentCount = 0;\\n                    if (--bouquets == 0)\\n                        return true;\\n                }\\n            } else {\\n                adjacentCount = 0;\\n            }\\n        }\\n        return bouquets == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475381,
                "title": "simple-c-solution-using-binary-search-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int> a, int m, int k, int mid)\\n    {\\n        int n=a.size();\\n        int bouq=0;\\n        int flow=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]<=mid)\\n                flow++;\\n            else \\n            {\\n                flow=0;\\n            }\\n            if(flow>=k)\\n            {\\n                bouq++;\\n                flow=0;\\n            }\\n        }\\n        if(bouq>=m)\\n            return true;\\n        else\\n            return false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        if(n<k*m)\\n            return -1;\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(bloomDay,m,k,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\tPlease consider upvoting.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int> a, int m, int k, int mid)\\n    {\\n        int n=a.size();\\n        int bouq=0;\\n        int flow=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]<=mid)\\n                flow++;\\n            else \\n            {\\n                flow=0;\\n            }\\n            if(flow>=k)\\n            {\\n                bouq++;\\n                flow=0;\\n            }\\n        }\\n        if(bouq>=m)\\n            return true;\\n        else\\n            return false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        if(n<k*m)\\n            return -1;\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(bloomDay,m,k,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686312,
                "title": "c-binary-search-template-simulation-pruning-natural",
                "content": "**Idea:**\\nRemeber \\'first bad version\\'\\nhttps://leetcode.com/problems/first-bad-version/\\nIt\\'s similar idea with more overheads.\\nI used simulation to make things easier. It took me 56 mintures to come up with this solution in the weekly contest.\\n\\nIf you have any suggestion can help me speed up thinking, I will greatly appreciate. \\n\\n\\nversion 1: one-hour thinking solution in 43-lines:\\nDuring conest, my thinking is very fuzy and doing some brute-force searching for solution.  I smell the binary search pattern, then I was scared by the potential challenge from boutiquet task: k ajacent flower.\\nOne vital point I want to share is: \\nAs human, we think top-down. Please always begin with function calling, such as valid(), then write function to implement it. This is how we communicate with others and how we natually come up the solution.\\n\\n\\nTime complexity: O(NlogMaxDay); maxDay = 1e9;\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        vector<int> v(b);\\n        const int n = v.size();\\n        if(m*k>n) return -1;\\n        sort(v.begin(), v.end());\\n        int minV = v[0], maxV = v[n-1];        \\n        int l = minV, r = maxV+1;        \\n        int hasSolution = 0;\\n        while(l<r){\\n            int mid = l + (r - l) / 2;\\n            bool possible = isValid(b, mid, m, k);            \\n            if(possible) {\\n                r = mid;\\n                hasSolution++; \\n            }else \\n                l = mid + 1;\\n        }\\n        return hasSolution > 0 ? l : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int bouquets, int k){        \\n        const int n = b.size();\\n        vector<int> flowers(n);\\n        int tot = 0;\\n        for(int i = 0; i < n; i++){\\n            flowers[i] = (b[i] <= day);        \\n            tot += flowers[i];\\n        }\\n        if(tot < bouquets * k) return false;\\n        for(int i = 0, cnt = 0; i < n; i++){            \\n            if(flowers[i] == 1){\\n                cnt++;\\n                if(cnt ==k) cnt = 0, bouquets--;\\n                if(bouquets == 0) return true;\\n            }\\n            else cnt=0;\\n        }\\n        return false;        \\n    }\\n};\\n```\\n\\n\\nversion 2: optmized version in post-contest in 24-lines\\nTime complexity: O(NlogMaxDay); maxDay = 1e9;\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {      \\n        int maxDay = 1e9 + 1;\\n        int l = 1, r = maxDay; // [); left close right open rule                            \\n        while(l<r){\\n            int mid = l + (r - l) / 2;                \\n            if(isValid(b, mid, m, k)) r = mid;  // use isValid to decouple the question into 2 smalll subproblems then conquer them 1 by 1            \\n            else l = mid + 1;\\n        }\\n        return l < maxDay ? l  : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int bouquets, int k){                \\n        for(int i = 0, cnt = 0; i < b.size(); i++)\\n            if(b[i] <= day){\\n                cnt++;\\n                if(cnt ==k) cnt = 0, bouquets--;\\n                if(bouquets == 0) return true;\\n            }else cnt=0;        \\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        vector<int> v(b);\\n        const int n = v.size();\\n        if(m*k>n) return -1;\\n        sort(v.begin(), v.end());\\n        int minV = v[0], maxV = v[n-1];        \\n        int l = minV, r = maxV+1;        \\n        int hasSolution = 0;\\n        while(l<r){\\n            int mid = l + (r - l) / 2;\\n            bool possible = isValid(b, mid, m, k);            \\n            if(possible) {\\n                r = mid;\\n                hasSolution++; \\n            }else \\n                l = mid + 1;\\n        }\\n        return hasSolution > 0 ? l : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int bouquets, int k){        \\n        const int n = b.size();\\n        vector<int> flowers(n);\\n        int tot = 0;\\n        for(int i = 0; i < n; i++){\\n            flowers[i] = (b[i] <= day);        \\n            tot += flowers[i];\\n        }\\n        if(tot < bouquets * k) return false;\\n        for(int i = 0, cnt = 0; i < n; i++){            \\n            if(flowers[i] == 1){\\n                cnt++;\\n                if(cnt ==k) cnt = 0, bouquets--;\\n                if(bouquets == 0) return true;\\n            }\\n            else cnt=0;\\n        }\\n        return false;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {      \\n        int maxDay = 1e9 + 1;\\n        int l = 1, r = maxDay; // [); left close right open rule                            \\n        while(l<r){\\n            int mid = l + (r - l) / 2;                \\n            if(isValid(b, mid, m, k)) r = mid;  // use isValid to decouple the question into 2 smalll subproblems then conquer them 1 by 1            \\n            else l = mid + 1;\\n        }\\n        return l < maxDay ? l  : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int bouquets, int k){                \\n        for(int i = 0, cnt = 0; i < b.size(); i++)\\n            if(b[i] <= day){\\n                cnt++;\\n                if(cnt ==k) cnt = 0, bouquets--;\\n                if(bouquets == 0) return true;\\n            }else cnt=0;        \\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123111,
                "title": "beats-97-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (bloomDay.size() < (long long) m * k) \\n            return -1;\\n\\n        int mn = INT_MAX, mx = INT_MIN;\\n        for (int i : bloomDay) {\\n            mx = max(mx, i);\\n            mn = min(mn, i);\\n        }\\n\\n        int l = mn; \\n        int r = mx;\\n\\n        // l, r bloom days (min, max)\\n        while (l < r) {\\n            int mid = (l + r) / 2;\\n            int possibleBookies = getPossibleBookies(bloomDay, mid, k);\\n\\n            // still not enough.  If wait more days, we will get more floor.  Now increase l (wait more)\\n            if (possibleBookies < m) \\n                l = mid + 1;\\n            else  // why not mid - 1?\\n                r = mid;\\n        }\\n\\n        return l;      \\n    }\\n\\n    int getPossibleBookies(vector<int>& bloomDay, int day, int k) {\\n        int bouquets = 0, flowersCollected = 0;\\n\\n        for (int value : bloomDay) {\\n            if (value <= day) {\\n                flowersCollected++;\\n            } \\n            else  // k adjacent flowers.  if value > day, it will bloom value days. now 0.\\n                flowersCollected = 0;\\n\\n            if (flowersCollected == k) {\\n                // collect all k adjacent flowers. Now collect another k adjacent flowers\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n        return bouquets;\\n    }\\n};\\n```\\n![leetcode.jpeg](https://assets.leetcode.com/users/images/de28b337-9647-4445-8cc4-9c437648a2b0_1675175214.8793533.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (bloomDay.size() < (long long) m * k) \\n            return -1;\\n\\n        int mn = INT_MAX, mx = INT_MIN;\\n        for (int i : bloomDay) {\\n            mx = max(mx, i);\\n            mn = min(mn, i);\\n        }\\n\\n        int l = mn; \\n        int r = mx;\\n\\n        // l, r bloom days (min, max)\\n        while (l < r) {\\n            int mid = (l + r) / 2;\\n            int possibleBookies = getPossibleBookies(bloomDay, mid, k);\\n\\n            // still not enough.  If wait more days, we will get more floor.  Now increase l (wait more)\\n            if (possibleBookies < m) \\n                l = mid + 1;\\n            else  // why not mid - 1?\\n                r = mid;\\n        }\\n\\n        return l;      \\n    }\\n\\n    int getPossibleBookies(vector<int>& bloomDay, int day, int k) {\\n        int bouquets = 0, flowersCollected = 0;\\n\\n        for (int value : bloomDay) {\\n            if (value <= day) {\\n                flowersCollected++;\\n            } \\n            else  // k adjacent flowers.  if value > day, it will bloom value days. now 0.\\n                flowersCollected = 0;\\n\\n            if (flowersCollected == k) {\\n                // collect all k adjacent flowers. Now collect another k adjacent flowers\\n                bouquets++;\\n                flowersCollected = 0;\\n            }\\n        }\\n        return bouquets;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907251,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn+n)=O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        int s=INT_MAX,e=INT_MIN,ans=-1;\\n        for(int i=0;i<n;i++){\\n            s=min(s,bloomDay[i]);\\n            e=max(e,bloomDay[i]);\\n        }\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            int c=0,no=0;\\n            for(int i=0;i<n;i++){\\n                if(bloomDay[i]<=mid)\\n                    c++;\\n                else\\n                    c=0;\\n                if(c==k){\\n                    c=0;\\n                    no++;\\n                }\\n                if(no==m)\\n                    break;\\n            }\\n            if(no<m)\\n                s=mid+1;\\n            else{\\n                ans=mid;\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        int s=INT_MAX,e=INT_MIN,ans=-1;\\n        for(int i=0;i<n;i++){\\n            s=min(s,bloomDay[i]);\\n            e=max(e,bloomDay[i]);\\n        }\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            int c=0,no=0;\\n            for(int i=0;i<n;i++){\\n                if(bloomDay[i]<=mid)\\n                    c++;\\n                else\\n                    c=0;\\n                if(c==k){\\n                    c=0;\\n                    no++;\\n                }\\n                if(no==m)\\n                    break;\\n            }\\n            if(no<m)\\n                s=mid+1;\\n            else{\\n                ans=mid;\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754633,
                "title": "c-binary-search-easy-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    /* we want to check can we make m bouquets at a day of mid or not */\\n    bool check(vector<int> &arr, int mid, int m, int k){\\n        int subarray = 0;\\n        int total = 0;\\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] <= mid){\\n                total++;\\n            }\\n            else{\\n                if(total == k){\\n                    subarray++;\\n                }\\n                total = 0;\\n            }\\n            if(total == k){\\n                subarray++;\\n                total = 0;\\n            }\\n        }\\n        if(subarray >= m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& arr, int m, int k) {\\n        /* if m*k < total no. of flows then we can\\'t make m bouquets */\\n        if(((long long)m*(long long)k) > arr.size()) return -1;\\n        \\n        /* maximum days we can take as maximum element in the array after that all flows will get bloom  */\\n        int l = 1, r = *max_element(arr.begin(), arr.end());\\n        int ans = -1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(arr, mid, m, k)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* we want to check can we make m bouquets at a day of mid or not */\\n    bool check(vector<int> &arr, int mid, int m, int k){\\n        int subarray = 0;\\n        int total = 0;\\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] <= mid){\\n                total++;\\n            }\\n            else{\\n                if(total == k){\\n                    subarray++;\\n                }\\n                total = 0;\\n            }\\n            if(total == k){\\n                subarray++;\\n                total = 0;\\n            }\\n        }\\n        if(subarray >= m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& arr, int m, int k) {\\n        /* if m*k < total no. of flows then we can\\'t make m bouquets */\\n        if(((long long)m*(long long)k) > arr.size()) return -1;\\n        \\n        /* maximum days we can take as maximum element in the array after that all flows will get bloom  */\\n        int l = 1, r = *max_element(arr.begin(), arr.end());\\n        int ans = -1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(arr, mid, m, k)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233972,
                "title": "python-binsearch-and-strings-t-m-94-92",
                "content": "```\\nclass Solution:\\n\\n                                    # pretty much the standard bin-search solution,\\n                                    # but with a string-manipulation helper function \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m*k: return -1\\n\\n        def f(day: int)->bool:\\n            s = \\'\\'.join([\\'X\\' if b <= day else \\' \\' for b in bloomDay])\\n            return s.count(\\'X\\'*k) >= m\\n\\n        left, right = min(bloomDay), max(bloomDay)\\n        while left < right:\\n            mid = (left + right)//2\\n            if f(mid): right = mid \\n            else: left = mid + 1\\n                \\n        return right",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n                                    # pretty much the standard bin-search solution,\\n                                    # but with a string-manipulation helper function \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m*k: return -1\\n\\n        def f(day: int)->bool:\\n            s = \\'\\'.join([\\'X\\' if b <= day else \\' \\' for b in bloomDay])\\n            return s.count(\\'X\\'*k) >= m\\n\\n        left, right = min(bloomDay), max(bloomDay)\\n        while left < right:\\n            mid = (left + right)//2\\n            if f(mid): right = mid \\n            else: left = mid + 1\\n                \\n        return right",
                "codeTag": "Java"
            },
            {
                "id": 2227168,
                "title": "c-simple-binary-search-o-n-log-max-min",
                "content": "```\\nclass Solution {\\npublic:\\n    //time complexity O(n*log(max-min))\\n    bool isValid(vector<int>&v,int m,int k,int mid){\\n        int cnt = 0;\\n        int temp = 0;\\n        for(int i=0;i<v.size();++i){\\n            if(v[i] <= mid){\\n                temp++;\\n            }else{\\n                temp = 0;\\n            }\\n            if(temp == k){\\n                temp = 0;\\n                cnt++;\\n            }\\n        }\\n        return cnt >= m;\\n    }\\n    int minDays(vector<int>& v, int m, int k) {\\n        int l = *min_element(v.begin(),v.end());\\n        int h = *max_element(v.begin(),v.end());\\n        int res = -1;\\n        //search space can be reduced to min element to max element\\n        while(l<=h){\\n            int mid = l+(h-l)/2;\\n            if(isValid(v,m,k,mid)){\\n                res = mid;\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //time complexity O(n*log(max-min))\\n    bool isValid(vector<int>&v,int m,int k,int mid){\\n        int cnt = 0;\\n        int temp = 0;\\n        for(int i=0;i<v.size();++i){\\n            if(v[i] <= mid){\\n                temp++;\\n            }else{\\n                temp = 0;\\n            }\\n            if(temp == k){\\n                temp = 0;\\n                cnt++;\\n            }\\n        }\\n        return cnt >= m;\\n    }\\n    int minDays(vector<int>& v, int m, int k) {\\n        int l = *min_element(v.begin(),v.end());\\n        int h = *max_element(v.begin(),v.end());\\n        int res = -1;\\n        //search space can be reduced to min element to max element\\n        while(l<=h){\\n            int mid = l+(h-l)/2;\\n            if(isValid(v,m,k,mid)){\\n                res = mid;\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651427,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length,l = 0, r = findmax(bloomDay); \\n        if ((m*k)>n) return -1;\\n        while (l < r) {\\n            int mid = l+(r - l) / 2, count = 0, total = 0;//count the flowers for each bouq,total is bouq number\\n            for (int i : bloomDay){\\n                if(i>mid) count = 0;\\n                else if (++count>= k) {\\n                        total++; \\n                        count = 0;\\n                    }\\n                \\n            }\\n                        \\n            if (total < m)  l = mid + 1; \\n            else  r = mid;\\n            \\n        }\\n        return l;\\n    }\\n        private int findmax(int[] A){\\n        int max=0;\\n        for (int i :A){\\n            if (i>max) max = i;\\n        }\\n        return max;\\n        }\\n    }       \\n            \\n            \\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length,l = 0, r = findmax(bloomDay); \\n        if ((m*k)>n) return -1;\\n        while (l < r) {\\n            int mid = l+(r - l) / 2, count = 0, total = 0;//count the flowers for each bouq,total is bouq number\\n            for (int i : bloomDay){\\n                if(i>mid) count = 0;\\n                else if (++count>= k) {\\n                        total++; \\n                        count = 0;\\n                    }\\n                \\n            }\\n                        \\n            if (total < m)  l = mid + 1; \\n            else  r = mid;\\n            \\n        }\\n        return l;\\n    }\\n        private int findmax(int[] A){\\n        int max=0;\\n        for (int i :A){\\n            if (i>max) max = i;\\n        }\\n        return max;\\n        }\\n    }       \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580760,
                "title": "read-this-if-you-don-t-understand-why-binary-search-is-used-here-javascript",
                "content": "We know that for any flower to bloom it would atleast take the min of bloomDay and at max it would take the max of bloomDay, so\\nour answer should definitely lie between the minimum of bloomDay and maximum of bloomDay.\\n\\nTo solve this problem we can actually break the problem into two: \\n1. We need to find if we can make m bouqets given any number of days for a given k.\\n2. Now to actually find out the minimum no of days, we can look for all the days iterating from minimum to maximum and then see if we can make m bouqets on any of these days, as soon as we find an answer we know that is the minimum no of days as we are iterating all the way from minimum to maximum no of days.\\n3. Now since we can find a range, for finding the minimum no of days we can optimize the loop for finding the potentialDay using binary search.\\n\\nSo the function for solving the 1st problem would look like below, which is same for both brute force and binary search:\\n\\n```\\nfunction canMakeMBouquets(bloomDay, potentialDay, m, k){\\n    let flowers = 0;\\n    let bouquets = 0;\\n    for(let day of bloomDay){\\n        if(day > potentialDay){\\n\\t\\t\\t// we are resetting flowers to 0 mainly because we can only include adjacent flowers and if this flower cannot be chosen any of them adjacent and before it cannot be used\\n            flowers = 0;\\n        }else{\\n            flowers++;\\n        }\\n        if(flowers === k){\\n            bouquets++;\\n            flowers = 0; // resetting flowers to 0 again since we already made one bouqet using the flowers\\n        }\\n    }\\n    return bouquets >= m;\\n}\\n```\\n\\nThe brute force solution for this problem would look like below:\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // brute force solution would be to iterate over all the days from min to max\\n    // and then see if we can make m bouqets\\n    if(bloomDay.length < m * k) return -1;\\n    let min = Infinity;\\n    let max = 0;\\n    for(let day of bloomDay){\\n        min = Math.min(min, day);\\n        max = Math.max(max, day);\\n    }\\n    for(let day=min; day <= max; day++){\\n        if(canMakeMBouquets(bloomDay, day, m, k)){\\n            return day;\\n        }\\n    }\\n    return -1;\\n};\\n```\\n\\nThe optimized solution for the problem would look like below:\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // brute force solution would be to iterate over all the days from min to max\\n    // and then see if we can make m bouqets\\n    // so to optimize the solution we can instead do binary search on the potential day\\n    // instead of going over all the days\\n    if(bloomDay.length < m * k) return -1;\\n    let min = Infinity;\\n    let max = 0;\\n    for(let day of bloomDay){\\n        min = Math.min(min, day);\\n        max = Math.max(max, day);\\n    }\\n    let left = min, right = max;\\n    while(left < right){\\n        let mid = left + Math.floor((right - left) / 2);\\n        if(canMakeMBouquets(bloomDay, mid, m, k)){\\n            right = mid; // this can be a potential ans but we can further look for days lesser than this\\n        }else{\\n            left = mid + 1;\\n        }\\n    }\\n    return left; // either left or right would have the same value at the end.\\n};\\n```\\n\\nPlease upvote if it helps, this will encourage me to write more articles.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nfunction canMakeMBouquets(bloomDay, potentialDay, m, k){\\n    let flowers = 0;\\n    let bouquets = 0;\\n    for(let day of bloomDay){\\n        if(day > potentialDay){\\n\\t\\t\\t// we are resetting flowers to 0 mainly because we can only include adjacent flowers and if this flower cannot be chosen any of them adjacent and before it cannot be used\\n            flowers = 0;\\n        }else{\\n            flowers++;\\n        }\\n        if(flowers === k){\\n            bouquets++;\\n            flowers = 0; // resetting flowers to 0 again since we already made one bouqet using the flowers\\n        }\\n    }\\n    return bouquets >= m;\\n}\\n```\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // brute force solution would be to iterate over all the days from min to max\\n    // and then see if we can make m bouqets\\n    if(bloomDay.length < m * k) return -1;\\n    let min = Infinity;\\n    let max = 0;\\n    for(let day of bloomDay){\\n        min = Math.min(min, day);\\n        max = Math.max(max, day);\\n    }\\n    for(let day=min; day <= max; day++){\\n        if(canMakeMBouquets(bloomDay, day, m, k)){\\n            return day;\\n        }\\n    }\\n    return -1;\\n};\\n```\n```\\nvar minDays = function(bloomDay, m, k) {\\n    // brute force solution would be to iterate over all the days from min to max\\n    // and then see if we can make m bouqets\\n    // so to optimize the solution we can instead do binary search on the potential day\\n    // instead of going over all the days\\n    if(bloomDay.length < m * k) return -1;\\n    let min = Infinity;\\n    let max = 0;\\n    for(let day of bloomDay){\\n        min = Math.min(min, day);\\n        max = Math.max(max, day);\\n    }\\n    let left = min, right = max;\\n    while(left < right){\\n        let mid = left + Math.floor((right - left) / 2);\\n        if(canMakeMBouquets(bloomDay, mid, m, k)){\\n            right = mid; // this can be a potential ans but we can further look for days lesser than this\\n        }else{\\n            left = mid + 1;\\n        }\\n    }\\n    return left; // either left or right would have the same value at the end.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1417360,
                "title": "very-simple-binary-search-solution",
                "content": "# Just use binary search on every possible day and check for every day.\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &arr, int m, int k, int mid) {\\n        int n = arr.size();\\n        int count=0;\\n        for(int i=0; i<n; i++) {\\n            if(mid>=arr[i]) count++;\\n            else count=0;\\n            if(count==k) {m--; count=0;}\\n            if(m==0) return true;\\n        }\\n        return false;\\n    }\\n    int minDays(vector<int>& arr, int m, int k) {\\n        int n = arr.size();\\n        int r=*max_element(arr.begin(), arr.end());\\n        if(m*k>n) return -1;\\n        int l=*min_element(arr.begin(), arr.end());\\n        int ans=-1;\\n        while(l<=r) {\\n            int mid = l + (r-l)/2;\\n            if(check(arr, m, k, mid)) {\\n                r=mid-1;\\n                ans=mid;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &arr, int m, int k, int mid) {\\n        int n = arr.size();\\n        int count=0;\\n        for(int i=0; i<n; i++) {\\n            if(mid>=arr[i]) count++;\\n            else count=0;\\n            if(count==k) {m--; count=0;}\\n            if(m==0) return true;\\n        }\\n        return false;\\n    }\\n    int minDays(vector<int>& arr, int m, int k) {\\n        int n = arr.size();\\n        int r=*max_element(arr.begin(), arr.end());\\n        if(m*k>n) return -1;\\n        int l=*min_element(arr.begin(), arr.end());\\n        int ans=-1;\\n        while(l<=r) {\\n            int mid = l + (r-l)/2;\\n            if(check(arr, m, k, mid)) {\\n                r=mid-1;\\n                ans=mid;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083921,
                "title": "binary-search-beats-95-c-with-full-explanation",
                "content": "this solution is on solved on binary search . techniques here is used is binary search on answer .. \\nHere we first consider no. of days to be answers..where smallest no. of day may be 1 and the max days possible is the max of the blooming days\\n... then we find mid .. and on bloom array we chk how many flowers bloom after #mid days,, checking continuity .. if we find continously bloom flowers we kept on increasing our counter ,, if we find any unbloom flower we added them to bouget complete as c/k (total adjacent flowers bloomed/ total adjacent flowers needed) \\nif bougets completed is greater than equal to m the we decrease r to mid -1 \\nelse  we increase l to mid +1\\n\\n\\nhope explanation is clear .. upvote it if uh like the solution\\n\\n// MY CODE ::\\n\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k > bloomDay.size())\\n            return -1;\\n        int l=1,r=*max_element(bloomDay.begin(),bloomDay.end());\\n        while(l<=r){\\n            int md=l+(r-l)/2;\\n            int c=0,mcopy=0;\\n\\n            for(auto i:bloomDay){\\n                if(i<=md)\\n                   c++;\\n                else{\\n                    mcopy+=c/k;\\n                    // cout<<c<<\" \"<<mcopy<<\" \"<<i<<\" \"<<md<<endl;\\n                    c=0;\\n                }\\n            }``\\n            if(c>0){\\n                mcopy+=c/k;\\n            }\\n            if(mcopy>=m)\\n                r=md-1;\\n            else l=md+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k > bloomDay.size())\\n            return -1;\\n        int l=1,r=*max_element(bloomDay.begin(),bloomDay.end());\\n        while(l<=r){\\n            int md=l+(r-l)/2;\\n            int c=0,mcopy=0;\\n\\n            for(auto i:bloomDay){\\n                if(i<=md)\\n                   c++;\\n                else{\\n                    mcopy+=c/k;\\n                    // cout<<c<<\" \"<<mcopy<<\" \"<<i<<\" \"<<md<<endl;\\n                    c=0;\\n                }\\n            }``\\n            if(c>0){\\n                mcopy+=c/k;\\n            }\\n            if(mcopy>=m)\\n                r=md-1;\\n            else l=md+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 819184,
                "title": "6-questions-in-one-template-of-binary-search-for-beginners-python",
                "content": "6 questions in one template of binary search - for beginners! - python\\n\\n**Method:**\\n1. left - inclusive; right - exclusive\\n2. use while left < right\\n3. if finding min value, define \\'isok\\' function (and return left) ; \\n4. if finding max value, define \\'isfail\\' function (and return left-1).\\n\\nIn Chinese:\\n\\n1. \\u5DE6\\u95ED\\u53F3\\u5F00\\uFF1B\\n2. \\u4F7F\\u7528left < right\\n3. binary search\\u662F\\u7528\\u6765\\u67E5\\u627E\\u6700\\u5C0F\\u503C\\u7684\\uFF0C\\u5982\\u679C\\u9898\\u76EE\\u662F\\u5BFB\\u627E\\u6700\\u5C0F\\u503C\\uFF0C\\u90A3\\u5C31\\u76F4\\u63A5\\u8FD4\\u56DEleft\\uFF1B\\n4. \\u5982\\u679C\\u9898\\u76EE\\u8981\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF0C\\u90A3\\u5B9A\\u4E49\\u4E00\\u4E2Aisfail\\u51FD\\u6570\\uFF0C\\u5E76\\u627E\\u8BA9isfail\\u8FD4\\u56DEtrue\\u7684\\u6700\\u5C0F\\u7684left\\uFF0C\\u8FD9\\u6837\\u7684\\u8BDD\\uFF0Cleft-1\\u5C31\\u662F\\u6211\\u4EEC\\u8981\\u6C42\\u7684\\u6700\\u5927\\u7684\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u503C\\u4E86\\u3002\\n\\n\\n**1011. Capacity To Ship Packages Within D Days**\\n\\nMedium\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nShare\\nA conveyor belt has packages that must be shipped from one port to another within D days.\\n\\nThe i-th package on the conveyor belt has a weight of weights[i].  Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\\n\\nExample 1:\\n\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n\\'\\'\\'\\n\\n```\\n# # looking for a min value, then build a \\'isok\\' function and directly use binary search to \\n# find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode1011:\\n    def shipWithinDays(self, weights, D):\\n        # binary search\\n        # min weight capacity of the ship\\n        \\n        def isok(mid):\\n            # real days needed with max weight capacity of mid\\n            day = 1\\n            cursum = 0\\n            for weight in weights:\\n                if cursum + weight > mid:\\n                    day += 1\\n                    cursum = 0\\n                cursum += weight\\n            return day <= D\\n        \\n        left = max(weights) # note that this should be max(weights), not min(weights)!!\\n        right = sum(weights) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n\\n**1231. Divide Chocolate**\\n\\nHard\\nhttps://leetcode.com/problems/divide-chocolate/\\n\\nYou have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness.\\n\\nYou want to share the chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts, each piece consists of some consecutive chunks.\\n\\nBeing generous, you will eat the piece with the minimum total sweetness and give the other pieces to your friends.\\n\\nFind the maximum total sweetness of the piece you can get by cutting the chocolate bar optimally.\\n\\nExample 1:\\n\\nInput: sweetness = [1,2,3,4,5,6,7,8,9], K = 5\\nOutput: 6\\nExplanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]\\n\\n```\\n# point: looking for max value, then build a \"fail\" function,\\n# and use binary search to find the min \\'left\\' that let fail(left) return True.\\n# then, left-1 is the max value to let fail(left-1) return False (i.e., not_fail(left-1) is true)!\\nclass Solution_Leetcode1231(object):\\n    def maximizeSweetness(self, sweetness, K):\\n        # binary search method is for looking for the MIN value! so, we find the min value (left) that fail\\n        # then left-1 is the max value that success!\\n        # look for max value, find the min value that fail, and then min.value - 1 is the result of success\\n        \\n        left = min(sweetness)\\n        right = sum(sweetness)+ 1\\n        \\n        def fail(mid):\\n            pieces = 0\\n            cursum = 0\\n            for sweet in sweetness:\\n                cursum += sweet\\n                if cursum >= mid:\\n                    # then current piece is ensure to be >= mid, we can start a new piece\\n                    pieces += 1\\n                    cursum = 0\\n            return pieces < K+1\\n        \\n        while left < right:\\n            mid = left+ (right-left)//2\\n            if fail(mid): # the result \\'left\\' is the min value that let fail(left)=True!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1\\n```        \\n\\nhttps://leetcode.com/problems/split-array-largest-sum/\\n**410. Split Array Largest Sum**\\n\\nHard\\nGiven an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\\n\\nWrite an algorithm to minimize the largest sum among these m subarrays.\\n\\nExample 1:\\n\\nInput: nums = [7,2,5,10,8], m = 2\\nOutput: 18\\nExplanation:\\nThere are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8],\\nwhere the largest sum among the two subarrays is only 18.\\n\\'\\'\\'\\n```\\n# looking for a min value, then build a \\'isok\\' function and directly use binary search,\\n# to find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode410(object):\\n    def splitArray(self, nums, m):\\n        # binary search\\n        # make a guess and then check how many subarrays x; if x > m, the guess is too big; else, the guess is too small\\n        left = max(nums)\\n        right = sum(nums) + 1\\n        \\n        def isok(mid): # or, you can change \\'isok\\' name into \\'is_mid_too_big\\'\\n            # all subarray\\'s sum <= mid\\n            setcount = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num> mid:\\n                    setcount += 1\\n                    cursum = 0\\n                cursum += num\\n            return setcount <= m # this is <=, not >=! which is very important!\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid): # is_mid_too_big, and we do not have enough subset when separating under mid, so we should make mid smaller!\\n                # or, think extremelly, if mid=2**31-1, then all numbers are in one subset, 1 <= m, so we should make mid smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\nclass Solution_leetcode410_2(object):\\n    def splitArray(self, nums, m):\\n        # use binary search - it is finding the min value!\\n        # find the min sum value such that for the m sbusets of nums, sum of a subset <= x\\n        \\n        left = max(nums)\\n        right = sum(nums)\\n        \\n        def subsetnum(mid):\\n            setnum = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num > mid:  # \\u8F6C\\u6362\\u601D\\u60F3\\uFF1A\\u672C\\u6765\\u662F\\u7ED9\\u5B9Am\\u4E2A\\u5B50\\u96C6\\uFF0C\\u6C42\\u5F97\\u662F\\u5B50\\u96C6\\u548C\\u5F97\\u6700\\u5927\\u503C\\u3002\\n\\t\\t\\t\\t\\t# \\u6211\\u4EEC\\u53CD\\u8FC7\\u6765\\uFF0C\\u5148\\u6307\\u5B9A\\u5B50\\u96C6\\u7684\\u548C\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u7136\\u540E\\u53BB\\u53CD\\u63A8\\u80FD\\u80FD\\u591F\\u5206\\u6210\\u591A\\u5C11\\u4E2A\\u5B50\\u96C6\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570>m\\uFF0C\\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5C0F\\u4E86\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570< m, \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\n\\t\\t\\t\\t\\t# \\uFF08\\u8003\\u8651\\u731C\\u6D4B\\u4E3A\\u65E0\\u7A77\\u5927\\u7684\\u65F6\\u5019\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u4E00\\u4E2Asubset\\u5C31\\u53EF\\u4EE5\\u4E86\\uFF09=\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u53D8\\u5C0F\\u5B83\\n                    setnum += 1\\n                    cursum = 0\\n                cursum += num\\n            return setnum\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if subsetnum(mid) <= m: # \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF01\\u6211\\u4EEC\\u9700\\u8981\\u51CF\\u5C0Fmid! \\u8FD9\\u4E00\\u70B9\\u975E\\u5E38\\u91CD\\u8981!\\n                # extremely, if we guess mid = 2**31-1, then subsetnum(mid) = 1 \\n\\t\\t\\t\\t# (all elements are in one subset), this means that our guessing is too big\\n                # we can make it smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\'\\'\\'\\n\\n**1482. Minimum Number of Days to Make m Bouquets**\\n\\nhttps://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/\\nGiven an integer array bloomDay, an integer m and an integer k.\\n\\nWe need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\\n\\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\\n\\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\\n\\'\\'\\'\\n```\\nclass Solution_Leetcode1482:\\n    def minDays(self, bloomdays, m, k):\\n        # binary search method, seek for the min day, \\n        # guess a day, -> check how many bouquets \\u82B1\\u675F\\n        \\n        left = min(bloomdays)\\n        right = max(bloomdays) + 1\\n        \\n        def isgood(mid):\\n            count = 0\\n            cursum = 0\\n            for aday in bloomdays:\\n                if aday > mid:\\n                    cursum = 0 # reset to 0\\n                else:\\n                    cursum += 1\\n                    if cursum == k:\\n                        count += 1\\n                        cursum = 0 # need to reset cursum here!\\n            return count >= m\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isgood(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left if left <= max(bloomdays) else -1\\n```\\n\\n\\n**875. Koko Eating Bananas**\\nhttps://leetcode.com/problems/koko-eating-bananas/\\n\\nKoko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.\\n\\nKoko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour.\\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\\n\\nReturn the minimum integer K such that she can eat all the bananas within H hours.\\n```\\n\\nclass Solution_leetcode875(object):\\n    def minEatingSpeed(self, piles, H):\\n        # still, change the problem, binary search,\\n        # guess the target value and compute how many banana koko can eat -> min speed\\n        left = 1\\n        right = max(piles) + 1\\n        \\n        def caneatall(mid): # isok(mid)\\n            # hours cost really should <=H\\n            hours = 0\\n            for pile in piles:\\n                hours += math.ceil(pile/float(mid)) \\n                # do not work if we use pile/mid!!! should change int into float!! this is very important!\\n            return hours <= H\\n        \\n        while left < right:\\n            mid = left + (right - left)//2\\n            if caneatall(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left # the min speed that satisfies caneatall(left)\\n```\\n\\n\\nGo back to finding max value again, using binary search!\\n\\n**1552. Magnetic Force Between Two Balls**\\nhttps://leetcode.com/problems/magnetic-force-between-two-balls/\\n\\nIn universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\\n\\nRick stated that magnetic force between two different balls at positions x and y is |x - y|.\\n\\nGiven the integer array position and the integer m. Return the required force.\\n```\\nclass Solution_Leetcode1552:\\n    def maxDistance(self, position, m):\\n        n = len(position)\\n        position.sort()\\n        \\n        def isfail(mid):\\n            ans = 1\\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\\n            for i in range(1, n):\\n                if position[i] - curr >= mid:\\n                    ans += 1\\n                    curr = position[i]\\n            return ans < m\\n        \\n        left = 0 # \\u6CE8\\u610F\\uFF0C\\u4E0D\\u5E94\\u8BE5\\u628Aleft\\u8D4B\\u503C\\u4E3Amin(position)! \\u56E0\\u4E3A\\u6211\\u4EEC\\u6C42\\u5F97\\u662Fdistance!\\n        # note that, left = min(position) is wrong, since we are looking for \\'distance\\'!\\n        right = max(position) - min(position) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isfail(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1 # left is the min value to fail, so left-1 is the max value to succeed!\\n        # \\u56E0\\u4E3A\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF01\\u6240\\u4EE5\\u9700\\u8981\\u5DE7\\u5999\\u4F7F\\u7528binary search!\\n```",
                "solutionTags": [],
                "code": "```\\n# # looking for a min value, then build a \\'isok\\' function and directly use binary search to \\n# find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode1011:\\n    def shipWithinDays(self, weights, D):\\n        # binary search\\n        # min weight capacity of the ship\\n        \\n        def isok(mid):\\n            # real days needed with max weight capacity of mid\\n            day = 1\\n            cursum = 0\\n            for weight in weights:\\n                if cursum + weight > mid:\\n                    day += 1\\n                    cursum = 0\\n                cursum += weight\\n            return day <= D\\n        \\n        left = max(weights) # note that this should be max(weights), not min(weights)!!\\n        right = sum(weights) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\n# point: looking for max value, then build a \"fail\" function,\\n# and use binary search to find the min \\'left\\' that let fail(left) return True.\\n# then, left-1 is the max value to let fail(left-1) return False (i.e., not_fail(left-1) is true)!\\nclass Solution_Leetcode1231(object):\\n    def maximizeSweetness(self, sweetness, K):\\n        # binary search method is for looking for the MIN value! so, we find the min value (left) that fail\\n        # then left-1 is the max value that success!\\n        # look for max value, find the min value that fail, and then min.value - 1 is the result of success\\n        \\n        left = min(sweetness)\\n        right = sum(sweetness)+ 1\\n        \\n        def fail(mid):\\n            pieces = 0\\n            cursum = 0\\n            for sweet in sweetness:\\n                cursum += sweet\\n                if cursum >= mid:\\n                    # then current piece is ensure to be >= mid, we can start a new piece\\n                    pieces += 1\\n                    cursum = 0\\n            return pieces < K+1\\n        \\n        while left < right:\\n            mid = left+ (right-left)//2\\n            if fail(mid): # the result \\'left\\' is the min value that let fail(left)=True!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1\\n```\n```\\n# looking for a min value, then build a \\'isok\\' function and directly use binary search,\\n# to find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode410(object):\\n    def splitArray(self, nums, m):\\n        # binary search\\n        # make a guess and then check how many subarrays x; if x > m, the guess is too big; else, the guess is too small\\n        left = max(nums)\\n        right = sum(nums) + 1\\n        \\n        def isok(mid): # or, you can change \\'isok\\' name into \\'is_mid_too_big\\'\\n            # all subarray\\'s sum <= mid\\n            setcount = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num> mid:\\n                    setcount += 1\\n                    cursum = 0\\n                cursum += num\\n            return setcount <= m # this is <=, not >=! which is very important!\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid): # is_mid_too_big, and we do not have enough subset when separating under mid, so we should make mid smaller!\\n                # or, think extremelly, if mid=2**31-1, then all numbers are in one subset, 1 <= m, so we should make mid smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\nclass Solution_leetcode410_2(object):\\n    def splitArray(self, nums, m):\\n        # use binary search - it is finding the min value!\\n        # find the min sum value such that for the m sbusets of nums, sum of a subset <= x\\n        \\n        left = max(nums)\\n        right = sum(nums)\\n        \\n        def subsetnum(mid):\\n            setnum = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num > mid:  # \\u8F6C\\u6362\\u601D\\u60F3\\uFF1A\\u672C\\u6765\\u662F\\u7ED9\\u5B9Am\\u4E2A\\u5B50\\u96C6\\uFF0C\\u6C42\\u5F97\\u662F\\u5B50\\u96C6\\u548C\\u5F97\\u6700\\u5927\\u503C\\u3002\\n\\t\\t\\t\\t\\t# \\u6211\\u4EEC\\u53CD\\u8FC7\\u6765\\uFF0C\\u5148\\u6307\\u5B9A\\u5B50\\u96C6\\u7684\\u548C\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u7136\\u540E\\u53BB\\u53CD\\u63A8\\u80FD\\u80FD\\u591F\\u5206\\u6210\\u591A\\u5C11\\u4E2A\\u5B50\\u96C6\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570>m\\uFF0C\\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5C0F\\u4E86\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570< m, \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\n\\t\\t\\t\\t\\t# \\uFF08\\u8003\\u8651\\u731C\\u6D4B\\u4E3A\\u65E0\\u7A77\\u5927\\u7684\\u65F6\\u5019\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u4E00\\u4E2Asubset\\u5C31\\u53EF\\u4EE5\\u4E86\\uFF09=\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u53D8\\u5C0F\\u5B83\\n                    setnum += 1\\n                    cursum = 0\\n                cursum += num\\n            return setnum\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if subsetnum(mid) <= m: # \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF01\\u6211\\u4EEC\\u9700\\u8981\\u51CF\\u5C0Fmid! \\u8FD9\\u4E00\\u70B9\\u975E\\u5E38\\u91CD\\u8981!\\n                # extremely, if we guess mid = 2**31-1, then subsetnum(mid) = 1 \\n\\t\\t\\t\\t# (all elements are in one subset), this means that our guessing is too big\\n                # we can make it smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\nclass Solution_Leetcode1482:\\n    def minDays(self, bloomdays, m, k):\\n        # binary search method, seek for the min day, \\n        # guess a day, -> check how many bouquets \\u82B1\\u675F\\n        \\n        left = min(bloomdays)\\n        right = max(bloomdays) + 1\\n        \\n        def isgood(mid):\\n            count = 0\\n            cursum = 0\\n            for aday in bloomdays:\\n                if aday > mid:\\n                    cursum = 0 # reset to 0\\n                else:\\n                    cursum += 1\\n                    if cursum == k:\\n                        count += 1\\n                        cursum = 0 # need to reset cursum here!\\n            return count >= m\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isgood(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left if left <= max(bloomdays) else -1\\n```\n```\\n\\nclass Solution_leetcode875(object):\\n    def minEatingSpeed(self, piles, H):\\n        # still, change the problem, binary search,\\n        # guess the target value and compute how many banana koko can eat -> min speed\\n        left = 1\\n        right = max(piles) + 1\\n        \\n        def caneatall(mid): # isok(mid)\\n            # hours cost really should <=H\\n            hours = 0\\n            for pile in piles:\\n                hours += math.ceil(pile/float(mid)) \\n                # do not work if we use pile/mid!!! should change int into float!! this is very important!\\n            return hours <= H\\n        \\n        while left < right:\\n            mid = left + (right - left)//2\\n            if caneatall(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left # the min speed that satisfies caneatall(left)\\n```\n```\\nclass Solution_Leetcode1552:\\n    def maxDistance(self, position, m):\\n        n = len(position)\\n        position.sort()\\n        \\n        def isfail(mid):\\n            ans = 1\\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\\n            for i in range(1, n):\\n                if position[i] - curr >= mid:\\n                    ans += 1\\n                    curr = position[i]\\n            return ans < m\\n        \\n        left = 0 # \\u6CE8\\u610F\\uFF0C\\u4E0D\\u5E94\\u8BE5\\u628Aleft\\u8D4B\\u503C\\u4E3Amin(position)! \\u56E0\\u4E3A\\u6211\\u4EEC\\u6C42\\u5F97\\u662Fdistance!\\n        # note that, left = min(position) is wrong, since we are looking for \\'distance\\'!\\n        right = max(position) - min(position) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isfail(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1 # left is the min value to fail, so left-1 is the max value to succeed!\\n        # \\u56E0\\u4E3A\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF01\\u6240\\u4EE5\\u9700\\u8981\\u5DE7\\u5999\\u4F7F\\u7528binary search!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707611,
                "title": "python-binary-search-mathematical-function-definition-75-speed",
                "content": "Here the checker function is a function of `day`(days passed) and returns the number of bouquets possible.\\n\\n`checker(day)` is an increasing function because the bouquets possible increase or stay the same with every passing day.\\nIf on a day `d` the checker returns `True`, it means that on day `d`, minimum `m` bouquets are possible to be made, so we need no check for `days > d` and hence `high=mid`\\nOtherwise, on a day `d` if the checker returns `False`, it means that for `days <= d`, the `bouquets count <m` hence, we need to check for days `d+1 onwards`, hence `low=d+1`\\n\\n**Time Complexity**: O(n logn)\\n```\\nclass Solution:\\n    def checker(self,arr, d, m, k) -> bool:\\n        \\'\\'\\'\\n        d -> days\\n        m -> bouquets\\n        k -> adjacent flowers\\n        \\n        return bool\\n        \\'\\'\\'\\n        arr = [10**9] + arr + [10**9] #appending array with maximum values\\n        idx = []\\n        for i in range(len(arr)):\\n            if arr[i] > d:\\n                idx.append(i)\\n        cnt = 0\\n        for i in range(len(idx)-1):\\n            # how many bouquet can we make out of an interval of valid flowers \\n            cnt += (idx[i+1] - idx[i] - 1) // k\\n        \\n        # return if count >= m\\n        return cnt >= m\\n\\n    def minDays(self, arr: List[int], m: int, k: int) -> int:\\n        if m*k > len(arr):\\n            return -1\\n        lo, hi = 1, max(arr)\\n        \\n        while(hi >= lo):\\n            mid = (hi+lo)//2\\n            if(self.checker(arr, mid, m, k) == True):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n            if(hi == lo): break\\n    \\n        if self.checker(arr, lo, m, k):\\n            return lo\\n        else:\\n            return hi\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checker(self,arr, d, m, k) -> bool:\\n        \\'\\'\\'\\n        d -> days\\n        m -> bouquets\\n        k -> adjacent flowers\\n        \\n        return bool\\n        \\'\\'\\'\\n        arr = [10**9] + arr + [10**9] #appending array with maximum values\\n        idx = []\\n        for i in range(len(arr)):\\n            if arr[i] > d:\\n                idx.append(i)\\n        cnt = 0\\n        for i in range(len(idx)-1):\\n            # how many bouquet can we make out of an interval of valid flowers \\n            cnt += (idx[i+1] - idx[i] - 1) // k\\n        \\n        # return if count >= m\\n        return cnt >= m\\n\\n    def minDays(self, arr: List[int], m: int, k: int) -> int:\\n        if m*k > len(arr):\\n            return -1\\n        lo, hi = 1, max(arr)\\n        \\n        while(hi >= lo):\\n            mid = (hi+lo)//2\\n            if(self.checker(arr, mid, m, k) == True):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n            if(hi == lo): break\\n    \\n        if self.checker(arr, lo, m, k):\\n            return lo\\n        else:\\n            return hi\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 686698,
                "title": "java-simple-binary-search",
                "content": "Similar with coco eat bnana and shipping  goods problems.\\nVery easy to think of binary search.\\nMake sure to use:\\n1,  early quit when k * m > n;\\n2,  int mid = l + (r - l) / 2 avoid Integer overflow\\n3,  corner case if (m == 0) return 0;\\n```\\nclass Solution {\\n    public int minDays(int[] bs, int m, int k) {\\n        if (m == 0) return 0;\\n        int n = bs.length, l = Integer.MAX_VALUE, r = Integer.MIN_VALUE;\\n        if (k * m > n) return -1;\\n        for (int i : bs) {\\n            l = Math.min(l, i);\\n            r = Math.max(r, i);\\n        }\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (canMake(bs, mid, k) >= m) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int canMake(int[] bs, int mid, int k) {\\n        int res = 0;\\n        for (int cnt = 0, i = 0; i < bs.length; i++) {\\n            if (bs[i] <= mid) cnt++; \\n            else cnt = 0;\\n            if (cnt >= k) {\\n                res++;\\n                cnt = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bs, int m, int k) {\\n        if (m == 0) return 0;\\n        int n = bs.length, l = Integer.MAX_VALUE, r = Integer.MIN_VALUE;\\n        if (k * m > n) return -1;\\n        for (int i : bs) {\\n            l = Math.min(l, i);\\n            r = Math.max(r, i);\\n        }\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (canMake(bs, mid, k) >= m) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int canMake(int[] bs, int mid, int k) {\\n        int res = 0;\\n        for (int cnt = 0, i = 0; i < bs.length; i++) {\\n            if (bs[i] <= mid) cnt++; \\n            else cnt = 0;\\n            if (cnt >= k) {\\n                res++;\\n                cnt = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686655,
                "title": "merge-interval-nlogn-easy-to-understand-not-a-binary-search",
                "content": "The idea is simple. Every time a flower is bloomed, it will connect the blooming flowers before and after it. Try to merge the blooming interval and keep track of how many available bonquets.\\n\\nPlease read the code for details.\\n\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m * k > len(bloomDay):\\n            return -1\\n        \\n        # an interval is a consecutive region of flowers\\n\\t\\t# intervals[i] means the other end of an interval, and one of its end is i.\\n\\t\\t# -1 means this is not the end of an interval.\\n        intervals = [-1] * len(bloomDay)\\n        \\n        ## sort the index based on blooming time\\n        bloom_order = sorted(enumerate(bloomDay), key=lambda x: x[1])\\n        ## number of available bonquets\\n        count = 0\\n        \\n        for i, timestamp in bloom_order:\\n            ## the change of #bonquets in this iteration\\n            delta_count = 0\\n            # the new interval generated by this bloom\\n            head = tail = i\\n            # extend the head\\n            if i > 0 and intervals[i-1] != -1:\\n                head = intervals[i-1]\\n                intervals[i-1] = -1\\n                # #bonquets from [head, i-1]\\n                delta_count -= (i - head) // k\\n            \\n            # extend the tail\\n            if i < len(bloomDay) - 1 and intervals[i+1] != -1:\\n                tail = intervals[i+1]\\n                intervals[i+1] = -1\\n                # #bonquets from [i+1, tail]\\n                delta_count -= (tail - i) // k\\n                \\n            # #bonquets from the new interval\\n            delta_count += (tail - head + 1) // k\\n            # update the interval array\\n            intervals[head] = tail\\n            intervals[tail] = head\\n            # update the available bonquets\\n            count += delta_count\\n            \\n            if count >= m:\\n                return timestamp\\n        return -1\\n            \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m * k > len(bloomDay):\\n            return -1\\n        \\n        # an interval is a consecutive region of flowers\\n\\t\\t# intervals[i] means the other end of an interval, and one of its end is i.\\n\\t\\t# -1 means this is not the end of an interval.\\n        intervals = [-1] * len(bloomDay)\\n        \\n        ## sort the index based on blooming time\\n        bloom_order = sorted(enumerate(bloomDay), key=lambda x: x[1])\\n        ## number of available bonquets\\n        count = 0\\n        \\n        for i, timestamp in bloom_order:\\n            ## the change of #bonquets in this iteration\\n            delta_count = 0\\n            # the new interval generated by this bloom\\n            head = tail = i\\n            # extend the head\\n            if i > 0 and intervals[i-1] != -1:\\n                head = intervals[i-1]\\n                intervals[i-1] = -1\\n                # #bonquets from [head, i-1]\\n                delta_count -= (i - head) // k\\n            \\n            # extend the tail\\n            if i < len(bloomDay) - 1 and intervals[i+1] != -1:\\n                tail = intervals[i+1]\\n                intervals[i+1] = -1\\n                # #bonquets from [i+1, tail]\\n                delta_count -= (tail - i) // k\\n                \\n            # #bonquets from the new interval\\n            delta_count += (tail - head + 1) // k\\n            # update the interval array\\n            intervals[head] = tail\\n            intervals[tail] = head\\n            # update the available bonquets\\n            count += delta_count\\n            \\n            if count >= m:\\n                return timestamp\\n        return -1\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 686436,
                "title": "c-binary-search-with-brief-explanation",
                "content": "The max number of days we can wait is  = maximum value of days required to bloom flower in given input. \\nWhile minimum days = minimum value required to bloom flower. \\nOur task is to find the minimum number of days so that we have sufficient flowers to form required bouquets.\\n\\nSo, We do binary search from 0 to max to find the minimum number of days that gives sufficient m group of k consecutive flowers.\\n\\n```csharp\\npublic int MinDays(int[] bloomDay, int m, int k)\\n{\\n\\tint flowersRequired = m * k;\\n\\tint flowersAvailable = bloomDay.Length;\\n\\n\\tif (flowersAvailable < flowersRequired)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint min = int.MaxValue;\\n\\tint max = int.MinValue;\\n\\tforeach(var flower in bloomDay)\\n\\t{\\n\\t\\tmin = Math.Min(min, flower);\\n\\t\\tmax = Math.Max(max, flower);\\n\\t}\\n\\n\\tint low = min;\\n\\tint high = max;\\n\\n\\twhile (low < high)\\n\\t{\\n\\t\\tint mid = low + (high - low) / 2;\\n\\n\\t\\tint currentBlooomed = 0;\\n\\t\\tint bouquets = 0;\\n\\n\\t\\tforeach (var flower in bloomDay)\\n\\t\\t{\\n\\t\\t\\tif (flower <= mid)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (currentBlooomed == k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed = 0;\\n\\t\\t\\t\\tbouquets++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (bouquets >= m)\\n\\t\\t{\\n\\t\\t\\thigh = mid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn low;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinDays(int[] bloomDay, int m, int k)\\n{\\n\\tint flowersRequired = m * k;\\n\\tint flowersAvailable = bloomDay.Length;\\n\\n\\tif (flowersAvailable < flowersRequired)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint min = int.MaxValue;\\n\\tint max = int.MinValue;\\n\\tforeach(var flower in bloomDay)\\n\\t{\\n\\t\\tmin = Math.Min(min, flower);\\n\\t\\tmax = Math.Max(max, flower);\\n\\t}\\n\\n\\tint low = min;\\n\\tint high = max;\\n\\n\\twhile (low < high)\\n\\t{\\n\\t\\tint mid = low + (high - low) / 2;\\n\\n\\t\\tint currentBlooomed = 0;\\n\\t\\tint bouquets = 0;\\n\\n\\t\\tforeach (var flower in bloomDay)\\n\\t\\t{\\n\\t\\t\\tif (flower <= mid)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (currentBlooomed == k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurrentBlooomed = 0;\\n\\t\\t\\t\\tbouquets++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (bouquets >= m)\\n\\t\\t{\\n\\t\\t\\thigh = mid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn low;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686388,
                "title": "python3-binary-search",
                "content": "(1428ms, 91.90%)\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m*k: return -1 # edge case \\n        \\n        def fn(d):\\n            \"\"\"Return True if it is possible to make m bouquets on given day.\"\"\"\\n            mm, kk = m, k\\n            for x in bloomDay: \\n                kk = kk-1 if x <= d else k\\n                if not kk: mm, kk = mm-1, k\\n                if not mm: return True\\n            return False \\n        \\n        # \"first true\" binary search\\n        lo, hi = 0, max(bloomDay)\\n        while lo < hi:\\n            mid = lo + hi >> 1\\n            if fn(mid): hi = mid\\n            else: lo = mid + 1\\n        return lo  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m*k: return -1 # edge case \\n        \\n        def fn(d):\\n            \"\"\"Return True if it is possible to make m bouquets on given day.\"\"\"\\n            mm, kk = m, k\\n            for x in bloomDay: \\n                kk = kk-1 if x <= d else k\\n                if not kk: mm, kk = mm-1, k\\n                if not mm: return True\\n            return False \\n        \\n        # \"first true\" binary search\\n        lo, hi = 0, max(bloomDay)\\n        while lo < hi:\\n            mid = lo + hi >> 1\\n            if fn(mid): hi = mid\\n            else: lo = mid + 1\\n        return lo  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 686379,
                "title": "java-two-solutions-dp-binary-search-solutions",
                "content": "At first glance, I was determined that was a DP problem. So I wrote the following first solution. But to my surprise it was TLE at the last test case. \\n\\nThe time complexity is ```O(N^2)```. I personally think Leetcode should let this solution pass. The test cases seems too strict. I really spent quite some time on this problem during the contest.\\n\\n```\\n    int[][] memo;\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        memo = new int[n + 1][m + 1];\\n        int[] max = new int[n + 1];\\n        for (int i = 0; i <= n - k; i++) {\\n            for (int j = i; j < i + k; j++) {\\n                max[i] = Math.max(max[i], bloomDay[j]);\\n            }\\n        }\\n        return dp(bloomDay, m, k, 0, max);\\n    }\\n    \\n    private int dp(int[] A, int m, int k, int start, int[] max) {\\n        if (m == 0) return 0;\\n        if (memo[start][m] != 0) return memo[start][m];\\n        int n = A.length;\\n        if (n - start < m * k) {\\n            memo[start][m] = -1;\\n            return -1;\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int i = start; i <= n - m * k; i++) {\\n            int c = max[i];\\n            res = Math.min(res, Math.max(c, dp(A, m - 1, k, i + k, max)));\\n        }\\n        memo[start][m] = res;\\n        return res;\\n    }\\n```\\n\\n\\nSo what\\'s better than ```O(N^2)``` ? Cloest one is ```O(NlogN)```. It took me a while to come up with using binary seach to find the answer. \\n\\n```\\n    public int minDays(int[] A, int m, int k) {\\n        // binary search answer\\n        int l = Integer.MAX_VALUE, r = 0;\\n        int n = A.length;\\n        if (n < m * k) return -1;\\n        for (int i = 0; i < A.length; i++) {\\n            l = Math.min(l, A[i]);\\n            r = Math.max(r, A[i]);\\n        }\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (helper(A, m, k, mid)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    private boolean helper(int[] A, int m, int k, int t) {\\n        int n = A.length;\\n        for (int i = 0; i <= n - k; i++) {\\n            if (A[i] > t) continue;\\n            int c = i;\\n            while (c < i + k) {\\n                if (A[c] > t) break;\\n                c++;\\n            }\\n            if (c == i + k) m--;\\n            i = c - 1;\\n        }\\n        return m <= 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```O(N^2)```\n```\\n    int[][] memo;\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        memo = new int[n + 1][m + 1];\\n        int[] max = new int[n + 1];\\n        for (int i = 0; i <= n - k; i++) {\\n            for (int j = i; j < i + k; j++) {\\n                max[i] = Math.max(max[i], bloomDay[j]);\\n            }\\n        }\\n        return dp(bloomDay, m, k, 0, max);\\n    }\\n    \\n    private int dp(int[] A, int m, int k, int start, int[] max) {\\n        if (m == 0) return 0;\\n        if (memo[start][m] != 0) return memo[start][m];\\n        int n = A.length;\\n        if (n - start < m * k) {\\n            memo[start][m] = -1;\\n            return -1;\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int i = start; i <= n - m * k; i++) {\\n            int c = max[i];\\n            res = Math.min(res, Math.max(c, dp(A, m - 1, k, i + k, max)));\\n        }\\n        memo[start][m] = res;\\n        return res;\\n    }\\n```\n```O(N^2)```\n```O(NlogN)```",
                "codeTag": "Unknown"
            },
            {
                "id": 686252,
                "title": "javascript-sort-union-find",
                "content": "```javascript\\nconst BLOOMED = \\'X\\';\\n/**\\n * @param {number[]} bloomDay\\n * @param {number} m\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDays = function(bloomDay, m, k) {\\n    if ((m * k) > bloomDay.length) return -1;\\n    \\n    const unionFind = bloomDay.map((_, idx) => idx);\\n    const daysAndIndexes = bloomDay.map((day, idx) => ({ day, idx }));\\n    daysAndIndexes.sort((a,b) => a.day - b.day);\\n    \\n    \\n    if (k === 1) return daysAndIndexes[m - 1].day;\\n    \\n    const find = (x) => unionFind[x] = unionFind[x] === x ? x : find(unionFind[x]);\\n    const union = (x, y) => unionFind[find(x)] = find(y);\\n    \\n    const map = {};\\n    let totalBouquets = 0;\\n    for (let { day, idx } of daysAndIndexes) {\\n        bloomDay[idx] = BLOOMED;\\n        map[idx] = { numFlowers: 1, numBouquetsInGroup: 0 };\\n        \\n        let totalPrevBouquets = 0;\\n        for (let delta of [1, -1]) {\\n            if (bloomDay[idx + delta] === BLOOMED) {\\n                const root = find(idx + delta);\\n                union(root, idx);\\n                map[idx].numFlowers += map[root].numFlowers;\\n                totalPrevBouquets += map[root].numBouquetsInGroup;\\n            }\\n        }\\n        \\n        map[idx].numBouquetsInGroup = Math.floor(map[idx].numFlowers / k);\\n        if (map[idx].numBouquetsInGroup > totalPrevBouquets) totalBouquets++;\\n        \\n        if (totalBouquets === m) return day;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst BLOOMED = \\'X\\';\\n/**\\n * @param {number[]} bloomDay\\n * @param {number} m\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDays = function(bloomDay, m, k) {\\n    if ((m * k) > bloomDay.length) return -1;\\n    \\n    const unionFind = bloomDay.map((_, idx) => idx);\\n    const daysAndIndexes = bloomDay.map((day, idx) => ({ day, idx }));\\n    daysAndIndexes.sort((a,b) => a.day - b.day);\\n    \\n    \\n    if (k === 1) return daysAndIndexes[m - 1].day;\\n    \\n    const find = (x) => unionFind[x] = unionFind[x] === x ? x : find(unionFind[x]);\\n    const union = (x, y) => unionFind[find(x)] = find(y);\\n    \\n    const map = {};\\n    let totalBouquets = 0;\\n    for (let { day, idx } of daysAndIndexes) {\\n        bloomDay[idx] = BLOOMED;\\n        map[idx] = { numFlowers: 1, numBouquetsInGroup: 0 };\\n        \\n        let totalPrevBouquets = 0;\\n        for (let delta of [1, -1]) {\\n            if (bloomDay[idx + delta] === BLOOMED) {\\n                const root = find(idx + delta);\\n                union(root, idx);\\n                map[idx].numFlowers += map[root].numFlowers;\\n                totalPrevBouquets += map[root].numBouquetsInGroup;\\n            }\\n        }\\n        \\n        map[idx].numBouquetsInGroup = Math.floor(map[idx].numFlowers / k);\\n        if (map[idx].numBouquetsInGroup > totalPrevBouquets) totalBouquets++;\\n        \\n        if (totalBouquets === m) return day;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953250,
                "title": "java-binary-search-easy-to-untderstand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        long val=(long)m*k;\\n        if( val > bloomDay.length) return -1;\\n\\n        int low=Integer.MAX_VALUE;\\n        int high=Integer.MIN_VALUE;\\n\\n        for(int i=0;i<bloomDay.length;i++){\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(possibleDays(bloomDay,m,k,mid)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n           \\n        }\\n        return low;\\n\\n\\n    }\\n\\n    public boolean possibleDays(int[] bloomDay, int m, int k,int mid){\\n        \\n        int totalBouquet=0;\\n        int window=0;\\n        for(int i=0;i<bloomDay.length;i++){\\n            if(bloomDay[i]<=mid){\\n                window++;\\n            }\\n            else{\\n                totalBouquet+=(window/k);\\n                window=0;\\n\\n            }\\n        }\\n\\n        totalBouquet+=(window/k);\\n        return totalBouquet>=m;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        long val=(long)m*k;\\n        if( val > bloomDay.length) return -1;\\n\\n        int low=Integer.MAX_VALUE;\\n        int high=Integer.MIN_VALUE;\\n\\n        for(int i=0;i<bloomDay.length;i++){\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }\\n\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n\\n            if(possibleDays(bloomDay,m,k,mid)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n           \\n        }\\n        return low;\\n\\n\\n    }\\n\\n    public boolean possibleDays(int[] bloomDay, int m, int k,int mid){\\n        \\n        int totalBouquet=0;\\n        int window=0;\\n        for(int i=0;i<bloomDay.length;i++){\\n            if(bloomDay[i]<=mid){\\n                window++;\\n            }\\n            else{\\n                totalBouquet+=(window/k);\\n                window=0;\\n\\n            }\\n        }\\n\\n        totalBouquet+=(window/k);\\n        return totalBouquet>=m;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928859,
                "title": "c-interesting-approach-binary-search",
                "content": "\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\nbool canMake(vector<int>&v, int mid, int m, int k ){ \\n    long long bc=0, adcnt=0;\\n    for(int i=0; i<v.size(); i++){\\n        if(v[i]<=mid){\\n            adcnt++;\\n            if(adcnt==k){\\n                bc++;\\n                if(bc==m)return true;\\n                adcnt=0;\\n            }\\n        }\\n        else adcnt=0;\\n    } \\n    return false;\\n}\\n\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 1, e = *max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(canMake(bloomDay, mid, m, k)){\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else s = mid+1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nbool canMake(vector<int>&v, int mid, int m, int k ){ \\n    long long bc=0, adcnt=0;\\n    for(int i=0; i<v.size(); i++){\\n        if(v[i]<=mid){\\n            adcnt++;\\n            if(adcnt==k){\\n                bc++;\\n                if(bc==m)return true;\\n                adcnt=0;\\n            }\\n        }\\n        else adcnt=0;\\n    } \\n    return false;\\n}\\n\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 1, e = *max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(canMake(bloomDay, mid, m, k)){\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else s = mid+1;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926687,
                "title": "c-easiest-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int solve(int mid,vector<int>&bloomDay,int k){\\n       int ct=0;\\n       int n=bloomDay.size();\\n       int total=0;\\n       for(int i=0;i<n;i++){\\n           if(mid>=bloomDay[i]){\\n               ct++;\\n               if(ct==k){\\n                   total++;ct=0;\\n               }\\n           }else ct=0;\\n       }\\n\\n       return total;\\n\\n   }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        if(m>n/k)return -1;\\n\\n        int i=1,j=INT_MIN;\\n        for(int k=0;k<n;k++)j=max(j,bloomDay[k]);\\n        int mid;\\n        int ans=INT_MAX;\\n        while(i<=j){\\n            mid=i+(j-i)/2;\\n            if(solve(mid,bloomDay,k)>=m){\\n               ans=min(ans,mid);\\n               j=mid-1;\\n            }else i=mid+1;\\n        }\\n\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int solve(int mid,vector<int>&bloomDay,int k){\\n       int ct=0;\\n       int n=bloomDay.size();\\n       int total=0;\\n       for(int i=0;i<n;i++){\\n           if(mid>=bloomDay[i]){\\n               ct++;\\n               if(ct==k){\\n                   total++;ct=0;\\n               }\\n           }else ct=0;\\n       }\\n\\n       return total;\\n\\n   }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n=bloomDay.size();\\n        if(m>n/k)return -1;\\n\\n        int i=1,j=INT_MIN;\\n        for(int k=0;k<n;k++)j=max(j,bloomDay[k]);\\n        int mid;\\n        int ans=INT_MAX;\\n        while(i<=j){\\n            mid=i+(j-i)/2;\\n            if(solve(mid,bloomDay,k)>=m){\\n               ans=min(ans,mid);\\n               j=mid-1;\\n            }else i=mid+1;\\n        }\\n\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924003,
                "title": "binary-search-easy-c-solution-best-optimal-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int flower(vector<int>& b, int day, int k) {\\n        int flow = 0;\\n        int count = 0;\\n        for (int i = 0; i < b.size(); i++) {\\n            if (b[i] <= day) {\\n                count++;\\n                if (count == k) {\\n                    flow++;\\n                    count = 0; // Reset count after reaching k consecutive flowers\\n                }\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        return flow;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (m > bloomDay.size() / k) return -1;\\n        int low = INT_MAX;\\n        int high = INT_MIN;\\n        for (auto i : bloomDay) {\\n            low = min(low, i);\\n            high = max(high, i);\\n        }\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2; // Avoid potential integer overflow\\n            if (flower(bloomDay, mid, k) >= m) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int flower(vector<int>& b, int day, int k) {\\n        int flow = 0;\\n        int count = 0;\\n        for (int i = 0; i < b.size(); i++) {\\n            if (b[i] <= day) {\\n                count++;\\n                if (count == k) {\\n                    flow++;\\n                    count = 0; // Reset count after reaching k consecutive flowers\\n                }\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        return flow;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if (m > bloomDay.size() / k) return -1;\\n        int low = INT_MAX;\\n        int high = INT_MIN;\\n        for (auto i : bloomDay) {\\n            low = min(low, i);\\n            high = max(high, i);\\n        }\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2; // Avoid potential integer overflow\\n            if (flower(bloomDay, mid, k) >= m) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804431,
                "title": "best-easy-c-solution-striver-based-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(vector<int>& bloomDay, int m, int k,int mid)\\n{\\n    int cnt=0;\\n    int no=0;//no of bouquets formes\\n    for(int i=0;i<bloomDay.size();i++)\\n    {\\n        if(bloomDay[i]<=mid)\\n        {\\n            cnt++;\\n        }\\n        else\\n        {\\n            no+=cnt/k;\\n            cnt=0;\\n        }\\n    }\\n    no+=cnt/k;\\n    return no>=m;\\n}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        long long val=1LL*m*k;\\n        if(val>bloomDay.size())return -1;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n               mini=min(mini,bloomDay[i]);\\n               maxi=max(maxi,bloomDay[i]);\\n        }\\n        int l=mini;\\n        int h=maxi;\\n        int ans=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            if(check(bloomDay,m,k,mid))\\n           {\\n               ans=mid;\\n               h=mid-1;\\n           }\\n           else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(vector<int>& bloomDay, int m, int k,int mid)\\n{\\n    int cnt=0;\\n    int no=0;//no of bouquets formes\\n    for(int i=0;i<bloomDay.size();i++)\\n    {\\n        if(bloomDay[i]<=mid)\\n        {\\n            cnt++;\\n        }\\n        else\\n        {\\n            no+=cnt/k;\\n            cnt=0;\\n        }\\n    }\\n    no+=cnt/k;\\n    return no>=m;\\n}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        long long val=1LL*m*k;\\n        if(val>bloomDay.size())return -1;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n               mini=min(mini,bloomDay[i]);\\n               maxi=max(maxi,bloomDay[i]);\\n        }\\n        int l=mini;\\n        int h=maxi;\\n        int ans=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            if(check(bloomDay,m,k,mid))\\n           {\\n               ans=mid;\\n               h=mid-1;\\n           }\\n           else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778738,
                "title": "striver-s-solution",
                "content": "# Complexity\\n- Time complexity : $$O(N$$ $$log(range))$$  , where range = maxEle - minEle + 1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(1ll*m*k > 1ll*n) return -1;\\n\\n        int low = *min_element(begin(bloomDay),end(bloomDay));\\n        int high = *max_element(begin(bloomDay),end(bloomDay));\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(bloomDay,mid,m,k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n\\n    bool isPossible(vector<int>& bloomDay, int mid, int m, int k) {\\n        int cnt=0 , curr=0;\\n        for(int i=0 ; i<bloomDay.size() ; i++) {\\n            if(mid >= bloomDay[i]) {\\n                curr++;\\n            }\\n            else {\\n                cnt += curr/k;\\n                curr = 0;\\n            }\\n        }\\n        cnt += curr/k;\\n        return cnt>=m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(1ll*m*k > 1ll*n) return -1;\\n\\n        int low = *min_element(begin(bloomDay),end(bloomDay));\\n        int high = *max_element(begin(bloomDay),end(bloomDay));\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(bloomDay,mid,m,k)) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n\\n    bool isPossible(vector<int>& bloomDay, int mid, int m, int k) {\\n        int cnt=0 , curr=0;\\n        for(int i=0 ; i<bloomDay.size() ; i++) {\\n            if(mid >= bloomDay[i]) {\\n                curr++;\\n            }\\n            else {\\n                cnt += curr/k;\\n                curr = 0;\\n            }\\n        }\\n        cnt += curr/k;\\n        return cnt>=m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720429,
                "title": "binary-search-on-answer",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int mid, vector<int> &nums, int m, int k)\\n{\\n    int req = 0;\\n    int count = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (nums[i] <= mid)\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            req += (count / k);\\n            count = 0;\\n        }\\n    }\\n    req += (count / k);\\n    return req >= m;\\n}\\n\\nint minDays(vector<int> &nums, int m, int k)\\n{\\n    int n = nums.size();\\n    // if (m * k > n)\\n    // {\\n    //     return -1;\\n    // }\\n\\n    int lb = 0;\\n    int ub = *max_element(nums.begin(), nums.end());\\n    int ans = -1;\\n\\n    while (lb <= ub)\\n    {\\n        int mid = lb + (ub - lb) / 2;\\n        if (isValid(mid, nums, m, k))\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int mid, vector<int> &nums, int m, int k)\\n{\\n    int req = 0;\\n    int count = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (nums[i] <= mid)\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            req += (count / k);\\n            count = 0;\\n        }\\n    }\\n    req += (count / k);\\n    return req >= m;\\n}\\n\\nint minDays(vector<int> &nums, int m, int k)\\n{\\n    int n = nums.size();\\n    // if (m * k > n)\\n    // {\\n    //     return -1;\\n    // }\\n\\n    int lb = 0;\\n    int ub = *max_element(nums.begin(), nums.end());\\n    int ans = -1;\\n\\n    while (lb <= ub)\\n    {\\n        int mid = lb + (ub - lb) / 2;\\n        if (isValid(mid, nums, m, k))\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609843,
                "title": "binary-search-time-o-n-log-n-space-o-1",
                "content": "# Intuition\\nSince bloomDay[i] represents the day after flower will bloom. For example if bloomDay[i] = 2, the flower will be available after 2 days. Now we have to make bouquet of size \"k\", we need k adjacent flowers. From this we can conclude that we can form bouquet only in the range min(bloomDay) to max(bloomDay). Since we have low and high endpoints to form a bouquet, we can search through min and max bloomDay using binary Search. \\n\\n# Algorithm:\\nWhile minDay <= maxDay repeat:\\n\\nStep 1: Calculate midDay = (minDay + maxday) / 2 <br>\\nStep 2: For day in bloomDay:\\n    - If day <= midDay i.e. flower is available to form bouquet. If this is the first available flower then increment flower_count by 1 and adjacent to True. Else if already adjacent is True i.e. previous flower is also available then just increment count by 1\\n    -  Else if day > midDay i.e. flower is not ready yet we will reset the count to 0 and adjacent to False\\n    - After above calculation we will check if count is equal to \"k\" then it means we can form a bouquet, so increment bouquet_count and reset count and adjacent variables <br>\\nStep 3:  If bouquet_count >= m: i.e. we found a solution so we will store the min of previos solution and current one. and look for better solution in less days. So we will search through left half of current search space.\\nElse We didn\\'t found solution yet so we will search through right half of search space.\\n\\n# Complexity\\n- Time complexity:\\n- For Binary Search log(n) and in each iteration of binary search we iterate through given array so overall complexity becomes: \\nO(n * log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m*k > len(bloomDay):\\n            return -1\\n\\n        min_value, max_value = min(bloomDay), max(bloomDay)\\n        answer = max_value\\n\\n        while min_value <= max_value:\\n            mid = (min_value + max_value) // 2\\n\\n            count, bouquets, adjacent = 0, 0, False\\n            for i in range(len(bloomDay)):\\n                if bloomDay[i] <= mid:\\n                    if count == 0:\\n                        adjacent = True\\n                        count += 1\\n                    elif adjacent:\\n                        count += 1\\n                else:\\n                    count = 0\\n                    adjacent = False\\n                \\n                if count == k:\\n                    bouquets += 1\\n                    count, adjacent = 0, False\\n                \\n            if bouquets >= m:\\n                answer = min(answer, mid)\\n                max_value = mid - 1\\n            else:\\n                min_value = mid + 1\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m*k > len(bloomDay):\\n            return -1\\n\\n        min_value, max_value = min(bloomDay), max(bloomDay)\\n        answer = max_value\\n\\n        while min_value <= max_value:\\n            mid = (min_value + max_value) // 2\\n\\n            count, bouquets, adjacent = 0, 0, False\\n            for i in range(len(bloomDay)):\\n                if bloomDay[i] <= mid:\\n                    if count == 0:\\n                        adjacent = True\\n                        count += 1\\n                    elif adjacent:\\n                        count += 1\\n                else:\\n                    count = 0\\n                    adjacent = False\\n                \\n                if count == k:\\n                    bouquets += 1\\n                    count, adjacent = 0, False\\n                \\n            if bouquets >= m:\\n                answer = min(answer, mid)\\n                max_value = mid - 1\\n            else:\\n                min_value = mid + 1\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413961,
                "title": "beginner-friendly-binary-search-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool isPossible(vector<int>& bloomDay, int m, int k,int mid){\\n     int adjFlower=0,Bouquet=0,n=bloomDay.size();\\n     for(int i=0;i<n;i++){\\n         if(bloomDay[i]<=mid){\\n             adjFlower++;\\n             if(adjFlower==k){\\n                 Bouquet++;\\n                  if(Bouquet==m){\\n                      return true;\\n                  }\\n                  adjFlower=0;\\n             }\\n         }\\n         else {\\n             adjFlower=0;\\n            \\n         }\\n     }\\n     return false;\\n }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int start=0 ,sum=0,ans=-1,end=0;\\n        for( int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<start)\\n            start=bloomDay[i];\\n            if(bloomDay[i]>end)\\n            end=bloomDay[i];\\n        }\\n        \\n        int mid=start+(end-start)/2;\\n        while (start<=end){\\n            if(isPossible(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else {\\n                start=mid+1;\\n            }\\n            mid=start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/ee704328-30ac-4589-9eb4-e9b46f5b8872_1681410421.5456107.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool isPossible(vector<int>& bloomDay, int m, int k,int mid){\\n     int adjFlower=0,Bouquet=0,n=bloomDay.size();\\n     for(int i=0;i<n;i++){\\n         if(bloomDay[i]<=mid){\\n             adjFlower++;\\n             if(adjFlower==k){\\n                 Bouquet++;\\n                  if(Bouquet==m){\\n                      return true;\\n                  }\\n                  adjFlower=0;\\n             }\\n         }\\n         else {\\n             adjFlower=0;\\n            \\n         }\\n     }\\n     return false;\\n }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int start=0 ,sum=0,ans=-1,end=0;\\n        for( int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<start)\\n            start=bloomDay[i];\\n            if(bloomDay[i]>end)\\n            end=bloomDay[i];\\n        }\\n        \\n        int mid=start+(end-start)/2;\\n        while (start<=end){\\n            if(isPossible(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else {\\n                start=mid+1;\\n            }\\n            mid=start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303087,
                "title": "easy-binary-search-implementation-with-comments-logical-approach",
                "content": "**Youtube video for reference : https://www.youtube.com/watch?v=paYIrQKxE7I**\\n```\\nclass Solution\\n{\\npublic:\\n    int minDays(vector<int> &bloomDay, int m, int k)\\n    {\\n\\n        int n = bloomDay.size();\\n\\n        if ((m * k) > n)\\n        { // if there are no flowers which are required then we simply return -1\\n            return -1;\\n        }\\n\\n        int low = INT_MAX;\\n\\n        int high = INT_MIN;\\n\\n        for (auto d : bloomDay)\\n        {\\n\\n            low = min(low, d);\\n\\n            high = max(high, d);\\n        }\\n\\n        while (low < high)\\n        {\\n\\n            int mid = low + (high - low) / 2;\\n\\n            int cur = 0, adj = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (bloomDay[i] > mid)\\n                    adj = 0; // check if the flower is bloomed or not\\n\\n                else\\n                {\\n                    adj++; // if the criteria for k is complete or not\\n\\n                    if (adj == k)\\n                    {\\n                        cur++;\\n                        adj = 0;\\n                    }\\n                }\\n                if (cur >= m)\\n                    break; // check if the curr is equal to m bouquet\\n            }\\n            if (cur < m)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF YOU LIKE THIS :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minDays(vector<int> &bloomDay, int m, int k)\\n    {\\n\\n        int n = bloomDay.size();\\n\\n        if ((m * k) > n)\\n        { // if there are no flowers which are required then we simply return -1\\n            return -1;\\n        }\\n\\n        int low = INT_MAX;\\n\\n        int high = INT_MIN;\\n\\n        for (auto d : bloomDay)\\n        {\\n\\n            low = min(low, d);\\n\\n            high = max(high, d);\\n        }\\n\\n        while (low < high)\\n        {\\n\\n            int mid = low + (high - low) / 2;\\n\\n            int cur = 0, adj = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (bloomDay[i] > mid)\\n                    adj = 0; // check if the flower is bloomed or not\\n\\n                else\\n                {\\n                    adj++; // if the criteria for k is complete or not\\n\\n                    if (adj == k)\\n                    {\\n                        cur++;\\n                        adj = 0;\\n                    }\\n                }\\n                if (cur >= m)\\n                    break; // check if the curr is equal to m bouquet\\n            }\\n            if (cur < m)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293318,
                "title": "simple-binary-search-c-solution-easy-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n      // if(m * k > bloomDay.size()) return -1;\\n     int left = INT_MAX, right = INT_MIN,ans = -1;\\n     for(int i = 0; i < bloomDay.size(); i++){\\n       left = min(left, bloomDay[i]);\\n       right = max(right, bloomDay[i]);\\n     }\\n     cout << left << endl;\\n     cout << right << endl;\\n     while(left <= right){\\n       int mid = left + (right - left) / 2;\\n       int flowers = 0, bouquets = 0;\\n       for(int i = 0; i < bloomDay.size(); i++){\\n         if(bloomDay[i] <= mid){\\n           flowers++;\\n         } else {\\n           flowers = 0;\\n         }\\n         if(flowers == k){\\n           bouquets++;\\n           flowers = 0;\\n         }\\n         if(bouquets == m) break;\\n       }\\n       if(bouquets < m) left = mid + 1;\\n       else {\\n       ans = mid;\\n       right = mid - 1;\\n       }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n      // if(m * k > bloomDay.size()) return -1;\\n     int left = INT_MAX, right = INT_MIN,ans = -1;\\n     for(int i = 0; i < bloomDay.size(); i++){\\n       left = min(left, bloomDay[i]);\\n       right = max(right, bloomDay[i]);\\n     }\\n     cout << left << endl;\\n     cout << right << endl;\\n     while(left <= right){\\n       int mid = left + (right - left) / 2;\\n       int flowers = 0, bouquets = 0;\\n       for(int i = 0; i < bloomDay.size(); i++){\\n         if(bloomDay[i] <= mid){\\n           flowers++;\\n         } else {\\n           flowers = 0;\\n         }\\n         if(flowers == k){\\n           bouquets++;\\n           flowers = 0;\\n         }\\n         if(bouquets == m) break;\\n       }\\n       if(bouquets < m) left = mid + 1;\\n       else {\\n       ans = mid;\\n       right = mid - 1;\\n       }\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3289458,
                "title": "c-simple-solution-wowowow-poggers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfunction to check if the solution is possible and then binary search the respective parts\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool myFunc(vector<int>& bloomDay, int m, int k , int mid){\\n        int count = 0;\\n        for(int i = 0; i < bloomDay.size() ; i ++){\\n            if(bloomDay[i] > mid){\\n                count = 0;\\n            }     \\n            if(bloomDay[i] <= mid){\\n                count++;\\n            }\\n            if(count == k){\\n                count = 0;\\n                m--;\\n            }\\n            if(m == 0) \\n                return true;  \\n    }    \\n      return false;\\n}    \\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int max = *max_element(bloomDay.begin(), bloomDay.end());\\n        int min = 0 ;\\n        int mid = 0 ;\\n        int ans =-1 ;\\n        while(min <= max){\\n            mid = (min + max)/2;\\n            if(myFunc(bloomDay, m, k , mid)){\\n                ans = mid;\\n                max = mid -1;\\n            }\\n            else{\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool myFunc(vector<int>& bloomDay, int m, int k , int mid){\\n        int count = 0;\\n        for(int i = 0; i < bloomDay.size() ; i ++){\\n            if(bloomDay[i] > mid){\\n                count = 0;\\n            }     \\n            if(bloomDay[i] <= mid){\\n                count++;\\n            }\\n            if(count == k){\\n                count = 0;\\n                m--;\\n            }\\n            if(m == 0) \\n                return true;  \\n    }    \\n      return false;\\n}    \\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int max = *max_element(bloomDay.begin(), bloomDay.end());\\n        int min = 0 ;\\n        int mid = 0 ;\\n        int ans =-1 ;\\n        while(min <= max){\\n            mid = (min + max)/2;\\n            if(myFunc(bloomDay, m, k , mid)){\\n                ans = mid;\\n                max = mid -1;\\n            }\\n            else{\\n                min = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272174,
                "title": "c-binary-search-on-search-space-self-explainatory",
                "content": "**Time Complexity: O(n*log(end-start)))**, where n is the size of array, end is max_element of the array and start is the minimum element of the array\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& bloomDay, int m, int k, int bloom){\\n        int subarray = 0;\\n        int bouq_cnt = 0;\\n        \\n        for(auto x: bloomDay){\\n            if(x <= bloom){\\n                subarray++;\\n                if(subarray == k)\\n                    bouq_cnt++, subarray = 0;\\n            }\\n            else\\n                subarray = 0;\\n        }\\n        \\n        return bouq_cnt >= m;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int start = *min_element(bloomDay.begin(), bloomDay.end());\\n        int end = *max_element(bloomDay.begin(), bloomDay.end());\\n        int res = -1;\\n        \\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(bloomDay, m, k, mid)){\\n                res = mid;\\n                end = mid-1;\\n            }\\n            else\\n                start = mid+1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nDo Upvote if this helps.\\nThanks!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& bloomDay, int m, int k, int bloom){\\n        int subarray = 0;\\n        int bouq_cnt = 0;\\n        \\n        for(auto x: bloomDay){\\n            if(x <= bloom){\\n                subarray++;\\n                if(subarray == k)\\n                    bouq_cnt++, subarray = 0;\\n            }\\n            else\\n                subarray = 0;\\n        }\\n        \\n        return bouq_cnt >= m;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int start = *min_element(bloomDay.begin(), bloomDay.end());\\n        int end = *max_element(bloomDay.begin(), bloomDay.end());\\n        int res = -1;\\n        \\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(bloomDay, m, k, mid)){\\n                res = mid;\\n                end = mid-1;\\n            }\\n            else\\n                start = mid+1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218448,
                "title": "easy-java-solution-beat-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing binary search \\nbounds are min and max \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe check if the days less than mid can be enough to make bouquets \\nif so then we check the right half for minimum days\\nelse we traverse the right half \\nwe keep track of the adjacency using count \\n# Complexity\\n- Time complexity:O(nlogm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int minDays(int[] bloomDay, int m, int k) {\\n       if((long)m*k>bloomDay.length) return -1;\\n     \\n        int left=1,right=1,mid;\\n        for(int i:bloomDay)\\n        {\\n            left=Math.min(left,i);\\n            right=Math.max(right,i);\\n        }\\n        while(left<right)\\n        {\\n            mid=left+(right-left)/2;\\n            if(canmake(mid,m,k,bloomDay))\\n                right=mid;\\n            else\\n                left=mid+1;\\n        }\\n        return left;\\n    }\\n    \\n    private boolean canmake(int val,int bouquet, int flowers,int[] bloom)\\n    {\\n        int count=0;\\n        for(int i:bloom)\\n        {\\n            if(i<=val)\\n            {\\n                count++;\\n                if(count==flowers)\\n                {\\n                    bouquet--;\\n                    count=0;\\n                    if(bouquet==0) return true;\\n                }\\n            }\\n            else count = 0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int minDays(int[] bloomDay, int m, int k) {\\n       if((long)m*k>bloomDay.length) return -1;\\n     \\n        int left=1,right=1,mid;\\n        for(int i:bloomDay)\\n        {\\n            left=Math.min(left,i);\\n            right=Math.max(right,i);\\n        }\\n        while(left<right)\\n        {\\n            mid=left+(right-left)/2;\\n            if(canmake(mid,m,k,bloomDay))\\n                right=mid;\\n            else\\n                left=mid+1;\\n        }\\n        return left;\\n    }\\n    \\n    private boolean canmake(int val,int bouquet, int flowers,int[] bloom)\\n    {\\n        int count=0;\\n        for(int i:bloom)\\n        {\\n            if(i<=val)\\n            {\\n                count++;\\n                if(count==flowers)\\n                {\\n                    bouquet--;\\n                    count=0;\\n                    if(bouquet==0) return true;\\n                }\\n            }\\n            else count = 0;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192866,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>& vec, int m, int k,int mid){\\n        \\n        int curr = 0;\\n        int n = vec.size();\\n        int temp = 0;\\n        \\n        for(int i =0;i<n;i++){\\n            \\n            if(temp==k){\\n                curr++;\\n                temp = 0;\\n            }\\n            \\n            if(vec[i]<=mid){\\n                temp++;\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        \\n        if(temp==k){\\n            curr++;\\n            temp = 0;\\n        }\\n        \\n        return curr>=m;\\n    }\\n    \\n    int minDays(vector<int>& vec, int m, int k) {\\n        \\n        int high = vec[0];\\n        int n = vec.size();\\n        \\n        for(auto iter : vec){\\n            high = max(high,iter);\\n        }\\n        \\n        int low = 1;\\n        \\n        int ans = -1;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(f(vec,m,k,mid)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>& vec, int m, int k,int mid){\\n        \\n        int curr = 0;\\n        int n = vec.size();\\n        int temp = 0;\\n        \\n        for(int i =0;i<n;i++){\\n            \\n            if(temp==k){\\n                curr++;\\n                temp = 0;\\n            }\\n            \\n            if(vec[i]<=mid){\\n                temp++;\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        \\n        if(temp==k){\\n            curr++;\\n            temp = 0;\\n        }\\n        \\n        return curr>=m;\\n    }\\n    \\n    int minDays(vector<int>& vec, int m, int k) {\\n        \\n        int high = vec[0];\\n        int n = vec.size();\\n        \\n        for(auto iter : vec){\\n            high = max(high,iter);\\n        }\\n        \\n        int low = 1;\\n        \\n        int ans = -1;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(f(vec,m,k,mid)){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942086,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(Nlog(j-i))\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int i=*min_element(bloomDay.begin(), bloomDay.end()), j=*max_element(bloomDay.begin(), bloomDay.end());\\n        while(i<j){\\n            int mid=i+(j-i)/2;\\n            int cnt=0, ans=0;\\n            for(auto it: bloomDay){\\n                if(it>mid){cnt=0;}\\n                else{\\n                    cnt++;\\n                    if(cnt==k){\\n                        cnt=0;\\n                        ans++;\\n                    }\\n                }\\n                if(ans>=m){break;}\\n            }\\n            if(ans>=m){j=mid;}\\n            else{i=mid+1;}\\n        }\\n        int cnt=0, ans=0;\\n        for(auto it: bloomDay){\\n            if(it>i){cnt=0;}\\n            else{\\n                cnt++;\\n                if(cnt==k){\\n                    cnt=0;\\n                    ans++;\\n                }\\n            }\\n            if(ans>=m){break;}\\n        }\\n        if(ans>=m){return i;}\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int i=*min_element(bloomDay.begin(), bloomDay.end()), j=*max_element(bloomDay.begin(), bloomDay.end());\\n        while(i<j){\\n            int mid=i+(j-i)/2;\\n            int cnt=0, ans=0;\\n            for(auto it: bloomDay){\\n                if(it>mid){cnt=0;}\\n                else{\\n                    cnt++;\\n                    if(cnt==k){\\n                        cnt=0;\\n                        ans++;\\n                    }\\n                }\\n                if(ans>=m){break;}\\n            }\\n            if(ans>=m){j=mid;}\\n            else{i=mid+1;}\\n        }\\n        int cnt=0, ans=0;\\n        for(auto it: bloomDay){\\n            if(it>i){cnt=0;}\\n            else{\\n                cnt++;\\n                if(cnt==k){\\n                    cnt=0;\\n                    ans++;\\n                }\\n            }\\n            if(ans>=m){break;}\\n        }\\n        if(ans>=m){return i;}\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916641,
                "title": "golang-binarysearch",
                "content": "# Intuition\\nUsing binarySearch find optimal days required to make m bouques\\n\\n# Approach\\n1. Use binarySearch to find number of appox days\\n2. Using that approx days, find out how many sequential flowers would have bloomed\\n3. If number of sequential flowers bloomed are more than bouquet requirement, then try reducing the number of days to min days required.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc minDays(bloomDay []int, m int, k int) int {\\n    n := len(bloomDay)\\n\\n    if m * k > n {\\n        return -1\\n    }\\n\\n    left, right := 1, 1000000000\\n    for left < right {\\n        mid := (left + right) / 2\\n\\n        if canMakeBouq(bloomDay,  mid, m, k) {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n\\n    return left\\n}\\n\\nfunc canMakeBouq(bloomDay []int, days, m, k int) bool {\\n    bouq := 0\\n    seq := 0\\n    for i := 0; i < len(bloomDay) && bouq < m; i++ {\\n        if bloomDay[i] > days {\\n            seq = 0\\n            continue\\n        } \\n        seq++\\n        if seq == k {\\n            bouq++\\n            seq = 0 // start again new sequence\\n        }\\n    }\\n\\n    return bouq >= m\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc minDays(bloomDay []int, m int, k int) int {\\n    n := len(bloomDay)\\n\\n    if m * k > n {\\n        return -1\\n    }\\n\\n    left, right := 1, 1000000000\\n    for left < right {\\n        mid := (left + right) / 2\\n\\n        if canMakeBouq(bloomDay,  mid, m, k) {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n\\n    return left\\n}\\n\\nfunc canMakeBouq(bloomDay []int, days, m, k int) bool {\\n    bouq := 0\\n    seq := 0\\n    for i := 0; i < len(bloomDay) && bouq < m; i++ {\\n        if bloomDay[i] > days {\\n            seq = 0\\n            continue\\n        } \\n        seq++\\n        if seq == k {\\n            bouq++\\n            seq = 0 // start again new sequence\\n        }\\n    }\\n\\n    return bouq >= m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2840291,
                "title": "java-binary-search-common-template-commented-with-code-walk-through",
                "content": "```\\nclass Solution \\n{\\n    public int minDays(int[] bloomDay, int m, int k) \\n    {\\n        //  m*k= Number of flowers required that is should be <= n (bloomDay.length)\\n        //  k: is also the length of the subarray (flowers for bouquet)\\n        \\n        if (m*k> bloomDay.length)\\n            return -1;\\n        int ans=-1;\\n        \\n        /*  Main Idea: m subarrays (bouquets) of size k, and we need to minimize the maximum value in these sub-arrays\\n         -> if above condition (m*k> len) is false, we are guaranteed an answer. \\n            Also, we know the answer lies between the maximum and minimum value in our bloom-array, and since the answer is guaranteed we can check the feasibility (which means searching will be involved) and depending on that change our search space.\\n         -> So we might be able to use Binary Search instead of checking for each element of the array.\\n         \\n         Let\\'s think*/\\n         int low=0;\\n         int high= (int)Math.pow(10,9); // Also can find the max and min values from the array\\n        \\n        while (low<=high)\\n        {\\n            int mid= low+ (high-low)/2; // Possible result\\n            \\n            // Check if it is possible?\\n            if (isPossible(bloomDay, mid, m, k)){   \\n                ans= mid;\\n                high= mid-1; // Lets check for a lesser possible answer\\n            }\\n            else\\n                low= mid+1; // Looks like we can not have m bouquets for this mid\\n            \\n        }\\n        return ans;\\n       \\n    }\\n    // Check for a possible answer (mid): Going through the array and checking if for an assumed answer, can we make more than or equal to required bouquets \\n\\t// [Essentially finding the count of subarrays of size k with all elements less than or equal to mid]\\n    public boolean isPossible(int arr[], int mid, int bouquets, int k) \\n    {   \\n        int flowers=0;\\n        int boqs=0;\\n\\n        for (int i=0; i<arr.length; i++)\\n        {\\n            if (arr[i]>mid) // Implies flower hasn\\'t bloomed so can not be a part of subarray, so count set to 0\\n                flowers=0; // Since adjacent\\n            \\n            else \\n            // We need to check if the number of flowers is k(indicates size of curr subarray)\\n            {\\n                flowers++; // Count of elements/ flowers in subarray/ bouquets (adjacent)\\n                if (flowers==k)\\n                    {\\n                    boqs++; // Count of bouquets\\n                    flowers=0; \\n                }\\n                else\\n                    continue;\\n            }\\n            \\n        }\\n        if (boqs>= bouquets) // We can make m bouquets\\n            return true;\\n        else \\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minDays(int[] bloomDay, int m, int k) \\n    {\\n        //  m*k= Number of flowers required that is should be <= n (bloomDay.length)\\n        //  k: is also the length of the subarray (flowers for bouquet)\\n        \\n        if (m*k> bloomDay.length)\\n            return -1;\\n        int ans=-1;\\n        \\n        /*  Main Idea: m subarrays (bouquets) of size k, and we need to minimize the maximum value in these sub-arrays\\n         -> if above condition (m*k> len) is false, we are guaranteed an answer. \\n            Also, we know the answer lies between the maximum and minimum value in our bloom-array, and since the answer is guaranteed we can check the feasibility (which means searching will be involved) and depending on that change our search space.\\n         -> So we might be able to use Binary Search instead of checking for each element of the array.\\n         \\n         Let\\'s think*/\\n         int low=0;\\n         int high= (int)Math.pow(10,9); // Also can find the max and min values from the array\\n        \\n        while (low<=high)\\n        {\\n            int mid= low+ (high-low)/2; // Possible result\\n            \\n            // Check if it is possible?\\n            if (isPossible(bloomDay, mid, m, k)){   \\n                ans= mid;\\n                high= mid-1; // Lets check for a lesser possible answer\\n            }\\n            else\\n                low= mid+1; // Looks like we can not have m bouquets for this mid\\n            \\n        }\\n        return ans;\\n       \\n    }\\n    // Check for a possible answer (mid): Going through the array and checking if for an assumed answer, can we make more than or equal to required bouquets \\n\\t// [Essentially finding the count of subarrays of size k with all elements less than or equal to mid]\\n    public boolean isPossible(int arr[], int mid, int bouquets, int k) \\n    {   \\n        int flowers=0;\\n        int boqs=0;\\n\\n        for (int i=0; i<arr.length; i++)\\n        {\\n            if (arr[i]>mid) // Implies flower hasn\\'t bloomed so can not be a part of subarray, so count set to 0\\n                flowers=0; // Since adjacent\\n            \\n            else \\n            // We need to check if the number of flowers is k(indicates size of curr subarray)\\n            {\\n                flowers++; // Count of elements/ flowers in subarray/ bouquets (adjacent)\\n                if (flowers==k)\\n                    {\\n                    boqs++; // Count of bouquets\\n                    flowers=0; \\n                }\\n                else\\n                    continue;\\n            }\\n            \\n        }\\n        if (boqs>= bouquets) // We can make m bouquets\\n            return true;\\n        else \\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694584,
                "title": "python-binary-search-on-answer-explained",
                "content": "This is one of those problems where we have to make use of the \"Binary Search on Answer\" concept.\\n\\n\\tIn simple words - Apply Binary Search on the range of possible solution values.\\n\\t\\nHere, we have to find \"minimum days to wait\" to make m bouquets.\\n\\nNow, What can be the range of values in which solution can exist?\\n\\nWe have to think of what can be the smallest possible input? We might be asked for 1 bouquet that can be make using 1 flower only.\\n\\nSo in that case, what is the minimum days we need to wait?\\n\\t\\t\\n\\t\\tConsider this example - \\n\\t\\t\\n\\t\\tbloomDay = [1,10,3,10,2], m = 1, k = 1\\n\\t\\t\\n\\t\\tWe can see that bloomDay[0] has value = 1 which means this flower will bloom after waiting for 1 day only.\\n\\t\\t\\n\\t\\tAnd since we only need 1 flower, the minimum days we need to wait is 1. Because 1 is the smallest value in this array.\\n\\t\\t\\n\\t\\tAnd this is the lower bound of our range.\\n\\t\\t\\n\\t\\t\\nSimilarly, think of what can be the upper bound?\\n\\nWhat if we are asked to make one bouquet but that will be made using all the flowers that we have in array. \\n\\n\\t\\tConsider this example - \\n\\t\\t\\n\\t\\tbloomDay = [1,10,3,10,2], m = 1, k = 5\\n\\t\\t\\n\\t\\tSo, to get all the 5 flowers ready for bouquet, we have to wait 10 days, right? \\n\\t\\t\\n\\t\\tBecause only then the flowers at index 1 and index 3 will bloom. \\n\\t\\t\\nThis means, the upper bound of the range is the maximum value in the given array.\\n\\nHence the Range is - \\n\\n\\t\\tMinimum Value in bloomDay \\n\\t\\t\\t\\t\\t\\tTo\\n\\t\\tMaximim Value in bloomDay\\n\\t\\t\\nAnd we are sure that solution for any test case lies in this range only.\\n\\nAnd since this range is sorted, we can use Binary search to get the minimum valid value.\\n\\n\\tbloomDay = [1,10,3,10,2], m = 3, k = 1\\n\\t\\n\\tHere, range is from 1 to 10\\n\\t\\n\\tSo, we get mid = 5\\n\\t\\n\\tNow, how to check if we can wait 5 days to make m bouquets?\\n\\t\\n\\tThat\\'s where we can use a Helper method that checks just that.\\n\\t\\n\\nWe will go through the array and for every flower, we check if it can bloom in <= mid days. IF yes, we can take this flower. But it is also important to note that we need adjacent flowers. So, if some flower takes longer days to bloom, then that means, we have to again start searching for k adjacent flowers from 0.\\n\\nIf we got k adjacent flowers, we can make one bouquet\\n\\nAnd when loop ends, we just need to check whether we were able to make at least \"m\" bouquets after waiting for \"mid\" days.\\n\\n# **CODE**\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to check if after waiting certain number of days\\n    # We can make m bouquets\\n    \\n    def isValid(self, days, bloomDay, m, k):\\n        bouquets = 0\\n        flowerCount = 0\\n        \\n        for day in bloomDay:\\n            # If we have to wait <= \"days\" for this flower, increment flowerCount \\n            if day <= days: flowerCount += 1\\n            # Otherwise we have to reset flowerCount because we can only take adjacent flowers\\n            else: flowerCount = 0\\n            \\n            # If we got k flowers, we can make one bouquet. So increment bouquet count and also reset flowerCount\\n            if flowerCount == k: \\n                bouquets += 1\\n                flowerCount = 0\\n                \\n        # If we can make at least m bouquet after waiting \"days\" days then return True\\n        return bouquets >= m\\n    \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        \\n        # For one bouquet, we need k flowers\\n        # For m bouquet, we need m * k flowers\\n        # And length of array = flowers we have\\n        \\n        # If we don\\'t have enough flowers at all\\n        \\n        if len(bloomDay) < m * k: return -1\\n        \\n        \\n        # Binary Search on Answer\\n        # We want the minimum number of days to wait to make m bouquets\\n        \\n        \\n        # What is the lower bound for minimum days to wait?\\n        # It is the lowest value in bloomDay, right?\\n        \\n        # What is the upper bound? It is the highest value\\n        \\n        start = min(bloomDay)\\n        end  = max(bloomDay)\\n        result = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # We need to check if after waiting for mid days, we can make m bouquets\\n            \\n            if self.isValid(mid, bloomDay, m, k):\\n                # If we can wait mid days for m bouquets, this is one possible solution\\n                # But since we want minimum days to wait, we keep searching for a lower possible valid value\\n                \\n                result = mid\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Helper method to check if after waiting certain number of days\\n    # We can make m bouquets\\n    \\n    def isValid(self, days, bloomDay, m, k):\\n        bouquets = 0\\n        flowerCount = 0\\n        \\n        for day in bloomDay:\\n            # If we have to wait <= \"days\" for this flower, increment flowerCount \\n            if day <= days: flowerCount += 1\\n            # Otherwise we have to reset flowerCount because we can only take adjacent flowers\\n            else: flowerCount = 0\\n            \\n            # If we got k flowers, we can make one bouquet. So increment bouquet count and also reset flowerCount\\n            if flowerCount == k: \\n                bouquets += 1\\n                flowerCount = 0\\n                \\n        # If we can make at least m bouquet after waiting \"days\" days then return True\\n        return bouquets >= m\\n    \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        \\n        # For one bouquet, we need k flowers\\n        # For m bouquet, we need m * k flowers\\n        # And length of array = flowers we have\\n        \\n        # If we don\\'t have enough flowers at all\\n        \\n        if len(bloomDay) < m * k: return -1\\n        \\n        \\n        # Binary Search on Answer\\n        # We want the minimum number of days to wait to make m bouquets\\n        \\n        \\n        # What is the lower bound for minimum days to wait?\\n        # It is the lowest value in bloomDay, right?\\n        \\n        # What is the upper bound? It is the highest value\\n        \\n        start = min(bloomDay)\\n        end  = max(bloomDay)\\n        result = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # We need to check if after waiting for mid days, we can make m bouquets\\n            \\n            if self.isValid(mid, bloomDay, m, k):\\n                # If we can wait mid days for m bouquets, this is one possible solution\\n                # But since we want minimum days to wait, we keep searching for a lower possible valid value\\n                \\n                result = mid\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617570,
                "title": "c-easy-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    bool canGetBouq(vector<int>& bloomDay, int days, int m, int k){\\n        int count=0,result=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i]<=days){\\n                count++; //count represents consective flowers\\n            }\\n            else{\\n                count=0;\\n            }\\n            if(count==k){\\n                count=0; //reset the window\\n                result++;\\n            }\\n        }\\n        return result>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int low=1,high=1000000000;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(canGetBouq(bloomDay,mid,m,k)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return canGetBouq(bloomDay,low,m,k) ? low : -1; //Final check if the result day can have atleast `m` bouquets.\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool canGetBouq(vector<int>& bloomDay, int days, int m, int k){\\n        int count=0,result=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i]<=days){\\n                count++; //count represents consective flowers\\n            }\\n            else{\\n                count=0;\\n            }\\n            if(count==k){\\n                count=0; //reset the window\\n                result++;\\n            }\\n        }\\n        return result>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int low=1,high=1000000000;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(canGetBouq(bloomDay,mid,m,k)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return canGetBouq(bloomDay,low,m,k) ? low : -1; //Final check if the result day can have atleast `m` bouquets.\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578894,
                "title": "binary-search-c-best",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& b,int mid, int k, int m,int n)\\n    {\\n        int tot=0,flo=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(b[i] <= mid)\\n            {\\n                flo++;\\n                if(flo == k){\\n                    tot++;\\n                    flo=0;   \\n                }\\n            }else\\n                flo=0;\\n        }\\n        return tot >= m;\\n    }\\n    \\n    int minDays(vector<int>& b, int m, int k) {\\n        int n=b.size();\\n        if(k*m > n)return -1;\\n        int l=1,r=*max_element(b.begin(),b.end()),ans=-1;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(check(b,mid,k,m,n))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& b,int mid, int k, int m,int n)\\n    {\\n        int tot=0,flo=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(b[i] <= mid)\\n            {\\n                flo++;\\n                if(flo == k){\\n                    tot++;\\n                    flo=0;   \\n                }\\n            }else\\n                flo=0;\\n        }\\n        return tot >= m;\\n    }\\n    \\n    int minDays(vector<int>& b, int m, int k) {\\n        int n=b.size();\\n        if(k*m > n)return -1;\\n        int l=1,r=*max_element(b.begin(),b.end()),ans=-1;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(check(b,mid,k,m,n))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244993,
                "title": "cpp-binary-search-with-comments",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValid(vector<int>& bloomDay, int bouquets, int flowers, int days){\\n\\t\\t\\tint bouq = 0, flow = 0; //initially keep the bouqets with flowers that can be formed as 0\\n\\t\\t\\tfor(auto bloom : bloomDay){\\n\\t\\t\\t\\tflow = (bloom <= days) ? flow + 1 : 0;  //Increment flowers if element is less than or equal to days , or else reset it to 0\\n\\t\\t\\t\\tif(flow == flowers){  //if flowers == desired flowers , you can make a bouquet, Reset flowers after incrementing bouquet\\n\\t\\t\\t\\t\\tflow = 0; \\n\\t\\t\\t\\t\\tbouq ++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn bouq >= bouquets; //return true if bouqets >= desired bouqets or return false\\n\\t\\t}\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < m*k) return -1; // in case making bouqet isnt possible because that many flowers arent present\\n        int low = 1; //Search space - 1 to max of arr. (1 day to bloom or max of all the days present to bloom)\\n        int high = 0;\\n        for(auto days: bloomDay) high = max(high, days);\\n        while(low < high){\\n            int mid = low + (high-low)/2; //avoid integer overflow\\n            if(isValid(bloomDay, m, k, mid)){\\n                high = mid; //if the isValid returns true, try to find a better result by shrink the search space to the left.(Note that mid can be a possible answer , hence high = mid and not mid-1)\\n            }else{\\n                low = mid + 1; //if isValid returns false, eliminate left. Hence low = mid + 1 and not low = mid\\n            }\\n        }\\n        return low; //at last low and high will be pointing to the same answer, so return anyone of them\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isValid(vector<int>& bloomDay, int bouquets, int flowers, int days){\\n\\t\\t\\tint bouq = 0, flow = 0; //initially keep the bouqets with flowers that can be formed as 0\\n\\t\\t\\tfor(auto bloom : bloomDay){\\n\\t\\t\\t\\tflow = (bloom <= days) ? flow + 1 : 0;  //Increment flowers if element is less than or equal to days , or else reset it to 0\\n\\t\\t\\t\\tif(flow == flowers){  //if flowers == desired flowers , you can make a bouquet, Reset flowers after incrementing bouquet\\n\\t\\t\\t\\t\\tflow = 0; \\n\\t\\t\\t\\t\\tbouq ++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2062891,
                "title": "binary-search-easy-solution-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\nprivate:\\n    bool isf(int mid,vector<int> &b,int m,int k){\\n        int flower=0;int var=0;\\n        for(int i=0;i<b.size();i++){\\n            if(b[i]<=mid) {\\n                var++;\\n                if(var==k){\\n                    flower++;\\n                    var=0;\\n                }\\n            }else var=0;\\n            \\n        }return flower>=m;\\n    }\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        if((m*k)>b.size()) return -1;\\n        int i=1;\\n        int j=*max_element(b.begin(),b.end());\\n        int ans=j;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(isf(mid,b,m,k)){\\n                cout<<mid<<\" \";\\n                ans=mid;\\n                j=mid-1;\\n            }else i=mid+1;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isf(int mid,vector<int> &b,int m,int k){\\n        int flower=0;int var=0;\\n        for(int i=0;i<b.size();i++){\\n            if(b[i]<=mid) {\\n                var++;\\n                if(var==k){\\n                    flower++;\\n                    var=0;\\n                }\\n            }else var=0;\\n            \\n        }return flower>=m;\\n    }\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        if((m*k)>b.size()) return -1;\\n        int i=1;\\n        int j=*max_element(b.begin(),b.end());\\n        int ans=j;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(isf(mid,b,m,k)){\\n                cout<<mid<<\" \";\\n                ans=mid;\\n                j=mid-1;\\n            }else i=mid+1;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1995826,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    \\n    def canWork(self, blooms, days, m, k):\\n        flowers = 0\\n        for flower in blooms:\\n            flowers = flowers + 1 if (flower <= days) else 0\\n            if flowers == k:\\n                m -= 1\\n                flowers = 0\\n        return m <= 0\\n    \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n        left, right = 1, max(bloomDay)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if self.canWork(bloomDay, mid, m, k):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def canWork(self, blooms, days, m, k):\\n        flowers = 0\\n        for flower in blooms:\\n            flowers = flowers + 1 if (flower <= days) else 0\\n            if flowers == k:\\n                m -= 1\\n                flowers = 0\\n        return m <= 0\\n    \\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n        left, right = 1, max(bloomDay)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if self.canWork(bloomDay, mid, m, k):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986979,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\npublic int minDays(int[] A, int m, int k) {\\n        int n = A.length, left = 1, right = (int)1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\\n\\n***JavaScript***\\n```\\nvar minDays = function (bloomDay, m, k) {\\n  let n = bloomDay.length;\\n  let left = 1;\\n  let right = Number.MAX_SAFE_INTEGER;\\n  if (m * k > n) {\\n    return -1;\\n  }\\n  while (left < right) {\\n    let mid = Math.floor(left / 2 + right / 2);\\n    let flowers = 0;\\n    let bouque = 0;\\n    for (let j = 0; j < n; j++) {\\n      if (bloomDay[j] > mid) {\\n        flowers = 0;\\n      } else {\\n        flowers++;\\n        if (flowers >= k) {\\n          bouque++;\\n          flowers = 0;\\n        }\\n      }\\n    }\\n    if (bouque < m) {\\n      left = mid + 1;\\n    } else {\\n      right = mid;\\n    }\\n  }\\n\\n  return left;\\n};\\n```\\n\\n***C++***\\n```\\nint minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\\n\\n***Python***\\n```\\ndef minDays(self, A, m, k):\\n        if m * k > len(A): return -1\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            flow = bouq = 0\\n            for a in A:\\n                flow = 0 if a > mid else flow + 1\\n                if flow >= k:\\n                    flow = 0\\n                    bouq += 1\\n                    if bouq == m: break\\n            if bouq == m:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n***Kotlin***\\n```\\nfun minDays(A: IntArray, m: Int, k: Int): Int {\\n        val len = A.size\\n        val max = 1000000001 // max value of A is 10^9\\n        \\n        fun isPossible(day: Int): Boolean {\\n            val garden = BooleanArray(len) { i -> if (A[i] <= day) true else false }\\n            var bouquet = 0\\n            var countAdj = 0\\n            for (isBloomed in garden) {\\n                if (isBloomed) { \\n                    countAdj++\\n                    if (countAdj == k) {\\n                        bouquet++\\n                        countAdj = 0\\n                    }\\n                } else {\\n                    countAdj = 0\\n                }\\n            }\\n            return bouquet >= m\\n        }\\n        \\n        var low = 1\\n        var high = max\\n        while (low < high) {\\n            val mid = (high + low) / 2\\n            if (isPossible(mid).not()) \\n                low = mid + 1\\n            else\\n                high = mid\\n        }\\n        return if (low == max) -1 else low\\n    }\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func minDays(_ bd: [Int], _ m: Int, _ k: Int) -> Int {\\n        guard bd.count >= m * k else { return -1 }\\n        var lhs = 0, rhs = 0, valid = Set<Int>(), res = Int.max\\n\\n        for d in bd {\\n            if d > rhs { rhs = d }\\n            if d <= lhs { lhs = d }\\n        }\\n        \\n        func match(_ t: Int) -> Bool {\\n            var cnt = 0, sum = 0\\n            for d in bd {\\n                if d <= t { sum += 1 } else { cnt += sum / k; sum = 0 }\\n            }\\n            return cnt + sum / k >= m\\n        }\\n\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) >> 1\\n            valid.insert(mid)\\n            if match(mid) {\\n                res = min(res, mid)\\n                rhs = mid - 1\\n            } else {\\n                lhs = mid + 1\\n            }\\n        }\\n        return valid.contains(lhs) ? res : min(res, match(lhs) ? lhs : .max)\\n    }\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\npublic int minDays(int[] A, int m, int k) {\\n        int n = A.length, left = 1, right = (int)1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\n```\\nvar minDays = function (bloomDay, m, k) {\\n  let n = bloomDay.length;\\n  let left = 1;\\n  let right = Number.MAX_SAFE_INTEGER;\\n  if (m * k > n) {\\n    return -1;\\n  }\\n  while (left < right) {\\n    let mid = Math.floor(left / 2 + right / 2);\\n    let flowers = 0;\\n    let bouque = 0;\\n    for (let j = 0; j < n; j++) {\\n      if (bloomDay[j] > mid) {\\n        flowers = 0;\\n      } else {\\n        flowers++;\\n        if (flowers >= k) {\\n          bouque++;\\n          flowers = 0;\\n        }\\n      }\\n    }\\n    if (bouque < m) {\\n      left = mid + 1;\\n    } else {\\n      right = mid;\\n    }\\n  }\\n\\n  return left;\\n};\\n```\n```\\nint minDays(vector<int>& A, int m, int k) {\\n        int n = A.size(), left = 1, right = 1e9;\\n        if (m * k > n) return -1;\\n        while (left < right) {\\n            int mid = (left + right) / 2, flow = 0, bouq = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (A[j] > mid) {\\n                    flow = 0;\\n                } else if (++flow >= k) {\\n                    bouq++;\\n                    flow = 0;\\n                }\\n            }\\n            if (bouq < m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n```\n```\\ndef minDays(self, A, m, k):\\n        if m * k > len(A): return -1\\n        left, right = 1, max(A)\\n        while left < right:\\n            mid = (left + right) / 2\\n            flow = bouq = 0\\n            for a in A:\\n                flow = 0 if a > mid else flow + 1\\n                if flow >= k:\\n                    flow = 0\\n                    bouq += 1\\n                    if bouq == m: break\\n            if bouq == m:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\nfun minDays(A: IntArray, m: Int, k: Int): Int {\\n        val len = A.size\\n        val max = 1000000001 // max value of A is 10^9\\n        \\n        fun isPossible(day: Int): Boolean {\\n            val garden = BooleanArray(len) { i -> if (A[i] <= day) true else false }\\n            var bouquet = 0\\n            var countAdj = 0\\n            for (isBloomed in garden) {\\n                if (isBloomed) { \\n                    countAdj++\\n                    if (countAdj == k) {\\n                        bouquet++\\n                        countAdj = 0\\n                    }\\n                } else {\\n                    countAdj = 0\\n                }\\n            }\\n            return bouquet >= m\\n        }\\n        \\n        var low = 1\\n        var high = max\\n        while (low < high) {\\n            val mid = (high + low) / 2\\n            if (isPossible(mid).not()) \\n                low = mid + 1\\n            else\\n                high = mid\\n        }\\n        return if (low == max) -1 else low\\n    }\\n```\n```\\nclass Solution {\\n    func minDays(_ bd: [Int], _ m: Int, _ k: Int) -> Int {\\n        guard bd.count >= m * k else { return -1 }\\n        var lhs = 0, rhs = 0, valid = Set<Int>(), res = Int.max\\n\\n        for d in bd {\\n            if d > rhs { rhs = d }\\n            if d <= lhs { lhs = d }\\n        }\\n        \\n        func match(_ t: Int) -> Bool {\\n            var cnt = 0, sum = 0\\n            for d in bd {\\n                if d <= t { sum += 1 } else { cnt += sum / k; sum = 0 }\\n            }\\n            return cnt + sum / k >= m\\n        }\\n\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) >> 1\\n            valid.insert(mid)\\n            if match(mid) {\\n                res = min(res, mid)\\n                rhs = mid - 1\\n            } else {\\n                lhs = mid + 1\\n            }\\n        }\\n        return valid.contains(lhs) ? res : min(res, match(lhs) ? lhs : .max)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962800,
                "title": "c-binary-search-with-sliding-window-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr, int m, int k,int maxDay){\\n        int toPick = m;\\n        int i=0,j = 0,cnt=0;\\n        while(j < arr.size()){\\n            int window = j - i + 1;\\n            if(arr[j] <= maxDay){\\n                cnt++;\\n            }\\n            \\n            if(window == k){\\n                if(cnt == k){\\n                    toPick--;\\n                    cnt = 0;\\n                    i = j + 1;\\n                }else{\\n                    if(arr[i] <= maxDay){\\n                        cnt--;\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return toPick <= 0;\\n    }\\n    int minDays(vector<int>& arr, int m, int k) {\\n        int lo = INT_MAX, hi = INT_MIN;\\n        for(int i : arr){\\n            lo = min(i,lo);\\n            hi = max(i,hi);\\n        }\\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,m,k,mid)){\\n                hi = mid - 1;\\n                ans = mid;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// n.log(max-min)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& arr, int m, int k,int maxDay){\\n        int toPick = m;\\n        int i=0,j = 0,cnt=0;\\n        while(j < arr.size()){\\n            int window = j - i + 1;\\n            if(arr[j] <= maxDay){\\n                cnt++;\\n            }\\n            \\n            if(window == k){\\n                if(cnt == k){\\n                    toPick--;\\n                    cnt = 0;\\n                    i = j + 1;\\n                }else{\\n                    if(arr[i] <= maxDay){\\n                        cnt--;\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return toPick <= 0;\\n    }\\n    int minDays(vector<int>& arr, int m, int k) {\\n        int lo = INT_MAX, hi = INT_MIN;\\n        for(int i : arr){\\n            lo = min(i,lo);\\n            hi = max(i,hi);\\n        }\\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,m,k,mid)){\\n                hi = mid - 1;\\n                ans = mid;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// n.log(max-min)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950294,
                "title": "c-binary-search",
                "content": "I think many people not able to identify that this problem comes under binary search. So to identify if the given problem can be solved using binary search or not check the final answer if it is between some range or not.\\n\\nYou will always find the range and you have to find the maximum and minimum from that range by keeping in a mind some condition and reducing a boundary.\\n\\nFor eg:  bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\\nhere range will be **1 to sumOfDaysInArray** which is 1 to 54\\nwe have to find the mid element which is 27\\n\\nwe will check for 27 if it can be total no of days or not and we find that it can be the answer but we want the minimum one so will will reduce the boundary from 1 to 27 and will try to find ans in this range and this process will continue untill low<high.\\n\\n**So for binary search always check if answer lies between some range or not.**\\n\\nI know its useless to add code here as many people already posted the code but still i will post for convenience,\\n\\n```\\n int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(k*m>bloomDay.size())\\n            return -1;\\n        long long low=1,high;\\n        for(auto i:bloomDay)\\n            high+=i;\\n        int ans;\\n        while(low<high){\\n            long long mid=low+(high-low)/2;\\n            int temp=0;\\n            int total=0;\\n            for(int i=0;i<bloomDay.size();i++){\\n                if(bloomDay[i]<=mid)\\n                    temp++;\\n                else temp=0;\\n                if(temp==k){\\n                    total++;\\n                    temp=0;\\n                }\\n            }\\n            if(total>=m){\\n                ans=mid;\\n                high=mid;\\n            }\\n            else low=mid+1;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(k*m>bloomDay.size())\\n            return -1;\\n        long long low=1,high;\\n        for(auto i:bloomDay)\\n            high+=i;\\n        int ans;\\n        while(low<high){\\n            long long mid=low+(high-low)/2;\\n            int temp=0;\\n            int total=0;\\n            for(int i=0;i<bloomDay.size();i++){\\n                if(bloomDay[i]<=mid)\\n                    temp++;\\n                else temp=0;\\n                if(temp==k){\\n                    total++;\\n                    temp=0;\\n                }\\n            }\\n            if(total>=m){\\n                ans=mid;\\n                high=mid;\\n            }\\n            else low=mid+1;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940673,
                "title": "java-binary-search-beats-98-79",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m*k){return -1;}\\n        \\n        int left = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : bloomDay){\\n            max = Math.max(i, max);\\n        }\\n        int right = max;\\n        while(left < right){\\n            int mid = left + (right-left)/2;\\n            if(feasible(bloomDay, m, k, mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean feasible(int[] bloomDay, int m, int k, int days){\\n        int count_continuous = 0;\\n        int count_flower = 0;\\n        for(int i : bloomDay){\\n            if(i <= days){\\n                count_continuous ++;\\n                if(count_continuous >= k){\\n                    count_continuous = 0;\\n                    count_flower ++;\\n                }\\n            }else{\\n                count_continuous = 0;\\n            }\\n        }\\n        \\n        return count_flower >= m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m*k){return -1;}\\n        \\n        int left = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : bloomDay){\\n            max = Math.max(i, max);\\n        }\\n        int right = max;\\n        while(left < right){\\n            int mid = left + (right-left)/2;\\n            if(feasible(bloomDay, m, k, mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean feasible(int[] bloomDay, int m, int k, int days){\\n        int count_continuous = 0;\\n        int count_flower = 0;\\n        for(int i : bloomDay){\\n            if(i <= days){\\n                count_continuous ++;\\n                if(count_continuous >= k){\\n                    count_continuous = 0;\\n                    count_flower ++;\\n                }\\n            }else{\\n                count_continuous = 0;\\n            }\\n        }\\n        \\n        return count_flower >= m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664714,
                "title": "c-binary-search-on-answer-detail-explanation",
                "content": "*`!!!Please please like or Upvote  if you find useful : <3`*\\n**Point to Notice :**\\n1. Array must be in same order.\\n2. m is the number of boque and k is the number of flower in each boque => number of flower in the array must be grater than m*k.\\n\\n**Thinking about binary search :**\\n1.  Minimum time to bloom a single flower is the minimum value in the array.\\n2.  Maximum time to bloom all flower is maximum value in the array.\\n3.  Since we know that answer must lie between maximum and minimum value.\\n4.  Here we use binary search b/w max and min and every time you find middle element and go for it.\\n**Helper function:**\\n1. It help to conclude weather we are able to  find  m boque  with k flower each or not .\\n\\n\\n```\\n//CODE:\\n\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>&arr,int m,int k,int mid)\\n    {\\n        int flower=0;\\n        int boque=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<=mid)//checking the flowe which are ready in mid of day\\n            {\\n                flower++;//adding flower var\\n                if(flower==k)//if we get flower ==k we make a boque and add to it.\\n                {\\n                    boque++;\\n                    flower=0;//and making flower count=0;\\n                }\\n            }\\n            else//if we get any array greater than mid then we leave the flower and make flower value=0\\n            {\\n                flower=0;\\n            }\\n        }\\n        if(boque>=m)//checking is we are able to make m boque or not..\\n        {\\n            return 1;\\n            \\n        }\\n        return 0;\\n    }\\n    \\n \\n    int minDays(vector<int>& arr, int m, int k) {\\n        \\n        int n=arr.size();\\n        if(m*k>n)\\n        {\\n            return -1;\\n        }\\n\\t\\t//checking corner cases\\n        \\n        int mini=*min_element(arr.begin(),arr.end());//minimum time\\n        int maxi=*max_element(arr.begin(),arr.end());//maximum time\\n        //applying generic binary seach\\n        int start=mini;\\n        int end=maxi;\\n        int ans=-1;\\n        while(start<end)\\n        {\\n            int mid=(start+end)/2;\\n            if(is_possible(arr,m,k,mid))//checking weather we are able to create m boque or not\\n            {\\n                end=mid;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n                \\n            }\\n        }\\n        return start;\\n        \\n    }\\n    \\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n//CODE:\\n\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>&arr,int m,int k,int mid)\\n    {\\n        int flower=0;\\n        int boque=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<=mid)//checking the flowe which are ready in mid of day\\n            {\\n                flower++;//adding flower var\\n                if(flower==k)//if we get flower ==k we make a boque and add to it.\\n                {\\n                    boque++;\\n                    flower=0;//and making flower count=0;\\n                }\\n            }\\n            else//if we get any array greater than mid then we leave the flower and make flower value=0\\n            {\\n                flower=0;\\n            }\\n        }\\n        if(boque>=m)//checking is we are able to make m boque or not..\\n        {\\n            return 1;\\n            \\n        }\\n        return 0;\\n    }\\n    \\n \\n    int minDays(vector<int>& arr, int m, int k) {\\n        \\n        int n=arr.size();\\n        if(m*k>n)\\n        {\\n            return -1;\\n        }\\n\\t\\t//checking corner cases\\n        \\n        int mini=*min_element(arr.begin(),arr.end());//minimum time\\n        int maxi=*max_element(arr.begin(),arr.end());//maximum time\\n        //applying generic binary seach\\n        int start=mini;\\n        int end=maxi;\\n        int ans=-1;\\n        while(start<end)\\n        {\\n            int mid=(start+end)/2;\\n            if(is_possible(arr,m,k,mid))//checking weather we are able to create m boque or not\\n            {\\n                end=mid;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n                \\n            }\\n        }\\n        return start;\\n        \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266371,
                "title": "easy-binary-search-solution-c",
                "content": "1. n < m*k is to check if the size of  array is less than the number of flowers required.\\n2. As we need to \"minimize the number of days\" so we need to reduce the search space [ ans=mid; high=mid-1]\\n3.  makeBouquet() will check if we can get consecutive flowers of K [ given in the question ] and increase the count of \"bouquet\" variable once \"flower\" count is passed the value of K and return true or false if we can create \"m\" bouquets.\\n4.  if ( !makeBouquet() ) because I want to reduce the search space from maximum value to minimum possible solution.\\n5.  low and high are minimum and maximum number of days.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    using ll=long long;\\n    \\n    bool makeBouquet(vector<int>& bloomDay, int m, int k,int mid){\\n        int flower=0;\\n        int n=bloomDay.size();\\n        int bouquet=0;\\n        for(int i=0;i<n;i++){\\n            if(bloomDay[i]>mid){\\n                flower=0;\\n            }else{\\n                flower++;\\n            }\\n            \\n            if(flower>=k){\\n                bouquet++;\\n                flower=0;\\n            }\\n        }\\n        \\n        return (bouquet>=m);\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int low=*min_element(bloomDay.begin(),bloomDay.end());\\n        int high=*max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        int n=bloomDay.size();\\n        \\n        if((ll)n<((ll)m*k))return -1; \\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            ll mid=(low+high)>>1;\\n            if(!makeBouquet(bloomDay,m,k,mid)){\\n                low=mid+1;\\n            }else{\\n                ans=mid;\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    using ll=long long;\\n    \\n    bool makeBouquet(vector<int>& bloomDay, int m, int k,int mid){\\n        int flower=0;\\n        int n=bloomDay.size();\\n        int bouquet=0;\\n        for(int i=0;i<n;i++){\\n            if(bloomDay[i]>mid){\\n                flower=0;\\n            }else{\\n                flower++;\\n            }\\n            \\n            if(flower>=k){\\n                bouquet++;\\n                flower=0;\\n            }\\n        }\\n        \\n        return (bouquet>=m);\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int low=*min_element(bloomDay.begin(),bloomDay.end());\\n        int high=*max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        int n=bloomDay.size();\\n        \\n        if((ll)n<((ll)m*k))return -1; \\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            ll mid=(low+high)>>1;\\n            if(!makeBouquet(bloomDay,m,k,mid)){\\n                low=mid+1;\\n            }else{\\n                ans=mid;\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229041,
                "title": "c-binary-search-with-simple-english-explanation",
                "content": "Algorithm: \\n The minimum days will lie in between lo = min(bloomDays) and hi = max(bloomDays),\\n as when\\n  i)  m* k = 1, you only need to have 1 flower, which at min will bloom in min(bloomDays) days\\n  ii) m* k = bloomDays.size(){i.e. number of flowers}, you need n flowers, all of which at max will bloom in max(bloomDays) days; \\n\\nlet the ans be Mid = lo + (hi - lo)/2, and check if its possible to have m* k adjacent flowers in mid days.. If possible then search on a smaller space of days for better value ie ** lo to mid **  \\n\\nPossibility Check\\n1. Check for bouquet and Adjacent Count, bouquet>m and adjacent count should be great than or equal to k \\nas long as bloomDays[i] days <= mid, adjacentCount++, if adjacent count >k then bouquet++, adjacentCount = 1;\\nwhen bloomDays[i] days > mid, adjacent count = 0 \\n\\nCode\\n\\n```\\n typedef long long ll;\\n    \\n    bool isPossible(vector<int>& bloomDay, int m, int k, ll x){\\n        ll bouquet = 0, adjacentBloomers = 0;\\n        for(int i = 0; i<bloomDay.size(); i++){\\n            if(bloomDay[i]<=x){\\n                adjacentBloomers++;\\n                if(adjacentBloomers==k){\\n                    bouquet++; \\n                    adjacentBloomers = 0;\\n                }\\n            }else{\\n                adjacentBloomers = 0;\\n            }\\n        }\\n        \\n        return bouquet>=m;\\n        \\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int flowers = bloomDay.size();\\n       \\n        if(k*m >flowers)return -1;\\n        \\n        ll lo = INT_MAX, hi = INT_MIN, mid;\\n       \\n        for(auto& day:bloomDay){\\n            hi = max(hi, (ll)day);\\n            lo = min(lo, (ll)day);\\n        }\\n        \\n        int ans = 1;\\n        if(lo == hi)return lo;\\n        \\n        \\n        while(lo<=hi){\\n            mid = lo+(hi-lo)/2;\\n            if(isPossible(bloomDay, m, k, mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else {\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n typedef long long ll;\\n    \\n    bool isPossible(vector<int>& bloomDay, int m, int k, ll x){\\n        ll bouquet = 0, adjacentBloomers = 0;\\n        for(int i = 0; i<bloomDay.size(); i++){\\n            if(bloomDay[i]<=x){\\n                adjacentBloomers++;\\n                if(adjacentBloomers==k){\\n                    bouquet++; \\n                    adjacentBloomers = 0;\\n                }\\n            }else{\\n                adjacentBloomers = 0;\\n            }\\n        }\\n        \\n        return bouquet>=m;\\n        \\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int flowers = bloomDay.size();\\n       \\n        if(k*m >flowers)return -1;\\n        \\n        ll lo = INT_MAX, hi = INT_MIN, mid;\\n       \\n        for(auto& day:bloomDay){\\n            hi = max(hi, (ll)day);\\n            lo = min(lo, (ll)day);\\n        }\\n        \\n        int ans = 1;\\n        if(lo == hi)return lo;\\n        \\n        \\n        while(lo<=hi){\\n            mid = lo+(hi-lo)/2;\\n            if(isPossible(bloomDay, m, k, mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }else {\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1078516,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {      \\n        int maxDay = 1e9 + 1;\\n        int l = 1, r = maxDay;                            \\n        while(l<r){\\n            int mid = l + (r - l) / 2;                \\n            if(isValid(b, mid, m, k)) r = mid;  \\n            else l = mid + 1;\\n        }\\n        return l != maxDay ? l  : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int m, int k){            \\n        \\n        int flwcnt=0;\\n        int buqcnt=0;\\n        for(int i = 0; i < b.size(); i++)\\n            \\n            if(b[i] <= day){\\n                \\n                flwcnt++;\\n                if(flwcnt ==k) flwcnt = 0, buqcnt++;\\n                if(buqcnt == m) return true;\\n                \\n                \\n            }else \\n                flwcnt=0;   \\n        \\n        \\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {      \\n        int maxDay = 1e9 + 1;\\n        int l = 1, r = maxDay;                            \\n        while(l<r){\\n            int mid = l + (r - l) / 2;                \\n            if(isValid(b, mid, m, k)) r = mid;  \\n            else l = mid + 1;\\n        }\\n        return l != maxDay ? l  : -1;\\n    }\\n    \\nprivate:\\n    bool isValid(const vector<int>& b, int day, int m, int k){            \\n        \\n        int flwcnt=0;\\n        int buqcnt=0;\\n        for(int i = 0; i < b.size(); i++)\\n            \\n            if(b[i] <= day){\\n                \\n                flwcnt++;\\n                if(flwcnt ==k) flwcnt = 0, buqcnt++;\\n                if(buqcnt == m) return true;\\n                \\n                \\n            }else \\n                flwcnt=0;   \\n        \\n        \\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990569,
                "title": "java-iterative-binary-search-o-m-log-n-easy-to-understand",
                "content": "**Time Complexity: O(m * log n)**\\nm = length of bloomDay array\\nn = (maximum element of bloomDay - minimum element of bloomDay)\\n\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k){\\n        int low = Integer.MAX_VALUE; int high = Integer.MIN_VALUE;\\n        for(int d : bloomDay){\\n            low = Math.min(low, d);\\n            high = Math.max(high, d);\\n        }\\n\\n        int result = -1;\\n\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n\\n            if(isSufficient(mid, bloomDay, m, k)){ // Check if (days = mid) will be sufficient to make bouquets\\n                result = mid;\\n                high = mid - 1;\\n            }\\n            else { // If not sufficient then go to right side to check with greater number of days\\n                low = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public boolean isSufficient(int day, int[] bloomDay, int m, int k){\\n        int result = 0; int counter = 0;\\n\\n        for(int i = 0; i < bloomDay.length; i++){\\n            if(bloomDay[i] <= day && counter < k){\\n                counter++;\\n            }\\n            else if(bloomDay[i] > day && counter > 0){\\n                counter = 0;\\n            }\\n\\n            if(counter >= k){\\n                result++;\\n                counter = 0;\\n            }\\n        }\\n        return result >= m;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k){\\n        int low = Integer.MAX_VALUE; int high = Integer.MIN_VALUE;\\n        for(int d : bloomDay){\\n            low = Math.min(low, d);\\n            high = Math.max(high, d);\\n        }\\n\\n        int result = -1;\\n\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n\\n            if(isSufficient(mid, bloomDay, m, k)){ // Check if (days = mid) will be sufficient to make bouquets\\n                result = mid;\\n                high = mid - 1;\\n            }\\n            else { // If not sufficient then go to right side to check with greater number of days\\n                low = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public boolean isSufficient(int day, int[] bloomDay, int m, int k){\\n        int result = 0; int counter = 0;\\n\\n        for(int i = 0; i < bloomDay.length; i++){\\n            if(bloomDay[i] <= day && counter < k){\\n                counter++;\\n            }\\n            else if(bloomDay[i] > day && counter > 0){\\n                counter = 0;\\n            }\\n\\n            if(counter >= k){\\n                result++;\\n                counter = 0;\\n            }\\n        }\\n        return result >= m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852229,
                "title": "java-dp-dfs-defeated-by-mle",
                "content": "83 / 91 test cases passed.\\nStatus: Memory Limit Exceeded\\n```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    HashMap<Integer, Integer> bloom = new HashMap<>();\\n\\t// days required for bouquet [start, start+k-1]\\n\\t\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        Integer[] days = new Integer[bloomDay.length];\\n        for(int i = 0; i < n; i++){\\n            days[i] = bloomDay[i];\\n        }\\n        \\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int i = 0; i < k; i++){\\n            pq.add(days[i]);\\n        }\\n        bloom.put(0, pq.peek());\\n        \\n        for(int i = k; i < n; i++){\\n            pq.remove(days[i-k]);\\n            pq.add(days[i]);\\n            bloom.put(i-k+1, pq.peek());\\n        }\\n        dp = new Integer [m+1][n+1];\\n        int ans = dfs(m, k, 0);\\n        if(ans == Integer.MAX_VALUE) return -1;\\n        return ans;\\n    }\\n    \\n    int dfs(int m, int k, int flowerIdx){\\n         if(m == 0)\\n            return 0;\\n        \\n         if(bloom.get(flowerIdx) == null) \\n             return Integer.MAX_VALUE;\\n        \\n         if(dp[m][flowerIdx] != null)\\n             return dp[m][flowerIdx];\\n        \\n         int localMin = Math.min(\\n         //take\\n         Math.max(dfs(m-1, k, flowerIdx+k), bloom.get(flowerIdx)), \\n         //no take\\n         dfs(m, k, flowerIdx+1));\\n        \\n         dp[m][flowerIdx] = localMin;\\n         return localMin;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n    Integer[][] dp;\\n    HashMap<Integer, Integer> bloom = new HashMap<>();\\n\\t// days required for bouquet [start, start+k-1]\\n\\t\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        Integer[] days = new Integer[bloomDay.length];\\n        for(int i = 0; i < n; i++){\\n            days[i] = bloomDay[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 851134,
                "title": "binary-search-intuition-and-theory-explained-c-implementation",
                "content": "**Basic Intuition**\\n\\n* First of all we need to observe that we can make atmost floor(total no of flowers / k) and hence if m is greater than this value then for sure the answer is -1.\\n\\n* Second Lets think of the Intuition for the why binary Search ? Lets say I need to check that If I would be able to have the goal completed with **x days**, lets assume for now the answer is yes, then for sure I would be able to do the same at **x+1 days** and the justification being that next day I would be atleast having the no of already bloomed flowers and hence as the days increase the no of flowers are going to just increase and hence it would be very much possible to do the job tommorow provided I can do it today\\n\\n* This would make the range of the our answer to look something like **BBBBBBGGGGGGG** where **G** stands for a good ans(possible to do within this much days) and **B** stands for bad ans(not possible to do so) and hence, If I am at a **G** right now for sure the next all elements are **G** only and hence I need to find the first answer such that its itself is **G** and the element just before this element would be **B**. So kinda I need to find the border of the same.\\n\\n**Explaining the Implementation**\\n* Lets take two pointers mi which is ryt now at a bad answer(for simplification taking it 0 because it would never be able to do the job in 0 days) and ma which is ryt now at a good answer(INT_MAX is a simple justification because by this day I would have all my flowers bloomed and hence It is for sure a good answer\\n\\n* Now Just Implementing a classic binary search, take the mid element of good-bad sequence, if the current mid is a good answer set the ma pointer to good (because for sure all the answer in front of this are good only) and if the case if opposite then set mi pointer to mid (because for sure all answer before this mid are also bad) \\n\\n* Do this until mi and ma and adjacent (Thus find the border of our good-bad sequence)\\n\\n* In the end my ma pointer would be pointing to the least good value and mi pointer would be pointing to the most bad value \\n\\n* It is easy to see that in the end ma pointer is our required answer and hence return the ma pointer \\n\\n* Implement the check function to justify the current good-bad condition of the mid for our own because not a big deal to imagine\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n\\tbool isPos(int x, int m, int k, vector<int> &b) {\\n\\t\\tint cur = 0;\\n\\t\\tint tot = 0;\\n\\t\\tfor (int &i : b) {\\n\\t\\t\\tif (i > x) tot += cur / k, cur = 0;\\n\\t\\t\\telse cur++;\\n\\t\\t}\\n\\t\\treturn tot >= m;\\n\\t}\\n    \\n\\tint minDays(vector<int>& b, int m, int k) {\\n\\t\\tif (b.size() / k < m) return -1;\\n\\t\\tb.push_back(INT_MAX);\\n\\n\\t\\tint mi = 0, ma = INT_MAX;\\n\\t\\twhile (mi + 1 < ma) {\\n\\t\\t\\tint mid = mi + (ma - mi) / 2;\\n\\t\\t\\tif (isPos(mid, m, k, b)) ma = mid;\\n\\t\\t\\telse mi = mid;\\n\\t\\t}\\n\\n\\t\\treturn ma;\\n\\t}\\n};\\n```\\n**Content Regarding Binary Search**\\n[Just register and open the Binary Search section and start practising (PS : Its not related to me in anyway and is free)](https://codeforces.com/edu/courses)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool isPos(int x, int m, int k, vector<int> &b) {\\n\\t\\tint cur = 0;\\n\\t\\tint tot = 0;\\n\\t\\tfor (int &i : b) {\\n\\t\\t\\tif (i > x) tot += cur / k, cur = 0;\\n\\t\\t\\telse cur++;\\n\\t\\t}\\n\\t\\treturn tot >= m;\\n\\t}\\n    \\n\\tint minDays(vector<int>& b, int m, int k) {\\n\\t\\tif (b.size() / k < m) return -1;\\n\\t\\tb.push_back(INT_MAX);\\n\\n\\t\\tint mi = 0, ma = INT_MAX;\\n\\t\\twhile (mi + 1 < ma) {\\n\\t\\t\\tint mid = mi + (ma - mi) / 2;\\n\\t\\t\\tif (isPos(mid, m, k, b)) ma = mid;\\n\\t\\t\\telse mi = mid;\\n\\t\\t}\\n\\n\\t\\treturn ma;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736440,
                "title": "python-0-nlog-n-using-binary-search-with-explanation",
                "content": "```\\nclass Solution:\\n    def minDays(self, days: List[int], m: int, k: int) -> int:\\n        \\n        n = len(days)\\n        \\n        \\n        if (m*k)>n:\\n            return -1\\n        \\n        def check(num):\\n            \\n            ## This function will return whether in \\'num\\' days, can we form the \\n            ## required number of bouquets or not.\\n            \\n            ## the following array will tell whether the ith flower \\n            ## will bloom in num days or not\\n            yes_no_array = [1 if i<=num else 0 for i in days] \\n            \\n            ## once this is done, just find whether there are m groups\\n            ## in the above list having k consecutive 1s.\\n            \\n            if sum(yes_no_array)<(m*k):\\n                return 0\\n            \\n            total_found = 0\\n            i = 0\\n            \\n            while i<n:\\n                \\n                total = 0\\n                    \\n                while i<n and yes_no_array[i] == 1:\\n                        \\n                    total+=1\\n                    \\n                    \\n                    if total == k:\\n\\t\\t\\t\\t\\t## consecutive k flowers have been collected \\n                        ## increase the total flowers that can be formed\\n                        total_found += 1\\n                        \\n\\t\\t\\t\\t\\t\\t## if the requirement has been satisfied, it is possible to \\n\\t\\t\\t\\t\\t\\t## make the required bouquets in \\'num\\' days, hence return 1\\n                        if total_found == m:\\n                            return 1\\n                        \\n                        break\\n                        \\n                    i+=1\\n                    \\n                i+=1\\n                \\n                \\n            return 0\\n                \\n\\n        \\n        low = min(days)\\n        high = max(days)\\n        \\n        ## the max possible answer is high, no matter what the case is\\n        current_ans = high\\n        \\n        \\n        while low<=high:\\n            \\n            mid = (low+high)//2\\n            \\n            if check(mid):\\n                \\n                current_ans = min(current_ans, mid)\\n                high = mid-1\\n                \\n            else:\\n                \\n                low = mid+1\\n                \\n                \\n        return current_ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, days: List[int], m: int, k: int) -> int:\\n        \\n        n = len(days)\\n        \\n        \\n        if (m*k)>n:\\n            return -1\\n        \\n        def check(num):\\n            \\n            ## This function will return whether in \\'num\\' days, can we form the \\n            ## required number of bouquets or not.\\n            \\n            ## the following array will tell whether the ith flower \\n            ## will bloom in num days or not\\n            yes_no_array = [1 if i<=num else 0 for i in days] \\n            \\n            ## once this is done, just find whether there are m groups\\n            ## in the above list having k consecutive 1s.\\n            \\n            if sum(yes_no_array)<(m*k):\\n                return 0\\n            \\n            total_found = 0\\n            i = 0\\n            \\n            while i<n:\\n                \\n                total = 0\\n                    \\n                while i<n and yes_no_array[i] == 1:\\n                        \\n                    total+=1\\n                    \\n                    \\n                    if total == k:\\n\\t\\t\\t\\t\\t## consecutive k flowers have been collected \\n                        ## increase the total flowers that can be formed\\n                        total_found += 1\\n                        \\n\\t\\t\\t\\t\\t\\t## if the requirement has been satisfied, it is possible to \\n\\t\\t\\t\\t\\t\\t## make the required bouquets in \\'num\\' days, hence return 1\\n                        if total_found == m:\\n                            return 1\\n                        \\n                        break\\n                        \\n                    i+=1\\n                    \\n                i+=1\\n                \\n                \\n            return 0\\n                \\n\\n        \\n        low = min(days)\\n        high = max(days)\\n        \\n        ## the max possible answer is high, no matter what the case is\\n        current_ans = high\\n        \\n        \\n        while low<=high:\\n            \\n            mid = (low+high)//2\\n            \\n            if check(mid):\\n                \\n                current_ans = min(current_ans, mid)\\n                high = mid-1\\n                \\n            else:\\n                \\n                low = mid+1\\n                \\n                \\n        return current_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715925,
                "title": "python-100-speed-o-n-log-n-time-o-n-space",
                "content": "**Python - 100% Speed - O(n log n) time, O(n) space**\\n\\nThe code below solves the problem with 100% speed in Python. It might seem intricate, but its working principles are fairly simple:\\n1. Start by assuming that the highest \"day count\" is our best solution.\\n2. Assign a subset-ID to each element of \"bloomDay\", such that each subset is contiguous (and able to hold at least \"k\" flowers)\\n3. Sort the dates, and create an O(n) for-loop where we try to remove the dates one-by-one (checking the feasibility).\\n4. For each date, we split our subsets and remove any trailing pieces unable to hold \"k\" flowers. To keep our O(n) time complexity in the for-loop, we track the boundaries of the subsets using a global dictionary (id_ij) that we constantly update.\\n\\n5. Additionally, we track two scalar variables called \"counting\" and \"residual\", which contain the number of available flower slots and any \"residual\" places in the subsets which can\\'t be fully occupied (E.g. residual=1 for a subset of length=8 and k=7). \\n\\n6. We check the feasibility of decreasing our max. \"day count\" and update the result.\\n\\n7. If the numbers of available slots is too low (<m*k), we break the loop and exit.\\n\\nI hope the explanation was helpful. Cheers,\\n```\\nfmax  = lambda x,y  : x if x>y else y # this is 33%+ faster than the standard \"max\" function\\nfmin  = lambda x,y  : x if x<y else y\\nclass Solution:\\n    def minDays(self, bloomDay, m: int, k: int) -> int:\\n        L0 = len(bloomDay)\\n        if (m*k)>L0 or (not L0) or (m<1) or (k<1):\\n            return -1\\n        if (m*k)==L0:\\n            return max(*bloomDay) if L0>1 else bloomDay[0]\\n        #\\n        get_res = lambda a,b: (b-a+1)%k\\n        #\\n        ids   = [ 1 for _ in bloomDay ]\\n        id_ij = { 1 : [0,L0-1] }\\n        residual = get_res(0,L0-1)\\n        last  = 1\\n        #\\n        ordered = sorted([ (x,i) for i,x in enumerate(bloomDay) ])\\n        #\\n        result   = ordered[-1][0]\\n        counting = L0\\n        #\\n        for i0 in reversed(range(L0)):\\n            x,i = ordered[i0]\\n            # Get rid of each max. values, one-by-one\\n            id0 = ids[i]\\n            if id0:\\n                a,b       = id_ij[id0]\\n                residual -= get_res(a,b)\\n                ids[i]    = None\\n                counting -= 1\\n                #\\n                # Check Left Side\\n                if (i-1-a+1)>=k:\\n                    id_ij[id0] = a,i-1\\n                    residual  += get_res(a,i-1)\\n                else:\\n                    id_ij.pop(id0)\\n                    counting -= len(    range(a,i)    )\\n                    for j in range(a,i):\\n                        ids[j] = None\\n                #\\n                # Check Right Side\\n                if (b-(i+1)+1)>=k:\\n                    new = last = last + 1\\n                    id_ij[new] = i+1,b\\n                    residual  += get_res(i+1,b)\\n                else:\\n                    new = None\\n                    counting -= len( range(i+1,b+1) )\\n                #\\n                for j in range(i+1,b+1):\\n                    ids[j] = new\\n            #\\n            if (counting-residual)>=(m*k) and (i0>0):\\n                result = ordered[i0-1][0]\\n            elif counting<(m*k):\\n                break\\n        #\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfmax  = lambda x,y  : x if x>y else y # this is 33%+ faster than the standard \"max\" function\\nfmin  = lambda x,y  : x if x<y else y\\nclass Solution:\\n    def minDays(self, bloomDay, m: int, k: int) -> int:\\n        L0 = len(bloomDay)\\n        if (m*k)>L0 or (not L0) or (m<1) or (k<1):\\n            return -1\\n        if (m*k)==L0:\\n            return max(*bloomDay) if L0>1 else bloomDay[0]\\n        #\\n        get_res = lambda a,b: (b-a+1)%k\\n        #\\n        ids   = [ 1 for _ in bloomDay ]\\n        id_ij = { 1 : [0,L0-1] }\\n        residual = get_res(0,L0-1)\\n        last  = 1\\n        #\\n        ordered = sorted([ (x,i) for i,x in enumerate(bloomDay) ])\\n        #\\n        result   = ordered[-1][0]\\n        counting = L0\\n        #\\n        for i0 in reversed(range(L0)):\\n            x,i = ordered[i0]\\n            # Get rid of each max. values, one-by-one\\n            id0 = ids[i]\\n            if id0:\\n                a,b       = id_ij[id0]\\n                residual -= get_res(a,b)\\n                ids[i]    = None\\n                counting -= 1\\n                #\\n                # Check Left Side\\n                if (i-1-a+1)>=k:\\n                    id_ij[id0] = a,i-1\\n                    residual  += get_res(a,i-1)\\n                else:\\n                    id_ij.pop(id0)\\n                    counting -= len(    range(a,i)    )\\n                    for j in range(a,i):\\n                        ids[j] = None\\n                #\\n                # Check Right Side\\n                if (b-(i+1)+1)>=k:\\n                    new = last = last + 1\\n                    id_ij[new] = i+1,b\\n                    residual  += get_res(i+1,b)\\n                else:\\n                    new = None\\n                    counting -= len( range(i+1,b+1) )\\n                #\\n                for j in range(i+1,b+1):\\n                    ids[j] = new\\n            #\\n            if (counting-residual)>=(m*k) and (i0>0):\\n                result = ordered[i0-1][0]\\n            elif counting<(m*k):\\n                break\\n        #\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709880,
                "title": "java-faster-than-99-32-100-better-memory-commented-code",
                "content": "class Solution {\\n    \\n\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n        \\n\\t\\t// If No. of flowers required are less than no. of flowers to bloom, then bouquet impossible\\n        if(bloomDay.length < m*k)\\n            return -1;\\n        \\n        int left = 1, right = findMax(bloomDay); // right is set to last day a flower blooms\\n        \\n        while(left <= right)  {\\n            \\n            int mid = left + (right - left)/2;\\n            \\n\\t\\t\\t// if bouquets possible on day i, then right = i - 1\\n            if(isPossible(bloomDay, mid, m, k)) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        \\n        }\\n        \\n        return left;    \\n        \\n        \\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int day, int m, int k) {\\n        \\n        int bouquets = 0; // No. of bouquets\\n        int countAdjacent = 0; // Adjacent flowers counter\\n        \\n        for(int blooms : bloomDay) {\\n           \\n\\t\\t   // if flower has bloomed, increment countAdjacent\\n\\t\\t   if(blooms <= day) {\\n                countAdjacent++;\\n                \\n\\t\\t\\t\\t// When k adjacent flowers bloomed, increment bouquets\\n\\t\\t\\t\\tif(countAdjacent == k) {\\n                    bouquets++;\\n                    countAdjacent = 0; // reset countAdjacent\\n                }\\n           \\n\\t\\t   } else {\\n                countAdjacent = 0; // If found a gap in adjacent flowers, reset countAdjacent\\n            }\\n        }\\n        \\n        return bouquets >= m; // if no. of bouquets possible >= required bouquets\\n    }\\n    \\n\\t// Find the day the last flower blooms\\n    private int findMax(int[] bloomDay) {\\n        int max = Integer.MIN_VALUE;\\n        for(int day : bloomDay) {\\n            if(max < day)\\n                max = day;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    \\n\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n        \\n\\t\\t// If No. of flowers required are less than no. of flowers to bloom, then bouquet impossible\\n        if(bloomDay.length < m*k)\\n            return -1;\\n        \\n        int left = 1, right = findMax(bloomDay); // right is set to last day a flower blooms\\n        \\n        while(left <= right)  {\\n            \\n            int mid = left + (right - left)/2;\\n            \\n\\t\\t\\t// if bouquets possible on day i, then right = i - 1\\n            if(isPossible(bloomDay, mid, m, k)) {\\n                right = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 692488,
                "title": "easy-binary-search-with-detailed-explanation-in-c",
                "content": "The Idea is to perform binary search between  the values of array blooms day with left limit equals to the minimum value and r equals to the largest value in given array and then checking for each value wether we have m groups of k size ready if this is the case then we lower the r value to mid or else if more days are required then the answer is defineately greater then the mid therefore l is assigned mid +1.Continuing the loop until we reach the minimum value for which m groups of k flowers could be formed.\\n\\nAttaching the code for better understanding\\n\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& nums, int m, int k)\\n    {\\n        int n=nums.size();\\n        if(n<m*k)\\n            return -1;\\n        int l=nums[min_element(nums.begin(),nums.end())-nums.begin()];\\n        int r=nums[max_element(nums.begin(),nums.end())-nums.begin()];\\n        while(l<r)\\n        {\\n            int mid=(r-l)/2+l;\\n            int z=0,cnt=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]<=mid)\\n                    z++;\\n                else\\n                    z=0;\\n                if(z==k)\\n                {\\n                    z=0;\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>=m)\\n                r=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\nIf you do like please upvote :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& nums, int m, int k)\\n    {\\n        int n=nums.size();\\n        if(n<m*k)\\n            return -1;\\n        int l=nums[min_element(nums.begin(),nums.end())-nums.begin()];\\n        int r=nums[max_element(nums.begin(),nums.end())-nums.begin()];\\n        while(l<r)\\n        {\\n            int mid=(r-l)/2+l;\\n            int z=0,cnt=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]<=mid)\\n                    z++;\\n                else\\n                    z=0;\\n                if(z==k)\\n                {\\n                    z=0;\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>=m)\\n                r=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691096,
                "title": "optimal-o-n-algorithm-beat-100",
                "content": "Use divide and conquer, and shrink intervals.\\n```\\nconst int N=100005,inf=~0u>>1;\\nint a[N],b[N];\\nclass Solution {\\npublic:\\n    int minDays(vector<int> &v, int m, int k) {\\n        int n=v.size(),l=0,l1,t,s,c,ans=-1; if (m*k>n)return -1;\\n\\t\\tfor (int i=0;i<n;++i)a[l]=v[i],b[l++]=1;\\n\\t\\twhile (1){\\n\\t\\t\\tdo{t=a[rand()%l];}while (t==0||t==inf);\\n\\t\\t\\ts=c=0;\\n\\t\\t\\tfor (int i=0;i<l;++i)\\n\\t\\t\\t\\tif (a[i]<=t)c+=b[i];\\n\\t\\t\\t\\telse s+=c/k,c=0;\\n\\t\\t\\ts+=c/k;\\n\\t\\t\\tif (s>=m){\\n\\t\\t\\t\\tans=t;\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]>=t)a[i]=inf;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]<=t)a[i]=0;\\n\\t\\t\\t}\\n\\t\\t\\tl1=0;\\n\\t\\t\\tfor (int i=1;i<l;++i)\\n\\t\\t\\t\\tif (a[i]==a[l1])b[l1]+=b[i];\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t++l1,a[l1]=a[i],b[l1]=b[i];\\n\\t\\t\\t\\t\\tif (a[l1]==inf&&a[l1-1]==0&&l1>=2&&a[l1-2]==inf)m-=b[l1-1]/k,l1-=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\tl=l1+1;\\n\\t\\t\\tif (l<4){\\n\\t\\t\\t\\tl1=0;\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]>0&&a[i]<inf)l1=1;\\n\\t\\t\\t\\tif (!l1)return ans;\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N=100005,inf=~0u>>1;\\nint a[N],b[N];\\nclass Solution {\\npublic:\\n    int minDays(vector<int> &v, int m, int k) {\\n        int n=v.size(),l=0,l1,t,s,c,ans=-1; if (m*k>n)return -1;\\n\\t\\tfor (int i=0;i<n;++i)a[l]=v[i],b[l++]=1;\\n\\t\\twhile (1){\\n\\t\\t\\tdo{t=a[rand()%l];}while (t==0||t==inf);\\n\\t\\t\\ts=c=0;\\n\\t\\t\\tfor (int i=0;i<l;++i)\\n\\t\\t\\t\\tif (a[i]<=t)c+=b[i];\\n\\t\\t\\t\\telse s+=c/k,c=0;\\n\\t\\t\\ts+=c/k;\\n\\t\\t\\tif (s>=m){\\n\\t\\t\\t\\tans=t;\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]>=t)a[i]=inf;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]<=t)a[i]=0;\\n\\t\\t\\t}\\n\\t\\t\\tl1=0;\\n\\t\\t\\tfor (int i=1;i<l;++i)\\n\\t\\t\\t\\tif (a[i]==a[l1])b[l1]+=b[i];\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t++l1,a[l1]=a[i],b[l1]=b[i];\\n\\t\\t\\t\\t\\tif (a[l1]==inf&&a[l1-1]==0&&l1>=2&&a[l1-2]==inf)m-=b[l1-1]/k,l1-=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\tl=l1+1;\\n\\t\\t\\tif (l<4){\\n\\t\\t\\t\\tl1=0;\\n\\t\\t\\t\\tfor (int i=0;i<l;++i)if (a[i]>0&&a[i]<inf)l1=1;\\n\\t\\t\\t\\tif (!l1)return ans;\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686823,
                "title": "python-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        ## Similar to Leetcode: 410. Split Array Largest Sum ##\\n        ## Similar to Leetcode: 875. Koko Eating Bananas ##\\n        \\n        ## TIME COMPLEXICITY : O(NlogN) ##\\n        ## SPACE COMPLEXICITY : O(1) ##\\n        \\n        # How many bouquets are possible with t days ?\\n        def bouquet_count( t ):\\n            count = 0\\n            res = 0\\n            for i in range(n):\\n                if bloomDay[i] <= t:    \\n                    count += 1\\n                    if count == k:      # if consecutive k days are less than t. we count it as one Valid bouquet formation\\n                        count = 0\\n                        res += 1\\n                else:\\n                    count = 0           # watchout, reset count if even one day is more than t.\\n            return res\\n        \\n        n = len(bloomDay)\\n        if m * k > n: return -1\\n        \\n        lo, hi = min(bloomDay), max(bloomDay)\\n        while(lo <= hi):\\n            mid = lo + (hi - lo)//2\\n            if bouquet_count(mid) >= m:\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return lo                       # return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        ## RC ##\\n        ## APPROACH : BINARY SEARCH ##\\n        ## Similar to Leetcode: 410. Split Array Largest Sum ##\\n        ## Similar to Leetcode: 875. Koko Eating Bananas ##\\n        \\n        ## TIME COMPLEXICITY : O(NlogN) ##\\n        ## SPACE COMPLEXICITY : O(1) ##\\n        \\n        # How many bouquets are possible with t days ?\\n        def bouquet_count( t ):\\n            count = 0\\n            res = 0\\n            for i in range(n):\\n                if bloomDay[i] <= t:    \\n                    count += 1\\n                    if count == k:      # if consecutive k days are less than t. we count it as one Valid bouquet formation\\n                        count = 0\\n                        res += 1\\n                else:\\n                    count = 0           # watchout, reset count if even one day is more than t.\\n            return res\\n        \\n        n = len(bloomDay)\\n        if m * k > n: return -1\\n        \\n        lo, hi = min(bloomDay), max(bloomDay)\\n        while(lo <= hi):\\n            mid = lo + (hi - lo)//2\\n            if bouquet_count(mid) >= m:\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return lo                       # return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686659,
                "title": "python-iterative-not-binary-search",
                "content": "The simpliest solution would be checking the possibility of collecting bouquets at every day when any flower blooms. However this solution is too time consuming. A lot of people used binary search so that they don\\'t have to check every day, but unfourtunately I didn\\'t think about it during the contest. I\\'ve decided to post my way of overcoming time problem to show, that even if you **forgot about existence of binary search** like I did, you can still solve the problem!\\n\\nThe main idea is to check every day something blooms and update the information from previous day. I\\'ve decided to create a list called `flowers_left_from`, which is the same length as `bloomDay`. If there is a flower on `i`th position, then `flowers_left_from` is equal to the number of consecutive flowers to the left modulo `k` + 1, otherwise 0.\\nFor example, if 1 is a flower, 0 is non-flower, the garden is in state [1, 1, 1, 1, 0, 0, 1] and k = 2 then `flowers_left_from` would be [1, 2, 1, 2, 0, 0, 1]. \\nThis list represents the best way to fit bouquets: if there is a group of more that `k` consecutive flowers we take first `k` as a bouquet, then second `k`  as a bouquet if we can fit and so on, therefore the number of elements equal to `k` in `flowers_left_from` is the max number of bouquets from this garden. Now I want to check all days something bloomed and update this list.\\n\\n\\n```\\ndef minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n\\tif m * k > len(bloomDay):\\n\\t\\treturn -1\\n\\tflowers_left_from = [0] * len(bloomDay)\\n\\tbloom_day_dict = defaultdict(list)\\n\\tbouquets = 0\\n\\tfor i in range(len(bloomDay)):\\n\\t\\tbloom_day_dict[bloomDay[i]].append(i)\\n\\tbloomDaySorted = sorted([[day, bloom_day_dict[day]] for day in bloom_day_dict])\\n```\\n\\nI\\'ve created `bloomDaySorted` which is an ordered list, every element there is a pair [day, (flowers that bloomed that day)]. `bouquets` is a variable of number of bouquets now, that will be updated.\\n\\n```\\n\\tfor day, flower_list in bloomDaySorted:\\n\\t\\tfor flower in flower_list:\\n\\t\\t\\tbefore = flowers_left_from[flower]\\n\\t\\t\\tif flower == 0:\\n\\t\\t\\t\\tflowers_left_from[flower] = 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tflowers_left_from[flower] = flowers_left_from[flower - 1] % k + 1\\n\\t\\t\\tif before == k and flowers_left_from[flower] != k:\\n\\t\\t\\t\\tbouquets -= 1\\n\\t\\t\\tif before != k and flowers_left_from[flower] == k:\\n\\t\\t\\t\\tbouquets += 1\\n```\\n\\nNow for each day something bloomed we update `flowers_left from` the following way: if `flowers_left_from[flower]` is now blooming, then we put correct value there. After this operation number of bouquets could change, so I check if this value stopped being `k` or became `k`. \\n\\n```\\n\\t\\t\\tfor i in range(flower + 1, len(flowers_left_from)):\\n\\t\\t\\t\\tbefore = flowers_left_from[i]\\n\\n\\t\\t\\t\\tif flowers_left_from[i] == 0:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tflowers_left_from[i] = flowers_left_from[i - 1] % k + 1\\n\\n\\t\\t\\t\\tif before == k and flowers_left_from[i] != k:\\n\\t\\t\\t\\t\\tbouquets -= 1\\n\\t\\t\\t\\tif before != k and flowers_left_from[i] == k:\\n\\t\\t\\t\\t\\tbouquets += 1\\n\\t\\tif bouquets >= m:\\n\\t\\t\\treturn day \\n```\\n\\nThen I update all flowers to the right until I don\\'t meet a non-flower. And also check if number of `k`\\'s changed. After all updates for this day I check if number of bouquets is equal to at least `m` and return `day` if this happened.\\n\\nP.S. I know this solution is worse than binary search in every possible aspect. I wanted to share it because I saw a comment below someone\\'s binary search solution asking \"How do you even think of binary search here?\" I wanted to show, that even if you didn\\'t come up with binary search idea, you still could think of something else :)\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n\\tif m * k > len(bloomDay):\\n\\t\\treturn -1\\n\\tflowers_left_from = [0] * len(bloomDay)\\n\\tbloom_day_dict = defaultdict(list)\\n\\tbouquets = 0\\n\\tfor i in range(len(bloomDay)):\\n\\t\\tbloom_day_dict[bloomDay[i]].append(i)\\n\\tbloomDaySorted = sorted([[day, bloom_day_dict[day]] for day in bloom_day_dict])\\n```\n```\\n\\tfor day, flower_list in bloomDaySorted:\\n\\t\\tfor flower in flower_list:\\n\\t\\t\\tbefore = flowers_left_from[flower]\\n\\t\\t\\tif flower == 0:\\n\\t\\t\\t\\tflowers_left_from[flower] = 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tflowers_left_from[flower] = flowers_left_from[flower - 1] % k + 1\\n\\t\\t\\tif before == k and flowers_left_from[flower] != k:\\n\\t\\t\\t\\tbouquets -= 1\\n\\t\\t\\tif before != k and flowers_left_from[flower] == k:\\n\\t\\t\\t\\tbouquets += 1\\n```\n```\\n\\t\\t\\tfor i in range(flower + 1, len(flowers_left_from)):\\n\\t\\t\\t\\tbefore = flowers_left_from[i]\\n\\n\\t\\t\\t\\tif flowers_left_from[i] == 0:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tflowers_left_from[i] = flowers_left_from[i - 1] % k + 1\\n\\n\\t\\t\\t\\tif before == k and flowers_left_from[i] != k:\\n\\t\\t\\t\\t\\tbouquets -= 1\\n\\t\\t\\t\\tif before != k and flowers_left_from[i] == k:\\n\\t\\t\\t\\t\\tbouquets += 1\\n\\t\\tif bouquets >= m:\\n\\t\\t\\treturn day \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 686507,
                "title": "to-those-who-don-t-know-why-binary-search-here-is-my-explanation-c",
                "content": "This is my code during the contest. It gives a TLE. \\nStatus: TLE\\nApproach: \\nI will add the days in a priority queue and take the longest day from it and check (validate) whether we can make m bouquets of size k.\\n```\\nclass Solution {\\npublic:\\n    bool canWeMake(vector<int> & bloomDay, int m, int k, int t){\\n        int count = 0;\\n        \\n       for(int i = 0; i < bloomDay.size(); i++){\\n           \\n           if(bloomDay[i] <= t){\\n               count++;\\n               if(count == k){\\n                   count = 0;\\n                   m--;\\n                   if(!m) return true;\\n               }\\n           }\\n           else{\\n               count = 0;\\n           }\\n       }\\n        return !m ? true : false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        priority_queue<int> pq(bloomDay.begin(), bloomDay.end());\\n        int res = -1;\\n        while(!pq.empty()){\\n            auto t = pq.top();\\n            if(canWeMake(bloomDay, m, k, t)){\\n                res = t;\\n            }\\n            pq.pop();\\n        }\\n        return res == -1 ? -1 : res;\\n    }\\n};\\n```\\nStatus: Accepted\\nWrote this after reading some discuss posts. People solved it using binary search.\\nI am confused. According to my knowledge binary search can be used if the list is sorted. Here the days are not in sorted order.\\nThen How?\\nThere is little difference between both codes.\\nIn the first one, I am trying to validate all the possible days.\\nIn the second one, I am validating the middle day. If the day can make m bouquets of size k then we will look at the day less than it or else i will increase the day.\\n```\\nclass Solution {\\npublic:\\n    bool canWeMake(vector<int> & bloomDay, int m, int k, int t){\\n        int count = 0;\\n        \\n       for(int i = 0; i < bloomDay.size(); i++){\\n           \\n           if(bloomDay[i] <= t){\\n               count++;\\n               if(count == k){\\n                   count = 0;\\n                   m--;\\n                   if(!m) return true;\\n               }\\n           }\\n           else{\\n               count = 0;\\n           }\\n       }\\n        return !m ? true : false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int left = *min_element(bloomDay.begin(), bloomDay.end());\\n        int right = *max_element(bloomDay.begin(), bloomDay.end());\\n        if (m * k > bloomDay.size())\\n        return -1;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canWeMake(bloomDay, m, k, mid)){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canWeMake(vector<int> & bloomDay, int m, int k, int t){\\n        int count = 0;\\n        \\n       for(int i = 0; i < bloomDay.size(); i++){\\n           \\n           if(bloomDay[i] <= t){\\n               count++;\\n               if(count == k){\\n                   count = 0;\\n                   m--;\\n                   if(!m) return true;\\n               }\\n           }\\n           else{\\n               count = 0;\\n           }\\n       }\\n        return !m ? true : false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        priority_queue<int> pq(bloomDay.begin(), bloomDay.end());\\n        int res = -1;\\n        while(!pq.empty()){\\n            auto t = pq.top();\\n            if(canWeMake(bloomDay, m, k, t)){\\n                res = t;\\n            }\\n            pq.pop();\\n        }\\n        return res == -1 ? -1 : res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canWeMake(vector<int> & bloomDay, int m, int k, int t){\\n        int count = 0;\\n        \\n       for(int i = 0; i < bloomDay.size(); i++){\\n           \\n           if(bloomDay[i] <= t){\\n               count++;\\n               if(count == k){\\n                   count = 0;\\n                   m--;\\n                   if(!m) return true;\\n               }\\n           }\\n           else{\\n               count = 0;\\n           }\\n       }\\n        return !m ? true : false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int left = *min_element(bloomDay.begin(), bloomDay.end());\\n        int right = *max_element(bloomDay.begin(), bloomDay.end());\\n        if (m * k > bloomDay.size())\\n        return -1;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(canWeMake(bloomDay, m, k, mid)){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686299,
                "title": "binary-search-easy-with-hint-on-how-to-identify",
                "content": "This solution was a little tricky, not in thought but in implementation, I figured out the binary search approach in 5 mins, the check function took a few fails to understand properly (even though that part was basically heavily hinted by question description examples).\\n\\nFor those who don\\'t understand a binary search problem easily, they usually involve a continuous range you have to check and this range does not necessarily consist of the input array and the solution demands min or max in that range where the solution changes from false to true or vice versa.\\n\\nQuestions that are similar and will help get this idea down:\\n#### EASY: \\n* [First Bad Version](https://leetcode.com/problems/first-bad-version/) | **Same template you don\\'t have to write condition yourself**\\n#### MEDIUM: \\n* [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) | [**Solution**](https://leetcode.com/problems/koko-eating-bananas/discuss/603208/Binary-Search)\\n* [Capacity to ship packages within d days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/) | [**Solution**](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/665176/Basic-Binary-Search-Solution)\\n#### HARD: \\n* [Split Largest Sum Array Problem](https://leetcode.com/problems/split-array-largest-sum/submissions/) | **Same as capacity to ship pacakges**\\n\\nHere is a link to a video by Errichto that I didn\\'t understand first time I watched, but definitely helped me get an intuition for when to use binary search and how - [Link](https://www.youtube.com/watch?v=GU7DpgHINWQ)\\n\\nUnderstanding things like lower_bound, upper_bound and doing questions like find sq root using binary search, search in sorted rotated array, search minimum in rotated sorted array also help and they also help in questions based on sorting, binary search trees, priority queues and such.\\n```\\nbool check(int mid, vector<int> &bl, int m, int k) {\\n    int nk = k, i = 0;\\n    while(i < bl.size()) {\\n        while(nk && i < bl.size() && (bl[i] - mid) <= 0) {\\n            nk--;\\n            i++;\\n        }\\n        if(!nk)\\n            m--;\\n        nk = k;\\n        if(i < bl.size() && (bl[i] - mid) > 0)\\n            i++;\\n    }\\n    return m <= 0;\\n}\\n\\nint minDays(vector<int>& bloomDay, int m, int k) {\\n    int l = *min_element(begin(bloomDay), end(bloomDay));\\n    int r = *max_element(begin(bloomDay), end(bloomDay));\\n    while(l < r) {\\n        int mid = l + (r-l)/2;\\n        if(check(mid, bloomDay, m, k))\\n            r = mid;\\n        else\\n            l = mid + 1;\\n    }\\n    return check(r, bloomDay, m, k) ? l: -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(int mid, vector<int> &bl, int m, int k) {\\n    int nk = k, i = 0;\\n    while(i < bl.size()) {\\n        while(nk && i < bl.size() && (bl[i] - mid) <= 0) {\\n            nk--;\\n            i++;\\n        }\\n        if(!nk)\\n            m--;\\n        nk = k;\\n        if(i < bl.size() && (bl[i] - mid) > 0)\\n            i++;\\n    }\\n    return m <= 0;\\n}\\n\\nint minDays(vector<int>& bloomDay, int m, int k) {\\n    int l = *min_element(begin(bloomDay), end(bloomDay));\\n    int r = *max_element(begin(bloomDay), end(bloomDay));\\n    while(l < r) {\\n        int mid = l + (r-l)/2;\\n        if(check(mid, bloomDay, m, k))\\n            r = mid;\\n        else\\n            l = mid + 1;\\n    }\\n    return check(r, bloomDay, m, k) ? l: -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686253,
                "title": "java-binary-search-with-comments-o-logn",
                "content": "When it comes to search problem within a range, the first thing comes into my mind is binary serach.\\n\\n```\\n\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m*k) return -1;\\n        //because 1 <= bloomDay[i] <= 10^9, we can set binary search range to be:\\n        int lo = 0, hi = (int) 1e9;\\n        while(lo < hi){\\n            int mid = lo +(hi-lo)/2;\\n            if(valid(mid,bloomDay,m,k)){\\n                hi = mid;//as we want the minimum number of days, keep searching\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    boolean valid(int day, int[] bloomDay, int m, int flowerCnt){\\n        int curFlowerCnt=0;\\n        for(int i = 0; i<bloomDay.length; i++){\\n            //if current flower bloomed and we have enough flowers, go to next garden\\n            if((bloomDay[i] <= day) && (++curFlowerCnt == flowerCnt)){\\n                //reset flowerCnt for next garden\\n                curFlowerCnt = 0;\\n                if(--m == 0) return true;\\n            }else if(bloomDay[i] > day){\\n                //reset flowerCnt as we need continuous flowers\\n                curFlowerCnt = 0;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m*k) return -1;\\n        //because 1 <= bloomDay[i] <= 10^9, we can set binary search range to be:\\n        int lo = 0, hi = (int) 1e9;\\n        while(lo < hi){\\n            int mid = lo +(hi-lo)/2;\\n            if(valid(mid,bloomDay,m,k)){\\n                hi = mid;//as we want the minimum number of days, keep searching\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    boolean valid(int day, int[] bloomDay, int m, int flowerCnt){\\n        int curFlowerCnt=0;\\n        for(int i = 0; i<bloomDay.length; i++){\\n            //if current flower bloomed and we have enough flowers, go to next garden\\n            if((bloomDay[i] <= day) && (++curFlowerCnt == flowerCnt)){\\n                //reset flowerCnt for next garden\\n                curFlowerCnt = 0;\\n                if(--m == 0) return true;\\n            }else if(bloomDay[i] > day){\\n                //reset flowerCnt as we need continuous flowers\\n                curFlowerCnt = 0;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686236,
                "title": "a-bit-faster-than-binary-search-java-n-log-n",
                "content": "As @hairyCoder mentioned in the comments, this solution is not as strightforwrd as binary search tree, but considering the fact that the length of array is smaller than the value of the biggest element, it\\'s on paper slightly better than BS :) Although it\\'s harder to understand and needs O(n) of space as @linweijie mentioned\\n\\n\\n\\n    TreeSet<Integer> treeSetOfRemovedIndexes;\\n    int totalPossibleBanquets;\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        if (m * k > n) {\\n            return -1;\\n        }\\n        TreeMap<Integer, TreeSet<Integer>> tm = buildTreeMap(bloomDay); // new TreeMap<>();\\n        Integer high = tm.lastKey();\\n        treeSetOfRemovedIndexes = new TreeSet<>();\\n        treeSetOfRemovedIndexes.add(-1);\\n        treeSetOfRemovedIndexes.add(n);\\n        totalPossibleBanquets = n /k;\\n        while (high != null) {\\n            TreeSet<Integer> ts = tm.get(high);\\n            if (cannotMakeDesiredBanquets(ts, m, k)) {\\n                return high;\\n            }\\n            high = tm.lowerKey(high);\\n        }\\n        return tm.firstKey();\\n    }\\n\\n    private TreeMap<Integer, TreeSet<Integer>> buildTreeMap(int[] bloomDay) {\\n        TreeMap<Integer, TreeSet<Integer>> tm = new TreeMap<>();\\n        for (int i = 0; i < bloomDay.length; ++i) {\\n            int n = bloomDay[i];\\n            if (!tm.containsKey(n)) {\\n                tm.put(n, new TreeSet<>());\\n            }\\n            tm.get(n).add(i);\\n        }\\n        return tm;\\n    }\\n\\n    private boolean cannotMakeDesiredBanquets(TreeSet<Integer> ts, int m, int k) {\\n        for (int i : ts) {\\n            int higherKey = treeSetOfRemovedIndexes.higher(i);\\n            int lowerKey = treeSetOfRemovedIndexes.lower(i);\\n            totalPossibleBanquets -= (higherKey - lowerKey - 1) / k;\\n            totalPossibleBanquets += (higherKey - i - 1) / k;\\n            totalPossibleBanquets += (i - lowerKey - 1) / k;\\n            treeSetOfRemovedIndexes.add(i);\\n        }\\n        return totalPossibleBanquets < m;\\n    }",
                "solutionTags": [],
                "code": "As @hairyCoder mentioned in the comments, this solution is not as strightforwrd as binary search tree, but considering the fact that the length of array is smaller than the value of the biggest element, it\\'s on paper slightly better than BS :) Although it\\'s harder to understand and needs O(n) of space as @linweijie mentioned\\n\\n\\n\\n    TreeSet<Integer> treeSetOfRemovedIndexes;\\n    int totalPossibleBanquets;\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int n = bloomDay.length;\\n        if (m * k > n) {\\n            return -1;\\n        }\\n        TreeMap<Integer, TreeSet<Integer>> tm = buildTreeMap(bloomDay); // new TreeMap<>();\\n        Integer high = tm.lastKey();\\n        treeSetOfRemovedIndexes = new TreeSet<>();\\n        treeSetOfRemovedIndexes.add(-1);\\n        treeSetOfRemovedIndexes.add(n);\\n        totalPossibleBanquets = n /k;\\n        while (high != null) {\\n            TreeSet<Integer> ts = tm.get(high);\\n            if (cannotMakeDesiredBanquets(ts, m, k)) {\\n                return high;\\n            }\\n            high = tm.lowerKey(high);\\n        }\\n        return tm.firstKey();\\n    }\\n\\n    private TreeMap<Integer, TreeSet<Integer>> buildTreeMap(int[] bloomDay) {\\n        TreeMap<Integer, TreeSet<Integer>> tm = new TreeMap<>();\\n        for (int i = 0; i < bloomDay.length; ++i) {\\n            int n = bloomDay[i];\\n            if (!tm.containsKey(n)) {\\n                tm.put(n, new TreeSet<>());\\n            }\\n            tm.get(n).add(i);\\n        }\\n        return tm;\\n    }\\n\\n    private boolean cannotMakeDesiredBanquets(TreeSet<Integer> ts, int m, int k) {\\n        for (int i : ts) {\\n            int higherKey = treeSetOfRemovedIndexes.higher(i);\\n            int lowerKey = treeSetOfRemovedIndexes.lower(i);\\n            totalPossibleBanquets -= (higherKey - lowerKey - 1) / k;\\n            totalPossibleBanquets += (higherKey - i - 1) / k;\\n            totalPossibleBanquets += (i - lowerKey - 1) / k;\\n            treeSetOfRemovedIndexes.add(i);\\n        }\\n        return totalPossibleBanquets < m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3943437,
                "title": "optimal-solution-using-bs-on-answer-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are going to use the Binary Search algorithm to optimize the approach.\\n\\nThe primary objective of the Binary Search algorithm is to efficiently determine the appropriate half to eliminate, thereby reducing the search space by half. It does this by determining a specific condition that ensures that the target is not present in that half.\\n\\nNow, we are not given any sorted array on which we can apply binary search. But, if we observe closely, we can notice that our answer space i.e. [mini(arr[]), max(arr[])] is sorted. So, we will apply binary search on the answer space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **If m*k > arr.size:** This means we have insufficient flowers. So, it is impossible to make m bouquets and we will return -1.\\n2. Next, we will find the maximum element i.e. max(arr[]), and the minimum element i.e. min(arr[]) in the array.\\n3. Place the 2 pointers i.e. low and high: Initially, we will place the pointers. The pointer low will point to min(arr[]) and the high will point to max(arr[]).\\n4. Calculate the \\u2018mid\\u2019: Now, inside the loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\n    $$mid = (low+high) / 2$$\\n4. Eliminate the halves based on the value returned by possible():\\nWe will pass the potential answer, represented by the variable \\u2018mid\\u2019 (which corresponds to a specific day), to the \\u2018possible()\\u2019 function.\\n    1. If possible() returns true: On satisfying this condition, we can conclude that the number \\u2018mid\\u2019 is one of our possible answers. But we want the minimum number. So, we will eliminate the right half and consider the left half(i.e. high = mid-1).\\n    2. Otherwise, the value mid is smaller than the number we want. This means the numbers greater than \\u2018mid\\u2019 should be considered and the right half of \\u2018mid\\u2019 consists of such numbers. So, we will eliminate the left half and consider the right half(i.e. low = mid+1).\\n6. Finally, outside the loop, we will return the value of low as the pointer will be pointing to the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int days,vector<int>& bloomDay,int m,int k) {\\n        int count = 0;\\n        int n = bloomDay.size();\\n        int buoquetCount = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            if(days >= bloomDay[i]) {\\n                count++;\\n            }\\n            else {\\n                buoquetCount += (count/k);\\n                count = 0;\\n            }\\n        }\\n        buoquetCount += (count/k);\\n\\n        if(buoquetCount >= m)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n       long long val = m * 1ll * k * 1ll;\\n        int n = bloomDay.size(); //size of the array\\n        if (val > n) return -1; //impossible case.\\n\\n        int low = *min_element(bloomDay.begin(),bloomDay.end());\\n\\n        int high = *max_element(bloomDay.begin(),bloomDay.end());\\n\\n        int ans = high;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,bloomDay,m,k)) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int days,vector<int>& bloomDay,int m,int k) {\\n        int count = 0;\\n        int n = bloomDay.size();\\n        int buoquetCount = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            if(days >= bloomDay[i]) {\\n                count++;\\n            }\\n            else {\\n                buoquetCount += (count/k);\\n                count = 0;\\n            }\\n        }\\n        buoquetCount += (count/k);\\n\\n        if(buoquetCount >= m)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n       long long val = m * 1ll * k * 1ll;\\n        int n = bloomDay.size(); //size of the array\\n        if (val > n) return -1; //impossible case.\\n\\n        int low = *min_element(bloomDay.begin(),bloomDay.end());\\n\\n        int high = *max_element(bloomDay.begin(),bloomDay.end());\\n\\n        int ans = high;\\n\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,bloomDay,m,k)) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else {\\n                low = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931399,
                "title": "simple-c-solution",
                "content": "# Linearly Iterating\\nIn this approach we will loop thorugh all the possible solutions linearly\\n```\\nclass Solution {\\npublic:\\n    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<minElement){\\n                minElement=bloomDay[i];\\n            }\\n            if(bloomDay[i]>maxElement){\\n                maxElement=bloomDay[i];\\n            }\\n        }\\n    }\\n    bool isPossible(vector<int> &bloomDay,int days,int m,int k){\\n        int count=0,numOfBouq=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=days){\\n                count++;\\n            }\\n            else{\\n                numOfBouq+=count/k;\\n                count=0;\\n            }\\n        }\\n        numOfBouq+=count/k;\\n        return numOfBouq>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int minDays=INT_MAX,maxDays=INT_MIN;\\n        arrayMinMax(bloomDay,minDays,maxDays);\\n        for(int i=minDays;i<=maxDays;i++){\\n            if(isPossible(bloomDay,i,m,k)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Binary Search\\nIn this approach we will be applying binary search on the possible answers/solutions\\n```\\nclass Solution {\\npublic:\\n    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<minElement){\\n                minElement=bloomDay[i];\\n            }\\n            if(bloomDay[i]>maxElement){\\n                maxElement=bloomDay[i];\\n            }\\n        }\\n    }\\n    bool isPossible(vector<int> &bloomDay,int days,int m,int k){\\n        int count=0,numOfBouq=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=days){\\n                count++;\\n            }\\n            else{\\n                numOfBouq+=count/k;\\n                count=0;\\n            }\\n        }\\n        numOfBouq+=count/k;\\n        return numOfBouq>=m;\\n    }\\n    int minDays(vector<int> &bloomDay,int m,int k){\\n        // Edge case\\n        long long val=m*1ll*k*1ll;\\n        int n=bloomDay.size();\\n        if(val>n){\\n            return -1;\\n        }\\n\\n        int low=INT_MAX,high=INT_MIN;\\n        arrayMinMax(bloomDay,low,high);\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(bloomDay,mid,m,k)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<minElement){\\n                minElement=bloomDay[i];\\n            }\\n            if(bloomDay[i]>maxElement){\\n                maxElement=bloomDay[i];\\n            }\\n        }\\n    }\\n    bool isPossible(vector<int> &bloomDay,int days,int m,int k){\\n        int count=0,numOfBouq=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=days){\\n                count++;\\n            }\\n            else{\\n                numOfBouq+=count/k;\\n                count=0;\\n            }\\n        }\\n        numOfBouq+=count/k;\\n        return numOfBouq>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int minDays=INT_MAX,maxDays=INT_MIN;\\n        arrayMinMax(bloomDay,minDays,maxDays);\\n        for(int i=minDays;i<=maxDays;i++){\\n            if(isPossible(bloomDay,i,m,k)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void arrayMinMax(vector<int> &bloomDay,int &minElement,int &maxElement){\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<minElement){\\n                minElement=bloomDay[i];\\n            }\\n            if(bloomDay[i]>maxElement){\\n                maxElement=bloomDay[i];\\n            }\\n        }\\n    }\\n    bool isPossible(vector<int> &bloomDay,int days,int m,int k){\\n        int count=0,numOfBouq=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=days){\\n                count++;\\n            }\\n            else{\\n                numOfBouq+=count/k;\\n                count=0;\\n            }\\n        }\\n        numOfBouq+=count/k;\\n        return numOfBouq>=m;\\n    }\\n    int minDays(vector<int> &bloomDay,int m,int k){\\n        // Edge case\\n        long long val=m*1ll*k*1ll;\\n        int n=bloomDay.size();\\n        if(val>n){\\n            return -1;\\n        }\\n\\n        int low=INT_MAX,high=INT_MIN;\\n        arrayMinMax(bloomDay,low,high);\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(bloomDay,mid,m,k)){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893349,
                "title": "simple-and-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& bloomDay,int day, int m, int k){\\n        int cnt = 0;\\n        int noofB = 0;\\n        for(int i = 0;i<bloomDay.size();i++){\\n            if(bloomDay[i] <= day){\\n                cnt++;\\n            }\\n            else{\\n                noofB += (cnt/k);\\n                cnt = 0;\\n            }\\n        }\\n        noofB += (cnt/k);\\n        if(noofB >= m){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        long long val = m * 1ll * k * 1ll;\\n        if(val > bloomDay.size()){\\n            return -1;\\n        }\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<bloomDay.size();i++){\\n            mini = min(mini,bloomDay[i]);\\n            maxi = max(maxi,bloomDay[i]);\\n        }\\n\\n        int low = mini, high = maxi;\\n        int ans = high;\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(possible(bloomDay,mid,m,k)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<int>& bloomDay,int day, int m, int k){\\n        int cnt = 0;\\n        int noofB = 0;\\n        for(int i = 0;i<bloomDay.size();i++){\\n            if(bloomDay[i] <= day){\\n                cnt++;\\n            }\\n            else{\\n                noofB += (cnt/k);\\n                cnt = 0;\\n            }\\n        }\\n        noofB += (cnt/k);\\n        if(noofB >= m){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        long long val = m * 1ll * k * 1ll;\\n        if(val > bloomDay.size()){\\n            return -1;\\n        }\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<bloomDay.size();i++){\\n            mini = min(mini,bloomDay[i]);\\n            maxi = max(maxi,bloomDay[i]);\\n        }\\n\\n        int low = mini, high = maxi;\\n        int ans = high;\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n\\n            if(possible(bloomDay,mid,m,k)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820610,
                "title": "c-super-easy-clean-code-binary-search-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        int n = bloomDay.size();\\n        if(1LL* m * k > n) return -1;\\n\\n        int low = bloomDay[0];\\n        int high = low;\\n\\n        for(int i=1; i<n; i++){\\n            low = min(low,bloomDay[i]);\\n            high = max(high,bloomDay[i]);\\n        }\\n\\n        while(low < high){\\n            int mid = low + (high - low) / 2;\\n\\n            int total = 0;\\n            int count = 0;\\n\\n            for(int i=0; i<n; i++){\\n                if(bloomDay[i] > mid){\\n                    total += count/k;\\n                    count = 0;\\n                }\\n                else{\\n                    count++;\\n                }\\n            }\\n\\n            total += count/k;\\n\\n            if(total < m){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n\\n        }\\n\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        int n = bloomDay.size();\\n        if(1LL* m * k > n) return -1;\\n\\n        int low = bloomDay[0];\\n        int high = low;\\n\\n        for(int i=1; i<n; i++){\\n            low = min(low,bloomDay[i]);\\n            high = max(high,bloomDay[i]);\\n        }\\n\\n        while(low < high){\\n            int mid = low + (high - low) / 2;\\n\\n            int total = 0;\\n            int count = 0;\\n\\n            for(int i=0; i<n; i++){\\n                if(bloomDay[i] > mid){\\n                    total += count/k;\\n                    count = 0;\\n                }\\n                else{\\n                    count++;\\n                }\\n            }\\n\\n            total += count/k;\\n\\n            if(total < m){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n\\n        }\\n\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3775049,
                "title": "c-binary-search-easy-to-understand",
                "content": "CODE:\\n```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<int>&bloomDay,int day,int m,int k) {\\n        int count =0;\\n        int numB = 0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i] <= day)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n               numB+=(count/k);\\n                count = 0;\\n            }\\n        }\\n        numB+=(count/k);\\n        return numB>=m; // returning true if number of Bouquests greater than or equal to m\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < (long long)((long long )m*k)) return -1; // we have to typecast here because if we dont it will result in integer overflow as 10^9 is constraints \\n        \\n      int low  = *min_element(bloomDay.begin(),bloomDay.end()); \\n      int high =  *max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        while(low<=high)\\n        {\\n            long long mid = low+(high-low)/2;\\n            \\n            if(possible(bloomDay,mid,m,k))\\n            {\\n                high  = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n        \\n    }\\n};\\n```\\nWhy do we return low here\\nWe return low here because suppose we we dont  find a possibility to use that bloomday then we eliminate one part of the search space and do low = mid+1; by doing this we are basically guiding our low from not possible state to possible state and thus we return low.\\n\\nDry run once and u will understand it better.\\n\\nKindly upvote if u find it helpful :))",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<int>&bloomDay,int day,int m,int k) {\\n        int count =0;\\n        int numB = 0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            if(bloomDay[i] <= day)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n               numB+=(count/k);\\n                count = 0;\\n            }\\n        }\\n        numB+=(count/k);\\n        return numB>=m; // returning true if number of Bouquests greater than or equal to m\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(bloomDay.size() < (long long)((long long )m*k)) return -1; // we have to typecast here because if we dont it will result in integer overflow as 10^9 is constraints \\n        \\n      int low  = *min_element(bloomDay.begin(),bloomDay.end()); \\n      int high =  *max_element(bloomDay.begin(),bloomDay.end());\\n        \\n        while(low<=high)\\n        {\\n            long long mid = low+(high-low)/2;\\n            \\n            if(possible(bloomDay,mid,m,k))\\n            {\\n                high  = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766107,
                "title": "binary-search-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < (long)m*k) return -1;\\n        int max = 0, min = Integer.MAX_VALUE;\\n        for(int day:bloomDay){\\n            max = Math.max(max, day);\\n            min = Math.min(min, day);\\n        }\\n        int start = min, end = max;\\n        while(start<end){\\n            int mid = start+(end-start)/2;\\n            int bouquet = computeDays(bloomDay, k, mid);\\n            if(bouquet<m){\\n                start = mid+1;\\n            }\\n            else end = mid;\\n        }\\n        return start;\\n    }\\n    private int computeDays(int[] bloomDay, int k, int day){\\n        int b = 0;\\n        int currFlower = 0;\\n        for(int i=0;i<bloomDay.length;i++>){\\n            if(bloomDay[i]>day){\\n                currFlower = 0;\\n            }\\n            else{\\n                currFlower++;\\n                if(currFlower>=k){\\n                    currFlower = 0;\\n                    b++;\\n                }\\n            }\\n        }\\n        return b;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < (long)m*k) return -1;\\n        int max = 0, min = Integer.MAX_VALUE;\\n        for(int day:bloomDay){\\n            max = Math.max(max, day);\\n            min = Math.min(min, day);\\n        }\\n        int start = min, end = max;\\n        while(start<end){\\n            int mid = start+(end-start)/2;\\n            int bouquet = computeDays(bloomDay, k, mid);\\n            if(bouquet<m){\\n                start = mid+1;\\n            }\\n            else end = mid;\\n        }\\n        return start;\\n    }\\n    private int computeDays(int[] bloomDay, int k, int day){\\n        int b = 0;\\n        int currFlower = 0;\\n        for(int i=0;i<bloomDay.length;i++>){\\n            if(bloomDay[i]>day){\\n                currFlower = 0;\\n            }\\n            else{\\n                currFlower++;\\n                if(currFlower>=k){\\n                    currFlower = 0;\\n                    b++;\\n                }\\n            }\\n        }\\n        return b;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721917,
                "title": "binary-search-java-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int max = bloomDay[0];\\n        int min = bloomDay[0];\\n        for(int i = 0;i<bloomDay.length;i++)\\n        {\\n            min = Math.min(min,bloomDay[i]);\\n            max = Math.max(max,bloomDay[i]);\\n        }\\n        int ans = -1;\\n        while(min<=max)\\n        {\\n            int mid = min + (max-min)/2;\\n            boolean can = calc(bloomDay,mid,m,k);\\n            if(can == true)\\n            {\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else\\n            min = mid + 1;\\n        }\\n        return ans;\\n    }\\n    public boolean calc(int[] a , int days, int m ,int k)\\n    {\\n        int no=0;\\n        int c = 0;\\n        for(int i = 0;i<a.length;i++)\\n        {\\n            if(a[i]<=days)\\n            c++;\\n            else\\n            {\\n                no = no + (c/k);\\n                c=0;\\n            }\\n        }\\n        no = no + (c/k);\\n        if(no>=m)\\n        return true;\\n        else\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int max = bloomDay[0];\\n        int min = bloomDay[0];\\n        for(int i = 0;i<bloomDay.length;i++)\\n        {\\n            min = Math.min(min,bloomDay[i]);\\n            max = Math.max(max,bloomDay[i]);\\n        }\\n        int ans = -1;\\n        while(min<=max)\\n        {\\n            int mid = min + (max-min)/2;\\n            boolean can = calc(bloomDay,mid,m,k);\\n            if(can == true)\\n            {\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else\\n            min = mid + 1;\\n        }\\n        return ans;\\n    }\\n    public boolean calc(int[] a , int days, int m ,int k)\\n    {\\n        int no=0;\\n        int c = 0;\\n        for(int i = 0;i<a.length;i++)\\n        {\\n            if(a[i]<=days)\\n            c++;\\n            else\\n            {\\n                no = no + (c/k);\\n                c=0;\\n            }\\n        }\\n        no = no + (c/k);\\n        if(no>=m)\\n        return true;\\n        else\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586422,
                "title": "detailed-explanation-intuition-c-solution-binary-search",
                "content": "# Intuition\\nThis problem is similar to \\'Koko eating bananas\\' problem. Solve this problem to understand the intuition.\\nHere is the problem link:\\nhttps://leetcode.com/problems/koko-eating-bananas/\\n\\nHere is the brief of the intuition:\\n1. Firstly, if totalFlowers = (m * k) is greater than size of the array then, we cannot make the required bouquets.\\n2. Find the max element from the array then, we have a search space from [1 to max(bloomDay)]. This represents all the possible days. We need to minimize the number of required days.\\n\\nExample, bloomDay = {1, 2, 5, 10, 3, 4}\\nSearch space = [1 ------- 10]\\n\\n3. Apply binary search to the search space.\\n4. With each mid element found, check whether we are able to get the required number of bouquets.\\n5. If (bouquets >= m), update answer and move to the left part of the search space (high = mid - 1). Else, move to the right part of the search space (low = mid + 1).\\n\\n# Approach\\nApproach for the minDays() function is pretty straight forward. We just need to apply binary search.\\n\\nLet us see the approach for possibleBouquets() function.\\n\\nConsider mid = 9\\nbloomDay = {7, 7, 7, 7, 12, 7, 7}\\nLet us make an array which contains 1 for (elem <= mid) else 0\\n**[Note: we are not using any extra array, this is just for demonstration]**\\naux Array = {1, 1, 1, 1, 0, 1, 1}\\nLet the adjacent flowers, k = 3\\n\\nUntil 0, we have count = 4. Therefore 1 bouquet can be made (4 > 3).\\nAfter 0, count = 2. No bouquet can be formed as there are only 2 adjacent flowers.\\n\\nTherefore total bouquets = 1 + 0 = 1\\nReturn the number of bouquets.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int possibleBouquets(vector<int> &bloomDay, int n, int k, long long mid) {\\n\\n        int bouquets = 0, adjCount = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(bloomDay[i] <= mid) {\\n                adjCount++;\\n            }\\n            else {\\n                bouquets += (adjCount / k);\\n                adjCount = 0;\\n            }\\n        } \\n\\n        bouquets += (adjCount / k);\\n\\n        return bouquets;\\n\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        int n = bloomDay.size();\\n\\n        if(n < (long long)m * k)\\n            return -1;\\n\\n        long long low = 1, high = *max_element(bloomDay.begin(), bloomDay.end());\\n        long long ans = high;\\n\\n        while(low <= high) {\\n            long long mid = (low + high) >> 1;\\n\\n            int bouquets = possibleBouquets(bloomDay, n, k, mid);\\n\\n            if(bouquets >= m) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\n**O(n * log(max(bloomDay)))**\\n\\nWe are using a search space from 1 to max(blommDay) and apply binary search. Therefore, log(max(bloomDay)).\\nWith each mid element, we are traversing the complete array of size n.\\nTherfore, total complexity is: O(n * log(max(bloomDay)))\\n\\n- Space complexity:\\n**O(1)**\\nWe are not using any extra space.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int possibleBouquets(vector<int> &bloomDay, int n, int k, long long mid) {\\n\\n        int bouquets = 0, adjCount = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(bloomDay[i] <= mid) {\\n                adjCount++;\\n            }\\n            else {\\n                bouquets += (adjCount / k);\\n                adjCount = 0;\\n            }\\n        } \\n\\n        bouquets += (adjCount / k);\\n\\n        return bouquets;\\n\\n    }\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        int n = bloomDay.size();\\n\\n        if(n < (long long)m * k)\\n            return -1;\\n\\n        long long low = 1, high = *max_element(bloomDay.begin(), bloomDay.end());\\n        long long ans = high;\\n\\n        while(low <= high) {\\n            long long mid = (low + high) >> 1;\\n\\n            int bouquets = possibleBouquets(bloomDay, n, k, mid);\\n\\n            if(bouquets >= m) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330075,
                "title": "we-dont-need-1e9-as-end-great-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany of you are thinking that why are we taking end as 1e9 thats a large no then finding mid and soo on.\\nInstead we take the max element of the array which is maximum no of days it cant exceed that limit so why dont we take and the ans is yes \\nwhich is great for not checking the infite no of mid and finding the solution here is the solution......\\n\\nhope u like it and pls upvote :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& v,int m,int k,int mid){\\n        int tot=0,bough=0;\\n        for(int i=0;i<v.size();i++){\\n            \\n            if(v[i]<=mid){\\n                bough++;\\n                if(bough==k){\\n                    tot++;\\n                    bough=0;\\n                }\\n            }\\n            else bough=0;\\n        }\\n        if(tot>=m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        // if(m*k>bloomDay.size()) return -1;\\n        int maxi=-1;\\n        for(int i=0;i<bloomDay.size();i++){\\n            maxi=max(maxi,bloomDay[i]);\\n        }\\n        int low=0,high=maxi;\\n        int result=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                result=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& v,int m,int k,int mid){\\n        int tot=0,bough=0;\\n        for(int i=0;i<v.size();i++){\\n            \\n            if(v[i]<=mid){\\n                bough++;\\n                if(bough==k){\\n                    tot++;\\n                    bough=0;\\n                }\\n            }\\n            else bough=0;\\n        }\\n        if(tot>=m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        // if(m*k>bloomDay.size()) return -1;\\n        int maxi=-1;\\n        for(int i=0;i<bloomDay.size();i++){\\n            maxi=max(maxi,bloomDay[i]);\\n        }\\n        int low=0,high=maxi;\\n        int result=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                result=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203417,
                "title": "binary-search-in-rust",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n    pub fn min_days(bloom_day: Vec<i32>, m: i32, k: i32) -> i32 {\\n        let gg = *bloom_day.iter().max().unwrap();\\n        let (mut min, mut max) = (0, gg + 1);\\n        let mut mid;\\n        while min < max {\\n            mid = (min + max) / 2;\\n\\n            if Self::can_bloom(mid, &bloom_day, m, k) {\\n                max = mid;\\n            } else {\\n                min = mid + 1;\\n            }\\n        }\\n\\n        if min > gg { -1 } else { min }\\n    }\\n\\n    fn can_bloom(day: i32, days: &Vec<i32>, m: i32, k: i32) -> bool {\\n        let k = k as usize;\\n        let (mut prev, mut ans) = (0, 0);\\n        for i in 0..days.len() {\\n            if days[i] <= day {\\n                if 1 + i - prev == k {\\n                    ans += 1;\\n                    prev = i + 1;\\n                }\\n            } else {\\n                prev = i + 1;\\n            }\\n            if ans == m { return true }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn min_days(bloom_day: Vec<i32>, m: i32, k: i32) -> i32 {\\n        let gg = *bloom_day.iter().max().unwrap();\\n        let (mut min, mut max) = (0, gg + 1);\\n        let mut mid;\\n        while min < max {\\n            mid = (min + max) / 2;\\n\\n            if Self::can_bloom(mid, &bloom_day, m, k) {\\n                max = mid;\\n            } else {\\n                min = mid + 1;\\n            }\\n        }\\n\\n        if min > gg { -1 } else { min }\\n    }\\n\\n    fn can_bloom(day: i32, days: &Vec<i32>, m: i32, k: i32) -> bool {\\n        let k = k as usize;\\n        let (mut prev, mut ans) = (0, 0);\\n        for i in 0..days.len() {\\n            if days[i] <= day {\\n                if 1 + i - prev == k {\\n                    ans += 1;\\n                    prev = i + 1;\\n                }\\n            } else {\\n                prev = i + 1;\\n            }\\n            if ans == m { return true }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132581,
                "title": "beats-99-7-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int bouqets, int flowersPerBouqet) {\\n        int n=bloomDay.size(),ans=INT_MAX;\\n        if(n<(long long )bouqets*flowersPerBouqet)\\n        {\\n            return -1;\\n        }\\n        int i=0,j=0;\\n        for(auto element:bloomDay)\\n        {\\n            j=max(j,element);\\n            i=min(i,element);\\n        }\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int temp_bouqets=bouqets,temp_flowersPerBouqet=flowersPerBouqet;\\n            for(auto element:bloomDay)\\n            {   \\n                if(element<=mid)\\n                {\\n                      temp_flowersPerBouqet--;    \\n                      if(temp_flowersPerBouqet==0)\\n                      {\\n                           temp_bouqets--;\\n                           if(temp_bouqets==0)\\n                            {\\n                                  break;\\n                            }\\n                          temp_flowersPerBouqet=flowersPerBouqet;\\n                      }\\n                }\\n                else{\\n                        temp_flowersPerBouqet=flowersPerBouqet;\\n                    }\\n             }\\n                 if(mid<=ans and temp_bouqets<=0)\\n                 {\\n                   ans=min(mid,ans);\\n                   j=mid-1;\\n                 }\\n                 else i=mid+1;\\n             \\n            } \\n            return ans;  \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int bouqets, int flowersPerBouqet) {\\n        int n=bloomDay.size(),ans=INT_MAX;\\n        if(n<(long long )bouqets*flowersPerBouqet)\\n        {\\n            return -1;\\n        }\\n        int i=0,j=0;\\n        for(auto element:bloomDay)\\n        {\\n            j=max(j,element);\\n            i=min(i,element);\\n        }\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int temp_bouqets=bouqets,temp_flowersPerBouqet=flowersPerBouqet;\\n            for(auto element:bloomDay)\\n            {   \\n                if(element<=mid)\\n                {\\n                      temp_flowersPerBouqet--;    \\n                      if(temp_flowersPerBouqet==0)\\n                      {\\n                           temp_bouqets--;\\n                           if(temp_bouqets==0)\\n                            {\\n                                  break;\\n                            }\\n                          temp_flowersPerBouqet=flowersPerBouqet;\\n                      }\\n                }\\n                else{\\n                        temp_flowersPerBouqet=flowersPerBouqet;\\n                    }\\n             }\\n                 if(mid<=ans and temp_bouqets<=0)\\n                 {\\n                   ans=min(mid,ans);\\n                   j=mid-1;\\n                 }\\n                 else i=mid+1;\\n             \\n            } \\n            return ans;  \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098773,
                "title": "easy-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple binary search appraoch\\nand if product of m and k is grater than size of vector then return -1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(max(v)))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bd, int m, int k) {\\n        int n=bd.size();\\n        long long pdt = (long long)m*k;\\n        if(pdt>n)\\n            return -1;\\n        int st=0; \\n        int en=*max_element(bd.begin(),bd.end());\\n        int ans=0;\\n        while(en>=st)\\n        {\\n            int mid=st+(en-st)/2;\\n            int countb=0,countc=0;\\n            for(int i=0; i<n; i++)\\n            {\\n                \\n                if(bd[i]<=mid)\\n                {\\n                    countc++;\\n                }\\n                if(countc==k)\\n                {\\n                    countb++;\\n                    countc=0;\\n                }\\n                if(bd[i]>mid)\\n                {\\n                    countc=0;\\n                }\\n            }\\n            if(countb>=m)\\n            {\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bd, int m, int k) {\\n        int n=bd.size();\\n        long long pdt = (long long)m*k;\\n        if(pdt>n)\\n            return -1;\\n        int st=0; \\n        int en=*max_element(bd.begin(),bd.end());\\n        int ans=0;\\n        while(en>=st)\\n        {\\n            int mid=st+(en-st)/2;\\n            int countb=0,countc=0;\\n            for(int i=0; i<n; i++)\\n            {\\n                \\n                if(bd[i]<=mid)\\n                {\\n                    countc++;\\n                }\\n                if(countc==k)\\n                {\\n                    countb++;\\n                    countc=0;\\n                }\\n                if(bd[i]>mid)\\n                {\\n                    countc=0;\\n                }\\n            }\\n            if(countb>=m)\\n            {\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073981,
                "title": "easy-variables-commented-code-c-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {    // Binary Search, O(nlog(max(bloomDay))) -> O(nlogn)\\npublic:\\n\\n    bool isPossible( vector<int>& bloomDay, int boqCnt, int flrCnt, int curDay ){\\n\\n        int adjCnt = 0;                 // count for number of adjacent bloomed flower we found\\n\\n        for( auto bDay : bloomDay ){    // iterate for all the flowers in bloomDay\\n\\n            if( bDay <= curDay )        // if the bloom day is smaller than current day, this means that the flower is bloomed, so increase adjacent count\\n                adjCnt++ ;\\n\\n            else adjCnt = 0;            // if the flower is not bloomed, reset adjacent count\\n\\n            if( adjCnt == flrCnt ){     // if the adjacent count becomes equal to the flower needed to make a single boquet\\n                boqCnt-- ;              // decrease the boquet count as we made one boquet\\n                adjCnt = 0 ;            // reset the adjacent count, as we will find new k adjacent flowers now\\n            }    \\n        }\\n\\n        if( boqCnt <= 0 ) return true;\\n\\n    return false;\\n}\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        // if the flowers needed to make all the m boquets that is m times k is greater than the provided flowers, its not possible to make the boquets, return -1\\n        if( (long long )m * k > bloomDay.size() ) return -1;   \\n\\n        int minDay = 1;          // minimum days for a flower to bloom, atleast 1 ofcourse\\n        int maxDay = 1000000000; // maximum day possible, according to constraints let it be 1e9, or we can use max(bloomDay)\\n\\n        while( minDay < maxDay ){   // while the minDay is smaller than maxDay\\n\\n            int curDay = minDay + ( maxDay - minDay )/2;  // let the curDay be the middle between minDay and maxDay\\n\\n            // if for the current day, we can make the m boquets, then lets try for a previous day, so shrink the search space starting from minDay to curDay\\n            if( isPossible( bloomDay, m, k, curDay ) )      \\n                maxDay = curDay ;\\n            \\n            // if we cant make m boquets at current day, lets try for a latter day, shrink the search space from, curDay to maxDay\\n            else minDay = curDay + 1; \\n\\n        }\\n    // return the minimum day we found \\n    return minDay;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {    // Binary Search, O(nlog(max(bloomDay))) -> O(nlogn)\\npublic:\\n\\n    bool isPossible( vector<int>& bloomDay, int boqCnt, int flrCnt, int curDay ){\\n\\n        int adjCnt = 0;                 // count for number of adjacent bloomed flower we found\\n\\n        for( auto bDay : bloomDay ){    // iterate for all the flowers in bloomDay\\n\\n            if( bDay <= curDay )        // if the bloom day is smaller than current day, this means that the flower is bloomed, so increase adjacent count\\n                adjCnt++ ;\\n\\n            else adjCnt = 0;            // if the flower is not bloomed, reset adjacent count\\n\\n            if( adjCnt == flrCnt ){     // if the adjacent count becomes equal to the flower needed to make a single boquet\\n                boqCnt-- ;              // decrease the boquet count as we made one boquet\\n                adjCnt = 0 ;            // reset the adjacent count, as we will find new k adjacent flowers now\\n            }    \\n        }\\n\\n        if( boqCnt <= 0 ) return true;\\n\\n    return false;\\n}\\n\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        // if the flowers needed to make all the m boquets that is m times k is greater than the provided flowers, its not possible to make the boquets, return -1\\n        if( (long long )m * k > bloomDay.size() ) return -1;   \\n\\n        int minDay = 1;          // minimum days for a flower to bloom, atleast 1 ofcourse\\n        int maxDay = 1000000000; // maximum day possible, according to constraints let it be 1e9, or we can use max(bloomDay)\\n\\n        while( minDay < maxDay ){   // while the minDay is smaller than maxDay\\n\\n            int curDay = minDay + ( maxDay - minDay )/2;  // let the curDay be the middle between minDay and maxDay\\n\\n            // if for the current day, we can make the m boquets, then lets try for a previous day, so shrink the search space starting from minDay to curDay\\n            if( isPossible( bloomDay, m, k, curDay ) )      \\n                maxDay = curDay ;\\n            \\n            // if we cant make m boquets at current day, lets try for a latter day, shrink the search space from, curDay to maxDay\\n            else minDay = curDay + 1; \\n\\n        }\\n    // return the minimum day we found \\n    return minDay;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041542,
                "title": "binary-search",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinDays(int[] bloomDay, int m, int k) {\\n        var n = bloomDay.Length;\\n\\n        if (n < m * k) {\\n            return -1;\\n        }\\n\\n        var left = 1;\\n        var right = 1000000000;\\n        var res = Int32.MaxValue;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n\\n            var flowers = 0;\\n            var bouquets = 0;\\n            for (var i = 0; i < n; i++) {\\n                if (bloomDay[i] > mid) {\\n                    flowers = 0;\\n                    continue;\\n                } \\n                \\n                flowers++;\\n                if (flowers == k) {\\n                    flowers = 0;\\n                    bouquets++;\\n                    if (bouquets == m) {\\n                        res = Math.Min(res, mid);\\n                        break;\\n                    }\\n                }                \\n            }\\n\\n            if (bouquets >= m) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return res == Int32.MaxValue ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDays(int[] bloomDay, int m, int k) {\\n        var n = bloomDay.Length;\\n\\n        if (n < m * k) {\\n            return -1;\\n        }\\n\\n        var left = 1;\\n        var right = 1000000000;\\n        var res = Int32.MaxValue;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n\\n            var flowers = 0;\\n            var bouquets = 0;\\n            for (var i = 0; i < n; i++) {\\n                if (bloomDay[i] > mid) {\\n                    flowers = 0;\\n                    continue;\\n                } \\n                \\n                flowers++;\\n                if (flowers == k) {\\n                    flowers = 0;\\n                    bouquets++;\\n                    if (bouquets == m) {\\n                        res = Math.Min(res, mid);\\n                        break;\\n                    }\\n                }                \\n            }\\n\\n            if (bouquets >= m) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return res == Int32.MaxValue ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961733,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &bd, int m, int k) {\\n        int cnt = 0, n = 0;\\n        for(int i=0; i<bd.size(); i++) {\\n            bd[i] <= x ? n++ : n = 0;\\n            if(n == k) cnt++, n = 0;\\n        }\\n        return cnt < m ? false : true;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 0, e = 1e9, ans = INT_MAX;\\n        while(s <= e) {\\n            int mid = (s + e) / 2;\\n            if(good(mid, bloomDay, m, k)) ans = min(ans, mid), e = mid - 1;\\n            else s = mid + 1;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &bd, int m, int k) {\\n        int cnt = 0, n = 0;\\n        for(int i=0; i<bd.size(); i++) {\\n            bd[i] <= x ? n++ : n = 0;\\n            if(n == k) cnt++, n = 0;\\n        }\\n        return cnt < m ? false : true;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 0, e = 1e9, ans = INT_MAX;\\n        while(s <= e) {\\n            int mid = (s + e) / 2;\\n            if(good(mid, bloomDay, m, k)) ans = min(ans, mid), e = mid - 1;\\n            else s = mid + 1;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929787,
                "title": "find-the-range-for-binary-search-and-apply-the-condition-mention-in-the-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        \\n        \\n        \\n        int n = b.size();\\n        if(long(m)*long(k)>n)\\n            return -1;\\n        int mn = INT_MAX;\\n        int mx = INT_MIN;\\n        \\n        \\n        for(auto i:b)\\n        {\\n            mn = min(mn,i);\\n            mx = max(mx,i);\\n        }\\n        \\n        \\n        int l,r;\\n        l = mn;\\n        r = mx;\\n        \\n        int res = 0;\\n        while(l<r)\\n        {\\n            int mid = (l+r)/2;\\n            int adj=0;\\n            res=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(b[i]<=mid)\\n                {\\n                    adj++;\\n                    if(adj == k){\\n                        res++;\\n                        adj=0;\\n                    }\\n                    if(res>=m)\\n                        break;\\n                }\\n                else\\n                {\\n                    adj=0;\\n                }\\n            }\\n            \\n            if(res<m)\\n            {\\n                l = mid+1;\\n            }\\n            else\\n                r = mid;\\n        }\\n        \\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& b, int m, int k) {\\n        \\n        \\n        \\n        int n = b.size();\\n        if(long(m)*long(k)>n)\\n            return -1;\\n        int mn = INT_MAX;\\n        int mx = INT_MIN;\\n        \\n        \\n        for(auto i:b)\\n        {\\n            mn = min(mn,i);\\n            mx = max(mx,i);\\n        }\\n        \\n        \\n        int l,r;\\n        l = mn;\\n        r = mx;\\n        \\n        int res = 0;\\n        while(l<r)\\n        {\\n            int mid = (l+r)/2;\\n            int adj=0;\\n            res=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(b[i]<=mid)\\n                {\\n                    adj++;\\n                    if(adj == k){\\n                        res++;\\n                        adj=0;\\n                    }\\n                    if(res>=m)\\n                        break;\\n                }\\n                else\\n                {\\n                    adj=0;\\n                }\\n            }\\n            \\n            if(res<m)\\n            {\\n                l = mid+1;\\n            }\\n            else\\n                r = mid;\\n        }\\n        \\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726172,
                "title": "c-easy-to-understand-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    /* we want to check can we make m bouquets at a day of mid or not */\\n    bool check(vector<int> &arr, int mid, int m, int k){\\n        int subarray = 0;\\n        int total = 0;\\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] <= mid){\\n                total++;\\n            }\\n            else{\\n                if(total == k){\\n                    subarray++;\\n                }\\n                total = 0;\\n            }\\n            if(total == k){\\n                subarray++;\\n                total = 0;\\n            }\\n        }\\n        if(subarray >= m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& arr, int m, int k) {\\n        /* if m*k < total no. of flows then we can\\'t make m bouquets */\\n        if(((long long)m*(long long)k) > arr.size()) return -1;\\n        \\n        /* maximum days we can take as maximum element in the array after that all flows will get bloom  */\\n        int l = 1, r = *max_element(arr.begin(), arr.end());\\n        int ans = -1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(arr, mid, m, k)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```\\n\\nIf you like the solution please upvote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* we want to check can we make m bouquets at a day of mid or not */\\n    bool check(vector<int> &arr, int mid, int m, int k){\\n        int subarray = 0;\\n        int total = 0;\\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] <= mid){\\n                total++;\\n            }\\n            else{\\n                if(total == k){\\n                    subarray++;\\n                }\\n                total = 0;\\n            }\\n            if(total == k){\\n                subarray++;\\n                total = 0;\\n            }\\n        }\\n        if(subarray >= m) return true;\\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& arr, int m, int k) {\\n        /* if m*k < total no. of flows then we can\\'t make m bouquets */\\n        if(((long long)m*(long long)k) > arr.size()) return -1;\\n        \\n        /* maximum days we can take as maximum element in the array after that all flows will get bloom  */\\n        int l = 1, r = *max_element(arr.begin(), arr.end());\\n        int ans = -1;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(arr, mid, m, k)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608871,
                "title": "c-solution-fast-easy-efficient-readable-and-beginner-friendly",
                "content": "**If the solution helps you, please do consider upvoting it.**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& bloomDay,int m,int k,int mid)\\n    {\\n        int count=0,size=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            size=(bloomDay[i]<=mid) ?size+1 :0;\\n            if(size==k)\\n            {\\n                size=0;\\n                count++;\\n            }\\n            if(count==m)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n         if(bloomDay.size()==0 or m==0 or k==0)\\n             return 0;\\n        if(m*k>bloomDay.size())\\n            return -1;\\n        int left=*min_element(bloomDay.begin(),bloomDay.end());\\n        int right=*max_element(bloomDay.begin(),bloomDay.end());\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isValid(bloomDay,m,k,mid))\\n                right=mid-1;\\n            else\\n                left=mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& bloomDay,int m,int k,int mid)\\n    {\\n        int count=0,size=0;\\n        for(int i=0;i<bloomDay.size();i++)\\n        {\\n            size=(bloomDay[i]<=mid) ?size+1 :0;\\n            if(size==k)\\n            {\\n                size=0;\\n                count++;\\n            }\\n            if(count==m)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n         if(bloomDay.size()==0 or m==0 or k==0)\\n             return 0;\\n        if(m*k>bloomDay.size())\\n            return -1;\\n        int left=*min_element(bloomDay.begin(),bloomDay.end());\\n        int right=*max_element(bloomDay.begin(),bloomDay.end());\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isValid(bloomDay,m,k,mid))\\n                right=mid-1;\\n            else\\n                left=mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606682,
                "title": "java-basic-binary-search-93-08-faster",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int min = 0;\\n        int max = 0;\\n        for(int i = 0; i< bloomDay.length; i++){\\n            min = Math.min(min , bloomDay[i]);\\n            max = Math.max(max , bloomDay[i]);\\n            }\\n        int res = -1;\\n        if(bloomDay.length < m*k) return res;\\n        \\n        int low = min;\\n        int high = max;\\n        int mid = 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isvalid(bloomDay , mid , k , m)){\\n                res = mid;\\n                high = mid -1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n    public static boolean isvalid(int [] bloomDay, int mid , int k , int m){\\n        int flower=0;\\n        int bouquet=0;\\n        for(int i=0;i<bloomDay.length;i++)\\n        {\\n            if(bloomDay[i]<=mid)\\n            {\\n                flower++;\\n                if(flower==k)\\n                {\\n                    bouquet++;\\n                    flower=0;\\n                }\\n            }\\n            else\\n            {\\n                flower=0;\\n            }\\n        }\\n        return bouquet>=m;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int min = 0;\\n        int max = 0;\\n        for(int i = 0; i< bloomDay.length; i++){\\n            min = Math.min(min , bloomDay[i]);\\n            max = Math.max(max , bloomDay[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2606597,
                "title": "java-solution-using-binary-search",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n\\t\\t if(m*k>bloomDay.length){\\n\\t\\t\\t return -1;\\n\\t\\t }   \\n\\t\\t\\tint min=0;\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i:bloomDay){\\n\\t\\t\\t\\tmin=Math.min(min,i);\\n\\t\\t\\t\\tmax=Math.max(max,i);\\n\\t\\t\\t}\\n\\t\\t\\tint ans=0;\\n\\t\\t\\twhile(min<=max){\\n\\t\\t\\t\\tint mid=min+(max-min)/2;\\n\\t\\t\\t\\tif(valid(bloomDay,mid,m,k)){\\n\\t\\t\\t\\t\\tans=mid;\\n\\t\\t\\t\\t   max=mid-1; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmin=mid+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tpublic static boolean valid(int[]bloomDay,int mid,int m,int k){\\n\\t\\t\\tint flower=0;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i:bloomDay){\\n\\t\\t\\t\\tif(i<=mid)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tflower++;\\n\\n\\t\\t\\t\\t\\tif(flower==k){\\n\\t\\t\\t\\t\\t\\tcount++;    \\n\\t\\t\\t\\t\\t\\tflower=0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tflower=0;\\n\\t\\t\\t}\\n\\t\\t\\tif(count>=m){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minDays(int[] bloomDay, int m, int k) {\\n\\t\\t if(m*k>bloomDay.length){\\n\\t\\t\\t return -1;\\n\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 2553745,
                "title": "c-98-fast-easy-o-n-lgn-readable",
                "content": "**Please upvote if helpful**\\n```\\nclass Solution {\\n    bool isPos(vector<int>& bloomDay, int day, int m, int k) {\\n\\t//Method returns true if it is possible to satisfy given requirement\\n        int n=bloomDay.size(), i=-1, j=0, numBq=0;    //i is point before start of window, j is point under examination\\n        while(j<n) {\\n            if(bloomDay[j]<=day) {\\n\\t\\t\\t//If the flower has bloomed\\n                if(j-i==k) {\\n                    numBq++;\\n                    i=j;\\n                }\\n                j++;\\n            }\\n            else {\\n\\t\\t\\t//Restart the window\\n                i = j;\\n                j++;\\n            }\\n        }\\n        return numBq>=m;\\n    }\\n    \\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        \\n        if(n < m * k)\\n            return -1;\\n        \\n        int left = 1, right = *max_element(bloomDay.begin(), bloomDay.end()), mid;\\n        while(left < right) {\\n            mid = left + (right - left)/2;\\n            \\n            if(isPos(bloomDay, mid, m, k)) \\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```\\n**Please upvote if helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool isPos(vector<int>& bloomDay, int day, int m, int k) {\\n\\t//Method returns true if it is possible to satisfy given requirement\\n        int n=bloomDay.size(), i=-1, j=0, numBq=0;    //i is point before start of window, j is point under examination\\n        while(j<n) {\\n            if(bloomDay[j]<=day) {\\n\\t\\t\\t//If the flower has bloomed\\n                if(j-i==k) {\\n                    numBq++;\\n                    i=j;\\n                }\\n                j++;\\n            }\\n            else {\\n\\t\\t\\t//Restart the window\\n                i = j;\\n                j++;\\n            }\\n        }\\n        return numBq>=m;\\n    }\\n    \\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        \\n        if(n < m * k)\\n            return -1;\\n        \\n        int left = 1, right = *max_element(bloomDay.begin(), bloomDay.end()), mid;\\n        while(left < right) {\\n            mid = left + (right - left)/2;\\n            \\n            if(isPos(bloomDay, mid, m, k)) \\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544038,
                "title": "easy-understanding-o-nlog-n-solution",
                "content": "question have a clue that one can choose adjacent k flowers from any subarray of the array\\n\\nclass Solution {\\n    public int minDays(int[] a, int m, int k) {\\n       int l = 0 ,  hi = 0 ,n = a.length,res = -1;\\n        \\n        if(m*k>n)return res;\\n        // Arrays.sort(a);\\n        for(int i : a)\\n        {\\n            l = Math.min(l,i);\\n            hi = Math.max(hi,i);\\n        }\\n        while(l<=hi)\\n        {\\n            int mid= (l+hi)>>1;\\n            if(isVal(a,m,k,mid))\\n            {\\n                res = mid;\\n                // System.out.print(\"--\"+res);\\n                hi = mid-1;\\n                \\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isVal(int[] a, int m , int  k , int mid)\\n    {\\n        int j = 0 ,i=0,buk = 0 ;\\n        while(i<a.length)\\n        {   if(a[i]<=mid)\\n            buk++;\\n            else buk = 0 ;\\n            if(buk==k)\\n            {\\n                j++;\\n                buk=0;\\n            }\\n            if(j==m)return true;\\n            i++;\\n        }\\n        return j>=m;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int minDays(int[] a, int m, int k) {\\n       int l = 0 ,  hi = 0 ,n = a.length,res = -1;\\n        \\n        if(m*k>n)return res;\\n        // Arrays.sort(a);\\n        for(int i : a)\\n        {\\n            l = Math.min(l,i);\\n            hi = Math.max(hi,i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2518363,
                "title": "binary-search-solution-in-python",
                "content": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m*k > len(bloomDay):\\n            return -1\\n        start=0\\n        end=self.findMax(bloomDay)\\n        res=-1\\n        while start<=end:\\n            mid=int((start+end)/2)\\n            if self.isValidScheme(bloomDay,mid,m,k)==True:\\n                res=mid\\n                end=mid-1\\n            else:\\n                start=mid+1\\n        return res\\n    def isValidScheme(self,bloomDay,mid,b,f):\\n        boq=0\\n        flower=0\\n        for i in range(len(bloomDay)):\\n            if bloomDay[i]<=mid:\\n                flower=flower+1\\n            if bloomDay[i]>mid:\\n                flower=0\\n            if flower==f:\\n                boq=boq+1\\n                flower=0\\n            if boq==b:\\n                return True\\n        return False\\n    def findMax(self,arr):\\n        max=0\\n        for i in arr:\\n            if i>max:\\n                max=i\\n        return max\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if m*k > len(bloomDay):\\n            return -1\\n        start=0\\n        end=self.findMax(bloomDay)\\n        res=-1\\n        while start<=end:\\n            mid=int((start+end)/2)\\n            if self.isValidScheme(bloomDay,mid,m,k)==True:\\n                res=mid\\n                end=mid-1\\n            else:\\n                start=mid+1\\n        return res\\n    def isValidScheme(self,bloomDay,mid,b,f):\\n        boq=0\\n        flower=0\\n        for i in range(len(bloomDay)):\\n            if bloomDay[i]<=mid:\\n                flower=flower+1\\n            if bloomDay[i]>mid:\\n                flower=0\\n            if flower==f:\\n                boq=boq+1\\n                flower=0\\n            if boq==b:\\n                return True\\n        return False\\n    def findMax(self,arr):\\n        max=0\\n        for i in arr:\\n            if i>max:\\n                max=i\\n        return max\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509404,
                "title": "java-binary-search-with-predicate-function-self-descriptive-codes",
                "content": "*For commented and Explaination, follow the link below*\\n[https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/2509397/Java-or-Binary-Search(On-Day)-or-Handwritten-Explaination-or-TLE-to-Accepted]\\n```\\nclass Solution extends PredicateAPI {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m * 1L * k) return -1;\\n        return minimumDaysToMakeMBouquets(bloomDay, m, k);\\n    }\\n    \\n    private int minimumDaysToMakeMBouquets(int[] bloomDay, int m, int k) {\\n        int maxBloomDay = Arrays.stream(bloomDay).max().getAsInt(); \\n        int left = 1, right = maxBloomDay;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(isPossibleToMakeMBouquetsWithinDDays(bloomDay, m, k, mid))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n}\\n\\nclass PredicateAPI {\\n    private int[] hasFoundKAdjacentFlowers(int[] bloomDay, int d, int left, int right) {\\n        while(left < right) {\\n            if(bloomDay[left] > d)\\n                return new int[]{0, left};\\n            left += 1;\\n        }\\n        return new int[]{1, right};\\n    }\\n    \\n    boolean isPossibleToMakeMBouquetsWithinDDays(int[] bloomDay, int m, int k, int d) {\\n        int lastWinStart = bloomDay.length - k;\\n        int left = 0, right = k;\\n        while(left <= lastWinStart) {\\n            int[] found = hasFoundKAdjacentFlowers(bloomDay, d, left, right);\\n            if(found[0] == 1) m -= 1;\\n            left = (found[0] == 1) ? found[1] : found[1] + 1;\\n            right = left + k;\\n            if(m == 0) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution extends PredicateAPI {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(bloomDay.length < m * 1L * k) return -1;\\n        return minimumDaysToMakeMBouquets(bloomDay, m, k);\\n    }\\n    \\n    private int minimumDaysToMakeMBouquets(int[] bloomDay, int m, int k) {\\n        int maxBloomDay = Arrays.stream(bloomDay).max().getAsInt(); \\n        int left = 1, right = maxBloomDay;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(isPossibleToMakeMBouquetsWithinDDays(bloomDay, m, k, mid))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n}\\n\\nclass PredicateAPI {\\n    private int[] hasFoundKAdjacentFlowers(int[] bloomDay, int d, int left, int right) {\\n        while(left < right) {\\n            if(bloomDay[left] > d)\\n                return new int[]{0, left};\\n            left += 1;\\n        }\\n        return new int[]{1, right};\\n    }\\n    \\n    boolean isPossibleToMakeMBouquetsWithinDDays(int[] bloomDay, int m, int k, int d) {\\n        int lastWinStart = bloomDay.length - k;\\n        int left = 0, right = k;\\n        while(left <= lastWinStart) {\\n            int[] found = hasFoundKAdjacentFlowers(bloomDay, d, left, right);\\n            if(found[0] == 1) m -= 1;\\n            left = (found[0] == 1) ? found[1] : found[1] + 1;\\n            right = left + k;\\n            if(m == 0) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496565,
                "title": "c-easy-and-clean-code-100-faster-with-comment",
                "content": "class Solution {\\n    \\n    public:\\n    bool isPosibleDay(vector<int> &arr,int m,int k,int mid){\\n        int count=0; //flower which bloom\\n        int ans=0; // bouquet\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            // check if flower bloom or not and its hould be in continuos manner is yes count++ else we have reste count\\n            if(arr[i]<=mid){\\n               count++; \\n            }\\n            else\\n            {\\n                count=0;\\n            }\\n            \\n            //we need to check like we have require flower to make  one bouquet if yes increase ans ++ \\n            if(count==k){\\n                ans++;\\n                count=0;\\n            }\\n            \\n        }\\n        \\n        return ans>=m;\\n        \\n    }\\n    \\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        \\n        int start=*min_element(bloomDay.begin(),bloomDay.end());  // if all flower bloom on first day then we require min\\n        int end=*max_element(bloomDay.begin(),bloomDay.end()); // if all flower bloom on last day then we require max \\n        \\n        int ans=-1;\\n        \\n        \\n        //we can directly return -1 if our require flower is greater then what available\\n        if(m*k>bloomDay.size()){\\n            return ans;\\n        }\\n        \\n        // binary search on answer\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n           \\n            \\n            // here we got valid solution so we store and we need minimum so we are eliminating large part\\n            if(isPosibleDay(bloomDay,m,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n    public:\\n    bool isPosibleDay(vector<int> &arr,int m,int k,int mid){\\n        int count=0; //flower which bloom\\n        int ans=0; // bouquet\\n        \\n        for(int i=0;i<arr.size();i++){\\n            \\n            // check if flower bloom or not and its hould be in continuos manner is yes count++ else we have reste count\\n            if(arr[i]<=mid){\\n               count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2496533,
                "title": "100-faster-java-solution-using-binary-search",
                "content": "```\\n public boolean isPossible(int arr[], int days,int k,int m){\\n        int n = arr.length;\\n        int count = 0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]<=days){\\n                count++;\\n            }else{\\n                count = 0;\\n            }\\n            if(count==k){\\n                ans++;\\n                count = 0;\\n            }\\n        }\\n        return ans>=m;\\n    }\\n    \\n    public int minDays(int[] bloomDay, int m, int k) {\\n        // Arrays.sort(bloomDay);\\n        int start = Integer.MAX_VALUE, end = Integer.MIN_VALUE, n = bloomDay.length;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            start = Math.min(start,bloomDay[i]);\\n            end = Math.max(end,bloomDay[i]);\\n        }\\n        \\n        int ans = -1;\\n        int toallFlowers = m*k;\\n        if(toallFlowers>n)\\n            return ans;\\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(isPossible(bloomDay,mid,k,m)){\\n                ans = mid;\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n public boolean isPossible(int arr[], int days,int k,int m){\\n        int n = arr.length;\\n        int count = 0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]<=days){\\n                count++;\\n            }else{\\n                count = 0;\\n            }\\n            if(count==k){\\n                ans++;\\n                count = 0;\\n            }\\n        }\\n        return ans>=m;\\n    }\\n    \\n    public int minDays(int[] bloomDay, int m, int k) {\\n        // Arrays.sort(bloomDay);\\n        int start = Integer.MAX_VALUE, end = Integer.MIN_VALUE, n = bloomDay.length;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            start = Math.min(start,bloomDay[i]);\\n            end = Math.max(end,bloomDay[i]);\\n        }\\n        \\n        int ans = -1;\\n        int toallFlowers = m*k;\\n        if(toallFlowers>n)\\n            return ans;\\n        while(start<=end){\\n            int mid = start + (end - start)/2;\\n            if(isPossible(bloomDay,mid,k,m)){\\n                ans = mid;\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474167,
                "title": "easy-c-solution-with-full-explanation",
                "content": "// Range of our answer will lie between minimum and maximim of bloomdays beacuse we need minimum 1 flower to make a bouquet ans maximum all flowers.\\n\\nExample: bloomDays=[1,10,3,10,2]\\nthen our st=1 and en=10.\\n\\nclass Solution {\\npublic:\\n  \\n  //this function is used to check whether we can make at least m bouquest with mid as our bloom day\\n\\n    bool check(vector<int>v,int bouquets,int flow,int day)\\n    {\\n        int adjFlowers=0,bouq=0;\\n        for (int i = 0; i < v.size(); i++) {\\n               if (v[i] > day) {\\n                 adjFlowers = 0;\\n                } else if (++adjFlowers == flow) {\\n                    bouq++;\\n                    adjFlowers = 0;\\n                }\\n            }\\n        return (bouq>=bouquets);\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k>bloomDay.size())\\n            return -1;\\n        int st=INT_MAX,en=INT_MIN;\\n        int n=bloomDay.size();\\n        int ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            st=min(st,bloomDay[i]);\\n            en=max(en,bloomDay[i]);\\n        }\\n        while(st<=en)\\n        {\\n            int mid=st+(en-st)/2;\\n            if(check(bloomDay,m,k,mid))\\n            {\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else\\n                st=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease upvote it if you like the solution :)",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n  \\n  //this function is used to check whether we can make at least m bouquest with mid as our bloom day\\n\\n    bool check(vector<int>v,int bouquets,int flow,int day)\\n    {\\n        int adjFlowers=0,bouq=0;\\n        for (int i = 0; i < v.size(); i++) {\\n               if (v[i] > day) {\\n                 adjFlowers = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2445995,
                "title": "java-o-log-n-binary-search",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int s = min(bloomDay), e = (int)1e9, ans = -1;\\n        while(s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if(completable(bloomDay, mid, m, k)) {\\n                ans = mid;\\n                e = mid - 1;\\n            } else s = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    public static boolean completable(int[] arr, int nod, int nob, int nof) {\\n       int k = 0, m = 0;\\n       for(int i : arr) {\\n           if(i <= nod) {\\n               k ++;\\n               if(k == nof) {\\n                   m++;\\n                   k = 0;    \\n               }\\n           } else k = 0;\\n       }\\n        return m >= nob;\\n    }\\n    \\n    public int min(int[] wts) {\\n        int min = wts[0];\\n        for(int i : wts) if(i < min) min = i;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int s = min(bloomDay), e = (int)1e9, ans = -1;\\n        while(s <= e) {\\n            int mid = s + (e - s) / 2;\\n            if(completable(bloomDay, mid, m, k)) {\\n                ans = mid;\\n                e = mid - 1;\\n            } else s = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    public static boolean completable(int[] arr, int nod, int nob, int nof) {\\n       int k = 0, m = 0;\\n       for(int i : arr) {\\n           if(i <= nod) {\\n               k ++;\\n               if(k == nof) {\\n                   m++;\\n                   k = 0;    \\n               }\\n           } else k = 0;\\n       }\\n        return m >= nob;\\n    }\\n    \\n    public int min(int[] wts) {\\n        int min = wts[0];\\n        for(int i : wts) if(i < min) min = i;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434712,
                "title": "simple-c-solution-binary-search-100-fast-o-nlongn-time-complexity",
                "content": "```\\nclass Solution {\\n    bool ispossible(vector<int>& bloomDay, int &day, int &m, int &k)\\n    {\\n        int c = 0, d = 0;\\n        for(int bday : bloomDay)\\n        {\\n            c = bday <= day ? c+1 : 0;\\n            if(c == k)\\n                c = 0, d++;\\n        }\\n        return d >= m;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n =  bloomDay.size();\\n        if(n < m*k) return -1;\\n        int l = 1, h = *max_element(bloomDay.begin(), bloomDay.end());\\n        while(l<h)\\n        {\\n            int mid = l +(h-l)/2;\\n            if(ispossible(bloomDay, mid, m, k))\\n                h = mid;\\n            else\\n                l =  mid+1;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool ispossible(vector<int>& bloomDay, int &day, int &m, int &k)\\n    {\\n        int c = 0, d = 0;\\n        for(int bday : bloomDay)\\n        {\\n            c = bday <= day ? c+1 : 0;\\n            if(c == k)\\n                c = 0, d++;\\n        }\\n        return d >= m;\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n =  bloomDay.size();\\n        if(n < m*k) return -1;\\n        int l = 1, h = *max_element(bloomDay.begin(), bloomDay.end());\\n        while(l<h)\\n        {\\n            int mid = l +(h-l)/2;\\n            if(ispossible(bloomDay, mid, m, k))\\n                h = mid;\\n            else\\n                l =  mid+1;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421142,
                "title": "c-binary-search-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use binary search to find the minimum number of days it takes for `m` bouquets of flowers to bloom. We can start with `l = 1` and `r = 1e9` as the minimum and maximum possible number of days. We can then check the middle day using the `check` function. If the number of bouquets that bloom on the middle day is less than `m`, we can search for a larger day by setting `l = mid + 1`. Otherwise, we can search for a smaller day by setting `r = mid`. We can continue this process until we find the minimum number of days.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n log(mx))$$, where n is the length of bloomDay, m is the number of bouquets needed, and x is the maximum value in bloomDay. This is because we perform binary search on the range of possible days, and for each day we need to check if it is possible to form m bouquets with k flowers. This takes $$O(n)$$ time, so the overall time complexity is $$O(n log(mx))$$.\\n\\n- Space complexity: $$O(1)$$ We use constant space to store variables and perform calculations, so the space complexity is $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int>& bloomDay, int day, int k) {\\n        int count = 0;\\n        int res = 0;\\n        for(int b : bloomDay) {\\n            if(b <= day) {\\n                count++;\\n                if(count >= k) {\\n                    // increment the result by the number of k bouquets that can be made\\n                    res += count / k;\\n                    count = 0;\\n                }\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int l = 1, r = 1e9;\\n        // if it is impossible to form m bouquets with k flowers, return -1\\n        if(m * k > bloomDay.size()) return -1;\\n        \\n        while(l < r) {\\n            // set the middle value between l and r\\n            int mid = (l + r) / 2;\\n\\n            // if it is not possible to form m bouquets with k flowers with the current middle value\\n            if(check(bloomDay, mid, k) < m) {\\n                l = mid + 1; // increase l to mid + 1\\n            } else {\\n                r = mid; // otherwise, set r to mid\\n            }\\n        }\\n        return l; // return l as the minimum number of days required to form m bouquets with k flowers\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int>& bloomDay, int day, int k) {\\n        int count = 0;\\n        int res = 0;\\n        for(int b : bloomDay) {\\n            if(b <= day) {\\n                count++;\\n                if(count >= k) {\\n                    // increment the result by the number of k bouquets that can be made\\n                    res += count / k;\\n                    count = 0;\\n                }\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int l = 1, r = 1e9;\\n        // if it is impossible to form m bouquets with k flowers, return -1\\n        if(m * k > bloomDay.size()) return -1;\\n        \\n        while(l < r) {\\n            // set the middle value between l and r\\n            int mid = (l + r) / 2;\\n\\n            // if it is not possible to form m bouquets with k flowers with the current middle value\\n            if(check(bloomDay, mid, k) < m) {\\n                l = mid + 1; // increase l to mid + 1\\n            } else {\\n                r = mid; // otherwise, set r to mid\\n            }\\n        }\\n        return l; // return l as the minimum number of days required to form m bouquets with k flowers\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351788,
                "title": "c-most-easy-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n      bool check(int mid,vector<int> &v, int m, int k)\\n      {\\n          int n=v.size();\\n          int cnt=0;// taking cnt for the no of k adjacent bouquets possible\\n          for(int i=0;i<v.size();i++)\\n          {\\n              if(v[i]<=mid)\\n              {\\n                  int c=0;\\n                  while(i<n and v[i]<=mid)\\n                  {\\n                      i++;\\n                      c++;// c->checking for adjacent count\\n                  }\\n                 cnt+=c/k;\\n              }\\n          }\\n          if(cnt>=m)\\n              return true;\\n          return false;\\n          \\n      }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s=*min_element(bloomDay.begin(),bloomDay.end());\\n        int e=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=e;\\n        if((m*k)>bloomDay.size())\\n            return -1;\\n        while(s<=e)\\n        {\\n           int mid=s+(e-s)/2;\\n            if(check(mid,bloomDay,m,k))\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      bool check(int mid,vector<int> &v, int m, int k)\\n      {\\n          int n=v.size();\\n          int cnt=0;// taking cnt for the no of k adjacent bouquets possible\\n          for(int i=0;i<v.size();i++)\\n          {\\n              if(v[i]<=mid)\\n              {\\n                  int c=0;\\n                  while(i<n and v[i]<=mid)\\n                  {\\n                      i++;\\n                      c++;// c->checking for adjacent count\\n                  }\\n                 cnt+=c/k;\\n              }\\n          }\\n          if(cnt>=m)\\n              return true;\\n          return false;\\n          \\n      }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s=*min_element(bloomDay.begin(),bloomDay.end());\\n        int e=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=e;\\n        if((m*k)>bloomDay.size())\\n            return -1;\\n        while(s<=e)\\n        {\\n           int mid=s+(e-s)/2;\\n            if(check(mid,bloomDay,m,k))\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309926,
                "title": "java-binary-search-solution-brute-force-optimization",
                "content": "Time Complexity - O(n * n * log(max item in bloomDay)) \\n\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low = 1;\\n        int high = Integer.MIN_VALUE;\\n        \\n        for (int day : bloomDay) {\\n            high = Math.max(day, high);\\n        }\\n        \\n        boolean flag = false;\\n            \\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if (isPossible(bloomDay, m, k, mid)) {\\n                flag = true;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n        \\n        return flag ? low : -1;\\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int m, int k, int day) {\\n        \\n        for (int i=0; i < bloomDay.length - k + 1; i++) {\\n            int count = 0;\\n            for (int j = i; j < i + k; j++) {\\n                if (bloomDay[j] <= day)\\n                    count++;\\n                else \\n                    break;\\n            }\\n            \\n            if (count == k) {\\n                m--;\\n                i = i + k - 1;\\n            }\\n        }\\n      \\n        return m <= 0;\\n    }\\n}\\n```\\n\\nReducing time complexity of isPossible method from 0(n*n) to O(n)\\n\\nTime Complexity - 0(n * log(max item in bloomDay));\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low = Integer.MAX_VALUE;\\n        int high = Integer.MIN_VALUE;\\n        \\n        for (int day : bloomDay) {\\n            high = Math.max(day, high);\\n            low = Math.min(day, low);\\n        }\\n        \\n        boolean flag = false;\\n            \\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if (isPossible(bloomDay, m, k, mid)) {\\n                flag = true;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n        \\n        return flag ? low : -1;\\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int m, int k, int day) {\\n        int count = 0;\\n        \\n        for (int i=0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] <= day)\\n                    count++;\\n            else\\n                count = 0;\\n            \\n            if (count == k) {\\n                m--;\\n                count = 0;\\n            }\\n        }\\n      \\n        return m <= 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low = 1;\\n        int high = Integer.MIN_VALUE;\\n        \\n        for (int day : bloomDay) {\\n            high = Math.max(day, high);\\n        }\\n        \\n        boolean flag = false;\\n            \\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if (isPossible(bloomDay, m, k, mid)) {\\n                flag = true;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n        \\n        return flag ? low : -1;\\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int m, int k, int day) {\\n        \\n        for (int i=0; i < bloomDay.length - k + 1; i++) {\\n            int count = 0;\\n            for (int j = i; j < i + k; j++) {\\n                if (bloomDay[j] <= day)\\n                    count++;\\n                else \\n                    break;\\n            }\\n            \\n            if (count == k) {\\n                m--;\\n                i = i + k - 1;\\n            }\\n        }\\n      \\n        return m <= 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int low = Integer.MAX_VALUE;\\n        int high = Integer.MIN_VALUE;\\n        \\n        for (int day : bloomDay) {\\n            high = Math.max(day, high);\\n            low = Math.min(day, low);\\n        }\\n        \\n        boolean flag = false;\\n            \\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if (isPossible(bloomDay, m, k, mid)) {\\n                flag = true;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n        \\n        return flag ? low : -1;\\n    }\\n    \\n    private boolean isPossible(int[] bloomDay, int m, int k, int day) {\\n        int count = 0;\\n        \\n        for (int i=0; i < bloomDay.length; i++) {\\n            if (bloomDay[i] <= day)\\n                    count++;\\n            else\\n                count = 0;\\n            \\n            if (count == k) {\\n                m--;\\n                count = 0;\\n            }\\n        }\\n      \\n        return m <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263361,
                "title": "73-tc-and-92-tc-easy-python-solution",
                "content": "```\\ndef minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n\\tn = len(bloomDay)\\n\\tif(n < m*k):\\n\\t\\treturn -1\\n\\tlru_cache(None)\\n\\tdef isValid(day):\\n\\t\\ti = 0\\n\\t\\tc = 0\\n\\t\\ttemp = 0\\n\\t\\twhile(i < n):\\n\\t\\t\\tif(bloomDay[i] <= day):\\n\\t\\t\\t\\tc += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp += c//k\\n\\t\\t\\t\\tc = 0\\n\\t\\t\\tif(temp >= m):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\ti += 1\\n\\t\\ttemp += c//k\\n\\t\\tif(temp >= m):\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\ti, j = min(bloomDay), max(bloomDay)\\n\\tans = -1\\n\\twhile(i <= j):\\n\\t\\tmid = (i+j)//2\\n\\t\\tx = isValid(mid)\\n\\t\\tif(x):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n\\tn = len(bloomDay)\\n\\tif(n < m*k):\\n\\t\\treturn -1\\n\\tlru_cache(None)\\n\\tdef isValid(day):\\n\\t\\ti = 0\\n\\t\\tc = 0\\n\\t\\ttemp = 0\\n\\t\\twhile(i < n):\\n\\t\\t\\tif(bloomDay[i] <= day):\\n\\t\\t\\t\\tc += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp += c//k\\n\\t\\t\\t\\tc = 0\\n\\t\\t\\tif(temp >= m):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\ti += 1\\n\\t\\ttemp += c//k\\n\\t\\tif(temp >= m):\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\ti, j = min(bloomDay), max(bloomDay)\\n\\tans = -1\\n\\twhile(i <= j):\\n\\t\\tmid = (i+j)//2\\n\\t\\tx = isValid(mid)\\n\\t\\tif(x):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2263315,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& bloomDay, int m, int k, int day){\\n        int cur = 0;\\n        int cnt = 0;\\n        cout<<day<<\" \";\\n        for(int i=0; i<bloomDay.size(); i++){\\n            if(day >= bloomDay[i]){\\n                cur++;\\n            }else{\\n                cnt += cur/k;\\n                cur = 0;\\n            }\\n        }\\n        cnt += cur/k;\\n        cout<<cnt<<\"\\\\n\";\\n        return cnt>=m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(m*k > n) return -1;\\n        int l=INT_MAX, r=INT_MIN;\\n        for(auto it:bloomDay){\\n            l = min(it,l);\\n            r = max(it,r);\\n        }\\n        int res = INT_MAX;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(bloomDay,m,k,mid)){\\n                res = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& bloomDay, int m, int k, int day){\\n        int cur = 0;\\n        int cnt = 0;\\n        cout<<day<<\" \";\\n        for(int i=0; i<bloomDay.size(); i++){\\n            if(day >= bloomDay[i]){\\n                cur++;\\n            }else{\\n                cnt += cur/k;\\n                cur = 0;\\n            }\\n        }\\n        cnt += cur/k;\\n        cout<<cnt<<\"\\\\n\";\\n        return cnt>=m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(m*k > n) return -1;\\n        int l=INT_MAX, r=INT_MIN;\\n        for(auto it:bloomDay){\\n            l = min(it,l);\\n            r = max(it,r);\\n        }\\n        int res = INT_MAX;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(bloomDay,m,k,mid)){\\n                res = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2249455,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(m*k>bloomDay.length) return -1;\\n        int lo=1,hi=1_000_000_000;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(isPossible(bloomDay,k,mid,m)) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return hi+1;\\n    }\\n    private boolean isPossible(int[] arr, int k, int time, int m){\\n        int bqs = 0,start = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>time) start = i+1;\\n            else if(i-start+1 == k) {bqs++;start=i+1;} \\n        }\\n        return bqs>=m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(m*k>bloomDay.length) return -1;\\n        int lo=1,hi=1_000_000_000;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(isPossible(bloomDay,k,mid,m)) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return hi+1;\\n    }\\n    private boolean isPossible(int[] arr, int k, int time, int m){\\n        int bqs = 0,start = 0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>time) start = i+1;\\n            else if(i-start+1 == k) {bqs++;start=i+1;} \\n        }\\n        return bqs>=m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240283,
                "title": "java-binary-search-with-approach-and-commented-code",
                "content": "Approach :\\n* Create a helper function (checkBouquets) which returns true / false, whether we can get \\'m\\' bouquets for a given day using \\'k\\' adjecent flowers.\\n* Find the min and max day from \\'bloomDay\\'. Call it min and max. They represet that we need at least \\'min\\' day or at most \\'max\\' day to get the bouquets.\\n* The answer should be between [min,max]\\n* Do a binary search on min and max.\\n\\nCommented the code.\\n```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int min = 0; // hold minimum days\\n        int max = 0;// hold max days\\n        for(int d:bloomDay){\\n            min = min>d?d:min;\\n            max = max<d?d:max;\\n        }\\n        int minday = -1; \\n        // do abinary search between min and max day.\\n        // As we need min day to get at least 1 flower and max day to get all flower.\\n        // The answer should be [min,max]\\n        // We do a binary search to get the minimum no of day needed.\\n        while(min<=max){\\n            int mid = min + (max-min)/2; \\n            if(checkBouquets(bloomDay, m, k, mid)) // this checkBouquets : return if we can create all the bouquets with give condition\\n            {\\n                // we can get the m bouquets. lets try with smaller no of day.\\n                minday = mid;\\n                max = mid-1;\\n            }else{\\n                 // we can\\'t get the m bouquets. lets try with big no of day.\\n                min = mid+1;\\n            }\\n        }\\n        return minday;\\n    }\\n    \\n    private boolean checkBouquets(int[] bloomDay, int m, int k, int day){\\n        int count = 0;\\n        int bouquets = 0;\\n        for(int d:bloomDay) // loop over all flower\\n        { \\n            if(d<=day){ // if the bloomDay of flower is less or equal to day, then increase the count, else reset it to 0.\\n               count++; \\n            }else {\\n                count = 0;\\n            }\\n            /*\\n            if the count is equal to given adjacent number increase the no of bouquets and reset the count to 0.\\n            We are reseting count to zero so that the count for next bouquet begin (one flower can be part of exactly one bouquet).\\n            */\\n            if(count == k){ \\n                count = 0;\\n                bouquets++;\\n            }\\n        }\\n        // return the count of bouquets >= m(target).\\n        return bouquets >= m; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int min = 0; // hold minimum days\\n        int max = 0;// hold max days\\n        for(int d:bloomDay){\\n            min = min>d?d:min;\\n            max = max<d?d:max;\\n        }\\n        int minday = -1; \\n        // do abinary search between min and max day.\\n        // As we need min day to get at least 1 flower and max day to get all flower.\\n        // The answer should be [min,max]\\n        // We do a binary search to get the minimum no of day needed.\\n        while(min<=max){\\n            int mid = min + (max-min)/2; \\n            if(checkBouquets(bloomDay, m, k, mid)) // this checkBouquets : return if we can create all the bouquets with give condition\\n            {\\n                // we can get the m bouquets. lets try with smaller no of day.\\n                minday = mid;\\n                max = mid-1;\\n            }else{\\n                 // we can\\'t get the m bouquets. lets try with big no of day.\\n                min = mid+1;\\n            }\\n        }\\n        return minday;\\n    }\\n    \\n    private boolean checkBouquets(int[] bloomDay, int m, int k, int day){\\n        int count = 0;\\n        int bouquets = 0;\\n        for(int d:bloomDay) // loop over all flower\\n        { \\n            if(d<=day){ // if the bloomDay of flower is less or equal to day, then increase the count, else reset it to 0.\\n               count++; \\n            }else {\\n                count = 0;\\n            }\\n            /*\\n            if the count is equal to given adjacent number increase the no of bouquets and reset the count to 0.\\n            We are reseting count to zero so that the count for next bouquet begin (one flower can be part of exactly one bouquet).\\n            */\\n            if(count == k){ \\n                count = 0;\\n                bouquets++;\\n            }\\n        }\\n        // return the count of bouquets >= m(target).\\n        return bouquets >= m; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131053,
                "title": "javascript-js-solution-ultrafast",
                "content": "JavaScript solution\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    if (m * k > bloomDay.length) {\\n        return -1;\\n    }\\n\\n    let left = 0;\\n    let right = 0;\\n    \\n    for (const day of bloomDay) {\\n        left = Math.min(day, left);\\n        right = Math.max(day, right);\\n    }\\n\\n    let ans = right;\\n    \\n    while (left < right) {\\n        const day = Math.floor((left + right) / 2);\\n        \\n        let count = 0;\\n        let current = 0;\\n        \\n        for (let j = 0; j < bloomDay.length; j++) {\\n            if (bloomDay[j] <= day) {\\n                current++;\\n            } else {\\n                current = 0;\\n            }\\n            \\n            if (current === k) {\\n                count++;\\n                current = 0;\\n            }\\n        }\\n\\n        if (count === m) {\\n            ans = Math.min(ans, day);\\n        }\\n\\n        if (count < m) {\\n            left = day + 1;\\n        } else {\\n            right = day;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar minDays = function(bloomDay, m, k) {\\n    if (m * k > bloomDay.length) {\\n        return -1;\\n    }\\n\\n    let left = 0;\\n    let right = 0;\\n    \\n    for (const day of bloomDay) {\\n        left = Math.min(day, left);\\n        right = Math.max(day, right);\\n    }\\n\\n    let ans = right;\\n    \\n    while (left < right) {\\n        const day = Math.floor((left + right) / 2);\\n        \\n        let count = 0;\\n        let current = 0;\\n        \\n        for (let j = 0; j < bloomDay.length; j++) {\\n            if (bloomDay[j] <= day) {\\n                current++;\\n            } else {\\n                current = 0;\\n            }\\n            \\n            if (current === k) {\\n                count++;\\n                current = 0;\\n            }\\n        }\\n\\n        if (count === m) {\\n            ans = Math.min(ans, day);\\n        }\\n\\n        if (count < m) {\\n            left = day + 1;\\n        } else {\\n            right = day;\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128929,
                "title": "c-short-concise-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeBoquet(vector<int>& bloomDay, int& m, int& k, int& mid){\\n        int count = 0;\\n        int adjacent = 0;\\n        \\n        for(auto &flower : bloomDay){\\n            if(flower > mid){ // flower doesnt bloom yet\\n                adjacent = 0;\\n            }else{\\n                ++adjacent;\\n                if(adjacent == k){\\n                    count++;\\n                    adjacent = 0;\\n                }\\n            }\\n            if(count == m){ // we already made m boquets\\n                break;\\n            }\\n        }\\n        return count>=m;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k > bloomDay.size()){\\n            return -1;\\n        }\\n        \\n        int low = INT_MAX;\\n        int high = INT_MIN;\\n        int ans = -1;\\n        \\n        for(auto &elem : bloomDay){\\n            low = min(low, elem);\\n            high = max(high, elem);\\n        }\\n        \\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            bool boquetPossible = makeBoquet(bloomDay, m, k, mid);\\n            \\n            if(boquetPossible){\\n                ans = mid; // this could be potential answer\\n                high = mid-1; // continue minimizing bloom day\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool makeBoquet(vector<int>& bloomDay, int& m, int& k, int& mid){\\n        int count = 0;\\n        int adjacent = 0;\\n        \\n        for(auto &flower : bloomDay){\\n            if(flower > mid){ // flower doesnt bloom yet\\n                adjacent = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2115254,
                "title": "c-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& bloomDay,int m,int k,int maxDay){\\n        int adj=0,nb=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=maxDay and adj<k){\\n                adj++;\\n            }else if(bloomDay[i]<=maxDay and adj==k){\\n                nb++;\\n                adj=1;\\n            }else if(bloomDay[i]>maxDay and adj<k){\\n                adj=0;\\n            }else if(bloomDay[i]>maxDay and adj==k){\\n                nb++;\\n                adj=0;\\n            }\\n        }\\n        if(adj==k){\\n            nb++;\\n        }\\n        return nb>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int l=*min_element(bloomDay.begin(),bloomDay.end());\\n        int r=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(l<=r){\\n            int mxDay=l+(r-l)/2;\\n            \\n            if(isPossible(bloomDay,m,k,mxDay)){\\n                ans=mxDay;\\n                r=mxDay-1;\\n            }else{\\n                l=mxDay+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& bloomDay,int m,int k,int maxDay){\\n        int adj=0,nb=0;\\n        for(int i=0;i<bloomDay.size();i++){\\n            if(bloomDay[i]<=maxDay and adj<k){\\n                adj++;\\n            }else if(bloomDay[i]<=maxDay and adj==k){\\n                nb++;\\n                adj=1;\\n            }else if(bloomDay[i]>maxDay and adj<k){\\n                adj=0;\\n            }else if(bloomDay[i]>maxDay and adj==k){\\n                nb++;\\n                adj=0;\\n            }\\n        }\\n        if(adj==k){\\n            nb++;\\n        }\\n        return nb>=m;\\n    }\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int l=*min_element(bloomDay.begin(),bloomDay.end());\\n        int r=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(l<=r){\\n            int mxDay=l+(r-l)/2;\\n            \\n            if(isPossible(bloomDay,m,k,mxDay)){\\n                ans=mxDay;\\n                r=mxDay-1;\\n            }else{\\n                l=mxDay+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105742,
                "title": "by-dog-stepped-on-bee",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] d, int m, int k) {\\n        int l=0;\\n        int h=0;\\n        int ans=-1;\\n        for(int x:d)if(x>h)h=x;\\n        while(l<=h){\\n            int mi=l+(h-l)/2;\\n            int c=0,dt=0;\\n            for(int x:d){\\n                \\n                if(x<=mi)dt++;\\n                else{\\n                    dt=0;\\n                }\\n                if(dt==k){\\n                    dt=0;\\n                    c++;\\n                }\\n            }\\n            if(c>=m){\\n                ans=mi;\\n                h=mi-1;\\n            }\\n            else{\\n                l=mi+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] d, int m, int k) {\\n        int l=0;\\n        int h=0;\\n        int ans=-1;\\n        for(int x:d)if(x>h)h=x;\\n        while(l<=h){\\n            int mi=l+(h-l)/2;\\n            int c=0,dt=0;\\n            for(int x:d){\\n                \\n                if(x<=mi)dt++;\\n                else{\\n                    dt=0;\\n                }\\n                if(dt==k){\\n                    dt=0;\\n                    c++;\\n                }\\n            }\\n            if(c>=m){\\n                ans=mi;\\n                h=mi-1;\\n            }\\n            else{\\n                l=mi+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950829,
                "title": "simple-and-clear-code-using-binary-search-on-answer",
                "content": "class Solution {\\npublic:\\n    bool ispossible(vector<int>& a, int m, int k,int mid){\\n        int c=0,mc=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<=mid){\\n                c++;\\n                if(c>=k){\\n                   mc++;\\n                    c=0;\\n                }\\n            }\\n            else{\\n                c=0;\\n            }           \\n        }\\n        if(mc>=m)\\n            return true;\\n        return false;\\n    }\\n    int minDays(vector<int>& a, int m, int k) {\\n        int ans=-1,s=0,c=0,n=a.size(),maxi=0;\\n        if(n<m*k)\\n            return -1;\\n        for(int i=0;i<n;i++)\\n            maxi=max(maxi,a[i]);\\n        int l=1,h=maxi;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            if(ispossible(a,m,k,mid)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispossible(vector<int>& a, int m, int k,int mid){\\n        int c=0,mc=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<=mid){\\n                c++;\\n                if(c>=k){\\n                   mc++;\\n                    c=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1950080,
                "title": "javascript-typescript-binary-search-explained-in-code",
                "content": "Following the great binary search template. Same idea as 875 Koko\\'s Bananas.\\n\\nThe search range is whatever we are trying to minimise. Here it is the number of days to pick all required bouquets.\\nso [1, maxDays] where maxDays is max day in bloomDay.\\n\\nSo for each binary search day, we test if it is possible to pick all the required flowers under constraints on with this day value.\\nCreating the function is the hard part imo, I had to look at the hint cos i was using sliding window at first lol ._.\\n\\n\\n```\\nfunction minDays(bloomDay: number[], m: number, k: number): number {\\n    // find min number of days to make m bouquets with k flowers\\n    // min no. of days. range is [1, max(bloomDay)];\\n    let maxDays = 0;\\n    // o(n)\\n    for(const d of bloomDay) {\\n        maxDays = Math.max(maxDays, d);\\n    }\\n    \\n    let left = 1;\\n    let right = maxDays;\\n\\n    // log(maxDays)\\n    while(left <= right) {\\n        // daysElapsed\\n        const mid = Math.floor(left + (right-left) / 2);\\n        \\n        // can we pick m bouquets with k flowers at daysELapsed\\n        if(canPickAllFlowers(bloomDay, mid, m, k)) {\\n            // shrink range find left border\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    // o(n*log(maxDays));\\n    if(left > maxDays) {\\n        return -1;\\n    }\\n    return left;\\n};\\n\\n// o(n);\\nfunction canPickAllFlowers(bloomDay: number[], daysElapsed: number, m: number, k: number) {\\n    let bouquetsPicked = 0;\\n    let numAdjFlowers = 0;\\n    \\n    for(const d of bloomDay) {\\n\\t\\t// can pick this flower as it is within our test day\\n\\t\\tif(d <= daysElapsed) {\\n\\t\\t\\t// add to num of adjacents\\n            numAdjFlowers++;\\n\\t\\t\\t// if enough flowers (constraint k flowers per bouquet, add to bouquet count)\\n            if(numAdjFlowers === k) {\\n                bouquetsPicked++;\\n\\t\\t\\t\\t// reset for next element\\n                numAdjFlowers = 0;\\n            }\\n        } else {\\n            numAdjFlowers = 0;\\n        }\\n    }\\n\\n    // do we have enough bouquets\\n    return bouquetsPicked >= m;\\n}```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Tree"
                ],
                "code": "```\\nfunction minDays(bloomDay: number[], m: number, k: number): number {\\n    // find min number of days to make m bouquets with k flowers\\n    // min no. of days. range is [1, max(bloomDay)];\\n    let maxDays = 0;\\n    // o(n)\\n    for(const d of bloomDay) {\\n        maxDays = Math.max(maxDays, d);\\n    }\\n    \\n    let left = 1;\\n    let right = maxDays;\\n\\n    // log(maxDays)\\n    while(left <= right) {\\n        // daysElapsed\\n        const mid = Math.floor(left + (right-left) / 2);\\n        \\n        // can we pick m bouquets with k flowers at daysELapsed\\n        if(canPickAllFlowers(bloomDay, mid, m, k)) {\\n            // shrink range find left border\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    // o(n*log(maxDays));\\n    if(left > maxDays) {\\n        return -1;\\n    }\\n    return left;\\n};\\n\\n// o(n);\\nfunction canPickAllFlowers(bloomDay: number[], daysElapsed: number, m: number, k: number) {\\n    let bouquetsPicked = 0;\\n    let numAdjFlowers = 0;\\n    \\n    for(const d of bloomDay) {\\n\\t\\t// can pick this flower as it is within our test day\\n\\t\\tif(d <= daysElapsed) {\\n\\t\\t\\t// add to num of adjacents\\n            numAdjFlowers++;\\n\\t\\t\\t// if enough flowers (constraint k flowers per bouquet, add to bouquet count)\\n            if(numAdjFlowers === k) {\\n                bouquetsPicked++;\\n\\t\\t\\t\\t// reset for next element\\n                numAdjFlowers = 0;\\n            }\\n        } else {\\n            numAdjFlowers = 0;\\n        }\\n    }\\n\\n    // do we have enough bouquets\\n    return bouquetsPicked >= m;\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940088,
                "title": "js-iterative-and-binary-search",
                "content": "The easiest way to solve these binary search problems is to start by implementing the iterative solution like so:\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    const requiredFlowers = k * m;\\n    if(bloomDay.length < requiredFlowers) return -1;\\n    \\n    const canMakeBouquets = (day) => {\\n        let bouquets = 0;\\n        let currentRun = 0;\\n        for(let i = 0; i < bloomDay.length; i++) {\\n            if(bloomDay[i] <= day) {\\n                currentRun++;\\n            } else {\\n                currentRun = 0;\\n            }\\n            if(currentRun === k){\\n                bouquets++;\\n                currentRun = 0;\\n            }\\n        }\\n        return bouquets >= m;\\n    }\\n    \\n    let right = Math.max(...bloomDay);\\n    \\n    for(let day = 1; day <= right; day++) {\\n        if(canMakeBouquets(day)) {\\n            return day;\\n        }\\n    }\\n};\\n```\\n\\nThen just replace the for-loop with a binary search:\\n\\n```\\nvar minDays = function(bloomDay, m, k) {\\n    const requiredFlowers = k * m;\\n    if(bloomDay.length < requiredFlowers) return -1;\\n    \\n    const canMakeBouquets = (day) => {\\n        let bouquets = 0;\\n        let currentRun = 0;\\n        for(let i = 0; i < bloomDay.length; i++) {\\n            if(bloomDay[i] <= day) {\\n                currentRun++;\\n            } else {\\n                currentRun = 0;\\n            }\\n            if(currentRun === k){\\n                bouquets++;\\n                currentRun = 0;\\n            }\\n        }\\n        return bouquets >= m;\\n    }\\n    \\n    let left = 1;\\n    let right = Math.max(...bloomDay);\\n    \\n    while(left < right) {\\n        let day = Math.floor((left + right) / 2);\\n        if(canMakeBouquets(day)) {\\n            right = day;\\n        } else {\\n            left = day+1;\\n        }\\n    }\\n    return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minDays = function(bloomDay, m, k) {\\n    const requiredFlowers = k * m;\\n    if(bloomDay.length < requiredFlowers) return -1;\\n    \\n    const canMakeBouquets = (day) => {\\n        let bouquets = 0;\\n        let currentRun = 0;\\n        for(let i = 0; i < bloomDay.length; i++) {\\n            if(bloomDay[i] <= day) {\\n                currentRun++;\\n            } else {\\n                currentRun = 0;\\n            }\\n            if(currentRun === k){\\n                bouquets++;\\n                currentRun = 0;\\n            }\\n        }\\n        return bouquets >= m;\\n    }\\n    \\n    let right = Math.max(...bloomDay);\\n    \\n    for(let day = 1; day <= right; day++) {\\n        if(canMakeBouquets(day)) {\\n            return day;\\n        }\\n    }\\n};\\n```\n```\\nvar minDays = function(bloomDay, m, k) {\\n    const requiredFlowers = k * m;\\n    if(bloomDay.length < requiredFlowers) return -1;\\n    \\n    const canMakeBouquets = (day) => {\\n        let bouquets = 0;\\n        let currentRun = 0;\\n        for(let i = 0; i < bloomDay.length; i++) {\\n            if(bloomDay[i] <= day) {\\n                currentRun++;\\n            } else {\\n                currentRun = 0;\\n            }\\n            if(currentRun === k){\\n                bouquets++;\\n                currentRun = 0;\\n            }\\n        }\\n        return bouquets >= m;\\n    }\\n    \\n    let left = 1;\\n    let right = Math.max(...bloomDay);\\n    \\n    while(left < right) {\\n        let day = Math.floor((left + right) / 2);\\n        if(canMakeBouquets(day)) {\\n            right = day;\\n        } else {\\n            left = day+1;\\n        }\\n    }\\n    return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929329,
                "title": "binary-search-python-solution-75-faster-memory-less-than-50",
                "content": "### ***Solution: Time O(n log(max)) / Memory O(1)***\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        def is_Possible(day):\\n            flowers=bouquet=0                \\n            for d in bloomDay:\\n                if d>day: flowers=0\\n                else:\\n                    flowers+=1\\n                    if flowers==k: bouquet+=1 ; flowers=0\\n            return bouquet>=m\\n            \\n        if len(bloomDay)<m*k: return -1       \\n        lo=min(bloomDay) ; hi=max(bloomDay)\\n        while lo<hi: \\n            mid=(lo+hi)//2 \\n            if is_Possible(mid): hi=mid          \\n            else: lo=mid+1\\n        return hi\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        def is_Possible(day):\\n            flowers=bouquet=0                \\n            for d in bloomDay:\\n                if d>day: flowers=0\\n                else:\\n                    flowers+=1\\n                    if flowers==k: bouquet+=1 ; flowers=0\\n            return bouquet>=m\\n            \\n        if len(bloomDay)<m*k: return -1       \\n        lo=min(bloomDay) ; hi=max(bloomDay)\\n        while lo<hi: \\n            mid=(lo+hi)//2 \\n            if is_Possible(mid): hi=mid          \\n            else: lo=mid+1\\n        return hi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908205,
                "title": "java-o-nlog-max-binary-search-on-answer",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(m*k>bloomDay.length)\\n            return -1;\\n        \\n        int low=bloomDay[0],high=bloomDay[0];\\n        \\n        for(int x : bloomDay){\\n            low=Math.min(low,x);\\n            high=Math.max(high,x);\\n        }\\n        \\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            int bouqetsPossible=search(bloomDay,mid,k);\\n            \\n            if(bouqetsPossible<m)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n        }\\n        return low; \\n    }\\n    \\n    int search(int[] ar,int val,int k){\\n        int res=0;\\n        int i=0,n=ar.length;\\n        \\n        while(i<n){\\n            int j=i;\\n            int cnt=0;\\n            while(j<i+k && j<n){\\n                if(ar[j]<=val)\\n                    cnt++;\\n                else\\n                    break;\\n                j++;\\n            }\\n            if(cnt==k)\\n            {\\n                res++;\\n                i=j;\\n            }\\n            else\\n                i=j+1;\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        if(m*k>bloomDay.length)\\n            return -1;\\n        \\n        int low=bloomDay[0],high=bloomDay[0];\\n        \\n        for(int x : bloomDay){\\n            low=Math.min(low,x);\\n            high=Math.max(high,x);\\n        }\\n        \\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            int bouqetsPossible=search(bloomDay,mid,k);\\n            \\n            if(bouqetsPossible<m)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n        }\\n        return low; \\n    }\\n    \\n    int search(int[] ar,int val,int k){\\n        int res=0;\\n        int i=0,n=ar.length;\\n        \\n        while(i<n){\\n            int j=i;\\n            int cnt=0;\\n            while(j<i+k && j<n){\\n                if(ar[j]<=val)\\n                    cnt++;\\n                else\\n                    break;\\n                j++;\\n            }\\n            if(cnt==k)\\n            {\\n                res++;\\n                i=j;\\n            }\\n            else\\n                i=j+1;\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901274,
                "title": "c-easy-to-undestand-with-explanation",
                "content": "**Approach:-** Applying Binary Search on Answer Approach.\\n-->What Actully we are doing?\\n\\n-->**The Lowest Day we require** = Minimum Element of array.\\n-->**The Highest Day we require is** = Maximum Element of array.\\n\\nNow We Check In Between thease days:-\\n**We Calculate a mid day.:-**\\nAnd For Mid day we check how many Bouquets we will form by taking consecutive **k** flowers(whithin mid day)\\n\\n-->If the total number of Bouquets form within mid day is greater than equal to **m**\\n  -->Then this is our one of the Possible answer. so we update high=mid-1; \\n  \\n-->If the total number of boquet form within mid day is less than m.\\nthen we increase low=mid+1;\\n\\n\\nTo understand what is happening inside **isPossible** function look at the code and read comment.\\n```\\nclass Solution {\\npublic: \\n    bool isPossible(vector<int>&nums,int mid,int k,int m)\\n    {\\n        /*Its Little bit Sliding window type.\\n        But not same*/\\n        int i=0,n=nums.size(),count=0;\\n        \\n        while(i+k-1<n) //For Every window of k from starting from any index i.\\n        {\\n            int mx=INT_MIN;\\n            int index=-1;\\n            for(int j=i;j<=i+k-1;j++) //For that window we will find maximimum element and its index.\\n            {\\n                if(nums[j]>=mx)\\n                    mx=nums[j],index=j;\\n            }\\n            if(mx>mid) //for that window if mx>mid, means it is not Possible to form boquest withim mid days.\\n                i=index+1; //So we increase our i to index+1.\\n            else\\n            {\\n                i=i+k; //i=i+k means ,this window is ok ,search for wIndOw after that window.\\n                count++; //Increase the Count\\n            }\\n        }\\n        \\n        return count>=m?1:0; //If count is greater than m means it is possible ans.\\n    }\\n    int minDays(vector<int>& nums, int m, int k) {\\n        int low=*min_element(nums.begin(),nums.end()); //Lowest days we require,\\n        int high=*max_element(nums.begin(),nums.end()); //Highest days we require\\n        \\n        int ans=-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            \\n            if(isPossible(nums,mid,k,m))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n*If you find it helpful. Please upvote.*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool isPossible(vector<int>&nums,int mid,int k,int m)\\n    {\\n        /*Its Little bit Sliding window type.\\n        But not same*/\\n        int i=0,n=nums.size(),count=0;\\n        \\n        while(i+k-1<n) //For Every window of k from starting from any index i.\\n        {\\n            int mx=INT_MIN;\\n            int index=-1;\\n            for(int j=i;j<=i+k-1;j++) //For that window we will find maximimum element and its index.\\n            {\\n                if(nums[j]>=mx)\\n                    mx=nums[j],index=j;\\n            }\\n            if(mx>mid) //for that window if mx>mid, means it is not Possible to form boquest withim mid days.\\n                i=index+1; //So we increase our i to index+1.\\n            else\\n            {\\n                i=i+k; //i=i+k means ,this window is ok ,search for wIndOw after that window.\\n                count++; //Increase the Count\\n            }\\n        }\\n        \\n        return count>=m?1:0; //If count is greater than m means it is possible ans.\\n    }\\n    int minDays(vector<int>& nums, int m, int k) {\\n        int low=*min_element(nums.begin(),nums.end()); //Lowest days we require,\\n        int high=*max_element(nums.begin(),nums.end()); //Highest days we require\\n        \\n        int ans=-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            \\n            if(isPossible(nums,mid,k,m))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859061,
                "title": "python-very-easy-brute-and-optimal-solutions",
                "content": "\\u274C **Solution 1:**  Sort the bloomDays and Linear Search each day and check whether it is possible or not. If it is possible then directly return it because is sorted, day will be minimum\\n\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):               # this function to check if a day is possible will be used in all the below solutions.\\n            flowers = bouquet = 0\\n            for d in bloomDay:\\n                if d > pluckDay: flowers = 0\\n                else:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquet += 1\\n                        flowers = 0\\n            return bouquet >= m\\n          \\n        arr = sorted(list(set(bloomDay)))\\n        \\n        for day in arr:\\n            if isPossible(day): return day\\n        return -1\\n```\\n***\\n```Time Complexity   : O(N*N)```\\n```Space Complexity: O(N) taking another list```\\n***\\n\\n\\u2714 **Solution: 2** (Binary Search between min and max Days)\\nWe know answer will lie beween this min max range. Why?\\nIts easy, we cant make a bouquet when no flower is bloomed(ie first day where atleast one flower is bloomed) or  why would be go after the maxDay when all flower is already bloomed, taking extra day is absurd.\\n\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):                 # pluckDay: the day when we pluck the flower\\n            flowers = bouquet = 0                 # flowers: to count number of flowers bloomed: bouquet: No of bouquets made\\n            for d in bloomDay:                    # traverse each bloomDay\\n                if d > pluckDay: flowers = 0      # if bloomDay > pluckDay, it means it means that flowers is not yet bloomed, so we cant pluck it on that day, reset it to zero as it break the adjacency streak\\n                else:                             # else the flower is bloomed\\n                    flowers += 1                  # increment the flower counter\\n                    if flowers == k:              # if we have k adjacents, then make a bouquet\\n                        bouquet += 1\\n                        flowers = 0               # also the streak is broken as the flower is already used\\n            return bouquet >= m                   # return whether we had surpass or match the bouqeut making thresold\\n            \\n        if len(bloomDay) < m * k: return -1       # if number of flower is less than required, we cannot make it, so return -1 in that case\\n        \\n        l, h = min(bloomDay), max(bloomDay)\\n        while l < h: \\n            day = (l + h) // 2 \\n            if isPossible(day): h = day           # if possible then we will check for lower days because we need to minimise. h = day bcoz we dont want lose what we got,\\n            else: l = day + 1\\n        return h\\n```\\n***\\n```Time Complexity: O(N*Log(max))```\\n```Space Complexity: O(1)```\\n***\\n\\n\\n\\u2714 **Solution 3:** Copy the list, Sort it and then do the binary search to pick and check days.\\n\\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):\\n            flowers = bouquet = 0\\n            for d in bloomDay:\\n                if d > pluckDay: flowers = 0\\n                else:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquet += 1\\n                        flowers = 0\\n            return bouquet >= m\\n            \\n        if len(bloomDay) < m * k: return -1    \\n        \\n        arr = sorted(list(set(bloomDay)))\\n        \\n        l = 0; h = len(arr) - 1\\n        while l < h: \\n            mid = (l + h) // 2\\n            day = arr[mid]\\n            if isPossible(day): h = mid\\n            else: l = mid + 1\\n        return arr[h]\\n```\\n***\\n```Time Complexity: O(N*Log(N))```\\n```Space Complexity: O(N) taking another list```\\n***\\n\\n***If you have any questions or you think above solutions can further be optimised, please do comment below.***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):               # this function to check if a day is possible will be used in all the below solutions.\\n            flowers = bouquet = 0\\n            for d in bloomDay:\\n                if d > pluckDay: flowers = 0\\n                else:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquet += 1\\n                        flowers = 0\\n            return bouquet >= m\\n          \\n        arr = sorted(list(set(bloomDay)))\\n        \\n        for day in arr:\\n            if isPossible(day): return day\\n        return -1\\n```\n```Time Complexity   : O(N*N)```\n```Space Complexity: O(N) taking another list```\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):                 # pluckDay: the day when we pluck the flower\\n            flowers = bouquet = 0                 # flowers: to count number of flowers bloomed: bouquet: No of bouquets made\\n            for d in bloomDay:                    # traverse each bloomDay\\n                if d > pluckDay: flowers = 0      # if bloomDay > pluckDay, it means it means that flowers is not yet bloomed, so we cant pluck it on that day, reset it to zero as it break the adjacency streak\\n                else:                             # else the flower is bloomed\\n                    flowers += 1                  # increment the flower counter\\n                    if flowers == k:              # if we have k adjacents, then make a bouquet\\n                        bouquet += 1\\n                        flowers = 0               # also the streak is broken as the flower is already used\\n            return bouquet >= m                   # return whether we had surpass or match the bouqeut making thresold\\n            \\n        if len(bloomDay) < m * k: return -1       # if number of flower is less than required, we cannot make it, so return -1 in that case\\n        \\n        l, h = min(bloomDay), max(bloomDay)\\n        while l < h: \\n            day = (l + h) // 2 \\n            if isPossible(day): h = day           # if possible then we will check for lower days because we need to minimise. h = day bcoz we dont want lose what we got,\\n            else: l = day + 1\\n        return h\\n```\n```Time Complexity: O(N*Log(max))```\n```Space Complexity: O(1)```\n```\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        \\n        def isPossible(pluckDay):\\n            flowers = bouquet = 0\\n            for d in bloomDay:\\n                if d > pluckDay: flowers = 0\\n                else:\\n                    flowers += 1\\n                    if flowers == k:\\n                        bouquet += 1\\n                        flowers = 0\\n            return bouquet >= m\\n            \\n        if len(bloomDay) < m * k: return -1    \\n        \\n        arr = sorted(list(set(bloomDay)))\\n        \\n        l = 0; h = len(arr) - 1\\n        while l < h: \\n            mid = (l + h) // 2\\n            day = arr[mid]\\n            if isPossible(day): h = mid\\n            else: l = mid + 1\\n        return arr[h]\\n```\n```Time Complexity: O(N*Log(N))```\n```Space Complexity: O(N) taking another list```",
                "codeTag": "Java"
            },
            {
                "id": 1842863,
                "title": "c-there-were-many-simillar-question-there-on-leetcode",
                "content": "//\\n\\n     there were many simailar question on leetcode .only the difference on the valid function...\\n\\t ## credit : Aditya Verma Sir....\\n\\n\\nclass Solution {\\npublic:\\n\\n\\n    bool isvalid(vector<int>bloomDay,int m,int k,int mid)\\n    {\\n        int count=0;\\n       for(int i=0;i<bloomDay.size();i++)\\n       {\\n            if(bloomDay[i]<=mid)count++;\\n        else if(bloomDay[i]>mid)count=0;\\n        if(count==k)\\n        {\\n            m--;\\n            count=0;\\n        }\\n        if(m==0)\\n            return true;\\n       }\\n        \\n        return false;\\n    }\\n    \\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        if(m*k>bloomDay.size())\\n            return -1;\\n        int i=1;\\n        int j=*max_element(bloomDay.begin(),bloomDay.end());\\n        int ans=-1;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(isvalid(bloomDay,m,k,mid))\\n            {\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else\\n                i=mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    bool isvalid(vector<int>bloomDay,int m,int k,int mid)\\n    {\\n        int count=0;\\n       for(int i=0;i<bloomDay.size();i++)\\n       {\\n            if(bloomDay[i]<=mid)count++;\\n        else if(bloomDay[i]>mid)count=0;\\n        if(count==k)\\n        {\\n            m--;\\n            count=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1820808,
                "title": "c-binary-search-readable-code-aditya-verma-template",
                "content": "\\tbool checkIfPossible(int mid, int m, int k, vector<int>& bloomDay){\\n\\t\\t\\tint windowsize=0;\\n\\t\\t\\tfor(int i =0; i<bloomDay.size();i++){\\n\\t\\t\\t\\tif(bloomDay[i]<=mid)windowsize++;\\n\\t\\t\\t\\telse if(bloomDay[i]>mid)windowsize=0;\\n\\t\\t\\t\\tif(windowsize==k){\\n\\t\\t\\t\\t\\tm--;\\n\\t\\t\\t\\t\\twindowsize=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(m==0){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint minDays(vector<int>& bloomDay, int m, int k) {\\n\\t\\t\\tif(m*k>bloomDay.size()) return -1;\\n\\t\\t\\tint high=bloomDay[0];\\n\\t\\t\\tfor(auto i: bloomDay) high=max(high,i);\\n\\t\\t\\tint result =high;\\n\\t\\t\\tint low=0;\\n\\t\\t\\twhile(low<=high){\\n\\t\\t\\t\\tint mid= low + (high-low)/2;\\n\\t\\t\\t\\tif(checkIfPossible(mid, m, k, bloomDay)){\\n\\t\\t\\t\\t\\tresult=mid;\\n\\t\\t\\t\\t\\thigh=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tlow=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "\\tbool checkIfPossible(int mid, int m, int k, vector<int>& bloomDay){\\n\\t\\t\\tint windowsize=0;\\n\\t\\t\\tfor(int i =0; i<bloomDay.size();i++){\\n\\t\\t\\t\\tif(bloomDay[i]<=mid)windowsize++;\\n\\t\\t\\t\\telse if(bloomDay[i]>mid)windowsize=0;\\n\\t\\t\\t\\tif(windowsize==k){\\n\\t\\t\\t\\t\\tm--;\\n\\t\\t\\t\\t\\twindowsize=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(m==0){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tint minDays(vector<int>& bloomDay, int m, int k) {\\n\\t\\t\\tif(m*k>bloomDay.size()) return -1;\\n\\t\\t\\tint high=bloomDay[0];\\n\\t\\t\\tfor(auto i: bloomDay) high=max(high,i);\\n\\t\\t\\tint result =high;\\n\\t\\t\\tint low=0;\\n\\t\\t\\twhile(low<=high){\\n\\t\\t\\t\\tint mid= low + (high-low)/2;\\n\\t\\t\\t\\tif(checkIfPossible(mid, m, k, bloomDay)){\\n\\t\\t\\t\\t\\tresult=mid;\\n\\t\\t\\t\\t\\thigh=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tlow=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1744942,
                "title": "java-92-faster-binary-search-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int len = bloomDay.length;\\n        \\n        int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE;\\n        for(int i=0;i<len;i++){\\n            min = Math.min(bloomDay[i],min);\\n            max = Math.max(bloomDay[i],max);\\n        }\\n        int s=min,e=max,ans=-1;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(isPossible(bloomDay,mid,m,k)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] arr,int days,int m,int k){\\n        int len = arr.length;\\n        int start=0,end=0;\\n        for(;end<len;end++){\\n            if(arr[end]>days){\\n                m-=(end-start)/k;\\n                start=end+1;\\n            }\\n        }\\n        m-=(end-start)/k;\\n        return m<=0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        int len = bloomDay.length;\\n        \\n        int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE;\\n        for(int i=0;i<len;i++){\\n            min = Math.min(bloomDay[i],min);\\n            max = Math.max(bloomDay[i],max);\\n        }\\n        int s=min,e=max,ans=-1;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(isPossible(bloomDay,mid,m,k)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[] arr,int days,int m,int k){\\n        int len = arr.length;\\n        int start=0,end=0;\\n        for(;end<len;end++){\\n            if(arr[end]>days){\\n                m-=(end-start)/k;\\n                start=end+1;\\n            }\\n        }\\n        m-=(end-start)/k;\\n        return m<=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716567,
                "title": "simple-java-soloution-o-logn",
                "content": "class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        \\n        int low=Integer.MAX_VALUE,high=-1,n=bloomDay.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n           int mid=low+(-low+high)/2;\\n           int i=0,j=0;\\n            int tmp=0;\\n            while(i<n)\\n            {\\n                if(bloomDay[i]<=mid)\\n                {\\n                    i++;\\n                }\\n                else\\n                {\\n                   tmp+=(i-j)/k;\\n                   i++;\\n                   j=i;\\n                }\\n            }\\n            tmp+=(i-j)/k;\\n           // System.out.println(mid+\" \"+tmp);\\n            if(tmp>=m)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minDays(int[] bloomDay, int m, int k) {\\n        \\n        int low=Integer.MAX_VALUE,high=-1,n=bloomDay.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            low=Math.min(low,bloomDay[i]);\\n            high=Math.max(high,bloomDay[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1708887,
                "title": "java-allocate-books-pattern-binary-search",
                "content": "```\\nclass Solution {\\n    \\n    \\n    public boolean isValid(int[] arr, int m, int k, int currDay){\\n        \\n        int numOfFlowers = 0;\\n        int numBouquets = 0;\\n\\n        \\n        for(int i=0; i<arr.length; i++){\\n            \\n            if(currDay >= arr[i]){\\n                numOfFlowers++;\\n            }\\n            else{\\n                numOfFlowers = 0;\\n            }\\n            \\n            if(numOfFlowers == k){\\n                numBouquets++;\\n                numOfFlowers = 0;\\n            }\\n            \\n            if(numBouquets >= m){\\n                return true;\\n            }\\n            \\n            \\n        }\\n        \\n\\n        return false;\\n        \\n    }\\n\\n    \\n    \\n    public int minDays(int[] bloomDay, int m, int k) {\\n        \\n        int n = bloomDay.length;\\n        \\n        int start = 0;\\n        // max ele from bloomDay\\n        int end = Arrays.stream(bloomDay).max().getAsInt();\\n        \\n        int result = -1;\\n        \\n        while(start<=end){\\n            \\n            int day = start + ((end-start)/2);\\n            \\n            if(isValid(bloomDay, m, k, day)== true){\\n                result = day;\\n                end = day-1;\\n            }\\n            else{\\n                start = day+1;\\n            }\\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public boolean isValid(int[] arr, int m, int k, int currDay){\\n        \\n        int numOfFlowers = 0;\\n        int numBouquets = 0;\\n\\n        \\n        for(int i=0; i<arr.length; i++){\\n            \\n            if(currDay >= arr[i]){\\n                numOfFlowers++;\\n            }\\n            else{\\n                numOfFlowers = 0;\\n            }\\n            \\n            if(numOfFlowers == k){\\n                numBouquets++;\\n                numOfFlowers = 0;\\n            }\\n            \\n            if(numBouquets >= m){\\n                return true;\\n            }\\n            \\n            \\n        }\\n        \\n\\n        return false;\\n        \\n    }\\n\\n    \\n    \\n    public int minDays(int[] bloomDay, int m, int k) {\\n        \\n        int n = bloomDay.length;\\n        \\n        int start = 0;\\n        // max ele from bloomDay\\n        int end = Arrays.stream(bloomDay).max().getAsInt();\\n        \\n        int result = -1;\\n        \\n        while(start<=end){\\n            \\n            int day = start + ((end-start)/2);\\n            \\n            if(isValid(bloomDay, m, k, day)== true){\\n                result = day;\\n                end = day-1;\\n            }\\n            else{\\n                start = day+1;\\n            }\\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657888,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n\\tbool isValid(vector<int>& A, int m, int k, int x) {\\n\\n\\t\\tint cnt = 0, size = 0;\\n\\t\\tfor (int i = 0; i < A.size(); i++) {\\n\\t\\t\\tsize = (A[i] <= x) ? size+1 : 0;\\n\\t\\t\\tif (size == k) size = 0, cnt++;\\n\\t\\t\\tif (cnt == m)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(n<k*m)\\n            return -1;\\n        int lo = *min_element(bloomDay.begin(),bloomDay.end());\\n        int hi = *max_element(bloomDay.begin(),bloomDay.end());\\n        int ans = -1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                hi = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool isValid(vector<int>& A, int m, int k, int x) {\\n\\n\\t\\tint cnt = 0, size = 0;\\n\\t\\tfor (int i = 0; i < A.size(); i++) {\\n\\t\\t\\tsize = (A[i] <= x) ? size+1 : 0;\\n\\t\\t\\tif (size == k) size = 0, cnt++;\\n\\t\\t\\tif (cnt == m)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n        if(n<k*m)\\n            return -1;\\n        int lo = *min_element(bloomDay.begin(),bloomDay.end());\\n        int hi = *max_element(bloomDay.begin(),bloomDay.end());\\n        int ans = -1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(isValid(bloomDay,m,k,mid)){\\n                hi = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657052,
                "title": "c-binary-search-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 0, e = *max_element(bloomDay.begin(), bloomDay.end());\\n        int ans = -1;\\n        int mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(isPossible(bloomDay, mid, m, k)){\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n            mid = s + (e-s)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& bDay, int mid, int m, int k){\\n        int adjacent = 0, count = 0;\\n        for(int i = 0; i < bDay.size(); i++){\\n            if(bDay[i] <= mid){\\n                adjacent++;\\n            }\\n            else{\\n                adjacent = 0;\\n            }\\n            if(adjacent==k){\\n                count++;\\n                adjacent = 0;\\n            }\\n        }\\n        if(count < m){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int s = 0, e = *max_element(bloomDay.begin(), bloomDay.end());\\n        int ans = -1;\\n        int mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(isPossible(bloomDay, mid, m, k)){\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n            mid = s + (e-s)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& bDay, int mid, int m, int k){\\n        int adjacent = 0, count = 0;\\n        for(int i = 0; i < bDay.size(); i++){\\n            if(bDay[i] <= mid){\\n                adjacent++;\\n            }\\n            else{\\n                adjacent = 0;\\n            }\\n            if(adjacent==k){\\n                count++;\\n                adjacent = 0;\\n            }\\n        }\\n        if(count < m){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636706,
                "title": "c-binary-search-with-intuition",
                "content": "We need to find the minimum time so that we can get m bouquets. \\nTwo cases:\\n1- Its not possible - just take the maximum element in the bloom array and check if we are able to get m bouquets or not. If not so return -1 \\n2- Its possible to find a solution\\nHere we need to find the minimum time so here its clear that we need to do a binary search so we will take the maximum time as the max element in the bloom array and the minimum element as 0. so the we need to see if the current mid gets us m bouquets or not if it does then we can decrease the time (range will be from l to mid) or we need to increase the time range [mid + 1,r] so when we come out of the while we will get the minimum time.\\n\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>&A,int k,int m,int t)\\n    {\\n        int n = A.size();\\n        int i = 0;\\n        int count = 0;\\n        while(i < n)\\n        {\\n            if(A[i] > t)\\n            {\\n                count = 0;\\n            }\\n            else\\n            {\\n                count++; \\n            }\\n            \\n            if(count == k)\\n            {\\n                m--;\\n                count = 0;\\n            }\\n            i++;\\n        }\\n        return (m <= 0);\\n    }\\n    int minDays(vector<int>&A, int m, int k) {\\n        int n = A.size();\\n        int l = 0;\\n        int r = *max_element(A.begin(), A.end());\\n        if(check(A,k,m,r) != 1)\\n            return -1;\\n        while(l < r)\\n        {\\n            int mid = (l + r) / 2;\\n            if(check(A,k,m,mid) != 1)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n                \\n        }\\n        return r;\\n        \\n        \\n    }\\n};\\n```\\nPlease comment if you think there is any error or please give  a upvote if you like the article",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&A,int k,int m,int t)\\n    {\\n        int n = A.size();\\n        int i = 0;\\n        int count = 0;\\n        while(i < n)\\n        {\\n            if(A[i] > t)\\n            {\\n                count = 0;\\n            }\\n            else\\n            {\\n                count++; \\n            }\\n            \\n            if(count == k)\\n            {\\n                m--;\\n                count = 0;\\n            }\\n            i++;\\n        }\\n        return (m <= 0);\\n    }\\n    int minDays(vector<int>&A, int m, int k) {\\n        int n = A.size();\\n        int l = 0;\\n        int r = *max_element(A.begin(), A.end());\\n        if(check(A,k,m,r) != 1)\\n            return -1;\\n        while(l < r)\\n        {\\n            int mid = (l + r) / 2;\\n            if(check(A,k,m,mid) != 1)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n                \\n        }\\n        return r;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477202,
                "title": "binary-search-o-n-log-n-c-solution-explained",
                "content": "```\\n\\n// count(vector<int>& bloomDay, int d, int k) returns the number of bouquet that can be made if we take \\'d\\' days as the min number of days.\\n// count(bloomDay, d, k) >= m, means that we can easily make \\'m\\' bouquets if we take \\'d\\' as our minimum number of days.\\n// so we store d in a variable \\'res\\' and continued our binary search to find an even better answer if it exits !\\n\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n\\t\\tif(m * k > n) return -1;\\n\\t\\t\\n        int l = INT_MAX, r = -1;\\n        for(int i=0; i<n; i++){\\n            l = min(l, bloomDay[i]);\\n            r = max(r, bloomDay[i]);\\n        }\\n        \\n        int res = r;\\n        while(l <= r){\\n            int d = l + (r - l)/2;\\n            if(count(bloomDay, d, k) >= m){\\n                res = d, r = d-1;\\n            }else{\\n                l = d+1;\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n\\t\\n\\tint count(vector<int>& bloomDay, int d, int k){\\n        int kcnt = 0, mcnt = 0;\\n        for(int i=0; i<bloomDay.size(); i++){\\n            if(d >= bloomDay[i]){\\n                kcnt++;\\n                if(kcnt == k){\\n                    mcnt++;\\n                    kcnt = 0;\\n                }\\n            }else{\\n                kcnt = 0;\\n            }\\n        }\\n        return mcnt;\\n    }\\t\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\n// count(vector<int>& bloomDay, int d, int k) returns the number of bouquet that can be made if we take \\'d\\' days as the min number of days.\\n// count(bloomDay, d, k) >= m, means that we can easily make \\'m\\' bouquets if we take \\'d\\' as our minimum number of days.\\n// so we store d in a variable \\'res\\' and continued our binary search to find an even better answer if it exits !\\n\\nclass Solution {\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int n = bloomDay.size();\\n\\t\\tif(m * k > n) return -1;\\n\\t\\t\\n        int l = INT_MAX, r = -1;\\n        for(int i=0; i<n; i++){\\n            l = min(l, bloomDay[i]);\\n            r = max(r, bloomDay[i]);\\n        }\\n        \\n        int res = r;\\n        while(l <= r){\\n            int d = l + (r - l)/2;\\n            if(count(bloomDay, d, k) >= m){\\n                res = d, r = d-1;\\n            }else{\\n                l = d+1;\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n\\t\\n\\tint count(vector<int>& bloomDay, int d, int k){\\n        int kcnt = 0, mcnt = 0;\\n        for(int i=0; i<bloomDay.size(); i++){\\n            if(d >= bloomDay[i]){\\n                kcnt++;\\n                if(kcnt == k){\\n                    mcnt++;\\n                    kcnt = 0;\\n                }\\n            }else{\\n                kcnt = 0;\\n            }\\n        }\\n        return mcnt;\\n    }\\t\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433661,
                "title": "c-binary-search",
                "content": "```\\n\\n```public:\\n    bool solve(vector<int>&nums,int m,int k,int mid)\\n    {\\n        int i,f=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                f++;\\n            }\\n            else\\n            {\\n                f=0;\\n            }\\n            if(f==k)\\n            {\\n                count++;\\n                f=0;\\n            }\\n        }\\n        if(count>=m)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    int minDays(vector<int>& nums, int m, int k) {\\n        int i,l=0,r,ans=-1;\\n        r=*max_element(nums.begin(),nums.end());\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(solve(nums,m,k,mid))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400675,
                "title": "c-binary-search-easy-solution-with-explanation-beats-90",
                "content": "This is one of the classic problems which uses the concept of applying binary search on our required answer. The least possible answer is 1 and and the max possible answer should be the maximum bloomDay[i] value because at that time all the flowers would have bloomed.\\n\\nThe only edge case here is that we need to have enough flowers to make m bouquets, otherwise it is always possible to make m bouquets given we wait enough number of days.\\n\\nNow we need to minimize these number of days, we apply the standard binary search procedure here and check if it is possible to make m bouquets in (mid) days now, if it is possible then the paradigm of binary search dictates that we must get a smaller answer, hence we decrease our search space to low-->mid-1 else if its not possible to make m bouquets with m number of days then we must go for a higher number of days hence our search spaces reduces to mid+1-->high.\\n\\nThe check function here is a simple function which checks if it is possible to make m bouquets with the given number of days. The logic is to basically find k continuous bloomed flowers and if found then increase the total count otherwise if the current flower is not bloomed, then we must start from the next flower onwards since the question says that we can pick only adjacent flowers.\\n\\n```\\nclass Solution {\\npublic:\\n    int len;\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n        len = bloomDay.size();\\n        if(len/k < m)\\n            return -1;\\n        int low=1,high=*max_element(bloomDay.begin(),bloomDay.end());\\n        int res = -1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(check(bloomDay,mid,m,k))\\n            {\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n        return res;\\n    }\\n    \\n    bool check(const vector<int>&bloomDay,int cdays,int m,int k)\\n    {\\n        int total_count = 0, current_count = 0;\\n        for(auto &x : bloomDay)\\n        {\\n            if(x<=cdays)\\n            {\\n                ++current_count;\\n                if(current_count==k)\\n                {\\n                    ++total_count;\\n                    current_count = 0;\\n                }\\n            }\\n            else\\n            {\\n                current_count = 0;\\n            }\\n        }\\n        return total_count >= m;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int len;\\n    int minDays(vector<int>& bloomDay, int m, int k) \\n    {\\n        len = bloomDay.size();\\n        if(len/k < m)\\n            return -1;\\n        int low=1,high=*max_element(bloomDay.begin(),bloomDay.end());\\n        int res = -1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(check(bloomDay,mid,m,k))\\n            {\\n                res = mid;\\n                high = mid-1;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564996,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1569991,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1566620,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1840885,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1838613,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1574615,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1805210,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1958295,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 2030542,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1845933,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1564996,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1569991,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1566620,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1840885,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1838613,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1574615,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1805210,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1958295,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 2030542,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            },
            {
                "id": 1845933,
                "content": [
                    {
                        "username": "random_str",
                        "content": "struggled for 1 hour to come up with a logic to solve this, but I couldn\\'t. Two months into the preparation and still struggling on questions like this is very discouraging."
                    },
                    {
                        "username": "nikalinov",
                        "content": "At 2 months you are still a beginner tho, don't be discouraged"
                    },
                    {
                        "username": "hemantrk",
                        "content": "Try thinking in this direction, at any given day what is the number of k - consecutive - bloomed flower. is it enough to make **m** bouquets."
                    },
                    {
                        "username": "aakarshmadhavan",
                        "content": "Hi,\\n\\nI used to struggle with these types of problems. There is a core concept here to realize.\\n\\n- You can always use binary search to find a MINIMUM or a MAXIMUM, this problem has the property that it wants you to find the minimum possible, and you have a defined maximum and minimum, we know number of days cannot be more than max and cannot be less than min, this exactly leads to binary search."
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. I always thought binary search was just for finding something but after doing more problems, it is also used for optimization. Very powerful technique"
                    },
                    {
                        "username": "NotInPasadena",
                        "content": "As soon as I saw the word \"binarySearch\", I was like \"crap, it\\'s just another divide chocolate kind of problem\". But I spent all my time trying to improve my top-down DP solution, got nowhere but TLE.\\nI am wondering how to develop the intuition to avoid the top-down DP trap in this kind of question? Of course when I hit TLE, I should consider another direction to solve the problem #I am so weak#"
                    },
                    {
                        "username": "Tenerickperez",
                        "content": "im having more trouble understanding the problem than actually solving it"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "[@sud_298](/sud_298)  https://youtu.be/TXAuxeYBTdg better watch this "
                    },
                    {
                        "username": "sud_298",
                        "content": "Exactly!!"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "If anyone is failing one test case in java then use \\n `if (((long)m * k) > n)\\n            return -1;\\n        `\\ninstead of  `if(m*k >n) return -1;`\\n\\nas the range for m is given 10^6 and for k it is 10^5 so when multiplied it causes integer overflow ."
                    },
                    {
                        "username": "anupk11",
                        "content": "Thanks! I was also failing in one testcase."
                    },
                    {
                        "username": "zhenya_vlasov",
                        "content": "1. Problem description hides 2 crucial points \\n\\t- we need to collect m bouquests on the SAME given day. Can\\'t collect m-x bouqets on some day, then collect more on another, till we reach m. \\nThis can be understood only from the examples. \\n\\t- once flower bloomed but we can\\'t collect m bouquets -> that flower stays in the garden in the \\'bloomed\\' status. \\n\\n3. Based on the most upvoted ans by lee215, bin search solution requires \\'leftmost\\' variation of the bin search algo (even though we don\\'t have duplicates in an array we are searching on). \\n"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Relax!! \\nfirst come up with the brute force solution then finding the solution with binary search will be easy. \\n\\nthink of a search space which contains all the elements from min(bloomDay) to the max(bloomDay)\\n\\ncheck if they are adjacent \\n\\nand keep shrinking the search space until you find the min no. of days required "
                    },
                    {
                        "username": "GUDIGUNTLAVYSHNAVI",
                        "content": "Thankyou for the hint"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Use  `if((long)m*k>n) return -1;` instead of  `if(m*k>n) return -1;`  to avoid integer overflow.\\nThank me later\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "its been 2 months ive started dsa like roughly 1-2 hrs a day , I solved this in 35 mins (brute force-> binary search). Is it good enough? what time is considered as good time for this qn?\n"
                    },
                    {
                        "username": "jat_sagar47",
                        "content": "10 minutes max "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate min and max days and then find the mid. Create a isValid function and pass the mid variable.\\nThen check at the mid was possible to make bouquets or not.\\nif it is not check other side.\\nfinally we got the answer."
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest Color Value in a Directed Graph",
        "question_content": "<p>There is a <strong>directed graph</strong> of <code>n</code> colored nodes and <code>m</code> edges. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>\r\n\r\n<p>You are given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the <strong>color</strong> of the <code>i<sup>th</sup></code> node in this graph (<strong>0-indexed</strong>). You are also given a 2D array <code>edges</code> where <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> indicates that there is a <strong>directed edge</strong> from node <code>a<sub>j</sub></code> to node <code>b<sub>j</sub></code>.</p>\r\n\r\n<p>A valid <strong>path</strong> in the graph is a sequence of nodes <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> such that there is a directed edge from <code>x<sub>i</sub></code> to <code>x<sub>i+1</sub></code> for every <code>1 &lt;= i &lt; k</code>. The <strong>color value</strong> of the path is the number of nodes that are colored the <strong>most frequently</strong> occurring color along that path.</p>\r\n\r\n<p>Return <em>the <strong>largest color value</strong> of any valid path in the given graph, or </em><code>-1</code><em> if the graph contains a cycle</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/21/leet1.png\" style=\"width: 400px; height: 182px;\" /></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]]\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong> The path 0 -&gt; 2 -&gt; 3 -&gt; 4 contains 3 nodes that are colored <code>&quot;a&quot; (red in the above image)</code>.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/21/leet2.png\" style=\"width: 85px; height: 85px;\" /></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> colors = &quot;a&quot;, edges = [[0,0]]\r\n<strong>Output:</strong> -1\r\n<strong>Explanation:</strong> There is a cycle from 0 to 0.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>n == colors.length</code></li>\r\n\t<li><code>m == edges.length</code></li>\r\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>colors</code> consists of lowercase English letters.</li>\r\n\t<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub>&nbsp;&lt; n</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 1198658,
                "title": "c-topological-sort",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Topological Sort\\n\\n**Intuition**: We can use BFS Topological Sort to visit the nodes. When visiting the next node, we can forward the color information to the next node. Also Topo-sort can help detect circle.\\n\\n**Algorithm**:\\n\\nJust do normal topo sort. One modification is that, for each node, we need to store a `int cnt[26]` array where `cnt[i]` is the **maximum** count of color `i` in **all** paths to the current node.\\n\\nFor example, assume there are two paths reaching the current node, `aba`, `bba`. Then `cnt[\\'a\\'] = 2` and `cnt[\\'b\\'] = 2` because both color `a` and `b` can be `2` in different paths.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-240/problems/largest-color-value-in-a-directed-graph/\\n// Author: github.com/lzl124631x\\n// Time: O(V + E)\\n// Space: O(V + E)\\nclass Solution {\\n    typedef array<int, 26> T;\\npublic:\\n    int largestPathValue(string C, vector<vector<int>>& E) {\\n        unordered_map<int, vector<int>> G;\\n        vector<int> indegree(C.size());\\n        for (auto &e : E) {\\n            G[e[0]].push_back(e[1]); // build graph\\n            indegree[e[1]]++; // count indegrees\\n        }\\n        vector<T> cnt(C.size(), T{}); // cnt[i][j] is the maximum count of j-th color from the ancester nodes to node i.\\n        queue<int> q;\\n        for (int i = 0; i < C.size(); ++i) {\\n            if (indegree[i] == 0) { // if this node has 0 indegree, we can use it as a source node\\n                q.push(i);\\n                cnt[i][C[i] - \\'a\\'] = 1; // the count of the current color should be 1\\n            }\\n        }\\n        int ans = 0, seen = 0;\\n        while (q.size()) {\\n            auto u = q.front();\\n            q.pop();\\n            int val = *max_element(begin(cnt[u]), end(cnt[u])); // we use the maximum of all the maximum color counts as the color value.\\n            ans = max(ans, val);\\n            ++seen;\\n            for (int v : G[u]) {\\n                for (int i = 0; i < 26; ++i) {\\n                    cnt[v][i] = max(cnt[v][i], cnt[u][i] + (i == C[v] - \\'a\\')); // try to use node `u` to update all the color counts of node `v`.\\n                }\\n                if (--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return seen < C.size() ? -1 : ans;\\n    }\\n};\\n```\\n\\nPS: \\nThanks @rookie_siramk:\\nThis line `int val = *max_element(begin(cnt[u]), end(cnt[u])); ` can be replaced with `int val = cnt[u][C[u] - \\'a\\'];` because there must be a path that has the greatest color value and ends with the corresponding color.",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-240/problems/largest-color-value-in-a-directed-graph/\\n// Author: github.com/lzl124631x\\n// Time: O(V + E)\\n// Space: O(V + E)\\nclass Solution {\\n    typedef array<int, 26> T;\\npublic:\\n    int largestPathValue(string C, vector<vector<int>>& E) {\\n        unordered_map<int, vector<int>> G;\\n        vector<int> indegree(C.size());\\n        for (auto &e : E) {\\n            G[e[0]].push_back(e[1]); // build graph\\n            indegree[e[1]]++; // count indegrees\\n        }\\n        vector<T> cnt(C.size(), T{}); // cnt[i][j] is the maximum count of j-th color from the ancester nodes to node i.\\n        queue<int> q;\\n        for (int i = 0; i < C.size(); ++i) {\\n            if (indegree[i] == 0) { // if this node has 0 indegree, we can use it as a source node\\n                q.push(i);\\n                cnt[i][C[i] - \\'a\\'] = 1; // the count of the current color should be 1\\n            }\\n        }\\n        int ans = 0, seen = 0;\\n        while (q.size()) {\\n            auto u = q.front();\\n            q.pop();\\n            int val = *max_element(begin(cnt[u]), end(cnt[u])); // we use the maximum of all the maximum color counts as the color value.\\n            ans = max(ans, val);\\n            ++seen;\\n            for (int v : G[u]) {\\n                for (int i = 0; i < 26; ++i) {\\n                    cnt[v][i] = max(cnt[v][i], cnt[u][i] + (i == C[v] - \\'a\\')); // try to use node `u` to update all the color counts of node `v`.\\n                }\\n                if (--indegree[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return seen < C.size() ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396205,
                "title": "image-explanation-simple-bfs-complete-intuition-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\r\\n`Largest Color Value in a Directed Graph` by `Aryan Mittal`\\r\\n![lc.png](https://assets.leetcode.com/users/images/59728e62-f2f6-435f-92b5-a1ac16b94fba_1681024940.783462.png)\\r\\n\\r\\n\\r\\n\\r\\n# Approach & Intution\\r\\n![image.png](https://assets.leetcode.com/users/images/d268d56f-4b44-4abe-a8a8-19d0b7a66ae1_1681019735.9802983.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/c1afa3db-e077-48ac-be20-f8d29598c2c9_1681019754.1476243.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/8bfdc4af-78b0-4a4a-badb-0a2dd1a9a202_1681019764.6686597.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/f9c40a62-73b8-47c2-b2e2-240a1e3d2aca_1681019772.3362288.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/5cd0833b-922d-4306-8d27-5e8058c9afdc_1681019779.9674668.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/95f96174-3e13-4dff-8871-91771f2f81ee_1681019787.7936614.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/828bda0d-e6ba-44c4-9f50-cd3c2ae04e1a_1681019795.5984516.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/1457a41d-e5cd-40f4-944e-9ab7cd83a03c_1681019804.440304.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/12dc6d06-ca92-4fb2-9cc0-e6c271cdfe0e_1681019817.8200758.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/7200d082-475c-49a4-ad9c-c7fa068b9ca2_1681019827.1658123.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/2085ca70-0ae0-49d4-80c5-0d53b213c90a_1681019841.2306588.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/e5724f8c-d781-4f5b-9187-8dc81be88d03_1681019848.7189512.png)\\r\\n![image.png](https://assets.leetcode.com/users/images/44bb9427-1609-4f4d-b1ba-fa0d98f8dbe0_1681019854.3651013.png)\\r\\n\\r\\n\\r\\n# Code\\r\\n```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        vector<int> indegrees(n, 0);\\r\\n        vector<vector<int>> graph(n, vector<int>());\\r\\n        for (vector<int>& edge : edges) {\\r\\n            graph[edge[0]].push_back(edge[1]);\\r\\n            indegrees[edge[1]]++;\\r\\n        }\\r\\n        queue<int> zero_indegree;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zero_indegree.push(i);\\r\\n            }\\r\\n        }\\r\\n        vector<vector<int>> counts(n, vector<int>(26, 0));\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i][colors[i] - \\'a\\']++;\\r\\n        }\\r\\n        int max_count = 0;\\r\\n        int visited = 0;\\r\\n        while (!zero_indegree.empty()) {\\r\\n            int u = zero_indegree.front();\\r\\n            zero_indegree.pop();\\r\\n            visited++;\\r\\n            for (int v : graph[u]) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (colors[v] - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zero_indegree.push(v);\\r\\n                }\\r\\n            }\\r\\n            max_count = max(max_count, *max_element(counts[u].begin(), counts[u].end()));\\r\\n        }\\r\\n        return visited == n ? max_count : -1;\\r\\n    }\\r\\n};\\r\\n```\\r\\n```Java []\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        int[] indegrees = new int[n];\\r\\n        List<List<Integer>> graph = new ArrayList<>();\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            graph.add(new ArrayList<Integer>());\\r\\n        }\\r\\n        for (int[] edge : edges) {\\r\\n            graph.get(edge[0]).add(edge[1]);\\r\\n            indegrees[edge[1]]++;\\r\\n        }\\r\\n        Queue<Integer> zeroIndegree = new LinkedList<>();\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zeroIndegree.offer(i);\\r\\n            }\\r\\n        }\\r\\n        int[][] counts = new int[n][26];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i][colors.charAt(i) - \\'a\\']++;\\r\\n        }\\r\\n        int maxCount = 0;\\r\\n        int visited = 0;\\r\\n        while (!zeroIndegree.isEmpty()) {\\r\\n            int u = zeroIndegree.poll();\\r\\n            visited++;\\r\\n            for (int v : graph.get(u)) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    counts[v][i] = Math.max(counts[v][i], counts[u][i] + (colors.charAt(v) - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zeroIndegree.offer(v);\\r\\n                }\\r\\n            }\\r\\n            maxCount = Math.max(maxCount, Arrays.stream(counts[u]).max().getAsInt());\\r\\n        }\\r\\n        return visited == n ? maxCount : -1;\\r\\n    }\\r\\n}\\r\\n```\\r\\n```Python []\\r\\nfrom typing import List\\r\\nfrom collections import deque\\r\\n\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        indegrees = [0] * n\\r\\n        graph = [[] for _ in range(n)]\\r\\n        for edge in edges:\\r\\n            graph[edge[0]].append(edge[1])\\r\\n            indegrees[edge[1]] += 1\\r\\n        zero_indegree = deque()\\r\\n        for i in range(n):\\r\\n            if indegrees[i] == 0:\\r\\n                zero_indegree.append(i)\\r\\n        counts = [[0]*26 for _ in range(n)]\\r\\n        for i in range(n):\\r\\n            counts[i][ord(colors[i]) - ord(\\'a\\')] += 1\\r\\n        max_count = 0\\r\\n        visited = 0\\r\\n        while zero_indegree:\\r\\n            u = zero_indegree.popleft()\\r\\n            visited += 1\\r\\n            for v in graph[u]:\\r\\n                for i in range(26):\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (ord(colors[v]) - ord(\\'a\\') == i))\\r\\n                indegrees[v] -= 1\\r\\n                if indegrees[v] == 0:\\r\\n                    zero_indegree.append(v)\\r\\n            max_count = max(max_count, max(counts[u]))\\r\\n        return max_count if visited == n else -1\\r\\n```\\r\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        vector<int> indegrees(n, 0);\\r\\n        vector<vector<int>> graph(n, vector<int>());\\r\\n        for (vector<int>& edge : edges) {\\r\\n            graph[edge[0]].push_back(edge[1]);\\r\\n            indegrees[edge[1]]++;\\r\\n        }\\r\\n        queue<int> zero_indegree;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zero_indegree.push(i);\\r\\n            }\\r\\n        }\\r\\n        vector<vector<int>> counts(n, vector<int>(26, 0));\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i][colors[i] - \\'a\\']++;\\r\\n        }\\r\\n        int max_count = 0;\\r\\n        int visited = 0;\\r\\n        while (!zero_indegree.empty()) {\\r\\n            int u = zero_indegree.front();\\r\\n            zero_indegree.pop();\\r\\n            visited++;\\r\\n            for (int v : graph[u]) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (colors[v] - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zero_indegree.push(v);\\r\\n                }\\r\\n            }\\r\\n            max_count = max(max_count, *max_element(counts[u].begin(), counts[u].end()));\\r\\n        }\\r\\n        return visited == n ? max_count : -1;\\r\\n    }\\r\\n};\\r\\n```\n```Java []\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        int[] indegrees = new int[n];\\r\\n        List<List<Integer>> graph = new ArrayList<>();\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            graph.add(new ArrayList<Integer>());\\r\\n        }\\r\\n        for (int[] edge : edges) {\\r\\n            graph.get(edge[0]).add(edge[1]);\\r\\n            indegrees[edge[1]]++;\\r\\n        }\\r\\n        Queue<Integer> zeroIndegree = new LinkedList<>();\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zeroIndegree.offer(i);\\r\\n            }\\r\\n        }\\r\\n        int[][] counts = new int[n][26];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i][colors.charAt(i) - \\'a\\']++;\\r\\n        }\\r\\n        int maxCount = 0;\\r\\n        int visited = 0;\\r\\n        while (!zeroIndegree.isEmpty()) {\\r\\n            int u = zeroIndegree.poll();\\r\\n            visited++;\\r\\n            for (int v : graph.get(u)) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    counts[v][i] = Math.max(counts[v][i], counts[u][i] + (colors.charAt(v) - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zeroIndegree.offer(v);\\r\\n                }\\r\\n            }\\r\\n            maxCount = Math.max(maxCount, Arrays.stream(counts[u]).max().getAsInt());\\r\\n        }\\r\\n        return visited == n ? maxCount : -1;\\r\\n    }\\r\\n}\\r\\n```\n```Python []\\r\\nfrom typing import List\\r\\nfrom collections import deque\\r\\n\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        indegrees = [0] * n\\r\\n        graph = [[] for _ in range(n)]\\r\\n        for edge in edges:\\r\\n            graph[edge[0]].append(edge[1])\\r\\n            indegrees[edge[1]] += 1\\r\\n        zero_indegree = deque()\\r\\n        for i in range(n):\\r\\n            if indegrees[i] == 0:\\r\\n                zero_indegree.append(i)\\r\\n        counts = [[0]*26 for _ in range(n)]\\r\\n        for i in range(n):\\r\\n            counts[i][ord(colors[i]) - ord(\\'a\\')] += 1\\r\\n        max_count = 0\\r\\n        visited = 0\\r\\n        while zero_indegree:\\r\\n            u = zero_indegree.popleft()\\r\\n            visited += 1\\r\\n            for v in graph[u]:\\r\\n                for i in range(26):\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (ord(colors[v]) - ord(\\'a\\') == i))\\r\\n                indegrees[v] -= 1\\r\\n                if indegrees[v] == 0:\\r\\n                    zero_indegree.append(v)\\r\\n            max_count = max(max_count, max(counts[u]))\\r\\n        return max_count if visited == n else -1\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200575,
                "title": "topological-sort-vs-dfs-vs-dijkstra",
                "content": "I tried to solve it first using DFS, but got TLE. Then I switched to Dijkstra, and, after a few optimizations, it got accepted. But solving it using Dijkstra was quite tricky due to many edge conditions.\\n\\n> Update: you can do DFS as shown by [manuagrawal2013](https://leetcode.com/manuagrawal2013/) below if you use memoisation. I\\'ll add DFS solution as well.\\n\\nAfter the fact, I looked at other solutions and realized that we just can process items in a topological order and track maximum counts for each color. This solution was so much easier to implemen. I\\'ll post my BFS solution below just for the reference and appreciation of how easier it is to solve this problem when you find the right approach.\\n\\n#### Topological Sort\\nTo process nodes in the topological order, we track the indegree - the number of incoming edges - for each node. We start with nodes with zero indegrees (sources), and then \"remove\" outgoing edges (in other words, reduce the indegree of connected nodes). After that, we pick a new set of nodes with zero indegree, and repeat the process.\\n\\nWe convert our edges to adjacency list, and count the indegree for each node. After that, nodes with zero indegrees are our sources. For each node, we track the count of each 26 character colors. \\n\\nWhen we process a node `i`:\\n- We increase the count for color `cs[i]`\\n- We process all adjacent nodes, and for each node `j`:\\n\\t\\t- Set count for each color to maximum value between `i` and `j`.\\n\\t\\t- Decrease the indegree (\"remove\" the edge)\\n\\t\\t- If the node indegree becomes zero, we add it as a source for the next round.\\n\\nNote that the above algorithm will never enter a cycle, as no nodes in the cycle will ever have zero indegree. Thus, we count nodes that we process, and make sure we processed all nodes (or else there is a cycle so we return `-1`).\\n\\n**C++ (520 ms)**\\n```cpp\\nint largestPathValue(string cs, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(cs.size()), cnt(cs.size(), vector<int>(26));\\n    vector<int> indegrees(cs.size());\\n    for (auto &e: edges) {\\n        al[e[0]].push_back(e[1]);\\n        ++indegrees[e[1]];\\n    }\\n    vector<int> q;\\n    for (int i = 0; i < cs.size(); ++i)\\n        if (indegrees[i] == 0)\\n            q.push_back(i);\\n    int res = 0, processed = 0;\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (auto i : q) {\\n            ++processed;\\n            res = max(res, ++cnt[i][cs[i] - \\'a\\']);\\n            for (auto j : al[i]) {\\n                for (auto k = 0; k < 26; ++k)\\n                    cnt[j][k] = max(cnt[j][k], cnt[i][k]);\\n                if (--indegrees[j] == 0)\\n                    q1.push_back(j);\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return processed != cs.size() ? -1 : res;\\n}\\n```\\n#### DFS\\nWe can use a simple DFS to reach leaf nodes, and then go back and track the maximum counts for each color. \\n\\n**C++ (496 ms)**\\n```cpp\\nint dfs(int i, string &c, vector<vector<int>> &al, vector<vector<int>> &cnt, vector<int> &visited) {\\n    if (!visited[i]) {\\n        visited[i] = 1;\\n        for (auto j : al[i]) {\\n            if (dfs(j, c, al, cnt, visited) == INT_MAX)\\n                return INT_MAX;\\n            for (auto k = 0; k < 26; ++k)\\n                cnt[i][k] = max(cnt[i][k], cnt[j][k]);\\n        }\\n        ++cnt[i][c[i] - \\'a\\'];\\n        visited[i] = 2;\\n    }\\n    return visited[i] == 2 ? cnt[i][c[i] - \\'a\\'] : INT_MAX;\\n}\\nint largestPathValue(string c, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(c.size()), cnt(c.size(), vector<int>(26));\\n    vector<int> visited(c.size());\\n    for (auto &e : edges)\\n        al[e[0]].push_back(e[1]);\\n    int res = 0;\\n    for (auto i = 0; i < c.size() && res != INT_MAX; ++i)\\n        res = max(res, dfs(i, c, al, cnt, visited));\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\\n#### Dijkstra\\nOK, the code below is quite long because of optimizations and handling edge cases. \\n\\n- We need a separate algorithm (gray-black BFS) to detect cycles.\\n- To make it faster, we analyze the graph independently for each of 26 colors. \\n- As an additional optimization, we start with the most frequent color and prute for rare colors.\\n\\nWe then run Dijkstra starting from the source nodes (like in the approach above). Basically, we run BFS tracking the count of the current color in each node.\\n\\n**C++ (820 ms)**\\n```cpp\\nbool dfs(vector<vector<int>> &al, vector<int> &gb, int i) {\\n    if (gb[i] == 0) {\\n        gb[i] = 1;\\n        for (auto j : al[i])\\n            if (!dfs(al, gb, j))\\n                return false;\\n        gb[i] = 2;\\n    }\\n    return gb[i] == 2;\\n}\\nint largestPathValue(string cs, vector<vector<int>>& edges) {\\n    int cnt[128] = {};\\n    for (auto ch : cs)\\n        ++cnt[ch];\\n    char st[26] = {};\\n    iota(begin(st), end(st), \\'a\\');\\n    sort(begin(st), end(st), [&](char a, char b){ return cnt[a] > cnt[b];});    \\n    vector<vector<int>> al(cs.size());\\n    vector<bool> target(cs.size());\\n    for (auto &e: edges) {\\n        al[e[0]].push_back(e[1]);\\n        target[e[1]] = true;\\n    }\\n    vector<pair<int, int>> q_src;\\n    for (int i = 0; i < cs.size(); ++i)\\n        if (!target[i])\\n            q_src.push_back({i, -1});\\n    int res = 0;\\n    vector<int> gb(cs.size());\\n    for (auto [i, tmp] : q_src)\\n        if (!dfs(al, gb, i))\\n            return -1;\\n    if (count(begin(gb), end(gb), 2) != cs.size())\\n        return -1;\\n    for (char ch : st) {\\n        if (res >= cnt[ch])\\n            continue;\\n        vector<int> cnt(cs.size(), -1);\\n        auto q = q_src;\\n        while (!q.empty()) {\\n            vector<pair<int, int>> q1;\\n            for (auto [i, from] : q) {\\n                int count = (from == -1 ? 0 : cnt[from]) + (cs[i] == ch);\\n                if (count < cnt[i])\\n                    continue;\\n                cnt[i] = count;\\n                res = max(res, cnt[i]);\\n                for (auto j : al[i]) {\\n                    if (cnt[j] < cnt[i] + (cs[j] == ch)) {\\n                        cnt[j] = cnt[i] + (cs[j] == ch);\\n                        q1.push_back({j, i});\\n                    }\\n                }\\n            }\\n            swap(q, q1);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint largestPathValue(string cs, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(cs.size()), cnt(cs.size(), vector<int>(26));\\n    vector<int> indegrees(cs.size());\\n    for (auto &e: edges) {\\n        al[e[0]].push_back(e[1]);\\n        ++indegrees[e[1]];\\n    }\\n    vector<int> q;\\n    for (int i = 0; i < cs.size(); ++i)\\n        if (indegrees[i] == 0)\\n            q.push_back(i);\\n    int res = 0, processed = 0;\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (auto i : q) {\\n            ++processed;\\n            res = max(res, ++cnt[i][cs[i] - \\'a\\']);\\n            for (auto j : al[i]) {\\n                for (auto k = 0; k < 26; ++k)\\n                    cnt[j][k] = max(cnt[j][k], cnt[i][k]);\\n                if (--indegrees[j] == 0)\\n                    q1.push_back(j);\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return processed != cs.size() ? -1 : res;\\n}\\n```\n```cpp\\nint dfs(int i, string &c, vector<vector<int>> &al, vector<vector<int>> &cnt, vector<int> &visited) {\\n    if (!visited[i]) {\\n        visited[i] = 1;\\n        for (auto j : al[i]) {\\n            if (dfs(j, c, al, cnt, visited) == INT_MAX)\\n                return INT_MAX;\\n            for (auto k = 0; k < 26; ++k)\\n                cnt[i][k] = max(cnt[i][k], cnt[j][k]);\\n        }\\n        ++cnt[i][c[i] - \\'a\\'];\\n        visited[i] = 2;\\n    }\\n    return visited[i] == 2 ? cnt[i][c[i] - \\'a\\'] : INT_MAX;\\n}\\nint largestPathValue(string c, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(c.size()), cnt(c.size(), vector<int>(26));\\n    vector<int> visited(c.size());\\n    for (auto &e : edges)\\n        al[e[0]].push_back(e[1]);\\n    int res = 0;\\n    for (auto i = 0; i < c.size() && res != INT_MAX; ++i)\\n        res = max(res, dfs(i, c, al, cnt, visited));\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\n```cpp\\nbool dfs(vector<vector<int>> &al, vector<int> &gb, int i) {\\n    if (gb[i] == 0) {\\n        gb[i] = 1;\\n        for (auto j : al[i])\\n            if (!dfs(al, gb, j))\\n                return false;\\n        gb[i] = 2;\\n    }\\n    return gb[i] == 2;\\n}\\nint largestPathValue(string cs, vector<vector<int>>& edges) {\\n    int cnt[128] = {};\\n    for (auto ch : cs)\\n        ++cnt[ch];\\n    char st[26] = {};\\n    iota(begin(st), end(st), \\'a\\');\\n    sort(begin(st), end(st), [&](char a, char b){ return cnt[a] > cnt[b];});    \\n    vector<vector<int>> al(cs.size());\\n    vector<bool> target(cs.size());\\n    for (auto &e: edges) {\\n        al[e[0]].push_back(e[1]);\\n        target[e[1]] = true;\\n    }\\n    vector<pair<int, int>> q_src;\\n    for (int i = 0; i < cs.size(); ++i)\\n        if (!target[i])\\n            q_src.push_back({i, -1});\\n    int res = 0;\\n    vector<int> gb(cs.size());\\n    for (auto [i, tmp] : q_src)\\n        if (!dfs(al, gb, i))\\n            return -1;\\n    if (count(begin(gb), end(gb), 2) != cs.size())\\n        return -1;\\n    for (char ch : st) {\\n        if (res >= cnt[ch])\\n            continue;\\n        vector<int> cnt(cs.size(), -1);\\n        auto q = q_src;\\n        while (!q.empty()) {\\n            vector<pair<int, int>> q1;\\n            for (auto [i, from] : q) {\\n                int count = (from == -1 ? 0 : cnt[from]) + (cs[i] == ch);\\n                if (count < cnt[i])\\n                    continue;\\n                cnt[i] = count;\\n                res = max(res, cnt[i]);\\n                for (auto j : al[i]) {\\n                    if (cnt[j] < cnt[i] + (cs[j] == ch)) {\\n                        cnt[j] = cnt[i] + (cs[j] == ch);\\n                        q1.push_back({j, i});\\n                    }\\n                }\\n            }\\n            swap(q, q1);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1204630,
                "title": "java-topological-sort-dp",
                "content": "**Intitution:**\\n* If there is cycle then we have to return -1. To detect cycle in directed graph Khans Algorithm is the way.\\n* colors contains only lowerCase English letters. So basically atmax 26 different color can be there.\\n* Make a storage kind of thing which will hold **Maximum** count of all 26 colour till myself. So that My neighbour will use that information . ( DP thing)\\n* now Code will clear all your doubts :).\\n\\n**CODE:**\\n```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        //1. Build the Graph and Indegree array\\n       ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n        int n=colors.length();\\n        char[] color=colors.toCharArray();\\n        \\n        for(int i=0;i<n;i++) graph.add(i,new ArrayList<>());\\n        int[] indegree=new int[n];\\n        for(int[] edge:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            indegree[v]++;\\n            graph.get(u).add(v);\\n        }\\n        \\n\\t\\t//2. color count map. map[i][j] is the maximum count of j-th color from the ancester nodes to node i\\n        int[][] map=new int[n][26]; \\n        \\n\\t\\t//3.Khans Algorithm ( Iterative Topological Sort)\\n        Queue<Integer> que=new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                que.add(i);\\n                map[i][color[i]-\\'a\\']=1;\\n            }\\n        }\\n        \\n        int res=0;\\n        int seen=0;\\n        \\n        while(que.size()>0){\\n            int node=que.remove();\\n            seen++;\\n            \\n            int max=getMax(map[node]);\\n            res=Math.max(res,max);\\n            \\n            for(int nbr:graph.get(node)){\\n                // update the map of next node\\n                for(int i=0;i<26;i++){\\n                    map[nbr][i]=Math.max(map[nbr][i],map[node][i] + (color[nbr]-\\'a\\'==i?1:0));\\n                }\\n                indegree[nbr]--;\\n                \\n                if(indegree[nbr]==0){\\n                    que.add(nbr);\\n                }\\n            }\\n        }\\n        //if seen!=n means cycle is there\\n        return seen==n?res:-1;\\n    }\\n    \\n    private int getMax(int[] num){\\n        int max=num[0];\\n        for(int n:num){\\n            max=Math.max(n,max);\\n        }\\n        return max;\\n    }\\n   \\n}\\n```\\n\\n**Complexity:**\\n`Time:O(V+E) and Space:O(N*N)`\\n\\nPlease **UPVOTE** if found it helpful :)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        //1. Build the Graph and Indegree array\\n       ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n        int n=colors.length();\\n        char[] color=colors.toCharArray();\\n        \\n        for(int i=0;i<n;i++) graph.add(i,new ArrayList<>());\\n        int[] indegree=new int[n];\\n        for(int[] edge:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            indegree[v]++;\\n            graph.get(u).add(v);\\n        }\\n        \\n\\t\\t//2. color count map. map[i][j] is the maximum count of j-th color from the ancester nodes to node i\\n        int[][] map=new int[n][26]; \\n        \\n\\t\\t//3.Khans Algorithm ( Iterative Topological Sort)\\n        Queue<Integer> que=new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                que.add(i);\\n                map[i][color[i]-\\'a\\']=1;\\n            }\\n        }\\n        \\n        int res=0;\\n        int seen=0;\\n        \\n        while(que.size()>0){\\n            int node=que.remove();\\n            seen++;\\n            \\n            int max=getMax(map[node]);\\n            res=Math.max(res,max);\\n            \\n            for(int nbr:graph.get(node)){\\n                // update the map of next node\\n                for(int i=0;i<26;i++){\\n                    map[nbr][i]=Math.max(map[nbr][i],map[node][i] + (color[nbr]-\\'a\\'==i?1:0));\\n                }\\n                indegree[nbr]--;\\n                \\n                if(indegree[nbr]==0){\\n                    que.add(nbr);\\n                }\\n            }\\n        }\\n        //if seen!=n means cycle is there\\n        return seen==n?res:-1;\\n    }\\n    \\n    private int getMax(int[] num){\\n        int max=num[0];\\n        for(int n:num){\\n            max=Math.max(n,max);\\n        }\\n        return max;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198908,
                "title": "python-shortest-code-and-fast",
                "content": "**Idea**\\n\\n1. The main idea is if there is a path with max. frequency of the color, then we can take any path containing it without changing the frequency of the max. color. Thus, we only need to count the colors  along the longest possible paths.\\n2. The composition of the colors along each of the paths does not matter. We only need to count max. frequency of each of the colors along all the paths that lead to the terminal node.  \\n\\n**Algorithm**\\n\\nFor each node (starting from the nodes that do not have incoming edges), calculate how frequent each of the colors is along all possible paths that lead to that node. Update max. for the outgoing nodes.  We can process each node as soon as we process all the incoming nodes/edges for the node.\\n\\n\\n**Variables**\\n\\n*Graph* contains graph coding - the list of outgoing edges for each node.\\n*incoming* contains the number of unprocessed incoming edges for the node. The number is changing as we process edges. If an incoming edge is processed, then we decrement *incoming* counter for the node.\\n*stack* contains the current list of nodes to process. For all the nodels in *stack*, we have already processed all the incoming edges.\\n*cnts* - the count of the frequency of all the colors for the paths that lead to the node. We increment the color of the node itself when we pop the node from the queue.\\n\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        \\n        N = len(colors)                                     # Number of nodes\\n        incoming, Graph = [0]*N, [[] for _ in range(N)]     # Define count for incoming edges, graph\\n        for _, v in edges: incoming[v]+=1                   # Count incoming edges\\n        for u, v in edges: Graph[u].append(v)               # Code the graph\\n        stack = [u for u in range(N) if incoming[u]==0]     # Populate stack with the nodes without incoming edges\\n        cnts = [[0]*26 for _ in range(N)]                   # Max. colors along all the incoming paths for the node \\n\\n        while stack:                                        # While we have nodes to process\\n            u = stack.pop()                                 # Pop the next node to process\\n            cnts[u][ord(colors[u])-ord(\\'a\\')] += 1           # Increment the color of the node itself\\n            for v in Graph[u]:                              # For all outgoing edges of the node\\n                cnts[v] = list(map(max, cnts[v], cnts[u]))  # Update max. colors of the outgoing node\\n                incoming[v] -= 1                            # Decrement the counter of edges for the outgoing node\\n                if incoming[v]==0: stack.append(v)          # If outgoing node has no more incoming edges, add to the stack\\n\\n        return -1 if sum(incoming)>0 else max([max(node) for node in cnts])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        \\n        N = len(colors)                                     # Number of nodes\\n        incoming, Graph = [0]*N, [[] for _ in range(N)]     # Define count for incoming edges, graph\\n        for _, v in edges: incoming[v]+=1                   # Count incoming edges\\n        for u, v in edges: Graph[u].append(v)               # Code the graph\\n        stack = [u for u in range(N) if incoming[u]==0]     # Populate stack with the nodes without incoming edges\\n        cnts = [[0]*26 for _ in range(N)]                   # Max. colors along all the incoming paths for the node \\n\\n        while stack:                                        # While we have nodes to process\\n            u = stack.pop()                                 # Pop the next node to process\\n            cnts[u][ord(colors[u])-ord(\\'a\\')] += 1           # Increment the color of the node itself\\n            for v in Graph[u]:                              # For all outgoing edges of the node\\n                cnts[v] = list(map(max, cnts[v], cnts[u]))  # Update max. colors of the outgoing node\\n                incoming[v] -= 1                            # Decrement the counter of edges for the outgoing node\\n                if incoming[v]==0: stack.append(v)          # If outgoing node has no more incoming edges, add to the stack\\n\\n        return -1 if sum(incoming)>0 else max([max(node) for node in cnts])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395923,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\nThe problem asks us to find the longest path in the directed graph such that the path contains all the colors from the string in the same order as they appear in the string. We can use dynamic programming and topological sorting to solve this problem.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nWe can create a directed graph using the edges given in the input. We can use a list of lists to represent the adjacency list of the graph. We can also maintain an array of arrays to keep track of the count of each color in the path that ends at each vertex. We can use another array to keep track of the in-degree of each vertex in the graph. We can use a queue to perform the topological sort of the graph. We can start by adding all the vertices with zero in-degree to the queue. We can then remove a vertex from the queue, update the count of each color in the path that ends at that vertex, and update the in-degree of all its neighbors. If the in-degree of a neighbor becomes zero after updating, we can add it to the queue. We can repeat this process until the queue becomes empty.\\r\\n\\r\\nWe can also maintain a variable to keep track of the maximum count of a color in the path. We can update this variable whenever we update the count of a color in the path that ends at a vertex.\\r\\n\\r\\nAt the end of the process, we can check if we have processed all the vertices in the graph. If not, we can return -1 as it means there is a cycle in the graph. If we have processed all the vertices, we can return the maximum count of a color in the path.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nTime complexity: O(V+E), where V is the number of vertices in the graph, and E is the number of edges in the graph. We need to process each vertex and edge at most once.\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(V*26), where V is the number of vertices in the graph. We need to maintain an array of size 26 for each vertex to keep track of the count of each color in the path that ends at that vertex. We also need to maintain an adjacency list for the graph, which requires O(E) space.\\r\\n\\r\\n\\r\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\r\\n\\r\\n\\r\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\r\\n```\\r\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\r\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\r\\nIt\\'s a simple way to show your appreciation and\\r\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\r\\n```\\r\\n# Code\\r\\n```java []\\r\\nclass Solution {\\r\\npublic int largestPathValue(String colors, int[][] edges) {\\r\\n    List<List<Integer>> al = new ArrayList<>();\\r\\n    List<int[]> cnt = new ArrayList<>();\\r\\n    int n = colors.length();\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        al.add(new ArrayList<>());\\r\\n        cnt.add(new int[26]);\\r\\n    }\\r\\n    int[] indegrees = new int[n];\\r\\n    for (int[] e : edges) {\\r\\n        al.get(e[0]).add(e[1]);\\r\\n        indegrees[e[1]]++;\\r\\n    }\\r\\n    List<Integer> q = new ArrayList<>();\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        if (indegrees[i] == 0)\\r\\n            q.add(i);\\r\\n    }\\r\\n    int res = 0, processed = 0;\\r\\n    while (!q.isEmpty()) {\\r\\n        List<Integer> q1 = new ArrayList<>();\\r\\n        for (int i : q) {\\r\\n            processed++;\\r\\n            res = Math.max(res, ++cnt.get(i)[colors.charAt(i) - \\'a\\']);\\r\\n            for (int j : al.get(i)) {\\r\\n                for (int k = 0; k < 26; k++)\\r\\n                    cnt.get(j)[k] = Math.max(cnt.get(j)[k], cnt.get(i)[k]);\\r\\n                if (--indegrees[j] == 0)\\r\\n                    q1.add(j);\\r\\n            }\\r\\n        }\\r\\n        q = q1;\\r\\n    }\\r\\n    return processed != n ? -1 : res;\\r\\n}\\r\\n\\r\\n}\\r\\n```\\r\\n```c++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n  int largestPathValue(string cs, vector<vector<int>>& edges) {\\r\\n    vector<vector<int>> al(cs.size()), cnt(cs.size(), vector<int>(26));\\r\\n    vector<int> indegrees(cs.size());\\r\\n    for (auto &e: edges) {\\r\\n        al[e[0]].push_back(e[1]);\\r\\n        ++indegrees[e[1]];\\r\\n    }\\r\\n    vector<int> q;\\r\\n    for (int i = 0; i < cs.size(); ++i)\\r\\n        if (indegrees[i] == 0)\\r\\n            q.push_back(i);\\r\\n    int res = 0, processed = 0;\\r\\n    while (!q.empty()) {\\r\\n        vector<int> q1;\\r\\n        for (auto i : q) {\\r\\n            ++processed;\\r\\n            res = max(res, ++cnt[i][cs[i] - \\'a\\']);\\r\\n            for (auto j : al[i]) {\\r\\n                for (auto k = 0; k < 26; ++k)\\r\\n                    cnt[j][k] = max(cnt[j][k], cnt[i][k]);\\r\\n                if (--indegrees[j] == 0)\\r\\n                    q1.push_back(j);\\r\\n            }\\r\\n        }\\r\\n        swap(q, q1);\\r\\n    }\\r\\n    return processed != cs.size() ? -1 : res;\\r\\n}\\r\\n};\\r\\n```\\r\\n```python []\\r\\nclass Solution(object):\\r\\n    def largestPathValue(self, colors, edges):\\r\\n        n = len(colors)\\r\\n        al = [[] for _ in range(n)]\\r\\n        cnt = [[0] * 26 for _ in range(n)]\\r\\n        indegrees = [0] * n\\r\\n        \\r\\n        for e in edges:\\r\\n            al[e[0]].append(e[1])\\r\\n            indegrees[e[1]] += 1\\r\\n            \\r\\n        q = []\\r\\n        for i in range(n):\\r\\n            if indegrees[i] == 0:\\r\\n                q.append(i)\\r\\n        \\r\\n        res, processed = 0, 0\\r\\n        while q:\\r\\n            q1 = []\\r\\n            for i in q:\\r\\n                processed += 1\\r\\n                res = max(res, cnt[i][ord(colors[i]) - ord(\\'a\\')] + 1)\\r\\n                cnt[i][ord(colors[i]) - ord(\\'a\\')] += 1\\r\\n                for j in al[i]:\\r\\n                    for k in range(26):\\r\\n                        cnt[j][k] = max(cnt[j][k], cnt[i][k])\\r\\n                    indegrees[j] -= 1\\r\\n                    if indegrees[j] == 0:\\r\\n                        q1.append(j)\\r\\n            q = q1\\r\\n        \\r\\n        return res if processed == n else -1\\r\\n\\r\\n```\\r\\n\\r\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\r\\n```\\r\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\r\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\r\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\r\\nIt\\'s a simple way to show your appreciation and\\r\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\r\\n```\n```java []\\r\\nclass Solution {\\r\\npublic int largestPathValue(String colors, int[][] edges) {\\r\\n    List<List<Integer>> al = new ArrayList<>();\\r\\n    List<int[]> cnt = new ArrayList<>();\\r\\n    int n = colors.length();\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        al.add(new ArrayList<>());\\r\\n        cnt.add(new int[26]);\\r\\n    }\\r\\n    int[] indegrees = new int[n];\\r\\n    for (int[] e : edges) {\\r\\n        al.get(e[0]).add(e[1]);\\r\\n        indegrees[e[1]]++;\\r\\n    }\\r\\n    List<Integer> q = new ArrayList<>();\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        if (indegrees[i] == 0)\\r\\n            q.add(i);\\r\\n    }\\r\\n    int res = 0, processed = 0;\\r\\n    while (!q.isEmpty()) {\\r\\n        List<Integer> q1 = new ArrayList<>();\\r\\n        for (int i : q) {\\r\\n            processed++;\\r\\n            res = Math.max(res, ++cnt.get(i)[colors.charAt(i) - \\'a\\']);\\r\\n            for (int j : al.get(i)) {\\r\\n                for (int k = 0; k < 26; k++)\\r\\n                    cnt.get(j)[k] = Math.max(cnt.get(j)[k], cnt.get(i)[k]);\\r\\n                if (--indegrees[j] == 0)\\r\\n                    q1.add(j);\\r\\n            }\\r\\n        }\\r\\n        q = q1;\\r\\n    }\\r\\n    return processed != n ? -1 : res;\\r\\n}\\r\\n\\r\\n}\\r\\n```\n```c++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n  int largestPathValue(string cs, vector<vector<int>>& edges) {\\r\\n    vector<vector<int>> al(cs.size()), cnt(cs.size(), vector<int>(26));\\r\\n    vector<int> indegrees(cs.size());\\r\\n    for (auto &e: edges) {\\r\\n        al[e[0]].push_back(e[1]);\\r\\n        ++indegrees[e[1]];\\r\\n    }\\r\\n    vector<int> q;\\r\\n    for (int i = 0; i < cs.size(); ++i)\\r\\n        if (indegrees[i] == 0)\\r\\n            q.push_back(i);\\r\\n    int res = 0, processed = 0;\\r\\n    while (!q.empty()) {\\r\\n        vector<int> q1;\\r\\n        for (auto i : q) {\\r\\n            ++processed;\\r\\n            res = max(res, ++cnt[i][cs[i] - \\'a\\']);\\r\\n            for (auto j : al[i]) {\\r\\n                for (auto k = 0; k < 26; ++k)\\r\\n                    cnt[j][k] = max(cnt[j][k], cnt[i][k]);\\r\\n                if (--indegrees[j] == 0)\\r\\n                    q1.push_back(j);\\r\\n            }\\r\\n        }\\r\\n        swap(q, q1);\\r\\n    }\\r\\n    return processed != cs.size() ? -1 : res;\\r\\n}\\r\\n};\\r\\n```\n```python []\\r\\nclass Solution(object):\\r\\n    def largestPathValue(self, colors, edges):\\r\\n        n = len(colors)\\r\\n        al = [[] for _ in range(n)]\\r\\n        cnt = [[0] * 26 for _ in range(n)]\\r\\n        indegrees = [0] * n\\r\\n        \\r\\n        for e in edges:\\r\\n            al[e[0]].append(e[1])\\r\\n            indegrees[e[1]] += 1\\r\\n            \\r\\n        q = []\\r\\n        for i in range(n):\\r\\n            if indegrees[i] == 0:\\r\\n                q.append(i)\\r\\n        \\r\\n        res, processed = 0, 0\\r\\n        while q:\\r\\n            q1 = []\\r\\n            for i in q:\\r\\n                processed += 1\\r\\n                res = max(res, cnt[i][ord(colors[i]) - ord(\\'a\\')] + 1)\\r\\n                cnt[i][ord(colors[i]) - ord(\\'a\\')] += 1\\r\\n                for j in al[i]:\\r\\n                    for k in range(26):\\r\\n                        cnt[j][k] = max(cnt[j][k], cnt[i][k])\\r\\n                    indegrees[j] -= 1\\r\\n                    if indegrees[j] == 0:\\r\\n                        q1.append(j)\\r\\n            q = q1\\r\\n        \\r\\n        return res if processed == n else -1\\r\\n\\r\\n```\n```\\r\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198837,
                "title": "c-faster-than-100-solution-algo-used-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        set<int> vis;\\n        int n=colors.length();\\n        vector<int> adj[n];\\n        int indegree[n];\\n        memset(indegree, 0, sizeof(indegree));\\n        for(int i=0;i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(indegree[i]==0) q.push(i);\\n        }\\n        int visited[n];\\n        memset(visited, 0, sizeof(visited));\\n        int dp[n][26];\\n        memset(dp, 0,sizeof(dp));\\n        int ans = 0;\\n        while(!q.empty()){\\n            int ind = q.front();\\n            q.pop();\\n            dp[ind][colors[ind]-\\'a\\']++;\\n            visited[ind]++;\\n            for(int i=0; i<26; i++){\\n                ans = max(ans, dp[ind][i]);\\n            }\\n            for(auto i:adj[ind]){\\n                indegree[i]--;\\n                if(indegree[i]==0){\\n                    q.push(i);\\n                }else if(indegree[i]<0){\\n                    return -1;\\n                }\\n                for(int j=0; j<26;j++){\\n                    dp[i][j] = max(dp[i][j], dp[ind][j]);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n;i++){\\n            if(!visited[i]) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        set<int> vis;\\n        int n=colors.length();\\n        vector<int> adj[n];\\n        int indegree[n];\\n        memset(indegree, 0, sizeof(indegree));\\n        for(int i=0;i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(indegree[i]==0) q.push(i);\\n        }\\n        int visited[n];\\n        memset(visited, 0, sizeof(visited));\\n        int dp[n][26];\\n        memset(dp, 0,sizeof(dp));\\n        int ans = 0;\\n        while(!q.empty()){\\n            int ind = q.front();\\n            q.pop();\\n            dp[ind][colors[ind]-\\'a\\']++;\\n            visited[ind]++;\\n            for(int i=0; i<26; i++){\\n                ans = max(ans, dp[ind][i]);\\n            }\\n            for(auto i:adj[ind]){\\n                indegree[i]--;\\n                if(indegree[i]==0){\\n                    q.push(i);\\n                }else if(indegree[i]<0){\\n                    return -1;\\n                }\\n                for(int j=0; j<26;j++){\\n                    dp[i][j] = max(dp[i][j], dp[ind][j]);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n;i++){\\n            if(!visited[i]) return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395597,
                "title": "java-easy-solution-explained-similiar-questions-linked",
                "content": "# Intuition\\r\\nWe can use BFS Topological Sort to visit the all the nodes. Topological sort takes care if there is a cycle in the graph. Only addition in standard TP and this question is that when visiting the next node, we need to forward the color information to the next node.\\r\\n\\r\\nCode is heavily commented and once you read the approach it will make algorithm easy to understand.\\r\\n\\r\\n***Similar questions to solve that will give confidence for Topological sort.***\\r\\nLC 207 [Course Schedule](https://leetcode.com/problems/course-schedule/description/)\\r\\nLC 210 [Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)\\r\\n\\r\\n----\\r\\n\\r\\n# Approach\\r\\n1) Initialise adjacency list, visited counter, indegree[legnth], colorsDP[i][26](which stores max colors for a node i)\\r\\n2) Maintain indegree of each node i (which is all incoming nodes at i)\\r\\n3) Push all nodes which have indegree 0 into the queue\\r\\n4) For each node(parent/source) in queue\\r\\nIncrease visited by 1\\r\\nFor all its neighbours (child/destination)of parent(source)\\r\\n-  decrease child\\'s indegree by 1\\r\\n- if indegree == 0 add to queue, they are ready to become source now\\r\\n- maintain max for each color(range 0-26) i.e we are copying parent\\'s color to them, but since we need to maintain max color so *colorsDP[child][i] = Math.max(colorsDP[child][i] , colorsDP[parent][i])*\\r\\n5) If there is a cyle in graph toplogical sort won\\'t let visited count reach the total node count\\r\\n6) Find the max-count from the colorsDP and that is the ans.\\r\\n\\r\\n-----\\r\\nHope it is easy to understand.\\r\\nLet me know if there is something unclear and i can fix it.\\r\\n\\r\\nOtherwise, please upvote if you like the solution, it would be encouraging\\r\\n\\r\\n-----\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        \\r\\n        List<List<Integer>> adjList = new ArrayList<>() ;\\r\\n        int length = colors.length() ;\\r\\n        int inDegree[] = new int[length] ;\\r\\n        int colorsDP[][] = new int[length][26] ;\\r\\n        int visited = 0 ;\\r\\n        \\r\\n        for(int i=0 ; i<length ; i++){\\r\\n            adjList.add(new ArrayList<>());\\r\\n        }\\r\\n        \\r\\n        for(int i=0 ; i<edges.length ; i++){\\r\\n            int start = edges[i][0] ;\\r\\n            int end = edges[i][1] ;\\r\\n            adjList.get(start).add(end) ;\\r\\n            inDegree[end]++ ;\\r\\n        }\\r\\n        \\r\\n        // In DAG there will atleast one node whose indegree will be 0,\\r\\n        // and such a nodes or nodes will our starting point\\r\\n        Queue<Integer> queue = new LinkedList<>() ;\\r\\n        for(int i=0 ; i<inDegree.length ; i++){\\r\\n            if(inDegree[i] == 0){\\r\\n                queue.add(i);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        while(!queue.isEmpty()){\\r\\n            int parent = queue.poll() ;\\r\\n            int parentColor = colors.charAt(parent) - \\'a\\' ;\\r\\n            //incrementing the parent\\'s color in colorsDP\\r\\n            colorsDP[parent][parentColor] = colorsDP[parent][parentColor]+1 ;\\r\\n            \\r\\n            //for all neighbours of the parent or current node we are processing\\r\\n            for(Integer child : adjList.get(parent)){\\r\\n                //reduce the indegree of that child\\r\\n                inDegree[child]-- ;\\r\\n                //indegree if zero than that child/node can behave as source now\\r\\n                if(inDegree[child] == 0){\\r\\n                    queue.add(child);\\r\\n                }\\r\\n\\r\\n                // Copying all the parent color into child but keeping the max color of child\\r\\n                // Hence we can find MAX COLOR till this child.\\r\\n                // Or we can say that we our keeping track of all colors till that particular child node/destination node where source is the parent here\\r\\n                for(int i=0 ; i<26 ; i++){\\r\\n                    colorsDP[child][i] = Math.max(colorsDP[child][i] , colorsDP[parent][i]); \\r\\n                }\\r\\n            }\\r\\n\\r\\n            visited++ ; //this counter is done to maintain \\r\\n        }\\r\\n        \\r\\n        //If we couldn\\'t visit all the nodes than there is a cycle\\r\\n        if(visited != length)\\r\\n            return -1 ;\\r\\n        \\r\\n        \\r\\n        int maxColor = 0 ;\\r\\n        \\r\\n        for(int i=0 ; i<colorsDP.length ; i++){\\r\\n            for(int j=0 ; j<26 ; j++){\\r\\n                maxColor = Math.max(maxColor , colorsDP[i][j]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return maxColor ;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        \\r\\n        List<List<Integer>> adjList = new ArrayList<>() ;\\r\\n        int length = colors.length() ;\\r\\n        int inDegree[] = new int[length] ;\\r\\n        int colorsDP[][] = new int[length][26] ;\\r\\n        int visited = 0 ;\\r\\n        \\r\\n        for(int i=0 ; i<length ; i++){\\r\\n            adjList.add(new ArrayList<>());\\r\\n        }\\r\\n        \\r\\n        for(int i=0 ; i<edges.length ; i++){\\r\\n            int start = edges[i][0] ;\\r\\n            int end = edges[i][1] ;\\r\\n            adjList.get(start).add(end) ;\\r\\n            inDegree[end]++ ;\\r\\n        }\\r\\n        \\r\\n        // In DAG there will atleast one node whose indegree will be 0,\\r\\n        // and such a nodes or nodes will our starting point\\r\\n        Queue<Integer> queue = new LinkedList<>() ;\\r\\n        for(int i=0 ; i<inDegree.length ; i++){\\r\\n            if(inDegree[i] == 0){\\r\\n                queue.add(i);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        while(!queue.isEmpty()){\\r\\n            int parent = queue.poll() ;\\r\\n            int parentColor = colors.charAt(parent) - \\'a\\' ;\\r\\n            //incrementing the parent\\'s color in colorsDP\\r\\n            colorsDP[parent][parentColor] = colorsDP[parent][parentColor]+1 ;\\r\\n            \\r\\n            //for all neighbours of the parent or current node we are processing\\r\\n            for(Integer child : adjList.get(parent)){\\r\\n                //reduce the indegree of that child\\r\\n                inDegree[child]-- ;\\r\\n                //indegree if zero than that child/node can behave as source now\\r\\n                if(inDegree[child] == 0){\\r\\n                    queue.add(child);\\r\\n                }\\r\\n\\r\\n                // Copying all the parent color into child but keeping the max color of child\\r\\n                // Hence we can find MAX COLOR till this child.\\r\\n                // Or we can say that we our keeping track of all colors till that particular child node/destination node where source is the parent here\\r\\n                for(int i=0 ; i<26 ; i++){\\r\\n                    colorsDP[child][i] = Math.max(colorsDP[child][i] , colorsDP[parent][i]); \\r\\n                }\\r\\n            }\\r\\n\\r\\n            visited++ ; //this counter is done to maintain \\r\\n        }\\r\\n        \\r\\n        //If we couldn\\'t visit all the nodes than there is a cycle\\r\\n        if(visited != length)\\r\\n            return -1 ;\\r\\n        \\r\\n        \\r\\n        int maxColor = 0 ;\\r\\n        \\r\\n        for(int i=0 ; i<colorsDP.length ; i++){\\r\\n            for(int j=0 ; j<26 ; j++){\\r\\n                maxColor = Math.max(maxColor , colorsDP[i][j]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return maxColor ;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198730,
                "title": "python-3-bfs-with-picture-explanation",
                "content": "Imagine there is one edge from ```node[i]``` to ```node[j]```, and there are some path of max length **till** ```node[i]```.\\nIf we traverse from ```node[i]``` to ```node[j]```, among all the pathes till ```node[i]```, only the number of character ```node[j]``` is added by 1.\\n\\n\\n#### Pass to the next node.\\nTake the picture below as an example.\\n![image](https://assets.leetcode.com/users/images/8478317e-6d8e-4f3c-b214-4a07303b6d80_1620535399.1520753.png)\\nSuppose there are some pathes till blue node, and among these pathes, we have up to ```2 \"a\", 3 \"b\"``` and ```1 \"c\"```, we can save the numbers in dictionary like ```{\"a\": 2, \"b\": 3, \"c\": 1}```\\nFrom blue node to green node, because the character of green node is \"a\", so only the number of \"a\" is added by 1. We can easily get the values for green node by passing the dictionary of blue node and add value of \"a\" by 1.\\n\\n#### Node with multiple precursors\\nWe only need to save the maximum number among all precursors. \\nTake the picture below as an example\\n![image](https://assets.leetcode.com/users/images/960be0b7-6da3-4cc5-8488-4e8ed46c7264_1620535748.6396437.png)\\n\\nThe node1 (ch1) has 2 \"b\", while the node2 has 3 \"b\", so we just save 3 \"b\" to the dictionary for green node.\\n\\n#### If there exists circle or not.\\nPlease refer to **210. Course Schedule II**  https://leetcode.com/problems/course-schedule-ii/\\nKey is that in BFS, we only push node in the queue when **it has no unvisited precursors**. Each time we visit a node, we substract the number of precusors of its successors by 1. If any successor has 0 unvisited precursors, we can push it into queue.\\n\\nAt the end, we can easily judge if there is a cycle by calculating the number of visited node. If ```len(visited) == n```, there is no circle.\\n\\n\\n\\n```\\ndef largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n, dq, seen = len(colors), collections.deque(), set()\\n        nxt = [set() for _ in range(n)]\\n        pre = [0 for _ in range(n)]\\n        dicts = [{x : 1} for x in colors]\\n        \\n        for i, j in edges:\\n            if i == j:\\n                return -1\\n            nxt[i].add(j)\\n            pre[j] += 1\\n            \\n        for i in range(n):\\n            if not pre[i]:\\n                dq.append(i)\\n                seen.add(i)\\n                \\n        while dq:\\n            cur = dq.popleft()\\n            for cand in nxt[cur]:\\n                tmp = {colors[cand] : 1}\\n                for i, x in dicts[cur].items():\\n                    if i not in tmp:\\n                        tmp[i] = x\\n                    else:\\n                        tmp[i] += x\\n                for i, x in tmp.items():\\n                    if i not in dicts[cand]:\\n                        dicts[cand][i] = x\\n                    else:\\n                        dicts[cand][i] = max(dicts[cand][i], x)\\n                pre[cand] -= 1\\n                if not pre[cand] and cand not in seen:\\n                    seen.add(cand)\\n                    dq.append(cand)\\n                    \\n        if len(seen) != n:\\n            return -1\\n        \\n        return max(max(i.values()) for i in dicts)\\n```",
                "solutionTags": [],
                "code": "```node[i]```\n```node[j]```\n```node[i]```\n```node[i]```\n```node[j]```\n```node[i]```\n```node[j]```\n```2 \"a\", 3 \"b\"```\n```1 \"c\"```\n```{\"a\": 2, \"b\": 3, \"c\": 1}```\n```len(visited) == n```\n```\\ndef largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n, dq, seen = len(colors), collections.deque(), set()\\n        nxt = [set() for _ in range(n)]\\n        pre = [0 for _ in range(n)]\\n        dicts = [{x : 1} for x in colors]\\n        \\n        for i, j in edges:\\n            if i == j:\\n                return -1\\n            nxt[i].add(j)\\n            pre[j] += 1\\n            \\n        for i in range(n):\\n            if not pre[i]:\\n                dq.append(i)\\n                seen.add(i)\\n                \\n        while dq:\\n            cur = dq.popleft()\\n            for cand in nxt[cur]:\\n                tmp = {colors[cand] : 1}\\n                for i, x in dicts[cur].items():\\n                    if i not in tmp:\\n                        tmp[i] = x\\n                    else:\\n                        tmp[i] += x\\n                for i, x in tmp.items():\\n                    if i not in dicts[cand]:\\n                        dicts[cand][i] = x\\n                    else:\\n                        dicts[cand][i] = max(dicts[cand][i], x)\\n                pre[cand] -= 1\\n                if not pre[cand] and cand not in seen:\\n                    seen.add(cand)\\n                    dq.append(cand)\\n                    \\n        if len(seen) != n:\\n            return -1\\n        \\n        return max(max(i.values()) for i in dicts)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1258312,
                "title": "c-solution-using-topological-sort",
                "content": "Upvote if helpful :)\\n\\n```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.length();\\n        unordered_map<int,vector<int>> graph;\\n        vector<int> indegree(n,0);\\n        \\n        for(auto e:edges){\\n            graph[e[0]].push_back(e[1]);\\n            indegree[e[1]]++;\\n        }\\n        \\n        vector<vector<int>> charcount(n,vector<int>(26,0));\\n        \\n        queue<int> q;\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        \\n        int visited=0,ans=0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            visited++;\\n            \\n            ans = max(ans,++charcount[curr][colors[curr]-\\'a\\']);\\n            \\n            for(auto v:graph[curr]){\\n                indegree[v]--;\\n                if(indegree[v]==0)\\n                    q.push(v);\\n                for(int i=0;i<26;i++){\\n                    charcount[v][i] = max(charcount[curr][i],charcount[v][i]);\\n                }\\n            }\\n        }\\n        \\n        if(visited!=n)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.length();\\n        unordered_map<int,vector<int>> graph;\\n        vector<int> indegree(n,0);\\n        \\n        for(auto e:edges){\\n            graph[e[0]].push_back(e[1]);\\n            indegree[e[1]]++;\\n        }\\n        \\n        vector<vector<int>> charcount(n,vector<int>(26,0));\\n        \\n        queue<int> q;\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        \\n        int visited=0,ans=0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            visited++;\\n            \\n            ans = max(ans,++charcount[curr][colors[curr]-\\'a\\']);\\n            \\n            for(auto v:graph[curr]){\\n                indegree[v]--;\\n                if(indegree[v]==0)\\n                    q.push(v);\\n                for(int i=0;i<26;i++){\\n                    charcount[v][i] = max(charcount[curr][i],charcount[v][i]);\\n                }\\n            }\\n        }\\n        \\n        if(visited!=n)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198765,
                "title": "java-simple-dfs-memo",
                "content": "Use DFS to traverse through the graph and while traversing, at each node memoize the maximum color values for all the paths originating from that node. \\n\\n```\\nclass Solution {\\n    private int max;\\n    private Map<Integer, Map<Character, Integer>> memo;\\n    private boolean hasCycle;\\n    \\n    public int largestPathValue(String colors, int[][] edges) {        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int edge[] : edges) {\\n            List<Integer> list = map.getOrDefault(edge[0], new ArrayList<>());\\n            list.add(edge[1]);\\n            map.put(edge[0], list);\\n        }\\n        \\n        max = -1;\\n        memo = new HashMap<>();\\n        \\n        boolean visited[] = new boolean[colors.length()];\\n        hasCycle = false;\\n        \\n        for(int i = 0; i < colors.length(); i++) {\\n            dfs(i, map, colors, visited);\\n            \\n            if(hasCycle) {\\n                return -1;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private Map<Character, Integer> dfs(int curr, Map<Integer, List<Integer>> map, String colors, boolean visited[]) {\\n        if(visited[curr]) {\\n            hasCycle = true;\\n            return new HashMap<>();\\n        }\\n        \\n        if(memo.get(curr) != null) {\\n            return memo.get(curr);\\n        }\\n        \\n        visited[curr] = true;\\n        List<Integer> list = map.get(curr);\\n        Map<Character, Integer> currMap = new HashMap<>();\\n                \\n        if(list != null && !list.isEmpty()) {\\n            for(int i : list) {\\n                Map<Character, Integer> resMap = dfs(i, map, colors, visited);\\n                \\n                if(hasCycle) {\\n                    return currMap;\\n                }\\n                \\n                for(char c : resMap.keySet()) {\\n                    int val = resMap.get(c);\\n                    int currVal = currMap.getOrDefault(c, 0);\\n                    currVal = Math.max(currVal, val);\\n                    currMap.put(c, currVal);\\n                    max = Math.max(currVal, max);\\n                }\\n            }\\n        }\\n        \\n        int currentNodeColorCount = currMap.getOrDefault(colors.charAt(curr), 0);\\n        currMap.put(colors.charAt(curr), currentNodeColorCount + 1);\\n        \\n        max = Math.max(currentNodeColorCount + 1, max);\\n        \\n        visited[curr] = false;\\n        memo.put(curr, currMap);\\n        return currMap;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n    private int max;\\n    private Map<Integer, Map<Character, Integer>> memo;\\n    private boolean hasCycle;\\n    \\n    public int largestPathValue(String colors, int[][] edges) {        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int edge[] : edges) {\\n            List<Integer> list = map.getOrDefault(edge[0], new ArrayList<>());\\n            list.add(edge[1]);\\n            map.put(edge[0], list);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1198648,
                "title": "python-easy-dp-solution-with-explanation",
                "content": "Let `dp[i][j]` be the maximum frequency of jth letter till we have reached ith node.\\nThe value of i is from 0 to n-1 and j is from 0 to 25.(a to z)\\nWhen we visit ith node, we should consider all the paths that lead to the ith node for calculating maximum frequency.\\n\\nWe maintain a list `degree`, which denotes the indegree of the current node.\\nInitially we push all the nodes which have degree = 0 in the queue.\\nLet count represent the number of nodes that have been popped.\\n\\nWe do the following till queue is empty or till count becomes n:\\n1. Pop node from queue. Increment the count.\\n2. Increment `dp[node][color[node]]` by 1.\\n3. Iterate through all the neighbours of currnode.\\n\\t\\ta. Iterate through all the characters.\\n\\t\\tb. Update `dp[neighbour][char] = max(dp[neighbour][char], dp[node][char])`\\n4. Decrease degree of the neighbour by 1. If the degree of the neighbour becomes 0, push it in the queue. \\n5. After count becomes n and if the queue is not empty, that means there is a cycle in the graph. Return -1 in this case.\\n6. Else return max from dp.\\n\\n```\\ndef largestPathValue(self, color: str, edges: List[List[int]]) -> int:\\n        n = len(color)\\n        graph = [[] for node in range(n)]\\n        deg = [0 for i in range(n)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            deg[v] += 1\\n        q = []\\n        dp = [[0 for j in range(26)]for i in range(n)]\\n        for i in range(n):\\n            if deg[i] == 0:\\n                q.append(i)\\n        count = 0\\n        ans = -1\\n        while q != []:\\n            currnode = q.pop(0)\\n            count += 1\\n            dp[currnode][ord(color[currnode])-ord(\\'a\\')] += 1\\n            ans = max(ans, dp[currnode][ord(color[currnode])-ord(\\'a\\')])\\n            for neigh in graph[currnode]:\\n                for i in range(26):\\n                    dp[neigh][i] = max(dp[neigh][i], dp[currnode][i])\\n                deg[neigh] -= 1\\n                if deg[neigh] == 0:\\n                    q.append(neigh)\\n            if count == n:\\n                break\\n        \\n        if q != [] or count < n:\\n            return -1\\n        return ans\\n            \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef largestPathValue(self, color: str, edges: List[List[int]]) -> int:\\n        n = len(color)\\n        graph = [[] for node in range(n)]\\n        deg = [0 for i in range(n)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            deg[v] += 1\\n        q = []\\n        dp = [[0 for j in range(26)]for i in range(n)]\\n        for i in range(n):\\n            if deg[i] == 0:\\n                q.append(i)\\n        count = 0\\n        ans = -1\\n        while q != []:\\n            currnode = q.pop(0)\\n            count += 1\\n            dp[currnode][ord(color[currnode])-ord(\\'a\\')] += 1\\n            ans = max(ans, dp[currnode][ord(color[currnode])-ord(\\'a\\')])\\n            for neigh in graph[currnode]:\\n                for i in range(26):\\n                    dp[neigh][i] = max(dp[neigh][i], dp[currnode][i])\\n                deg[neigh] -= 1\\n                if deg[neigh] == 0:\\n                    q.append(neigh)\\n            if count == n:\\n                break\\n        \\n        if q != [] or count < n:\\n            return -1\\n        return ans\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1199138,
                "title": "python-faster-than-100-topological-sort-memo-recent-beginner",
                "content": "I am a beginner as I started using LeetCode 2 months ago. I was very happy with myself that I got this right that I wanted to share my solution. This is my first post. I would love feedback. \\n\\nThis was a fun problem that I was able to finish shortly after the contest! I made many over simplifications until I got the right answer. Sharing how I developed my intuition to solve this.\\n\\n1. How to test for a cycle?\\n\\tI was checking whether I had visited this node earlier or not. This worked for the self-loop example but failed for one of the other test cases. You need two variables `visited` and `recursion`. `visited` helps you end the DFS early but doesn\\'t guarantee whether there is a cycle or not. `recursion` is a variable we set when start DFS from that node. If going down the path, we reach back our node, we know we have a cycle. We unset `recursion` when we are done with DFS from that node.\\n\\n2. Can simple DFS give me the maximum path?\\n\\tI next assumed that DFS would give me the max path from which I can detect the max frequency. This again worked for example test cases but it leaves it to chance - actually the way we have constructed the edges, depending on which vertex get\\'s picked from `adj[u]` we may or may not be on the maximal path. Thus it\\'s best to run through all the paths.\\n\\t\\n3. Why topological sort?\\n\\tGenerating all possible paths is an over-kill. We need memoization (dynamic programming) but we cannot use the vertex order. Example we start from N-1 vertex to 0 but realize that the directed graph has a directed edge N-1 to 0 which means the value of vertex N-1 depends on vertex 0. Topological sort solves this. It gives us an order that we can be sure is resolved of all dependencies. \\n\\n4. Why do we take the maximum of the colours adjacent to our nodes?\\n\\tInitially I tried to look at the adjacent vertexs and take pick the colour frequency `array[26]` for the one of the paths with the highest frequency. I soon realized that there can be a path that doesn\\'t look like a winner from this vertex but as we go up the root it might be the winner. We can\\'t see what colours come before this vertext. Therefore, we don\\'t want to lose any information. We combine all options by taking the max of each colour from this node. \\n\\t\\nThis problem combined multiple ideas and helped me internalize these concepts - directed graph, cycle detection, topological sort, memoization.\\n\\nHope it\\'s helpful.\\n\\nThanks\\n\\n```\\nclass Graph:\\n    \\n    def __init__(self, colors):\\n        self.V = len(colors)\\n        self.adj = [[] for _ in range(self.V)]\\n        self.reset()\\n        \\n    def reset(self):\\n        self.visited = [False] * self.V\\n        self.recursion = [False] * self.V\\n        self.stack = []\\n        \\n    def addEdges(self, edges: List[List[int]]):\\n        for u,v in edges:\\n            self.addEdge(u, v)\\n        \\n    def addEdge(self, u, v):\\n        self.adj[u].append(v)        \\n        \\n    def DFS(self, u):\\n        if self.recursion[u]:\\n            raise ValueError(\"Cycled Detected\")\\n\\n        if self.visited[u]:\\n            return\\n\\n        self.visited[u] = True\\n        self.recursion[u] = True\\n\\n        for v in self.adj[u]:\\n            self.DFS(v)\\n            \\n        self.stack.append(u)\\n            \\n        self.recursion[u] = False\\n    \\n    def getTopologicalSortOrder(self):        \\n        self.reset()\\n        \\n        for u in range(self.V):\\n            self.DFS(u)\\n        \\n        return self.stack[::-1]\\n    \\n    def isConnected(self, u, v):\\n        return self.adj[u].index(v) >= 0\\n    \\n    def getAdjs(self, u):\\n        return self.adj[u]\\n        \\n        \\n\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n                             \\n        g = Graph(colors)\\n        g.addEdges(edges)\\n        \\n        try:\\n            order = g.getTopologicalSortOrder()\\n\\n            result, dp = 0, [[0]*26 for _ in range(len(order)+1)]\\n            for i in range(len(order)-1, -1, -1):            \\n                u = order[i]\\n                # we are storing the max colours possible for all paths from this node      \\n                for v in g.getAdjs(u):\\n                    for k in range(26):\\n                        dp[u][k] = max(dp[u][k], dp[v][k])\\n\\n                c = ord(colors[u])-97\\n                dp[u][c] += 1\\n\\n                result = max(result, max(dp[u]))\\n\\n            return result        \\n        except:\\n            return -1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\nclass Graph:\\n    \\n    def __init__(self, colors):\\n        self.V = len(colors)\\n        self.adj = [[] for _ in range(self.V)]\\n        self.reset()\\n        \\n    def reset(self):\\n        self.visited = [False] * self.V\\n        self.recursion = [False] * self.V\\n        self.stack = []\\n        \\n    def addEdges(self, edges: List[List[int]]):\\n        for u,v in edges:\\n            self.addEdge(u, v)\\n        \\n    def addEdge(self, u, v):\\n        self.adj[u].append(v)        \\n        \\n    def DFS(self, u):\\n        if self.recursion[u]:\\n            raise ValueError(\"Cycled Detected\")\\n\\n        if self.visited[u]:\\n            return\\n\\n        self.visited[u] = True\\n        self.recursion[u] = True\\n\\n        for v in self.adj[u]:\\n            self.DFS(v)\\n            \\n        self.stack.append(u)\\n            \\n        self.recursion[u] = False\\n    \\n    def getTopologicalSortOrder(self):        \\n        self.reset()\\n        \\n        for u in range(self.V):\\n            self.DFS(u)\\n        \\n        return self.stack[::-1]\\n    \\n    def isConnected(self, u, v):\\n        return self.adj[u].index(v) >= 0\\n    \\n    def getAdjs(self, u):\\n        return self.adj[u]\\n        \\n        \\n\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n                             \\n        g = Graph(colors)\\n        g.addEdges(edges)\\n        \\n        try:\\n            order = g.getTopologicalSortOrder()\\n\\n            result, dp = 0, [[0]*26 for _ in range(len(order)+1)]\\n            for i in range(len(order)-1, -1, -1):            \\n                u = order[i]\\n                # we are storing the max colours possible for all paths from this node      \\n                for v in g.getAdjs(u):\\n                    for k in range(26):\\n                        dp[u][k] = max(dp[u][k], dp[v][k])\\n\\n                c = ord(colors[u])-97\\n                dp[u][c] += 1\\n\\n                result = max(result, max(dp[u]))\\n\\n            return result        \\n        except:\\n            return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395634,
                "title": "from-dumb-to-pro-with-just-one-visit-my-promise-to-you",
                "content": "## Complexity\\r\\n- Time complexity:\\r\\n$O(n * 26)$ -> To calculate largest color value using BFS\\r\\n$O(n)$ -> To detect cycle using DFS\\r\\n**Overall Time Complexity** = $O(n*26) + O(n) \\\\approx O(n)$\\r\\n\\r\\n- Space complexity:\\r\\n$O(n * 26)$ -> To store the largest color value at each node\\r\\n$O(3 * n)$ -> To detect cycle using DFS\\r\\n**Overall Time Complexity** = $O(n*26) + O(3 * n) \\\\approx O(n)$\\r\\n\\r\\n## First Approach\\r\\nFirst thing we all can identify that if there is a cycle then we have to return -1.\\r\\nAnd the second thing if we visit a node(current node) from a parent node then we have to copy all the color value from parent node and increase the current node\\'s colour value by 1.\\r\\n\\r\\nAnd in every step we update the maxcolor variable according to maximum color value.\\r\\n\\r\\nAt last return the maxcolor.\\r\\n\\r\\n# code\\r\\n```\\r\\nclass Solution {\\r\\n    bool detectCycle(int s, vector<vector<int>>& adj, vector<int>& vis, vector<int>& pathVis)\\r\\n    {\\r\\n        if(!vis[s]) {\\r\\n            vis[s] = 1;\\r\\n            pathVis[s] = 1;\\r\\n\\r\\n            for(int x : adj[s]) {\\r\\n                if(detectCycle(x, adj, vis, pathVis)) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n            pathVis[s] = 0;\\r\\n        } else if(pathVis[s]) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges)\\r\\n    {\\r\\n        int maxcolor = -1;\\r\\n        vector<vector<int>> adj(colors.size());\\r\\n\\r\\n        for(auto x : edges) {\\r\\n            adj[x[0]].push_back(x[1]);\\r\\n        }\\r\\n\\r\\n        vector<int> vis(adj.size());\\r\\n        vector<int> pathVis(adj.size());\\r\\n        if(detectCycle(0, adj, vis, pathVis)) {\\r\\n            return -1;\\r\\n        }\\r\\n        vector<vector<int>> dp(adj.size(), vector<int>(26, 0));\\r\\n\\r\\n        for(int i = 0; i < adj.size(); i++) {\\r\\n\\r\\n            //When we visit a node we increase its color value by 1;\\r\\n            dp[i][colors[i] - 97] += 1;\\r\\n\\r\\n            /*we increase the color value in this stage only so we\\r\\n            may get the maxcolor value only in this stage*/\\r\\n            maxcolor = max(maxcolor, dp[i][colors[i] - 97]);\\r\\n            for(int x : adj[i]) {\\r\\n                for(int col = 0; col < 26; col++) {\\r\\n                    if(dp[x][col] < dp[i][col]) {\\r\\n                        dp[x][col] = dp[i][col]; \\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return maxcolor;\\r\\n    }\\r\\n};\\r\\n```\\r\\n## Above code will fail for the following test case\\r\\n\"bbbhb\"\\r\\n[[0,2],[3,0],[1,3],[4,1]]\\r\\n\\r\\nFor the above test case we vist from 0 to 2 then we visit 1 to 3 and then 3 to 0. To get max value we have to again vist node 2 to 0.\\r\\nFor very long test cases if we visit again a visited node then we will get **TLE**.\\r\\nTo avoid it we have to visit the graph(adjacency list) in topological order.\\r\\nThe topological order of the above test case is:\\r\\n    1->3->0->2\\r\\n\\r\\n## Modifiaction of First Approach\\r\\nwe have to sort the graph node in topological order.\\r\\nTo do the above we store the node(which we visit first) in a vector(at last).\\r\\nHere we perform the above task inside dectcycle function(visiting the graph node using DFS). \\r\\n\\r\\n# Final Code\\r\\n```\\r\\nclass Solution {\\r\\n    vector<int> topo;\\r\\n    bool detectCycle(int s, vector<vector<int>>& adj, vector<int>& vis, vector<int>& pathVis)\\r\\n    {\\r\\n        if(!vis[s]) {\\r\\n            vis[s] = 1;\\r\\n            pathVis[s] = 1;\\r\\n\\r\\n            for(int x : adj[s]) {\\r\\n                if(detectCycle(x, adj, vis, pathVis)) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n            topo.push_back(s);\\r\\n            pathVis[s] = 0;\\r\\n        } else if(pathVis[s]) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges)\\r\\n    {\\r\\n        int maxcolor = -1;\\r\\n        vector<vector<int>> adj(colors.size());\\r\\n\\r\\n        for(auto x : edges) {\\r\\n            adj[x[0]].push_back(x[1]);\\r\\n        }\\r\\n\\r\\n        vector<int> vis(adj.size());\\r\\n        vector<int> pathVis(adj.size());\\r\\n\\r\\n        for(int i = 0; i <adj.size(); i++) {\\r\\n            if(!vis[i]) {\\r\\n                if(detectCycle(i, adj, vis, pathVis)) {\\r\\n                    return -1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        vector<vector<int>> dp(adj.size(), vector<int>(26, 0));\\r\\n\\r\\n        for(int k = topo.size() - 1; k >= 0; k--) {\\r\\n            int i = topo[k];\\r\\n            dp[i][colors[i] - 97] += 1;\\r\\n            maxcolor = max(maxcolor, dp[i][colors[i] - 97]);\\r\\n            \\r\\n            for(int x : adj[i]) {\\r\\n                for(int col = 0; col < 26; col++) {\\r\\n                    if(dp[x][col] < dp[i][col]) {\\r\\n                        dp[x][col] = dp[i][col];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return maxcolor;\\r\\n    }\\r\\n};\\r\\n```\\r\\n*Thank you for taking the time to read my post in its entirety. I appreciate your attention and hope you found it informative and helpful*\\r\\n\\r\\n**PLEASE UPVOTE THIS POST IF YOU FOUND IT HELPFUL**\\r\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    bool detectCycle(int s, vector<vector<int>>& adj, vector<int>& vis, vector<int>& pathVis)\\r\\n    {\\r\\n        if(!vis[s]) {\\r\\n            vis[s] = 1;\\r\\n            pathVis[s] = 1;\\r\\n\\r\\n            for(int x : adj[s]) {\\r\\n                if(detectCycle(x, adj, vis, pathVis)) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n            pathVis[s] = 0;\\r\\n        } else if(pathVis[s]) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges)\\r\\n    {\\r\\n        int maxcolor = -1;\\r\\n        vector<vector<int>> adj(colors.size());\\r\\n\\r\\n        for(auto x : edges) {\\r\\n            adj[x[0]].push_back(x[1]);\\r\\n        }\\r\\n\\r\\n        vector<int> vis(adj.size());\\r\\n        vector<int> pathVis(adj.size());\\r\\n        if(detectCycle(0, adj, vis, pathVis)) {\\r\\n            return -1;\\r\\n        }\\r\\n        vector<vector<int>> dp(adj.size(), vector<int>(26, 0));\\r\\n\\r\\n        for(int i = 0; i < adj.size(); i++) {\\r\\n\\r\\n            //When we visit a node we increase its color value by 1;\\r\\n            dp[i][colors[i] - 97] += 1;\\r\\n\\r\\n            /*we increase the color value in this stage only so we\\r\\n            may get the maxcolor value only in this stage*/\\r\\n            maxcolor = max(maxcolor, dp[i][colors[i] - 97]);\\r\\n            for(int x : adj[i]) {\\r\\n                for(int col = 0; col < 26; col++) {\\r\\n                    if(dp[x][col] < dp[i][col]) {\\r\\n                        dp[x][col] = dp[i][col]; \\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return maxcolor;\\r\\n    }\\r\\n};\\r\\n```\n```\\r\\nclass Solution {\\r\\n    vector<int> topo;\\r\\n    bool detectCycle(int s, vector<vector<int>>& adj, vector<int>& vis, vector<int>& pathVis)\\r\\n    {\\r\\n        if(!vis[s]) {\\r\\n            vis[s] = 1;\\r\\n            pathVis[s] = 1;\\r\\n\\r\\n            for(int x : adj[s]) {\\r\\n                if(detectCycle(x, adj, vis, pathVis)) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n            topo.push_back(s);\\r\\n            pathVis[s] = 0;\\r\\n        } else if(pathVis[s]) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges)\\r\\n    {\\r\\n        int maxcolor = -1;\\r\\n        vector<vector<int>> adj(colors.size());\\r\\n\\r\\n        for(auto x : edges) {\\r\\n            adj[x[0]].push_back(x[1]);\\r\\n        }\\r\\n\\r\\n        vector<int> vis(adj.size());\\r\\n        vector<int> pathVis(adj.size());\\r\\n\\r\\n        for(int i = 0; i <adj.size(); i++) {\\r\\n            if(!vis[i]) {\\r\\n                if(detectCycle(i, adj, vis, pathVis)) {\\r\\n                    return -1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        vector<vector<int>> dp(adj.size(), vector<int>(26, 0));\\r\\n\\r\\n        for(int k = topo.size() - 1; k >= 0; k--) {\\r\\n            int i = topo[k];\\r\\n            dp[i][colors[i] - 97] += 1;\\r\\n            maxcolor = max(maxcolor, dp[i][colors[i] - 97]);\\r\\n            \\r\\n            for(int x : adj[i]) {\\r\\n                for(int col = 0; col < 26; col++) {\\r\\n                    if(dp[x][col] < dp[i][col]) {\\r\\n                        dp[x][col] = dp[i][col];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return maxcolor;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198888,
                "title": "java-topological-sort-with-explanation",
                "content": "A typical topological sort but need to store extra information along the sorting process.\\n1. Use a class `Node` to record the global color frequency `colors` of all paths leading to this node. It also holds logic for updating `colors` when visiting this node and get the color with max frequency. \\n2. When we proceed to a node without outdegrees, i.e., no edge to other nodes, compare the node\\'s max color with the current `ans`.\\n3. Use `count` to track how many nodes have been visited already and use this to determine whether there is cycle at the end.\\n```java\\nclass Solution {\\n    \\n\\tstatic class Node {\\n\\t    // Stores the max frequency of color for this node.\\n\\t\\t// There may be multiple paths leading to this node, for each color,\\n\\t\\t// only the one with max count is needed here.\\n\\t\\tpublic int[] colors = new int[26];\\n\\t\\tpublic int colorIndex;\\n\\n\\t\\tNode (char c) {\\n\\t\\t\\tcolorIndex = c - \\'a\\';\\n\\t\\t}\\n\\n\\t\\tpublic void start() {\\n\\t\\t\\tcolors[colorIndex]++;\\n\\t\\t}\\n\\n\\t\\t// This is the key. When visiting a node, no matter which path leads to this node,\\n\\t\\t// we only need to store the max color frequency.\\n\\t\\t// Of course, you need to add 1 for this node\\'s color.\\n\\t\\tpublic void visit(int[] pre) {\\n\\t\\t\\tfor (int i = 0; i < pre.length; ++i) {\\n\\t\\t\\t\\tcolors[i] = Math.max(pre[i] + (i == colorIndex ? 1 : 0), colors[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int maxColor() {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tfor (int c : colors) {\\n\\t\\t\\t\\tmax = Math.max(max, c);\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int largestPathValue(String colors, int[][] edges) {\\n\\t\\tchar[] colorMap = colors.toCharArray();\\n\\t\\tint nodeSize = colorMap.length;\\n\\n\\t\\tint[] indegrees = new int[nodeSize];\\n\\t\\tList<Integer>[] outdegrees = new ArrayList[nodeSize];\\n\\t\\tfor (int i = 0; i < nodeSize; ++i) {\\n\\t\\t\\toutdegrees[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tint from = edge[0];\\n\\t\\t\\tint to = edge[1];\\n\\t\\t\\tindegrees[to]++;\\n\\t\\t\\toutdegrees[from].add(to);\\n\\t\\t}\\n\\n\\t\\tNode[] nodes = new Node[nodeSize];\\n\\t\\tfor (int i = 0; i < nodeSize; ++i) {\\n\\t\\t\\tnodes[i] = new Node(colorMap[i]);\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tQueue<Integer> visiting = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < nodeSize; ++i) {\\n\\t\\t\\tif (indegrees[i] == 0) {\\n\\t\\t\\t\\tvisiting.offer(i);\\n\\t\\t\\t\\t++count;\\n\\t\\t\\t\\tnodes[i].start();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint ans = 0;\\n\\t\\twhile (!visiting.isEmpty()) {\\n\\t\\t\\tint label = visiting.poll();\\n\\t\\t\\tif (outdegrees[label].isEmpty()) {\\n\\t\\t\\t\\tans = Math.max(ans, nodes[label].maxColor());\\n\\t\\t\\t}\\n\\t\\t\\tfor (int next : outdegrees[label]) {\\n\\t\\t\\t\\tnodes[next].visit(nodes[label].colors);\\n\\t\\t\\t\\tif (--indegrees[next] == 0) {\\n\\t\\t\\t\\t\\tvisiting.offer(next);\\n\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count == nodeSize ? ans : -1;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n\\tstatic class Node {\\n\\t    // Stores the max frequency of color for this node.\\n\\t\\t// There may be multiple paths leading to this node, for each color,\\n\\t\\t// only the one with max count is needed here.\\n\\t\\tpublic int[] colors = new int[26];\\n\\t\\tpublic int colorIndex;\\n\\n\\t\\tNode (char c) {\\n\\t\\t\\tcolorIndex = c - \\'a\\';\\n\\t\\t}\\n\\n\\t\\tpublic void start() {\\n\\t\\t\\tcolors[colorIndex]++;\\n\\t\\t}\\n\\n\\t\\t// This is the key. When visiting a node, no matter which path leads to this node,\\n\\t\\t// we only need to store the max color frequency.\\n\\t\\t// Of course, you need to add 1 for this node\\'s color.\\n\\t\\tpublic void visit(int[] pre) {\\n\\t\\t\\tfor (int i = 0; i < pre.length; ++i) {\\n\\t\\t\\t\\tcolors[i] = Math.max(pre[i] + (i == colorIndex ? 1 : 0), colors[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int maxColor() {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tfor (int c : colors) {\\n\\t\\t\\t\\tmax = Math.max(max, c);\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int largestPathValue(String colors, int[][] edges) {\\n\\t\\tchar[] colorMap = colors.toCharArray();\\n\\t\\tint nodeSize = colorMap.length;\\n\\n\\t\\tint[] indegrees = new int[nodeSize];\\n\\t\\tList<Integer>[] outdegrees = new ArrayList[nodeSize];\\n\\t\\tfor (int i = 0; i < nodeSize; ++i) {\\n\\t\\t\\toutdegrees[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tint from = edge[0];\\n\\t\\t\\tint to = edge[1];\\n\\t\\t\\tindegrees[to]++;\\n\\t\\t\\toutdegrees[from].add(to);\\n\\t\\t}\\n\\n\\t\\tNode[] nodes = new Node[nodeSize];\\n\\t\\tfor (int i = 0; i < nodeSize; ++i) {\\n\\t\\t\\tnodes[i] = new Node(colorMap[i]);\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tQueue<Integer> visiting = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < nodeSize; ++i) {\\n\\t\\t\\tif (indegrees[i] == 0) {\\n\\t\\t\\t\\tvisiting.offer(i);\\n\\t\\t\\t\\t++count;\\n\\t\\t\\t\\tnodes[i].start();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint ans = 0;\\n\\t\\twhile (!visiting.isEmpty()) {\\n\\t\\t\\tint label = visiting.poll();\\n\\t\\t\\tif (outdegrees[label].isEmpty()) {\\n\\t\\t\\t\\tans = Math.max(ans, nodes[label].maxColor());\\n\\t\\t\\t}\\n\\t\\t\\tfor (int next : outdegrees[label]) {\\n\\t\\t\\t\\tnodes[next].visit(nodes[label].colors);\\n\\t\\t\\t\\tif (--indegrees[next] == 0) {\\n\\t\\t\\t\\t\\tvisiting.offer(next);\\n\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count == nodeSize ? ans : -1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200668,
                "title": "easy-python-sol",
                "content": "basic idea is to first create graph and indegree map then we made dp[u][c] telling that if the path ended at u then freq of c color is ...colorvalues gives the color each node has ....then basic topological sort ... with viisted set we check wether we go to all nodes if not means we have a cycle and return -1 and at v  which is edge with u we find for all c dp[v][c] freq of of c till v ....for result if visited all the nodes we get the max of ,max element from the dp like max(x )in dp the from those max x we get the max freq in the PATHS ,,,,if u find it usefull do upvote plz it gives a lot of motivation..thanks have a nice day and keep learning \\n```py\\nclass Solution(object):\\n    def largestPathValue(self, colors, edges):\\n        n=len(colors)\\n        graph=defaultdict(list)\\n        indegree=defaultdict(int)\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            indegree[v]+=1\\n        \\n        queue=[]    \\n        dp=[[0]*26 for _ in range(n)]\\n        colorvalues=[ord(c)-ord(\"a\") for c in colors]\\n        for u in range(n):\\n            if u not in indegree:\\n                queue.append(u)\\n                dp[u][colorvalues[u]]=1\\n            \\n        visited=0\\n        while queue:\\n            u=queue.pop()\\n            visited+=1\\n\\n            for v in graph[u]:\\n                for c in range(26):\\n                    dp[v][c]=max(dp[v][c],dp[u][c] + (c==colorvalues[v]))\\n                indegree[v]-=1\\n                if indegree[v]==0:\\n                    queue.append(v)\\n                    del indegree[v]\\n        if visited<n:\\n            return -1\\n        return max(max(x) for x in dp)\\n\\t\\t```\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```py\\nclass Solution(object):\\n    def largestPathValue(self, colors, edges):\\n        n=len(colors)\\n        graph=defaultdict(list)\\n        indegree=defaultdict(int)\\n        \\n        for u,v in edges:\\n            graph[u].append(v)\\n            indegree[v]+=1\\n        \\n        queue=[]    \\n        dp=[[0]*26 for _ in range(n)]\\n        colorvalues=[ord(c)-ord(\"a\") for c in colors]\\n        for u in range(n):\\n            if u not in indegree:\\n                queue.append(u)\\n                dp[u][colorvalues[u]]=1\\n            \\n        visited=0\\n        while queue:\\n            u=queue.pop()\\n            visited+=1\\n\\n            for v in graph[u]:\\n                for c in range(26):\\n                    dp[v][c]=max(dp[v][c],dp[u][c] + (c==colorvalues[v]))\\n                indegree[v]-=1\\n                if indegree[v]==0:\\n                    queue.append(v)\\n                    del indegree[v]\\n        if visited<n:\\n            return -1\\n        return max(max(x) for x in dp)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1198641,
                "title": "python-topological-sort-dp",
                "content": "We run dfs on the graph first to check if there is a cycle and construct a topological sort of the graph. \\nFor each color `c`, we can loop over the topological sorted vertices and use dp to calculate the max number of `c` colored vertices on a path that ends on the current vertex.\\n\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n=len(colors)\\n        adj=[[] for _ in range(n)]\\n        for a,b in edges:\\n            adj[a].append(b)\\n        \\n        visited=[0]*n\\n        tp=[]\\n        cycle=False\\n\\n        def dfs(node):\\n            nonlocal cycle\\n            if visited[node]:\\n                if visited[node]==1:\\n                    cycle=True\\n                return\\n            visited[node]=1\\n            for c in adj[node]:\\n                dfs(c)\\n            visited[node]=2\\n            tp.append(node)\\n\\n        for i in range(n):\\n            if not visited[i]:\\n                dfs(i)\\n                \\n        if cycle:\\n            return -1\\n        tp.reverse()\\n        \\n        colors=[ord(c)-ord(\\'a\\') for c in colors]\\n        ans=0\\n        for c in range(26):\\n            dp=[0]*n\\n            for v in tp:\\n                if colors[v]==c:\\n                    dp[v]+=1\\n                    ans=max(ans,dp[v])\\n                for k in adj[v]:\\n                    dp[k]=max(dp[k],dp[v])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n=len(colors)\\n        adj=[[] for _ in range(n)]\\n        for a,b in edges:\\n            adj[a].append(b)\\n        \\n        visited=[0]*n\\n        tp=[]\\n        cycle=False\\n\\n        def dfs(node):\\n            nonlocal cycle\\n            if visited[node]:\\n                if visited[node]==1:\\n                    cycle=True\\n                return\\n            visited[node]=1\\n            for c in adj[node]:\\n                dfs(c)\\n            visited[node]=2\\n            tp.append(node)\\n\\n        for i in range(n):\\n            if not visited[i]:\\n                dfs(i)\\n                \\n        if cycle:\\n            return -1\\n        tp.reverse()\\n        \\n        colors=[ord(c)-ord(\\'a\\') for c in colors]\\n        ans=0\\n        for c in range(26):\\n            dp=[0]*n\\n            for v in tp:\\n                if colors[v]==c:\\n                    dp[v]+=1\\n                    ans=max(ans,dp[v])\\n                for k in adj[v]:\\n                    dp[k]=max(dp[k],dp[v])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395517,
                "title": "beats-90-cpp-sol",
                "content": "# PLEASE UPVOTE ME \\uD83E\\uDD79\\uD83E\\uDD79\\r\\n\\r\\n# Intuition\\r\\nWe want to find the largest path value in a directed graph, which means we need to find the longest path ending at each node.\\r\\nWe can use topological sorting to traverse the graph in a way that ensures we only visit nodes that have all their incoming edges processed.\\r\\nAt each visited node, we can update the counts for its neighbors based on the counts for the current node and the color of the neighbor.\\r\\nWe can use a set of nodes with zero indegrees to start the traversal and continue until we have visited all nodes, or detect a cycle in the graph.\\r\\nThe counts array allows us to keep track of the number of occurrences of each color in the longest path ending at each node, which is what we need to compute the largest path value.\\r\\n\\r\\n# Approach\\r\\nThe problem asks to find the largest path value in a directed graph, where each node has a color from the range [a, z].\\r\\nWe can use topological sorting to traverse the graph and compute the count of each color in the longest path ending at each node.\\r\\nTo do this, we first build the adjacency list and the array of indegrees for each node, as well as a set of nodes with zero indegrees.\\r\\nWe also initialize an array of counts for each node and color, with counts[i][j] representing the number of occurrences of color j in the longest path ending at node i.\\r\\nThen, we start traversing the graph from the nodes with zero indegrees, updating the counts for the neighbors of each visited node.\\r\\nFinally, we return the maximum count among all nodes if we have visited all nodes, or -1 if there is a cycle in the graph.\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n\\r\\n  int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        int k = 26;\\r\\n        vector<int> indegrees(n, 0);\\r\\n        vector<vector<int>> graph(n, vector<int>());\\r\\n        for (vector<int>& edge : edges) {\\r\\n            int u = edge[0];\\r\\n            int v = edge[1];\\r\\n            graph[u].push_back(v);\\r\\n            indegrees[v]++;\\r\\n        }\\r\\n        unordered_set<int> zero_indegree;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zero_indegree.insert(i);\\r\\n            }\\r\\n        }\\r\\n        vector<vector<int>> counts(n, vector<int>(k, 0));\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i][colors[i] - \\'a\\']++;\\r\\n        }\\r\\n        int max_count = 0;\\r\\n        int visited = 0;\\r\\n        while (!zero_indegree.empty()) {\\r\\n            int u = *zero_indegree.begin();\\r\\n            zero_indegree.erase(u);\\r\\n            visited++;\\r\\n            for (int v : graph[u]) {\\r\\n                for (int i = 0; i < k; i++) {\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (colors[v] - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zero_indegree.insert(v);\\r\\n                }\\r\\n            }\\r\\n            max_count = max(max_count, *max_element(counts[u].begin(), counts[u].end()));\\r\\n        }\\r\\n        return visited == n ? max_count : -1;\\r\\n    }\\r\\n\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n\\r\\n  int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        int k = 26;\\r\\n        vector<int> indegrees(n, 0);\\r\\n        vector<vector<int>> graph(n, vector<int>());\\r\\n        for (vector<int>& edge : edges) {\\r\\n            int u = edge[0];\\r\\n            int v = edge[1];\\r\\n            graph[u].push_back(v);\\r\\n            indegrees[v]++;\\r\\n        }\\r\\n        unordered_set<int> zero_indegree;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zero_indegree.insert(i);\\r\\n            }\\r\\n        }\\r\\n        vector<vector<int>> counts(n, vector<int>(k, 0));\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i][colors[i] - \\'a\\']++;\\r\\n        }\\r\\n        int max_count = 0;\\r\\n        int visited = 0;\\r\\n        while (!zero_indegree.empty()) {\\r\\n            int u = *zero_indegree.begin();\\r\\n            zero_indegree.erase(u);\\r\\n            visited++;\\r\\n            for (int v : graph[u]) {\\r\\n                for (int i = 0; i < k; i++) {\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (colors[v] - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zero_indegree.insert(v);\\r\\n                }\\r\\n            }\\r\\n            max_count = max(max_count, *max_element(counts[u].begin(), counts[u].end()));\\r\\n        }\\r\\n        return visited == n ? max_count : -1;\\r\\n    }\\r\\n\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395897,
                "title": "easiest-solution-topological-sort-dynamic-programming",
                "content": "```\\r\\nclass GraphNode {\\r\\n    int val;\\r\\n    ArrayList<Integer> neighbors;\\r\\n\\r\\n    public GraphNode(int n) {\\r\\n        this.val = n;\\r\\n        this.neighbors = new ArrayList();\\r\\n    }\\r\\n\\r\\n    public void addNodes(int n) {\\r\\n        this.neighbors.add(n);\\r\\n    }\\r\\n}\\r\\n\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        int m = edges.length;\\r\\n        GraphNode graph[] = new GraphNode[n];\\r\\n        int count[][] = new int[n][26];\\r\\n        int indegree[] = new int[n];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            graph[i] = new GraphNode(i);\\r\\n        }\\r\\n        for (int edge[] : edges) {\\r\\n            int src = edge[0];\\r\\n            int dest = edge[1];\\r\\n            graph[src].addNodes(dest);\\r\\n            indegree[dest]++;\\r\\n        }\\r\\n\\r\\n        Queue<Integer> queue = new LinkedList<>();\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                queue.add(i);\\r\\n            }\\r\\n            count[i][colors.charAt(i) - \\'a\\'] = 1;\\r\\n        }\\r\\n\\r\\n        int maxLength = 0;\\r\\n        int visited = 0;\\r\\n        while (!queue.isEmpty()) {\\r\\n            int curr = queue.poll();\\r\\n            visited++;\\r\\n            for (int neighbor : graph[curr].neighbors) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    count[neighbor][i] = Math.max(count[neighbor][i], count[curr][i] + (colors.charAt(neighbor) - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegree[neighbor]--;\\r\\n                if (indegree[neighbor] == 0) {\\r\\n                    queue.add(neighbor);\\r\\n                }\\r\\n            }\\r\\n            maxLength = Math.max(maxLength, Arrays.stream(count[curr]).max().getAsInt());\\r\\n        }\\r\\n        return visited == n ? maxLength : -1;\\r\\n    }\\r\\n}\\r\\n\\r\\n```\\r\\n# Upvoting is much appreciated",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass GraphNode {\\r\\n    int val;\\r\\n    ArrayList<Integer> neighbors;\\r\\n\\r\\n    public GraphNode(int n) {\\r\\n        this.val = n;\\r\\n        this.neighbors = new ArrayList();\\r\\n    }\\r\\n\\r\\n    public void addNodes(int n) {\\r\\n        this.neighbors.add(n);\\r\\n    }\\r\\n}\\r\\n\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        int m = edges.length;\\r\\n        GraphNode graph[] = new GraphNode[n];\\r\\n        int count[][] = new int[n][26];\\r\\n        int indegree[] = new int[n];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            graph[i] = new GraphNode(i);\\r\\n        }\\r\\n        for (int edge[] : edges) {\\r\\n            int src = edge[0];\\r\\n            int dest = edge[1];\\r\\n            graph[src].addNodes(dest);\\r\\n            indegree[dest]++;\\r\\n        }\\r\\n\\r\\n        Queue<Integer> queue = new LinkedList<>();\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                queue.add(i);\\r\\n            }\\r\\n            count[i][colors.charAt(i) - \\'a\\'] = 1;\\r\\n        }\\r\\n\\r\\n        int maxLength = 0;\\r\\n        int visited = 0;\\r\\n        while (!queue.isEmpty()) {\\r\\n            int curr = queue.poll();\\r\\n            visited++;\\r\\n            for (int neighbor : graph[curr].neighbors) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    count[neighbor][i] = Math.max(count[neighbor][i], count[curr][i] + (colors.charAt(neighbor) - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegree[neighbor]--;\\r\\n                if (indegree[neighbor] == 0) {\\r\\n                    queue.add(neighbor);\\r\\n                }\\r\\n            }\\r\\n            maxLength = Math.max(maxLength, Arrays.stream(count[curr]).max().getAsInt());\\r\\n        }\\r\\n        return visited == n ? maxLength : -1;\\r\\n    }\\r\\n}\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395788,
                "title": "solution-using-dynamic-programming-complete-explanation",
                "content": "\\r\\n\\r\\n# Approach\\r\\nTo solve this problem, we can use dynamic programming. We will define a 2D array dp, where dp[i][j] represents the maximum number of nodes of the color j that can be found in any valid path starting from node i. We will then iterate over all nodes in the graph, and for each node i, we will calculate the values of dp[i][j] for all colors j.\\r\\n\\r\\nTo calculate the value of dp[i][j], we will first iterate over all incoming edges to node i, and for each edge (u, i), we will take the maximum of dp[u][j] for all colors j, and add 1 if the color of node i is j. This will give us the maximum number of nodes of color j that we can get by extending a valid path from node u to node i. We will then take the maximum of these values for all incoming edges, and set dp[i][j] to this maximum.\\r\\n\\r\\nOnce we have calculated the values of dp for all nodes and colors, we can find the maximum color value of any valid path by iterating over all nodes and colors, and taking the maximum value of dp[i][j] for all i and j.\\r\\n\\r\\nIf at any point during the calculation of dp, we find a cycle in the graph, we can immediately return -1, since there can be no valid paths in a graph with a cycle.\\r\\n\\r\\nIn this code, the function dfs implements the dynamic programming algorithm described above. The visited array is used to keep track of the visited nodes during the depth-first search. The dp array stores the maximum number of nodes of each color that can be found in any valid path starting from a given node. The colors string stores the color of each node.\\r\\n\\r\\nThe largestPathValue function sets up the adjacency list and initializes the dp and visited arrays. It then iterates over all nodes in the graph, and for each node i, it calls dfs to calculate the values of dp[i][j]\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(nm), where n is the number of nodes in the graph and m is the number of edges\\r\\n\\r\\n- Space complexity:\\r\\nO(n + 26n), which simplifies to O(n), where n is the number of nodes in the graph\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        vector<vector<int>> adj(n);\\r\\n        for (auto edge : edges) {\\r\\n            adj[edge[0]].push_back(edge[1]);\\r\\n        }\\r\\n        vector<vector<int>> dp(n, vector<int>(26));\\r\\n        vector<int> visited(n, 0);\\r\\n        int ans = 0;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (visited[i] == 0 && dfs(i, adj, visited, dp, colors) == false) {\\r\\n                return -1;\\r\\n            }\\r\\n            for (int j = 0; j < 26; j++) {\\r\\n                ans = max(ans, dp[i][j]);\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    \\r\\n    bool dfs(int u, vector<vector<int>>& adj, vector<int>& visited, vector<vector<int>>& dp, string& colors) {\\r\\n        visited[u] = 1;\\r\\n        for (int v : adj[u]) {\\r\\n            if (visited[v] == 1) {\\r\\n                return false;\\r\\n            }\\r\\n            if (visited[v] == 0 && dfs(v, adj, visited, dp, colors) == false) {\\r\\n                return false;\\r\\n            }\\r\\n            for (int j = 0; j < 26; j++) {\\r\\n                dp[u][j] = max(dp[u][j], dp[v][j]);\\r\\n            }\\r\\n        }\\r\\n        dp[u][colors[u] - \\'a\\']++;\\r\\n        visited[u] = 2;\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        vector<vector<int>> adj(n);\\r\\n        for (auto edge : edges) {\\r\\n            adj[edge[0]].push_back(edge[1]);\\r\\n        }\\r\\n        vector<vector<int>> dp(n, vector<int>(26));\\r\\n        vector<int> visited(n, 0);\\r\\n        int ans = 0;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (visited[i] == 0 && dfs(i, adj, visited, dp, colors) == false) {\\r\\n                return -1;\\r\\n            }\\r\\n            for (int j = 0; j < 26; j++) {\\r\\n                ans = max(ans, dp[i][j]);\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    \\r\\n    bool dfs(int u, vector<vector<int>>& adj, vector<int>& visited, vector<vector<int>>& dp, string& colors) {\\r\\n        visited[u] = 1;\\r\\n        for (int v : adj[u]) {\\r\\n            if (visited[v] == 1) {\\r\\n                return false;\\r\\n            }\\r\\n            if (visited[v] == 0 && dfs(v, adj, visited, dp, colors) == false) {\\r\\n                return false;\\r\\n            }\\r\\n            for (int j = 0; j < 26; j++) {\\r\\n                dp[u][j] = max(dp[u][j], dp[v][j]);\\r\\n            }\\r\\n        }\\r\\n        dp[u][colors[u] - \\'a\\']++;\\r\\n        visited[u] = 2;\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123357,
                "title": "c-easy-to-understand-topological-sort-bfs",
                "content": "#### **Intitution/Approach:**\\n\\n* To detect cycle in directed graph use Khans Algorithm(topo sort).\\n* Make a storage for each node that will hold Maximum count of all 26 colour till current node. \\n* So that its neighbour will use that information to update their own maxCount of all colors. ( DP thing)\\n\\n##### **Code (with comments) :**\\n```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size(); // total nodes \\n        \\n        unordered_map<int,vector<int>> graph; //adj. list\\n        vector<int> indegree(n, 0); // to count indegree of all nodes\\n        vector<vector<int>> maxColorCount(n, vector<int>(26, 0));\\n        //i.e maxColorCount[i][j] gives the max Count of color j to reach ith node\\n        \\n        //prepare the adj. list\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            graph[u].push_back(v);\\n            indegree[v]++;\\n        }\\n        \\n        \\n        int ans=0; //to calculate the largest color count value of a valid path\\n        int total=0; // to check if we can visit all nodes or not (i.e if cycle is present then we cannot) \\n        queue<int> q; \\n        \\n        //push all 0 indegree nodes\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        \\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            \\n            total++;\\n            \\n            //node=> ith node ; colors[node] -\\'a\\' => jth color\\n            maxColorCount[node][colors[node]-\\'a\\']++;\\n            ans=max(ans, maxColorCount[node][colors[node]-\\'a\\']);\\n            \\n            for(int nbr: graph[node]){\\n                if(--indegree[nbr]==0){\\n                    q.push(nbr);\\n                }\\n                \\n                for(int i=0;i<26;i++)\\n                //update the maxColorCount for each neighbour node \\n                maxColorCount[nbr][i]=max(maxColorCount[node][i],  maxColorCount[nbr][i]);\\n            }\\n        }\\n        \\n        if(total!=n) return -1; // cycle detected\\n        \\n        return ans; \\n    }\\n};\\n```\\n\\n#### **Upvote if you like it :)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size(); // total nodes \\n        \\n        unordered_map<int,vector<int>> graph; //adj. list\\n        vector<int> indegree(n, 0); // to count indegree of all nodes\\n        vector<vector<int>> maxColorCount(n, vector<int>(26, 0));\\n        //i.e maxColorCount[i][j] gives the max Count of color j to reach ith node\\n        \\n        //prepare the adj. list\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            \\n            graph[u].push_back(v);\\n            indegree[v]++;\\n        }\\n        \\n        \\n        int ans=0; //to calculate the largest color count value of a valid path\\n        int total=0; // to check if we can visit all nodes or not (i.e if cycle is present then we cannot) \\n        queue<int> q; \\n        \\n        //push all 0 indegree nodes\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        \\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            \\n            total++;\\n            \\n            //node=> ith node ; colors[node] -\\'a\\' => jth color\\n            maxColorCount[node][colors[node]-\\'a\\']++;\\n            ans=max(ans, maxColorCount[node][colors[node]-\\'a\\']);\\n            \\n            for(int nbr: graph[node]){\\n                if(--indegree[nbr]==0){\\n                    q.push(nbr);\\n                }\\n                \\n                for(int i=0;i<26;i++)\\n                //update the maxColorCount for each neighbour node \\n                maxColorCount[nbr][i]=max(maxColorCount[node][i],  maxColorCount[nbr][i]);\\n            }\\n        }\\n        \\n        if(total!=n) return -1; // cycle detected\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397496,
                "title": "c-dp-easy-and-topo-sort",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string s, vector<vector<int>>& e) {\\r\\n        int n=s.size();\\r\\n        vector<int>ad[n];\\r\\n         vector<int>ind(n,0);\\r\\n        for(auto i:e){\\r\\n            ad[i[0]].push_back(i[1]);\\r\\n            ind[i[1]]++;\\r\\n        }\\r\\n        vector<int>col(n);\\r\\n        for(int i=0;i<s.size();i++)col[i]=s[i]-\\'a\\';\\r\\n        queue<int>q;\\r\\n        int ans=0;\\r\\n        int mx=1;\\r\\n        vector<vector<int>>dp(n,vector<int>(26,0));\\r\\n        vector<int>vis(n,0);\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(ind[i]==0){\\r\\n                vis[i]=1;\\r\\n                q.push(i);\\r\\n                dp[i][col[i]]++;\\r\\n            }\\r\\n            \\r\\n        }\\r\\n        while(q.size()){\\r\\n            int x=q.front();\\r\\n            q.pop();\\r\\n            ans++;\\r\\n            for(auto i:ad[x]){\\r\\n                if(!vis[i]){\\r\\n                    for(int j=0;j<26;j++){\\r\\n                        dp[i][j]=max(dp[i][j],dp[x][j] + (j==col[i]));\\r\\n                        mx=max(mx,dp[i][j]);\\r\\n                    }\\r\\n                }\\r\\n                ind[i]--;\\r\\n                if(ind[i]==0)q.push(i);\\r\\n            }\\r\\n        }\\r\\n      if(ans!=n)return -1;\\r\\n      else return mx;\\r\\n    }\\r\\n};\\r\\n```\\r\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/7ccbb644-9442-43fc-820d-ca33e7e993ee_1681047098.39331.jpeg)\\r\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string s, vector<vector<int>>& e) {\\r\\n        int n=s.size();\\r\\n        vector<int>ad[n];\\r\\n         vector<int>ind(n,0);\\r\\n        for(auto i:e){\\r\\n            ad[i[0]].push_back(i[1]);\\r\\n            ind[i[1]]++;\\r\\n        }\\r\\n        vector<int>col(n);\\r\\n        for(int i=0;i<s.size();i++)col[i]=s[i]-\\'a\\';\\r\\n        queue<int>q;\\r\\n        int ans=0;\\r\\n        int mx=1;\\r\\n        vector<vector<int>>dp(n,vector<int>(26,0));\\r\\n        vector<int>vis(n,0);\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(ind[i]==0){\\r\\n                vis[i]=1;\\r\\n                q.push(i);\\r\\n                dp[i][col[i]]++;\\r\\n            }\\r\\n            \\r\\n        }\\r\\n        while(q.size()){\\r\\n            int x=q.front();\\r\\n            q.pop();\\r\\n            ans++;\\r\\n            for(auto i:ad[x]){\\r\\n                if(!vis[i]){\\r\\n                    for(int j=0;j<26;j++){\\r\\n                        dp[i][j]=max(dp[i][j],dp[x][j] + (j==col[i]));\\r\\n                        mx=max(mx,dp[i][j]);\\r\\n                    }\\r\\n                }\\r\\n                ind[i]--;\\r\\n                if(ind[i]==0)q.push(i);\\r\\n            }\\r\\n        }\\r\\n      if(ans!=n)return -1;\\r\\n      else return mx;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395502,
                "title": "java-85-faster-code",
                "content": "\\r\\n\\r\\n# Code\\r\\n  PLEASE UPVOTE IF YOU LIKE.\\r\\n```\\r\\nclass Solution {\\r\\nboolean cycle=false;\\r\\n\\r\\npublic int largestPathValue(String colors , int[][] edges) {\\r\\n        \\r\\n        if(edges.length==0){\\r\\n                return 1;\\r\\n        }\\r\\n        \\r\\n    List<List<Integer>> graph=new ArrayList<>();\\r\\n        int n=colors.length();\\r\\n        \\r\\n        for(int i=0;i<=n;i++){\\r\\n                graph.add(new ArrayList<>());\\r\\n        }\\r\\n        \\r\\n      for(int i=0;i<edges.length;i++){\\r\\n              int u=edges[i][0];\\r\\n              int v=edges[i][1];\\r\\n             \\r\\n              \\r\\n              graph.get(u).add(v);\\r\\n      }  \\r\\n        \\r\\n         int max=0;\\r\\n        HashMap<Integer,int[]> map=new HashMap<>();\\r\\n        boolean[] visited=new boolean[n+1];\\r\\n        \\r\\n        int[] visited2=new int[n+1];\\r\\n    \\r\\n     \\r\\n        \\r\\n        for(int i=0;i<n;i++){\\r\\n            if(!map.containsKey(i)){\\r\\n                     int[] arr= dfs(i,graph,visited,map,colors,visited2);\\r\\n                    \\r\\n                    if(cycle)return -1;\\r\\n              \\r\\n                for(int j=0;j<26;j++){\\r\\n                        max=Math.max(arr[j],max);\\r\\n                }\\r\\n            }\\r\\n              \\r\\n        }\\r\\n        return max;\\r\\n        \\r\\n        \\r\\n}\\r\\n    public int[] dfs(int src,List<List<Integer>> graph,boolean[] visited,HashMap<Integer,int[] > map,String colors,int[] visited2){\\r\\n            \\r\\n          \\r\\n            if(map.containsKey(src))return map.get(src);\\r\\n            \\r\\n            visited[src]=true;\\r\\n           visited2[src]=-1;\\r\\n         int[] arr=new int[26];\\r\\n            for(int child:graph.get(src)){\\r\\n                    if(visited2[child]==-1){\\r\\n                            cycle=true;\\r\\n                    }\\r\\n                    if(visited[child]!=true){\\r\\n                        int[] a=    dfs(child,graph,visited,map,colors,visited2);\\r\\n                            for(int i=0;i<26;i++){\\r\\n                                  arr[i]=  Math.max(arr[i],a[i]);\\r\\n                            }\\r\\n                    }\\r\\n            }\\r\\n            visited[src]=false;\\r\\n            visited2[src]=2;\\r\\n             arr[colors.charAt(src)-\\'a\\']++;\\r\\n            map.put(src,arr);\\r\\n            return  arr;\\r\\n            \\r\\n            \\r\\n            \\r\\n    }\\r\\n    \\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\nboolean cycle=false;\\r\\n\\r\\npublic int largestPathValue(String colors , int[][] edges) {\\r\\n        \\r\\n        if(edges.length==0){\\r\\n                return 1;\\r\\n        }\\r\\n        \\r\\n    List<List<Integer>> graph=new ArrayList<>();\\r\\n        int n=colors.length();\\r\\n        \\r\\n        for(int i=0;i<=n;i++){\\r\\n                graph.add(new ArrayList<>());\\r\\n        }\\r\\n        \\r\\n      for(int i=0;i<edges.length;i++){\\r\\n              int u=edges[i][0];\\r\\n              int v=edges[i][1];\\r\\n             \\r\\n              \\r\\n              graph.get(u).add(v);\\r\\n      }  \\r\\n        \\r\\n         int max=0;\\r\\n        HashMap<Integer,int[]> map=new HashMap<>();\\r\\n        boolean[] visited=new boolean[n+1];\\r\\n        \\r\\n        int[] visited2=new int[n+1];\\r\\n    \\r\\n     \\r\\n        \\r\\n        for(int i=0;i<n;i++){\\r\\n            if(!map.containsKey(i)){\\r\\n                     int[] arr= dfs(i,graph,visited,map,colors,visited2);\\r\\n                    \\r\\n                    if(cycle)return -1;\\r\\n              \\r\\n                for(int j=0;j<26;j++){\\r\\n                        max=Math.max(arr[j],max);\\r\\n                }\\r\\n            }\\r\\n              \\r\\n        }\\r\\n        return max;\\r\\n        \\r\\n        \\r\\n}\\r\\n    public int[] dfs(int src,List<List<Integer>> graph,boolean[] visited,HashMap<Integer,int[] > map,String colors,int[] visited2){\\r\\n            \\r\\n          \\r\\n            if(map.containsKey(src))return map.get(src);\\r\\n            \\r\\n            visited[src]=true;\\r\\n           visited2[src]=-1;\\r\\n         int[] arr=new int[26];\\r\\n            for(int child:graph.get(src)){\\r\\n                    if(visited2[child]==-1){\\r\\n                            cycle=true;\\r\\n                    }\\r\\n                    if(visited[child]!=true){\\r\\n                        int[] a=    dfs(child,graph,visited,map,colors,visited2);\\r\\n                            for(int i=0;i<26;i++){\\r\\n                                  arr[i]=  Math.max(arr[i],a[i]);\\r\\n                            }\\r\\n                    }\\r\\n            }\\r\\n            visited[src]=false;\\r\\n            visited2[src]=2;\\r\\n             arr[colors.charAt(src)-\\'a\\']++;\\r\\n            map.put(src,arr);\\r\\n            return  arr;\\r\\n            \\r\\n            \\r\\n            \\r\\n    }\\r\\n    \\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198715,
                "title": "c-simple-dfs-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint n;\\n\\t\\tstring s;\\n\\t\\tvector<int> used;\\n\\t\\tvector<vector<int>> graph,dp;\\n\\n\\t\\tbool chkCycle(int i) {\\n\\t\\t\\tif(used[i]==2) return 0;\\n\\t\\t\\tif(used[i]) return 1;\\n\\t\\t\\tused[i]=1;\\n\\t\\t\\tfor(int j: graph[i]) {\\n\\t\\t\\t\\tif(chkCycle(j)) return 1;\\n\\t\\t\\t}\\n\\t\\t\\tused[i]=2;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint getDp(int i,int j) {\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tint mx=0;\\n\\t\\t\\tfor(int k: graph[i]) mx= max(mx, getDp(k,j) );\\n\\t\\t\\tif(s[i]-\\'a\\'==j) mx++;\\n\\t\\t\\tdp[i][j]=mx;\\n\\t\\t\\treturn mx;\\n\\t\\t}\\n\\n\\t\\tint largestPathValue(string colors, vector<vector<int>>& edges) {\\n\\t\\t\\tn=0; s= colors;\\n\\t\\t\\tfor(auto &i: edges) n=max(n,max(i[0],i[1])); n++;\\n\\t\\t\\tgraph.clear(); graph.resize(n);\\n\\t\\t\\tdp.clear(); dp.resize(n,vector<int>(26,-1));\\n\\t\\t\\tused.clear(); used.resize(n,0);\\n\\n\\t\\t\\tfor(auto &i: edges) {\\n\\t\\t\\t\\tgraph[i[0]].push_back(i[1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) if(used[i]==0) if(chkCycle(i)) return -1;\\n\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int j=0;j<26;j++) {\\n\\t\\t\\t\\tint mx=0;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\t\\tmx= max(mx, getDp(i,j));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if(mx) cout<<j<<\"@\"<<mx<<\\' \\';\\n\\t\\t\\t\\tans= max(ans,mx);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint n;\\n\\t\\tstring s;\\n\\t\\tvector<int> used;\\n\\t\\tvector<vector<int>> graph,dp;\\n\\n\\t\\tbool chkCycle(int i) {\\n\\t\\t\\tif(used[i]==2) return 0;\\n\\t\\t\\tif(used[i]) return 1;\\n\\t\\t\\tused[i]=1;\\n\\t\\t\\tfor(int j: graph[i]) {\\n\\t\\t\\t\\tif(chkCycle(j)) return 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3396251,
                "title": "c-dfs",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\n    void dfs(int curr, string &colors, vector<int> adjList[], vector<bool> &visited, vector<bool> &currPath, vector<vector<int>> &count, int &ans) {\\r\\n        if(currPath[curr] || ans == -1) {\\r\\n            ans = -1;\\r\\n            return;\\r\\n        }\\r\\n        if(visited[curr]) return;\\r\\n        visited[curr] = true;\\r\\n        currPath[curr] = true;\\r\\n        for(int next: adjList[curr]) {\\r\\n            dfs(next, colors, adjList, visited, currPath, count, ans);\\r\\n            if(ans == -1) return;\\r\\n            for(int i = 0; i < 26; i++) {\\r\\n                count[curr][i] = max(count[curr][i], count[next][i]);\\r\\n            }\\r\\n        }\\r\\n        count[curr][colors[curr] - \\'a\\']++;\\r\\n        ans = max(ans, count[curr][colors[curr] - \\'a\\']);\\r\\n        currPath[curr] = false;\\r\\n    }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.length();\\r\\n        vector<int> adjList[n];\\r\\n        for(vector<int> edge: edges) {\\r\\n            adjList[edge[0]].push_back(edge[1]);\\r\\n        }\\r\\n        int ans = INT_MIN;\\r\\n        vector<bool> visited(n), currPath(n);\\r\\n        vector<vector<int>> count(n, vector<int>(26));\\r\\n        for(int i = 0; i < n; i++) {\\r\\n            dfs(i, colors, adjList, visited, currPath, count, ans);\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    void dfs(int curr, string &colors, vector<int> adjList[], vector<bool> &visited, vector<bool> &currPath, vector<vector<int>> &count, int &ans) {\\r\\n        if(currPath[curr] || ans == -1) {\\r\\n            ans = -1;\\r\\n            return;\\r\\n        }\\r\\n        if(visited[curr]) return;\\r\\n        visited[curr] = true;\\r\\n        currPath[curr] = true;\\r\\n        for(int next: adjList[curr]) {\\r\\n            dfs(next, colors, adjList, visited, currPath, count, ans);\\r\\n            if(ans == -1) return;\\r\\n            for(int i = 0; i < 26; i++) {\\r\\n                count[curr][i] = max(count[curr][i], count[next][i]);\\r\\n            }\\r\\n        }\\r\\n        count[curr][colors[curr] - \\'a\\']++;\\r\\n        ans = max(ans, count[curr][colors[curr] - \\'a\\']);\\r\\n        currPath[curr] = false;\\r\\n    }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.length();\\r\\n        vector<int> adjList[n];\\r\\n        for(vector<int> edge: edges) {\\r\\n            adjList[edge[0]].push_back(edge[1]);\\r\\n        }\\r\\n        int ans = INT_MIN;\\r\\n        vector<bool> visited(n), currPath(n);\\r\\n        vector<vector<int>> count(n, vector<int>(26));\\r\\n        for(int i = 0; i < n; i++) {\\r\\n            dfs(i, colors, adjList, visited, currPath, count, ans);\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297442,
                "title": "python-dfs-solution",
                "content": "# Intuition\\r\\nYou only need to record the max number of occurence of each color. \\r\\n\\r\\n# Approach\\r\\nDFS to find cycle\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(M+N)\\r\\n\\r\\n- Space complexity:\\r\\nO(M+N)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        graph = defaultdict(list)\\r\\n        for edge in edges:\\r\\n            u, v = edge\\r\\n            graph[u].append(v)\\r\\n\\r\\n        visited = [-1] * len(colors)\\r\\n        max_colors = defaultdict(lambda:[0]*26)\\r\\n        \\r\\n        def explore(node):\\r\\n            # returns if we found a cycle\\r\\n            if visited[node] == 0:\\r\\n                return True\\r\\n            elif visited[node] == 1:\\r\\n                return False\\r\\n\\r\\n            visited[node] = 0\\r\\n            mc = [0] * 26\\r\\n            for neighbor in graph[node]:\\r\\n                have_cycle = explore(neighbor)\\r\\n                if have_cycle: return have_cycle\\r\\n                mc = [max(mc[i], max_colors[neighbor][i]) for i in range(len(mc))]\\r\\n            mc[ord(colors[node]) - ord(\\'a\\')] += 1\\r\\n            max_colors[node] = mc\\r\\n\\r\\n            visited[node] = 1\\r\\n            return False\\r\\n\\r\\n        for v in range(len(colors)):\\r\\n            if explore(v): return -1\\r\\n\\r\\n        res = 0\\r\\n        for v in max_colors.keys():\\r\\n            res = max(res, max(max_colors[v]))\\r\\n\\r\\n        return res\\r\\n\\r\\n        \\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        graph = defaultdict(list)\\r\\n        for edge in edges:\\r\\n            u, v = edge\\r\\n            graph[u].append(v)\\r\\n\\r\\n        visited = [-1] * len(colors)\\r\\n        max_colors = defaultdict(lambda:[0]*26)\\r\\n        \\r\\n        def explore(node):\\r\\n            # returns if we found a cycle\\r\\n            if visited[node] == 0:\\r\\n                return True\\r\\n            elif visited[node] == 1:\\r\\n                return False\\r\\n\\r\\n            visited[node] = 0\\r\\n            mc = [0] * 26\\r\\n            for neighbor in graph[node]:\\r\\n                have_cycle = explore(neighbor)\\r\\n                if have_cycle: return have_cycle\\r\\n                mc = [max(mc[i], max_colors[neighbor][i]) for i in range(len(mc))]\\r\\n            mc[ord(colors[node]) - ord(\\'a\\')] += 1\\r\\n            max_colors[node] = mc\\r\\n\\r\\n            visited[node] = 1\\r\\n            return False\\r\\n\\r\\n        for v in range(len(colors)):\\r\\n            if explore(v): return -1\\r\\n\\r\\n        res = 0\\r\\n        for v in max_colors.keys():\\r\\n            res = max(res, max(max_colors[v]))\\r\\n\\r\\n        return res\\r\\n\\r\\n        \\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339793,
                "title": "c-2-solutions-topological-sort-dfs-dp-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/largest-color-value-in-a-directed-graph/\\n    \\n    Core idea is to first process the nodes that come first in terms of dependency order.\\n    This ensures that when we process a node, all the paths coming to that node have been processed and\\n    the node will be processed at the end.\\n    \\n    Since we want to explore each path, naive DFS for each path will give TLE.\\n    We need to save the path color information. To do so, we can use a vector of size 26 for each node.\\n    This keeps track of longest length path with a given color appearing most frequently.\\n    \\n    SOLUTION 1: TOPOLOGICAL SORT (Kahn\\'s Algo)\\n    In Kahn\\'s algo, each time we are reducing the indegree, we are basically concluding the path traversed\\n    till that node. So we can do an extra step here, we also give that node the info of max color paths ending there.\\n    Keep passing on the path color info to each level. Also we use a var to keep track of max value seen so far.\\n    \\n    SOLUTION 2: DFS + DP\\n    This is also topological sort but with DFS. Just like topological sort with DFS, we first explore the neighboring nodes.\\n    Now here we save the path color info for each node if the traversal starts from there.\\n    So when a neighbor is done processing, just check the color path lengths that are possible from that neighbor\\n    and update the info of current node accordingly. Again a var is used to keep track of max value seen.\\n*/\\nclass Solution {\\npublic:\\n    /////////////////////////////////////////////////////////////////////// SOLUTION 1: TOPOLOGICAL SORT\\n    // TC: O(V + E)\\n    // SC: O(V + E)\\n    int topologicalSol(vector<unordered_set<int> >& graph, string& colors) {\\n        int n = graph.size(), processed = 0;\\n        queue<int> q;\\n        // indegree[i] = No. of incoming edges to node i\\n        vector<int> indegree(n, 0);\\n        // color_path_len[i][c] = For each color c,\\n        // stores the max no. of times c has been seen in a path ending here at node i  \\n        vector<vector<int> > color_path_len(n, vector<int>(26, 0));\\n        // Overall longest same colored nodes in a path\\n        int max_color = -1;\\n        \\n        // Find the indegree for each node\\n        for(int node = 0; node < n; node++)\\n            for(auto neighbor: graph[node])\\n                ++indegree[neighbor];\\n        \\n        // Add all the 0 indegree nodes\\n        for(int node = 0; node < n; node++)\\n            if(indegree[node] == 0)\\n                q.emplace(node);\\n        \\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            ++processed;\\n            \\n            // Update the max color path info for the current node\\n            max_color = max(max_color, ++color_path_len[node][colors[node] - \\'a\\']);\\n                \\n            // Remove edge from each neighbor\\n            for(auto neighbor: graph[node]) {\\n                --indegree[neighbor];\\n                if(indegree[neighbor] == 0)\\n                    q.emplace(neighbor);\\n                \\n                // Update the color path info for the neighbor\\n                for(int color = 0; color < 26; color++) {\\n                    color_path_len[neighbor][color] = max(color_path_len[neighbor][color],\\n                                                         color_path_len[node][color]);\\n                }\\n            }\\n        }\\n        \\n        return processed < n ? -1 : max_color;\\n    }\\n    \\n\\t/////////////////////////////////////////////////////////////////////////// SOLUTION 2: DFS + DP\\n    // TC: O(V + E)\\n    // SC: O(V + E)\\n    bool dfs(int node, vector<unordered_set<int> >& graph, string& colors, \\n             vector<int>& visited, vector<vector<int> >& color_path_len, int& max_color) {\\n        // Node is currently under processing and we are again seeing it, means a cycle\\n        if(visited[node] == 1)\\n            return false;\\n        \\n        // Node is unvisited\\n        if(visited[node] == 0) {\\n            // Mark node as processing\\n            visited[node] = 1;\\n            \\n            // Explore the neighbors first\\n            for(auto neighbor: graph[node]) {\\n                if(!dfs(neighbor, graph, colors, visited, color_path_len, max_color))\\n                    return false;\\n                // Since all the paths starting this neighbors have been explored, get the\\n                // max color path info\\n                for(int color = 0; color < 26; color++) {\\n                    color_path_len[node][color] = max(color_path_len[node][color],\\n                                                     color_path_len[neighbor][color]);\\n                    max_color = max(max_color, color_path_len[node][color]);\\n                }\\n            }\\n            // Update the color info for current node\\n            max_color = max(max_color, ++color_path_len[node][colors[node] - \\'a\\']);\\n            \\n            // Mark as visited\\n            visited[node] = 2;\\n        }\\n        return true;\\n    }\\n    \\n    int dfsDpSol(vector<unordered_set<int> >& graph, string& colors) {\\n        int max_color = -1, n = graph.size();\\n        // visited[i] = {0 (Unvisited), 1 (Processing), 2(Visited)}\\n        vector<int> visited(n, 0);\\n        // color_path_len[i][c] = For each color c,\\n        // stores the max no. of times c has been seen in a path start from here at node i  \\n        vector<vector<int> > color_path_len(n, vector<int>(26, 0));\\n        \\n        for(int node = 0; node < n; node++)\\n            if(!dfs(node, graph, colors, visited, color_path_len, max_color))\\n                return -1;\\n        return max_color;\\n    }\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        // <node, [neighbors] >\\n        vector<unordered_set<int> > graph(colors.size());\\n        \\n        // create the graph\\n        for(auto edge: edges) \\n            graph[edge[0]].emplace(edge[1]);\\n        \\n        // return topologicalSol(graph, colors);\\n        return dfsDpSol(graph, colors);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/largest-color-value-in-a-directed-graph/\\n    \\n    Core idea is to first process the nodes that come first in terms of dependency order.\\n    This ensures that when we process a node, all the paths coming to that node have been processed and\\n    the node will be processed at the end.\\n    \\n    Since we want to explore each path, naive DFS for each path will give TLE.\\n    We need to save the path color information. To do so, we can use a vector of size 26 for each node.\\n    This keeps track of longest length path with a given color appearing most frequently.\\n    \\n    SOLUTION 1: TOPOLOGICAL SORT (Kahn\\'s Algo)\\n    In Kahn\\'s algo, each time we are reducing the indegree, we are basically concluding the path traversed\\n    till that node. So we can do an extra step here, we also give that node the info of max color paths ending there.\\n    Keep passing on the path color info to each level. Also we use a var to keep track of max value seen so far.\\n    \\n    SOLUTION 2: DFS + DP\\n    This is also topological sort but with DFS. Just like topological sort with DFS, we first explore the neighboring nodes.\\n    Now here we save the path color info for each node if the traversal starts from there.\\n    So when a neighbor is done processing, just check the color path lengths that are possible from that neighbor\\n    and update the info of current node accordingly. Again a var is used to keep track of max value seen.\\n*/\\nclass Solution {\\npublic:\\n    /////////////////////////////////////////////////////////////////////// SOLUTION 1: TOPOLOGICAL SORT\\n    // TC: O(V + E)\\n    // SC: O(V + E)\\n    int topologicalSol(vector<unordered_set<int> >& graph, string& colors) {\\n        int n = graph.size(), processed = 0;\\n        queue<int> q;\\n        // indegree[i] = No. of incoming edges to node i\\n        vector<int> indegree(n, 0);\\n        // color_path_len[i][c] = For each color c,\\n        // stores the max no. of times c has been seen in a path ending here at node i  \\n        vector<vector<int> > color_path_len(n, vector<int>(26, 0));\\n        // Overall longest same colored nodes in a path\\n        int max_color = -1;\\n        \\n        // Find the indegree for each node\\n        for(int node = 0; node < n; node++)\\n            for(auto neighbor: graph[node])\\n                ++indegree[neighbor];\\n        \\n        // Add all the 0 indegree nodes\\n        for(int node = 0; node < n; node++)\\n            if(indegree[node] == 0)\\n                q.emplace(node);\\n        \\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            ++processed;\\n            \\n            // Update the max color path info for the current node\\n            max_color = max(max_color, ++color_path_len[node][colors[node] - \\'a\\']);\\n                \\n            // Remove edge from each neighbor\\n            for(auto neighbor: graph[node]) {\\n                --indegree[neighbor];\\n                if(indegree[neighbor] == 0)\\n                    q.emplace(neighbor);\\n                \\n                // Update the color path info for the neighbor\\n                for(int color = 0; color < 26; color++) {\\n                    color_path_len[neighbor][color] = max(color_path_len[neighbor][color],\\n                                                         color_path_len[node][color]);\\n                }\\n            }\\n        }\\n        \\n        return processed < n ? -1 : max_color;\\n    }\\n    \\n\\t/////////////////////////////////////////////////////////////////////////// SOLUTION 2: DFS + DP\\n    // TC: O(V + E)\\n    // SC: O(V + E)\\n    bool dfs(int node, vector<unordered_set<int> >& graph, string& colors, \\n             vector<int>& visited, vector<vector<int> >& color_path_len, int& max_color) {\\n        // Node is currently under processing and we are again seeing it, means a cycle\\n        if(visited[node] == 1)\\n            return false;\\n        \\n        // Node is unvisited\\n        if(visited[node] == 0) {\\n            // Mark node as processing\\n            visited[node] = 1;\\n            \\n            // Explore the neighbors first\\n            for(auto neighbor: graph[node]) {\\n                if(!dfs(neighbor, graph, colors, visited, color_path_len, max_color))\\n                    return false;\\n                // Since all the paths starting this neighbors have been explored, get the\\n                // max color path info\\n                for(int color = 0; color < 26; color++) {\\n                    color_path_len[node][color] = max(color_path_len[node][color],\\n                                                     color_path_len[neighbor][color]);\\n                    max_color = max(max_color, color_path_len[node][color]);\\n                }\\n            }\\n            // Update the color info for current node\\n            max_color = max(max_color, ++color_path_len[node][colors[node] - \\'a\\']);\\n            \\n            // Mark as visited\\n            visited[node] = 2;\\n        }\\n        return true;\\n    }\\n    \\n    int dfsDpSol(vector<unordered_set<int> >& graph, string& colors) {\\n        int max_color = -1, n = graph.size();\\n        // visited[i] = {0 (Unvisited), 1 (Processing), 2(Visited)}\\n        vector<int> visited(n, 0);\\n        // color_path_len[i][c] = For each color c,\\n        // stores the max no. of times c has been seen in a path start from here at node i  \\n        vector<vector<int> > color_path_len(n, vector<int>(26, 0));\\n        \\n        for(int node = 0; node < n; node++)\\n            if(!dfs(node, graph, colors, visited, color_path_len, max_color))\\n                return -1;\\n        return max_color;\\n    }\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        // <node, [neighbors] >\\n        vector<unordered_set<int> > graph(colors.size());\\n        \\n        // create the graph\\n        for(auto edge: edges) \\n            graph[edge[0]].emplace(edge[1]);\\n        \\n        // return topologicalSol(graph, colors);\\n        return dfsDpSol(graph, colors);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252601,
                "title": "c-dfs-dp-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    // value[i] stores the color value of subtree with root i and\\n    // inDegree[i] stores the in-degree of node i\\n    int ans, value[100005], inDegree[100005];\\n    vector<int> adj[100005];\\n    \\n    // visited[i] stores if ith node has been visited for current color and\\n    // inStack[i] stores if ith node has been visited in current dfs\\n    bool visited[100005], inStack[100005];\\n    string col;\\n\\n    int dfs(int node, int color)\\n    {\\n        // if we have already visited node, return its value\\n        if (visited[node])\\n            return value[node];\\n\\n        visited[node] = inStack[node] = true;\\n\\n        if (color == col[node] - \\'a\\')\\n            value[node]++;\\n\\n        int val = 0;\\n\\n        for (auto x : adj[node])\\n        {\\n            // cycle exists\\n            if (inStack[x])\\n                ans = -1;\\n            else\\n                val = max(val, dfs(x, color));\\n        }\\n\\n        value[node] += val;\\n        inStack[node] = false;\\n\\n        return value[node];\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges)\\n    {\\n        for (int i = 0; i < 100005; i++)\\n        {\\n            inDegree[i] = 0;\\n            adj[i].clear();\\n        }\\n\\n        ans = 0;\\n        int n = colors.length();\\n        col = colors;\\n\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            inDegree[edges[i][1]]++;\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n\\n        for (int j = 0; j < 26; j++)\\n        {\\n            for (int i = 0; i < 100005; i++)\\n            {\\n                value[i] = 0;\\n                visited[i] = inStack[i] = false;\\n            }\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                // doing dfs only for nodes with indegree 0, equivalent to topological sort\\n                if (inDegree[i] == 0)\\n                {\\n                    int val = dfs(i, j);\\n\\n                    // cycle exists\\n                    if (ans == -1)\\n                        return -1;\\n\\n                    ans = max(ans, val);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            // cycle exists\\n            if (visited[i] == false)\\n                return -1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // value[i] stores the color value of subtree with root i and\\n    // inDegree[i] stores the in-degree of node i\\n    int ans, value[100005], inDegree[100005];\\n    vector<int> adj[100005];\\n    \\n    // visited[i] stores if ith node has been visited for current color and\\n    // inStack[i] stores if ith node has been visited in current dfs\\n    bool visited[100005], inStack[100005];\\n    string col;\\n\\n    int dfs(int node, int color)\\n    {\\n        // if we have already visited node, return its value\\n        if (visited[node])\\n            return value[node];\\n\\n        visited[node] = inStack[node] = true;\\n\\n        if (color == col[node] - \\'a\\')\\n            value[node]++;\\n\\n        int val = 0;\\n\\n        for (auto x : adj[node])\\n        {\\n            // cycle exists\\n            if (inStack[x])\\n                ans = -1;\\n            else\\n                val = max(val, dfs(x, color));\\n        }\\n\\n        value[node] += val;\\n        inStack[node] = false;\\n\\n        return value[node];\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges)\\n    {\\n        for (int i = 0; i < 100005; i++)\\n        {\\n            inDegree[i] = 0;\\n            adj[i].clear();\\n        }\\n\\n        ans = 0;\\n        int n = colors.length();\\n        col = colors;\\n\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            inDegree[edges[i][1]]++;\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n\\n        for (int j = 0; j < 26; j++)\\n        {\\n            for (int i = 0; i < 100005; i++)\\n            {\\n                value[i] = 0;\\n                visited[i] = inStack[i] = false;\\n            }\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                // doing dfs only for nodes with indegree 0, equivalent to topological sort\\n                if (inDegree[i] == 0)\\n                {\\n                    int val = dfs(i, j);\\n\\n                    // cycle exists\\n                    if (ans == -1)\\n                        return -1;\\n\\n                    ans = max(ans, val);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            // cycle exists\\n            if (visited[i] == false)\\n                return -1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398906,
                "title": "java-dfs-clean-code",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(m+n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(m+n)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n  int ans = 0;\\r\\n  boolean[] visited, recStack;\\r\\n  int[][] maps;\\r\\n  List<Integer>[] adj;\\r\\n  \\r\\n  private boolean dfs(int node, String colors) {\\r\\n    if (recStack[node]) return true;\\r\\n    if (visited[node]) return false;\\r\\n\\r\\n    visited[node] = recStack[node] = true;\\r\\n    \\r\\n    for (var neighbor : adj[node]) {\\r\\n      if (dfs(neighbor, colors))\\r\\n        return true;\\r\\n\\r\\n      for (var i=0; i<26; i++)\\r\\n        maps[node][i] = Math.max(maps[node][i], maps[neighbor][i]);\\r\\n    }\\r\\n    recStack[node] = false;\\r\\n    maps[node][colors.charAt(node) - \\'a\\']++;\\r\\n\\r\\n    for (var cnt : maps[node])\\r\\n      ans = Math.max(ans, cnt);\\r\\n\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  public int largestPathValue(String colors, int[][] edges) {\\r\\n    var n = colors.length();\\r\\n    recStack = new boolean[n];\\r\\n    visited = new boolean[n];\\r\\n    maps = new int[n][26];\\r\\n    adj = new ArrayList[n];\\r\\n  \\r\\n    for (var i=0; i<n ; i++)\\r\\n      adj[i] = new ArrayList<>();\\r\\n\\r\\n    for (var edge : edges)\\r\\n      adj[edge[0]].add(edge[1]);\\r\\n\\r\\n    for (var i=0; i<n; i++) {\\r\\n      if (!visited[i]) {\\r\\n        Arrays.fill(recStack, false);\\r\\n\\r\\n        if (dfs(i, colors)) return -1;\\r\\n      }\\r\\n    }\\r\\n    return ans;\\r\\n  }\\r\\n}\\r\\n```\\r\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n  int ans = 0;\\r\\n  boolean[] visited, recStack;\\r\\n  int[][] maps;\\r\\n  List<Integer>[] adj;\\r\\n  \\r\\n  private boolean dfs(int node, String colors) {\\r\\n    if (recStack[node]) return true;\\r\\n    if (visited[node]) return false;\\r\\n\\r\\n    visited[node] = recStack[node] = true;\\r\\n    \\r\\n    for (var neighbor : adj[node]) {\\r\\n      if (dfs(neighbor, colors))\\r\\n        return true;\\r\\n\\r\\n      for (var i=0; i<26; i++)\\r\\n        maps[node][i] = Math.max(maps[node][i], maps[neighbor][i]);\\r\\n    }\\r\\n    recStack[node] = false;\\r\\n    maps[node][colors.charAt(node) - \\'a\\']++;\\r\\n\\r\\n    for (var cnt : maps[node])\\r\\n      ans = Math.max(ans, cnt);\\r\\n\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  public int largestPathValue(String colors, int[][] edges) {\\r\\n    var n = colors.length();\\r\\n    recStack = new boolean[n];\\r\\n    visited = new boolean[n];\\r\\n    maps = new int[n][26];\\r\\n    adj = new ArrayList[n];\\r\\n  \\r\\n    for (var i=0; i<n ; i++)\\r\\n      adj[i] = new ArrayList<>();\\r\\n\\r\\n    for (var edge : edges)\\r\\n      adj[edge[0]].add(edge[1]);\\r\\n\\r\\n    for (var i=0; i<n; i++) {\\r\\n      if (!visited[i]) {\\r\\n        Arrays.fill(recStack, false);\\r\\n\\r\\n        if (dfs(i, colors)) return -1;\\r\\n      }\\r\\n    }\\r\\n    return ans;\\r\\n  }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398328,
                "title": "java-bfs-dynamic-programming",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nConstruct a reverse graph\\r\\nHave an array for each node to store max color value for each color\\r\\nStart from zero out degree nodes\\r\\nUpdate the parent nodes for each node, remove the edge from parent nodes.\\r\\nIf parent node has no out degree, add it to the queue\\r\\nreturn the max color value at the end \\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nQueue(BFS)\\r\\n# Complexity\\r\\n- Time complexity: O(n)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(n)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Node{\\r\\n    int outDegreeCount;\\r\\n    List<Node> parentNodes;\\r\\n    int[] childColorCounts;\\r\\n    char color;\\r\\n    Node(char color){\\r\\n        this.color = color;\\r\\n        parentNodes = new LinkedList<>();\\r\\n        childColorCounts = new int[26];\\r\\n        childColorCounts[color - 97] ++;\\r\\n    }\\r\\n    public String toString(){\\r\\n        return color+\" \";\\r\\n    }\\r\\n}\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        if(edges.length == 0){\\r\\n            return 1;\\r\\n        }\\r\\n        Map<Integer,Node> nodes = new HashMap<>();\\r\\n        \\r\\n        storeGraph(nodes, edges, colors);\\r\\n\\r\\n        Queue<Node> queueNodes = new LinkedList<>();\\r\\n\\r\\n        addZeroOutDegreeNodes(queueNodes, nodes, colors);\\r\\n        int visitedNodeCount = queueNodes.size(), n = nodes.size();\\r\\n        int maxColorValue = 0;\\r\\n\\r\\n        while(!queueNodes.isEmpty()){\\r\\n            int size = queueNodes.size();\\r\\n            while(size -- > 0){\\r\\n                Node node = queueNodes.poll();\\r\\n                maxColorValue = Math.max(maxColorValue, node.childColorCounts[node.color - 97]);\\r\\n                for(Node parentNode: node.parentNodes){\\r\\n                    updateParentColorCounts(nodes, node, parentNode);\\r\\n                    parentNode.outDegreeCount--;\\r\\n\\r\\n                    if(parentNode.outDegreeCount == 0){\\r\\n                        queueNodes.add(parentNode);\\r\\n                        visitedNodeCount++;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return visitedNodeCount == n ? maxColorValue : -1;\\r\\n    }\\r\\n    private void storeGraph(Map<Integer,Node> nodes, int[][] edges, String colors){\\r\\n        for(int[] edge: edges){\\r\\n            Node a = nodes.getOrDefault(edge[0], new Node(colors.charAt(edge[0])));\\r\\n            Node b = nodes.getOrDefault(edge[1], new Node(colors.charAt(edge[1])));\\r\\n            nodes.putIfAbsent(edge[0], a);\\r\\n            nodes.putIfAbsent(edge[1], b);\\r\\n            a.outDegreeCount++;\\r\\n\\r\\n            b.parentNodes.add(a);\\r\\n        }\\r\\n    }\\r\\n    private void addZeroOutDegreeNodes(Queue<Node> queueNodes, Map<Integer,Node> nodes, String colors){\\r\\n        for(Node node: nodes.values()){\\r\\n            if(node.outDegreeCount == 0){\\r\\n                queueNodes.add(node);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    private void updateParentColorCounts(Map<Integer,Node> nodes, Node node, Node parentNode){\\r\\n        for(int i = 0; i< 26;i++){\\r\\n            parentNode.childColorCounts[i] = Math.max(parentNode.childColorCounts[i], node.childColorCounts[i]);\\r\\n            if(i == parentNode.color - 97){\\r\\n                parentNode.childColorCounts[i] = Math.max(parentNode.childColorCounts[i], node.childColorCounts[i]+1);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Queue"
                ],
                "code": "```\\r\\nclass Node{\\r\\n    int outDegreeCount;\\r\\n    List<Node> parentNodes;\\r\\n    int[] childColorCounts;\\r\\n    char color;\\r\\n    Node(char color){\\r\\n        this.color = color;\\r\\n        parentNodes = new LinkedList<>();\\r\\n        childColorCounts = new int[26];\\r\\n        childColorCounts[color - 97] ++;\\r\\n    }\\r\\n    public String toString(){\\r\\n        return color+\" \";\\r\\n    }\\r\\n}\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        if(edges.length == 0){\\r\\n            return 1;\\r\\n        }\\r\\n        Map<Integer,Node> nodes = new HashMap<>();\\r\\n        \\r\\n        storeGraph(nodes, edges, colors);\\r\\n\\r\\n        Queue<Node> queueNodes = new LinkedList<>();\\r\\n\\r\\n        addZeroOutDegreeNodes(queueNodes, nodes, colors);\\r\\n        int visitedNodeCount = queueNodes.size(), n = nodes.size();\\r\\n        int maxColorValue = 0;\\r\\n\\r\\n        while(!queueNodes.isEmpty()){\\r\\n            int size = queueNodes.size();\\r\\n            while(size -- > 0){\\r\\n                Node node = queueNodes.poll();\\r\\n                maxColorValue = Math.max(maxColorValue, node.childColorCounts[node.color - 97]);\\r\\n                for(Node parentNode: node.parentNodes){\\r\\n                    updateParentColorCounts(nodes, node, parentNode);\\r\\n                    parentNode.outDegreeCount--;\\r\\n\\r\\n                    if(parentNode.outDegreeCount == 0){\\r\\n                        queueNodes.add(parentNode);\\r\\n                        visitedNodeCount++;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return visitedNodeCount == n ? maxColorValue : -1;\\r\\n    }\\r\\n    private void storeGraph(Map<Integer,Node> nodes, int[][] edges, String colors){\\r\\n        for(int[] edge: edges){\\r\\n            Node a = nodes.getOrDefault(edge[0], new Node(colors.charAt(edge[0])));\\r\\n            Node b = nodes.getOrDefault(edge[1], new Node(colors.charAt(edge[1])));\\r\\n            nodes.putIfAbsent(edge[0], a);\\r\\n            nodes.putIfAbsent(edge[1], b);\\r\\n            a.outDegreeCount++;\\r\\n\\r\\n            b.parentNodes.add(a);\\r\\n        }\\r\\n    }\\r\\n    private void addZeroOutDegreeNodes(Queue<Node> queueNodes, Map<Integer,Node> nodes, String colors){\\r\\n        for(Node node: nodes.values()){\\r\\n            if(node.outDegreeCount == 0){\\r\\n                queueNodes.add(node);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    private void updateParentColorCounts(Map<Integer,Node> nodes, Node node, Node parentNode){\\r\\n        for(int i = 0; i< 26;i++){\\r\\n            parentNode.childColorCounts[i] = Math.max(parentNode.childColorCounts[i], node.childColorCounts[i]);\\r\\n            if(i == parentNode.color - 97){\\r\\n                parentNode.childColorCounts[i] = Math.max(parentNode.childColorCounts[i], node.childColorCounts[i]+1);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396557,
                "title": "js-dfs-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    const n = colors.length;\\r\\n    const visited = Array(n).fill(0);\\r\\n    const maxCount = Array(n).fill(0).map(_=>Array(26).fill(0));\\r\\n    const adj = Array(n).fill(0).map(_=>[]);\\r\\n    \\r\\n    for(const [a,b] of edges){\\r\\n      adj[a].push(b);\\r\\n    }\\r\\n    let res = 0;\\r\\n    for(let i=0; i<n; i++){\\r\\n      res = Math.max(res, dfs(i, maxCount));\\r\\n    };\\r\\n    return res === Infinity ? -1 : res;\\r\\n\\r\\n    function dfs(node, colorsCount){\\r\\n      const cur = colors[node].charCodeAt()-97;\\r\\n      if(!visited[node]){\\r\\n        visited[node] = 1;\\r\\n        for(const next of adj[node]){\\r\\n          if(dfs(next, colorsCount) === Infinity){\\r\\n            return Infinity;\\r\\n          }\\r\\n          for(let k=0; k<26; k++){\\r\\n            maxCount[node][k] = Math.max(maxCount[node][k], maxCount[next][k]);\\r\\n          }\\r\\n        }\\r\\n        maxCount[node][cur]++;\\r\\n        visited[node] = 2;\\r\\n      }\\r\\n      return visited[node] === 2 ? maxCount[node][cur] : Infinity;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    const n = colors.length;\\r\\n    const visited = Array(n).fill(0);\\r\\n    const maxCount = Array(n).fill(0).map(_=>Array(26).fill(0));\\r\\n    const adj = Array(n).fill(0).map(_=>[]);\\r\\n    \\r\\n    for(const [a,b] of edges){\\r\\n      adj[a].push(b);\\r\\n    }\\r\\n    let res = 0;\\r\\n    for(let i=0; i<n; i++){\\r\\n      res = Math.max(res, dfs(i, maxCount));\\r\\n    };\\r\\n    return res === Infinity ? -1 : res;\\r\\n\\r\\n    function dfs(node, colorsCount){\\r\\n      const cur = colors[node].charCodeAt()-97;\\r\\n      if(!visited[node]){\\r\\n        visited[node] = 1;\\r\\n        for(const next of adj[node]){\\r\\n          if(dfs(next, colorsCount) === Infinity){\\r\\n            return Infinity;\\r\\n          }\\r\\n          for(let k=0; k<26; k++){\\r\\n            maxCount[node][k] = Math.max(maxCount[node][k], maxCount[next][k]);\\r\\n          }\\r\\n        }\\r\\n        maxCount[node][cur]++;\\r\\n        visited[node] = 2;\\r\\n      }\\r\\n      return visited[node] === 2 ? maxCount[node][cur] : Infinity;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3396304,
                "title": "python-dfs-dp",
                "content": "# Approach\\r\\n\\r\\nDFS with cycle detection. Similar to Course Schedules.\\r\\n\\r\\nImagine each node as having it\\'s own dictionary. Each node\\'s color values is the max of its children node\\'s color values.\\r\\n\\r\\nThis approach prevents us from having to do a DFS starting at every node, which would be quadratic time. Since each node has its own dictionary, or in other words, we store the best paths for each node, we don\\'t need to go through paths we\\'ve already visited.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(v + e)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(v)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n\\r\\n        if not edges: return 1\\r\\n\\r\\n        adj_list = defaultdict(list)\\r\\n        for a, b in edges:\\r\\n            adj_list[a].append(b)\\r\\n        \\r\\n\\r\\n        def dfs(cur):\\r\\n            \\r\\n            if cur in cycle: return True\\r\\n            if cur in visited: return False\\r\\n                \\r\\n            visited.add(cur)\\r\\n            cycle.add(cur)\\r\\n\\r\\n            for neigh in adj_list[cur]:\\r\\n                \\r\\n                if dfs(neigh):\\r\\n                    return True\\r\\n                    \\r\\n                for color in range(26):\\r\\n                    dp[cur][color] = max(dp[cur][color], dp[neigh][color])\\r\\n            \\r\\n\\r\\n            cur_color = ord(colors[cur]) - ord(\"a\")\\r\\n            dp[cur][cur_color] += 1\\r\\n            self.ans = max(self.ans, dp[cur][cur_color])\\r\\n\\r\\n            cycle.remove(cur)\\r\\n            return False\\r\\n\\r\\n\\r\\n        visited = set()\\r\\n        cycle = set()\\r\\n        dp = [[0] * 26 for _ in range(len(colors))]\\r\\n        self.ans = -1\\r\\n\\r\\n        for node in range(len(colors)):\\r\\n            if node not in visited:\\r\\n                if dfs(node):\\r\\n                    return -1\\r\\n        \\r\\n        return self.ans\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n\\r\\n        if not edges: return 1\\r\\n\\r\\n        adj_list = defaultdict(list)\\r\\n        for a, b in edges:\\r\\n            adj_list[a].append(b)\\r\\n        \\r\\n\\r\\n        def dfs(cur):\\r\\n            \\r\\n            if cur in cycle: return True\\r\\n            if cur in visited: return False\\r\\n                \\r\\n            visited.add(cur)\\r\\n            cycle.add(cur)\\r\\n\\r\\n            for neigh in adj_list[cur]:\\r\\n                \\r\\n                if dfs(neigh):\\r\\n                    return True\\r\\n                    \\r\\n                for color in range(26):\\r\\n                    dp[cur][color] = max(dp[cur][color], dp[neigh][color])\\r\\n            \\r\\n\\r\\n            cur_color = ord(colors[cur]) - ord(\"a\")\\r\\n            dp[cur][cur_color] += 1\\r\\n            self.ans = max(self.ans, dp[cur][cur_color])\\r\\n\\r\\n            cycle.remove(cur)\\r\\n            return False\\r\\n\\r\\n\\r\\n        visited = set()\\r\\n        cycle = set()\\r\\n        dp = [[0] * 26 for _ in range(len(colors))]\\r\\n        self.ans = -1\\r\\n\\r\\n        for node in range(len(colors)):\\r\\n            if node not in visited:\\r\\n                if dfs(node):\\r\\n                    return -1\\r\\n        \\r\\n        return self.ans\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396042,
                "title": "easy-c-topological-sort-solution-graph",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n  int largestPathValue(string cs, vector<vector<int>>& edges) {\\r\\n    vector<vector<int>> al(cs.size()), cnt(cs.size(), vector<int>(26));\\r\\n    vector<int> indegrees(cs.size());\\r\\n    for (auto &e: edges) {\\r\\n        al[e[0]].push_back(e[1]);\\r\\n        ++indegrees[e[1]];\\r\\n    }\\r\\n    vector<int> q;\\r\\n    for (int i = 0; i < cs.size(); ++i)\\r\\n        if (indegrees[i] == 0)\\r\\n            q.push_back(i);\\r\\n    int res = 0, processed = 0;\\r\\n    while (!q.empty()) {\\r\\n        vector<int> q1;\\r\\n        for (auto i : q) {\\r\\n            ++processed;\\r\\n            res = max(res, ++cnt[i][cs[i] - \\'a\\']);\\r\\n            for (auto j : al[i]) {\\r\\n                for (auto k = 0; k < 26; ++k)\\r\\n                    cnt[j][k] = max(cnt[j][k], cnt[i][k]);\\r\\n                if (--indegrees[j] == 0)\\r\\n                    q1.push_back(j);\\r\\n            }\\r\\n        }\\r\\n        swap(q, q1);\\r\\n    }\\r\\n    return processed != cs.size() ? -1 : res;\\r\\n}\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n  int largestPathValue(string cs, vector<vector<int>>& edges) {\\r\\n    vector<vector<int>> al(cs.size()), cnt(cs.size(), vector<int>(26));\\r\\n    vector<int> indegrees(cs.size());\\r\\n    for (auto &e: edges) {\\r\\n        al[e[0]].push_back(e[1]);\\r\\n        ++indegrees[e[1]];\\r\\n    }\\r\\n    vector<int> q;\\r\\n    for (int i = 0; i < cs.size(); ++i)\\r\\n        if (indegrees[i] == 0)\\r\\n            q.push_back(i);\\r\\n    int res = 0, processed = 0;\\r\\n    while (!q.empty()) {\\r\\n        vector<int> q1;\\r\\n        for (auto i : q) {\\r\\n            ++processed;\\r\\n            res = max(res, ++cnt[i][cs[i] - \\'a\\']);\\r\\n            for (auto j : al[i]) {\\r\\n                for (auto k = 0; k < 26; ++k)\\r\\n                    cnt[j][k] = max(cnt[j][k], cnt[i][k]);\\r\\n                if (--indegrees[j] == 0)\\r\\n                    q1.push_back(j);\\r\\n            }\\r\\n        }\\r\\n        swap(q, q1);\\r\\n    }\\r\\n    return processed != cs.size() ? -1 : res;\\r\\n}\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395674,
                "title": "swift-kahn-s-topological-sort",
                "content": "**Kahn\\'s Algorithm (accepted answer)**\\n```\\nclass Solution {\\n    func largestPathValue(_ colors: String, _ edges: [[Int]]) -> Int {\\n        let outGraph = edges.reduce(into: [Int:[Int]]()) { g,e in g[e[0], default:[]] += [e[1]] }\\n        var inDegrees = edges.reduce(into: Array(repeating:0, count:colors.count)) { arr,e in arr[e[1]] += 1}\\n        let colors = Array(colors)\\n        var freqMap = Array(repeating: [Character: Int](), count: colors.count)\\n        var unvisited = Set(colors.indices)\\n        var queue = colors.indices.filter { inDegrees[$0] == 0 }\\n        \\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            unvisited.remove(node)\\n            freqMap[node][colors[node], default:0] += 1\\n            \\n            for adj in outGraph[node, default:[]] {\\n                inDegrees[adj] -= 1\\n                if inDegrees[adj] == 0 { queue.append(adj) }\\n                freqMap[adj].merge(freqMap[node], uniquingKeysWith: max)\\n            }\\n        }\\n        \\n        return unvisited.isEmpty ? freqMap.reduce(0) {max($0, $1.values.max()!)} : -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestPathValue(_ colors: String, _ edges: [[Int]]) -> Int {\\n        let outGraph = edges.reduce(into: [Int:[Int]]()) { g,e in g[e[0], default:[]] += [e[1]] }\\n        var inDegrees = edges.reduce(into: Array(repeating:0, count:colors.count)) { arr,e in arr[e[1]] += 1}\\n        let colors = Array(colors)\\n        var freqMap = Array(repeating: [Character: Int](), count: colors.count)\\n        var unvisited = Set(colors.indices)\\n        var queue = colors.indices.filter { inDegrees[$0] == 0 }\\n        \\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            unvisited.remove(node)\\n            freqMap[node][colors[node], default:0] += 1\\n            \\n            for adj in outGraph[node, default:[]] {\\n                inDegrees[adj] -= 1\\n                if inDegrees[adj] == 0 { queue.append(adj) }\\n                freqMap[adj].merge(freqMap[node], uniquingKeysWith: max)\\n            }\\n        }\\n        \\n        return unvisited.isEmpty ? freqMap.reduce(0) {max($0, $1.values.max()!)} : -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395632,
                "title": "python",
                "content": "# Intuition\\r\\n\\r\\nI haven\\'t checked the editorial, and this is probably the usual way to solve this problem. Still to my greatest surprise it beats 100% concerning the run time, although this measure is not completely reliable.\\r\\n\\r\\n\\r\\n# Approach\\r\\n\\r\\nFirst you can compute the topological order of the nodes, at the same time you check the existence of a directed cycle.\\r\\n\\r\\nOnce this is done you can compute for each color the maximal frequency along any path in the graph. The maximum of these maximal values is the answer.\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $O(|E|*|colors|)$\\r\\n\\r\\n- Space complexity: $O(|V|)$\\r\\n\\r\\n# Code\\r\\n\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        in_degree = [0]*n\\r\\n        out_edges = [[] for _ in range(n)]\\r\\n        \\r\\n        for a, b in edges:\\r\\n            in_degree[b] += 1\\r\\n            out_edges[a].append(b)\\r\\n\\r\\n        top_order = [i for i in range(n) if in_degree[i]==0]\\r\\n        k = 0\\r\\n        while k < len(top_order):\\r\\n            i = top_order[k]\\r\\n            k += 1\\r\\n            for j in out_edges[i]:\\r\\n                if in_degree[j] == 1:\\r\\n                    top_order.append(j)\\r\\n                in_degree[j] -= 1\\r\\n        if len(top_order) < n:\\r\\n            return -1\\r\\n        \\r\\n        max_color = 0\\r\\n        for c in set(colors):\\r\\n            c_freq = [0]*n\\r\\n            for i in reversed(top_order):\\r\\n                d = int(c == colors[i])\\r\\n                c_freq[i] = max((c_freq[j] for j in out_edges[i]), default=0) + d\\r\\n                if c_freq[i] > max_color:\\r\\n                    max_color = c_freq[i]\\r\\n\\r\\n        return max_color\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        in_degree = [0]*n\\r\\n        out_edges = [[] for _ in range(n)]\\r\\n        \\r\\n        for a, b in edges:\\r\\n            in_degree[b] += 1\\r\\n            out_edges[a].append(b)\\r\\n\\r\\n        top_order = [i for i in range(n) if in_degree[i]==0]\\r\\n        k = 0\\r\\n        while k < len(top_order):\\r\\n            i = top_order[k]\\r\\n            k += 1\\r\\n            for j in out_edges[i]:\\r\\n                if in_degree[j] == 1:\\r\\n                    top_order.append(j)\\r\\n                in_degree[j] -= 1\\r\\n        if len(top_order) < n:\\r\\n            return -1\\r\\n        \\r\\n        max_color = 0\\r\\n        for c in set(colors):\\r\\n            c_freq = [0]*n\\r\\n            for i in reversed(top_order):\\r\\n                d = int(c == colors[i])\\r\\n                c_freq[i] = max((c_freq[j] for j in out_edges[i]), default=0) + d\\r\\n                if c_freq[i] > max_color:\\r\\n                    max_color = c_freq[i]\\r\\n\\r\\n        return max_color\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395452,
                "title": "daily-leetcoding-challenge-april-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1401419,
                "title": "c-solution-using-topo-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>graph[100002];\\n    int largestPathValue(string s, vector<vector<int>>& edges) \\n    {\\n    \\n        int n=s.size();\\n        vector<int>in(n,0);\\n        for(auto it:edges)\\n        {\\n            graph[it[0]].push_back(it[1]);\\n            in[it[1]]++;\\n        }\\n        queue<int>q;\\n        vector<vector<int>>dp(n,vector<int>(26,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        int ans=0;\\n        vector<int>vis(n,0);\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            dp[temp][s[temp]-97]++;\\n            vis[temp]=1;\\n            for(int i=0;i<26;i++)\\n            {\\n                ans=max(ans,dp[temp][i]);\\n            }\\n            for(auto it:graph[temp])\\n            {\\n                in[it]--;\\n                if(in[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n                for(int i=0;i<26;i++)\\n                {\\n                    dp[it][i]=max(dp[it][i],dp[temp][i]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>graph[100002];\\n    int largestPathValue(string s, vector<vector<int>>& edges) \\n    {\\n    \\n        int n=s.size();\\n        vector<int>in(n,0);\\n        for(auto it:edges)\\n        {\\n            graph[it[0]].push_back(it[1]);\\n            in[it[1]]++;\\n        }\\n        queue<int>q;\\n        vector<vector<int>>dp(n,vector<int>(26,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        int ans=0;\\n        vector<int>vis(n,0);\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            dp[temp][s[temp]-97]++;\\n            vis[temp]=1;\\n            for(int i=0;i<26;i++)\\n            {\\n                ans=max(ans,dp[temp][i]);\\n            }\\n            for(auto it:graph[temp])\\n            {\\n                in[it]--;\\n                if(in[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n                for(int i=0;i<26;i++)\\n                {\\n                    dp[it][i]=max(dp[it][i],dp[temp][i]);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272753,
                "title": "java-clean-concise-topologic-sort-dp-solution-with-comments",
                "content": "\\n```\\nclass Solution {\\n\\n      Map<Integer, List<Integer>> graph = new HashMap<>();\\n      Map<Integer, Integer> indegree = new HashMap<>();\\n      int res = 0;\\n      boolean hasCycle = false;\\n    public int largestPathValue(String colors, int[][] edges) {\\n        if (edges == null || edges.length == 0) {\\n\\t\\t\\treturn 1; // no edges, no path, so the max is 1 (assuming colors is not null)\\n        }\\n        int n = colors.length(); // node numbered [0, n-1]\\n        int m = edges.length;\\n\\n        // init\\n        for (int[] edge : edges) {\\n            int start = edge[0];\\n            int end = edge[1];\\n\\n            List<Integer> lists = graph.getOrDefault(end, new ArrayList<>());\\n            graph.put(end, lists);\\n            lists = graph.getOrDefault(start, new ArrayList<>());\\n            lists.add(end);\\n            graph.put(start, lists);\\n\\n            int ind = indegree.getOrDefault(start, 0);\\n            indegree.put(start, ind);\\n            ind = indegree.getOrDefault(end, 0);\\n            ind++;\\n            indegree.put(end, ind);\\n        }\\n\\n        // dp init\\n        // dp[x][y] from the start node to node `x`, the max value of color `y`\\n        int[][] dp = new int[n][26];\\n        toposort(colors, graph, indegree, dp);\\n\\n        if (hasCycle) {\\n            return -1;\\n        }\\n\\n        return res;\\n    }\\n\\n    private void toposort(String colors, Map<Integer, List<Integer>> graph, Map<Integer, Integer> indegree, int[][] dp) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        List<Integer> path = new ArrayList<>();\\n\\n        for (Map.Entry<Integer, Integer> entry: indegree.entrySet()) {\\n            if (entry.getValue() == 0) {\\n                int node = entry.getKey();\\n                queue.add(node);\\n                // init dp\\n                int color = colors.charAt(node) - \\'a\\';\\n                dp[node][color] = 1;\\n            }\\n        }\\n\\n        while(!queue.isEmpty()) {\\n            Integer curr = queue.peek(); queue.poll();\\n            List<Integer> neighbours = graph.getOrDefault(curr, new ArrayList<>());\\n            for (Integer nb : neighbours) {\\n                for (int i = 0; i < 26; i++) {\\n                    // the way to update dp[][] is\\n                    // if current node color equal to i, then it is the max of my current dp[nb][i] and dp[my prev][i] + 1\\n                    // if current node color not equal to i, I still need to get the max of my current dp[nb][i] and dp[my prev][i]\\n                    // b/c my current value can be updated from other path, and got a better path size, but not from my current previous node\\n                    dp[nb][i] = colors.charAt(nb) - \\'a\\' == i ? Math.max(dp[nb][i], dp[curr][i] + 1) : Math.max(dp[nb][i], dp[curr][i]);\\n                    res = Math.max(res, dp[nb][i]);\\n                }\\n\\n                // decrease indegree\\n                int ind = indegree.getOrDefault(nb, 0);\\n                ind--;\\n                indegree.put(nb, ind);\\n                if (ind == 0) {\\n                    queue.add(nb);\\n                }\\n            }\\n\\n            path.add(curr);\\n        }\\n\\n        if (path.size() != colors.length()) {\\n            hasCycle = true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n\\n      Map<Integer, List<Integer>> graph = new HashMap<>();\\n      Map<Integer, Integer> indegree = new HashMap<>();\\n      int res = 0;\\n      boolean hasCycle = false;\\n    public int largestPathValue(String colors, int[][] edges) {\\n        if (edges == null || edges.length == 0) {\\n\\t\\t\\treturn 1; // no edges, no path, so the max is 1 (assuming colors is not null)\\n        }\\n        int n = colors.length(); // node numbered [0, n-1]\\n        int m = edges.length;\\n\\n        // init\\n        for (int[] edge : edges) {\\n            int start = edge[0];\\n            int end = edge[1];\\n\\n            List<Integer> lists = graph.getOrDefault(end, new ArrayList<>());\\n            graph.put(end, lists);\\n            lists = graph.getOrDefault(start, new ArrayList<>());\\n            lists.add(end);\\n            graph.put(start, lists);\\n\\n            int ind = indegree.getOrDefault(start, 0);\\n            indegree.put(start, ind);\\n            ind = indegree.getOrDefault(end, 0);\\n            ind++;\\n            indegree.put(end, ind);\\n        }\\n\\n        // dp init\\n        // dp[x][y] from the start node to node `x`, the max value of color `y`\\n        int[][] dp = new int[n][26];\\n        toposort(colors, graph, indegree, dp);\\n\\n        if (hasCycle) {\\n            return -1;\\n        }\\n\\n        return res;\\n    }\\n\\n    private void toposort(String colors, Map<Integer, List<Integer>> graph, Map<Integer, Integer> indegree, int[][] dp) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        List<Integer> path = new ArrayList<>();\\n\\n        for (Map.Entry<Integer, Integer> entry: indegree.entrySet()) {\\n            if (entry.getValue() == 0) {\\n                int node = entry.getKey();\\n                queue.add(node);\\n                // init dp\\n                int color = colors.charAt(node) - \\'a\\';\\n                dp[node][color] = 1;\\n            }\\n        }\\n\\n        while(!queue.isEmpty()) {\\n            Integer curr = queue.peek(); queue.poll();\\n            List<Integer> neighbours = graph.getOrDefault(curr, new ArrayList<>());\\n            for (Integer nb : neighbours) {\\n                for (int i = 0; i < 26; i++) {\\n                    // the way to update dp[][] is\\n                    // if current node color equal to i, then it is the max of my current dp[nb][i] and dp[my prev][i] + 1\\n                    // if current node color not equal to i, I still need to get the max of my current dp[nb][i] and dp[my prev][i]\\n                    // b/c my current value can be updated from other path, and got a better path size, but not from my current previous node\\n                    dp[nb][i] = colors.charAt(nb) - \\'a\\' == i ? Math.max(dp[nb][i], dp[curr][i] + 1) : Math.max(dp[nb][i], dp[curr][i]);\\n                    res = Math.max(res, dp[nb][i]);\\n                }\\n\\n                // decrease indegree\\n                int ind = indegree.getOrDefault(nb, 0);\\n                ind--;\\n                indegree.put(nb, ind);\\n                if (ind == 0) {\\n                    queue.add(nb);\\n                }\\n            }\\n\\n            path.add(curr);\\n        }\\n\\n        if (path.size() != colors.length()) {\\n            hasCycle = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198864,
                "title": "python-straighforward-dfs",
                "content": "Follow the flow of logic:\\n1. Build the graph\\n2. Detect loop\\n3. Find \"good nodes\" to start <- for a path to be optimal, there is no reason to start from any node that is not a \"head node\" or indegree = 0 node.\\n4. Explore the each possible start nodes and apply DFS, use memorization to save time complexity.\\n\\n```\\nClass Solution:\\n    def sort(self, graph):\\n        n = len(graph)\\n        indegree = [0] * n\\n        for node in range(len(graph)):\\n            for child in graph[node]:\\n                indegree[child] += 1        \\n        heads = [i for i, val in enumerate(indegree) if val == 0]        \\n        queue = heads[:]\\n        order = []\\n\\t\\t\\n        while queue:\\n            node = queue.pop(0)\\n            order.append(node)\\n            for child in graph[node]:\\n                indegree[child] -= 1\\n                if indegree[child] == 0:\\n                    queue.append(child)\\n        \\n        if len(order) == n:\\n            return heads\\n        else:\\n            return None\\n        \\n    \\n    def getPathValue(self, graph, colors, start):\\n        color_set = set(colors)\\n        color_dict = {c: i for i, c in enumerate(color_set)}        \\n        cache = dict()\\n        \\n        def dfs(node):\\n            if node in cache:\\n                return cache[node]\\n            ans = [0] * len(color_set)\\n            this_color = colors[node]\\n            this_color_id = color_dict[this_color]\\n            \\n            for child in graph[node]:\\n                for i, n in enumerate(dfs(child)):\\n                    ans[i] = max(n, ans[i])                \\n            \\n            ans[this_color_id] += 1\\n            cache[node] = tuple(ans)\\n            return ans\\n        \\n        res = dfs(start)\\n        return max(res)\\n    \\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        # build the graph\\n        n = len(colors)\\n        graph = [[] for _ in range(n)]\\n        for s, e in edges:\\n            graph[s].append(e)\\n        \\n        # topo sort the graph\\n        heads = self.sort(graph)\\n        # if has loop return -1\\n        if heads is None:\\n            return -1\\n                \\n        # max value will be one of the starting nodes\\n        colors = [c for c in colors]\\n        max_val = 0\\n        for head in heads:\\n            val = self.getPathValue(graph, colors, head)\\n            max_val = max(val, max_val)\\n        \\n        return max_val\\n```",
                "solutionTags": [],
                "code": "```\\nClass Solution:\\n    def sort(self, graph):\\n        n = len(graph)\\n        indegree = [0] * n\\n        for node in range(len(graph)):\\n            for child in graph[node]:\\n                indegree[child] += 1        \\n        heads = [i for i, val in enumerate(indegree) if val == 0]        \\n        queue = heads[:]\\n        order = []\\n\\t\\t\\n        while queue:\\n            node = queue.pop(0)\\n            order.append(node)\\n            for child in graph[node]:\\n                indegree[child] -= 1\\n                if indegree[child] == 0:\\n                    queue.append(child)\\n        \\n        if len(order) == n:\\n            return heads\\n        else:\\n            return None\\n        \\n    \\n    def getPathValue(self, graph, colors, start):\\n        color_set = set(colors)\\n        color_dict = {c: i for i, c in enumerate(color_set)}        \\n        cache = dict()\\n        \\n        def dfs(node):\\n            if node in cache:\\n                return cache[node]\\n            ans = [0] * len(color_set)\\n            this_color = colors[node]\\n            this_color_id = color_dict[this_color]\\n            \\n            for child in graph[node]:\\n                for i, n in enumerate(dfs(child)):\\n                    ans[i] = max(n, ans[i])                \\n            \\n            ans[this_color_id] += 1\\n            cache[node] = tuple(ans)\\n            return ans\\n        \\n        res = dfs(start)\\n        return max(res)\\n    \\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        # build the graph\\n        n = len(colors)\\n        graph = [[] for _ in range(n)]\\n        for s, e in edges:\\n            graph[s].append(e)\\n        \\n        # topo sort the graph\\n        heads = self.sort(graph)\\n        # if has loop return -1\\n        if heads is None:\\n            return -1\\n                \\n        # max value will be one of the starting nodes\\n        colors = [c for c in colors]\\n        max_val = 0\\n        for head in heads:\\n            val = self.getPathValue(graph, colors, head)\\n            max_val = max(val, max_val)\\n        \\n        return max_val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1198794,
                "title": "c-dfs-memorization",
                "content": "I ran 2 dfs one to detect cycle and other one to get the answer.  `isCycle` is standard dfs cycle detection code while second DFS is standard dfs. In second DFS i used memorization to speed up the calcuations.  We are storing an array of size 26 for each node. This array contains maximum  color count you will see when path is starting from this node. This is my constest code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>ADJ[100010], memo[100010];\\n    vector<int>visited;\\n    string C;\\n    bool isCycle(int node) {\\n        if (visited[node]) return true;\\n        visited[node] = 1;\\n        for (int next_node : ADJ[node]) if (visited[next_node] == 0 && isCycle(next_node)) return true;\\n        else if (visited[next_node] == 1) return true;\\n        visited[node] = 2;\\n        return false;\\n    }\\n    vector<int> dfs(int node) {\\n        if (memo[node].size() > 0) return memo[node];\\n        visited[node] = true;\\n        int color = C[node] - \\'a\\';\\n        vector<int>ret(26, 0);\\n        ret[color] = 1;\\n        for (int next_node : ADJ[node]) {\\n            vector<int>f = dfs(next_node);\\n            f[color]++;\\n            for (int i = 0; i < 26; i++) ret[i] = max(ret[i], f[i]);\\n        }\\n        return memo[node] = ret;\\n    }\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        C = colors;\\n        int n = colors.size();\\n        visited = vector<int>(n, 0);\\n        for (vector<int> edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            ADJ[u].push_back(v);\\n        }\\n        for (int i = 0 ; i < n; i++) if (!visited[i]) if (isCycle(i)) return -1;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) if (memo[i].size() ==0) {\\n            dfs(i);\\n            for (int j = 0; j < 26; j++) ans = max(memo[i][j], ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ADJ[100010], memo[100010];\\n    vector<int>visited;\\n    string C;\\n    bool isCycle(int node) {\\n        if (visited[node]) return true;\\n        visited[node] = 1;\\n        for (int next_node : ADJ[node]) if (visited[next_node] == 0 && isCycle(next_node)) return true;\\n        else if (visited[next_node] == 1) return true;\\n        visited[node] = 2;\\n        return false;\\n    }\\n    vector<int> dfs(int node) {\\n        if (memo[node].size() > 0) return memo[node];\\n        visited[node] = true;\\n        int color = C[node] - \\'a\\';\\n        vector<int>ret(26, 0);\\n        ret[color] = 1;\\n        for (int next_node : ADJ[node]) {\\n            vector<int>f = dfs(next_node);\\n            f[color]++;\\n            for (int i = 0; i < 26; i++) ret[i] = max(ret[i], f[i]);\\n        }\\n        return memo[node] = ret;\\n    }\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        C = colors;\\n        int n = colors.size();\\n        visited = vector<int>(n, 0);\\n        for (vector<int> edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            ADJ[u].push_back(v);\\n        }\\n        for (int i = 0 ; i < n; i++) if (!visited[i]) if (isCycle(i)) return -1;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) if (memo[i].size() ==0) {\\n            dfs(i);\\n            for (int j = 0; j < 26; j++) ans = max(memo[i][j], ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198772,
                "title": "python-easy-dp-solution-with-comments-beats-100",
                "content": "Without comments:\\n\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        starts = set([i for i in range(len(colors))])\\n        \\n        for edge in edges:\\n            graph[edge[0]].add(edge[1])\\n            starts.discard(edge[1])\\n                \\n        color_mappings = {}\\n        all_nodes_visited = set()\\n        \\n        def max_val(a, b):\\n            if a is None:\\n                return b\\n            if b is None:\\n                return a\\n            return max(a, b)\\n        \\n        def helper(ancestors, current_node):\\n            if current_node in ancestors:\\n                return None\\n            if current_node in color_mappings:\\n                return color_mappings[current_node]\\n            \\n            ancestors.add(current_node)\\n            all_nodes_visited.add(current_node)\\n            \\n            color_mapping = defaultdict(int)\\n            for child in graph[current_node]:\\n                child_color_mapping = helper(ancestors, child)\\n                if child_color_mapping is None:\\n                    return None\\n                \\n                all_keys = color_mapping.keys() | child_color_mapping.keys()\\n                for key in all_keys:\\n                    color_mapping[key] = max_val(color_mapping[key], child_color_mapping[key])\\n            \\n            ancestors.remove(current_node)\\n            color_mapping[colors[current_node]] += 1\\n            color_mappings[current_node] = color_mapping\\n            \\n            return color_mapping\\n        \\n        best_freq = -1\\n        \\n        for point in starts:\\n            color_mapping = helper(set(), point)\\n            if color_mapping is None:\\n                return -1\\n                \\n            best_freq = max(best_freq, max(color_mapping.values()))\\n        \\n        if len(all_nodes_visited) < len(colors):\\n            return -1\\n        \\n        return best_freq\\n```\\n\\nWith comments:\\n\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        # Potential start points, no edges being directed towards them.\\n        starts = set([i for i in range(len(colors))])\\n        \\n        for edge in edges:\\n            graph[edge[0]].add(edge[1])\\n            starts.discard(edge[1])\\n                \\n        # color_mappings maps {current_node: int -> color_mapping: dict)\\n        # color_mapping is a dictionary of {color: string -> max_freq: int}.\\n        #\\n        # Essentially, each entry in color_mappings represents the max frequency of each color\\n        # that can be obtained starting from current and traversing through the rest of the graph.\\n        #\\n        # This way, we avoid needing to perform redundant calculations on a per-node basis.\\n        color_mappings = {}\\n        # We use this set for additional cycle detection - if we finish traversing through each of\\n        # the start points, but we didn\\'t visit all of the nodes, then that means we have \\n        # a circular reference cycle. \\n        all_nodes_visited = set()\\n        \\n        # Helper function for getting the max val for a key from two dicts.\\n        def max_val(a, b):\\n            if a is None:\\n                return b\\n            if b is None:\\n                return a\\n            return max(a, b)\\n        \\n        # We are performing DP, and we use the ancestors set to help us detect cycles.\\n        # ancestors contains all the nodes that we\\'ve previously encountered (from the start point onwards)\\n        # to get us to this point. If we encounter the same node twice, then we have a cycle.\\n        # We add ourselves to ancestors as we inspect our children, and remove ourselves when we\\'re done.\\n        def helper(ancestors, current_node):\\n            if current_node in ancestors:\\n                # Cycle detected.\\n                return None\\n            if current_node in color_mappings:\\n                return color_mappings[current_node]\\n            \\n            ancestors.add(current_node)\\n            all_nodes_visited.add(current_node)\\n            \\n            color_mapping = defaultdict(int)\\n            # For each child, we keep the max frequency of color that can be obtained if we traverse\\n            # through them instead of another child.\\n            for child in graph[current_node]:\\n                child_color_mapping = helper(ancestors, child)\\n                # Cycle detected, emergency escape!\\n                if child_color_mapping is None:\\n                    return None\\n                \\n                # Basically, merging color_mapping and child_color_mapping, keeping the largest value for each key.\\n                all_keys = color_mapping.keys() | child_color_mapping.keys()\\n                for key in all_keys:\\n                    color_mapping[key] = max_val(color_mapping[key], child_color_mapping[key])\\n            \\n            ancestors.remove(current_node)\\n            # We need to account for the color of the current node.\\n            color_mapping[colors[current_node]] += 1\\n            color_mappings[current_node] = color_mapping\\n            \\n            return color_mapping\\n        \\n        best_freq = -1\\n        \\n        # We iterate through the potential start points, keeping track of the \\n        # max freq of any color that can be reached from this start point.\\n        for point in starts:\\n            color_mapping = helper(set(), point)\\n            if color_mapping is None:\\n                return -1\\n                \\n            best_freq = max(best_freq, max(color_mapping.values()))\\n        \\n        if len(all_nodes_visited) < len(colors):\\n            return -1\\n        \\n        return best_freq\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        starts = set([i for i in range(len(colors))])\\n        \\n        for edge in edges:\\n            graph[edge[0]].add(edge[1])\\n            starts.discard(edge[1])\\n                \\n        color_mappings = {}\\n        all_nodes_visited = set()\\n        \\n        def max_val(a, b):\\n            if a is None:\\n                return b\\n            if b is None:\\n                return a\\n            return max(a, b)\\n        \\n        def helper(ancestors, current_node):\\n            if current_node in ancestors:\\n                return None\\n            if current_node in color_mappings:\\n                return color_mappings[current_node]\\n            \\n            ancestors.add(current_node)\\n            all_nodes_visited.add(current_node)\\n            \\n            color_mapping = defaultdict(int)\\n            for child in graph[current_node]:\\n                child_color_mapping = helper(ancestors, child)\\n                if child_color_mapping is None:\\n                    return None\\n                \\n                all_keys = color_mapping.keys() | child_color_mapping.keys()\\n                for key in all_keys:\\n                    color_mapping[key] = max_val(color_mapping[key], child_color_mapping[key])\\n            \\n            ancestors.remove(current_node)\\n            color_mapping[colors[current_node]] += 1\\n            color_mappings[current_node] = color_mapping\\n            \\n            return color_mapping\\n        \\n        best_freq = -1\\n        \\n        for point in starts:\\n            color_mapping = helper(set(), point)\\n            if color_mapping is None:\\n                return -1\\n                \\n            best_freq = max(best_freq, max(color_mapping.values()))\\n        \\n        if len(all_nodes_visited) < len(colors):\\n            return -1\\n        \\n        return best_freq\\n```\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        # Potential start points, no edges being directed towards them.\\n        starts = set([i for i in range(len(colors))])\\n        \\n        for edge in edges:\\n            graph[edge[0]].add(edge[1])\\n            starts.discard(edge[1])\\n                \\n        # color_mappings maps {current_node: int -> color_mapping: dict)\\n        # color_mapping is a dictionary of {color: string -> max_freq: int}.\\n        #\\n        # Essentially, each entry in color_mappings represents the max frequency of each color\\n        # that can be obtained starting from current and traversing through the rest of the graph.\\n        #\\n        # This way, we avoid needing to perform redundant calculations on a per-node basis.\\n        color_mappings = {}\\n        # We use this set for additional cycle detection - if we finish traversing through each of\\n        # the start points, but we didn\\'t visit all of the nodes, then that means we have \\n        # a circular reference cycle. \\n        all_nodes_visited = set()\\n        \\n        # Helper function for getting the max val for a key from two dicts.\\n        def max_val(a, b):\\n            if a is None:\\n                return b\\n            if b is None:\\n                return a\\n            return max(a, b)\\n        \\n        # We are performing DP, and we use the ancestors set to help us detect cycles.\\n        # ancestors contains all the nodes that we\\'ve previously encountered (from the start point onwards)\\n        # to get us to this point. If we encounter the same node twice, then we have a cycle.\\n        # We add ourselves to ancestors as we inspect our children, and remove ourselves when we\\'re done.\\n        def helper(ancestors, current_node):\\n            if current_node in ancestors:\\n                # Cycle detected.\\n                return None\\n            if current_node in color_mappings:\\n                return color_mappings[current_node]\\n            \\n            ancestors.add(current_node)\\n            all_nodes_visited.add(current_node)\\n            \\n            color_mapping = defaultdict(int)\\n            # For each child, we keep the max frequency of color that can be obtained if we traverse\\n            # through them instead of another child.\\n            for child in graph[current_node]:\\n                child_color_mapping = helper(ancestors, child)\\n                # Cycle detected, emergency escape!\\n                if child_color_mapping is None:\\n                    return None\\n                \\n                # Basically, merging color_mapping and child_color_mapping, keeping the largest value for each key.\\n                all_keys = color_mapping.keys() | child_color_mapping.keys()\\n                for key in all_keys:\\n                    color_mapping[key] = max_val(color_mapping[key], child_color_mapping[key])\\n            \\n            ancestors.remove(current_node)\\n            # We need to account for the color of the current node.\\n            color_mapping[colors[current_node]] += 1\\n            color_mappings[current_node] = color_mapping\\n            \\n            return color_mapping\\n        \\n        best_freq = -1\\n        \\n        # We iterate through the potential start points, keeping track of the \\n        # max freq of any color that can be reached from this start point.\\n        for point in starts:\\n            color_mapping = helper(set(), point)\\n            if color_mapping is None:\\n                return -1\\n                \\n            best_freq = max(best_freq, max(color_mapping.values()))\\n        \\n        if len(all_nodes_visited) < len(colors):\\n            return -1\\n        \\n        return best_freq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198737,
                "title": "c-dp-dfs-solution",
                "content": "Steps :\\n1. Detect cycle in a directed graph, if any cycle found return -1;\\n2. Since there are only 26 colours, assume at one node keeping a state as the maximum frequency of each color in all of current node\\'s children, including this node as well. The state stored at one node is hence an array of 26(colors) elements. Return this state as result of dfs.\\n3. Finally count the maximum frequency of colors at each node assuming the node as the starting point of the path.\\n\\n``` \\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& B) {\\n     \\n        \\n        int A = colors.size();\\n        vector<int> gr[A];\\n        \\n        for(int i=0;i<B.size();i++)\\n        {\\n            int src = B[i][0];\\n            int dest = B[i][1];\\n            gr[src].push_back(dest);\\n\\n        }\\n        \\n        vector<bool> visited(A, false);\\n    \\n        bool ans = false;\\n\\n        set<int> seti;\\n        for(int i=0;i<A;i++)\\n        {\\n            if(visited[i]==false)\\n                ans |= getans(i, gr, visited, seti);\\n        }\\n        if(ans)\\n            return -1;\\n        \\n                \\n        vector<vector<int> > ct(colors.length(), vector<int> (26, 0));\\n        visited.assign(A, false);\\n        \\n        for(int i=0;i<A;i++)\\n        {\\n            if(visited[i])\\n                continue;\\n            getdfs(i, gr, ct, colors, visited);\\n        }\\n        \\n        \\n        int ansf = 0;\\n        \\n        for(int i=0;i<A;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n                ansf = max(ansf, ct[i][j]);\\n                \\n        }\\n        return ansf;\\n    }\\n    \\n    vector<int> getdfs(int curr, vector<int> gr[], vector<vector<int> >&ct, string &colors, vector<bool> &visited)\\n    {\\n        if(visited[curr])\\n        {\\n            return ct[curr];\\n        }\\n        \\n        for(int i=0;i<gr[curr].size();i++)\\n        {\\n            vector<int> last = getdfs(gr[curr][i], gr, ct, colors, visited);\\n            for(int j=0;j<26;j++)\\n                ct[curr][j] = max(ct[curr][j], last[j]);\\n            \\n        }\\n        ct[curr][colors[curr]-\\'a\\']++;\\n        visited[curr] = true;\\n        \\n        return ct[curr];\\n        \\n    }\\n    \\n    bool getans(int curr, vector<int> gr[], vector<bool> &visited, set<int> &seti)\\n    {\\n        if(seti.find(curr)!=seti.end())\\n            return true;\\n\\n        if(visited[curr])\\n            return false;\\n\\n        visited[curr] = true;\\n        seti.insert(curr);\\n        bool ans = false;\\n\\n        for(int i = 0;i<gr[curr].size();i++)\\n            ans|=getans(gr[curr][i], gr, visited, seti);\\n\\n        seti.erase(curr);\\n        return ans;\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& B) {\\n     \\n        \\n        int A = colors.size();\\n        vector<int> gr[A];\\n        \\n        for(int i=0;i<B.size();i++)\\n        {\\n            int src = B[i][0];\\n            int dest = B[i][1];\\n            gr[src].push_back(dest);\\n\\n        }\\n        \\n        vector<bool> visited(A, false);\\n    \\n        bool ans = false;\\n\\n        set<int> seti;\\n        for(int i=0;i<A;i++)\\n        {\\n            if(visited[i]==false)\\n                ans |= getans(i, gr, visited, seti);\\n        }\\n        if(ans)\\n            return -1;\\n        \\n                \\n        vector<vector<int> > ct(colors.length(), vector<int> (26, 0));\\n        visited.assign(A, false);\\n        \\n        for(int i=0;i<A;i++)\\n        {\\n            if(visited[i])\\n                continue;\\n            getdfs(i, gr, ct, colors, visited);\\n        }\\n        \\n        \\n        int ansf = 0;\\n        \\n        for(int i=0;i<A;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n                ansf = max(ansf, ct[i][j]);\\n                \\n        }\\n        return ansf;\\n    }\\n    \\n    vector<int> getdfs(int curr, vector<int> gr[], vector<vector<int> >&ct, string &colors, vector<bool> &visited)\\n    {\\n        if(visited[curr])\\n        {\\n            return ct[curr];\\n        }\\n        \\n        for(int i=0;i<gr[curr].size();i++)\\n        {\\n            vector<int> last = getdfs(gr[curr][i], gr, ct, colors, visited);\\n            for(int j=0;j<26;j++)\\n                ct[curr][j] = max(ct[curr][j], last[j]);\\n            \\n        }\\n        ct[curr][colors[curr]-\\'a\\']++;\\n        visited[curr] = true;\\n        \\n        return ct[curr];\\n        \\n    }\\n    \\n    bool getans(int curr, vector<int> gr[], vector<bool> &visited, set<int> &seti)\\n    {\\n        if(seti.find(curr)!=seti.end())\\n            return true;\\n\\n        if(visited[curr])\\n            return false;\\n\\n        visited[curr] = true;\\n        seti.insert(curr);\\n        bool ans = false;\\n\\n        for(int i = 0;i<gr[curr].size();i++)\\n            ans|=getans(gr[curr][i], gr, visited, seti);\\n\\n        seti.erase(curr);\\n        return ans;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013900,
                "title": "dfs-w-memo-topological-sort-explanation",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\nWe want to visit all possible paths, however there is repeat work\\r\\n\\r\\n![Screenshot 2023-09-07 at 15.07.45.png](https://assets.leetcode.com/users/images/9cbb39d8-ee72-4c2e-ad62-9480d58a6f33_1694084881.7756531.png)\\r\\n\\r\\n\\r\\nFor example, in the above graph there are 2 different paths that land us on node `3`, and if we follow both of them from `3` to `4` we\\'d be covering those subpaths twice. This suggests that we should keep track of which nodes we already have visited and not visit them again.\\r\\n\\r\\nWe can cache the results for each node like\\r\\n\\r\\n`dp = {\"<node>\": {\"<color1>\": 4, \"<color2>\": 3, ....  }`,\\r\\n\\r\\n e.g.\\r\\n\\r\\n`dp = {0: {\"a\": 2, \"c\": 1}, 1: {\"a\": 3, \"z\": 2}, ...}`\\r\\n\\r\\nwhich tells us that starting from node `1`, and over all possible paths from it,  we at most counted 3 \"a\" on a given path, 2 \"z\" etc\\r\\n\\r\\nTo build up this cache we use DFS, plunging down to leaf nodes first (no neighbours), such as node `4` in the diagram above. This will set \\r\\n`dp[4][\"a\"]=1` for example (if \"a\" is its color). \\r\\n\\r\\nWe then pop back up in the recursion to node `3` and can initialize `dp[3][\"a\"]=1\" (if \"a\" is color of `3` too). For every color of our neighbours paths, we can then update this nodes\\' max paths using the maxes from the neighbor that we already computed before popping up.\\r\\n\\r\\nIf the color is the same as this current node we must add 1, else we just take the neigbour max.\\r\\n\\r\\n**Cycles**\\r\\n\\r\\nThe additional thing is we need a `path` set that keeps track of all nodes in the current path...if we ever get to a node already in the path, then we know for sure the graph has a cycle and we need to abort. In this code we raise an exception to call the rest of the search off and return `-1`\\r\\n\\r\\n**Topological sort**\\r\\n\\r\\nThis is actually the same kind of DFS one runs during a topological sort such as when finding prerequisites based course ordering. \\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass CycleDetectedException(Exception):\\r\\n    pass\\r\\n\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        # adj rep of graph\\r\\n        n = len(colors)\\r\\n        g = {}\\r\\n        for i in range(n):\\r\\n            g[i] = []\\r\\n        for src, dst in edges:\\r\\n            g[src].append(dst)\\r\\n\\r\\n        # Path tracks cycles, visit to avoid repeat work\\r\\n        path, visit = set(), set()\\r\\n\\r\\n        # For each node store the max count of each color\\r\\n        # over all possible paths from it. Remember this is a DAG\\r\\n        # {0: {\"a\": 2, \"b\": 3, \"z\": 1}, ....}\\r\\n        # This is our cache to avoid repeat work\\r\\n        dp = {i: defaultdict(int) for i in range(n)}\\r\\n\\r\\n        def dfs(i):\\r\\n            # Given path has generated a cycle\\r\\n            if i in path:\\r\\n                raise CycleDetectedException\\r\\n\\r\\n            # Don\\'t repeat work if already been through this node\\r\\n            if i in visit:\\r\\n                return 0\\r\\n\\r\\n            dp[i][colors[i]] = 1\\r\\n\\r\\n            path.add(i)\\r\\n            for nei in g[i]:\\r\\n                dfs(nei)\\r\\n                for c in dp[nei]:\\r\\n                    neiCount = 1 + dp[nei][c] if c==colors[i] else dp[nei][c]\\r\\n                    dp[i][c] = max(dp[i][c], neiCount)\\r\\n            path.remove(i)\\r\\n            visit.add(i)\\r\\n\\r\\n        # Try paths starting from each node\\r\\n        res = 0\\r\\n        for i in range(len(colors)):\\r\\n            try:\\r\\n                dfs(i)\\r\\n                res = max(res, max(dp[i].values()))\\r\\n            except CycleDetectedException:\\r\\n                return -1\\r\\n\\r\\n        return res\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass CycleDetectedException(Exception):\\r\\n    pass\\r\\n\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        # adj rep of graph\\r\\n        n = len(colors)\\r\\n        g = {}\\r\\n        for i in range(n):\\r\\n            g[i] = []\\r\\n        for src, dst in edges:\\r\\n            g[src].append(dst)\\r\\n\\r\\n        # Path tracks cycles, visit to avoid repeat work\\r\\n        path, visit = set(), set()\\r\\n\\r\\n        # For each node store the max count of each color\\r\\n        # over all possible paths from it. Remember this is a DAG\\r\\n        # {0: {\"a\": 2, \"b\": 3, \"z\": 1}, ....}\\r\\n        # This is our cache to avoid repeat work\\r\\n        dp = {i: defaultdict(int) for i in range(n)}\\r\\n\\r\\n        def dfs(i):\\r\\n            # Given path has generated a cycle\\r\\n            if i in path:\\r\\n                raise CycleDetectedException\\r\\n\\r\\n            # Don\\'t repeat work if already been through this node\\r\\n            if i in visit:\\r\\n                return 0\\r\\n\\r\\n            dp[i][colors[i]] = 1\\r\\n\\r\\n            path.add(i)\\r\\n            for nei in g[i]:\\r\\n                dfs(nei)\\r\\n                for c in dp[nei]:\\r\\n                    neiCount = 1 + dp[nei][c] if c==colors[i] else dp[nei][c]\\r\\n                    dp[i][c] = max(dp[i][c], neiCount)\\r\\n            path.remove(i)\\r\\n            visit.add(i)\\r\\n\\r\\n        # Try paths starting from each node\\r\\n        res = 0\\r\\n        for i in range(len(colors)):\\r\\n            try:\\r\\n                dfs(i)\\r\\n                res = max(res, max(dp[i].values()))\\r\\n            except CycleDetectedException:\\r\\n                return -1\\r\\n\\r\\n        return res\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407012,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "First of all, Let me introduce my YouTube channel.\\r\\n\\r\\n# My youtube channel - KeetCode(Ex-Amazon)\\r\\n\\r\\nI create 142 videos for leetcode questions as of April 10, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\r\\n\\r\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\r\\n\\r\\n**I created a video for this question. I believe you can understand easily with visualization.** \\r\\n\\r\\n**Largest Color Value in a Directed Graph video**\\r\\nhttps://qr.paps.jp/AUBZ8\\r\\n\\r\\n**My youtube channel - KeetCode(Ex-Amazon)**\\r\\nhttps://qr.paps.jp/q2r7Z\\r\\n\\r\\n![FotoJet (46).jpg](https://assets.leetcode.com/users/images/0db0edf1-68b5-472f-bd01-442d728c4bc8_1681092433.2711854.jpeg)\\r\\n\\r\\n---\\r\\n\\r\\n# Intuition\\r\\nI solve this question with BFS and 2D dynamic programming. the reason why I use 2D dynamic programming is that we need to keep track of two data. One is current location and the other is how many colors we have so far when we are at some point.\\r\\n\\r\\n# Approach\\r\\n1. Create an empty graph using defaultdict with lists as the default value to represent edges.\\r\\n\\r\\n2. Create an array called indegree to keep track of the number of incoming edges for each vertex. Initialize each value to 0.\\r\\n\\r\\n1. Iterate over each edge in the input edges list. If an edge has the same source and destination, return -1. Add the destination vertex to the list of edges for the source vertex in the graph dictionary. Increment the indegree of the destination vertex.\\r\\n\\r\\n1. Create a queue called q and add all the vertices with 0 incoming edges (indegree) to the queue.\\r\\n\\r\\n1. Create a 2D array called dp with dimensions (number of vertices x 26) to keep track of the largest color value for each color at each vertex. Initialize each value to 0.\\r\\n\\r\\n1. Initialize a variable called max_color to 0 to keep track of the largest color value found so far.\\r\\n\\r\\n1. While the queue is not empty, remove the vertex at the front of the queue and process it.\\r\\n\\r\\n1. Get the color of the vertex from the input colors string by subtracting \\'a\\' from the ASCII code of the character at that index. Increment the value at dp[vertex][color] by 1.\\r\\n\\r\\n1. Update max_color to be the maximum value of dp[vertex][color] and max_color.\\r\\n\\r\\n1. For each neighbor (nei) of the current vertex, decrement its indegree by 1. For each color (c), update dp[nei][c] to be the maximum of its current value and dp[vertex][c].\\r\\n\\r\\n1. If the indegree of the neighbor becomes 0, add it to the queue.\\r\\n\\r\\n1. If any vertex has a non-zero indegree, return -1.\\r\\n\\r\\n1. Return the value of max_color.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(V + E)\\r\\nV is the number of vertex (colors) and E is the number of edges in the graph. This is because we traverse the graph using BFS, visiting each node and each edge only once.\\r\\n\\r\\n- Space complexity: O(VK + E)\\r\\nV is the number of vertex in the graph, K is the number of possible colors (26 in this case), and E is the number of edges in the graph. This is because we create a 2D dp array of size V*K to store the count of each color at each node, and an adjacency list to represent the edges of the graph, which takes up O(E) space.\\r\\n\\r\\n# Python\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        graph = defaultdict(list)\\r\\n        # indegree of vertex is the number of edges going to the vertex\\r\\n        indegree = [0] * len(colors)\\r\\n\\r\\n        for edge in edges:\\r\\n            if edge[0] == edge[1]:\\r\\n                return -1\\r\\n            graph[edge[0]].append(edge[1])\\r\\n            indegree[edge[1]] += 1\\r\\n        \\r\\n        q = deque([i for i in range(len(colors)) if indegree[i] == 0])\\r\\n        dp = [[0] * 26 for _ in range(len(colors))]\\r\\n        max_color = 0\\r\\n\\r\\n        while q:\\r\\n            vertex = q.popleft()\\r\\n            color = ord(colors[vertex]) - ord(\\'a\\')\\r\\n            dp[vertex][color] += 1\\r\\n            max_color = max(max_color, dp[vertex][color])\\r\\n\\r\\n            for nei in graph[vertex]:\\r\\n                indegree[nei] -= 1\\r\\n            \\r\\n                for c in range(26):\\r\\n                    dp[nei][c] = max(dp[nei][c], dp[vertex][c])\\r\\n                \\r\\n                if indegree[nei] == 0:\\r\\n                    q.append(nei)\\r\\n\\r\\n        if any(indegree):\\r\\n            return -1\\r\\n\\r\\n        return max_color        \\r\\n\\r\\n                    \\r\\n```\\r\\n# JavaScript\\r\\n```\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    const graph = new Map();\\r\\n    const indegree = new Array(colors.length).fill(0);\\r\\n\\r\\n    for (const [u, v] of edges) {\\r\\n        if (u === v) return -1;\\r\\n        graph.set(u, (graph.get(u) || []).concat(v));\\r\\n        indegree[v]++;\\r\\n    }\\r\\n\\r\\n    const q = [];\\r\\n    for (let i = 0; i < colors.length; i++) {\\r\\n        if (indegree[i] === 0) q.push(i);\\r\\n    }\\r\\n\\r\\n    const dp = Array.from({ length: colors.length }, () => Array(26).fill(0));\\r\\n    let maxColor = 0;\\r\\n\\r\\n    while (q.length) {\\r\\n        const vertex = q.shift();\\r\\n        const color = colors.charCodeAt(vertex) - 97;\\r\\n        dp[vertex][color]++;\\r\\n        maxColor = Math.max(maxColor, dp[vertex][color]);\\r\\n\\r\\n        if (!graph.has(vertex)) continue;\\r\\n\\r\\n        for (const nei of graph.get(vertex)) {\\r\\n            indegree[nei]--;\\r\\n\\r\\n            for (let c = 0; c < 26; c++) {\\r\\n                dp[nei][c] = Math.max(dp[nei][c], dp[vertex][c]);\\r\\n            }\\r\\n\\r\\n            if (indegree[nei] === 0) q.push(nei);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return indegree.some(x => x > 0) ? -1 : maxColor;    \\r\\n};\\r\\n```\\r\\n# Java\\r\\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\r\\n        int[] indegree = new int[colors.length()];\\r\\n\\r\\n        for (int[] edge : edges) {\\r\\n            if (edge[0] == edge[1]) {\\r\\n                return -1;\\r\\n            }\\r\\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\\r\\n            indegree[edge[1]]++;\\r\\n        }\\r\\n\\r\\n        Queue<Integer> q = new LinkedList<>();\\r\\n        for (int i = 0; i < colors.length(); i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.offer(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int[][] dp = new int[colors.length()][26];\\r\\n        int max_color = 0;\\r\\n\\r\\n        while (!q.isEmpty()) {\\r\\n            int vertex = q.poll();\\r\\n            int color = colors.charAt(vertex) - \\'a\\';\\r\\n            dp[vertex][color]++;\\r\\n            max_color = Math.max(max_color, dp[vertex][color]);\\r\\n\\r\\n            List<Integer> neighbors = graph.getOrDefault(vertex, new ArrayList<>());\\r\\n            for (int nei : neighbors) {\\r\\n                indegree[nei]--;\\r\\n                for (int c = 0; c < 26; c++) {\\r\\n                    dp[nei][c] = Math.max(dp[nei][c], dp[vertex][c]);\\r\\n                }\\r\\n                if (indegree[nei] == 0) {\\r\\n                    q.offer(nei);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < colors.length(); i++) {\\r\\n            if (indegree[i] > 0) {\\r\\n                return -1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return max_color;        \\r\\n    }\\r\\n}\\r\\n```\\r\\n# C++\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        unordered_map<int, vector<int>> graph;\\r\\n        int n = colors.size();\\r\\n        int indegree[n];\\r\\n        memset(indegree, 0, sizeof(indegree));\\r\\n\\r\\n        for (auto edge : edges) {\\r\\n            if (edge[0] == edge[1]) {\\r\\n                return -1;\\r\\n            }\\r\\n            graph[edge[0]].push_back(edge[1]);\\r\\n            indegree[edge[1]]++;\\r\\n        }\\r\\n\\r\\n        queue<int> q;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int dp[n][26];\\r\\n        memset(dp, 0, sizeof(dp));\\r\\n        int max_color = 0;\\r\\n\\r\\n        while (!q.empty()) {\\r\\n            int vertex = q.front();\\r\\n            q.pop();\\r\\n            int color = colors[vertex] - \\'a\\';\\r\\n            dp[vertex][color]++;\\r\\n            max_color = max(max_color, dp[vertex][color]);\\r\\n\\r\\n            for (auto nei : graph[vertex]) {\\r\\n                indegree[nei]--;\\r\\n                for (int c = 0; c < 26; c++) {\\r\\n                    dp[nei][c] = max(dp[nei][c], dp[vertex][c]);\\r\\n                }\\r\\n                if (indegree[nei] == 0) {\\r\\n                    q.push(nei);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] > 0) {\\r\\n                return -1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return max_color;        \\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        graph = defaultdict(list)\\r\\n        # indegree of vertex is the number of edges going to the vertex\\r\\n        indegree = [0] * len(colors)\\r\\n\\r\\n        for edge in edges:\\r\\n            if edge[0] == edge[1]:\\r\\n                return -1\\r\\n            graph[edge[0]].append(edge[1])\\r\\n            indegree[edge[1]] += 1\\r\\n        \\r\\n        q = deque([i for i in range(len(colors)) if indegree[i] == 0])\\r\\n        dp = [[0] * 26 for _ in range(len(colors))]\\r\\n        max_color = 0\\r\\n\\r\\n        while q:\\r\\n            vertex = q.popleft()\\r\\n            color = ord(colors[vertex]) - ord(\\'a\\')\\r\\n            dp[vertex][color] += 1\\r\\n            max_color = max(max_color, dp[vertex][color])\\r\\n\\r\\n            for nei in graph[vertex]:\\r\\n                indegree[nei] -= 1\\r\\n            \\r\\n                for c in range(26):\\r\\n                    dp[nei][c] = max(dp[nei][c], dp[vertex][c])\\r\\n                \\r\\n                if indegree[nei] == 0:\\r\\n                    q.append(nei)\\r\\n\\r\\n        if any(indegree):\\r\\n            return -1\\r\\n\\r\\n        return max_color        \\r\\n\\r\\n                    \\r\\n```\n```\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    const graph = new Map();\\r\\n    const indegree = new Array(colors.length).fill(0);\\r\\n\\r\\n    for (const [u, v] of edges) {\\r\\n        if (u === v) return -1;\\r\\n        graph.set(u, (graph.get(u) || []).concat(v));\\r\\n        indegree[v]++;\\r\\n    }\\r\\n\\r\\n    const q = [];\\r\\n    for (let i = 0; i < colors.length; i++) {\\r\\n        if (indegree[i] === 0) q.push(i);\\r\\n    }\\r\\n\\r\\n    const dp = Array.from({ length: colors.length }, () => Array(26).fill(0));\\r\\n    let maxColor = 0;\\r\\n\\r\\n    while (q.length) {\\r\\n        const vertex = q.shift();\\r\\n        const color = colors.charCodeAt(vertex) - 97;\\r\\n        dp[vertex][color]++;\\r\\n        maxColor = Math.max(maxColor, dp[vertex][color]);\\r\\n\\r\\n        if (!graph.has(vertex)) continue;\\r\\n\\r\\n        for (const nei of graph.get(vertex)) {\\r\\n            indegree[nei]--;\\r\\n\\r\\n            for (let c = 0; c < 26; c++) {\\r\\n                dp[nei][c] = Math.max(dp[nei][c], dp[vertex][c]);\\r\\n            }\\r\\n\\r\\n            if (indegree[nei] === 0) q.push(nei);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return indegree.some(x => x > 0) ? -1 : maxColor;    \\r\\n};\\r\\n```\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\r\\n        int[] indegree = new int[colors.length()];\\r\\n\\r\\n        for (int[] edge : edges) {\\r\\n            if (edge[0] == edge[1]) {\\r\\n                return -1;\\r\\n            }\\r\\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\\r\\n            indegree[edge[1]]++;\\r\\n        }\\r\\n\\r\\n        Queue<Integer> q = new LinkedList<>();\\r\\n        for (int i = 0; i < colors.length(); i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.offer(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int[][] dp = new int[colors.length()][26];\\r\\n        int max_color = 0;\\r\\n\\r\\n        while (!q.isEmpty()) {\\r\\n            int vertex = q.poll();\\r\\n            int color = colors.charAt(vertex) - \\'a\\';\\r\\n            dp[vertex][color]++;\\r\\n            max_color = Math.max(max_color, dp[vertex][color]);\\r\\n\\r\\n            List<Integer> neighbors = graph.getOrDefault(vertex, new ArrayList<>());\\r\\n            for (int nei : neighbors) {\\r\\n                indegree[nei]--;\\r\\n                for (int c = 0; c < 26; c++) {\\r\\n                    dp[nei][c] = Math.max(dp[nei][c], dp[vertex][c]);\\r\\n                }\\r\\n                if (indegree[nei] == 0) {\\r\\n                    q.offer(nei);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < colors.length(); i++) {\\r\\n            if (indegree[i] > 0) {\\r\\n                return -1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return max_color;        \\r\\n    }\\r\\n}\\r\\n```\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        unordered_map<int, vector<int>> graph;\\r\\n        int n = colors.size();\\r\\n        int indegree[n];\\r\\n        memset(indegree, 0, sizeof(indegree));\\r\\n\\r\\n        for (auto edge : edges) {\\r\\n            if (edge[0] == edge[1]) {\\r\\n                return -1;\\r\\n            }\\r\\n            graph[edge[0]].push_back(edge[1]);\\r\\n            indegree[edge[1]]++;\\r\\n        }\\r\\n\\r\\n        queue<int> q;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int dp[n][26];\\r\\n        memset(dp, 0, sizeof(dp));\\r\\n        int max_color = 0;\\r\\n\\r\\n        while (!q.empty()) {\\r\\n            int vertex = q.front();\\r\\n            q.pop();\\r\\n            int color = colors[vertex] - \\'a\\';\\r\\n            dp[vertex][color]++;\\r\\n            max_color = max(max_color, dp[vertex][color]);\\r\\n\\r\\n            for (auto nei : graph[vertex]) {\\r\\n                indegree[nei]--;\\r\\n                for (int c = 0; c < 26; c++) {\\r\\n                    dp[nei][c] = max(dp[nei][c], dp[vertex][c]);\\r\\n                }\\r\\n                if (indegree[nei] == 0) {\\r\\n                    q.push(nei);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] > 0) {\\r\\n                return -1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return max_color;        \\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398713,
                "title": "c-topological-sort-dynamic-programming-explained-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        //*First Part Topological sort*\\n        int n = colors.size();\\n        vector<int> Adj[n];\\n        vector<int> Indegree(n);//The number of Incoming Branches in the node\\n        for(auto &x : edges)\\n        {\\n            Indegree[x[1]]++;\\n            Adj[x[0]].push_back(x[1]);\\n        }\\n        queue<int> q1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!Indegree[i])q1.push(i);\\n        }\\n        vector<int> top_sort;\\n        while(!q1.empty())\\n        {\\n            int a = q1.front();\\n            top_sort.push_back(a);\\n            q1.pop();\\n            for(auto &x : Adj[a])\\n            {\\n                Indegree[x]--;\\n                if(!Indegree[x])q1.push(x);\\n            }\\n        }\\n        int ans = 0;\\n        if(top_sort.size() < n)return -1;//Here Exists a Cycle....\\n        vector<bool> IsVisited(n, false);\\n        vector<vector<int>> v2(n, vector<int>(26, 0));//Mapping the maximum number of occurence of char j, at node i --> v2[i][j] \\n        reverse(top_sort.begin(), top_sort.end());//For Reverse Traversing from leaf to Root\\n        for(auto &x : top_sort)\\n        {\\n            for(auto &y : Adj[x])\\n            {\\n                for(int i=0;i<26;i++)\\n                {\\n                    v2[x][i] = max(v2[x][i], v2[y][i]);\\n                }\\n            }\\n            v2[x][colors[x]-\\'a\\']++;\\n            ans = max(ans , v2[x][colors[x]-\\'a\\']);\\n        }\\n        return ans;\\n    }\\n};\\n         \\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        //*First Part Topological sort*\\n        int n = colors.size();\\n        vector<int> Adj[n];\\n        vector<int> Indegree(n);//The number of Incoming Branches in the node\\n        for(auto &x : edges)\\n        {\\n            Indegree[x[1]]++;\\n            Adj[x[0]].push_back(x[1]);\\n        }\\n        queue<int> q1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!Indegree[i])q1.push(i);\\n        }\\n        vector<int> top_sort;\\n        while(!q1.empty())\\n        {\\n            int a = q1.front();\\n            top_sort.push_back(a);\\n            q1.pop();\\n            for(auto &x : Adj[a])\\n            {\\n                Indegree[x]--;\\n                if(!Indegree[x])q1.push(x);\\n            }\\n        }\\n        int ans = 0;\\n        if(top_sort.size() < n)return -1;//Here Exists a Cycle....\\n        vector<bool> IsVisited(n, false);\\n        vector<vector<int>> v2(n, vector<int>(26, 0));//Mapping the maximum number of occurence of char j, at node i --> v2[i][j] \\n        reverse(top_sort.begin(), top_sort.end());//For Reverse Traversing from leaf to Root\\n        for(auto &x : top_sort)\\n        {\\n            for(auto &y : Adj[x])\\n            {\\n                for(int i=0;i<26;i++)\\n                {\\n                    v2[x][i] = max(v2[x][i], v2[y][i]);\\n                }\\n            }\\n            v2[x][colors[x]-\\'a\\']++;\\n            ans = max(ans , v2[x][colors[x]-\\'a\\']);\\n        }\\n        return ans;\\n    }\\n};\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397614,
                "title": "python-short-and-clean-dfs-dp-functional-programming",
                "content": "<!-- # Approach -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n + e)$$\\r\\n\\r\\n- Space complexity: $$O(n + e)$$\\r\\n\\r\\nwhere,\\r\\n`n is number of nodes`,\\r\\n`e is number of edges`.\\r\\n\\r\\n# Code\\r\\n```python\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:\\r\\n        Node = int\\r\\n        Color = str\\r\\n        Graph = Mapping[Node, tuple[Color, Collection[Node]]]\\r\\n\\r\\n        def max_color_count(graph: Graph) -> int:\\r\\n            seen: set[Node] = set()\\r\\n\\r\\n            @cache\\r\\n            def count_colors(root: Node) -> Counter[Color]:\\r\\n                color, nodes = graph[root]\\r\\n                if root in seen: return Counter({color: inf})\\r\\n\\r\\n                seen.add(root)\\r\\n                counter = Counter({color: 1}) + reduce(or_, map(count_colors, nodes), Counter())\\r\\n                seen.remove(root)\\r\\n\\r\\n                return counter\\r\\n            \\r\\n            return max(count_colors(node).most_common(1)[0][1] for node in graph)\\r\\n        \\r\\n\\r\\n        graph: Graph = {i: (c, set()) for i, c in enumerate(colors)}\\r\\n        for u, v in edges: graph[u][1].add(v)\\r\\n\\r\\n        count: int = max_color_count(graph)\\r\\n        return -1 if count == inf else count\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Graph",
                    "Counting"
                ],
                "code": "```python\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:\\r\\n        Node = int\\r\\n        Color = str\\r\\n        Graph = Mapping[Node, tuple[Color, Collection[Node]]]\\r\\n\\r\\n        def max_color_count(graph: Graph) -> int:\\r\\n            seen: set[Node] = set()\\r\\n\\r\\n            @cache\\r\\n            def count_colors(root: Node) -> Counter[Color]:\\r\\n                color, nodes = graph[root]\\r\\n                if root in seen: return Counter({color: inf})\\r\\n\\r\\n                seen.add(root)\\r\\n                counter = Counter({color: 1}) + reduce(or_, map(count_colors, nodes), Counter())\\r\\n                seen.remove(root)\\r\\n\\r\\n                return counter\\r\\n            \\r\\n            return max(count_colors(node).most_common(1)[0][1] for node in graph)\\r\\n        \\r\\n\\r\\n        graph: Graph = {i: (c, set()) for i, c in enumerate(colors)}\\r\\n        for u, v in edges: graph[u][1].add(v)\\r\\n\\r\\n        count: int = max_color_count(graph)\\r\\n        return -1 if count == inf else count\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397237,
                "title": "java-solution-using-dfs-and-dynamic-programming-and-hashing",
                "content": "# Intuition\\r\\nForm an adjacency list(graph).Iterate through each unvisisted node(origin node) in DFS and compute the max number of nodes for each color from all path from origin node.\\r\\n\\r\\n# Approach\\r\\nForm an adjacency list(graph) using given inputs.\\r\\n\\r\\nIterate through each unvisited node in adjacency list and perform dfs.\\r\\n\\r\\nIn dfs\\r\\n    keep checking for cycle\\r\\n    keep a array of map to store max number of nodes for each color from each node/index. when a node is visited again, you can refer in map to get the max(number of nodes) for each color\\r\\n\\r\\nfor each originating node, check the maximum number of nodes from map by iterating all color\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: n * colors.length()\\r\\n\\r\\n- Space complexity: n * n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    boolean isCycle;\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        List<Integer>[] graph = new ArrayList[colors.length()];\\r\\n        Map<Character,Integer>[] map = new HashMap[colors.length()];\\r\\n        isCycle = false;\\r\\n        for(int i = 0;i<edges.length;i++){\\r\\n            if(graph[edges[i][0]] == null){\\r\\n                graph[edges[i][0]] = new ArrayList<Integer>();\\r\\n            }\\r\\n            graph[edges[i][0]].add(edges[i][1]);\\r\\n        }\\r\\n        int max = 0;\\r\\n        for(int i = 0;i<colors.length() && !isCycle ;i++){\\r\\n            if(map[i] == null){\\r\\n                dfs(i,colors,graph,map,new boolean[colors.length()]);\\r\\n                for(Character c : map[i].keySet()){\\r\\n                    max = Math.max(max,map[i].get(c));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if(isCycle){\\r\\n            return -1;\\r\\n        }\\r\\n        return max;\\r\\n    }\\r\\n    public void dfs(int node,String color,List<Integer>[] graph,Map<Character,Integer>[] map,boolean visited[]){\\r\\n        if(visited[node]){\\r\\n            isCycle = true;\\r\\n            return;\\r\\n        }\\r\\n        if(map[node] != null){\\r\\n            return;\\r\\n        }\\r\\n        visited[node] = true;\\r\\n        map[node] = new HashMap<Character,Integer>();\\r\\n        if(graph[node] != null){\\r\\n            for(int i = 0;i<graph[node].size();i++){\\r\\n                dfs(graph[node].get(i),color,graph,map,visited);\\r\\n                for(Character c : map[graph[node].get(i)].keySet()){\\r\\n                    map[node].put(c,Math.max(map[node].getOrDefault(c,0),map[graph[node].get(i)].get(c)));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        map[node].put(color.charAt(node),map[node].getOrDefault(color.charAt(node),0)+1);\\r\\n        \\r\\n        visited[node] = false;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    boolean isCycle;\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        List<Integer>[] graph = new ArrayList[colors.length()];\\r\\n        Map<Character,Integer>[] map = new HashMap[colors.length()];\\r\\n        isCycle = false;\\r\\n        for(int i = 0;i<edges.length;i++){\\r\\n            if(graph[edges[i][0]] == null){\\r\\n                graph[edges[i][0]] = new ArrayList<Integer>();\\r\\n            }\\r\\n            graph[edges[i][0]].add(edges[i][1]);\\r\\n        }\\r\\n        int max = 0;\\r\\n        for(int i = 0;i<colors.length() && !isCycle ;i++){\\r\\n            if(map[i] == null){\\r\\n                dfs(i,colors,graph,map,new boolean[colors.length()]);\\r\\n                for(Character c : map[i].keySet()){\\r\\n                    max = Math.max(max,map[i].get(c));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if(isCycle){\\r\\n            return -1;\\r\\n        }\\r\\n        return max;\\r\\n    }\\r\\n    public void dfs(int node,String color,List<Integer>[] graph,Map<Character,Integer>[] map,boolean visited[]){\\r\\n        if(visited[node]){\\r\\n            isCycle = true;\\r\\n            return;\\r\\n        }\\r\\n        if(map[node] != null){\\r\\n            return;\\r\\n        }\\r\\n        visited[node] = true;\\r\\n        map[node] = new HashMap<Character,Integer>();\\r\\n        if(graph[node] != null){\\r\\n            for(int i = 0;i<graph[node].size();i++){\\r\\n                dfs(graph[node].get(i),color,graph,map,visited);\\r\\n                for(Character c : map[graph[node].get(i)].keySet()){\\r\\n                    map[node].put(c,Math.max(map[node].getOrDefault(c,0),map[graph[node].get(i)].get(c)));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        map[node].put(color.charAt(node),map[node].getOrDefault(color.charAt(node),0)+1);\\r\\n        \\r\\n        visited[node] = false;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397000,
                "title": "js-solution-memoizing-topological-sort",
                "content": "# Intuition\\r\\nUsing topological sort, we can:\\r\\n1) Detect whether graph has cycles\\r\\n2) Find longest path from any node\\r\\n\\r\\n# Approach\\r\\nFirst of all, we create two structures. Graph, represented in form of adjacency list and array with number of outgoing edges for each node.\\r\\n\\r\\nSecond, we create memo, to count maximum color values for any path starting from current node.\\r\\n\\r\\nThen, we run topological sort and during this, we update memo for each adjacent node.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(n^2)$$ in case all nodes are not connected to each other.\\r\\n\\r\\n- Space complexity:\\r\\n$$O(n * m)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\n// Create graph + array with number of outgoing edges\\r\\nfunction buildGraph(edges, n) {\\r\\n    const incoming = new Array(n);\\r\\n    const outgoing = new Array(n).fill(0);\\r\\n\\r\\n    for (let i = 0; i < n; i++) {\\r\\n        incoming[i] = [];\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < edges.length; i++) {\\r\\n        const [a, b] = edges[i];\\r\\n\\r\\n        incoming[b].push(a);\\r\\n\\r\\n        outgoing[a]++;\\r\\n    }\\r\\n\\r\\n    return [incoming, outgoing];\\r\\n}\\r\\n\\r\\n// Find sink node. (Node with no outgoing edges).\\r\\n// Since graph might not be connected, we need to run this method.\\r\\n// Visited array helps us to check whether this node was used as sink before.\\r\\nfunction findSink(out, visited) {\\r\\n    for (let i = 0; i < out.length; i++) {\\r\\n        if (out[i] === 0 && !visited[i]) {\\r\\n            return i;\\r\\n        }\\r\\n    }\\r\\n    return -1;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    const [incoming, outgoing] = buildGraph(edges, colors.length);\\r\\n\\r\\n    let visited = new Array(colors.length).fill(false);\\r\\n    let visitedCount = 0;\\r\\n\\r\\n    // Maximum color value\\r\\n    let max = 0;\\r\\n\\r\\n    // Create cache for all nodes\\r\\n    const memo = new Array(colors.length);\\r\\n    for (let i = 0; i < memo.length; i++) {\\r\\n        memo[i] = {};\\r\\n    }\\r\\n\\r\\n    let sink = findSink(outgoing, visited);\\r\\n\\r\\n    // Graph has cycle. No nodes have 0 outgoing edges.\\r\\n    if (sink === -1) {\\r\\n        return -1;\\r\\n    }\\r\\n\\r\\n    while (sink !== -1) {\\r\\n        // We count visited nodes just to improve performance.\\r\\n        visitedCount++;\\r\\n        visited[sink] = true;\\r\\n\\r\\n        // Color is represented by a letter. charCode of \"a\" = 97, charCode of \"b\" = 98, so we can calculate 0 - based index using this approach. \\r\\n        const colorIdx = colors[sink].charCodeAt(0) - 97;\\r\\n\\r\\n        if (!memo[sink][colorIdx]) {\\r\\n            memo[sink][colorIdx] = 0;\\r\\n        }\\r\\n        // Add color value of current node.\\r\\n        memo[sink][colorIdx]++;\\r\\n\\r\\n        // Update max for all color values.\\r\\n        max = Math.max(max, memo[sink][colorIdx]);\\r\\n\\r\\n        const adj = incoming[sink];\\r\\n        let maybeSink = -1;\\r\\n        // Traverse through all nodes which come to sink.\\r\\n        for (let i = 0; i < adj.length; i++) {\\r\\n            const n = adj[i];\\r\\n            outgoing[n]--;\\r\\n\\r\\n            const keys = Object.keys(memo[sink]);\\r\\n            // We need to update color values for all adjacent nodes.\\r\\n            for (let i = 0; i < keys.length; i++) {\\r\\n                const key = keys[i];\\r\\n                if (memo[n][key]) {\\r\\n                    memo[n][key] = Math.max(memo[n][key], memo[sink][key]);\\r\\n                } else {\\r\\n                    memo[n][key] = memo[sink][key];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // We create maybeSink in order to not call findSink every time since it causes TLE for some cases.\\r\\n            if (outgoing[n] === 0) {\\r\\n                maybeSink = n;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Graph might not be connected, so we need to find some other sink node.\\r\\n        sink = maybeSink === -1 ? findSink(outgoing, visited) : maybeSink;\\r\\n    }\\r\\n\\r\\n    // If we did not traverse all nodes, then graph has cycle, return -1. Otherwise, return max for all nodes.\\r\\n    return visitedCount === colors.length ? max : -1;\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\r\\n// Create graph + array with number of outgoing edges\\r\\nfunction buildGraph(edges, n) {\\r\\n    const incoming = new Array(n);\\r\\n    const outgoing = new Array(n).fill(0);\\r\\n\\r\\n    for (let i = 0; i < n; i++) {\\r\\n        incoming[i] = [];\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < edges.length; i++) {\\r\\n        const [a, b] = edges[i];\\r\\n\\r\\n        incoming[b].push(a);\\r\\n\\r\\n        outgoing[a]++;\\r\\n    }\\r\\n\\r\\n    return [incoming, outgoing];\\r\\n}\\r\\n\\r\\n// Find sink node. (Node with no outgoing edges).\\r\\n// Since graph might not be connected, we need to run this method.\\r\\n// Visited array helps us to check whether this node was used as sink before.\\r\\nfunction findSink(out, visited) {\\r\\n    for (let i = 0; i < out.length; i++) {\\r\\n        if (out[i] === 0 && !visited[i]) {\\r\\n            return i;\\r\\n        }\\r\\n    }\\r\\n    return -1;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    const [incoming, outgoing] = buildGraph(edges, colors.length);\\r\\n\\r\\n    let visited = new Array(colors.length).fill(false);\\r\\n    let visitedCount = 0;\\r\\n\\r\\n    // Maximum color value\\r\\n    let max = 0;\\r\\n\\r\\n    // Create cache for all nodes\\r\\n    const memo = new Array(colors.length);\\r\\n    for (let i = 0; i < memo.length; i++) {\\r\\n        memo[i] = {};\\r\\n    }\\r\\n\\r\\n    let sink = findSink(outgoing, visited);\\r\\n\\r\\n    // Graph has cycle. No nodes have 0 outgoing edges.\\r\\n    if (sink === -1) {\\r\\n        return -1;\\r\\n    }\\r\\n\\r\\n    while (sink !== -1) {\\r\\n        // We count visited nodes just to improve performance.\\r\\n        visitedCount++;\\r\\n        visited[sink] = true;\\r\\n\\r\\n        // Color is represented by a letter. charCode of \"a\" = 97, charCode of \"b\" = 98, so we can calculate 0 - based index using this approach. \\r\\n        const colorIdx = colors[sink].charCodeAt(0) - 97;\\r\\n\\r\\n        if (!memo[sink][colorIdx]) {\\r\\n            memo[sink][colorIdx] = 0;\\r\\n        }\\r\\n        // Add color value of current node.\\r\\n        memo[sink][colorIdx]++;\\r\\n\\r\\n        // Update max for all color values.\\r\\n        max = Math.max(max, memo[sink][colorIdx]);\\r\\n\\r\\n        const adj = incoming[sink];\\r\\n        let maybeSink = -1;\\r\\n        // Traverse through all nodes which come to sink.\\r\\n        for (let i = 0; i < adj.length; i++) {\\r\\n            const n = adj[i];\\r\\n            outgoing[n]--;\\r\\n\\r\\n            const keys = Object.keys(memo[sink]);\\r\\n            // We need to update color values for all adjacent nodes.\\r\\n            for (let i = 0; i < keys.length; i++) {\\r\\n                const key = keys[i];\\r\\n                if (memo[n][key]) {\\r\\n                    memo[n][key] = Math.max(memo[n][key], memo[sink][key]);\\r\\n                } else {\\r\\n                    memo[n][key] = memo[sink][key];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // We create maybeSink in order to not call findSink every time since it causes TLE for some cases.\\r\\n            if (outgoing[n] === 0) {\\r\\n                maybeSink = n;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Graph might not be connected, so we need to find some other sink node.\\r\\n        sink = maybeSink === -1 ? findSink(outgoing, visited) : maybeSink;\\r\\n    }\\r\\n\\r\\n    // If we did not traverse all nodes, then graph has cycle, return -1. Otherwise, return max for all nodes.\\r\\n    return visitedCount === colors.length ? max : -1;\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3396608,
                "title": "python-simple-and-clean-beats-99-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\r\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\r\\n\\r\\n*This is an NFT*\\r\\n\\r\\n# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n> We need to find the largest color value of any valid path in the graph. To achieve this, we can use a **dynamic programming approach**.\\r\\n\\r\\nWe can create a 2D array called `count` to keep track of the frequency of each color along a path from the starting node to the current node. We can also use a queue to keep track of nodes with no incoming edges. We can start by adding all such nodes to the queue and then traversing the graph in a **Breadth-First Search (BFS)** manner. At each node, we update the `count` array to include the current node\\'s color frequency and the frequency of its neighbors\\' colors. We can then add the neighbor nodes to the queue if their incoming edges have been processed. Finally, we can return the largest color value found.\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. Create an adjacency list `adj` to represent the graph, and an `indegree` array to keep track of the number of incoming edges for each node.\\r\\n1. Create a 2D array called `count` to keep track of the frequency of each color along a path from the starting node to the current node.\\r\\n1. Create an empty queue `q`.\\r\\n1. Add all nodes with an `indegree` of 0 to the queue.\\r\\n1. Set the `answer` variable to 0 and `nodesSeen` variable to 0.\\r\\n1. While the queue is not empty:\\r\\n    1. Remove the first node from the queue.\\r\\n    1. Update the `count` array to include the current node\\'s color frequency and the frequency of its neighbors\\' colors.\\r\\n    1. Update the `answer` variable to be the maximum of the current node\\'s color frequency and the previous `answer` value.\\r\\n    1. Increment the `nodesSeen` variable.\\r\\n    1. Add the current node\\'s neighbors to the queue if their incoming edges have been processed.\\r\\n1. If `nodesSeen` is less than `n` (the number of nodes in the graph), return -1, else return the `answer`.\\r\\n# Complexity\\r\\n- Time complexity: $O(n+e)$, where $n$ is the number of nodes and $e$ is the number of edges in the graph.\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $O(n+26n)$ = $O(n)$, where the first $n$ is for the adjacency list and the second $n$ is for the `count` array. The `indegree` array and the queue use $O(n)$ space as well. The constant 26 is used for the size of the `count` array, as there are 26 possible lowercase English letters.\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        adj = [[] for _ in range(n)]\\r\\n        indegree = [0] * n\\r\\n\\r\\n        for edge in edges:\\r\\n            adj[edge[0]].append(edge[1])\\r\\n            indegree[edge[1]] += 1\\r\\n\\r\\n        count = [[0] * 26 for _ in range(n)]\\r\\n        q = []\\r\\n\\r\\n        # Push all the nodes with indegree zero in the queue.\\r\\n        for i in range(n):\\r\\n            if indegree[i] == 0:\\r\\n                q.append(i)\\r\\n\\r\\n        answer = 0\\r\\n        nodesSeen = 0\\r\\n        while q:\\r\\n            node = q.pop(0)\\r\\n            answer = max(answer, count[node][ord(colors[node]) - ord(\\'a\\')] + 1)\\r\\n            count[node][ord(colors[node]) - ord(\\'a\\')] += 1\\r\\n            nodesSeen += 1\\r\\n\\r\\n            for neighbor in adj[node]:\\r\\n                for i in range(26):\\r\\n                    # Try to update the frequency of colors for neighbor to include paths\\r\\n                    # that use node->neighbor edge.\\r\\n                    count[neighbor][i] = max(count[neighbor][i], count[node][i])\\r\\n\\r\\n                indegree[neighbor] -= 1\\r\\n                if indegree[neighbor] == 0:\\r\\n                    q.append(neighbor)\\r\\n\\r\\n        return -1 if nodesSeen < n else answer\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        adj = [[] for _ in range(n)]\\r\\n        indegree = [0] * n\\r\\n\\r\\n        for edge in edges:\\r\\n            adj[edge[0]].append(edge[1])\\r\\n            indegree[edge[1]] += 1\\r\\n\\r\\n        count = [[0] * 26 for _ in range(n)]\\r\\n        q = []\\r\\n\\r\\n        # Push all the nodes with indegree zero in the queue.\\r\\n        for i in range(n):\\r\\n            if indegree[i] == 0:\\r\\n                q.append(i)\\r\\n\\r\\n        answer = 0\\r\\n        nodesSeen = 0\\r\\n        while q:\\r\\n            node = q.pop(0)\\r\\n            answer = max(answer, count[node][ord(colors[node]) - ord(\\'a\\')] + 1)\\r\\n            count[node][ord(colors[node]) - ord(\\'a\\')] += 1\\r\\n            nodesSeen += 1\\r\\n\\r\\n            for neighbor in adj[node]:\\r\\n                for i in range(26):\\r\\n                    # Try to update the frequency of colors for neighbor to include paths\\r\\n                    # that use node->neighbor edge.\\r\\n                    count[neighbor][i] = max(count[neighbor][i], count[node][i])\\r\\n\\r\\n                indegree[neighbor] -= 1\\r\\n                if indegree[neighbor] == 0:\\r\\n                    q.append(neighbor)\\r\\n\\r\\n        return -1 if nodesSeen < n else answer\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396323,
                "title": "dfs-solution",
                "content": "# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        adj=defaultdict(list)\\r\\n        for i,j in edges:\\r\\n            adj[i].append(j)\\r\\n        n,res=len(colors),0\\r\\n        visit,path=set(),set()\\r\\n        count=[[0]*26 for i in range(n)]\\r\\n        def dfs(node):\\r\\n            if node in path:\\r\\n                return float(\\'inf\\')\\r\\n            if node in visit:\\r\\n                return 0\\r\\n            visit.add(node)\\r\\n            path.add(node)\\r\\n            ci=ord(colors[node])-ord(\\'a\\')\\r\\n            count[node][ci]=1\\r\\n            for nei in adj[node]:\\r\\n                if dfs(nei)==float(\\'inf\\'):\\r\\n                    return float(\\'inf\\')\\r\\n                for c in range(26):\\r\\n                    count[node][c]=max(count[node][c],\\r\\n                    (1 if c==ci else 0) + count[nei][c])\\r\\n            path.remove(node)\\r\\n            return max(count[node])\\r\\n        for i in range(n):\\r\\n            res=max(dfs(i),res)\\r\\n        return -1 if res==float(\\'inf\\') else res\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        adj=defaultdict(list)\\r\\n        for i,j in edges:\\r\\n            adj[i].append(j)\\r\\n        n,res=len(colors),0\\r\\n        visit,path=set(),set()\\r\\n        count=[[0]*26 for i in range(n)]\\r\\n        def dfs(node):\\r\\n            if node in path:\\r\\n                return float(\\'inf\\')\\r\\n            if node in visit:\\r\\n                return 0\\r\\n            visit.add(node)\\r\\n            path.add(node)\\r\\n            ci=ord(colors[node])-ord(\\'a\\')\\r\\n            count[node][ci]=1\\r\\n            for nei in adj[node]:\\r\\n                if dfs(nei)==float(\\'inf\\'):\\r\\n                    return float(\\'inf\\')\\r\\n                for c in range(26):\\r\\n                    count[node][c]=max(count[node][c],\\r\\n                    (1 if c==ci else 0) + count[nei][c])\\r\\n            path.remove(node)\\r\\n            return max(count[node])\\r\\n        for i in range(n):\\r\\n            res=max(dfs(i),res)\\r\\n        return -1 if res==float(\\'inf\\') else res\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396059,
                "title": "java-dfs-solution",
                "content": "```\\r\\nclass Solution {\\r\\n    List<List<Integer>> graph;\\r\\n    boolean visited[];\\r\\n    int counts[][];\\r\\n\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int max = -1;\\r\\n        int nodes = colors.length();\\r\\n        counts = new int[nodes][26];\\r\\n        visited = new boolean[nodes];\\r\\n\\r\\n        graph = new ArrayList<>();\\r\\n\\r\\n        for (int i = 0; i < nodes; i++) {\\r\\n            graph.add(new ArrayList<>());\\r\\n        }\\r\\n\\r\\n        for (int[] edge: edges) {\\r\\n            int source = edge[0];\\r\\n            int dest = edge[1];\\r\\n\\r\\n            graph.get(source).add(dest);\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < nodes; i++) {\\r\\n\\r\\n            boolean pathVisited[] = new boolean[nodes];\\r\\n\\r\\n            int count = countInPath(i, pathVisited, colors);\\r\\n\\r\\n            max = Math.max(count, max);\\r\\n        }\\r\\n\\r\\n        return max == Integer.MAX_VALUE ? -1 : max;\\r\\n    }\\r\\n\\r\\n    private int countInPath(int node, boolean pathVisited[], String colors) {\\r\\n        if (pathVisited[node]) {\\r\\n            return Integer.MAX_VALUE;\\r\\n        }\\r\\n\\r\\n        int idx = colors.charAt(node) - \\'a\\';\\r\\n\\r\\n        if (visited[node]) {\\r\\n            return counts[node][idx];\\r\\n        }\\r\\n\\r\\n        visited[node] = true;\\r\\n        pathVisited[node] = true;\\r\\n\\r\\n        for (int adj: graph.get(node)) {\\r\\n            int data = countInPath(adj, pathVisited, colors);\\r\\n\\r\\n            if (data == Integer.MAX_VALUE) {\\r\\n                return Integer.MAX_VALUE;\\r\\n            }\\r\\n\\r\\n            for (int i = 0; i < 26; i++) {\\r\\n                counts[node][i] = Math.max(counts[node][i], counts[adj][i]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        counts[node][idx]++;\\r\\n        pathVisited[node] = false;\\r\\n\\r\\n        return counts[node][idx];\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    List<List<Integer>> graph;\\r\\n    boolean visited[];\\r\\n    int counts[][];\\r\\n\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int max = -1;\\r\\n        int nodes = colors.length();\\r\\n        counts = new int[nodes][26];\\r\\n        visited = new boolean[nodes];\\r\\n\\r\\n        graph = new ArrayList<>();\\r\\n\\r\\n        for (int i = 0; i < nodes; i++) {\\r\\n            graph.add(new ArrayList<>());\\r\\n        }\\r\\n\\r\\n        for (int[] edge: edges) {\\r\\n            int source = edge[0];\\r\\n            int dest = edge[1];\\r\\n\\r\\n            graph.get(source).add(dest);\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < nodes; i++) {\\r\\n\\r\\n            boolean pathVisited[] = new boolean[nodes];\\r\\n\\r\\n            int count = countInPath(i, pathVisited, colors);\\r\\n\\r\\n            max = Math.max(count, max);\\r\\n        }\\r\\n\\r\\n        return max == Integer.MAX_VALUE ? -1 : max;\\r\\n    }\\r\\n\\r\\n    private int countInPath(int node, boolean pathVisited[], String colors) {\\r\\n        if (pathVisited[node]) {\\r\\n            return Integer.MAX_VALUE;\\r\\n        }\\r\\n\\r\\n        int idx = colors.charAt(node) - \\'a\\';\\r\\n\\r\\n        if (visited[node]) {\\r\\n            return counts[node][idx];\\r\\n        }\\r\\n\\r\\n        visited[node] = true;\\r\\n        pathVisited[node] = true;\\r\\n\\r\\n        for (int adj: graph.get(node)) {\\r\\n            int data = countInPath(adj, pathVisited, colors);\\r\\n\\r\\n            if (data == Integer.MAX_VALUE) {\\r\\n                return Integer.MAX_VALUE;\\r\\n            }\\r\\n\\r\\n            for (int i = 0; i < 26; i++) {\\r\\n                counts[node][i] = Math.max(counts[node][i], counts[adj][i]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        counts[node][idx]++;\\r\\n        pathVisited[node] = false;\\r\\n\\r\\n        return counts[node][idx];\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395737,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n = len(colors)\\n        graph = collections.defaultdict(list)\\n        indegree = [0] * len(colors)\\n        for u, v in edges:\\n            graph[v].append(u)\\n            indegree[u] += 1\\n        \\n        count = [collections.defaultdict(int) for _ in range(n)]\\n        q = collections.deque(filter(lambda i: not indegree[i], range(n)))\\n        seen = 0\\n        ans = 0\\n        while q:\\n            curr = q.popleft()\\n            count[curr][colors[curr]] += 1\\n            ans = max(ans, count[curr][colors[curr]])\\n            seen += 1\\n\\n            for v in graph[curr]:\\n                for c in count[curr]:\\n                    count[v][c] = max(count[v][c], count[curr][c])\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    q.append(v)\\n        \\n        if seen < n:\\n            return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n = len(colors)\\n        graph = collections.defaultdict(list)\\n        indegree = [0] * len(colors)\\n        for u, v in edges:\\n            graph[v].append(u)\\n            indegree[u] += 1\\n        \\n        count = [collections.defaultdict(int) for _ in range(n)]\\n        q = collections.deque(filter(lambda i: not indegree[i], range(n)))\\n        seen = 0\\n        ans = 0\\n        while q:\\n            curr = q.popleft()\\n            count[curr][colors[curr]] += 1\\n            ans = max(ans, count[curr][colors[curr]])\\n            seen += 1\\n\\n            for v in graph[curr]:\\n                for c in count[curr]:\\n                    count[v][c] = max(count[v][c], count[curr][c])\\n                indegree[v] -= 1\\n                if indegree[v] == 0:\\n                    q.append(v)\\n        \\n        if seen < n:\\n            return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395652,
                "title": "c-topological-sort",
                "content": "# Code (Topological Sort)\\r\\n```\\r\\nclass Solution {\\r\\n    typedef array<int, 26> T;\\r\\npublic:\\r\\n    int largestPathValue(string C, vector<vector<int>>& E) {\\r\\n        unordered_map<int, vector<int>> G;\\r\\n        vector<int> indegree(C.size());\\r\\n        for (auto &e : E) {\\r\\n            G[e[0]].push_back(e[1]); // build graph\\r\\n            indegree[e[1]]++; // count indegrees\\r\\n        }\\r\\n\\r\\n        vector<T> cnt(C.size(), T{}); // cnt[i][j] is the maximum count of j-th color from the ancester nodes to node i.\\r\\n        queue<int> q;\\r\\n        for (int i = 0; i < C.size(); ++i) {\\r\\n            if (indegree[i] == 0) { // if this node has 0 indegree, we can use it as a source node\\r\\n                q.push(i);\\r\\n                cnt[i][C[i] - \\'a\\'] = 1; // the count of the current color should be 1\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int ans = 0, seen = 0;\\r\\n        while (q.size()) {\\r\\n            auto u = q.front();\\r\\n            q.pop();\\r\\n            int val = *max_element(begin(cnt[u]), end(cnt[u])); // we use the maximum of all the maximum color counts as the color value.\\r\\n            ans = max(ans, val);\\r\\n            ++seen;\\r\\n            for (int v : G[u]) {\\r\\n                for (int i = 0; i < 26; ++i) {\\r\\n                    cnt[v][i] = max(cnt[v][i], cnt[u][i] + (i == C[v] - \\'a\\')); // try to use node `u` to update all the color counts of node `v`.\\r\\n                }\\r\\n                if (--indegree[v] == 0) {\\r\\n                    q.push(v);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return seen < C.size() ? -1 : ans;\\r\\n    }\\r\\n};\\r\\n```\\r\\n",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    typedef array<int, 26> T;\\r\\npublic:\\r\\n    int largestPathValue(string C, vector<vector<int>>& E) {\\r\\n        unordered_map<int, vector<int>> G;\\r\\n        vector<int> indegree(C.size());\\r\\n        for (auto &e : E) {\\r\\n            G[e[0]].push_back(e[1]); // build graph\\r\\n            indegree[e[1]]++; // count indegrees\\r\\n        }\\r\\n\\r\\n        vector<T> cnt(C.size(), T{}); // cnt[i][j] is the maximum count of j-th color from the ancester nodes to node i.\\r\\n        queue<int> q;\\r\\n        for (int i = 0; i < C.size(); ++i) {\\r\\n            if (indegree[i] == 0) { // if this node has 0 indegree, we can use it as a source node\\r\\n                q.push(i);\\r\\n                cnt[i][C[i] - \\'a\\'] = 1; // the count of the current color should be 1\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int ans = 0, seen = 0;\\r\\n        while (q.size()) {\\r\\n            auto u = q.front();\\r\\n            q.pop();\\r\\n            int val = *max_element(begin(cnt[u]), end(cnt[u])); // we use the maximum of all the maximum color counts as the color value.\\r\\n            ans = max(ans, val);\\r\\n            ++seen;\\r\\n            for (int v : G[u]) {\\r\\n                for (int i = 0; i < 26; ++i) {\\r\\n                    cnt[v][i] = max(cnt[v][i], cnt[u][i] + (i == C[v] - \\'a\\')); // try to use node `u` to update all the color counts of node `v`.\\r\\n                }\\r\\n                if (--indegree[v] == 0) {\\r\\n                    q.push(v);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return seen < C.size() ? -1 : ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395454,
                "title": "easy-understand-simple-topological-sorting-method-java-python",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nTo find out whether there is a cycle in the graph, just enter the bfs directly. Because no matter what graph structure is either a chain or a ring, when it is a chain, there must be a chain head. When there is no ring on the way, it can traverse the entire graph from the chain head in turn according to the in-degree. Otherwise, if it cannot traverse the entire graph Then there is a cycle.\\r\\n\\r\\nAll that remains is to find the maximum color value in each path.\\r\\n\\r\\nBuild dp to record the maximum value of each color of each node under the previous path.\\r\\n\\r\\nWhen traversing to each node, first update the color value of this node, and then use each color value of this node to update the maximum color value of subsequent nodes. When the in-degree of subsequent nodes is 0, there is no longer a path to this node. You can add this node to the queue and continue traversing, so that you can solve\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n``` java []\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        char[] colorArray = colors.toCharArray();\\r\\n        int[] indegree = new int[n];\\r\\n        \\r\\n        // Adjacency list -> [[1, 2], [], [3], [4], []] \\r\\n        List<List<Integer>> adj = new ArrayList<>();\\r\\n        for (int i = 0; i < n; i++)\\r\\n            adj.add(new ArrayList<>());\\r\\n        for (int[] edge : edges){\\r\\n            indegree[edge[1]]++;\\r\\n            adj.get(edge[0]).add(edge[1]);\\r\\n            if (edge[0] == edge[1]) return -1;\\r\\n        }\\r\\n\\r\\n        // Deque using LinkedList is slower but also works\\r\\n        Deque<Integer> deq = new ArrayDeque<>(); \\r\\n        int[][] opt = new int[n][26];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                opt[i][colorArray[i] - \\'a\\'] = 1;\\r\\n                deq.offer(i); // if head then add into queue\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int ans = 1, count = 0;\\r\\n        while (!deq.isEmpty()) {\\r\\n            int ver = deq.poll();\\r\\n            for (int j = 0; j < 26; j++)\\r\\n                ans = Math.max(ans, opt[ver][j]);\\r\\n\\r\\n            for (int i : adj.get(ver)){ // traverse the following child list\\r\\n                int p = colorArray[i] - \\'a\\';\\r\\n                for (int j = 0; j < 26; j++)\\r\\n                    opt[i][j] = Math.max(opt[i][j], opt[ver][j] + ((p == j) ? 1 : 0));\\r\\n                // if degree is 0 then no later path, add into queue\\r\\n                indegree[i] --;\\r\\n                if (indegree[i] == 0) \\r\\n                    deq.offer(i);\\r\\n            }\\r\\n            count ++;\\r\\n        }\\r\\n\\r\\n        // check if circle exist\\r\\n        if (count != n)\\r\\n            return -1;\\r\\n        return ans;\\r\\n    }\\r\\n}\\r\\n```\\r\\n``` python []\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        adj = collections.defaultdict(set) # childnode set\\r\\n        indegree = [0 for i in range(n)] # indegree\\r\\n        for u, v in edges:\\r\\n            adj[u].add(v)\\r\\n            indegree[v] += 1\\r\\n        \\r\\n        deq = collections.deque()\\r\\n        opt = [[0 for i in range(26)] for j in range(n)] # opt of max color\\r\\n        for i in range(n):\\r\\n            if indegree[i] == 0: # if head\\r\\n                deq.append(i) # add into queue\\r\\n        \\r\\n        count = 0\\r\\n        while deq:\\r\\n            i = deq.popleft()\\r\\n            \\r\\n            opt[i][ord(colors[i]) - ord(\"a\")] += 1 # add on the color vlaue\\r\\n            for j in adj[i]: # the later child node\\r\\n                for k in range(26): # update maxvlaue of child node\\r\\n                    opt[j][k] = max(opt[i][k], opt[j][k])\\r\\n                indegree[j] -= 1 # update indegree\\r\\n                if indegree[j] == 0: # if degree is 0 then no later path\\r\\n                    deq.append(j) # add into queue\\r\\n            count += 1\\r\\n            \\r\\n        if count != n: # check if circle exist\\r\\n            return -1\\r\\n        return max([max(i) for i in opt]) # no circle, this is finsih result\\r\\n```\\r\\n\\r\\nAnother solution also using Topological Sorting and some place may different\\r\\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        char[] colorArray = colors.toCharArray();\\r\\n        int[] indegree = new int[n];\\r\\n\\r\\n        List<List<Integer>> adj = new ArrayList<>();\\r\\n        IntStream.range(0,n).forEach(a->adj.add(new ArrayList<>()));\\r\\n        for (int[] edge : edges){\\r\\n            indegree[edge[1]]++;\\r\\n            adj.get(edge[0]).add(edge[1]);\\r\\n        }\\r\\n\\r\\n        int res=0;\\r\\n        Deque<Integer> deque = new ArrayDeque<>();\\r\\n        int[][] opt = new int[n][26];\\r\\n        for(int i=0;i<indegree.length;i++){\\r\\n            if(indegree[i]==0) {\\r\\n                deque.offer(i);\\r\\n                opt[i][colorArray[i]-\\'a\\'] = 1;\\r\\n                res = 1;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        while (!deque.isEmpty()){\\r\\n            int cur=deque.pop();\\r\\n            for (int i : adj.get(cur)) {\\r\\n                int c = colorArray[i]-\\'a\\';\\r\\n                // update opt\\r\\n                for (int j = 0; j < 26; j++) {\\r\\n                    if(j == c){\\r\\n                        opt[i][c]=Math.max(opt[i][c],opt[cur][c]+1);\\r\\n                        res=Math.max(res,opt[i][j]);\\r\\n                    }else{\\r\\n                        opt[i][j]=Math.max(opt[i][j],opt[cur][j]);\\r\\n                        res=Math.max(res,opt[i][j]);\\r\\n                    }\\r\\n                }\\r\\n                indegree[i]--;\\r\\n                if(indegree[i]==0){\\r\\n                    deque.offer(i);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        // chec if circle exist\\r\\n        for(int v:indegree){\\r\\n            if(v!=0) return -1;\\r\\n        }\\r\\n        return  res;\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\n**Please upvate if helpful!!**\\r\\n\\r\\n![image.png](https://assets.leetcode.com/users/images/4cfe106c-39c2-421d-90ca-53a7797ed7b5_1680845537.3804016.png)",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "``` java []\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        char[] colorArray = colors.toCharArray();\\r\\n        int[] indegree = new int[n];\\r\\n        \\r\\n        // Adjacency list -> [[1, 2], [], [3], [4], []] \\r\\n        List<List<Integer>> adj = new ArrayList<>();\\r\\n        for (int i = 0; i < n; i++)\\r\\n            adj.add(new ArrayList<>());\\r\\n        for (int[] edge : edges){\\r\\n            indegree[edge[1]]++;\\r\\n            adj.get(edge[0]).add(edge[1]);\\r\\n            if (edge[0] == edge[1]) return -1;\\r\\n        }\\r\\n\\r\\n        // Deque using LinkedList is slower but also works\\r\\n        Deque<Integer> deq = new ArrayDeque<>(); \\r\\n        int[][] opt = new int[n][26];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                opt[i][colorArray[i] - \\'a\\'] = 1;\\r\\n                deq.offer(i); // if head then add into queue\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int ans = 1, count = 0;\\r\\n        while (!deq.isEmpty()) {\\r\\n            int ver = deq.poll();\\r\\n            for (int j = 0; j < 26; j++)\\r\\n                ans = Math.max(ans, opt[ver][j]);\\r\\n\\r\\n            for (int i : adj.get(ver)){ // traverse the following child list\\r\\n                int p = colorArray[i] - \\'a\\';\\r\\n                for (int j = 0; j < 26; j++)\\r\\n                    opt[i][j] = Math.max(opt[i][j], opt[ver][j] + ((p == j) ? 1 : 0));\\r\\n                // if degree is 0 then no later path, add into queue\\r\\n                indegree[i] --;\\r\\n                if (indegree[i] == 0) \\r\\n                    deq.offer(i);\\r\\n            }\\r\\n            count ++;\\r\\n        }\\r\\n\\r\\n        // check if circle exist\\r\\n        if (count != n)\\r\\n            return -1;\\r\\n        return ans;\\r\\n    }\\r\\n}\\r\\n```\n``` python []\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        adj = collections.defaultdict(set) # childnode set\\r\\n        indegree = [0 for i in range(n)] # indegree\\r\\n        for u, v in edges:\\r\\n            adj[u].add(v)\\r\\n            indegree[v] += 1\\r\\n        \\r\\n        deq = collections.deque()\\r\\n        opt = [[0 for i in range(26)] for j in range(n)] # opt of max color\\r\\n        for i in range(n):\\r\\n            if indegree[i] == 0: # if head\\r\\n                deq.append(i) # add into queue\\r\\n        \\r\\n        count = 0\\r\\n        while deq:\\r\\n            i = deq.popleft()\\r\\n            \\r\\n            opt[i][ord(colors[i]) - ord(\"a\")] += 1 # add on the color vlaue\\r\\n            for j in adj[i]: # the later child node\\r\\n                for k in range(26): # update maxvlaue of child node\\r\\n                    opt[j][k] = max(opt[i][k], opt[j][k])\\r\\n                indegree[j] -= 1 # update indegree\\r\\n                if indegree[j] == 0: # if degree is 0 then no later path\\r\\n                    deq.append(j) # add into queue\\r\\n            count += 1\\r\\n            \\r\\n        if count != n: # check if circle exist\\r\\n            return -1\\r\\n        return max([max(i) for i in opt]) # no circle, this is finsih result\\r\\n```\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length();\\r\\n        char[] colorArray = colors.toCharArray();\\r\\n        int[] indegree = new int[n];\\r\\n\\r\\n        List<List<Integer>> adj = new ArrayList<>();\\r\\n        IntStream.range(0,n).forEach(a->adj.add(new ArrayList<>()));\\r\\n        for (int[] edge : edges){\\r\\n            indegree[edge[1]]++;\\r\\n            adj.get(edge[0]).add(edge[1]);\\r\\n        }\\r\\n\\r\\n        int res=0;\\r\\n        Deque<Integer> deque = new ArrayDeque<>();\\r\\n        int[][] opt = new int[n][26];\\r\\n        for(int i=0;i<indegree.length;i++){\\r\\n            if(indegree[i]==0) {\\r\\n                deque.offer(i);\\r\\n                opt[i][colorArray[i]-\\'a\\'] = 1;\\r\\n                res = 1;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        while (!deque.isEmpty()){\\r\\n            int cur=deque.pop();\\r\\n            for (int i : adj.get(cur)) {\\r\\n                int c = colorArray[i]-\\'a\\';\\r\\n                // update opt\\r\\n                for (int j = 0; j < 26; j++) {\\r\\n                    if(j == c){\\r\\n                        opt[i][c]=Math.max(opt[i][c],opt[cur][c]+1);\\r\\n                        res=Math.max(res,opt[i][j]);\\r\\n                    }else{\\r\\n                        opt[i][j]=Math.max(opt[i][j],opt[cur][j]);\\r\\n                        res=Math.max(res,opt[i][j]);\\r\\n                    }\\r\\n                }\\r\\n                indegree[i]--;\\r\\n                if(indegree[i]==0){\\r\\n                    deque.offer(i);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        // chec if circle exist\\r\\n        for(int v:indegree){\\r\\n            if(v!=0) return -1;\\r\\n        }\\r\\n        return  res;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664463,
                "title": "c-easy-to-understand-with-graph",
                "content": "\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\ntypedef array<int, 26> T;\\r\\npublic:\\r\\n    int largestPathValue(string C, vector<vector<int>>& E) {\\r\\n        unordered_map<int, vector<int>> G;\\r\\n        vector<int> indegree(C.size());\\r\\n        for (auto &e : E) {\\r\\n            G[e[0]].push_back(e[1]); \\r\\n            indegree[e[1]]++; \\r\\n        }\\r\\n        vector<T> cnt(C.size(), T{});\\r\\n        queue<int> q;\\r\\n        for (int i = 0; i < C.size(); ++i) {\\r\\n            if (indegree[i] == 0) { \\r\\n                q.push(i);\\r\\n                cnt[i][C[i] - \\'a\\'] = 1; \\r\\n            }\\r\\n        }\\r\\n        int ans = 0, seen = 0;\\r\\n        while (q.size()) {\\r\\n            auto u = q.front();\\r\\n            q.pop();\\r\\n            int val = *max_element(begin(cnt[u]), end(cnt[u]));\\r\\n            ans = max(ans, val);\\r\\n            ++seen;\\r\\n            for (int v : G[u]) {\\r\\n                for (int i = 0; i < 26; ++i) {\\r\\n                    cnt[v][i] = max(cnt[v][i], cnt[u][i] + (i == C[v] - \\'a\\'));\\r\\n                }\\r\\n                if (--indegree[v] == 0) {\\r\\n                    q.push(v);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return seen < C.size() ? -1 : ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\ntypedef array<int, 26> T;\\r\\npublic:\\r\\n    int largestPathValue(string C, vector<vector<int>>& E) {\\r\\n        unordered_map<int, vector<int>> G;\\r\\n        vector<int> indegree(C.size());\\r\\n        for (auto &e : E) {\\r\\n            G[e[0]].push_back(e[1]); \\r\\n            indegree[e[1]]++; \\r\\n        }\\r\\n        vector<T> cnt(C.size(), T{});\\r\\n        queue<int> q;\\r\\n        for (int i = 0; i < C.size(); ++i) {\\r\\n            if (indegree[i] == 0) { \\r\\n                q.push(i);\\r\\n                cnt[i][C[i] - \\'a\\'] = 1; \\r\\n            }\\r\\n        }\\r\\n        int ans = 0, seen = 0;\\r\\n        while (q.size()) {\\r\\n            auto u = q.front();\\r\\n            q.pop();\\r\\n            int val = *max_element(begin(cnt[u]), end(cnt[u]));\\r\\n            ans = max(ans, val);\\r\\n            ++seen;\\r\\n            for (int v : G[u]) {\\r\\n                for (int i = 0; i < 26; ++i) {\\r\\n                    cnt[v][i] = max(cnt[v][i], cnt[u][i] + (i == C[v] - \\'a\\'));\\r\\n                }\\r\\n                if (--indegree[v] == 0) {\\r\\n                    q.push(v);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return seen < C.size() ? -1 : ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188721,
                "title": "java-o-26n-top-sort",
                "content": "When it comes to finding a cycle, usually we use DFS or Topsort.\\n\\nHere the graph is a directed graph, so Topsort should be better here because for DFS, it may be tricky to tell whether this visitied node was visited in the current DFS or previous ones as directed graph does not guranatee that 1 DFS will explore the whole graph. (We often need to do multiple DFSs and will need a way to avoid the nodes visitied in prior DFS while keeping track of a separate visited node list for the current DFS.)\\n\\nso let\\'s just use topsort because that seems like a bit less work (DFS will work too, just probably a bit more codes and complexity).\\n\\n*Key observation here is that there are only 26 colors, hence we can forward the current best to the next node*\\n*The base case is the nodes with indegree of 0, where the color they have represent 1*\\n\\nThis results in a time complexity of O(26N) which is acceptable for this problem.\\n\\n```Java\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n = colors.length();\\n        List<Integer>[] map = new ArrayList[n];\\n        Arrays.setAll(map, o -> new ArrayList<>());\\n        int[] indg = new int[n];\\n        for (int[] e : edges){\\n            map[e[0]].add(e[1]);\\n            indg[e[1]]++;\\n        }\\n        int[][] memo = new int[n][26];\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++){\\n            if (indg[i] == 0){\\n                memo[i][colors.charAt(i)-\\'a\\']++; // base case\\n                queue.offer(i);\\n            }\\n        }\\n\\n        int ans = 0;\\n        while(!queue.isEmpty()){\\n            --n;\\n            int cur = queue.poll();\\n            if (map[cur].size()==0){ // update ans at leave nodes\\n                ans = Math.max(ans, Arrays.stream(memo[cur]).max().getAsInt());\\n            }\\n            for (int next : map[cur]){\\n                for (int i = 0; i < 26; i++){ // forward the max to the next node\\n                    memo[next][i] = Math.max(memo[next][i], memo[cur][i] + (i == colors.charAt(next)-\\'a\\'? 1 : 0));\\n                }\\n                if (--indg[next]==0){\\n                    queue.offer(next);\\n                }\\n            }\\n        }\\n        return n==0?ans:-1;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```Java\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n = colors.length();\\n        List<Integer>[] map = new ArrayList[n];\\n        Arrays.setAll(map, o -> new ArrayList<>());\\n        int[] indg = new int[n];\\n        for (int[] e : edges){\\n            map[e[0]].add(e[1]);\\n            indg[e[1]]++;\\n        }\\n        int[][] memo = new int[n][26];\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++){\\n            if (indg[i] == 0){\\n                memo[i][colors.charAt(i)-\\'a\\']++; // base case\\n                queue.offer(i);\\n            }\\n        }\\n\\n        int ans = 0;\\n        while(!queue.isEmpty()){\\n            --n;\\n            int cur = queue.poll();\\n            if (map[cur].size()==0){ // update ans at leave nodes\\n                ans = Math.max(ans, Arrays.stream(memo[cur]).max().getAsInt());\\n            }\\n            for (int next : map[cur]){\\n                for (int i = 0; i < 26; i++){ // forward the max to the next node\\n                    memo[next][i] = Math.max(memo[next][i], memo[cur][i] + (i == colors.charAt(next)-\\'a\\'? 1 : 0));\\n                }\\n                if (--indg[next]==0){\\n                    queue.offer(next);\\n                }\\n            }\\n        }\\n        return n==0?ans:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229847,
                "title": "c-dfs-easy-solution",
                "content": "DSF SOLUTION ALONG WITH MEMORIZATION\\nTHE IDEA IS FIRST WE TRANSVERSE ALL THE CHILDS OF A NODE ( i ) AFTER THAT\\nTHE WE UPADTE THE MEMORY RELATED TO NODE i \\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>gr[],vector<vector<int>>&dp,int i,vector<int>&vis,vector<int>&cyc,string&col,int&f)\\n    {\\n        vis[i]=1;\\n        cyc[i]=1;\\n        \\n        for(int j=0;j<gr[i].size();j++)\\n        {\\n            if(!vis[gr[i][j]])\\n            {\\n               dfs(gr,dp,gr[i][j],vis,cyc,col,f);\\n                if(f)\\n                return;\\n            }\\n            else if(cyc[gr[i][j]])\\n            {\\n                f=1;\\n                return;\\n            }\\n\\t\\t\\t//Upadting memory for ith node\\n            for(int k=0;k<26;k++)\\n                dp[i][k]=max(dp[i][k],dp[gr[i][j]][k]);\\n        }\\n        dp[i][col[i]-\\'a\\']++;\\n        cyc[i]=0;\\n        return;\\n    }\\n    int largestPathValue(string col, vector<vector<int>>& ed) {\\n        int n=col.length();\\n        int m=ed.size();\\n        vector<int>gr[n];\\n        //creating graph\\n        for(int i=0;i<m;i++)\\n            gr[ed[i][0]].push_back(ed[i][1]);\\n        \\n        vector<vector<int>>dp(n,vector<int>(26));\\n        \\n        vector<int>vis(n);\\n        vector<int>cyc(n);\\n        //flag to indicate if cycle is found or not\\n        int f=0;\\n        //calling dsf on each unvisted node\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            dfs(gr,dp,i,vis,cyc,col,f);\\n            if(f)\\n            return -1;\\n        }  \\n        \\n        int ans=0;\\n        //find answere\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n                ans=max(ans,dp[i][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>gr[],vector<vector<int>>&dp,int i,vector<int>&vis,vector<int>&cyc,string&col,int&f)\\n    {\\n        vis[i]=1;\\n        cyc[i]=1;\\n        \\n        for(int j=0;j<gr[i].size();j++)\\n        {\\n            if(!vis[gr[i][j]])\\n            {\\n               dfs(gr,dp,gr[i][j],vis,cyc,col,f);\\n                if(f)\\n                return;\\n            }\\n            else if(cyc[gr[i][j]])\\n            {\\n                f=1;\\n                return;\\n            }\\n\\t\\t\\t//Upadting memory for ith node\\n            for(int k=0;k<26;k++)\\n                dp[i][k]=max(dp[i][k],dp[gr[i][j]][k]);\\n        }\\n        dp[i][col[i]-\\'a\\']++;\\n        cyc[i]=0;\\n        return;\\n    }\\n    int largestPathValue(string col, vector<vector<int>>& ed) {\\n        int n=col.length();\\n        int m=ed.size();\\n        vector<int>gr[n];\\n        //creating graph\\n        for(int i=0;i<m;i++)\\n            gr[ed[i][0]].push_back(ed[i][1]);\\n        \\n        vector<vector<int>>dp(n,vector<int>(26));\\n        \\n        vector<int>vis(n);\\n        vector<int>cyc(n);\\n        //flag to indicate if cycle is found or not\\n        int f=0;\\n        //calling dsf on each unvisted node\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            dfs(gr,dp,i,vis,cyc,col,f);\\n            if(f)\\n            return -1;\\n        }  \\n        \\n        int ans=0;\\n        //find answere\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n                ans=max(ans,dp[i][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203961,
                "title": "java-dfs-top-down-dp",
                "content": "```\\n\\nclass Solution\\n{\\n    \\n    int max;\\n    \\n    boolean hasCycle;\\n    \\n    HashMap<Integer, HashMap<Character, Integer>> dp;\\n    \\n    \\n    public int largestPathValue(String colors, int[][] edges) \\n    {\\n      \\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        \\n        int n = colors.length();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int ar[] : edges)\\n        {\\n            int a = ar[0];\\n            \\n            int b = ar[1];\\n            \\n            graph.get(a).add(b);\\n        }\\n        \\n        boolean vis[] = new boolean[n];\\n        \\n        max = -1;\\n        \\n        hasCycle = false;\\n        \\n        dp = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            dfs(i, graph, colors, vis);\\n            \\n            if(hasCycle)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        \\n        return max;\\n       \\n        \\n    }\\n    \\n    \\n    \\n    public HashMap<Character, Integer> dfs(int curr, ArrayList<ArrayList<Integer>> graph, String colors, boolean vis[])\\n    {\\n       if(vis[curr])\\n       {\\n           hasCycle = true;\\n           \\n           return new HashMap<>();\\n       }\\n        \\n       if(dp.get(curr) != null)\\n       {\\n           return dp.get(curr);\\n       }\\n        \\n        vis[curr] = true;\\n        \\n        ArrayList<Integer> neb = graph.get(curr);\\n        \\n        HashMap<Character, Integer> currMap = new HashMap<>();\\n        \\n        if(neb != null && !neb.isEmpty())\\n        {\\n            for(int i : neb)\\n            {\\n                HashMap<Character, Integer> resMap = dfs(i, graph, colors, vis);\\n                \\n                if(hasCycle)\\n                {\\n                    return currMap;\\n                }\\n                \\n                for(char c : resMap.keySet())\\n                {\\n                    int val = resMap.get(c);\\n                    \\n                    int currVal = currMap.getOrDefault(c, 0);\\n                    \\n                    currVal = Math.max(currVal, val);\\n                    \\n                    currMap.put(c, currVal);\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        int currentNodeColorCount = currMap.getOrDefault(colors.charAt(curr), 0);\\n        \\n        currMap.put(colors.charAt(curr), currentNodeColorCount + 1);\\n        \\n        max = Math.max(currentNodeColorCount + 1, max);\\n        \\n        vis[curr] = false;\\n        \\n        dp.put(curr, currMap);\\n        \\n        return currMap;\\n        \\n        \\n        \\n    }\\n    \\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\n    \\n    int max;\\n    \\n    boolean hasCycle;\\n    \\n    HashMap<Integer, HashMap<Character, Integer>> dp;\\n    \\n    \\n    public int largestPathValue(String colors, int[][] edges) \\n    {\\n      \\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        \\n        int n = colors.length();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int ar[] : edges)\\n        {\\n            int a = ar[0];\\n            \\n            int b = ar[1];\\n            \\n            graph.get(a).add(b);\\n        }\\n        \\n        boolean vis[] = new boolean[n];\\n        \\n        max = -1;\\n        \\n        hasCycle = false;\\n        \\n        dp = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            dfs(i, graph, colors, vis);\\n            \\n            if(hasCycle)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        \\n        return max;\\n       \\n        \\n    }\\n    \\n    \\n    \\n    public HashMap<Character, Integer> dfs(int curr, ArrayList<ArrayList<Integer>> graph, String colors, boolean vis[])\\n    {\\n       if(vis[curr])\\n       {\\n           hasCycle = true;\\n           \\n           return new HashMap<>();\\n       }\\n        \\n       if(dp.get(curr) != null)\\n       {\\n           return dp.get(curr);\\n       }\\n        \\n        vis[curr] = true;\\n        \\n        ArrayList<Integer> neb = graph.get(curr);\\n        \\n        HashMap<Character, Integer> currMap = new HashMap<>();\\n        \\n        if(neb != null && !neb.isEmpty())\\n        {\\n            for(int i : neb)\\n            {\\n                HashMap<Character, Integer> resMap = dfs(i, graph, colors, vis);\\n                \\n                if(hasCycle)\\n                {\\n                    return currMap;\\n                }\\n                \\n                for(char c : resMap.keySet())\\n                {\\n                    int val = resMap.get(c);\\n                    \\n                    int currVal = currMap.getOrDefault(c, 0);\\n                    \\n                    currVal = Math.max(currVal, val);\\n                    \\n                    currMap.put(c, currVal);\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        int currentNodeColorCount = currMap.getOrDefault(colors.charAt(curr), 0);\\n        \\n        currMap.put(colors.charAt(curr), currentNodeColorCount + 1);\\n        \\n        max = Math.max(currentNodeColorCount + 1, max);\\n        \\n        vis[curr] = false;\\n        \\n        dp.put(curr, currMap);\\n        \\n        return currMap;\\n        \\n        \\n        \\n    }\\n    \\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200383,
                "title": "python-short-topological-traversal-100",
                "content": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n = len(colors)\\n        G = defaultdict(set)\\n        inDeg = [0] * n\\n        for a, b in edges: \\n            G[a].add(b)\\n            inDeg[b] += 1\\n        Queue = [i for i in range(n) if inDeg[i]==0]\\n        dic = {i:defaultdict(int) for i in range(n)} #max freq of each colors over all paths ending at i\\n        visitCount, ans = 0, 1\\n        while Queue:\\n            i = Queue.pop()\\n            dic[i][colors[i]] += 1\\n            ans = max(ans, max(dic[i].values()))\\n            visitCount += 1\\n            for j in G[i]:\\n                for x in dic[i]: dic[j][x] = max(dic[i][x], dic[j][x])\\n                inDeg[j] -= 1\\n                if inDeg[j] == 0: Queue.append(j)\\n        return ans if visitCount == n else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n = len(colors)\\n        G = defaultdict(set)\\n        inDeg = [0] * n\\n        for a, b in edges: \\n            G[a].add(b)\\n            inDeg[b] += 1\\n        Queue = [i for i in range(n) if inDeg[i]==0]\\n        dic = {i:defaultdict(int) for i in range(n)} #max freq of each colors over all paths ending at i\\n        visitCount, ans = 0, 1\\n        while Queue:\\n            i = Queue.pop()\\n            dic[i][colors[i]] += 1\\n            ans = max(ans, max(dic[i].values()))\\n            visitCount += 1\\n            for j in G[i]:\\n                for x in dic[i]: dic[j][x] = max(dic[i][x], dic[j][x])\\n                inDeg[j] -= 1\\n                if inDeg[j] == 0: Queue.append(j)\\n        return ans if visitCount == n else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199847,
                "title": "python3-dp",
                "content": "\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        graph = {}\\n        indeg = [0] * len(colors)\\n        for u, v in edges: \\n            indeg[v] += 1\\n            graph.setdefault(u, []).append(v)\\n            \\n        # Kahn\\'s algo\\n        roots = [x for x in range(len(colors)) if indeg[x] == 0]\\n        \\n        stack = roots.copy()\\n        nodes = []\\n        while stack: \\n            x = stack.pop()\\n            nodes.append(x)\\n            for xx in graph.get(x, []):\\n                indeg[xx] -= 1\\n                if indeg[xx] == 0: stack.append(xx)\\n        if len(nodes) < len(colors): return -1 # cycle detected \\n        \\n        @cache\\n        def fn(x): \\n            \"\"\"Return distribution of (maximized) colors at given node.\"\"\"\\n            ans = [0]*26\\n            ans[ord(colors[x]) - 97] = 1\\n            for xx in graph.get(x, []): \\n                val = fn(xx)\\n                for i in range(26): \\n                    if i == ord(colors[x]) - 97: ans[i] = max(ans[i], 1 + val[i])\\n                    else: ans[i] = max(ans[i], val[i])\\n            return ans \\n        \\n        ans = [0]*26 \\n        for root in roots: \\n            val = fn(root)\\n            for i in range(26): ans[i] = max(ans[i], val[i])\\n        return max(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        graph = {}\\n        indeg = [0] * len(colors)\\n        for u, v in edges: \\n            indeg[v] += 1\\n            graph.setdefault(u, []).append(v)\\n            \\n        # Kahn\\'s algo\\n        roots = [x for x in range(len(colors)) if indeg[x] == 0]\\n        \\n        stack = roots.copy()\\n        nodes = []\\n        while stack: \\n            x = stack.pop()\\n            nodes.append(x)\\n            for xx in graph.get(x, []):\\n                indeg[xx] -= 1\\n                if indeg[xx] == 0: stack.append(xx)\\n        if len(nodes) < len(colors): return -1 # cycle detected \\n        \\n        @cache\\n        def fn(x): \\n            \"\"\"Return distribution of (maximized) colors at given node.\"\"\"\\n            ans = [0]*26\\n            ans[ord(colors[x]) - 97] = 1\\n            for xx in graph.get(x, []): \\n                val = fn(xx)\\n                for i in range(26): \\n                    if i == ord(colors[x]) - 97: ans[i] = max(ans[i], 1 + val[i])\\n                    else: ans[i] = max(ans[i], val[i])\\n            return ans \\n        \\n        ans = [0]*26 \\n        for root in roots: \\n            val = fn(root)\\n            for i in range(26): ans[i] = max(ans[i], val[i])\\n        return max(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198829,
                "title": "python-clean-well-not-simple",
                "content": "As usual, topo sort the directed graph in the init process.\\n\\nThen, either DFS to get the max result in the last layer of recursion, or BFS and preserve the current largest color value.\\n\\nTBH I wasn\\'t about to pull off the DP table idea during the contest - took me another 40 minutes to figure that out!\\n\\n```python\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n = len(colors)\\n        # Convert the colors from chars to index 0:a - 25:z\\n        colors = [ord(color)-ord(\\'a\\') for color in colors]\\n        \\n        # Topo sort the graph\\n        graph = [[] for _ in range(n)]\\n        degree = [0] * n\\n        for prev, curr in edges:\\n            graph[prev].append(curr)\\n            degree[curr] += 1\\n        \\n        dp = [[0 for _ in range(26)] for _ in range(n)]\\n        q = deque([node for node in range(n) if degree[node] == 0])\\n        \\n        count = 0\\n        result = -1\\n        while q:\\n            curr = q.popleft()\\n            dp[curr][colors[curr]] += 1\\n            result = max(result, dp[curr][colors[curr]])\\n            count += 1\\n            if count == n:\\n                # Cycle detected, or reached the largest node index\\n                break\\n            for neighbor in graph[curr]:\\n                for i in range(26):\\n                    # Pass the largest color value to the neighbor\\n                    dp[neighbor][i] = max(dp[neighbor][i], dp[curr][i])\\n                degree[neighbor] -= 1\\n                if degree[neighbor] == 0:\\n                    q.append(neighbor)\\n            \\n        if count < n or q:\\n            return -1\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n = len(colors)\\n        # Convert the colors from chars to index 0:a - 25:z\\n        colors = [ord(color)-ord(\\'a\\') for color in colors]\\n        \\n        # Topo sort the graph\\n        graph = [[] for _ in range(n)]\\n        degree = [0] * n\\n        for prev, curr in edges:\\n            graph[prev].append(curr)\\n            degree[curr] += 1\\n        \\n        dp = [[0 for _ in range(26)] for _ in range(n)]\\n        q = deque([node for node in range(n) if degree[node] == 0])\\n        \\n        count = 0\\n        result = -1\\n        while q:\\n            curr = q.popleft()\\n            dp[curr][colors[curr]] += 1\\n            result = max(result, dp[curr][colors[curr]])\\n            count += 1\\n            if count == n:\\n                # Cycle detected, or reached the largest node index\\n                break\\n            for neighbor in graph[curr]:\\n                for i in range(26):\\n                    # Pass the largest color value to the neighbor\\n                    dp[neighbor][i] = max(dp[neighbor][i], dp[curr][i])\\n                degree[neighbor] -= 1\\n                if degree[neighbor] == 0:\\n                    q.append(neighbor)\\n            \\n        if count < n or q:\\n            return -1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399711,
                "title": "python3-easy-solution-beats-99-8",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n\\r\\n        # Build the graph and calculate the indegree of each node.\\r\\n        graph = collections.defaultdict(list)\\r\\n        indegree = [0] * len(colors)\\r\\n        for u, v in edges:\\r\\n            graph[v].append(u)\\r\\n            indegree[u] += 1\\r\\n\\r\\n        # Initialize the count dictionary for each node and the queue with nodes\\r\\n        # that have zero indegree.\\r\\n        count = [collections.defaultdict(int) for _ in range(n)]\\r\\n        q = collections.deque(filter(lambda i: not indegree[i], range(n)))\\r\\n\\r\\n        # Traverse the graph using the queue.\\r\\n        seen = 0\\r\\n        ans = 0\\r\\n        while q:\\r\\n            curr = q.popleft()\\r\\n            count[curr][colors[curr]] += 1\\r\\n            ans = max(ans, count[curr][colors[curr]])\\r\\n            seen += 1\\r\\n\\r\\n            # Update the count dictionary for each neighbor of the current node.\\r\\n            for v in graph[curr]:\\r\\n                for c in count[curr]:\\r\\n                    count[v][c] = max(count[v][c], count[curr][c])\\r\\n                indegree[v] -= 1\\r\\n                if indegree[v] == 0:\\r\\n                    q.append(v)\\r\\n\\r\\n        # If we have not seen all nodes, there is a cycle in the graph.\\r\\n        if seen < n:\\r\\n            return -1\\r\\n        return ans\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n\\r\\n        # Build the graph and calculate the indegree of each node.\\r\\n        graph = collections.defaultdict(list)\\r\\n        indegree = [0] * len(colors)\\r\\n        for u, v in edges:\\r\\n            graph[v].append(u)\\r\\n            indegree[u] += 1\\r\\n\\r\\n        # Initialize the count dictionary for each node and the queue with nodes\\r\\n        # that have zero indegree.\\r\\n        count = [collections.defaultdict(int) for _ in range(n)]\\r\\n        q = collections.deque(filter(lambda i: not indegree[i], range(n)))\\r\\n\\r\\n        # Traverse the graph using the queue.\\r\\n        seen = 0\\r\\n        ans = 0\\r\\n        while q:\\r\\n            curr = q.popleft()\\r\\n            count[curr][colors[curr]] += 1\\r\\n            ans = max(ans, count[curr][colors[curr]])\\r\\n            seen += 1\\r\\n\\r\\n            # Update the count dictionary for each neighbor of the current node.\\r\\n            for v in graph[curr]:\\r\\n                for c in count[curr]:\\r\\n                    count[v][c] = max(count[v][c], count[curr][c])\\r\\n                indegree[v] -= 1\\r\\n                if indegree[v] == 0:\\r\\n                    q.append(v)\\r\\n\\r\\n        # If we have not seen all nodes, there is a cycle in the graph.\\r\\n        if seen < n:\\r\\n            return -1\\r\\n        return ans\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398905,
                "title": "typescript-javascript-easy-to-understand-solution",
                "content": "This is a long read, but I hope I have broken it up into digestible pieces so that it is easy to understand.\\r\\n\\r\\n# Intuition\\r\\nThis problem can be split into 2 main questions:\\r\\n1. Is the graph a valid Directed Acyclic Graph (DAG)?\\r\\n2. What is the longest color set?\\r\\n\\r\\nAs such, our approach will solve these two problems separately. If the question to #1 is false, then we always return -1.\\r\\n\\r\\nFor #2, we will need to consider that a node can have multiple children but also have multiple parents. Here is an example, where each node and its color are represented thusly: `1a` where `1` is the node, and `a` is the color.\\r\\n\\r\\n```\\r\\n                    0a\\r\\n                 /      \\\\\\r\\n                1b      4b\\r\\n                |       |\\r\\n                2a      5a\\r\\n                |       |\\r\\n                3a      6b\\r\\n                  \\\\    /\\r\\n                    7a\\r\\n```\\r\\nIn the example above, there are two paths to consider for the color set `a` at node `0`, left and right. We know that the left path will give us a higher number for color set `a`, and the right path will give us a higher number for color set `b`. Thus, at each node, we will need to compare all the children\\'s respective color sets. That is, node `0` needs to compare `1`\\'s `a` with `4`\\'s `a`, then compare `1`\\'s `b` with `4`\\'s `b`, and so on; then `0` will finally add its own color which results in the following color set at node `0`:\\r\\n```typescript\\r\\nNode 0: {\\r\\n  a: 4, // 3 from left branch + 0\\'s a\\r\\n  b: 2, // From the right branch\\r\\n}\\r\\n```\\r\\n\\r\\n#### Problem\\r\\nOne question is, how do we know where the start of the graph is? The answer to that is there is no specific start to the graph, nor will we ever know if there is one. However, Topological Sort is perfect for these kinds of DAG problems, since we can memoize the answer at each node. This allows us to choose any random node and memoize the answer to that node, then move to another random node. If another random node\\'s children happen to be a previously traversed node, we have memoized so we do not need to re-traverse and re-calculate. The result will still be a time complexity of O(V + E). Thus, we will be using topological sort to answer both questions above.\\r\\n\\r\\n# Approach\\r\\nAs mentioned above, we will separate the question into two main parts. However, before doing that, we need an Adjacency List so we can easily traverse our graph. That will be our very first step before tackling the other two problems.\\r\\n\\r\\n### Step 1: Create adjacency list - output == `graph`\\r\\nThis step is quite basic. Just loop through the edges and create a hashmap of nodes to arrays of children. The output of this step will take the following shape:\\r\\n```typescript\\r\\n{\\r\\n  [node: number]: number[]\\r\\n}\\r\\n```\\r\\n\\r\\nHere is an example output:\\r\\nExample Graph 1<a id=\"example-graph-1\"></a>\\r\\n```typescript\\r\\n{\\r\\n  0: [],\\r\\n  1: [2, 3],\\r\\n  2: [3],\\r\\n  3: [4, 5],\\r\\n  4: [5],\\r\\n  5: [],\\r\\n}\\r\\n```\\r\\n\\r\\n### Step 2: Is it a valid DAG?\\r\\nIn this step, we use topological sort to determine whether the graph is a valid DAG. As an overview, topological sort means to pick any node and traverse the graph and \"remember\" the output of that traversal. For example, in our [Example Graph 1](#user-content-example-graph-1) above, we could pick node 4 first and determine that from node 4, the graph is valid, while memoizing for node 4 & 5. Then we can choose node 3, which goes to both node 4 & 5, which we have memoized to be valid. Therefore node 3 is also valid; we memoize that and continue choosing a random node after.\\r\\n\\r\\n###### Steps Overview of Step 2\\r\\n1. Loop through all nodes in `graph` (they are the keys in `graph`)\\r\\n2. At each node, ask the question [\"is the graph a valid DAG from this node?\"](#user-content-is-valid-graph-dfs-approach)\\r\\n  - If not (a cycle has been found) return `-1` right away\\r\\n  - If it is, continue the loop\\r\\n\\r\\n###### Steps for \"is the graph a valid DAG from this node?\"<a id=\"is-valid-graph-dfs-approach\"></a>\\r\\nThis step uses DFS to traverse the graph. \\r\\n- Have a permanent memoized `nodeValidMemo` which stores information about whether the graph starting from `node` is a valid DAG. This is _not necessary_, but speeds up our traversals.\\r\\n- Have a \"temporary\" memoized `traversed` which stores information about whether our current run has seen a specific node before. This is _strictly necessary_, as this will determine if there is a cycle. __It is important to use backtracking on this cache!__\\r\\n- Base cases:\\r\\n  - If traversed, there is a cycle; return false.\\r\\n  - If `nodeValidMemo[node] == true`, then we have traversed `node` before and determined it is a valid DAG starting from `node`. Do not bother traversing any futher; return true.\\r\\n\\r\\n1. Set `traversed[node]` to true\\r\\n2. Loop through children of current node\\r\\n3. At each child, recurse\\r\\n  - If a cycle is found within the child, then this node is also invalid. Break out of the loop and stop all traversals. (We need to return `-1`)\\r\\n4. If we\\'ve traversed all children, backtrack `traversed[node]` and set `nodeValidMemo[node]`\\r\\n\\r\\n### Step 3: What is the longest color set?\\r\\nIf Step 2 has passed, then we need not worry about cycles at this point. Pundits will point out that we could technically do this step at step 2, but as this only multiples the complexity by a factor of 2, the time and space complexity remain the same, but it is much easier to solve Step 2 & Step 3 separately. Thus, we will solve them separately in this solution.\\r\\n\\r\\nStep 3 will similarly use topological sort to determine what the longest set at each node is. We can choose a random node, determine what the longest set was at this node, and record it in a memo. If we choose an upstream node later on and find this node again, we will simply use this node\\'s memo instead of traversing again.\\r\\n\\r\\nEach node contains the following information: the longest length of each color starting from this node, as well as the longest color set starting from this node.\\r\\n\\r\\nThe object will have the following shape:<a id=\"node-colors-graph-shape\"></a>\\r\\n```typescript\\r\\ninterface ColorsGraph {\\r\\n  [color: string]: number; // color is a single letter\\r\\n  longest: number; // Represents the longest color set at this node. This is to prevent us from looping another 26 times.\\r\\n}\\r\\n\\r\\ninterface NodeColorsGraph {\\r\\n  [node: number]: ColorsGraph\\r\\n}\\r\\n```\\r\\n\\r\\nExample object 2:<a id=\"example-object-2\"></a>\\r\\n```\\r\\n{\\r\\n  3: {\\r\\n    a: 3,\\r\\n    b: 1,\\r\\n    c: 1,\\r\\n    longest: 3,\\r\\n  },\\r\\n  4: {\\r\\n    a: 1,\\r\\n    b: 2,\\r\\n    c: 5,\\r\\n    longest: 5,\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n###### Steps\\r\\n1. Loop through all nodes in `graph` (they are the keys in `graph`)\\r\\n2. At each node, call the recursive function that traverses the node.\\r\\n3. After all nodes have been traversed, return the memoized `longest` color set\\r\\n\\r\\n###### Within recursive function<a id=\"find-longest-color-set\"></a>\\r\\n1. Base case == no children (do not need to account for this)\\r\\n2. Base case == found a memoized set of colors (we\\'ve traversed this node before)\\r\\n3. Loop through children and recursively call function starting at each child\\r\\n4. After each child returns a [ColorsGraph](#user-content-node-colors-graph-shape), compare it to every other child\\'s color graph and get the longest of each. For example, if we use [Example Object 2](#user-content-example-object-2) above, and node 3 & 4 were both children of node 2, then node 2 would use `a == 5` from node 3, and `b == 2` from node 4, and `c == 5` from node 4. This is because we want to take the longest color set, regardless of the branch taken, and pass it up stream in case node 2 is a child of any other nodes.\\r\\n5. After looping through children, add this node\\'s color to the color graph we were building from step 4.\\r\\n6. Update the longest color set\\r\\n7. Return the `ColorsGraph` of this node.\\r\\n\\r\\n# Complexity\\r\\nV = number of nodes (vertices)\\r\\nE = number of edges\\r\\n- Time complexity:\\r\\n  - Step 1: O(E)\\r\\n  - Step 2: O(V + E)\\r\\n  - Step 3: O(26V + E)\\r\\n  - All together = O(E + V + E + 26V + E) -> O(27V + 3E) -> O(V + E)\\r\\n\\r\\n- Space complexity:\\r\\n  - Step 1: O(V + E)\\r\\n  - Step 2: O(3V)\\r\\n  - Step 3: O(26V)\\r\\n  - All together = O(V + E + 3V + 26V) -> O(30V + E) -> O(V + E)\\r\\n\\r\\n# Code\\r\\n### Step 1: Create adjacency list\\r\\n```typescript\\r\\ninterface AdjList {\\r\\n    [node: number]: number[];\\r\\n}\\r\\n\\r\\nfunction createAdjList(edges: number[][]): AdjList {\\r\\n    const graph: AdjList = {};\\r\\n    for (let [node1, node2] of edges) {\\r\\n        if (graph[node1] == null) {\\r\\n            graph[node1] = [];\\r\\n        }\\r\\n        if (graph[node2] == null) {\\r\\n            graph[node2] = [];\\r\\n        }\\r\\n\\r\\n        graph[node1].push(node2);\\r\\n    }\\r\\n\\r\\n    return graph;\\r\\n}\\r\\n```\\r\\n\\r\\n### Step 2: [Validate is DAG](#user-content-is-valid-graph-dfs-approach)\\r\\n```typescript\\r\\nfunction isValidGraph(\\r\\n    graph: AdjList,\\r\\n    node: number,\\r\\n    traversed: { [node: number]: boolean },\\r\\n    nodeValidMemo: { [node: number]: boolean },\\r\\n): boolean {\\r\\n    if (traversed[node]) {\\r\\n        return false;\\r\\n    }\\r\\n    if (nodeValidMemo[node]) {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    traversed[node] = true;\\r\\n    const neighbors = graph[node];\\r\\n    let isValid = true;\\r\\n    for (const neighbor of neighbors) {\\r\\n        const _isValid = isValidGraph(graph, neighbor, traversed, nodeValidMemo);\\r\\n        if (!_isValid) {\\r\\n            isValid = false;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    traversed[node] = false;\\r\\n    nodeValidMemo[node] = true;\\r\\n\\r\\n    return isValid;\\r\\n}\\r\\n```\\r\\n\\r\\n### Step 3: [Get longest color set at each node](#user-content-find-longest-color-set)\\r\\n```typescript\\r\\ninterface ColorsGraph {\\r\\n    [color: string]: number;\\r\\n    longest: number;\\r\\n}\\r\\n\\r\\ninterface NodeColorsGraph {\\r\\n    [node: number]: ColorsGraph;\\r\\n}\\r\\n\\r\\nfunction combineColorGraphs(\\r\\n    node1ColorGraph: ColorsGraph,\\r\\n    node2ColorGraph: ColorsGraph,\\r\\n): void {\\r\\n    for (const color of Object.keys(node2ColorGraph)) {\\r\\n        if (node1ColorGraph[color] == null) {\\r\\n            node1ColorGraph[color] = 0;\\r\\n        }\\r\\n        if (node2ColorGraph[color] > node1ColorGraph[color]) {\\r\\n            node1ColorGraph[color] = node2ColorGraph[color];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction findLongestColors(\\r\\n    colors: string,\\r\\n    graph: AdjList,\\r\\n    node: number,\\r\\n    nodeColorsGraph: NodeColorsGraph,\\r\\n    trueLongest: { longest: number },\\r\\n): ColorsGraph {\\r\\n    if (nodeColorsGraph[node] != null) {\\r\\n        // This node\\'s been traversed before, return memoized info\\r\\n        return nodeColorsGraph[node];\\r\\n    }\\r\\n\\r\\n    const currentNodeColorGraph = { longest: 0 };\\r\\n    nodeColorsGraph[node] = currentNodeColorGraph;\\r\\n\\r\\n    // Recursively get the ColorsGraph of each child\\r\\n    for (const neighbor of graph[node]) {\\r\\n        const neighborColorsGraph = findLongestColors(colors, graph, neighbor, nodeColorsGraph, trueLongest);\\r\\n\\r\\n        // Compare all children\\'s with each other\\r\\n        combineColorGraphs(currentNodeColorGraph, neighborColorsGraph);\\r\\n    }\\r\\n\\r\\n    // Add this node\\'s color to `currentNodeColorGraph`\\r\\n    const color = colors[node];\\r\\n    if (currentNodeColorGraph[color] == null) {\\r\\n        currentNodeColorGraph[color] = 0;\\r\\n    }\\r\\n    currentNodeColorGraph[color]++;\\r\\n\\r\\n    // Memoize the longest\\r\\n    for (const _color of Object.keys(currentNodeColorGraph)) {\\r\\n        if (_color === \"longest\") {\\r\\n            continue;\\r\\n        }\\r\\n        if (currentNodeColorGraph[_color] > currentNodeColorGraph.longest) {\\r\\n            currentNodeColorGraph.longest = currentNodeColorGraph[_color];\\r\\n            if (trueLongest.longest < currentNodeColorGraph.longest) {\\r\\n                trueLongest.longest = currentNodeColorGraph.longest\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return currentNodeColorGraph;\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\n### All steps combined\\r\\n```typescript\\r\\nfunction largestPathValue(colors: string, edges: number[][]): number {\\r\\n    // Step 1: Create adjacency list\\r\\n    const graph = createAdjList(edges);\\r\\n\\r\\n    // Step 2: Verify the graph is a valid directed acyclic graph (DAG)\\r\\n    const nodes = Object.keys(graph);\\r\\n    const nodeValidMemo = {};\\r\\n    for (const node of nodes) {\\r\\n        const isValid = isValidGraph(graph, Number(node), {}, nodeValidMemo);\\r\\n        if (!isValid) {\\r\\n            return -1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Step 3: Find the longest colors in the DAG at each node\\r\\n    const nodeColorsGraph = {};\\r\\n    // `trueLongest` is not strictly necessary, but helps prevent us to loop one more time to make comparisons of all colors in all nodes\\r\\n    const trueLongest = { longest: 1 }\\r\\n    for (const node of nodes) {\\r\\n        findLongestColors(\\r\\n            colors,\\r\\n            graph,\\r\\n            Number(node),\\r\\n            nodeColorsGraph,\\r\\n            trueLongest\\r\\n        );\\r\\n    }\\r\\n\\r\\n    return trueLongest.longest;\\r\\n}\\r\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\r\\n                    0a\\r\\n                 /      \\\\\\r\\n                1b      4b\\r\\n                |       |\\r\\n                2a      5a\\r\\n                |       |\\r\\n                3a      6b\\r\\n                  \\\\    /\\r\\n                    7a\\r\\n```\n```typescript\\r\\nNode 0: {\\r\\n  a: 4, // 3 from left branch + 0\\'s a\\r\\n  b: 2, // From the right branch\\r\\n}\\r\\n```\n```typescript\\r\\n{\\r\\n  [node: number]: number[]\\r\\n}\\r\\n```\n```typescript\\r\\n{\\r\\n  0: [],\\r\\n  1: [2, 3],\\r\\n  2: [3],\\r\\n  3: [4, 5],\\r\\n  4: [5],\\r\\n  5: [],\\r\\n}\\r\\n```\n```typescript\\r\\ninterface ColorsGraph {\\r\\n  [color: string]: number; // color is a single letter\\r\\n  longest: number; // Represents the longest color set at this node. This is to prevent us from looping another 26 times.\\r\\n}\\r\\n\\r\\ninterface NodeColorsGraph {\\r\\n  [node: number]: ColorsGraph\\r\\n}\\r\\n```\n```\\r\\n{\\r\\n  3: {\\r\\n    a: 3,\\r\\n    b: 1,\\r\\n    c: 1,\\r\\n    longest: 3,\\r\\n  },\\r\\n  4: {\\r\\n    a: 1,\\r\\n    b: 2,\\r\\n    c: 5,\\r\\n    longest: 5,\\r\\n  }\\r\\n}\\r\\n```\n```typescript\\r\\ninterface AdjList {\\r\\n    [node: number]: number[];\\r\\n}\\r\\n\\r\\nfunction createAdjList(edges: number[][]): AdjList {\\r\\n    const graph: AdjList = {};\\r\\n    for (let [node1, node2] of edges) {\\r\\n        if (graph[node1] == null) {\\r\\n            graph[node1] = [];\\r\\n        }\\r\\n        if (graph[node2] == null) {\\r\\n            graph[node2] = [];\\r\\n        }\\r\\n\\r\\n        graph[node1].push(node2);\\r\\n    }\\r\\n\\r\\n    return graph;\\r\\n}\\r\\n```\n```typescript\\r\\nfunction isValidGraph(\\r\\n    graph: AdjList,\\r\\n    node: number,\\r\\n    traversed: { [node: number]: boolean },\\r\\n    nodeValidMemo: { [node: number]: boolean },\\r\\n): boolean {\\r\\n    if (traversed[node]) {\\r\\n        return false;\\r\\n    }\\r\\n    if (nodeValidMemo[node]) {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    traversed[node] = true;\\r\\n    const neighbors = graph[node];\\r\\n    let isValid = true;\\r\\n    for (const neighbor of neighbors) {\\r\\n        const _isValid = isValidGraph(graph, neighbor, traversed, nodeValidMemo);\\r\\n        if (!_isValid) {\\r\\n            isValid = false;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    traversed[node] = false;\\r\\n    nodeValidMemo[node] = true;\\r\\n\\r\\n    return isValid;\\r\\n}\\r\\n```\n```typescript\\r\\ninterface ColorsGraph {\\r\\n    [color: string]: number;\\r\\n    longest: number;\\r\\n}\\r\\n\\r\\ninterface NodeColorsGraph {\\r\\n    [node: number]: ColorsGraph;\\r\\n}\\r\\n\\r\\nfunction combineColorGraphs(\\r\\n    node1ColorGraph: ColorsGraph,\\r\\n    node2ColorGraph: ColorsGraph,\\r\\n): void {\\r\\n    for (const color of Object.keys(node2ColorGraph)) {\\r\\n        if (node1ColorGraph[color] == null) {\\r\\n            node1ColorGraph[color] = 0;\\r\\n        }\\r\\n        if (node2ColorGraph[color] > node1ColorGraph[color]) {\\r\\n            node1ColorGraph[color] = node2ColorGraph[color];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction findLongestColors(\\r\\n    colors: string,\\r\\n    graph: AdjList,\\r\\n    node: number,\\r\\n    nodeColorsGraph: NodeColorsGraph,\\r\\n    trueLongest: { longest: number },\\r\\n): ColorsGraph {\\r\\n    if (nodeColorsGraph[node] != null) {\\r\\n        // This node\\'s been traversed before, return memoized info\\r\\n        return nodeColorsGraph[node];\\r\\n    }\\r\\n\\r\\n    const currentNodeColorGraph = { longest: 0 };\\r\\n    nodeColorsGraph[node] = currentNodeColorGraph;\\r\\n\\r\\n    // Recursively get the ColorsGraph of each child\\r\\n    for (const neighbor of graph[node]) {\\r\\n        const neighborColorsGraph = findLongestColors(colors, graph, neighbor, nodeColorsGraph, trueLongest);\\r\\n\\r\\n        // Compare all children\\'s with each other\\r\\n        combineColorGraphs(currentNodeColorGraph, neighborColorsGraph);\\r\\n    }\\r\\n\\r\\n    // Add this node\\'s color to `currentNodeColorGraph`\\r\\n    const color = colors[node];\\r\\n    if (currentNodeColorGraph[color] == null) {\\r\\n        currentNodeColorGraph[color] = 0;\\r\\n    }\\r\\n    currentNodeColorGraph[color]++;\\r\\n\\r\\n    // Memoize the longest\\r\\n    for (const _color of Object.keys(currentNodeColorGraph)) {\\r\\n        if (_color === \"longest\") {\\r\\n            continue;\\r\\n        }\\r\\n        if (currentNodeColorGraph[_color] > currentNodeColorGraph.longest) {\\r\\n            currentNodeColorGraph.longest = currentNodeColorGraph[_color];\\r\\n            if (trueLongest.longest < currentNodeColorGraph.longest) {\\r\\n                trueLongest.longest = currentNodeColorGraph.longest\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return currentNodeColorGraph;\\r\\n}\\r\\n```\n```typescript\\r\\nfunction largestPathValue(colors: string, edges: number[][]): number {\\r\\n    // Step 1: Create adjacency list\\r\\n    const graph = createAdjList(edges);\\r\\n\\r\\n    // Step 2: Verify the graph is a valid directed acyclic graph (DAG)\\r\\n    const nodes = Object.keys(graph);\\r\\n    const nodeValidMemo = {};\\r\\n    for (const node of nodes) {\\r\\n        const isValid = isValidGraph(graph, Number(node), {}, nodeValidMemo);\\r\\n        if (!isValid) {\\r\\n            return -1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Step 3: Find the longest colors in the DAG at each node\\r\\n    const nodeColorsGraph = {};\\r\\n    // `trueLongest` is not strictly necessary, but helps prevent us to loop one more time to make comparisons of all colors in all nodes\\r\\n    const trueLongest = { longest: 1 }\\r\\n    for (const node of nodes) {\\r\\n        findLongestColors(\\r\\n            colors,\\r\\n            graph,\\r\\n            Number(node),\\r\\n            nodeColorsGraph,\\r\\n            trueLongest\\r\\n        );\\r\\n    }\\r\\n\\r\\n    return trueLongest.longest;\\r\\n}\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3398755,
                "title": "topo-sort-kahn-s-w-explanation-time-95-15-space-99-39",
                "content": "# Solution\\r\\nWe are using a topological sort to traverse the directed graph. To do this, we repeatedly queue the nodes with an indegree of 0 for processing. Once we have visited all nodes in this manner, the number of visited nodes should equal the total number of nodes in the graph if there are no cycles present.\\r\\n\\r\\nTo keep track of the largest accumulated colors for each node, we assign a counter to each node. Before visiting a new node, we update its counter to record only the largest number for each color since multiple nodes can lead to the same node in the graph. Then, we add the color of the node to the counter and update the largest color value variable.\\r\\n\\r\\n**Note:** After processing a node, we can pop the counter of the node from `cnters` to save space. This line is not essential for the algorithm to work, but it optimizes space consumption.\\r\\n\\r\\n\\r\\n# Complexity\\r\\nn: number of nodes\\r\\nm: number of edges\\r\\n\\r\\n- Time complexity:\\r\\n$$O(n+m)$$\\r\\n\\r\\n- Space complexity:\\r\\n$$O(n+m)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\nfrom collections import defaultdict, Counter, deque\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        graph, indegree = defaultdict(set), defaultdict(int)\\r\\n        for a, b in edges:\\r\\n            graph[a].add(b)\\r\\n            indegree[b] += 1\\r\\n        \\r\\n        ans = visited = 0\\r\\n        q, cnters = deque([node for node in range(n) if indegree[node] == 0]), defaultdict(Counter)\\r\\n        while q:\\r\\n            node = q.popleft()\\r\\n            visited += 1\\r\\n\\r\\n            cnters[node][colors[node]] += 1\\r\\n            ans = max(ans, cnters[node][colors[node]])\\r\\n\\r\\n            for nei in graph[node]:\\r\\n                for color in cnters[node]:\\r\\n                    cnters[nei][color] = max(cnters[node][color], cnters[nei][color])\\r\\n\\r\\n                indegree[nei] -= 1\\r\\n                if indegree[nei] == 0:\\r\\n                    q.append(nei)\\r\\n\\r\\n            cnters.pop(node)\\r\\n\\r\\n        return ans if visited == n else -1\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nfrom collections import defaultdict, Counter, deque\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        graph, indegree = defaultdict(set), defaultdict(int)\\r\\n        for a, b in edges:\\r\\n            graph[a].add(b)\\r\\n            indegree[b] += 1\\r\\n        \\r\\n        ans = visited = 0\\r\\n        q, cnters = deque([node for node in range(n) if indegree[node] == 0]), defaultdict(Counter)\\r\\n        while q:\\r\\n            node = q.popleft()\\r\\n            visited += 1\\r\\n\\r\\n            cnters[node][colors[node]] += 1\\r\\n            ans = max(ans, cnters[node][colors[node]])\\r\\n\\r\\n            for nei in graph[node]:\\r\\n                for color in cnters[node]:\\r\\n                    cnters[nei][color] = max(cnters[node][color], cnters[nei][color])\\r\\n\\r\\n                indegree[nei] -= 1\\r\\n                if indegree[nei] == 0:\\r\\n                    q.append(nei)\\r\\n\\r\\n            cnters.pop(node)\\r\\n\\r\\n        return ans if visited == n else -1\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398432,
                "title": "c-only-dfs-beats-60",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    void dfs(int node, vector<bool> &vis, vector<vector<int>> &adj, vector<bool> &track, vector<vector<int>> &colorMax, string &colors, int &ans, bool &isCycle) {\\r\\n        vis[node] = true;\\r\\n        \\r\\n        for(int k: adj[node]) {\\r\\n            if (!vis[k]) {\\r\\n                dfs(k, vis, adj, track, colorMax, colors, ans, isCycle);\\r\\n            } else if (!track[k]) isCycle = true;\\r\\n            for(int it=0;it<26;it++) {\\r\\n                colorMax[node][it] = max(colorMax[node][it], colorMax[k][it]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        colorMax[node][colors[node] - \\'a\\'] += 1;\\r\\n        ans = max(ans, colorMax[node][colors[node] - \\'a\\']);\\r\\n        track[node] = true;\\r\\n    }\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.length();\\r\\n        vector<bool> track(n, false);\\r\\n        vector<bool> vis(n, false);\\r\\n        bool isCycle = false;\\r\\n        vector<vector<int>> adj(n);\\r\\n        vector<vector<int>> colorMax(n, vector<int> (26, 0));\\r\\n        int ans = 1;\\r\\n\\r\\n        for(int i=0;i<edges.size();i++) {\\r\\n            adj[edges[i][0]].push_back(edges[i][1]);\\r\\n        }\\r\\n\\r\\n        for(int i=0;i<n;i++) {\\r\\n            if (!vis[i]) {\\r\\n                dfs(i, vis, adj, track, colorMax, colors, ans, isCycle);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (isCycle) return -1;\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```\\r\\n\\r\\nUpvote if you find it helpful :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    void dfs(int node, vector<bool> &vis, vector<vector<int>> &adj, vector<bool> &track, vector<vector<int>> &colorMax, string &colors, int &ans, bool &isCycle) {\\r\\n        vis[node] = true;\\r\\n        \\r\\n        for(int k: adj[node]) {\\r\\n            if (!vis[k]) {\\r\\n                dfs(k, vis, adj, track, colorMax, colors, ans, isCycle);\\r\\n            } else if (!track[k]) isCycle = true;\\r\\n            for(int it=0;it<26;it++) {\\r\\n                colorMax[node][it] = max(colorMax[node][it], colorMax[k][it]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        colorMax[node][colors[node] - \\'a\\'] += 1;\\r\\n        ans = max(ans, colorMax[node][colors[node] - \\'a\\']);\\r\\n        track[node] = true;\\r\\n    }\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.length();\\r\\n        vector<bool> track(n, false);\\r\\n        vector<bool> vis(n, false);\\r\\n        bool isCycle = false;\\r\\n        vector<vector<int>> adj(n);\\r\\n        vector<vector<int>> colorMax(n, vector<int> (26, 0));\\r\\n        int ans = 1;\\r\\n\\r\\n        for(int i=0;i<edges.size();i++) {\\r\\n            adj[edges[i][0]].push_back(edges[i][1]);\\r\\n        }\\r\\n\\r\\n        for(int i=0;i<n;i++) {\\r\\n            if (!vis[i]) {\\r\\n                dfs(i, vis, adj, track, colorMax, colors, ans, isCycle);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (isCycle) return -1;\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398259,
                "title": "dfs-memoization-c",
                "content": "```\\r\\nclass Solution {\\r\\n   unordered_map<int, unordered_map<char, int>> dp;\\r\\n   pair<unordered_map<char, int>, bool> dfs(int node, vector<int> adj[], string &colors, vector<int> &vis, vector<int> &dfsvis) {\\r\\n       vis[node] = dfsvis[node] = 1;\\r\\n       unordered_map<char, int> m;\\r\\n\\r\\n       for(int ad : adj[node]) {\\r\\n           if(!vis[ad]) {\\r\\n               auto r = dfs(ad, adj, colors, vis, dfsvis);\\r\\n               if(r.second) return {m, true};\\r\\n               for(auto i : r.first) m[i.first] = max(m[i.first], i.second);\\r\\n               \\r\\n           }\\r\\n           else {\\r\\n               if(dfsvis[ad]) return {m, true};\\r\\n               for(auto i : dp[ad]) m[i.first] = max(m[i.first], i.second);\\r\\n           }\\r\\n       }\\r\\n       m[colors[node]]++;\\r\\n       dfsvis[node] = 0;\\r\\n       dp[node] = m;\\r\\n       return {m, false};\\r\\n   }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size(), ans = 0;\\r\\n        vector<int> adj[n];\\r\\n        for(auto e : edges) adj[e[0]].push_back(e[1]);\\r\\n\\r\\n        vector<int> vis(n), dfsvis(n);\\r\\n        for(int i=0; i<n; i++) {\\r\\n            if(!vis[i]) {\\r\\n                auto r = dfs(i, adj, colors, vis, dfsvis);\\r\\n                if(r.second) return -1;\\r\\n                for(auto i : r.first) ans = max(ans, i.second);\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n   unordered_map<int, unordered_map<char, int>> dp;\\r\\n   pair<unordered_map<char, int>, bool> dfs(int node, vector<int> adj[], string &colors, vector<int> &vis, vector<int> &dfsvis) {\\r\\n       vis[node] = dfsvis[node] = 1;\\r\\n       unordered_map<char, int> m;\\r\\n\\r\\n       for(int ad : adj[node]) {\\r\\n           if(!vis[ad]) {\\r\\n               auto r = dfs(ad, adj, colors, vis, dfsvis);\\r\\n               if(r.second) return {m, true};\\r\\n               for(auto i : r.first) m[i.first] = max(m[i.first], i.second);\\r\\n               \\r\\n           }\\r\\n           else {\\r\\n               if(dfsvis[ad]) return {m, true};\\r\\n               for(auto i : dp[ad]) m[i.first] = max(m[i.first], i.second);\\r\\n           }\\r\\n       }\\r\\n       m[colors[node]]++;\\r\\n       dfsvis[node] = 0;\\r\\n       dp[node] = m;\\r\\n       return {m, false};\\r\\n   }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size(), ans = 0;\\r\\n        vector<int> adj[n];\\r\\n        for(auto e : edges) adj[e[0]].push_back(e[1]);\\r\\n\\r\\n        vector<int> vis(n), dfsvis(n);\\r\\n        for(int i=0; i<n; i++) {\\r\\n            if(!vis[i]) {\\r\\n                auto r = dfs(i, adj, colors, vis, dfsvis);\\r\\n                if(r.second) return -1;\\r\\n                for(auto i : r.first) ans = max(ans, i.second);\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398039,
                "title": "ruby-leetcode-s-translation",
                "content": "## Leetcode: 1857. Largest Color Value in a Directed Graph.\\n\\n**Ruby: Leetcode\\'s translation.**\\n\\nThis solution is the Leetcode\\'s [solution](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/solution/) translation.\\nRuby code:\\n```Ruby\\n# Leetcode: 1857. Largest Color Value in a Directed Graph.\\n# https://leetcode.com/problems/largest-color-value-in-a-directed-graph/\\n# = = = = = = = = = = = = = = \\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 1050 ms, faster than 100.00% of Ruby online submissions for Largest\\n# Color Value in a Directed Graph.\\n# Memory Usage: 277.7 MB, less than 100.00% of Ruby online submissions for\\n# Largest Color Value in a Directed Graph.\\n# 2023.04.09 Daily Challenge.\\n# @param {String} colors\\n# @param {Integer[][]} edges\\n# @return {Integer}\\ndef largest_path_value(colors, edges)\\n  # Based on:\\n  # https://leetcode.com/problems/largest-color-value-in-a-directed-graph/solution/\\n  n = colors.size\\n  adj = Array.new(n).map{ [] } \\n  indegree = Array.new(n,0)\\n  edges.each do |a,b|\\n    adj[a].push(b)\\n    indegree[b] += 1\\n  end\\n  count = Array.new(n).map{ [0]*26 }\\n  q = []\\n  (0...n).each do |i|\\n    q.push(i) if 0 == indegree[i]\\n  end\\n  answer, nodesSeen = 0 ,0\\n  while !q.empty? \\n    node = q.shift\\n    count[node][colors[node].ord - ?a.ord] += 1\\n    answer = [answer,count[node][colors[node].ord - ?a.ord]].max\\n    nodesSeen += 1\\n    adj[node].each do |neighbor|\\n      (0...26).each do |i|\\n        count[neighbor][i] = [count[neighbor][i],count[node][i]].max\\n      end\\n      indegree[neighbor] -= 1\\n      q.push(neighbor) if 0 == indegree[neighbor]\\n\\n    end\\n  end\\n  return nodesSeen < n ? -1 : answer\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1857. Largest Color Value in a Directed Graph.\\n# https://leetcode.com/problems/largest-color-value-in-a-directed-graph/\\n# = = = = = = = = = = = = = = \\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 1050 ms, faster than 100.00% of Ruby online submissions for Largest\\n# Color Value in a Directed Graph.\\n# Memory Usage: 277.7 MB, less than 100.00% of Ruby online submissions for\\n# Largest Color Value in a Directed Graph.\\n# 2023.04.09 Daily Challenge.\\n# @param {String} colors\\n# @param {Integer[][]} edges\\n# @return {Integer}\\ndef largest_path_value(colors, edges)\\n  # Based on:\\n  # https://leetcode.com/problems/largest-color-value-in-a-directed-graph/solution/\\n  n = colors.size\\n  adj = Array.new(n).map{ [] } \\n  indegree = Array.new(n,0)\\n  edges.each do |a,b|\\n    adj[a].push(b)\\n    indegree[b] += 1\\n  end\\n  count = Array.new(n).map{ [0]*26 }\\n  q = []\\n  (0...n).each do |i|\\n    q.push(i) if 0 == indegree[i]\\n  end\\n  answer, nodesSeen = 0 ,0\\n  while !q.empty? \\n    node = q.shift\\n    count[node][colors[node].ord - ?a.ord] += 1\\n    answer = [answer,count[node][colors[node].ord - ?a.ord]].max\\n    nodesSeen += 1\\n    adj[node].each do |neighbor|\\n      (0...26).each do |i|\\n        count[neighbor][i] = [count[neighbor][i],count[node][i]].max\\n      end\\n      indegree[neighbor] -= 1\\n      q.push(neighbor) if 0 == indegree[neighbor]\\n\\n    end\\n  end\\n  return nodesSeen < n ? -1 : answer\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3397942,
                "title": "beating-67-in-speed-and-my-original-way-i-did-not-know-how-to-id-circles-in-directed-graphs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe path starts with a node without ancestor. If we count the max number of nodes with a certain color in paths starting from a certain node and we traverse with all scenarios, the max count is the results, if no circle. And since colors are at most 26, the problem can be done within O(n) with storing the results. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor checking the circle, I came up with an original way (I did not know if this one is used commonly). To save a placeholder of the argument combo in the hashtable and if we see it again in the downstream recursions (which means a circle occurs), we jump out and return a special value to indicate a circle. If this combo is never seen again in its own downstream recursions, we assign the correct value of the combo in the hashtable. \\nAlso, since I start only with those nodes without ancestor (starting nodes), I need to keep a record of the nodes I have seen when I go along every path. If I cannot traverse all nodes possibly, it means there are some clusters of nodes forming circles without any starting node. In this case, -1 should be returned as well. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n\\n        n = len(colors)\\n        from collections import defaultdict\\n        dic = defaultdict(list)\\n        st = set(range(n))\\n        for x, y in edges:\\n            if x == y: \\n                return -1\\n            if y in st: \\n                st.remove(y)\\n            dic[x].append(y)\\n        if not st: // No starting nodes\\n            return -1\\n        \\n        dic_res = {} // hash table to save the combo\\n        self.res = 0\\n        seen = set() // Keep a record of the nodes I have seen during walking along all possible paths\\n        \\n        def calc2(node, color): \\n            seen.add(node)\\n            if (node, color) in dic_res:\\n                if dic_res[(node, color)] is not None: \\n                    res = dic_res[(node, color)]\\n                    self.res = max(self.res, res)\\n                    return res\\n                else: // Means the combo has been seen before and a circle is there. Jump out the recursion and return None as an indicator\\n                    return None\\n            else: \\n                dic_res[(node, color)] = None // Set a placeholder for later recursions to check\\n                color_node = colors[node]\\n                res = 0\\n                for newnode in dic[node]: \\n                    tmp = calc2(newnode, color)\\n                    if tmp == None: // Same as above, jump out the recursions and return None\\n                        return None\\n                    res = max(res, tmp)\\n                res += color == color_node\\n                self.res = max(res, self.res)\\n                // Only when we reach the very end of the recursions and have not seen any node seen before, we assign the values. Color will not change in the recursions. \\n                dic_res[(node, color)] = res\\n                return res\\n            \\n        for color in set(colors): \\n            for node in st: \\n                res = calc2(node, color)\\n                if res is None: // res is not very useful to us but if it is the indicator - None, there is a circle and we need to return 1\\n                    return -1\\n        if len(seen) < n: // If I have not traversed all nodes, return -1\\n            return -1\\n        return self.res\\n        \\n        \\n                              \\n                        \\n                \\n                \\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n\\n        n = len(colors)\\n        from collections import defaultdict\\n        dic = defaultdict(list)\\n        st = set(range(n))\\n        for x, y in edges:\\n            if x == y: \\n                return -1\\n            if y in st: \\n                st.remove(y)\\n            dic[x].append(y)\\n        if not st: // No starting nodes\\n            return -1\\n        \\n        dic_res = {} // hash table to save the combo\\n        self.res = 0\\n        seen = set() // Keep a record of the nodes I have seen during walking along all possible paths\\n        \\n        def calc2(node, color): \\n            seen.add(node)\\n            if (node, color) in dic_res:\\n                if dic_res[(node, color)] is not None: \\n                    res = dic_res[(node, color)]\\n                    self.res = max(self.res, res)\\n                    return res\\n                else: // Means the combo has been seen before and a circle is there. Jump out the recursion and return None as an indicator\\n                    return None\\n            else: \\n                dic_res[(node, color)] = None // Set a placeholder for later recursions to check\\n                color_node = colors[node]\\n                res = 0\\n                for newnode in dic[node]: \\n                    tmp = calc2(newnode, color)\\n                    if tmp == None: // Same as above, jump out the recursions and return None\\n                        return None\\n                    res = max(res, tmp)\\n                res += color == color_node\\n                self.res = max(res, self.res)\\n                // Only when we reach the very end of the recursions and have not seen any node seen before, we assign the values. Color will not change in the recursions. \\n                dic_res[(node, color)] = res\\n                return res\\n            \\n        for color in set(colors): \\n            for node in st: \\n                res = calc2(node, color)\\n                if res is None: // res is not very useful to us but if it is the indicator - None, there is a circle and we need to return 1\\n                    return -1\\n        if len(seen) < n: // If I have not traversed all nodes, return -1\\n            return -1\\n        return self.res\\n        \\n        \\n                              \\n                        \\n                \\n                \\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397886,
                "title": "solution-in-c",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n  int largestPathValue(string cs, vector<vector<int>>& edges) \\r\\n  {\\r\\n    vector<vector<int>> al(cs.size()), cnt(cs.size(), vector<int>(26));\\r\\n    vector<int> indegrees(cs.size());\\r\\n    for (auto &e: edges) \\r\\n    {\\r\\n        al[e[0]].push_back(e[1]);\\r\\n        ++indegrees[e[1]];\\r\\n    }\\r\\n    vector<int> q;\\r\\n    for (int i = 0; i < cs.size(); ++i)\\r\\n        if (indegrees[i] == 0)\\r\\n            q.push_back(i);\\r\\n    int res = 0, processed = 0;\\r\\n    while (!q.empty()) \\r\\n    {\\r\\n        vector<int> q1;\\r\\n        for (auto i : q) \\r\\n        {\\r\\n            ++processed;\\r\\n            res = max(res, ++cnt[i][cs[i] - \\'a\\']);\\r\\n            for (auto j : al[i]) \\r\\n            {\\r\\n                for (auto k = 0; k < 26; ++k)\\r\\n                    cnt[j][k] = max(cnt[j][k], cnt[i][k]);\\r\\n                if (--indegrees[j] == 0)\\r\\n                    q1.push_back(j);\\r\\n            }\\r\\n        }\\r\\n        swap(q, q1);\\r\\n    }\\r\\n    return processed != cs.size() ? -1 : res;\\r\\n}\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n  int largestPathValue(string cs, vector<vector<int>>& edges) \\r\\n  {\\r\\n    vector<vector<int>> al(cs.size()), cnt(cs.size(), vector<int>(26));\\r\\n    vector<int> indegrees(cs.size());\\r\\n    for (auto &e: edges) \\r\\n    {\\r\\n        al[e[0]].push_back(e[1]);\\r\\n        ++indegrees[e[1]];\\r\\n    }\\r\\n    vector<int> q;\\r\\n    for (int i = 0; i < cs.size(); ++i)\\r\\n        if (indegrees[i] == 0)\\r\\n            q.push_back(i);\\r\\n    int res = 0, processed = 0;\\r\\n    while (!q.empty()) \\r\\n    {\\r\\n        vector<int> q1;\\r\\n        for (auto i : q) \\r\\n        {\\r\\n            ++processed;\\r\\n            res = max(res, ++cnt[i][cs[i] - \\'a\\']);\\r\\n            for (auto j : al[i]) \\r\\n            {\\r\\n                for (auto k = 0; k < 26; ++k)\\r\\n                    cnt[j][k] = max(cnt[j][k], cnt[i][k]);\\r\\n                if (--indegrees[j] == 0)\\r\\n                    q1.push_back(j);\\r\\n            }\\r\\n        }\\r\\n        swap(q, q1);\\r\\n    }\\r\\n    return processed != cs.size() ? -1 : res;\\r\\n}\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397858,
                "title": "swift-beats-100-runtime-memory-o-v-e",
                "content": "# Complexity\\r\\nTime Complexity: O(V + E)\\r\\n- The `buildGraph` function iterates through each edge in `edges`, making its complexity O(E).\\r\\n- The `calculateInDegrees` function also iterates through each edge in `edges`, making its complexity O(E).\\r\\n- The `initialQueue` function iterates through each vertex in `inDegrees`, making its complexity O(V).\\r\\n- The main while loop in the `largestPathValue` function runs as many times as there are vertices in the graph. Within this loop, there is an inner loop that iterates through the neighbors of each vertex (i.e., edges). The total number of iterations of the inner loop is equal to the total number of edges in the graph. So, the complexity of this while loop is O(V + E).\\r\\n\\r\\nConsidering all the parts of the code, the overall time complexity of the given code is O(V + E).\\r\\n\\r\\nSpace Complexity: O(V + E)\\r\\n- The `graph` variable stores the adjacency list representation of the graph, which has a space complexity of O(V + E).\\r\\n- The `inDegrees` variable is an array that stores the in-degrees of all vertices, which has a space complexity of O(V).\\r\\n- The `colorCounts` variable is a dictionary storing color counts for each vertex, which has a space complexity of O(V * C), where C is the number of distinct colors in the graph. In the worst case, every vertex has a different color, making C = V, so the space complexity becomes O(V^2).\\r\\n- The `queue` variable is an array that stores the vertices with zero in-degrees. In the worst case, it might store all vertices, making its space complexity O(V).\\r\\n\\r\\nConsidering all the data structures used in the code, the overall space complexity of the given code is O(V^2 + E). However, if the number of distinct colors is significantly smaller than the number of vertices (C << V), the space complexity can be considered O(V + E).\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    func largestPathValue(_ colors: String, _ edges: [[Int]]) -> Int {\\r\\n        var graph = buildGraph(from: edges, vertexCount: colors.count)\\r\\n        var inDegrees = calculateInDegrees(from: edges, vertexCount: colors.count)\\r\\n        let colors = Array(colors)\\r\\n        \\r\\n        var colorCounts = [Int: [Character: Int]]()\\r\\n    \\r\\n        var result = -1\\r\\n        var queue: [Int] = initialQueue(from: inDegrees)\\r\\n        \\r\\n        while !queue.isEmpty {\\r\\n            let vertex = queue.removeLast()\\r\\n            var colorCount = colorCounts[vertex, default: [:]]\\r\\n            colorCount[colors[vertex], default: 0] += 1\\r\\n            result = max(result, colorCount[colors[vertex], default: 0])\\r\\n            \\r\\n            for neighbor in graph[vertex, default: []] {\\r\\n                inDegrees[neighbor] -= 1\\r\\n                var neighborColorCount = colorCounts[neighbor, default: [:]]\\r\\n                \\r\\n                for (key, value) in colorCount {\\r\\n                    neighborColorCount[key, default: 0] = max(neighborColorCount[key, default: 0], value)\\r\\n                }\\r\\n                \\r\\n                colorCounts[neighbor] = neighborColorCount\\r\\n                if inDegrees[neighbor] == 0 {\\r\\n                    queue.append(neighbor)\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return hasCycle(inDegrees) ? -1 : result\\r\\n    }\\r\\n    \\r\\n    private func buildGraph(from edges: [[Int]], vertexCount: Int) -> [Int: [Int]] {\\r\\n        var graph = [Int: [Int]]()\\r\\n        for edge in edges {\\r\\n            graph[edge[0], default: []].append(edge[1])\\r\\n        }\\r\\n        return graph\\r\\n    }\\r\\n    \\r\\n    private func calculateInDegrees(from edges: [[Int]], vertexCount: Int) -> [Int] {\\r\\n        var inDegrees = Array(repeating: 0, count: vertexCount)\\r\\n        for edge in edges {\\r\\n            inDegrees[edge[1]] += 1\\r\\n        }\\r\\n        return inDegrees\\r\\n    }\\r\\n    \\r\\n    private func initialQueue(from inDegrees: [Int]) -> [Int] {\\r\\n        var queue: [Int] = []\\r\\n        for (index, inDegree) in inDegrees.enumerated() {\\r\\n            if inDegree == 0 {\\r\\n                queue.append(index)\\r\\n            }\\r\\n        }\\r\\n        return queue\\r\\n    }\\r\\n    \\r\\n    private func hasCycle(_ inDegrees: [Int]) -> Bool {\\r\\n        return inDegrees.filter { $0 > 0 }.count > 0\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    func largestPathValue(_ colors: String, _ edges: [[Int]]) -> Int {\\r\\n        var graph = buildGraph(from: edges, vertexCount: colors.count)\\r\\n        var inDegrees = calculateInDegrees(from: edges, vertexCount: colors.count)\\r\\n        let colors = Array(colors)\\r\\n        \\r\\n        var colorCounts = [Int: [Character: Int]]()\\r\\n    \\r\\n        var result = -1\\r\\n        var queue: [Int] = initialQueue(from: inDegrees)\\r\\n        \\r\\n        while !queue.isEmpty {\\r\\n            let vertex = queue.removeLast()\\r\\n            var colorCount = colorCounts[vertex, default: [:]]\\r\\n            colorCount[colors[vertex], default: 0] += 1\\r\\n            result = max(result, colorCount[colors[vertex], default: 0])\\r\\n            \\r\\n            for neighbor in graph[vertex, default: []] {\\r\\n                inDegrees[neighbor] -= 1\\r\\n                var neighborColorCount = colorCounts[neighbor, default: [:]]\\r\\n                \\r\\n                for (key, value) in colorCount {\\r\\n                    neighborColorCount[key, default: 0] = max(neighborColorCount[key, default: 0], value)\\r\\n                }\\r\\n                \\r\\n                colorCounts[neighbor] = neighborColorCount\\r\\n                if inDegrees[neighbor] == 0 {\\r\\n                    queue.append(neighbor)\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return hasCycle(inDegrees) ? -1 : result\\r\\n    }\\r\\n    \\r\\n    private func buildGraph(from edges: [[Int]], vertexCount: Int) -> [Int: [Int]] {\\r\\n        var graph = [Int: [Int]]()\\r\\n        for edge in edges {\\r\\n            graph[edge[0], default: []].append(edge[1])\\r\\n        }\\r\\n        return graph\\r\\n    }\\r\\n    \\r\\n    private func calculateInDegrees(from edges: [[Int]], vertexCount: Int) -> [Int] {\\r\\n        var inDegrees = Array(repeating: 0, count: vertexCount)\\r\\n        for edge in edges {\\r\\n            inDegrees[edge[1]] += 1\\r\\n        }\\r\\n        return inDegrees\\r\\n    }\\r\\n    \\r\\n    private func initialQueue(from inDegrees: [Int]) -> [Int] {\\r\\n        var queue: [Int] = []\\r\\n        for (index, inDegree) in inDegrees.enumerated() {\\r\\n            if inDegree == 0 {\\r\\n                queue.append(index)\\r\\n            }\\r\\n        }\\r\\n        return queue\\r\\n    }\\r\\n    \\r\\n    private func hasCycle(_ inDegrees: [Int]) -> Bool {\\r\\n        return inDegrees.filter { $0 > 0 }.count > 0\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397837,
                "title": "php-solution",
                "content": "# Code\\r\\n```PHP\\r\\nclass Solution {\\r\\n    private $cache = [];\\r\\n    /**\\r\\n     * @param String $colors\\r\\n     * @param Integer[][] $edges\\r\\n     * @return Integer\\r\\n     */\\r\\n    function largestPathValue($colors, $edges) {\\r\\n        $map = [];\\r\\n        foreach($edges as [$a, $b]){\\r\\n           $map[$a][] = $b;\\r\\n        }\\r\\n        $max = 0;\\r\\n        $visited = array_fill(0, strlen($colors), false);\\r\\n        for($i = 0; $i<strlen($colors); $i++){\\r\\n            [$err, $c] = $this->getMaxC($map, $colors, $i, $visited);\\r\\n            if(!$err){\\r\\n                $max = max($max, max($c));\\r\\n            }\\r\\n            else return -1;\\r\\n        }\\r\\n\\r\\n        return $max;\\r\\n    }\\r\\n\\r\\n    function getMaxC($map, $colors, $i, &$visited) {\\r\\n        if($visited[$i]) return [true, []];\\r\\n        if(isset($this->cache[$i]))\\r\\n            return [false, $this->cache[$i]];\\r\\n        $res = $this->def();\\r\\n\\r\\n        $visited[$i] = true;\\r\\n        \\r\\n        foreach($map[$i] as $next) {\\r\\n            [$err, $subres] = $this->getMaxC($map, $colors, $next, $visited);\\r\\n            if($err) return [true, []];\\r\\n            foreach($subres as $c=>$v) {\\r\\n                $res[$c] = max($res[$c], $v);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        $visited[$i] = false;\\r\\n        $res[$colors[$i]]++;\\r\\n\\r\\n        return [false, $this->cache[$i] = $res];\\r\\n    }\\r\\n\\r\\n    function def() {\\r\\n        static $def = null;\\r\\n        if($def === null) {\\r\\n            $def = array_combine(range(\\'a\\', \\'z\\'), array_fill(0, 26, 0));\\r\\n        }\\r\\n\\r\\n        return $def;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "PHP",
                    "Memoization"
                ],
                "code": "```PHP\\r\\nclass Solution {\\r\\n    private $cache = [];\\r\\n    /**\\r\\n     * @param String $colors\\r\\n     * @param Integer[][] $edges\\r\\n     * @return Integer\\r\\n     */\\r\\n    function largestPathValue($colors, $edges) {\\r\\n        $map = [];\\r\\n        foreach($edges as [$a, $b]){\\r\\n           $map[$a][] = $b;\\r\\n        }\\r\\n        $max = 0;\\r\\n        $visited = array_fill(0, strlen($colors), false);\\r\\n        for($i = 0; $i<strlen($colors); $i++){\\r\\n            [$err, $c] = $this->getMaxC($map, $colors, $i, $visited);\\r\\n            if(!$err){\\r\\n                $max = max($max, max($c));\\r\\n            }\\r\\n            else return -1;\\r\\n        }\\r\\n\\r\\n        return $max;\\r\\n    }\\r\\n\\r\\n    function getMaxC($map, $colors, $i, &$visited) {\\r\\n        if($visited[$i]) return [true, []];\\r\\n        if(isset($this->cache[$i]))\\r\\n            return [false, $this->cache[$i]];\\r\\n        $res = $this->def();\\r\\n\\r\\n        $visited[$i] = true;\\r\\n        \\r\\n        foreach($map[$i] as $next) {\\r\\n            [$err, $subres] = $this->getMaxC($map, $colors, $next, $visited);\\r\\n            if($err) return [true, []];\\r\\n            foreach($subres as $c=>$v) {\\r\\n                $res[$c] = max($res[$c], $v);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        $visited[$i] = false;\\r\\n        $res[$colors[$i]]++;\\r\\n\\r\\n        return [false, $this->cache[$i] = $res];\\r\\n    }\\r\\n\\r\\n    function def() {\\r\\n        static $def = null;\\r\\n        if($def === null) {\\r\\n            $def = array_combine(range(\\'a\\', \\'z\\'), array_fill(0, 26, 0));\\r\\n        }\\r\\n\\r\\n        return $def;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397833,
                "title": "simple-c-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool isCyclic(vector<vector<int>>&graph, vector<int>&visited, int curr){\\r\\n        if(visited[curr]==2)\\r\\n            return true;\\r\\n        visited[curr]=2;\\r\\n        for(int i=0;i<graph[curr].size();i++)\\r\\n            if(visited[graph[curr][i]]!=1)\\r\\n                if(isCyclic(graph,visited,graph[curr][i]))\\r\\n                    return true;\\r\\n        visited[curr]=1;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    bool containsCycle(vector<vector<int>>&g, int n){\\r\\n        vector<int>visited(n,0);\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(visited[i]==0){\\r\\n                if(isCyclic(g,visited,i))\\r\\n                    return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n\\r\\n    int largestPathValue(string s, vector<vector<int>>& edges) {\\r\\n\\r\\n        int n=s.length();\\r\\n        vector<vector<int>>g(n);\\r\\n        for(int i=0;i<edges.size();i++){\\r\\n            g[edges[i][0]].push_back(edges[i][1]);\\r\\n        }\\r\\n        if(containsCycle(g,n))\\r\\n            return -1;\\r\\n        vector<int>indegree(n,0);\\r\\n        for(auto x: edges){\\r\\n            indegree[x[1]]++;\\r\\n        }\\r\\n        vector<vector<int>>count(n,vector<int>(26,0));\\r\\n        queue<int>q;\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(indegree[i]==0){\\r\\n                q.push(i);\\r\\n                count[i][s[i]-\\'a\\']++;   \\r\\n            }\\r\\n        }\\r\\n        int ans=0;\\r\\n        while(!q.empty()){\\r\\n            auto p=q.front();\\r\\n            q.pop();\\r\\n            int r=*max_element(count[p].begin(),count[p].end());\\r\\n            ans=max(ans,r);\\r\\n            for(auto v: g[p]){\\r\\n                for(int i=0;i<26;i++){\\r\\n                    count[v][i]=max(count[v][i],count[p][i]+(i==s[v]-\\'a\\'));\\r\\n                }\\r\\n                if(--indegree[v]==0){\\r\\n                    q.push(v);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool isCyclic(vector<vector<int>>&graph, vector<int>&visited, int curr){\\r\\n        if(visited[curr]==2)\\r\\n            return true;\\r\\n        visited[curr]=2;\\r\\n        for(int i=0;i<graph[curr].size();i++)\\r\\n            if(visited[graph[curr][i]]!=1)\\r\\n                if(isCyclic(graph,visited,graph[curr][i]))\\r\\n                    return true;\\r\\n        visited[curr]=1;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    bool containsCycle(vector<vector<int>>&g, int n){\\r\\n        vector<int>visited(n,0);\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(visited[i]==0){\\r\\n                if(isCyclic(g,visited,i))\\r\\n                    return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n\\r\\n    int largestPathValue(string s, vector<vector<int>>& edges) {\\r\\n\\r\\n        int n=s.length();\\r\\n        vector<vector<int>>g(n);\\r\\n        for(int i=0;i<edges.size();i++){\\r\\n            g[edges[i][0]].push_back(edges[i][1]);\\r\\n        }\\r\\n        if(containsCycle(g,n))\\r\\n            return -1;\\r\\n        vector<int>indegree(n,0);\\r\\n        for(auto x: edges){\\r\\n            indegree[x[1]]++;\\r\\n        }\\r\\n        vector<vector<int>>count(n,vector<int>(26,0));\\r\\n        queue<int>q;\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(indegree[i]==0){\\r\\n                q.push(i);\\r\\n                count[i][s[i]-\\'a\\']++;   \\r\\n            }\\r\\n        }\\r\\n        int ans=0;\\r\\n        while(!q.empty()){\\r\\n            auto p=q.front();\\r\\n            q.pop();\\r\\n            int r=*max_element(count[p].begin(),count[p].end());\\r\\n            ans=max(ans,r);\\r\\n            for(auto v: g[p]){\\r\\n                for(int i=0;i<26;i++){\\r\\n                    count[v][i]=max(count[v][i],count[p][i]+(i==s[v]-\\'a\\'));\\r\\n                }\\r\\n                if(--indegree[v]==0){\\r\\n                    q.push(v);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397818,
                "title": "simple-dfs-approach-with-comments",
                "content": "Run dfs for each node.\\r\\nKeep `state` of each node as a dictionary: `letter` to longest count of `letter` starting in this node\\r\\n\\r\\nDetect cycles by \"algorithm biting on its own tail\": `visit[node] == -1`\\r\\n# Code\\r\\n```\\r\\ndef largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n    n = len(colors)\\r\\n    out = [[] for _ in range(n)]        # outgoing edges init\\r\\n    for u, v in edges: out[u].append(v) # outgoing edges building of\\r\\n    visit = [0] * n                     # 0-unvisited, -1 in current stack, 1 visited\\r\\n    state = [defaultdict(int) for _ in range(n)]   # [node][letter] -> longest count of letters starting from this node\\r\\n    def dfs(node):\\r\\n        visit[node] = -1   # tmp on current path\\r\\n        for u in out[node]:\\r\\n            if visit[u] == -1: return -1   # cycle detedted\\r\\n            if not visit[u]:               # call dfs on unvisited nodes\\r\\n                if dfs(u) == -1:    # if there was a cycle\\r\\n                    return -1       # then return -1\\r\\n            for k, val in state[u].items():                 # update the state for each letter in the child\\r\\n                state[node][k] = max(state[node][k], val)\\r\\n        state[node][colors[node]] += 1                      # add the color of the node to the state\\r\\n        visit[node] = 1                                     # mark visited\\r\\n        return max(state[node].values())                    # longest color value for this node\\r\\n    \\r\\n    ret = 0\\r\\n    for u in range(n):   # the main loop over all nodes\\r\\n        if not visit[u]:\\r\\n            r = dfs(u)\\r\\n            if r == -1: return -1   # cycle detected\\r\\n            ret = max(ret, r)\\r\\n    return ret\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\ndef largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n    n = len(colors)\\r\\n    out = [[] for _ in range(n)]        # outgoing edges init\\r\\n    for u, v in edges: out[u].append(v) # outgoing edges building of\\r\\n    visit = [0] * n                     # 0-unvisited, -1 in current stack, 1 visited\\r\\n    state = [defaultdict(int) for _ in range(n)]   # [node][letter] -> longest count of letters starting from this node\\r\\n    def dfs(node):\\r\\n        visit[node] = -1   # tmp on current path\\r\\n        for u in out[node]:\\r\\n            if visit[u] == -1: return -1   # cycle detedted\\r\\n            if not visit[u]:               # call dfs on unvisited nodes\\r\\n                if dfs(u) == -1:    # if there was a cycle\\r\\n                    return -1       # then return -1\\r\\n            for k, val in state[u].items():                 # update the state for each letter in the child\\r\\n                state[node][k] = max(state[node][k], val)\\r\\n        state[node][colors[node]] += 1                      # add the color of the node to the state\\r\\n        visit[node] = 1                                     # mark visited\\r\\n        return max(state[node].values())                    # longest color value for this node\\r\\n    \\r\\n    ret = 0\\r\\n    for u in range(n):   # the main loop over all nodes\\r\\n        if not visit[u]:\\r\\n            r = dfs(u)\\r\\n            if r == -1: return -1   # cycle detected\\r\\n            ret = max(ret, r)\\r\\n    return ret\\r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3397802,
                "title": "java-easy-to-understand",
                "content": "# Code\\r\\n```\\r\\n\\r\\nclass Solution {\\r\\n\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        Graph graph = new Graph(edges, colors);\\r\\n\\r\\n        int result = 0;\\r\\n\\r\\n        boolean[] visited = new boolean[graph.len()];\\r\\n        for(int i = 0; i < graph.len(); i++) {\\r\\n            if(dfs(i, graph, visited)) return -1;\\r\\n            result = Math.max(result, graph.recallMax(i));\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    private boolean dfs(int from, Graph graph, boolean[] visited) {\\r\\n        if(visited[from]) return true;\\r\\n        visited[from] = true;\\r\\n\\r\\n        if(graph.isNotMemorized(from)) {\\r\\n            int[] memory = graph.recall(from);\\r\\n            for (int next : graph.neighbors(from)) {\\r\\n                if (dfs(next, graph, visited)) return true;\\r\\n                int[] nextMem = graph.recall(next);\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    memory[i] = Math.max(nextMem[i], memory[i]);\\r\\n                }\\r\\n            }\\r\\n            memory[graph.color(from)]++;\\r\\n        }\\r\\n\\r\\n        visited[from] = false;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    private static class Graph {\\r\\n        Map<Integer, Set<Integer>> connections;\\r\\n        int[][] memory;\\r\\n        String colors;\\r\\n\\r\\n        Graph(int[][] edges, String colors) {\\r\\n            this.colors = colors;\\r\\n            this.connections = new HashMap<>();\\r\\n            this.memory = new int[len()][];\\r\\n            for(int i = 0; i < len(); i++) {\\r\\n                this.connections.put(i, new HashSet<>());\\r\\n            }\\r\\n            for(int[] edge : edges) {\\r\\n                this.connections.get(edge[0]).add(edge[1]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int len() {\\r\\n            return colors.length();\\r\\n        }\\r\\n\\r\\n        Set<Integer> neighbors(int node) {\\r\\n            return connections.get(node);\\r\\n        }\\r\\n\\r\\n        int[] recall(int node) {\\r\\n            if(isNotMemorized(node)) {\\r\\n                memory[node] = new int[26];\\r\\n            }\\r\\n            return memory[node];\\r\\n        }\\r\\n\\r\\n        int recallMax(int node) {\\r\\n            int max = -1;\\r\\n            for(int v : recall(node)) {\\r\\n                max = Math.max(v, max);\\r\\n            }\\r\\n            return max;\\r\\n        }\\r\\n\\r\\n        boolean isNotMemorized(int node) {\\r\\n            return memory[node] == null;\\r\\n        }\\r\\n\\r\\n        int color(int node) {\\r\\n            return colors.charAt(node) - \\'a\\';\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\n\\r\\nclass Solution {\\r\\n\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        Graph graph = new Graph(edges, colors);\\r\\n\\r\\n        int result = 0;\\r\\n\\r\\n        boolean[] visited = new boolean[graph.len()];\\r\\n        for(int i = 0; i < graph.len(); i++) {\\r\\n            if(dfs(i, graph, visited)) return -1;\\r\\n            result = Math.max(result, graph.recallMax(i));\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    private boolean dfs(int from, Graph graph, boolean[] visited) {\\r\\n        if(visited[from]) return true;\\r\\n        visited[from] = true;\\r\\n\\r\\n        if(graph.isNotMemorized(from)) {\\r\\n            int[] memory = graph.recall(from);\\r\\n            for (int next : graph.neighbors(from)) {\\r\\n                if (dfs(next, graph, visited)) return true;\\r\\n                int[] nextMem = graph.recall(next);\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    memory[i] = Math.max(nextMem[i], memory[i]);\\r\\n                }\\r\\n            }\\r\\n            memory[graph.color(from)]++;\\r\\n        }\\r\\n\\r\\n        visited[from] = false;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    private static class Graph {\\r\\n        Map<Integer, Set<Integer>> connections;\\r\\n        int[][] memory;\\r\\n        String colors;\\r\\n\\r\\n        Graph(int[][] edges, String colors) {\\r\\n            this.colors = colors;\\r\\n            this.connections = new HashMap<>();\\r\\n            this.memory = new int[len()][];\\r\\n            for(int i = 0; i < len(); i++) {\\r\\n                this.connections.put(i, new HashSet<>());\\r\\n            }\\r\\n            for(int[] edge : edges) {\\r\\n                this.connections.get(edge[0]).add(edge[1]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int len() {\\r\\n            return colors.length();\\r\\n        }\\r\\n\\r\\n        Set<Integer> neighbors(int node) {\\r\\n            return connections.get(node);\\r\\n        }\\r\\n\\r\\n        int[] recall(int node) {\\r\\n            if(isNotMemorized(node)) {\\r\\n                memory[node] = new int[26];\\r\\n            }\\r\\n            return memory[node];\\r\\n        }\\r\\n\\r\\n        int recallMax(int node) {\\r\\n            int max = -1;\\r\\n            for(int v : recall(node)) {\\r\\n                max = Math.max(v, max);\\r\\n            }\\r\\n            return max;\\r\\n        }\\r\\n\\r\\n        boolean isNotMemorized(int node) {\\r\\n            return memory[node] == null;\\r\\n        }\\r\\n\\r\\n        int color(int node) {\\r\\n            return colors.charAt(node) - \\'a\\';\\r\\n        }\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397712,
                "title": "python-3-dp",
                "content": "# Intuition\\r\\n(This is a fun question!)\\r\\n\\r\\nAfter looking at the constraints, you know you need to use DP because input size is large.\\r\\n\\r\\nState variables: index of colors\\r\\nbase case: when reaching leaf node\\r\\nrecursion: read and return a count dict\\r\\n\\r\\nThe hardest part can be: \"how to cache\".\\r\\n\\r\\n# Approach\\r\\nDP\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(E+V) -> for each index, we loop through all adjacent edges. Since intermediate result is cached, no repeat calculation is made.\\r\\n\\r\\n- Space complexity:\\r\\nO(E+V) -> n2nxt connection graph\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        import collections\\r\\n\\r\\n        n2nxt = collections.defaultdict(list)\\r\\n\\r\\n        for a, b in edges:\\r\\n            n2nxt[a].append(b)\\r\\n\\r\\n        @lru_cache(None)\\r\\n        def cycle_check(n): # return bool, cycle?\\r\\n            nonlocal cycle\\r\\n            if cycle: # checked cycle found\\r\\n                return cycle\\r\\n            if n in visited:  # new cycle\\r\\n                cycle = True\\r\\n                return cycle\\r\\n            visited.add(n)\\r\\n            for nxt in n2nxt[n]:\\r\\n                cycle_check(nxt)\\r\\n                if cycle:\\r\\n                    return cycle\\r\\n            visited.remove(n)\\r\\n            return False\\r\\n\\r\\n        visited = set()\\r\\n        cycle = False\\r\\n        for i in range(len(colors)):\\r\\n            cycle_check(i)\\r\\n            if cycle:\\r\\n                return -1\\r\\n\\r\\n        # no cycle\\r\\n\\r\\n        @lru_cache(None)\\r\\n        def dfs(n): # return longest color count\\r\\n            if not n2nxt[n]: # no nxt\\r\\n                res = collections.defaultdict(int)\\r\\n                res[colors[n]] += 1\\r\\n                return res\\r\\n            \\r\\n            res = collections.defaultdict(int)\\r\\n\\r\\n            for nxt in n2nxt[n]:\\r\\n                nxtd = dfs(nxt)\\r\\n                for col, freq in nxtd.items():\\r\\n                    res[col] = max(res[col], freq)\\r\\n\\r\\n            res[colors[n]] += 1\\r\\n            \\r\\n            return res\\r\\n\\r\\n        ans = 0\\r\\n        for i in range(len(colors)):\\r\\n            dd = dfs(i)\\r\\n            ans = max(ans, dd[colors[i]])\\r\\n        return ans\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        import collections\\r\\n\\r\\n        n2nxt = collections.defaultdict(list)\\r\\n\\r\\n        for a, b in edges:\\r\\n            n2nxt[a].append(b)\\r\\n\\r\\n        @lru_cache(None)\\r\\n        def cycle_check(n): # return bool, cycle?\\r\\n            nonlocal cycle\\r\\n            if cycle: # checked cycle found\\r\\n                return cycle\\r\\n            if n in visited:  # new cycle\\r\\n                cycle = True\\r\\n                return cycle\\r\\n            visited.add(n)\\r\\n            for nxt in n2nxt[n]:\\r\\n                cycle_check(nxt)\\r\\n                if cycle:\\r\\n                    return cycle\\r\\n            visited.remove(n)\\r\\n            return False\\r\\n\\r\\n        visited = set()\\r\\n        cycle = False\\r\\n        for i in range(len(colors)):\\r\\n            cycle_check(i)\\r\\n            if cycle:\\r\\n                return -1\\r\\n\\r\\n        # no cycle\\r\\n\\r\\n        @lru_cache(None)\\r\\n        def dfs(n): # return longest color count\\r\\n            if not n2nxt[n]: # no nxt\\r\\n                res = collections.defaultdict(int)\\r\\n                res[colors[n]] += 1\\r\\n                return res\\r\\n            \\r\\n            res = collections.defaultdict(int)\\r\\n\\r\\n            for nxt in n2nxt[n]:\\r\\n                nxtd = dfs(nxt)\\r\\n                for col, freq in nxtd.items():\\r\\n                    res[col] = max(res[col], freq)\\r\\n\\r\\n            res[colors[n]] += 1\\r\\n            \\r\\n            return res\\r\\n\\r\\n        ans = 0\\r\\n        for i in range(len(colors)):\\r\\n            dd = dfs(i)\\r\\n            ans = max(ans, dd[colors[i]])\\r\\n        return ans\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397645,
                "title": "cpp-easy-solution",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        int k = 26;\\r\\n        vector<int> indegrees(n, 0);\\r\\n        vector<vector<int>> graph(n, vector<int>());\\r\\n        for (vector<int>& edge : edges) {\\r\\n            int u = edge[0];\\r\\n            int v = edge[1];\\r\\n            graph[u].push_back(v);\\r\\n            indegrees[v]++;\\r\\n        }\\r\\n        unordered_set<int> zero_indegree;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zero_indegree.insert(i);\\r\\n            }\\r\\n        }\\r\\n        vector<vector<int>> counts(n, vector<int>(k, 0));\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i][colors[i] - \\'a\\']++;\\r\\n        }\\r\\n        int max_count = 0;\\r\\n        int visited = 0;\\r\\n        while (!zero_indegree.empty()) {\\r\\n            int u = *zero_indegree.begin();\\r\\n            zero_indegree.erase(u);\\r\\n            visited++;\\r\\n            for (int v : graph[u]) {\\r\\n                for (int i = 0; i < k; i++) {\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (colors[v] - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zero_indegree.insert(v);\\r\\n                }\\r\\n            }\\r\\n            max_count = max(max_count, *max_element(counts[u].begin(), counts[u].end()));\\r\\n        }\\r\\n        return visited == n ? max_count : -1;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        int k = 26;\\r\\n        vector<int> indegrees(n, 0);\\r\\n        vector<vector<int>> graph(n, vector<int>());\\r\\n        for (vector<int>& edge : edges) {\\r\\n            int u = edge[0];\\r\\n            int v = edge[1];\\r\\n            graph[u].push_back(v);\\r\\n            indegrees[v]++;\\r\\n        }\\r\\n        unordered_set<int> zero_indegree;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zero_indegree.insert(i);\\r\\n            }\\r\\n        }\\r\\n        vector<vector<int>> counts(n, vector<int>(k, 0));\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i][colors[i] - \\'a\\']++;\\r\\n        }\\r\\n        int max_count = 0;\\r\\n        int visited = 0;\\r\\n        while (!zero_indegree.empty()) {\\r\\n            int u = *zero_indegree.begin();\\r\\n            zero_indegree.erase(u);\\r\\n            visited++;\\r\\n            for (int v : graph[u]) {\\r\\n                for (int i = 0; i < k; i++) {\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (colors[v] - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zero_indegree.insert(v);\\r\\n                }\\r\\n            }\\r\\n            max_count = max(max_count, *max_element(counts[u].begin(), counts[u].end()));\\r\\n        }\\r\\n        return visited == n ? max_count : -1;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397588,
                "title": "c-dfs-hashtable-short-and-simple",
                "content": "Just take care of the fact that there is **no cycle** for the **current** path.\\n\\nFor every node, save the **maximum** times a **particular letter** *(all the letters)* has appeared in the path with the current node as the starting point of the component *(**for all the paths starting from the current node**)*.\\n\\nUpdate the global result with the maximum no of times **any letter** has appeared for **any path**.\\n\\nPlease upvote if you find the solution clean and concise.\\n***Thank You!!***\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> hash;\\n    int res = 0;\\n    void dfs(vector<vector<int>>& adj, int& currnode, string& colors, int& pass, vector<bool>& done) {\\n        if(res == -1) return;\\n        if(hash[currnode].size()) {\\n            if(done[currnode]) {\\n                res = -1;\\n            }\\n            return;\\n        }\\n        done[currnode] = 1;\\n        hash[currnode] = vector<int>(26);\\n        for(int& child: adj[currnode]) {\\n            dfs(adj, child, colors, pass, done);\\n            if(res == -1) return;\\n            for(int i=0;i<26;i++)\\n                hash[currnode][i] = max(hash[currnode][i], hash[child][i]);\\n        }\\n        hash[currnode][colors[currnode] - \\'a\\']++;\\n        res = max(res, hash[currnode][colors[currnode] - \\'a\\']);\\n        done[currnode] = 0;\\n    }\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.size(), pass = 0;\\n        vector<bool> done(n);\\n        vector<vector<int>> adj(n);\\n        for(vector<int>& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        for(int i=0;i<n;i++) {\\n            if(res == -1) break;\\n            dfs(adj, i, colors, pass, done);\\n            pass++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> hash;\\n    int res = 0;\\n    void dfs(vector<vector<int>>& adj, int& currnode, string& colors, int& pass, vector<bool>& done) {\\n        if(res == -1) return;\\n        if(hash[currnode].size()) {\\n            if(done[currnode]) {\\n                res = -1;\\n            }\\n            return;\\n        }\\n        done[currnode] = 1;\\n        hash[currnode] = vector<int>(26);\\n        for(int& child: adj[currnode]) {\\n            dfs(adj, child, colors, pass, done);\\n            if(res == -1) return;\\n            for(int i=0;i<26;i++)\\n                hash[currnode][i] = max(hash[currnode][i], hash[child][i]);\\n        }\\n        hash[currnode][colors[currnode] - \\'a\\']++;\\n        res = max(res, hash[currnode][colors[currnode] - \\'a\\']);\\n        done[currnode] = 0;\\n    }\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.size(), pass = 0;\\n        vector<bool> done(n);\\n        vector<vector<int>> adj(n);\\n        for(vector<int>& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        for(int i=0;i<n;i++) {\\n            if(res == -1) break;\\n            dfs(adj, i, colors, pass, done);\\n            pass++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397475,
                "title": "c-dfs-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkCycle(int node, vector<int> adj[], vector<bool> &vis, vector<bool> &pathVis) {\\n        vis[node] = true;\\n        pathVis[node] = true;\\n        \\n        bool ans = false;\\n        for(auto &iter : adj[node]) {\\n            if(pathVis[iter]) return true;\\n            if(!vis[iter]) {\\n                ans |= checkCycle(iter, adj, vis, pathVis);\\n                if(ans) return true;\\n            }\\n            else if(iter == node) return true;\\n        }\\n        \\n        pathVis[node] = false;\\n        \\n        return ans;\\n    }\\n    \\n    int* dfs(int node, vector<int> adj[], string &colors, vector<bool> &vis, int dp[][26]) {\\n    \\n        if(vis[node]) return dp[node];\\n\\n        int* Curr;\\n        for(auto &nigg : adj[node]) {\\n \\n            Curr = dfs(nigg, adj, colors, vis, dp);\\n            for(int i = 0; i < 26; i++) \\n                dp[node][i] = max(Curr[i], dp[node][i]);\\n        }\\n        dp[node][colors[node] - \\'a\\']++;\\n\\n        \\n        vis[node] = true;\\n        \\n        return dp[node];\\n    }\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        \\n        int n = colors.size();\\n        vector<int> adjList[n];\\n        \\n        vector<int> inDegrees(n, 0);\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            adjList[u].push_back(v);\\n            inDegrees[v]++;\\n        }\\n        \\n        vector<bool> vis(n, false), pathVis(n, false);\\n        \\n        bool hasCycle = false;\\n        for(int i = 0; i < n; i++) \\n            if(!vis[i]) hasCycle |= checkCycle(i, adjList, vis, pathVis);\\n        \\n        if(hasCycle) return -1;\\n        int ans = 0;\\n        \\n        vis.assign(n, false);\\n\\n        int dp[n][26];\\n        memset(dp, 0, sizeof dp);\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(!inDegrees[i]) {\\n                int *freqs = dfs(i, adjList, colors, vis, dp);\\n                for(int i = 0; i < 26; i++) ans = max(ans, freqs[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkCycle(int node, vector<int> adj[], vector<bool> &vis, vector<bool> &pathVis) {\\n        vis[node] = true;\\n        pathVis[node] = true;\\n        \\n        bool ans = false;\\n        for(auto &iter : adj[node]) {\\n            if(pathVis[iter]) return true;\\n            if(!vis[iter]) {\\n                ans |= checkCycle(iter, adj, vis, pathVis);\\n                if(ans) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3397248,
                "title": "c-solution-topological-sort-dynamic-programming",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        vector<int> adj[n];\\r\\n        \\r\\n        unordered_map<int,int> indegree;\\r\\n        for(vector<int>&v : edges){\\r\\n            adj[v[0]].push_back(v[1]);\\r\\n            indegree[v[1]]++;\\r\\n        }\\r\\n        \\r\\n        queue<int> q;\\r\\n        vector<vector<int>> dp(n,vector<int> (26,0));\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(indegree[i] == 0) {\\r\\n                q.push(i);\\r\\n                dp[i][colors[i] - \\'a\\'] = 1;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        int visitedNodes = 0;\\r\\n        while(!q.empty()){\\r\\n            int node = q.front();\\r\\n            q.pop();\\r\\n            \\r\\n            visitedNodes++;\\r\\n            for(int child : adj[node]){\\r\\n                for(int i=0;i<26;i++){\\r\\n                    dp[child][i] = max(dp[child][i],dp[node][i] + (i == (colors[child] - \\'a\\')));\\r\\n                }\\r\\n\\r\\n                indegree[child]--;\\r\\n                if(indegree[child] == 0) q.push(child);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if(visitedNodes < n) return -1; //means cycle present\\r\\n        int ans = 0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            for(int clr=0;clr<26;clr++){\\r\\n                ans = max(ans,dp[i][clr]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        vector<int> adj[n];\\r\\n        \\r\\n        unordered_map<int,int> indegree;\\r\\n        for(vector<int>&v : edges){\\r\\n            adj[v[0]].push_back(v[1]);\\r\\n            indegree[v[1]]++;\\r\\n        }\\r\\n        \\r\\n        queue<int> q;\\r\\n        vector<vector<int>> dp(n,vector<int> (26,0));\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(indegree[i] == 0) {\\r\\n                q.push(i);\\r\\n                dp[i][colors[i] - \\'a\\'] = 1;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        int visitedNodes = 0;\\r\\n        while(!q.empty()){\\r\\n            int node = q.front();\\r\\n            q.pop();\\r\\n            \\r\\n            visitedNodes++;\\r\\n            for(int child : adj[node]){\\r\\n                for(int i=0;i<26;i++){\\r\\n                    dp[child][i] = max(dp[child][i],dp[node][i] + (i == (colors[child] - \\'a\\')));\\r\\n                }\\r\\n\\r\\n                indegree[child]--;\\r\\n                if(indegree[child] == 0) q.push(child);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if(visitedNodes < n) return -1; //means cycle present\\r\\n        int ans = 0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            for(int clr=0;clr<26;clr++){\\r\\n                ans = max(ans,dp[i][clr]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397240,
                "title": "very-easy-to-implement-beginner-friendly-intuitive",
                "content": "# Intuition\\r\\nSimply we need to followd the topological sort approach only. And while traversing the nodes and it\\'s adjacent nodes just keep a track of maximum number of vertices with a particular color code. And after traversing the node keep a track of all maximum values of vertices with same color code.\\r\\n\\r\\n# Approach\\r\\nTopoSort, BFS, Cycle Detection\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$O(n * 26) \\\\approx O(n)$\\r\\n\\r\\n- Space complexity:\\r\\n$O(n * 26) \\\\approx O(n)$\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        vector<int> color(26, 0);\\r\\n        int n = colors.size();\\r\\n        vector<int> adj[n];\\r\\n        for (auto vec : edges) {\\r\\n            adj[vec[0]].push_back(vec[1]);\\r\\n        }\\r\\n        vector<int> indegree(n, 0);\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            for (auto val : adj[i]) {\\r\\n                indegree[val]++;\\r\\n            }\\r\\n        }\\r\\n        queue<int> q;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n        if (q.empty()) {\\r\\n            return -1;\\r\\n        }\\r\\n        int count = 0;\\r\\n        int ans = INT_MIN;\\r\\n        vector<vector<int> > dp(n, vector<int> (26, 0));\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            dp[i][colors[i]-\\'a\\']++;\\r\\n        }\\r\\n        while (!q.empty()) {\\r\\n            int node = q.front();\\r\\n            q.pop();\\r\\n            count++;\\r\\n            for (auto x : adj[node]) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    dp[x][i] = max(dp[x][i], (dp[node][i] + ((colors[x] - \\'a\\') == i)));\\r\\n                }\\r\\n                indegree[x]--;\\r\\n                if (indegree[x] == 0) {\\r\\n                    q.push(x);\\r\\n                }\\r\\n            }\\r\\n            ans = max(ans, *max_element(dp[node].begin(), dp[node].end()));\\r\\n        }\\r\\n        if (count < n) {\\r\\n            return -1;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        vector<int> color(26, 0);\\r\\n        int n = colors.size();\\r\\n        vector<int> adj[n];\\r\\n        for (auto vec : edges) {\\r\\n            adj[vec[0]].push_back(vec[1]);\\r\\n        }\\r\\n        vector<int> indegree(n, 0);\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            for (auto val : adj[i]) {\\r\\n                indegree[val]++;\\r\\n            }\\r\\n        }\\r\\n        queue<int> q;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n        if (q.empty()) {\\r\\n            return -1;\\r\\n        }\\r\\n        int count = 0;\\r\\n        int ans = INT_MIN;\\r\\n        vector<vector<int> > dp(n, vector<int> (26, 0));\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            dp[i][colors[i]-\\'a\\']++;\\r\\n        }\\r\\n        while (!q.empty()) {\\r\\n            int node = q.front();\\r\\n            q.pop();\\r\\n            count++;\\r\\n            for (auto x : adj[node]) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    dp[x][i] = max(dp[x][i], (dp[node][i] + ((colors[x] - \\'a\\') == i)));\\r\\n                }\\r\\n                indegree[x]--;\\r\\n                if (indegree[x] == 0) {\\r\\n                    q.push(x);\\r\\n                }\\r\\n            }\\r\\n            ans = max(ans, *max_element(dp[node].begin(), dp[node].end()));\\r\\n        }\\r\\n        if (count < n) {\\r\\n            return -1;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397231,
                "title": "simply-explained",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nEach node will have a frequency array to save all max colors starting from it until the end of the path.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nRun dfs on each node, create a new freq array that holds the frequency of each color starting from this node.\\r\\n\\r\\n1. Loop over all children, choose the max frequency color for each color among all children.\\r\\n2. Add the current color to the freq array.\\r\\n3. Loop over the freq array and update global result with the max.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(n+e)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(n)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n// Author: Osama Ayman\\r\\n// Time: O(n+e)\\r\\n// Space: O(n)\\r\\nclass Solution {\\r\\n    int globalRes = 0;\\r\\n    Map<Integer, int[]> hm = new HashMap<>();\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        \\r\\n        // get all paths, keep track of freq of colors in each path\\r\\n        int nodes = colors.length();\\r\\n        // building our adjacency list, so we can traverse the graph\\r\\n        List<Integer>[] adjList = new ArrayList[nodes];\\r\\n        for(int i=0; i<nodes; i++){\\r\\n            adjList[i] = new ArrayList<>();\\r\\n        }\\r\\n        for(int[] e: edges){\\r\\n            adjList[e[0]].add(e[1]);\\r\\n        }\\r\\n       \\r\\n        // must loop over each node because the graph can be disconnected.\\r\\n        for(int i=0; i<nodes; i++){\\r\\n            // if dfs returns -1, then there is a cycle\\r\\n            if(dfs(i, adjList, new HashSet<>(), colors) == -1) return -1;\\r\\n        }\\r\\n\\r\\n        return globalRes;\\r\\n\\r\\n    }\\r\\n \\r\\n    private int dfs(int node, List<Integer>[] adjList, Set<Integer> vis, String colors){\\r\\n\\r\\n        if(vis.contains(node)) return -1;\\r\\n        vis.add(node);\\r\\n\\r\\n        // cur freq array for this node\\r\\n        int[] tmp = new int[26];\\r\\n\\r\\n        for(int child: adjList[node]){\\r\\n            // if child is not visited yet, visit it first\\r\\n            if(!hm.containsKey(child)){\\r\\n                if(dfs(child, adjList, vis, colors) == -1) return -1;\\r\\n            }\\r\\n            \\r\\n            int[] childFreq = hm.get(child);\\r\\n            // updating tmp with the max value color for each child\\r\\n            for(int i=0; i<26; i++){\\r\\n                tmp[i] =  Math.max(tmp[i], childFreq[i]);\\r\\n            }\\r\\n        }\\r\\n        // adding the cur color\\r\\n        tmp[colors.charAt(node)-\\'a\\']++;\\r\\n        // updating the max\\r\\n        for(int x: tmp){\\r\\n            globalRes = Math.max(globalRes, x);\\r\\n        }\\r\\n        // saving the current frequency array of color for this node\\r\\n        hm.put(node, tmp);\\r\\n        // remove cur node from visited set, as we are leaving it now\\r\\n        vis.remove(node);\\r\\n        // indicates that there is no cycle\\r\\n        return 0;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\n// Author: Osama Ayman\\r\\n// Time: O(n+e)\\r\\n// Space: O(n)\\r\\nclass Solution {\\r\\n    int globalRes = 0;\\r\\n    Map<Integer, int[]> hm = new HashMap<>();\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        \\r\\n        // get all paths, keep track of freq of colors in each path\\r\\n        int nodes = colors.length();\\r\\n        // building our adjacency list, so we can traverse the graph\\r\\n        List<Integer>[] adjList = new ArrayList[nodes];\\r\\n        for(int i=0; i<nodes; i++){\\r\\n            adjList[i] = new ArrayList<>();\\r\\n        }\\r\\n        for(int[] e: edges){\\r\\n            adjList[e[0]].add(e[1]);\\r\\n        }\\r\\n       \\r\\n        // must loop over each node because the graph can be disconnected.\\r\\n        for(int i=0; i<nodes; i++){\\r\\n            // if dfs returns -1, then there is a cycle\\r\\n            if(dfs(i, adjList, new HashSet<>(), colors) == -1) return -1;\\r\\n        }\\r\\n\\r\\n        return globalRes;\\r\\n\\r\\n    }\\r\\n \\r\\n    private int dfs(int node, List<Integer>[] adjList, Set<Integer> vis, String colors){\\r\\n\\r\\n        if(vis.contains(node)) return -1;\\r\\n        vis.add(node);\\r\\n\\r\\n        // cur freq array for this node\\r\\n        int[] tmp = new int[26];\\r\\n\\r\\n        for(int child: adjList[node]){\\r\\n            // if child is not visited yet, visit it first\\r\\n            if(!hm.containsKey(child)){\\r\\n                if(dfs(child, adjList, vis, colors) == -1) return -1;\\r\\n            }\\r\\n            \\r\\n            int[] childFreq = hm.get(child);\\r\\n            // updating tmp with the max value color for each child\\r\\n            for(int i=0; i<26; i++){\\r\\n                tmp[i] =  Math.max(tmp[i], childFreq[i]);\\r\\n            }\\r\\n        }\\r\\n        // adding the cur color\\r\\n        tmp[colors.charAt(node)-\\'a\\']++;\\r\\n        // updating the max\\r\\n        for(int x: tmp){\\r\\n            globalRes = Math.max(globalRes, x);\\r\\n        }\\r\\n        // saving the current frequency array of color for this node\\r\\n        hm.put(node, tmp);\\r\\n        // remove cur node from visited set, as we are leaving it now\\r\\n        vis.remove(node);\\r\\n        // indicates that there is no cycle\\r\\n        return 0;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397200,
                "title": "best-solution-till-now-don-t-follow-curious-ity",
                "content": "# Intuition\\r\\n  jUST AT FIRST DETECT THE TOPOLOGICAL SORT USING KAN\\'S ALGO ,\\r\\n  THEN DETECT CYCLE USING IT,\\r\\nAFTER THAT TAKE A COLOUR VECTOR[N][26]\\r\\nWHERE IT WILL SAVE EACH PATH ITERATION\\'S COLOURS\\r\\nAT LAST RETURN THE MAXIMUM VALUE\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n  TC: O(N * 26);\\r\\n  SC : O(N*26);\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n        queue<int>q;\\r\\n    void toposort(vector<int>&in, int n, vector<int> adj[], vector<int>&v) {\\r\\n        for (int i = 0 ; i < n; i++) {\\r\\n            if (!in[i]) {\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n        while(!q.empty()) {\\r\\n            int node = q.front();\\r\\n            v.push_back(node);\\r\\n            q.pop();\\r\\n            for (auto x: adj[node]) {\\r\\n                 in[x]--;\\r\\n                if (in[x] == 0) {\\r\\n                    q.push(x);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n    }\\r\\n\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.length();\\r\\n        vector<int>adj[n];\\r\\n        for (auto it: edges) {\\r\\n            int u = it[0];\\r\\n            int v= it[1];\\r\\n            adj[u].push_back(v);\\r\\n        }\\r\\n        vector<int>v;\\r\\n        //int in[n] = {0};\\r\\n        vector<int> in(n);\\r\\n         for(int i = 0; i < n; i++) {\\r\\n              for (auto x: adj[i]) {\\r\\n           \\r\\n                 in[x]++;\\r\\n             }\\r\\n        }\\r\\n        int maxi = INT_MIN;\\r\\n       toposort(in, n, adj, v);\\r\\n       vector<vector<int>>col(n, vector<int>(26, 0));\\r\\n        if (v.size() != n) return -1;\\r\\n        for (auto x: v) {\\r\\n            col[x][colors[x] - 97]++;\\r\\n            maxi = max(maxi, col[x][colors[x] - 97]);\\r\\n            for (auto y: adj[x]) {\\r\\n                //col[y] = col[x];\\r\\n                //col[y][colors[y] - \\'a\\']++;\\r\\n                for(int i = 0; i < 26; i++) {\\r\\n                    if(col[y][i] < col[x][i]) {\\r\\n                        col[y][i] = col[x][i];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            //col[x] = col[v];\\r\\n\\r\\n        }\\r\\n\\r\\n        return maxi;\\r\\n        \\r\\n    }\\r\\n\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n        queue<int>q;\\r\\n    void toposort(vector<int>&in, int n, vector<int> adj[], vector<int>&v) {\\r\\n        for (int i = 0 ; i < n; i++) {\\r\\n            if (!in[i]) {\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n        while(!q.empty()) {\\r\\n            int node = q.front();\\r\\n            v.push_back(node);\\r\\n            q.pop();\\r\\n            for (auto x: adj[node]) {\\r\\n                 in[x]--;\\r\\n                if (in[x] == 0) {\\r\\n                    q.push(x);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n    }\\r\\n\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.length();\\r\\n        vector<int>adj[n];\\r\\n        for (auto it: edges) {\\r\\n            int u = it[0];\\r\\n            int v= it[1];\\r\\n            adj[u].push_back(v);\\r\\n        }\\r\\n        vector<int>v;\\r\\n        //int in[n] = {0};\\r\\n        vector<int> in(n);\\r\\n         for(int i = 0; i < n; i++) {\\r\\n              for (auto x: adj[i]) {\\r\\n           \\r\\n                 in[x]++;\\r\\n             }\\r\\n        }\\r\\n        int maxi = INT_MIN;\\r\\n       toposort(in, n, adj, v);\\r\\n       vector<vector<int>>col(n, vector<int>(26, 0));\\r\\n        if (v.size() != n) return -1;\\r\\n        for (auto x: v) {\\r\\n            col[x][colors[x] - 97]++;\\r\\n            maxi = max(maxi, col[x][colors[x] - 97]);\\r\\n            for (auto y: adj[x]) {\\r\\n                //col[y] = col[x];\\r\\n                //col[y][colors[y] - \\'a\\']++;\\r\\n                for(int i = 0; i < 26; i++) {\\r\\n                    if(col[y][i] < col[x][i]) {\\r\\n                        col[y][i] = col[x][i];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            //col[x] = col[v];\\r\\n\\r\\n        }\\r\\n\\r\\n        return maxi;\\r\\n        \\r\\n    }\\r\\n\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397031,
                "title": "java-solution-using-topological-sort-readable-easy-and-understandable-code",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n      int n = colors.length();\\r\\n      HashMap<Integer,List<Integer>> graph = new HashMap<>();\\r\\n      int[] inDegree = new int[n];\\r\\n      Queue<Integer> q = new LinkedList<>();\\r\\n      int[][] count = new int[n][26];\\r\\n      for(int[] e : edges){\\r\\n        graph.computeIfAbsent(e[0],k -> new ArrayList<>()).add(e[1]);\\r\\n        inDegree[e[1]]++;\\r\\n      }\\r\\n      for(int i=0;i<n;i++){\\r\\n        if(inDegree[i] == 0){\\r\\n          q.offer(i);\\r\\n        }\\r\\n      }\\r\\n      for(int i=0;i<n;i++){\\r\\n        count[i][colors.charAt(i) - \\'a\\']++;\\r\\n      }\\r\\n      int visited = 0;\\r\\n      int res = 0;\\r\\n      while(!q.isEmpty()){\\r\\n        int curr = q.poll();\\r\\n        visited++;\\r\\n        if(graph.containsKey(curr)){\\r\\n        for(int child : graph.get(curr)){\\r\\n          for(int i=0;i<26;i++){\\r\\n              count[child][i] = Math.max(count[child][i] , count[curr][i] + (colors.charAt(child) - \\'a\\' == i ? 1 : 0));\\r\\n          }\\r\\n          inDegree[child]--;\\r\\n          if(inDegree[child] == 0){\\r\\n              q.add(child);\\r\\n          }\\r\\n        }\\r\\n        }\\r\\n        res = Math.max(res,Arrays.stream(count[curr]).max().getAsInt());\\r\\n      }\\r\\n      return visited == n ? res : -1;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n      int n = colors.length();\\r\\n      HashMap<Integer,List<Integer>> graph = new HashMap<>();\\r\\n      int[] inDegree = new int[n];\\r\\n      Queue<Integer> q = new LinkedList<>();\\r\\n      int[][] count = new int[n][26];\\r\\n      for(int[] e : edges){\\r\\n        graph.computeIfAbsent(e[0],k -> new ArrayList<>()).add(e[1]);\\r\\n        inDegree[e[1]]++;\\r\\n      }\\r\\n      for(int i=0;i<n;i++){\\r\\n        if(inDegree[i] == 0){\\r\\n          q.offer(i);\\r\\n        }\\r\\n      }\\r\\n      for(int i=0;i<n;i++){\\r\\n        count[i][colors.charAt(i) - \\'a\\']++;\\r\\n      }\\r\\n      int visited = 0;\\r\\n      int res = 0;\\r\\n      while(!q.isEmpty()){\\r\\n        int curr = q.poll();\\r\\n        visited++;\\r\\n        if(graph.containsKey(curr)){\\r\\n        for(int child : graph.get(curr)){\\r\\n          for(int i=0;i<26;i++){\\r\\n              count[child][i] = Math.max(count[child][i] , count[curr][i] + (colors.charAt(child) - \\'a\\' == i ? 1 : 0));\\r\\n          }\\r\\n          inDegree[child]--;\\r\\n          if(inDegree[child] == 0){\\r\\n              q.add(child);\\r\\n          }\\r\\n        }\\r\\n        }\\r\\n        res = Math.max(res,Arrays.stream(count[curr]).max().getAsInt());\\r\\n      }\\r\\n      return visited == n ? res : -1;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396962,
                "title": "java-runtime-125-ms-beats-35-45-memory-128-6-mb-beats-32-73",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length() ;\\r\\n        Map<Integer , ArrayList<Integer>> map = new HashMap<>() ;\\r\\n        for(int i=0 ; i<n ; i++){\\r\\n            map.put(i,new ArrayList<>()) ;\\r\\n        }\\r\\n        int indeg[] = new int[n] ;\\r\\n         for(int ar[] : edges){\\r\\n             indeg[ar[1]]++ ;\\r\\n             map.get(ar[0]).add(ar[1]) ;\\r\\n        }\\r\\n        \\r\\n        Queue<Integer> qu = new LinkedList<>() ;\\r\\n        for(int i=0 ; i<n ; i++){\\r\\n            if(indeg[i]==0)\\r\\n                qu.add(i) ;\\r\\n        }\\r\\n        \\r\\n        int dp[][] = new int[n][26] ;\\r\\n        int vis=0 ;\\r\\n        \\r\\n        while(!qu.isEmpty()){\\r\\n            int node = qu.poll() ;\\r\\n            int color = colors.charAt(node)-\\'a\\' ;\\r\\n            dp[node][color]++ ;\\r\\n            for(int nei : map.get(node)){\\r\\n            \\r\\n                for(int i=0 ; i<26 ; i++)\\r\\n                    dp[nei][i] = Math.max(dp[nei][i] , dp[node][i]) ;\\r\\n            \\r\\n                if(--indeg[nei]==0)\\r\\n                    qu.add(nei) ;\\r\\n            }\\r\\n            vis++ ;\\r\\n        }\\r\\n        if(vis!=n)return -1 ;\\r\\n        int ans=0 ;\\r\\n        for(int i=0 ; i<n ; i++){\\r\\n            for(int j=0 ; j<26 ; j++){\\r\\n                ans = Math.max(ans , dp[i][j]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return ans ;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n = colors.length() ;\\r\\n        Map<Integer , ArrayList<Integer>> map = new HashMap<>() ;\\r\\n        for(int i=0 ; i<n ; i++){\\r\\n            map.put(i,new ArrayList<>()) ;\\r\\n        }\\r\\n        int indeg[] = new int[n] ;\\r\\n         for(int ar[] : edges){\\r\\n             indeg[ar[1]]++ ;\\r\\n             map.get(ar[0]).add(ar[1]) ;\\r\\n        }\\r\\n        \\r\\n        Queue<Integer> qu = new LinkedList<>() ;\\r\\n        for(int i=0 ; i<n ; i++){\\r\\n            if(indeg[i]==0)\\r\\n                qu.add(i) ;\\r\\n        }\\r\\n        \\r\\n        int dp[][] = new int[n][26] ;\\r\\n        int vis=0 ;\\r\\n        \\r\\n        while(!qu.isEmpty()){\\r\\n            int node = qu.poll() ;\\r\\n            int color = colors.charAt(node)-\\'a\\' ;\\r\\n            dp[node][color]++ ;\\r\\n            for(int nei : map.get(node)){\\r\\n            \\r\\n                for(int i=0 ; i<26 ; i++)\\r\\n                    dp[nei][i] = Math.max(dp[nei][i] , dp[node][i]) ;\\r\\n            \\r\\n                if(--indeg[nei]==0)\\r\\n                    qu.add(nei) ;\\r\\n            }\\r\\n            vis++ ;\\r\\n        }\\r\\n        if(vis!=n)return -1 ;\\r\\n        int ans=0 ;\\r\\n        for(int i=0 ; i<n ; i++){\\r\\n            for(int j=0 ; j<26 ; j++){\\r\\n                ans = Math.max(ans , dp[i][j]);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return ans ;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396843,
                "title": "python-95-tc-topological-sort-with-explanation",
                "content": "# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n\\r\\n- Space complexity : $$O(n)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        if not edges: return 1 # Edge Case -> no edge -> 1\\r\\n        n = len(colors) # number of nodes\\r\\n        roots = {i for i in range(n)} # to check who are root nodes\\r\\n        graph = defaultdict(set) \\r\\n        indegree = defaultdict(int) \\r\\n        for a, b in edges:\\r\\n            graph[a].add(b) # generate graph\\r\\n            indegree[b] += 1 # save all nodes\\'s indegree\\r\\n            roots -= {b} # delete nodes who have parent\\r\\n        \\r\\n        Max = -1\\r\\n        # if we use list[] to do dp, we\\'ll use n*26 extra space, and exacly 26 times to update color for all nodes\\r\\n        # so I decide use double hash to optimize TC & MC\\r\\n        # dp define as -> max each color count when reach every node\\r\\n        dp = defaultdict(dict) \\r\\n        for root in roots: # search from every root\\r\\n            indegree[root] = 0 # set root\\'s indegree as 0 (cause indegree hash didn\\'t data for every root)\\r\\n            dp[root][colors[root]] = 1 # set dp[root]\\'s color to 1\\r\\n            q = [root]\\r\\n            while q: # BFS\\r\\n                cur = q.pop(0)\\r\\n                for nxt in graph[cur]:\\r\\n                    indegree[nxt] -= 1 # update indegree\\r\\n                    # if we meet a node that indegree == -1, means we found a loop, just return -1\\r\\n                    # (this situation won\\'t happen when using Topological Sort on a graph without loop)\\r\\n                    if indegree[nxt] == -1: return -1\\r\\n                    # update next node\\'s color count\\r\\n                    for c in dp[cur]:\\r\\n                        dp[nxt].setdefault(c, dp[cur][c])\\r\\n                        dp[nxt][c] = max(dp[nxt][c], dp[cur][c])\\r\\n                    # if we can finally visited next node\\r\\n                    if indegree[nxt] == 0:\\r\\n                        q.append(nxt)\\r\\n                        cc = colors[nxt] # next node\\'s color\\r\\n                        # add 1 to next node\\'s color count with it\\'s own color\\r\\n                        dp[nxt].setdefault(cc, 0)\\r\\n                        dp[nxt][cc] += 1\\r\\n                        Max = max(Max, dp[nxt][cc]) # update Max\\r\\n        return Max\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        if not edges: return 1 # Edge Case -> no edge -> 1\\r\\n        n = len(colors) # number of nodes\\r\\n        roots = {i for i in range(n)} # to check who are root nodes\\r\\n        graph = defaultdict(set) \\r\\n        indegree = defaultdict(int) \\r\\n        for a, b in edges:\\r\\n            graph[a].add(b) # generate graph\\r\\n            indegree[b] += 1 # save all nodes\\'s indegree\\r\\n            roots -= {b} # delete nodes who have parent\\r\\n        \\r\\n        Max = -1\\r\\n        # if we use list[] to do dp, we\\'ll use n*26 extra space, and exacly 26 times to update color for all nodes\\r\\n        # so I decide use double hash to optimize TC & MC\\r\\n        # dp define as -> max each color count when reach every node\\r\\n        dp = defaultdict(dict) \\r\\n        for root in roots: # search from every root\\r\\n            indegree[root] = 0 # set root\\'s indegree as 0 (cause indegree hash didn\\'t data for every root)\\r\\n            dp[root][colors[root]] = 1 # set dp[root]\\'s color to 1\\r\\n            q = [root]\\r\\n            while q: # BFS\\r\\n                cur = q.pop(0)\\r\\n                for nxt in graph[cur]:\\r\\n                    indegree[nxt] -= 1 # update indegree\\r\\n                    # if we meet a node that indegree == -1, means we found a loop, just return -1\\r\\n                    # (this situation won\\'t happen when using Topological Sort on a graph without loop)\\r\\n                    if indegree[nxt] == -1: return -1\\r\\n                    # update next node\\'s color count\\r\\n                    for c in dp[cur]:\\r\\n                        dp[nxt].setdefault(c, dp[cur][c])\\r\\n                        dp[nxt][c] = max(dp[nxt][c], dp[cur][c])\\r\\n                    # if we can finally visited next node\\r\\n                    if indegree[nxt] == 0:\\r\\n                        q.append(nxt)\\r\\n                        cc = colors[nxt] # next node\\'s color\\r\\n                        # add 1 to next node\\'s color count with it\\'s own color\\r\\n                        dp[nxt].setdefault(cc, 0)\\r\\n                        dp[nxt][cc] += 1\\r\\n                        Max = max(Max, dp[nxt][cc]) # update Max\\r\\n        return Max\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396820,
                "title": "topological-sort-with-dijkstra-touch",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string c, vector<vector<int>>& e) {\\n        int n = c.size();\\n        vector<vector<int>> g(n);\\n        vector<vector<int>> cd(n,vector<int> (26,0));\\n        vector<int> in(n,0);\\n        \\n        \\n        for(auto &i: e)\\n        {\\n            g[i[0]].push_back(i[1]);\\n            in[i[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int  i = 0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n                cd[i][c[i]-\\'a\\'] = 1;\\n            }\\n            \\n        }\\n        \\n        int ans =0 , cnt = 0;\\n        while(!q.empty())\\n        {\\n            int node  = q.front();\\n            q.pop();\\n            int val  = *max_element(cd[node].begin(),cd[node].end());\\n            ans = max(ans,val);\\n            cnt++;\\n            for(int v: g[node])\\n            {\\n                for(int i=0;i<26;i++)\\n                {\\n                    cd[v][i] = max(cd[v][i],cd[node][i]+(i==(c[v]-\\'a\\')));\\n                }\\n                in[v]--;\\n                if(in[v] == 0)\\n                    q.push(v);\\n                \\n            }\\n        }\\n        \\n        return cnt==n ?ans:-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string c, vector<vector<int>>& e) {\\n        int n = c.size();\\n        vector<vector<int>> g(n);\\n        vector<vector<int>> cd(n,vector<int> (26,0));\\n        vector<int> in(n,0);\\n        \\n        \\n        for(auto &i: e)\\n        {\\n            g[i[0]].push_back(i[1]);\\n            in[i[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int  i = 0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n                q.push(i);\\n                cd[i][c[i]-\\'a\\'] = 1;\\n            }\\n            \\n        }\\n        \\n        int ans =0 , cnt = 0;\\n        while(!q.empty())\\n        {\\n            int node  = q.front();\\n            q.pop();\\n            int val  = *max_element(cd[node].begin(),cd[node].end());\\n            ans = max(ans,val);\\n            cnt++;\\n            for(int v: g[node])\\n            {\\n                for(int i=0;i<26;i++)\\n                {\\n                    cd[v][i] = max(cd[v][i],cd[node][i]+(i==(c[v]-\\'a\\')));\\n                }\\n                in[v]--;\\n                if(in[v] == 0)\\n                    q.push(v);\\n                \\n            }\\n        }\\n        \\n        return cnt==n ?ans:-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396596,
                "title": "java-dfs-dp",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n=colors.length();\\r\\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\r\\n        for(int i=0;i<n;i++)\\r\\n        graph.add(new ArrayList<Integer>());\\r\\n        for(int[] edge : edges){\\r\\n            int a=edge[0];\\r\\n            int b=edge[1];\\r\\n            graph.get(a).add(b);\\r\\n        }\\r\\n\\r\\n        int[][] dp=new int[n][26];\\r\\n        boolean[] vis=new boolean[n];\\r\\n        int ans=0;      \\r\\n        \\r\\n        for(int i=0;i<n;i++){\\r\\n//if i is not visited do dfs\\r\\n            if(!vis[i] && dfs(i,graph,dp,vis,new boolean[n],colors))\\r\\n            return -1;\\r\\n            for(int k : dp[i])\\r\\n            ans=Math.max(ans,k);\\r\\n\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    public boolean dfs(int node,ArrayList<ArrayList<Integer>> graph,int[][] dp,boolean[] vis,boolean[] dfsvis,\\r\\n    String colors){\\r\\n        vis[node]=true;\\r\\n        dfsvis[node]=true;\\r\\n\\r\\n        for(int val : graph.get(node)){\\r\\n// return true if loop\\r\\n            if(dfsvis[val])\\r\\n            return true;\\r\\n// do dfs if not visited i.e if visited dfs is already done\\r\\n            if(!vis[val] && dfs(val,graph,dp,vis,dfsvis,colors))\\r\\n            return true; \\r\\n                   \\r\\n          for(int i=0;i<26;i++)\\r\\n          dp[node][i]=Math.max(dp[node][i],dp[val][i]);\\r\\n        }\\r\\n        dfsvis[node]=false;\\r\\n         dp[node][colors.charAt(node)-\\'a\\']++;\\r\\n         return false;\\r\\n    }\\r\\n   \\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        int n=colors.length();\\r\\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\r\\n        for(int i=0;i<n;i++)\\r\\n        graph.add(new ArrayList<Integer>());\\r\\n        for(int[] edge : edges){\\r\\n            int a=edge[0];\\r\\n            int b=edge[1];\\r\\n            graph.get(a).add(b);\\r\\n        }\\r\\n\\r\\n        int[][] dp=new int[n][26];\\r\\n        boolean[] vis=new boolean[n];\\r\\n        int ans=0;      \\r\\n        \\r\\n        for(int i=0;i<n;i++){\\r\\n//if i is not visited do dfs\\r\\n            if(!vis[i] && dfs(i,graph,dp,vis,new boolean[n],colors))\\r\\n            return -1;\\r\\n            for(int k : dp[i])\\r\\n            ans=Math.max(ans,k);\\r\\n\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    public boolean dfs(int node,ArrayList<ArrayList<Integer>> graph,int[][] dp,boolean[] vis,boolean[] dfsvis,\\r\\n    String colors){\\r\\n        vis[node]=true;\\r\\n        dfsvis[node]=true;\\r\\n\\r\\n        for(int val : graph.get(node)){\\r\\n// return true if loop\\r\\n            if(dfsvis[val])\\r\\n            return true;\\r\\n// do dfs if not visited i.e if visited dfs is already done\\r\\n            if(!vis[val] && dfs(val,graph,dp,vis,dfsvis,colors))\\r\\n            return true; \\r\\n                   \\r\\n          for(int i=0;i<26;i++)\\r\\n          dp[node][i]=Math.max(dp[node][i],dp[val][i]);\\r\\n        }\\r\\n        dfsvis[node]=false;\\r\\n         dp[node][colors.charAt(node)-\\'a\\']++;\\r\\n         return false;\\r\\n    }\\r\\n   \\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396450,
                "title": "c-solution-with-dfs-and-dp",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n1. In a directed graph, a cycle is confirmed, if we are able to reach a node again in its dfs call itself. So keep this check to detect cycle.\\r\\n2. As there are only 26 possible lowercase english alphabets, so we can safely try all ways via \"dynamic programming\" approach as the constraint is 10<sup>5</sup> for the no. of nodes, and for each node we can maintain state of 26 colors. So, overall state maintenance of O(26 X 10<sup>5</sup>) , which is feasible.\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. Let t[i][j] denote the max color in path starting from node \\'i\\' of color (j-\\'a\\'). Here, if \\'n\\' is the total no. of nodes (obtained from colors.size()), then \\'i\\' belongs to [0,n-1] and \\'j\\' belongs to [0,26].\\r\\n\\r\\n2. It is possible that on path from some node \\'u\\', we reach a node \\'v\\' which has been already visited and finished earlier, so instead of computing again, use the state maintained in t[v][j] to compute the t[v\\'s parent][j], for all j in [0,26-1] and return so on till t[u][j] is not computed for all j.\\r\\n\\r\\n3. The cycle detection would need another visited array, but for marking the status of completeness of each node, we can make an extra entry in \\'t\\' table only as t[u][26] to denote -1 for not visited, 0 for visited, 1 for finished. Taking an extra visited array will be of same complexity as anyway equal no. of integer entries are stored, so equal bytes will be consumed.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nThe time taken will be O(26(|V|+|E|)) for the overall dfs and then O(26|V|) for initialisation and computing the final maximum from t.\\r\\nThus, O(26(|V|+|E|)).\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nFor the adjacency list, O(|V|+|E|). And for the \\'t\\' table, it will be O(27|V|). Revursion stack space will be O(|V|+|E|).\\r\\nThus, O(max(27|V|, |V|+|E|)). \\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    void dfs(string& colors,vector<int> adjlist[],int t[][27],int cur,bool& cycle){\\r\\n        t[cur][26]=0;   //marked visited\\r\\n        // bool leaf=true;\\r\\n        for(auto neigh: adjlist[cur]){\\r\\n            // leaf=false;\\r\\n            if(t[neigh][26]==-1){\\r\\n                //call dfs over it\\r\\n                dfs(colors,adjlist,t,neigh,cycle);\\r\\n                //check if cycle formed, then return -1 on priority\\r\\n                if(cycle){\\r\\n                    return;\\r\\n                }\\r\\n            }else{\\r\\n                //check if t[neigh][26]!=-1 is due to a cycle or not\\r\\n                //if the node is revisited in its own dfs call, then only a cycle, but if a finished node is revisited, then its not a cycle as some other starting vertex is calling dfs() over it\\r\\n                if(t[neigh][26]==0){\\r\\n                    cycle=true;\\r\\n                    return;\\r\\n                }\\r\\n            }\\r\\n            //if either the neighbor already visited or now call completed over it\\r\\n            for(int i=0;i<26;i++){\\r\\n                t[cur][i]=max(t[cur][i],t[neigh][i]);\\r\\n            }\\r\\n        }\\r\\n        t[cur][colors[cur]-\\'a\\']+=1;     //since one more than all of its neighbors as it is of that particular character \\r\\n        //now we have computed t[cur][i] for all colors i\\r\\n        //even if it was a leaf(sink), we have done +1 at last\\r\\n        t[cur][26]=1;   //marked finished\\r\\n        return;\\r\\n    }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n=colors.size();\\r\\n        vector<int> adjlist[n];\\r\\n        for(int i=0;i<edges.size();i++){\\r\\n            adjlist[edges[i][0]].push_back(edges[i][1]);\\r\\n        }\\r\\n        int t[n][27];   //since colors is one of 26 lowercase alphabets\\r\\n        for(int i=0;i<n;i++){\\r\\n            for(int j=0;j<26;j++){\\r\\n                t[i][j]=0;\\r\\n            }\\r\\n            t[i][26]=-1;        //this extra one to check visited or not, finished or not\\r\\n        }\\r\\n        bool cycle=false;   //assume no cycle initially\\r\\n        //t[i][j]=max path length starting from node \\'i\\' of color \\'a\\'+j\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(t[i][26]==-1){\\r\\n                //call dfs from this node\\r\\n                dfs(colors,adjlist,t,i,cycle);\\r\\n                if(cycle){\\r\\n                    return -1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        //reached here means no cycle\\r\\n        //return the maximum value found\\r\\n        int ans=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            for(int j=0;j<26;j++){\\r\\n                ans=max(ans,t[i][j]);\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    void dfs(string& colors,vector<int> adjlist[],int t[][27],int cur,bool& cycle){\\r\\n        t[cur][26]=0;   //marked visited\\r\\n        // bool leaf=true;\\r\\n        for(auto neigh: adjlist[cur]){\\r\\n            // leaf=false;\\r\\n            if(t[neigh][26]==-1){\\r\\n                //call dfs over it\\r\\n                dfs(colors,adjlist,t,neigh,cycle);\\r\\n                //check if cycle formed, then return -1 on priority\\r\\n                if(cycle){\\r\\n                    return;\\r\\n                }\\r\\n            }else{\\r\\n                //check if t[neigh][26]!=-1 is due to a cycle or not\\r\\n                //if the node is revisited in its own dfs call, then only a cycle, but if a finished node is revisited, then its not a cycle as some other starting vertex is calling dfs() over it\\r\\n                if(t[neigh][26]==0){\\r\\n                    cycle=true;\\r\\n                    return;\\r\\n                }\\r\\n            }\\r\\n            //if either the neighbor already visited or now call completed over it\\r\\n            for(int i=0;i<26;i++){\\r\\n                t[cur][i]=max(t[cur][i],t[neigh][i]);\\r\\n            }\\r\\n        }\\r\\n        t[cur][colors[cur]-\\'a\\']+=1;     //since one more than all of its neighbors as it is of that particular character \\r\\n        //now we have computed t[cur][i] for all colors i\\r\\n        //even if it was a leaf(sink), we have done +1 at last\\r\\n        t[cur][26]=1;   //marked finished\\r\\n        return;\\r\\n    }\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n=colors.size();\\r\\n        vector<int> adjlist[n];\\r\\n        for(int i=0;i<edges.size();i++){\\r\\n            adjlist[edges[i][0]].push_back(edges[i][1]);\\r\\n        }\\r\\n        int t[n][27];   //since colors is one of 26 lowercase alphabets\\r\\n        for(int i=0;i<n;i++){\\r\\n            for(int j=0;j<26;j++){\\r\\n                t[i][j]=0;\\r\\n            }\\r\\n            t[i][26]=-1;        //this extra one to check visited or not, finished or not\\r\\n        }\\r\\n        bool cycle=false;   //assume no cycle initially\\r\\n        //t[i][j]=max path length starting from node \\'i\\' of color \\'a\\'+j\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(t[i][26]==-1){\\r\\n                //call dfs from this node\\r\\n                dfs(colors,adjlist,t,i,cycle);\\r\\n                if(cycle){\\r\\n                    return -1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        //reached here means no cycle\\r\\n        //return the maximum value found\\r\\n        int ans=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            for(int j=0;j<26;j++){\\r\\n                ans=max(ans,t[i][j]);\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396377,
                "title": "c-bfs-dp",
                "content": "# Approach\\r\\nWe use BFS (Similar to Kahn\\'s Algorithm) to traverse the graph and keep track of maximum value in path using DP with a $$cnt$$ matrix.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n\\r\\n- Space complexity: $$O(n)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        vector<vector<int>> cnt(n, vector<int>(26));\\r\\n        vector<int> adj[n], indegree(n);\\r\\n        queue<int> q;\\r\\n        for(auto&x:edges){\\r\\n            adj[x[0]].push_back(x[1]);\\r\\n            indegree[x[1]]++;\\r\\n        }\\r\\n        for(int i = 0; i < n; i++){\\r\\n            cnt[i][colors[i] - \\'a\\'] = 1;\\r\\n        }\\r\\n        for(int i = 0; i < n; i++) if(!indegree[i]) q.push(i);\\r\\n        int maxLen = 0, visited = 0;\\r\\n        while(q.size()){\\r\\n            auto node = q.front();\\r\\n            q.pop();\\r\\n            visited++;\\r\\n            for(auto&v:adj[node]){\\r\\n                for(int i = 0; i < 26; i++){\\r\\n                    cnt[v][i] = max(cnt[v][i], cnt[node][i] + (colors[v] - \\'a\\' == i));\\r\\n                }\\r\\n                if(--indegree[v] == 0) q.push(v);\\r\\n            }\\r\\n            maxLen = max(maxLen, *max_element(cnt[node].begin(), cnt[node].end()));\\r\\n        }\\r\\n        return visited == n ? maxLen : -1;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        vector<vector<int>> cnt(n, vector<int>(26));\\r\\n        vector<int> adj[n], indegree(n);\\r\\n        queue<int> q;\\r\\n        for(auto&x:edges){\\r\\n            adj[x[0]].push_back(x[1]);\\r\\n            indegree[x[1]]++;\\r\\n        }\\r\\n        for(int i = 0; i < n; i++){\\r\\n            cnt[i][colors[i] - \\'a\\'] = 1;\\r\\n        }\\r\\n        for(int i = 0; i < n; i++) if(!indegree[i]) q.push(i);\\r\\n        int maxLen = 0, visited = 0;\\r\\n        while(q.size()){\\r\\n            auto node = q.front();\\r\\n            q.pop();\\r\\n            visited++;\\r\\n            for(auto&v:adj[node]){\\r\\n                for(int i = 0; i < 26; i++){\\r\\n                    cnt[v][i] = max(cnt[v][i], cnt[node][i] + (colors[v] - \\'a\\' == i));\\r\\n                }\\r\\n                if(--indegree[v] == 0) q.push(v);\\r\\n            }\\r\\n            maxLen = max(maxLen, *max_element(cnt[node].begin(), cnt[node].end()));\\r\\n        }\\r\\n        return visited == n ? maxLen : -1;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396327,
                "title": "golang-dfs",
                "content": "# Code\\r\\n```\\r\\nfunc dfs(curr int, colors string, adjList [][]int, visited, currPath []bool, count [][]int, ans *int) {\\r\\n    if currPath[curr] || *ans == -1 {\\r\\n        *ans = -1\\r\\n        return\\r\\n    }\\r\\n    if visited[curr] {return}\\r\\n    visited[curr] = true\\r\\n    currPath[curr] = true\\r\\n    for _, next := range adjList[curr] {\\r\\n        dfs(next, colors, adjList, visited, currPath, count, ans)\\r\\n        if *ans == -1 {return}\\r\\n        for i := 0; i < 26; i++ {\\r\\n            if count[next][i] > count[curr][i] {\\r\\n                count[curr][i] = count[next][i]\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    count[curr][colors[curr] - \\'a\\']++\\r\\n    if count[curr][colors[curr] - \\'a\\'] > *ans {*ans = count[curr][colors[curr] - \\'a\\']}\\r\\n    currPath[curr] = false\\r\\n}\\r\\n\\r\\nfunc largestPathValue(colors string, edges [][]int) int {\\r\\n    var n int = len(colors)\\r\\n    adjList := make([][]int, n)\\r\\n    for _, edge := range edges {\\r\\n        adjList[edge[0]] = append(adjList[edge[0]], edge[1])\\r\\n    }\\r\\n    var ans int = math.MinInt\\r\\n    visited := make([]bool, n) \\r\\n    currPath := make([]bool, n)\\r\\n    count := make([][]int, n)\\r\\n    for i := 0; i < n; i++ {\\r\\n        count[i] = make([]int, 26)\\r\\n    }\\r\\n    for i := 0; i < n; i++ {\\r\\n        dfs(i, colors, adjList, visited, currPath, count, &ans)\\r\\n    }\\r\\n    return ans\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\r\\nfunc dfs(curr int, colors string, adjList [][]int, visited, currPath []bool, count [][]int, ans *int) {\\r\\n    if currPath[curr] || *ans == -1 {\\r\\n        *ans = -1\\r\\n        return\\r\\n    }\\r\\n    if visited[curr] {return}\\r\\n    visited[curr] = true\\r\\n    currPath[curr] = true\\r\\n    for _, next := range adjList[curr] {\\r\\n        dfs(next, colors, adjList, visited, currPath, count, ans)\\r\\n        if *ans == -1 {return}\\r\\n        for i := 0; i < 26; i++ {\\r\\n            if count[next][i] > count[curr][i] {\\r\\n                count[curr][i] = count[next][i]\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    count[curr][colors[curr] - \\'a\\']++\\r\\n    if count[curr][colors[curr] - \\'a\\'] > *ans {*ans = count[curr][colors[curr] - \\'a\\']}\\r\\n    currPath[curr] = false\\r\\n}\\r\\n\\r\\nfunc largestPathValue(colors string, edges [][]int) int {\\r\\n    var n int = len(colors)\\r\\n    adjList := make([][]int, n)\\r\\n    for _, edge := range edges {\\r\\n        adjList[edge[0]] = append(adjList[edge[0]], edge[1])\\r\\n    }\\r\\n    var ans int = math.MinInt\\r\\n    visited := make([]bool, n) \\r\\n    currPath := make([]bool, n)\\r\\n    count := make([][]int, n)\\r\\n    for i := 0; i < n; i++ {\\r\\n        count[i] = make([]int, 26)\\r\\n    }\\r\\n    for i := 0; i < n; i++ {\\r\\n        dfs(i, colors, adjList, visited, currPath, count, &ans)\\r\\n    }\\r\\n    return ans\\r\\n}\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3396187,
                "title": "c-cycle-detection-dfs-bottom-up-approach",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        \\r\\n        int n = colors.size();\\r\\n        vector<vector<int>> graph(n);\\r\\n\\r\\n        for(auto &i : edges)\\r\\n            graph[i[0]].push_back(i[1]);\\r\\n\\r\\n        vector<bool> visited(n, false), visited2 = visited;\\r\\n        for(int i = 0; i < n; i++)\\r\\n            if(!visited[i] && detectCycle(graph, visited, visited2, i))\\r\\n                return -1;\\r\\n\\r\\n        int mx = 0;\\r\\n        for(int i = 0; i < n; i++)\\r\\n            visited[i] = false;\\r\\n\\r\\n        unordered_map<int, vector<int>> mp;\\r\\n        for(int i = 0; i < n; i++)\\r\\n            if(mp.find(i) == mp.end())\\r\\n            {\\r\\n                vector<int> dp = helper(graph, colors, visited, i, mp);\\r\\n                for(auto &i : dp)\\r\\n                    mx = max(mx, i);\\r\\n            }\\r\\n\\r\\n        return mx;\\r\\n    }\\r\\n\\r\\n    bool detectCycle(vector<vector<int>> &graph, vector<bool> &visited, vector<bool> &visited2, int i)\\r\\n    {\\r\\n        if(visited[i])\\r\\n            return visited2[i];\\r\\n\\r\\n        visited[i] = visited2[i] = true;\\r\\n        for(auto &j : graph[i])\\r\\n            if(detectCycle(graph, visited, visited2, j))\\r\\n                return true;\\r\\n\\r\\n        return visited2[i] = false;\\r\\n    }\\r\\n\\r\\n    vector<int> helper(vector<vector<int>> &graph, string &colors, vector<bool> &visited, int i, unordered_map<int, vector<int>> &mp)\\r\\n    {\\r\\n        vector<int> dp(26, 0);\\r\\n\\r\\n        if(mp.find(i) != mp.end())\\r\\n            return mp[i];\\r\\n\\r\\n        for(auto &j : graph[i])\\r\\n        {\\r\\n            auto tmp = helper(graph, colors, visited, j, mp);\\r\\n            for(int i = 0; i < 26; i++)\\r\\n                dp[i] = max(tmp[i], dp[i]);\\r\\n        }\\r\\n\\r\\n        dp[colors[i] - \\'a\\']++;\\r\\n        return mp[i] = dp;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        \\r\\n        int n = colors.size();\\r\\n        vector<vector<int>> graph(n);\\r\\n\\r\\n        for(auto &i : edges)\\r\\n            graph[i[0]].push_back(i[1]);\\r\\n\\r\\n        vector<bool> visited(n, false), visited2 = visited;\\r\\n        for(int i = 0; i < n; i++)\\r\\n            if(!visited[i] && detectCycle(graph, visited, visited2, i))\\r\\n                return -1;\\r\\n\\r\\n        int mx = 0;\\r\\n        for(int i = 0; i < n; i++)\\r\\n            visited[i] = false;\\r\\n\\r\\n        unordered_map<int, vector<int>> mp;\\r\\n        for(int i = 0; i < n; i++)\\r\\n            if(mp.find(i) == mp.end())\\r\\n            {\\r\\n                vector<int> dp = helper(graph, colors, visited, i, mp);\\r\\n                for(auto &i : dp)\\r\\n                    mx = max(mx, i);\\r\\n            }\\r\\n\\r\\n        return mx;\\r\\n    }\\r\\n\\r\\n    bool detectCycle(vector<vector<int>> &graph, vector<bool> &visited, vector<bool> &visited2, int i)\\r\\n    {\\r\\n        if(visited[i])\\r\\n            return visited2[i];\\r\\n\\r\\n        visited[i] = visited2[i] = true;\\r\\n        for(auto &j : graph[i])\\r\\n            if(detectCycle(graph, visited, visited2, j))\\r\\n                return true;\\r\\n\\r\\n        return visited2[i] = false;\\r\\n    }\\r\\n\\r\\n    vector<int> helper(vector<vector<int>> &graph, string &colors, vector<bool> &visited, int i, unordered_map<int, vector<int>> &mp)\\r\\n    {\\r\\n        vector<int> dp(26, 0);\\r\\n\\r\\n        if(mp.find(i) != mp.end())\\r\\n            return mp[i];\\r\\n\\r\\n        for(auto &j : graph[i])\\r\\n        {\\r\\n            auto tmp = helper(graph, colors, visited, j, mp);\\r\\n            for(int i = 0; i < 26; i++)\\r\\n                dp[i] = max(tmp[i], dp[i]);\\r\\n        }\\r\\n\\r\\n        dp[colors[i] - \\'a\\']++;\\r\\n        return mp[i] = dp;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396063,
                "title": "1857-largest-color-value-in-a-directed-graph-java",
                "content": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        List<List<Integer>> al=new ArrayList();\\n        List<int[]> cnt =new ArrayList();\\n        int n=colors.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            al.add(new ArrayList());\\n            cnt.add(new int[26]);\\n        }\\n        \\n        int [] indeg=new int[n];\\n        for(int [] x:edges)\\n        {\\n            al.get(x[0]).add(x[1]);\\n            indeg[x[1]]++;\\n        }\\n        \\n        List<Integer> q=new ArrayList();\\n        for(int i=0;i<n;i++)\\n            if(indeg[i]==0)\\n                q.add(i);\\n        \\n        int res=0,checked=0;\\n        while(!q.isEmpty())\\n        {\\n            List<Integer> q1=new ArrayList();\\n            for(int i:q)\\n            {\\n                checked++;\\n                res=Math.max(res,++cnt.get(i)[colors.charAt(i)-\\'a\\']);\\n                for(int j:al.get(i))\\n                {\\n                    for(int k=0;k<26;k++)\\n                    cnt.get(j)[k]=Math.max(cnt.get(j)[k],cnt.get(i)[k]);\\n                    if(--indeg[j]==0)\\n                        q1.add(j);\\n                }\\n            }\\n            q=q1;\\n        }\\n        return checked !=n ?-1:res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        List<List<Integer>> al=new ArrayList();\\n        List<int[]> cnt =new ArrayList();\\n        int n=colors.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            al.add(new ArrayList());\\n            cnt.add(new int[26]);\\n        }\\n        \\n        int [] indeg=new int[n];\\n        for(int [] x:edges)\\n        {\\n            al.get(x[0]).add(x[1]);\\n            indeg[x[1]]++;\\n        }\\n        \\n        List<Integer> q=new ArrayList();\\n        for(int i=0;i<n;i++)\\n            if(indeg[i]==0)\\n                q.add(i);\\n        \\n        int res=0,checked=0;\\n        while(!q.isEmpty())\\n        {\\n            List<Integer> q1=new ArrayList();\\n            for(int i:q)\\n            {\\n                checked++;\\n                res=Math.max(res,++cnt.get(i)[colors.charAt(i)-\\'a\\']);\\n                for(int j:al.get(i))\\n                {\\n                    for(int k=0;k<26;k++)\\n                    cnt.get(j)[k]=Math.max(cnt.get(j)[k],cnt.get(i)[k]);\\n                    if(--indeg[j]==0)\\n                        q1.add(j);\\n                }\\n            }\\n            q=q1;\\n        }\\n        return checked !=n ?-1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396034,
                "title": "dfs-topological-sort-c-kahn-s-algo",
                "content": "PreRequisites : DFS, Topological sort using Kahn\\'s Algorithm..\\nIDEA : Firstly finding topological sort using Kahn\\'s Algorithm, which will also help in finding whether cycle exists or not.\\n\\n```\\n\\tint maxi;\\n\\t//map to use memorization, like for example if we have freq of all colors\\n\\t//including particular node and in it\\'s all paths after that, then no need to\\n\\t//recalculate it again!\\n    map<int, vector<int>> mp;\\n    vector<int> dfs(vector<int> adj[], int src, string &colors, vector<int>& vis)\\n    {\\n        vector<int> freq(26, 0);\\n\\t\\t//if visited already then, simply return its color freq map\\n        if(vis[src])\\n        {\\n            return mp[src];\\n        }\\n        vis[src] = 1;\\n        for(auto child : adj[src])\\n        {\\n            vector<int> f = dfs(adj, child, colors, vis);\\n\\t\\t\\t//storing maximum freq possible from all its path of src\\n            for(int i = 0; i < 26; i++)\\n            {\\n                freq[i] = max(freq[i], f[i]);\\n                maxi = max(freq[i], maxi);\\n            }\\n        }\\n        maxi = max(maxi, ++freq[colors[src] - \\'a\\']);\\n\\t\\t//memorization\\n        return mp[src] = freq;\\n    }\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.size();\\n        vector<int> adj[n];\\n        mp.clear();\\n\\t\\t//forming up the adjacency list\\n        for(auto &it : edges)\\n            adj[it[0]].push_back(it[1]);\\n        //applying Kahn\\'s Algorithm\\n        vector<int> inDegree(n, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(auto it : adj[i])\\n                inDegree[it]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(inDegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        vector<int> res;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            //storing nodes\\n            res.push_back(node);\\n            for(auto it : adj[node])\\n            {\\n                inDegree[it]--;\\n                if(inDegree[it] == 0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        // Imp condition for checking cycle\\n        if(res.size() != n)\\n            return -1;\\n\\t\\t\\t\\n        maxi = 0;\\n        vector<int> vis(n, 0);\\n\\t\\t//applying DFS \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[res[i]])\\n            {\\n                dfs(adj, res[i], colors, vis);\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n\\tint maxi;\\n\\t//map to use memorization, like for example if we have freq of all colors\\n\\t//including particular node and in it\\'s all paths after that, then no need to\\n\\t//recalculate it again!\\n    map<int, vector<int>> mp;\\n    vector<int> dfs(vector<int> adj[], int src, string &colors, vector<int>& vis)\\n    {\\n        vector<int> freq(26, 0);\\n\\t\\t//if visited already then, simply return its color freq map\\n        if(vis[src])\\n        {\\n            return mp[src];\\n        }\\n        vis[src] = 1;\\n        for(auto child : adj[src])\\n        {\\n            vector<int> f = dfs(adj, child, colors, vis);\\n\\t\\t\\t//storing maximum freq possible from all its path of src\\n            for(int i = 0; i < 26; i++)\\n            {\\n                freq[i] = max(freq[i], f[i]);\\n                maxi = max(freq[i], maxi);\\n            }\\n        }\\n        maxi = max(maxi, ++freq[colors[src] - \\'a\\']);\\n\\t\\t//memorization\\n        return mp[src] = freq;\\n    }\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.size();\\n        vector<int> adj[n];\\n        mp.clear();\\n\\t\\t//forming up the adjacency list\\n        for(auto &it : edges)\\n            adj[it[0]].push_back(it[1]);\\n        //applying Kahn\\'s Algorithm\\n        vector<int> inDegree(n, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(auto it : adj[i])\\n                inDegree[it]++;\\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(inDegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        vector<int> res;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            //storing nodes\\n            res.push_back(node);\\n            for(auto it : adj[node])\\n            {\\n                inDegree[it]--;\\n                if(inDegree[it] == 0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        // Imp condition for checking cycle\\n        if(res.size() != n)\\n            return -1;\\n\\t\\t\\t\\n        maxi = 0;\\n        vector<int> vis(n, 0);\\n\\t\\t//applying DFS \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[res[i]])\\n            {\\n                dfs(adj, res[i], colors, vis);\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3395960,
                "title": "beats-99-o-n-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nfrom string import ascii_lowercase\\r\\n\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        num_parents = [0]*n\\r\\n        graph = [[] for i in range(n)]\\r\\n        on_stack = [False] * n\\r\\n        freq = [0] * n\\r\\n\\r\\n        for n1, n2 in edges:\\r\\n            graph[n1].append(n2)\\r\\n            num_parents[n2] += 1\\r\\n        \\r\\n\\r\\n        def has_cycle(at):\\r\\n            if freq[at] == 1:\\r\\n                return False\\r\\n            if on_stack[at]:\\r\\n                return True\\r\\n            on_stack[at] = True\\r\\n            for to in graph[at]:\\r\\n                if has_cycle(to):\\r\\n                    return True\\r\\n            freq[at] = 1\\r\\n            on_stack[at] = False\\r\\n            return False\\r\\n\\r\\n\\r\\n        def calc_freq(at, c):\\r\\n            if freq[at] is not None:\\r\\n                return freq[at]\\r\\n                \\r\\n            f = 0\\r\\n            for to in graph[at]:\\r\\n                f = max(f, calc_freq(to, c))\\r\\n            \\r\\n            if colors[at] == c:\\r\\n                f += 1\\r\\n            freq[at] = f\\r\\n            return f\\r\\n        \\r\\n        for i in range(n):\\r\\n            if has_cycle(i):\\r\\n                return -1\\r\\n\\r\\n        max_freq = -1\\r\\n        for c in set(colors):\\r\\n            for i in range(n):\\r\\n                if num_parents[i] == 0:\\r\\n                    freq = [None] * n\\r\\n                    max_freq = max(max_freq, calc_freq(i, c))\\r\\n        \\r\\n        return max_freq\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nfrom string import ascii_lowercase\\r\\n\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        num_parents = [0]*n\\r\\n        graph = [[] for i in range(n)]\\r\\n        on_stack = [False] * n\\r\\n        freq = [0] * n\\r\\n\\r\\n        for n1, n2 in edges:\\r\\n            graph[n1].append(n2)\\r\\n            num_parents[n2] += 1\\r\\n        \\r\\n\\r\\n        def has_cycle(at):\\r\\n            if freq[at] == 1:\\r\\n                return False\\r\\n            if on_stack[at]:\\r\\n                return True\\r\\n            on_stack[at] = True\\r\\n            for to in graph[at]:\\r\\n                if has_cycle(to):\\r\\n                    return True\\r\\n            freq[at] = 1\\r\\n            on_stack[at] = False\\r\\n            return False\\r\\n\\r\\n\\r\\n        def calc_freq(at, c):\\r\\n            if freq[at] is not None:\\r\\n                return freq[at]\\r\\n                \\r\\n            f = 0\\r\\n            for to in graph[at]:\\r\\n                f = max(f, calc_freq(to, c))\\r\\n            \\r\\n            if colors[at] == c:\\r\\n                f += 1\\r\\n            freq[at] = f\\r\\n            return f\\r\\n        \\r\\n        for i in range(n):\\r\\n            if has_cycle(i):\\r\\n                return -1\\r\\n\\r\\n        max_freq = -1\\r\\n        for c in set(colors):\\r\\n            for i in range(n):\\r\\n                if num_parents[i] == 0:\\r\\n                    freq = [None] * n\\r\\n                    max_freq = max(max_freq, calc_freq(i, c))\\r\\n        \\r\\n        return max_freq\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395920,
                "title": "python-topological-sort",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    # bfs, topological sort\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        graph = collections.defaultdict(list)\\r\\n        indegree = collections.Counter()\\r\\n        for u, v in edges:\\r\\n            graph[v].append(u)\\r\\n            indegree[u] += 1\\r\\n\\r\\n        # counter[node][color]\\r\\n        counter = collections.defaultdict(lambda:collections.defaultdict(int))\\r\\n        q = collections.deque(filter(lambda i: indegree[i] == 0, range(n)))\\r\\n        seen = 0\\r\\n        ans = 0\\r\\n        while q:\\r\\n            node = q.popleft()\\r\\n            counter[node][colors[node]] += 1\\r\\n            ans = max(ans, counter[node][colors[node]])\\r\\n            seen += 1\\r\\n            for adj in graph[node]:\\r\\n                for c in counter[node]:\\r\\n                    counter[adj][c] = max(counter[adj][c], counter[node][c])\\r\\n                indegree[adj] -= 1\\r\\n                if indegree[adj] == 0: q.append(adj)\\r\\n        \\r\\n        return -1 if seen < n else ans\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    # bfs, topological sort\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        graph = collections.defaultdict(list)\\r\\n        indegree = collections.Counter()\\r\\n        for u, v in edges:\\r\\n            graph[v].append(u)\\r\\n            indegree[u] += 1\\r\\n\\r\\n        # counter[node][color]\\r\\n        counter = collections.defaultdict(lambda:collections.defaultdict(int))\\r\\n        q = collections.deque(filter(lambda i: indegree[i] == 0, range(n)))\\r\\n        seen = 0\\r\\n        ans = 0\\r\\n        while q:\\r\\n            node = q.popleft()\\r\\n            counter[node][colors[node]] += 1\\r\\n            ans = max(ans, counter[node][colors[node]])\\r\\n            seen += 1\\r\\n            for adj in graph[node]:\\r\\n                for c in counter[node]:\\r\\n                    counter[adj][c] = max(counter[adj][c], counter[node][c])\\r\\n                indegree[adj] -= 1\\r\\n                if indegree[adj] == 0: q.append(adj)\\r\\n        \\r\\n        return -1 if seen < n else ans\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395595,
                "title": "easy-with-c",
                "content": "# Intuition\\r\\nWe want to find the largest path value in a directed graph, which means we need to find the longest path ending at each node.\\r\\nWe can use topological sorting to traverse the graph in a way that ensures we only visit nodes that have all their incoming edges processed.\\r\\nAt each visited node, we can update the counts for its neighbors based on the counts for the current node and the color of the neighbor.\\r\\nWe can use a set of nodes with zero indegrees to start the traversal and continue until we have visited all nodes, or detect a cycle in the graph.\\r\\nThe counts array allows us to keep track of the number of occurrences of each color in the longest path ending at each node, which is what we need to compute the largest path value.\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\npublic class Solution {\\r\\n    public int LargestPathValue(string colors, int[][] edges) {\\r\\n        int n = colors.Length, k = 26;\\r\\n        int[] indegrees = new int[n];\\r\\n        List<int>[] graph = new List<int>[n];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            graph[i] = new List<int>();\\r\\n        }\\r\\n        foreach (int[] edge in edges) {\\r\\n            int u = edge[0], v = edge[1];\\r\\n            graph[u].Add(v);\\r\\n            indegrees[v]++;\\r\\n        }\\r\\n        HashSet<int> zero_indegree = new HashSet<int>();\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zero_indegree.Add(i);\\r\\n            }\\r\\n        }\\r\\n        int[,] counts = new int[n, k];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i, colors[i] - \\'a\\']++;\\r\\n        }\\r\\n        int max_count = 0, visited = 0;\\r\\n        while (zero_indegree.Count > 0) {\\r\\n            int u = zero_indegree.First();\\r\\n            zero_indegree.Remove(u);\\r\\n            visited++;\\r\\n            foreach (int v in graph[u]) {\\r\\n                for (int i = 0; i < k; i++) {\\r\\n                    counts[v, i] = Math.Max(counts[v, i], counts[u, i] + (colors[v] - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zero_indegree.Add(v);\\r\\n                }\\r\\n            }\\r\\n            max_count = Math.Max(max_count, Enumerable.Range(0, k).Select(i => counts[u, i]).Max());\\r\\n\\r\\n        }\\r\\n        return visited == n ? max_count : -1;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\r\\npublic class Solution {\\r\\n    public int LargestPathValue(string colors, int[][] edges) {\\r\\n        int n = colors.Length, k = 26;\\r\\n        int[] indegrees = new int[n];\\r\\n        List<int>[] graph = new List<int>[n];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            graph[i] = new List<int>();\\r\\n        }\\r\\n        foreach (int[] edge in edges) {\\r\\n            int u = edge[0], v = edge[1];\\r\\n            graph[u].Add(v);\\r\\n            indegrees[v]++;\\r\\n        }\\r\\n        HashSet<int> zero_indegree = new HashSet<int>();\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegrees[i] == 0) {\\r\\n                zero_indegree.Add(i);\\r\\n            }\\r\\n        }\\r\\n        int[,] counts = new int[n, k];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            counts[i, colors[i] - \\'a\\']++;\\r\\n        }\\r\\n        int max_count = 0, visited = 0;\\r\\n        while (zero_indegree.Count > 0) {\\r\\n            int u = zero_indegree.First();\\r\\n            zero_indegree.Remove(u);\\r\\n            visited++;\\r\\n            foreach (int v in graph[u]) {\\r\\n                for (int i = 0; i < k; i++) {\\r\\n                    counts[v, i] = Math.Max(counts[v, i], counts[u, i] + (colors[v] - \\'a\\' == i ? 1 : 0));\\r\\n                }\\r\\n                indegrees[v]--;\\r\\n                if (indegrees[v] == 0) {\\r\\n                    zero_indegree.Add(v);\\r\\n                }\\r\\n            }\\r\\n            max_count = Math.Max(max_count, Enumerable.Range(0, k).Select(i => counts[u, i]).Max());\\r\\n\\r\\n        }\\r\\n        return visited == n ? max_count : -1;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395587,
                "title": "implementation-using-c",
                "content": "```\\r\\npublic class Solution {\\r\\n    public int LargestPathValue(string colors, int[][] edges) {\\r\\n        int n = colors.Length;\\r\\n        var adj = new Dictionary<int, List<int>>();\\r\\n        int[] indegree = new int[n];\\r\\n\\r\\n        foreach (int[] edge in edges) {\\r\\n            if (!adj.ContainsKey(edge[0])) {\\r\\n                adj[edge[0]] = new List<int>();\\r\\n            }\\r\\n            adj[edge[0]].Add(edge[1]);\\r\\n            indegree[edge[1]]++;\\r\\n        }\\r\\n\\r\\n        int[][] count = new int[n][];\\r\\n        for (int i = 0; i < count.Length; ++i) {\\r\\n            count[i] = new int[26];\\r\\n        }\\r\\n        var q = new Queue<int>();\\r\\n\\r\\n        // Push all the nodes with indegree zero in the queue.\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.Enqueue(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int answer = 1, nodesSeen = 0;\\r\\n        while (q.Count > 0) {\\r\\n            int node = q.Dequeue();\\r\\n            answer = Math.Max(answer, ++count[node][colors[node] - \\'a\\']);\\r\\n            nodesSeen++;\\r\\n\\r\\n            if (!adj.ContainsKey(node)) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            foreach (int neighbor in adj[node]) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    // Try to update the frequency of colors for the neighbor to include paths\\r\\n                    // that use node->neighbor edge.\\r\\n                    count[neighbor][i] = Math.Max(count[neighbor][i], count[node][i]);\\r\\n                }\\r\\n\\r\\n                indegree[neighbor]--;\\r\\n                if (indegree[neighbor] == 0) {\\r\\n                    q.Enqueue(neighbor);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return nodesSeen < n ? -1 : answer;        \\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\r\\npublic class Solution {\\r\\n    public int LargestPathValue(string colors, int[][] edges) {\\r\\n        int n = colors.Length;\\r\\n        var adj = new Dictionary<int, List<int>>();\\r\\n        int[] indegree = new int[n];\\r\\n\\r\\n        foreach (int[] edge in edges) {\\r\\n            if (!adj.ContainsKey(edge[0])) {\\r\\n                adj[edge[0]] = new List<int>();\\r\\n            }\\r\\n            adj[edge[0]].Add(edge[1]);\\r\\n            indegree[edge[1]]++;\\r\\n        }\\r\\n\\r\\n        int[][] count = new int[n][];\\r\\n        for (int i = 0; i < count.Length; ++i) {\\r\\n            count[i] = new int[26];\\r\\n        }\\r\\n        var q = new Queue<int>();\\r\\n\\r\\n        // Push all the nodes with indegree zero in the queue.\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.Enqueue(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int answer = 1, nodesSeen = 0;\\r\\n        while (q.Count > 0) {\\r\\n            int node = q.Dequeue();\\r\\n            answer = Math.Max(answer, ++count[node][colors[node] - \\'a\\']);\\r\\n            nodesSeen++;\\r\\n\\r\\n            if (!adj.ContainsKey(node)) {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            foreach (int neighbor in adj[node]) {\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    // Try to update the frequency of colors for the neighbor to include paths\\r\\n                    // that use node->neighbor edge.\\r\\n                    count[neighbor][i] = Math.Max(count[neighbor][i], count[node][i]);\\r\\n                }\\r\\n\\r\\n                indegree[neighbor]--;\\r\\n                if (indegree[neighbor] == 0) {\\r\\n                    q.Enqueue(neighbor);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return nodesSeen < n ? -1 : answer;        \\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395581,
                "title": "javascript-depth-first-search-dfs-approach",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\nDFS\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    const paths = new Map() // a -> b\\r\\n    const incomes = new Map() // coming into node\\r\\n    const checked = new Set()\\r\\n    const cache = new Map()\\r\\n    const n = colors.length\\r\\n\\r\\n    for (let i = 0; i < n; i++) {\\r\\n        incomes.set(i, 0)\\r\\n        paths.set(i, new Set())\\r\\n    }\\r\\n\\r\\n    for (const [a, b] of edges) {\\r\\n        if (a == b) return -1\\r\\n        paths.get(a).add(b)\\r\\n        incomes.set(b, incomes.get(b) + 1)\\r\\n    }\\r\\n\\r\\n    let maxColour = 0\\r\\n\\r\\n    const dfs = (node, seen) => {\\r\\n        if (maxColour == -1) return null\\r\\n        if (seen.has(node)) {\\r\\n            maxColour = -1 \\r\\n            return null\\r\\n        }\\r\\n        if (cache.has(node)) return cache.get(node)\\r\\n\\r\\n        checked.add(node)\\r\\n        seen.add(node)\\r\\n        const colour = colors[node]\\r\\n        const mp = new Map()\\r\\n\\r\\n        const neighbours = paths.get(node)\\r\\n        if (neighbours && neighbours.size > 0) {\\r\\n            neighbours.forEach((nb) => {\\r\\n                const resp = dfs(nb, seen)\\r\\n                if (resp) {\\r\\n                    resp.forEach((v, k) => {\\r\\n                        const curr = mp.get(k) || 0\\r\\n                        mp.set(k, Math.max(curr, v))\\r\\n                    })\\r\\n                }\\r\\n            })\\r\\n        }\\r\\n\\r\\n        mp.set(colour, (mp.get(colour) || 0) + 1)            \\r\\n        seen.delete(node)\\r\\n        cache.set(node, mp)\\r\\n        return mp\\r\\n    }\\r\\n\\r\\n\\r\\n    incomes.forEach((v, k) => {\\r\\n        if (v == 0) { // starting dfs only for the nodes that doesn\\'t have incoming edges (edge nodes)\\r\\n            const mm = dfs(k, new Set())\\r\\n            mm.forEach((v, k) => {\\r\\n                if (maxColour !== -1) maxColour = Math.max(maxColour, v)\\r\\n            })\\r\\n        }\\r\\n    })\\r\\n\\r\\n    if (checked.size < n) return -1\\r\\n    return maxColour\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    const paths = new Map() // a -> b\\r\\n    const incomes = new Map() // coming into node\\r\\n    const checked = new Set()\\r\\n    const cache = new Map()\\r\\n    const n = colors.length\\r\\n\\r\\n    for (let i = 0; i < n; i++) {\\r\\n        incomes.set(i, 0)\\r\\n        paths.set(i, new Set())\\r\\n    }\\r\\n\\r\\n    for (const [a, b] of edges) {\\r\\n        if (a == b) return -1\\r\\n        paths.get(a).add(b)\\r\\n        incomes.set(b, incomes.get(b) + 1)\\r\\n    }\\r\\n\\r\\n    let maxColour = 0\\r\\n\\r\\n    const dfs = (node, seen) => {\\r\\n        if (maxColour == -1) return null\\r\\n        if (seen.has(node)) {\\r\\n            maxColour = -1 \\r\\n            return null\\r\\n        }\\r\\n        if (cache.has(node)) return cache.get(node)\\r\\n\\r\\n        checked.add(node)\\r\\n        seen.add(node)\\r\\n        const colour = colors[node]\\r\\n        const mp = new Map()\\r\\n\\r\\n        const neighbours = paths.get(node)\\r\\n        if (neighbours && neighbours.size > 0) {\\r\\n            neighbours.forEach((nb) => {\\r\\n                const resp = dfs(nb, seen)\\r\\n                if (resp) {\\r\\n                    resp.forEach((v, k) => {\\r\\n                        const curr = mp.get(k) || 0\\r\\n                        mp.set(k, Math.max(curr, v))\\r\\n                    })\\r\\n                }\\r\\n            })\\r\\n        }\\r\\n\\r\\n        mp.set(colour, (mp.get(colour) || 0) + 1)            \\r\\n        seen.delete(node)\\r\\n        cache.set(node, mp)\\r\\n        return mp\\r\\n    }\\r\\n\\r\\n\\r\\n    incomes.forEach((v, k) => {\\r\\n        if (v == 0) { // starting dfs only for the nodes that doesn\\'t have incoming edges (edge nodes)\\r\\n            const mm = dfs(k, new Set())\\r\\n            mm.forEach((v, k) => {\\r\\n                if (maxColour !== -1) maxColour = Math.max(maxColour, v)\\r\\n            })\\r\\n        }\\r\\n    })\\r\\n\\r\\n    if (checked.size < n) return -1\\r\\n    return maxColour\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3395580,
                "title": "java-solution-beats-100-100",
                "content": "\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    static final int[] q = new int[100000];\\r\\n\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        final int n = colors.length();\\r\\n        final char[] cs = colors.toCharArray();\\r\\n        final int[][] best = new int[n][];\\r\\n        final int[][] nexts = next(n, edges, 0);\\r\\n        final int[][] prevs = next(n, edges, 1);\\r\\n        final int[] counts = new int[n];\\r\\n        int len = 0;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if ((counts[i] = nexts[i].length) == 0) {\\r\\n                q[len++] = i;\\r\\n            }\\r\\n        }\\r\\n        for (int i = 0; i < len; i++) {\\r\\n            final int node = q[i];\\r\\n            final int[] max = new int[26];\\r\\n            for (int next : nexts[node]) {\\r\\n                final int[] other = best[next];\\r\\n                for (int j = 0; j < 26; j++) {\\r\\n                    max[j] = Math.max(max[j], other[j]);\\r\\n                }\\r\\n            }\\r\\n            max[cs[node] - \\'a\\']++;\\r\\n            best[node] = max;\\r\\n            for (int prev : prevs[node]) {\\r\\n                if (--counts[prev] == 0) {\\r\\n                    q[len++] = prev;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (len < n) return -1;\\r\\n        int max = 0;\\r\\n        for (int[] b : best) {\\r\\n            for (int b1 : b) {\\r\\n                max = Math.max(max, b1);\\r\\n            }\\r\\n        }\\r\\n        return max;\\r\\n    }\\r\\n\\r\\n    static final int[] counts = new int[100000];\\r\\n\\r\\n    static int[][] next(final int n, final int[][] edges, final int idx) {\\r\\n        for (int[] e : edges) {\\r\\n            counts[e[idx]]++;\\r\\n        }\\r\\n        final int[][] r = new int[n][];\\r\\n        for (int i = 0; i < n; i++) r[i] = new int[counts[i]];\\r\\n        for (int[] e : edges) {\\r\\n            final int n1 = e[idx];\\r\\n            r[n1][--counts[n1]] = e[1 - idx];\\r\\n        }\\r\\n        return r;\\r\\n    }\\r\\n}\\r\\n```\\r\\n### Please UpVote\\uD83D\\uDE42",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    static final int[] q = new int[100000];\\r\\n\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        final int n = colors.length();\\r\\n        final char[] cs = colors.toCharArray();\\r\\n        final int[][] best = new int[n][];\\r\\n        final int[][] nexts = next(n, edges, 0);\\r\\n        final int[][] prevs = next(n, edges, 1);\\r\\n        final int[] counts = new int[n];\\r\\n        int len = 0;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if ((counts[i] = nexts[i].length) == 0) {\\r\\n                q[len++] = i;\\r\\n            }\\r\\n        }\\r\\n        for (int i = 0; i < len; i++) {\\r\\n            final int node = q[i];\\r\\n            final int[] max = new int[26];\\r\\n            for (int next : nexts[node]) {\\r\\n                final int[] other = best[next];\\r\\n                for (int j = 0; j < 26; j++) {\\r\\n                    max[j] = Math.max(max[j], other[j]);\\r\\n                }\\r\\n            }\\r\\n            max[cs[node] - \\'a\\']++;\\r\\n            best[node] = max;\\r\\n            for (int prev : prevs[node]) {\\r\\n                if (--counts[prev] == 0) {\\r\\n                    q[len++] = prev;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (len < n) return -1;\\r\\n        int max = 0;\\r\\n        for (int[] b : best) {\\r\\n            for (int b1 : b) {\\r\\n                max = Math.max(max, b1);\\r\\n            }\\r\\n        }\\r\\n        return max;\\r\\n    }\\r\\n\\r\\n    static final int[] counts = new int[100000];\\r\\n\\r\\n    static int[][] next(final int n, final int[][] edges, final int idx) {\\r\\n        for (int[] e : edges) {\\r\\n            counts[e[idx]]++;\\r\\n        }\\r\\n        final int[][] r = new int[n][];\\r\\n        for (int i = 0; i < n; i++) r[i] = new int[counts[i]];\\r\\n        for (int[] e : edges) {\\r\\n            final int n1 = e[idx];\\r\\n            r[n1][--counts[n1]] = e[1 - idx];\\r\\n        }\\r\\n        return r;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919698,
                "title": "c-100-clean-topological-sort",
                "content": "# Intuition\\r\\nThis solution is based on topological sorting. You should read about it first to understand this better. According to the rules of topoSort, assume there is a vertex C which has incoming edges form vertex A and vertex B. Assume A and B with indegree = 0. Now before we can process the colors for C, we will FINISH evaluating the colors for A and B. After this we will evaluate the color for B and so on.. (see code for better udnerstanding)\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(V+E)\\r\\n\\r\\n- Space complexity:\\r\\nO(V+E)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int nodes = colors.size(),n=nodes,res=0;\\r\\n        vector<int> adjList[n];\\r\\n        vector<int> indegree(n,0);\\r\\n        //This will store the max colors for each Node. \\r\\n        vector<vector<int>> colorCount(n,vector<int>(26,0));\\r\\n        queue<int> Q;\\r\\n\\r\\n        for(auto &it : edges)\\r\\n            adjList[it[0]].push_back(it[1]),++indegree[it[1]];\\r\\n        \\r\\n        for(int i=0;i<n;i++)\\r\\n            if(indegree[i]==0) Q.push(i), --nodes;\\r\\n        \\r\\n        while(!Q.empty()){\\r\\n            int top = Q.front();Q.pop();\\r\\n            colorCount[top][colors[top]-\\'a\\']++;\\r\\n            res = max(res, colorCount[top][colors[top]-\\'a\\']);\\r\\n            for(auto &adjNode : adjList[top]){\\r\\n                //Suppose we can reach node \"adjNode\" from node \"top\" then this means we already have\\r\\n                //all the colors for the \"top\" node(due to topo sort), thus now update the \"adjNode\" colors\\r\\n                //based on the colors of \"top\".\\r\\n                for(int i=0;i<26;i++){\\r\\n                    colorCount[adjNode][i] = max(colorCount[adjNode][i],colorCount[top][i]);\\r\\n                    res = max(res, colorCount[adjNode][i]);\\r\\n                }\\r\\n                --indegree[adjNode];\\r\\n                if(indegree[adjNode]==0)\\r\\n                    Q.push(adjNode),--nodes;\\r\\n            }\\r\\n        }\\r\\n        return nodes == 0 ? res : -1;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int nodes = colors.size(),n=nodes,res=0;\\r\\n        vector<int> adjList[n];\\r\\n        vector<int> indegree(n,0);\\r\\n        //This will store the max colors for each Node. \\r\\n        vector<vector<int>> colorCount(n,vector<int>(26,0));\\r\\n        queue<int> Q;\\r\\n\\r\\n        for(auto &it : edges)\\r\\n            adjList[it[0]].push_back(it[1]),++indegree[it[1]];\\r\\n        \\r\\n        for(int i=0;i<n;i++)\\r\\n            if(indegree[i]==0) Q.push(i), --nodes;\\r\\n        \\r\\n        while(!Q.empty()){\\r\\n            int top = Q.front();Q.pop();\\r\\n            colorCount[top][colors[top]-\\'a\\']++;\\r\\n            res = max(res, colorCount[top][colors[top]-\\'a\\']);\\r\\n            for(auto &adjNode : adjList[top]){\\r\\n                //Suppose we can reach node \"adjNode\" from node \"top\" then this means we already have\\r\\n                //all the colors for the \"top\" node(due to topo sort), thus now update the \"adjNode\" colors\\r\\n                //based on the colors of \"top\".\\r\\n                for(int i=0;i<26;i++){\\r\\n                    colorCount[adjNode][i] = max(colorCount[adjNode][i],colorCount[top][i]);\\r\\n                    res = max(res, colorCount[adjNode][i]);\\r\\n                }\\r\\n                --indegree[adjNode];\\r\\n                if(indegree[adjNode]==0)\\r\\n                    Q.push(adjNode),--nodes;\\r\\n            }\\r\\n        }\\r\\n        return nodes == 0 ? res : -1;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583611,
                "title": "python-don-t-try-to-over-optimize-just-count-color-nodes-from-each-index-if-it-s-a-dag-o-26-n",
                "content": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n, adj, visited, dfs_visited = len(colors), defaultdict(list),set(), set()\\n        for a,b in edges: adj[a].append(b)\\n        # Return -1 if it\\'s a cycliv graph\\n        def dfs_cycle(i):\\n            visited.add(i)\\n            dfs_visited.add(i)\\n            for nei in adj[i]:\\n                if nei in visited and nei in dfs_visited: return True\\n                if nei not in visited and dfs_cycle(nei): return True\\n            dfs_visited.remove(i)\\n            return False\\n        \\n        for i in range(n):\\n            if i not in visited and dfs_cycle(i): return -1\\n        \\n        # Calculate color path from each node\\n        memo = {}\\n        def dfs(i, color):\\n\\t\\t\\tcount, mx = 0, 0\\n            if (i,color) in memo: \\n                return memo[(i,color)]\\n            if color == colors[i]: \\n\\t\\t\\t\\tcount += 1\\n            for nei in adj[i]:\\n                mx = max(mx,dfs(nei,color))\\n            memo[(i,color)] = mx + count\\n            return memo[(i,color)]\\n\\n        res = 0\\n\\t\\tfor i in range(n):\\n            res = max(res, dfs(i,colors[i]))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n, adj, visited, dfs_visited = len(colors), defaultdict(list),set(), set()\\n        for a,b in edges: adj[a].append(b)\\n        # Return -1 if it\\'s a cycliv graph\\n        def dfs_cycle(i):\\n            visited.add(i)\\n            dfs_visited.add(i)\\n            for nei in adj[i]:\\n                if nei in visited and nei in dfs_visited: return True\\n                if nei not in visited and dfs_cycle(nei): return True\\n            dfs_visited.remove(i)\\n            return False\\n        \\n        for i in range(n):\\n            if i not in visited and dfs_cycle(i): return -1\\n        \\n        # Calculate color path from each node\\n        memo = {}\\n        def dfs(i, color):\\n\\t\\t\\tcount, mx = 0, 0\\n            if (i,color) in memo: \\n                return memo[(i,color)]\\n            if color == colors[i]: \\n\\t\\t\\t\\tcount += 1\\n            for nei in adj[i]:\\n                mx = max(mx,dfs(nei,color))\\n            memo[(i,color)] = mx + count\\n            return memo[(i,color)]\\n\\n        res = 0\\n\\t\\tfor i in range(n):\\n            res = max(res, dfs(i,colors[i]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572830,
                "title": "java-dfs-dp-94-62-faster-99-23-less-memory",
                "content": "The idea is to essentially do a topological sort type of algorithm while keeping track of the parents of a given node so we can detect back edges in the DFS tree to find cycles as we go.\\n\\n`dp[i][c]` is the max number of times we see color c in any given path starting from node i. \\n\\nWhen we explore a node, first get the max for each color of that node\\'s neighbors, then we increment `dp[node][colors.get(node)]` to account for the node we just explored. \\n\\nUsing `inStack` to keep track of all of a node\\'s parents in the DFS tree. When we are exploring a node, if we encounter a situation where `inStack[node]` is true, we have detected a cycle. This is because `node` is a decendent of itself in the DFS tree, which can only happen if there is a cycle (see this for more detailed explanation: https://www.baeldung.com/cs/detecting-cycles-in-directed-graph#algorithm-idea)\\n\\n```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        if(edges.length == 0) \\n            return 1;\\n        \\n        List<Integer>[] adj = new List[colors.length()];\\n        for(int[] edge: edges) {\\n            if(adj[edge[0]] == null) {\\n                adj[edge[0]] = new ArrayList<>();\\n            }\\n            \\n            adj[edge[0]].add(edge[1]);\\n        }\\n        \\n        boolean[] visited = new boolean[colors.length()];\\n        int[][] dp = new int[colors.length()][26]; \\n        \\n        int max = 0;\\n        for(int i = 0; i < colors.length(); i++) {\\n            if(!visited[i]) {\\n                if(dfs(colors, visited, dp, new boolean[colors.length()], adj, i)) {\\n                    return -1;\\n                }\\n                \\n                // dp[i][c] = max number of times we see color c\\n                // in any given path starting from node i\\n                for(int c = 0; c < 26; c++) {\\n                    max = Math.max(dp[i][c], max);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    // return true if cycle detected.\\n    private boolean dfs(\\n        String colors, \\n        boolean[] visited, \\n        int[][] dp, \\n        boolean[] inStack,\\n        List<Integer>[] adj,\\n        int node\\n    ) {\\n        \\n        if(inStack[node]) {\\n            return true;\\n        }\\n        \\n        if(visited[node]) {\\n            return false;\\n        }\\n        \\n        inStack[node] = true;\\n        visited[node] = true;\\n        \\n        if(adj[node] != null) {\\n            for(int nbr: adj[node]) {\\n                if(dfs(colors, visited, dp, inStack, adj, nbr)) {\\n                    return true;\\n                }\\n\\n                for(int c = 0; c < 26; c++) {\\n                    dp[node][c] = Math.max(dp[node][c], dp[nbr][c]);\\n                }\\n            }\\n        }\\n        \\n        dp[node][colors.charAt(node) - \\'a\\']++;\\n        inStack[node] = false;\\n        \\n        return false;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        if(edges.length == 0) \\n            return 1;\\n        \\n        List<Integer>[] adj = new List[colors.length()];\\n        for(int[] edge: edges) {\\n            if(adj[edge[0]] == null) {\\n                adj[edge[0]] = new ArrayList<>();\\n            }\\n            \\n            adj[edge[0]].add(edge[1]);\\n        }\\n        \\n        boolean[] visited = new boolean[colors.length()];\\n        int[][] dp = new int[colors.length()][26]; \\n        \\n        int max = 0;\\n        for(int i = 0; i < colors.length(); i++) {\\n            if(!visited[i]) {\\n                if(dfs(colors, visited, dp, new boolean[colors.length()], adj, i)) {\\n                    return -1;\\n                }\\n                \\n                // dp[i][c] = max number of times we see color c\\n                // in any given path starting from node i\\n                for(int c = 0; c < 26; c++) {\\n                    max = Math.max(dp[i][c], max);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    // return true if cycle detected.\\n    private boolean dfs(\\n        String colors, \\n        boolean[] visited, \\n        int[][] dp, \\n        boolean[] inStack,\\n        List<Integer>[] adj,\\n        int node\\n    ) {\\n        \\n        if(inStack[node]) {\\n            return true;\\n        }\\n        \\n        if(visited[node]) {\\n            return false;\\n        }\\n        \\n        inStack[node] = true;\\n        visited[node] = true;\\n        \\n        if(adj[node] != null) {\\n            for(int nbr: adj[node]) {\\n                if(dfs(colors, visited, dp, inStack, adj, nbr)) {\\n                    return true;\\n                }\\n\\n                for(int c = 0; c < 26; c++) {\\n                    dp[node][c] = Math.max(dp[node][c], dp[nbr][c]);\\n                }\\n            }\\n        }\\n        \\n        dp[node][colors.charAt(node) - \\'a\\']++;\\n        inStack[node] = false;\\n        \\n        return false;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538959,
                "title": "trust-me-you-would-definitely-get-this-explanation-c-fully-explained",
                "content": "```\\n  map<int,vector<int>> adj;\\n    map<int,int> inedge;\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        \\n        //Step 1 Make graph and inedge map for every vertex\\n        \\n        int n=colors.size();                 //no of vertices in graph\\n        for(auto i:edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            inedge[i[1]]++;      // inedge incresed by 1\\n        }\\n\\n        //Step 2 Push 0 inedge nodes in queue and apply Topological sort\\n        queue<int> q;\\n        int dp[n][26];   //dp[1][4] denotes 1 vertex pe kitne \\'e\\' ho skte maximum \\n        memset(dp,0,sizeof dp);\\n        \\n        for(int i=0;i<n;i++)\\n            if(inedge[i]==0)\\n                q.push(i),dp[i][colors[i]-\\'a\\']=1;\\n        \\n        int totalVisited=0,ans=0;\\n        while(!q.empty())\\n        {\\n            auto parent=q.front();\\n            q.pop();\\n                \\n            int maxThisVertex= *max_element(dp[parent],dp[parent]+26);  //max value \\n            ans=max(ans,maxThisVertex); // in this vertex a-4 b-3 c-5 so max=5\\n              \\n            totalVisited++;  //one node more visited\\n                \\n//Step 3 child me mera pura 26 size ka array copy hoga bas jo value color[child] ki hai us ith poistion pe +1 hojayega agr parent ke pas 3 \\'g\\' the aur child b \\'g\\' to child ke pas 4 \\'g\\' hojayege\\n            for(auto child:adj[parent])\\n            {\\n               for(int i=0;i<26;i++)\\n                  dp[child][i]=max(dp[child][i],dp[parent][i] + (colors[child]-\\'a\\'==i));\\n                        \\n                inedge[child]--;\\n                    \\n                if(inedge[child]==0)  //if inedge ==0 then push in queue \\n                    q.push(child);  //this is topo sort main game\\n            }\\n        }\\n        \\n        //Step 4 if totalVisited more than n that means cycle is present -1\\n        return (totalVisited==n)?ans:-1;  \\n    }",
                "solutionTags": [],
                "code": "```\\n  map<int,vector<int>> adj;\\n    map<int,int> inedge;\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        \\n        //Step 1 Make graph and inedge map for every vertex\\n        \\n        int n=colors.size();                 //no of vertices in graph\\n        for(auto i:edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            inedge[i[1]]++;      // inedge incresed by 1\\n        }\\n\\n        //Step 2 Push 0 inedge nodes in queue and apply Topological sort\\n        queue<int> q;\\n        int dp[n][26];   //dp[1][4] denotes 1 vertex pe kitne \\'e\\' ho skte maximum \\n        memset(dp,0,sizeof dp);\\n        \\n        for(int i=0;i<n;i++)\\n            if(inedge[i]==0)\\n                q.push(i),dp[i][colors[i]-\\'a\\']=1;\\n        \\n        int totalVisited=0,ans=0;\\n        while(!q.empty())\\n        {\\n            auto parent=q.front();\\n            q.pop();\\n                \\n            int maxThisVertex= *max_element(dp[parent],dp[parent]+26);  //max value \\n            ans=max(ans,maxThisVertex); // in this vertex a-4 b-3 c-5 so max=5\\n              \\n            totalVisited++;  //one node more visited\\n                \\n//Step 3 child me mera pura 26 size ka array copy hoga bas jo value color[child] ki hai us ith poistion pe +1 hojayega agr parent ke pas 3 \\'g\\' the aur child b \\'g\\' to child ke pas 4 \\'g\\' hojayege\\n            for(auto child:adj[parent])\\n            {\\n               for(int i=0;i<26;i++)\\n                  dp[child][i]=max(dp[child][i],dp[parent][i] + (colors[child]-\\'a\\'==i));\\n                        \\n                inedge[child]--;\\n                    \\n                if(inedge[child]==0)  //if inedge ==0 then push in queue \\n                    q.push(child);  //this is topo sort main game\\n            }\\n        }\\n        \\n        //Step 4 if totalVisited more than n that means cycle is present -1\\n        return (totalVisited==n)?ans:-1;  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2483915,
                "title": "javascript-topological-sort",
                "content": "```\\nconst a = \\'a\\'.charCodeAt(0)\\n\\nconst mergeColorCountLists = (arr1, arr2) => {\\n    // create new array taking the max value of each color from each input array\\n    const mergedList = []\\n    for (let i=0; i < arr1.length; i++)\\n        mergedList.push( Math.max(arr1[i], arr2[i]) )\\n    return mergedList\\n}\\n\\nconst getMaxColor = (colorCount) => {\\n    // obtain max color count from each node after BFS\\n    let max = 0\\n    for (let colorArray of colorCount)\\n        max = Math.max(max, Math.max(...colorArray))\\n    return max\\n}\\n\\nconst largestPathValue = (colors, edges) => {\\n    if (!edges.length) return 1\\n    \\n    const N = colors.length,\\n          graph = {},\\n          inCount = new Array(N).fill(0),\\n          stack = new Array()\\n    \\n    for (let [u, v] of edges) {\\n        graph[u] ? graph[u].push(v) : graph[u] = [v]\\n        inCount[v] ? inCount[v]++ : inCount[v] = 1\\n    }\\n\\n    // begin BFS with nodes that do not have a parent\\n    for (let u of Object.keys(graph)) {\\n        if (!inCount[u]) stack.push(u)\\n    }\\n    \\n    // keep track of how many colors have been seen\\n    const colorCount = Array.from({ length: N }, () => Array(26).fill(0))\\n    \\n    while (stack.length) {\\n        let node = stack.pop()\\n        colorCount[node][colors[node].charCodeAt(0) - a]++\\n        if (!graph[node]) continue\\n        for (let nei of graph[node]) {\\n            // merge parent/child colorCount lists into one list of max colorCounts each node has seen\\n            colorCount[nei] = mergeColorCountLists(colorCount[node], colorCount[nei])\\n            inCount[nei]--\\n            if (!inCount[nei])\\n                stack.push(nei)\\n        }\\n    }\\n    \\n    return inCount.every(cnt => cnt === 0) ? getMaxColor(colorCount) : -1\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort"
                ],
                "code": "```\\nconst a = \\'a\\'.charCodeAt(0)\\n\\nconst mergeColorCountLists = (arr1, arr2) => {\\n    // create new array taking the max value of each color from each input array\\n    const mergedList = []\\n    for (let i=0; i < arr1.length; i++)\\n        mergedList.push( Math.max(arr1[i], arr2[i]) )\\n    return mergedList\\n}\\n\\nconst getMaxColor = (colorCount) => {\\n    // obtain max color count from each node after BFS\\n    let max = 0\\n    for (let colorArray of colorCount)\\n        max = Math.max(max, Math.max(...colorArray))\\n    return max\\n}\\n\\nconst largestPathValue = (colors, edges) => {\\n    if (!edges.length) return 1\\n    \\n    const N = colors.length,\\n          graph = {},\\n          inCount = new Array(N).fill(0),\\n          stack = new Array()\\n    \\n    for (let [u, v] of edges) {\\n        graph[u] ? graph[u].push(v) : graph[u] = [v]\\n        inCount[v] ? inCount[v]++ : inCount[v] = 1\\n    }\\n\\n    // begin BFS with nodes that do not have a parent\\n    for (let u of Object.keys(graph)) {\\n        if (!inCount[u]) stack.push(u)\\n    }\\n    \\n    // keep track of how many colors have been seen\\n    const colorCount = Array.from({ length: N }, () => Array(26).fill(0))\\n    \\n    while (stack.length) {\\n        let node = stack.pop()\\n        colorCount[node][colors[node].charCodeAt(0) - a]++\\n        if (!graph[node]) continue\\n        for (let nei of graph[node]) {\\n            // merge parent/child colorCount lists into one list of max colorCounts each node has seen\\n            colorCount[nei] = mergeColorCountLists(colorCount[node], colorCount[nei])\\n            inCount[nei]--\\n            if (!inCount[nei])\\n                stack.push(nei)\\n        }\\n    }\\n    \\n    return inCount.every(cnt => cnt === 0) ? getMaxColor(colorCount) : -1\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2407805,
                "title": "dynamic-programming-memorization-topological-sort",
                "content": "```\\nclass Solution {\\n    Stack<Integer> stk = new Stack<>();\\n    ArrayList<ArrayList<Integer>> dp = new ArrayList<>(); //for node at i\\'th it stores list of size 26 storing frequency of 26 colors.\\n    ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n\\t\\n    boolean[] visited;\\n    boolean[] dfsVisited;\\n\\t\\n    int ans=0;\\n    boolean cycle=false;\\n    public int largestPathValue(String colors, int[][] edges) {\\n        graph = build(colors.length(),edges);//Build graph;\\n        visited = new boolean[colors.length()];\\n        Arrays.fill(visited,false);\\n        for(int i=0;i<colors.length();i++){\\n            dp.add(new ArrayList<>());\\n        }\\n        dfsVisited = new boolean[colors.length()];\\n        Arrays.fill(dfsVisited,false);\\n        for(int i=0;i<colors.length();i++){\\n            dfs(i);\\n        }\\n        if(cycle) return -1;\\n        while(!stk.isEmpty()){\\n            ArrayList<Integer> arr = recurr(stk.pop(),colors);\\n\\n            for(int num: arr){\\n                ans = Math.max(ans,num);\\n            }\\n        }\\n        return ans;\\n    }\\n    public ArrayList<Integer> recurr(int u, String str){\\n        \\n        if(dp.get(u).size()==26) return dp.get(u);\\n        ArrayList<Integer> p = new ArrayList<>();\\n        for(int i=0;i<26;i++) p.add(0);\\n        \\n        for(int it: graph.get(u)){\\n            ArrayList<Integer> adj = recurr(it,str);\\n            for(int i=0;i<26;i++) p.set(i,Math.max(p.get(i),adj.get(i)));\\n        }\\n        p.set(str.charAt(u)-\\'a\\',p.get(str.charAt(u)-\\'a\\')+1);\\n        dp.set(u,p);\\n        return p;\\n    }\\n    public ArrayList<ArrayList<Integer>> build(int u, int[][] edges){\\n        for(int i=0;i<=u;i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges) graph.get(edge[0]).add(edge[1]);\\n        return graph;\\n    }\\n    public void dfs(int u){\\n        if(visited[u]==true) return;\\n        \\n        visited[u]=true;\\n        dfsVisited[u]=true;\\n        for(int it: graph.get(u)){\\n            if(dfsVisited[it]) {\\n                cycle=true;\\n                return;\\n            }\\n            dfs(it);\\n        }\\n        stk.add(u);\\n        dfsVisited[u]=false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Stack<Integer> stk = new Stack<>();\\n    ArrayList<ArrayList<Integer>> dp = new ArrayList<>(); //for node at i\\'th it stores list of size 26 storing frequency of 26 colors.\\n    ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n\\t\\n    boolean[] visited;\\n    boolean[] dfsVisited;\\n\\t\\n    int ans=0;\\n    boolean cycle=false;\\n    public int largestPathValue(String colors, int[][] edges) {\\n        graph = build(colors.length(),edges);//Build graph;\\n        visited = new boolean[colors.length()];\\n        Arrays.fill(visited,false);\\n        for(int i=0;i<colors.length();i++){\\n            dp.add(new ArrayList<>());\\n        }\\n        dfsVisited = new boolean[colors.length()];\\n        Arrays.fill(dfsVisited,false);\\n        for(int i=0;i<colors.length();i++){\\n            dfs(i);\\n        }\\n        if(cycle) return -1;\\n        while(!stk.isEmpty()){\\n            ArrayList<Integer> arr = recurr(stk.pop(),colors);\\n\\n            for(int num: arr){\\n                ans = Math.max(ans,num);\\n            }\\n        }\\n        return ans;\\n    }\\n    public ArrayList<Integer> recurr(int u, String str){\\n        \\n        if(dp.get(u).size()==26) return dp.get(u);\\n        ArrayList<Integer> p = new ArrayList<>();\\n        for(int i=0;i<26;i++) p.add(0);\\n        \\n        for(int it: graph.get(u)){\\n            ArrayList<Integer> adj = recurr(it,str);\\n            for(int i=0;i<26;i++) p.set(i,Math.max(p.get(i),adj.get(i)));\\n        }\\n        p.set(str.charAt(u)-\\'a\\',p.get(str.charAt(u)-\\'a\\')+1);\\n        dp.set(u,p);\\n        return p;\\n    }\\n    public ArrayList<ArrayList<Integer>> build(int u, int[][] edges){\\n        for(int i=0;i<=u;i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges) graph.get(edge[0]).add(edge[1]);\\n        return graph;\\n    }\\n    public void dfs(int u){\\n        if(visited[u]==true) return;\\n        \\n        visited[u]=true;\\n        dfsVisited[u]=true;\\n        for(int it: graph.get(u)){\\n            if(dfsVisited[it]) {\\n                cycle=true;\\n                return;\\n            }\\n            dfs(it);\\n        }\\n        stk.add(u);\\n        dfsVisited[u]=false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354483,
                "title": "dfs-with-max-color-freq-storing",
                "content": "```\\n//we store max color freq for a parent over its child so that every node visited only once\\nclass Solution {\\n    //dfs visited->n\\n    //visited->n*26\\n    public boolean find(List<List<Integer>>graph,int i,boolean[]dfs,int[][]visit,String colors){\\n        dfs[i]=true;\\n        visit[i][0]=0;  //i already visited it\\n        \\n        \\n        for(int child:graph.get(i)){\\n            if(dfs[child])return false;\\n            \\n            if(visit[child][0]==-1)\\n                if(!find(graph,child,dfs,visit,colors))return false;\\n            \\n            for(int j=0;j<26;j++)\\n                visit[i][j]=Math.max(visit[i][j],visit[child][j]);\\n                 \\n        }\\n        visit[i][colors.charAt(i)-\\'a\\']++;\\n        dfs[i]=false;\\n        return true;\\n    }\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n=colors.length();\\n        int maxf=0;\\n        int[][]visit=new int[n][26];\\n        List<List<Integer>>graph=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int i=0;i<edges.length;i++)\\n            graph.get(edges[i][0]).add(edges[i][1]);\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            visit[i][0]=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            if(visit[i][0]==-1){\\n                if(!find(graph,i,new boolean[n],visit,colors))return -1;\\n                \\n                for(int j=0;j<26;j++)\\n                    maxf=Math.max(maxf,visit[i][j]);\\n            }\\n        }\\n        return maxf;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//we store max color freq for a parent over its child so that every node visited only once\\nclass Solution {\\n    //dfs visited->n\\n    //visited->n*26\\n    public boolean find(List<List<Integer>>graph,int i,boolean[]dfs,int[][]visit,String colors){\\n        dfs[i]=true;\\n        visit[i][0]=0;  //i already visited it\\n        \\n        \\n        for(int child:graph.get(i)){\\n            if(dfs[child])return false;\\n            \\n            if(visit[child][0]==-1)\\n                if(!find(graph,child,dfs,visit,colors))return false;\\n            \\n            for(int j=0;j<26;j++)\\n                visit[i][j]=Math.max(visit[i][j],visit[child][j]);\\n                 \\n        }\\n        visit[i][colors.charAt(i)-\\'a\\']++;\\n        dfs[i]=false;\\n        return true;\\n    }\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n=colors.length();\\n        int maxf=0;\\n        int[][]visit=new int[n][26];\\n        List<List<Integer>>graph=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int i=0;i<edges.length;i++)\\n            graph.get(edges[i][0]).add(edges[i][1]);\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            visit[i][0]=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            if(visit[i][0]==-1){\\n                if(!find(graph,i,new boolean[n],visit,colors))return -1;\\n                \\n                for(int j=0;j<26;j++)\\n                    maxf=Math.max(maxf,visit[i][j]);\\n            }\\n        }\\n        return maxf;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096213,
                "title": "java-topological-sort",
                "content": "1. Use simple Topological approach to get the starting point and find edge .\\n2. If count != length , then cycle present , then return -1\\n3. Use dp[][] to keep track of all the colord till any perticular child or node\\n4. Traverse dp[][] to find the max count of color \\n\\n\\n```\\n\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        \\n        int length = colors.length() ;\\n        List<List<Integer>> adjList = new ArrayList<>() ;\\n        int inDegree[] = new int[length] ;\\n        int dp[][] = new int[length][26] ;\\n        int count = 0 ;\\n        \\n        for(int i=0 ; i<length ; i++){\\n            adjList.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0 ; i<edges.length ; i++){\\n            int start = edges[i][0] ;\\n            int end = edges[i][1] ;\\n            adjList.get(start).add(end) ;\\n            inDegree[end]++ ;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>() ;\\n        for(int i=0 ; i<inDegree.length ; i++){\\n            if(inDegree[i] == 0){\\n                queue.add(i);\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int parent = queue.poll() ;\\n            int parent_color = colors.charAt(parent) - \\'a\\' ;\\n            dp[parent][parent_color] = dp[parent][parent_color]+1 ;\\n            for(Integer child : adjList.get(parent)){\\n                inDegree[child]-- ;\\n                if(inDegree[child] == 0){\\n                    queue.add(child);\\n                }\\n                // Copying all the parent color into child but keeping the max color of child . Hence we can find max color till this child .\\n                for(int i=0 ; i<26 ; i++){\\n                    dp[child][i] = Math.max(dp[child][i] , dp[parent][i]); \\n                }\\n            }\\n            count++ ;\\n        }\\n        \\n        if(count != length){\\n            return -1 ;\\n        }\\n        \\n        int max_color = 0 ;\\n        \\n        for(int i=0 ; i<dp.length ; i++){\\n            for(int j=0 ; j<26 ; j++){\\n                max_color = Math.max(max_color , dp[i][j]);\\n            }\\n        }\\n        \\n        return max_color ;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        \\n        int length = colors.length() ;\\n        List<List<Integer>> adjList = new ArrayList<>() ;\\n        int inDegree[] = new int[length] ;\\n        int dp[][] = new int[length][26] ;\\n        int count = 0 ;\\n        \\n        for(int i=0 ; i<length ; i++){\\n            adjList.add(new ArrayList<>());\\n        }\\n        \\n        for(int i=0 ; i<edges.length ; i++){\\n            int start = edges[i][0] ;\\n            int end = edges[i][1] ;\\n            adjList.get(start).add(end) ;\\n            inDegree[end]++ ;\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>() ;\\n        for(int i=0 ; i<inDegree.length ; i++){\\n            if(inDegree[i] == 0){\\n                queue.add(i);\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int parent = queue.poll() ;\\n            int parent_color = colors.charAt(parent) - \\'a\\' ;\\n            dp[parent][parent_color] = dp[parent][parent_color]+1 ;\\n            for(Integer child : adjList.get(parent)){\\n                inDegree[child]-- ;\\n                if(inDegree[child] == 0){\\n                    queue.add(child);\\n                }\\n                // Copying all the parent color into child but keeping the max color of child . Hence we can find max color till this child .\\n                for(int i=0 ; i<26 ; i++){\\n                    dp[child][i] = Math.max(dp[child][i] , dp[parent][i]); \\n                }\\n            }\\n            count++ ;\\n        }\\n        \\n        if(count != length){\\n            return -1 ;\\n        }\\n        \\n        int max_color = 0 ;\\n        \\n        for(int i=0 ; i<dp.length ; i++){\\n            for(int j=0 ; j<26 ; j++){\\n                max_color = Math.max(max_color , dp[i][j]);\\n            }\\n        }\\n        \\n        return max_color ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073138,
                "title": "c-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& graph, vector<int>& visited, vector<vector<int>>& colorFreqMap, string& colors, int current){\\n        if(visited[current] == 0){\\n            visited[current] = 1;\\n            int i, j, k, l;\\n            for(i = 0; i < graph[current].size(); i++){\\n                if(!dfs(graph, visited, colorFreqMap, colors, graph[current][i])){\\n                    return false;\\n                }\\n                for(j = 0; j < 26; j++){\\n                    l = colorFreqMap[graph[current][i]][j];\\n                    k = colors[current] == j + \\'a\\' ? 1 + l : l;\\n                    colorFreqMap[current][j] = max(colorFreqMap[current][j], k);\\n                }\\n            }\\n            visited[current] = 2;\\n            return true;\\n        }\\n        else if(visited[current] == 1){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int i, j, n = colors.length();\\n        vector<vector<int>> graph(n);\\n        \\n        for(i = 0; i < edges.size(); i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<int> visited(n);\\n        vector<vector<int>> colorFreqMap;\\n        for(i = 0; i < n; i++){\\n            vector<int> temp(26);\\n            temp[colors[i] - \\'a\\'] = 1;\\n            colorFreqMap.push_back(temp);\\n        }\\n        \\n        for(i = 0; i < n; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(graph, visited, colorFreqMap, colors, i)){\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < 26; j++){\\n                ans = max(ans, colorFreqMap[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& graph, vector<int>& visited, vector<vector<int>>& colorFreqMap, string& colors, int current){\\n        if(visited[current] == 0){\\n            visited[current] = 1;\\n            int i, j, k, l;\\n            for(i = 0; i < graph[current].size(); i++){\\n                if(!dfs(graph, visited, colorFreqMap, colors, graph[current][i])){\\n                    return false;\\n                }\\n                for(j = 0; j < 26; j++){\\n                    l = colorFreqMap[graph[current][i]][j];\\n                    k = colors[current] == j + \\'a\\' ? 1 + l : l;\\n                    colorFreqMap[current][j] = max(colorFreqMap[current][j], k);\\n                }\\n            }\\n            visited[current] = 2;\\n            return true;\\n        }\\n        else if(visited[current] == 1){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n    \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int i, j, n = colors.length();\\n        vector<vector<int>> graph(n);\\n        \\n        for(i = 0; i < edges.size(); i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<int> visited(n);\\n        vector<vector<int>> colorFreqMap;\\n        for(i = 0; i < n; i++){\\n            vector<int> temp(26);\\n            temp[colors[i] - \\'a\\'] = 1;\\n            colorFreqMap.push_back(temp);\\n        }\\n        \\n        for(i = 0; i < n; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(graph, visited, colorFreqMap, colors, i)){\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < 26; j++){\\n                ans = max(ans, colorFreqMap[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923519,
                "title": "java-solution-using-topo-sort-dp",
                "content": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        //dp[i][j] : largest color value of ending at node i with colour j \\n        int n = colors.length() ;\\n        Map<Integer , ArrayList<Integer>> map = new HashMap<>() ;\\n        for(int i=0 ; i<n ; i++){\\n            map.put(i,new ArrayList<>()) ;\\n        }\\n        int indeg[] = new int[n] ;\\n         for(int ar[] : edges){\\n             indeg[ar[1]]++ ;\\n             map.get(ar[0]).add(ar[1]) ;\\n        }\\n        \\n        Queue<Integer> qu = new LinkedList<>() ;\\n        for(int i=0 ; i<n ; i++){\\n            if(indeg[i]==0)\\n                qu.add(i) ;\\n        }\\n        \\n        int dp[][] = new int[n][26] ;\\n        int vis=0 ;\\n        \\n        while(!qu.isEmpty()){\\n            int node = qu.poll() ;\\n            int color = colors.charAt(node)-\\'a\\' ;\\n            dp[node][color]++ ;\\n            for(int nei : map.get(node)){\\n            \\n                for(int i=0 ; i<26 ; i++)\\n\\t\\t\\t\\t//using current node as parent to update child nodes value\\n\\t\\t\\t\\t//think of the case where two nodes having indegree 0 are pointing to the same child node\\n                    dp[nei][i] = Math.max(dp[nei][i] , dp[node][i]) ;\\n            \\n                if(--indeg[nei]==0)\\n                    qu.add(nei) ;\\n            }\\n            vis++ ;\\n        }\\n        if(vis!=n)return -1 ;\\n        int ans=0 ;\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<26 ; j++){\\n                ans = Math.max(ans , dp[i][j]);\\n            }\\n        }\\n        \\n        return ans ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        //dp[i][j] : largest color value of ending at node i with colour j \\n        int n = colors.length() ;\\n        Map<Integer , ArrayList<Integer>> map = new HashMap<>() ;\\n        for(int i=0 ; i<n ; i++){\\n            map.put(i,new ArrayList<>()) ;\\n        }\\n        int indeg[] = new int[n] ;\\n         for(int ar[] : edges){\\n             indeg[ar[1]]++ ;\\n             map.get(ar[0]).add(ar[1]) ;\\n        }\\n        \\n        Queue<Integer> qu = new LinkedList<>() ;\\n        for(int i=0 ; i<n ; i++){\\n            if(indeg[i]==0)\\n                qu.add(i) ;\\n        }\\n        \\n        int dp[][] = new int[n][26] ;\\n        int vis=0 ;\\n        \\n        while(!qu.isEmpty()){\\n            int node = qu.poll() ;\\n            int color = colors.charAt(node)-\\'a\\' ;\\n            dp[node][color]++ ;\\n            for(int nei : map.get(node)){\\n            \\n                for(int i=0 ; i<26 ; i++)\\n\\t\\t\\t\\t//using current node as parent to update child nodes value\\n\\t\\t\\t\\t//think of the case where two nodes having indegree 0 are pointing to the same child node\\n                    dp[nei][i] = Math.max(dp[nei][i] , dp[node][i]) ;\\n            \\n                if(--indeg[nei]==0)\\n                    qu.add(nei) ;\\n            }\\n            vis++ ;\\n        }\\n        if(vis!=n)return -1 ;\\n        int ans=0 ;\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<26 ; j++){\\n                ans = Math.max(ans , dp[i][j]);\\n            }\\n        }\\n        \\n        return ans ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868744,
                "title": "java-algorithm-explained-in-detail",
                "content": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        \\n        //NOT ORIGINAL JUST EXPLAINING ONE GOOD METHOD IN DISCUSS BOARD\\n        \\n        //consider using DFS + dp, record each node with 26(letters) of it\\'s best records.\\n        //build adjacent list & color hashMap at start\\n        //step1, build the graph with a adjacent list manner O(n)\\n        //step2, do DFS search through each nodes, on each node:\\n        //if visited, looped, return -1\\n        //label as visited\\n        //Do dfs to child nodes\\n        //add the color count to color-count map, if it\\'s bigger than ansMax, update ansMax\\n        //complexity O(n+m)\\n        \\n        HashMap<Integer, ArrayList<Integer>> adjList = new HashMap<>();//adjacent list representation of a graph\\n        for(int[] e : edges){//building adjacent list\\n            if(!adjList.containsKey(e[0])){\\n                ArrayList<Integer> li = new ArrayList<>();\\n                li.add(e[1]);\\n                adjList.put(e[0],li);\\n            }\\n            else{\\n                ArrayList<Integer> li = adjList.get(e[0]);\\n                li.add(e[1]);\\n            }\\n        }\\n        int nodeNum = colors.length();\\n        \\n        int ans = 0;//ansMax\\n        int[][] maxRecord = new int[nodeNum][26]; // max record for each node, each color\\n        int[] visited = new int[nodeNum];// visited list for graph, 0:not visited, 1:visited\\n        for(int i = 0; i < nodeNum; i++){\\n            if(visited[i]!=0)continue;\\n            if(!dfs(i, visited, maxRecord, adjList, colors))return -1;\\n            //maxRecord is updated during dfs()\\n            for(int max : maxRecord[i])ans = Math.max(max, ans);//try to update answer\\n        }\\n        return ans;\\n    }\\n    private boolean dfs(int curNode, int[] visited, int[][] maxRecord, \\n                        HashMap<Integer,ArrayList<Integer>> adjList, String colors){\\n        if(visited[curNode]==1)return true;//verified before\\n        if(visited[curNode]==2)return false;//specifically for this node involved self-cycle, set back to 1 later\\n        visited[curNode]=2;\\n        if(adjList.get(curNode)==null){\\n            maxRecord[curNode][colors.charAt(curNode)-\\'a\\'] += 1;//add self to the color\\n            visited[curNode] = 1;//label verified\\n            return true;\\n        }\\n        for(int neighbor : adjList.get(curNode)){\\n            if(!dfs(neighbor, visited, maxRecord, adjList, colors))return false;//my child goes a loop\\n            for(int i = 0; i < maxRecord[curNode].length; i ++){\\n                maxRecord[curNode][i] = Math.max(maxRecord[curNode][i],maxRecord[neighbor][i]);//adopt neighbor-subtree\\n            }\\n        }\\n        maxRecord[curNode][colors.charAt(curNode)-\\'a\\'] += 1;//add self to the color\\n        visited[curNode] = 1;//label verified\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        \\n        //NOT ORIGINAL JUST EXPLAINING ONE GOOD METHOD IN DISCUSS BOARD\\n        \\n        //consider using DFS + dp, record each node with 26(letters) of it\\'s best records.\\n        //build adjacent list & color hashMap at start\\n        //step1, build the graph with a adjacent list manner O(n)\\n        //step2, do DFS search through each nodes, on each node:\\n        //if visited, looped, return -1\\n        //label as visited\\n        //Do dfs to child nodes\\n        //add the color count to color-count map, if it\\'s bigger than ansMax, update ansMax\\n        //complexity O(n+m)\\n        \\n        HashMap<Integer, ArrayList<Integer>> adjList = new HashMap<>();//adjacent list representation of a graph\\n        for(int[] e : edges){//building adjacent list\\n            if(!adjList.containsKey(e[0])){\\n                ArrayList<Integer> li = new ArrayList<>();\\n                li.add(e[1]);\\n                adjList.put(e[0],li);\\n            }\\n            else{\\n                ArrayList<Integer> li = adjList.get(e[0]);\\n                li.add(e[1]);\\n            }\\n        }\\n        int nodeNum = colors.length();\\n        \\n        int ans = 0;//ansMax\\n        int[][] maxRecord = new int[nodeNum][26]; // max record for each node, each color\\n        int[] visited = new int[nodeNum];// visited list for graph, 0:not visited, 1:visited\\n        for(int i = 0; i < nodeNum; i++){\\n            if(visited[i]!=0)continue;\\n            if(!dfs(i, visited, maxRecord, adjList, colors))return -1;\\n            //maxRecord is updated during dfs()\\n            for(int max : maxRecord[i])ans = Math.max(max, ans);//try to update answer\\n        }\\n        return ans;\\n    }\\n    private boolean dfs(int curNode, int[] visited, int[][] maxRecord, \\n                        HashMap<Integer,ArrayList<Integer>> adjList, String colors){\\n        if(visited[curNode]==1)return true;//verified before\\n        if(visited[curNode]==2)return false;//specifically for this node involved self-cycle, set back to 1 later\\n        visited[curNode]=2;\\n        if(adjList.get(curNode)==null){\\n            maxRecord[curNode][colors.charAt(curNode)-\\'a\\'] += 1;//add self to the color\\n            visited[curNode] = 1;//label verified\\n            return true;\\n        }\\n        for(int neighbor : adjList.get(curNode)){\\n            if(!dfs(neighbor, visited, maxRecord, adjList, colors))return false;//my child goes a loop\\n            for(int i = 0; i < maxRecord[curNode].length; i ++){\\n                maxRecord[curNode][i] = Math.max(maxRecord[curNode][i],maxRecord[neighbor][i]);//adopt neighbor-subtree\\n            }\\n        }\\n        maxRecord[curNode][colors.charAt(curNode)-\\'a\\'] += 1;//add self to the color\\n        visited[curNode] = 1;//label verified\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660471,
                "title": "python-solution-topological-sorting-and-dynamic-programming",
                "content": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n = len(colors)\\n        \\n        # Map the colors from str to int\\n        color_map = {}\\n        for c in colors:\\n            if c not in color_map:\\n                color_map[c] = len(color_map)\\n        color_size = len(color_map)\\n        \\n        # Construct the graph with adj list and calc the in degree of each node\\n        neighbor = defaultdict(lambda: [])\\n        deg = [0 for i in range(n)]\\n        for a, b in edges:\\n            neighbor[a].append(b)\\n            deg[b] += 1\\n        \\n        # Topological Sorting and Dynamic Programming\\n        queue = deque()\\n        \\n        # Each node has a list. The ith element represents\\n        # the maximum number of nodes with ith color in the paths that \\n        # has been found so far.\\n        dp = defaultdict(lambda: [0 for i in range(color_size)])\\n        \\n        for i in range(n):\\n            if deg[i] == 0:\\n                queue.append(i)\\n                c = colors[i]\\n                dp[i][color_map[c]] = 1\\n        \\n        maxLen = 1\\n        while len(queue) > 0:\\n            node = queue.popleft()\\n            \\n            for adj in neighbor[node]:\\n                deg[adj] -= 1\\n                cid = color_map[colors[adj]]\\n                \\n                for j in range(color_size):\\n                    offset = 1 if cid == j else 0\\n                    dp[adj][j] = max(dp[adj][j], dp[node][j] + offset)\\n                    maxLen = max(dp[adj][j], maxLen)\\n                if deg[adj] == 0:\\n                    queue.append(adj)\\n        \\n        if sum(deg) > 0:\\n            return -1\\n        else:\\n            return maxLen\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        n = len(colors)\\n        \\n        # Map the colors from str to int\\n        color_map = {}\\n        for c in colors:\\n            if c not in color_map:\\n                color_map[c] = len(color_map)\\n        color_size = len(color_map)\\n        \\n        # Construct the graph with adj list and calc the in degree of each node\\n        neighbor = defaultdict(lambda: [])\\n        deg = [0 for i in range(n)]\\n        for a, b in edges:\\n            neighbor[a].append(b)\\n            deg[b] += 1\\n        \\n        # Topological Sorting and Dynamic Programming\\n        queue = deque()\\n        \\n        # Each node has a list. The ith element represents\\n        # the maximum number of nodes with ith color in the paths that \\n        # has been found so far.\\n        dp = defaultdict(lambda: [0 for i in range(color_size)])\\n        \\n        for i in range(n):\\n            if deg[i] == 0:\\n                queue.append(i)\\n                c = colors[i]\\n                dp[i][color_map[c]] = 1\\n        \\n        maxLen = 1\\n        while len(queue) > 0:\\n            node = queue.popleft()\\n            \\n            for adj in neighbor[node]:\\n                deg[adj] -= 1\\n                cid = color_map[colors[adj]]\\n                \\n                for j in range(color_size):\\n                    offset = 1 if cid == j else 0\\n                    dp[adj][j] = max(dp[adj][j], dp[node][j] + offset)\\n                    maxLen = max(dp[adj][j], maxLen)\\n                if deg[adj] == 0:\\n                    queue.append(adj)\\n        \\n        if sum(deg) > 0:\\n            return -1\\n        else:\\n            return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599501,
                "title": "python-dp-dfs",
                "content": "```\\nclass Solution:\\n    class CycleException(Exception):\\n        pass\\n    \\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        letters=string.ascii_lowercase\\n        n = len(colors)\\n        # for each node N, maintain a list of all color values (for the graph rooted at N)\\n        color_values=[[1 if colors[node] == char else 0 for char in letters] for node in range(n)]\\n        \\n        # adjacency list for the graph\\n        children=[[] for node in range(n)]\\n        for parent, child in edges:\\n            children[parent].append(child)\\n            if parent == child:\\n                return -1\\n                \\n        def update_color_values(parent, child):\\n            parent_values=color_values[parent]\\n            child_values=color_values[child]\\n            for i in range(len(letters)):\\n                path_value = child_values[i]\\n                if colors[parent] == letters[i]:\\n                    path_value += 1\\n                parent_values[i] = max(parent_values[i], path_value)\\n                \\n        # keep track of nodes we have completely calculated\\n        complete = set() \\n        # keep track of parents so that we can detect cycles\\n        parents=set()\\n        def dfs(root: int):\\n            if root in complete:\\n                return\\n            if root in parents:\\n                raise Solution.CycleException\\n            parents.add(root)\\n            for child in children[root]:\\n                dfs(child)\\n                update_color_values(root, child)\\n            parents.remove(root)\\n            complete.add(root)\\n            \\n        largest = 0\\n        for node in range(n):\\n            try: \\n                dfs(node)\\n            except Solution.CycleException:\\n                return -1\\n            largest = max(largest,max(color_values[node]))\\n        return largest\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    class CycleException(Exception):\\n        pass\\n    \\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        letters=string.ascii_lowercase\\n        n = len(colors)\\n        # for each node N, maintain a list of all color values (for the graph rooted at N)\\n        color_values=[[1 if colors[node] == char else 0 for char in letters] for node in range(n)]\\n        \\n        # adjacency list for the graph\\n        children=[[] for node in range(n)]\\n        for parent, child in edges:\\n            children[parent].append(child)\\n            if parent == child:\\n                return -1\\n                \\n        def update_color_values(parent, child):\\n            parent_values=color_values[parent]\\n            child_values=color_values[child]\\n            for i in range(len(letters)):\\n                path_value = child_values[i]\\n                if colors[parent] == letters[i]:\\n                    path_value += 1\\n                parent_values[i] = max(parent_values[i], path_value)\\n                \\n        # keep track of nodes we have completely calculated\\n        complete = set() \\n        # keep track of parents so that we can detect cycles\\n        parents=set()\\n        def dfs(root: int):\\n            if root in complete:\\n                return\\n            if root in parents:\\n                raise Solution.CycleException\\n            parents.add(root)\\n            for child in children[root]:\\n                dfs(child)\\n                update_color_values(root, child)\\n            parents.remove(root)\\n            complete.add(root)\\n            \\n        largest = 0\\n        for node in range(n):\\n            try: \\n                dfs(node)\\n            except Solution.CycleException:\\n                return -1\\n            largest = max(largest,max(color_values[node]))\\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573495,
                "title": "dp-dfs-topological-sort-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int res;\\n    unordered_map<char, int> mp;\\n    int dfs(vector<int > gf[] , int x, vector<int> &vis, vector<int> &stk){\\n        if(vis[x]==1)return 1;\\n        if(vis[x]==2)return 0;\\n        vis[x]=2;\\n        for(auto it:gf[x]){\\n            \\n            if(!dfs(gf,it,vis,stk))return 0;\\n        }\\n        vis[x]=1;\\n        stk.push_back(x);\\n        return 1;\\n    }\\n    \\n    int dfs2(vector<int > gf[] , int x,vector<vector<int>> &dp,string &col, int cur_col ){\\n        \\n        if(dp[x][cur_col]!=-1)return dp[x][cur_col];\\n       \\n        dp[x][cur_col]=0;\\n        int mx=0;\\n        \\n        for(auto it:gf[x]){\\n            mx=max(mx,dfs2(gf,it,dp,col,cur_col));\\n        }\\n        \\n        dp[x][cur_col]=mx;\\n        if(mp.find(col[x])!=mp.end()&&(cur_col == mp[col[x]])){\\n          dp[x][cur_col]++;  \\n        }\\n        return dp[x][cur_col];\\n    }\\n    \\n    int largestPathValue(string col, vector<vector<int>>& e) {\\n        int n=col.length();\\n        vector<int> gf[n];\\n        for(auto it:e){\\n            gf[it[0]].push_back(it[1]);\\n        }\\n        \\n        /// find topological order->>>\\n        vector<int>vis(n,0);\\n        vector<int>stk;\\n        for(int i=0;i<n;i++){ \\n            if(!vis[i]) \\n            if(!dfs(gf,i,vis,stk))return -1;\\n        }\\n        reverse(stk.begin(),stk.end());\\n        \\n        // found topologincal order \\n        \\n        // in topological order assume each colour is ans so check for each , only 26 so we would be fine O(n*26)\\n        set<char> st(col.begin(),col.end());\\n        \\n        vector<vector<int>> dp(n,vector<int> ( st.size(), -1));\\n        \\n        int iii=0;\\n        for(auto it:st)mp[it]=iii++;\\n        \\n        for(auto it:stk){\\n            for(auto i : st){\\n                res=max(res,dfs2(gf,it,dp,col,mp[i]));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res;\\n    unordered_map<char, int> mp;\\n    int dfs(vector<int > gf[] , int x, vector<int> &vis, vector<int> &stk){\\n        if(vis[x]==1)return 1;\\n        if(vis[x]==2)return 0;\\n        vis[x]=2;\\n        for(auto it:gf[x]){\\n            \\n            if(!dfs(gf,it,vis,stk))return 0;\\n        }\\n        vis[x]=1;\\n        stk.push_back(x);\\n        return 1;\\n    }\\n    \\n    int dfs2(vector<int > gf[] , int x,vector<vector<int>> &dp,string &col, int cur_col ){\\n        \\n        if(dp[x][cur_col]!=-1)return dp[x][cur_col];\\n       \\n        dp[x][cur_col]=0;\\n        int mx=0;\\n        \\n        for(auto it:gf[x]){\\n            mx=max(mx,dfs2(gf,it,dp,col,cur_col));\\n        }\\n        \\n        dp[x][cur_col]=mx;\\n        if(mp.find(col[x])!=mp.end()&&(cur_col == mp[col[x]])){\\n          dp[x][cur_col]++;  \\n        }\\n        return dp[x][cur_col];\\n    }\\n    \\n    int largestPathValue(string col, vector<vector<int>>& e) {\\n        int n=col.length();\\n        vector<int> gf[n];\\n        for(auto it:e){\\n            gf[it[0]].push_back(it[1]);\\n        }\\n        \\n        /// find topological order->>>\\n        vector<int>vis(n,0);\\n        vector<int>stk;\\n        for(int i=0;i<n;i++){ \\n            if(!vis[i]) \\n            if(!dfs(gf,i,vis,stk))return -1;\\n        }\\n        reverse(stk.begin(),stk.end());\\n        \\n        // found topologincal order \\n        \\n        // in topological order assume each colour is ans so check for each , only 26 so we would be fine O(n*26)\\n        set<char> st(col.begin(),col.end());\\n        \\n        vector<vector<int>> dp(n,vector<int> ( st.size(), -1));\\n        \\n        int iii=0;\\n        for(auto it:st)mp[it]=iii++;\\n        \\n        for(auto it:stk){\\n            for(auto i : st){\\n                res=max(res,dfs2(gf,it,dp,col,mp[i]));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553364,
                "title": "dp-dfs-solution-with-explanation-motivation",
                "content": "First, I\\'ll just dump my solution then explain how I got it:\\n```\\nclass Solution {\\n    \\n    public int largestPathValue(String colors, int[][] edges) {\\n        Map<Integer, List<Integer>> graph = makeGraph(edges);\\n        int n = colors.length();\\n        // nodeStatus: 0 = unvisited, 1 = visiting, 2 = visited\\n        int[] nodeStatus = new int[n];\\n        Set<Character> allColors = new HashSet<>();\\n        for(char c : colors.toCharArray()) {\\n            allColors.add(c);\\n        }\\n        Map<Integer, Map<Character, Integer>> nodeToColorToVal = new HashMap<>();\\n        int max = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nodeStatus[i] == 2) {\\n                continue;\\n            }\\n            int lcv = explore(i, graph, nodeStatus, colors, allColors, nodeToColorToVal);\\n            if (lcv == -1) {\\n                return -1;\\n            }\\n            max = Math.max(max, lcv);\\n        }\\n        return max;\\n    }\\n    \\n    // creates adjacency graph representation\\n    private Map<Integer, List<Integer>> makeGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int[] edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            List<Integer> children = graph.getOrDefault(from, new ArrayList<>());\\n            children.add(to);\\n            graph.put(from, children);\\n        }\\n        return graph;\\n    }\\n    \\n    private Map<Character, Integer> initColorToVal(Set<Character> allColors) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(Character c : allColors) {\\n            map.put(c, 0);\\n        }\\n        return map;\\n    }\\n    \\n    //return -1 if cycle\\n    private int explore(int node,\\n                        Map<Integer,\\n                        List<Integer>> graph,\\n                        int[] nodeStatus,\\n                        String colors,\\n                        Set<Character> allColors,\\n                        Map<Integer, Map<Character, Integer>> nodeToColorToVal) {\\n        // mark node as visiting\\n        nodeStatus[node] = 1;\\n        int max = 1;\\n        Map<Character, Integer> colorToVal = initColorToVal(allColors);\\n        \\n        // recurse children\\n        for(Integer child : graph.getOrDefault(node, new ArrayList<>())) {\\n            // found a back edge, that is, found a cycle\\n            if (nodeStatus[child] == 1) {\\n                return -1;\\n            }\\n            // only recurse if not visited\\n            if (nodeStatus[child] == 0) {\\n                int cVal = explore(child, graph, nodeStatus, colors, allColors, nodeToColorToVal);\\n                if (cVal == -1) {\\n                    return -1;\\n                }\\n            }\\n            // handle colorToVal business\\n            for(Character color : allColors) {\\n                int existingVal = colorToVal.get(color);\\n                int childVal = nodeToColorToVal.get(child).get(color);\\n                if (childVal > existingVal) {\\n                    colorToVal.put(color, childVal);\\n                    max = Math.max(max, childVal);\\n                }\\n            }\\n        }\\n        // and add contribution of current node to appropriate color\\n        int currCurrentVal = colorToVal.getOrDefault(colors.charAt(node), 0) + 1;\\n        colorToVal.put(colors.charAt(node), currCurrentVal);\\n        max = Math.max(max, currCurrentVal);\\n        \\n        // populate our collection of subproblems with that for this node\\n        nodeToColorToVal.put(node, colorToVal);\\n        // mark node as visited\\n        nodeStatus[node] = 2;\\n        return max;\\n    }\\n    \\n}\\n```\\nExplanation:\\nFirst let\\'s make 2 observations about this problem:\\n1) If we have LCV along a path, then extending it can only improve the LCV. This suggests naive approach where, for all \"roots\" with no inbound edges, keep following paths till we hit a \"leaf\" with no outbound edges and find LCVs over each such trajectory and max over them. Simple DFS would find all root->leaf paths and can also detect presence of a cycle as well. So now question is, can we use Dynamic Programming to save work?\\n2) At each node, we can\\'t simply store a single LCV value. Why? Well say we have this graph below and we\\'re finding subproblem for node 2 (boxed): \\n![image](https://assets.leetcode.com/users/images/b49037b9-265e-4a7c-a0c1-4c2b17b9ef3c_1635786388.7669652.png)\\nNow from #2\\'s perspective, the LCV would be from path 2->3->4->5 and would be for color \"B\" and value would be 3 (node 3, node 4, node 5). But actually LCV for graph starts at node 0 and is 0->1->2->6 and is for color \"R\" and value is actually 4 (node 0, node 1, node 2, node 6). So when computing subproblem for node 2, we incorrectly discarded 2->6 path. We lost some information because color B \"dominated\" color R. So we need to store more information at each node. Hopefully this is motivation that we should add a color channel as well. This is now sufficient (One way to convince yourself is thinking about reduce the question to finding LCV but for 1 specfic color only).See ```nodeToColorToVal``` subproblem in my code. ```nodeToColorToVal.get(node).get(color)``` gives LCV over all paths starting at that ```node``` for that ```color```. To determine ```nodeToColorToVal.get(node)```, we would need to compute ```nodeToColorToVal.get(child)``` over all children. For each ```color```, cosider node\\'s color and max over all children\\'s  ```nodeToColorToVal.get(child).get(color)```. So we\\'ve recursively defined subproblem of a node in terms of it\\'s children, which is how DFS works.\\n\\nSo putting everything together, DFS is just screaming to be used. It can detect cycle and it gives us a way to order solving subproblems.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int largestPathValue(String colors, int[][] edges) {\\n        Map<Integer, List<Integer>> graph = makeGraph(edges);\\n        int n = colors.length();\\n        // nodeStatus: 0 = unvisited, 1 = visiting, 2 = visited\\n        int[] nodeStatus = new int[n];\\n        Set<Character> allColors = new HashSet<>();\\n        for(char c : colors.toCharArray()) {\\n            allColors.add(c);\\n        }\\n        Map<Integer, Map<Character, Integer>> nodeToColorToVal = new HashMap<>();\\n        int max = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nodeStatus[i] == 2) {\\n                continue;\\n            }\\n            int lcv = explore(i, graph, nodeStatus, colors, allColors, nodeToColorToVal);\\n            if (lcv == -1) {\\n                return -1;\\n            }\\n            max = Math.max(max, lcv);\\n        }\\n        return max;\\n    }\\n    \\n    // creates adjacency graph representation\\n    private Map<Integer, List<Integer>> makeGraph(int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int[] edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            List<Integer> children = graph.getOrDefault(from, new ArrayList<>());\\n            children.add(to);\\n            graph.put(from, children);\\n        }\\n        return graph;\\n    }\\n    \\n    private Map<Character, Integer> initColorToVal(Set<Character> allColors) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(Character c : allColors) {\\n            map.put(c, 0);\\n        }\\n        return map;\\n    }\\n    \\n    //return -1 if cycle\\n    private int explore(int node,\\n                        Map<Integer,\\n                        List<Integer>> graph,\\n                        int[] nodeStatus,\\n                        String colors,\\n                        Set<Character> allColors,\\n                        Map<Integer, Map<Character, Integer>> nodeToColorToVal) {\\n        // mark node as visiting\\n        nodeStatus[node] = 1;\\n        int max = 1;\\n        Map<Character, Integer> colorToVal = initColorToVal(allColors);\\n        \\n        // recurse children\\n        for(Integer child : graph.getOrDefault(node, new ArrayList<>())) {\\n            // found a back edge, that is, found a cycle\\n            if (nodeStatus[child] == 1) {\\n                return -1;\\n            }\\n            // only recurse if not visited\\n            if (nodeStatus[child] == 0) {\\n                int cVal = explore(child, graph, nodeStatus, colors, allColors, nodeToColorToVal);\\n                if (cVal == -1) {\\n                    return -1;\\n                }\\n            }\\n            // handle colorToVal business\\n            for(Character color : allColors) {\\n                int existingVal = colorToVal.get(color);\\n                int childVal = nodeToColorToVal.get(child).get(color);\\n                if (childVal > existingVal) {\\n                    colorToVal.put(color, childVal);\\n                    max = Math.max(max, childVal);\\n                }\\n            }\\n        }\\n        // and add contribution of current node to appropriate color\\n        int currCurrentVal = colorToVal.getOrDefault(colors.charAt(node), 0) + 1;\\n        colorToVal.put(colors.charAt(node), currCurrentVal);\\n        max = Math.max(max, currCurrentVal);\\n        \\n        // populate our collection of subproblems with that for this node\\n        nodeToColorToVal.put(node, colorToVal);\\n        // mark node as visited\\n        nodeStatus[node] = 2;\\n        return max;\\n    }\\n    \\n}\\n```\n```nodeToColorToVal```\n```nodeToColorToVal.get(node).get(color)```\n```node```\n```color```\n```nodeToColorToVal.get(node)```\n```nodeToColorToVal.get(child)```\n```color```\n```nodeToColorToVal.get(child).get(color)```",
                "codeTag": "Java"
            },
            {
                "id": 1544006,
                "title": "java-dfs-memoization-solution",
                "content": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int len = colors.length();\\n        List<Integer>[] graph = buildGraph(len, edges);\\n        \\n        int[] frequencies = new int[26];\\n        HashMap<Integer, int[]> calculatedFrequencies = new HashMap<>();\\n        int[] status = new int[len];\\n        for(int i = 0; i < len; i++) {\\n            if (status[i] != 0) {\\n                continue;\\n            }\\n\\n            // Although, the maximum number of colors is 26, the method will return an array of integer of length 27\\n            // 0-25 will be used for storing the maximum frequency of colors.\\n            // 26 will be used for determining if there is a loop in the graph.\\n            // If it is set to -1 during the DFS, there is a loop in the graph and it is not solvable.\\n            int[] localMax = runDFS(graph, i, calculatedFrequencies, status, colors);\\n            \\n            if (localMax[26] == -1) {\\n                Arrays.fill(frequencies, -1);\\n                break;\\n            } else {\\n                for(int color = 0; color < 26; color++) {\\n                    frequencies[color] = Math.max(frequencies[color], localMax[color]);\\n                }\\n            }\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int freq : frequencies) {\\n            max = Math.max(max, freq);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int[] runDFS(List<Integer>[] graph, int node, HashMap<Integer, int[]> calculatedFrequencies, int[] status, String colors) {\\n        if (calculatedFrequencies.containsKey(node)) {\\n            return calculatedFrequencies.get(node);\\n        }\\n\\n        int[] frequencies = new int[27];\\n        if (status[node] == 1) {\\n            frequencies[26] = -1;\\n            return frequencies;\\n        }\\n\\n        status[node] = 1;\\n        for(int neighbour : graph[node]) {\\n            int[] localMax = runDFS(graph, neighbour, calculatedFrequencies, status, colors);\\n            \\n            if (localMax[26] == -1) {\\n                return localMax;\\n            }\\n            \\n            for(int i = 0; i < 26; i++) {\\n                frequencies[i] = Math.max(frequencies[i], localMax[i]);\\n            }\\n        }\\n        status[node] = 2;\\n        \\n        int color = colors.charAt(node) - \\'a\\';\\n        frequencies[color]++;\\n        \\n        calculatedFrequencies.put(node, frequencies);\\n        \\n        return frequencies;\\n    }\\n    \\n    private List<Integer>[] buildGraph(int n, int[][] edges) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n\\n        for(int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int len = colors.length();\\n        List<Integer>[] graph = buildGraph(len, edges);\\n        \\n        int[] frequencies = new int[26];\\n        HashMap<Integer, int[]> calculatedFrequencies = new HashMap<>();\\n        int[] status = new int[len];\\n        for(int i = 0; i < len; i++) {\\n            if (status[i] != 0) {\\n                continue;\\n            }\\n\\n            // Although, the maximum number of colors is 26, the method will return an array of integer of length 27\\n            // 0-25 will be used for storing the maximum frequency of colors.\\n            // 26 will be used for determining if there is a loop in the graph.\\n            // If it is set to -1 during the DFS, there is a loop in the graph and it is not solvable.\\n            int[] localMax = runDFS(graph, i, calculatedFrequencies, status, colors);\\n            \\n            if (localMax[26] == -1) {\\n                Arrays.fill(frequencies, -1);\\n                break;\\n            } else {\\n                for(int color = 0; color < 26; color++) {\\n                    frequencies[color] = Math.max(frequencies[color], localMax[color]);\\n                }\\n            }\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int freq : frequencies) {\\n            max = Math.max(max, freq);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int[] runDFS(List<Integer>[] graph, int node, HashMap<Integer, int[]> calculatedFrequencies, int[] status, String colors) {\\n        if (calculatedFrequencies.containsKey(node)) {\\n            return calculatedFrequencies.get(node);\\n        }\\n\\n        int[] frequencies = new int[27];\\n        if (status[node] == 1) {\\n            frequencies[26] = -1;\\n            return frequencies;\\n        }\\n\\n        status[node] = 1;\\n        for(int neighbour : graph[node]) {\\n            int[] localMax = runDFS(graph, neighbour, calculatedFrequencies, status, colors);\\n            \\n            if (localMax[26] == -1) {\\n                return localMax;\\n            }\\n            \\n            for(int i = 0; i < 26; i++) {\\n                frequencies[i] = Math.max(frequencies[i], localMax[i]);\\n            }\\n        }\\n        status[node] = 2;\\n        \\n        int color = colors.charAt(node) - \\'a\\';\\n        frequencies[color]++;\\n        \\n        calculatedFrequencies.put(node, frequencies);\\n        \\n        return frequencies;\\n    }\\n    \\n    private List<Integer>[] buildGraph(int n, int[][] edges) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n\\n        for(int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539293,
                "title": "java-topological-order-o-m-n",
                "content": "This problem is similiar to [Parallel Courses III Solution Post](https://leetcode.com/problems/parallel-courses-iii/discuss/1539221/Java-or-Topological-Order-or-O(N%2BM)-or-Thinking-process)\\nPlease upvote if you think it\\'s helpful.\\n```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n = colors.length(), visited = 0, res = 0;\\n        Map<Integer, Set<Integer>> dep = new HashMap();\\n        int[] inDegree = new int[n];\\n        int[][] max = new int[n][26];\\n        for(int[]e : edges) {\\n            int u = e[0], v = e[1];\\n            dep.computeIfAbsent(u, x -> new HashSet()).add(v);\\n            inDegree[v]++;\\n        }\\n        Deque<Integer> q = new LinkedList();\\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) q.offer(i);\\n        }\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            visited += size;\\n            while(size-- > 0) {\\n                int cur = q.poll(), color = colors.charAt(cur) -\\'a\\';\\n                max[cur][color]++; \\n                res = Math.max(res, max[cur][color]); // update the result of the current color, since only the number of current color increased\\n                for(int nei : dep.getOrDefault(cur, new HashSet<>())) {\\n                    for(int i = 0; i < 26; i++) {\\n                        max[nei][i] = Math.max(max[cur][i], max[nei][i]); // maximum number of nodes for each color to reach ith node\\n                    }\\n                    inDegree[nei]--;\\n                    if(inDegree[nei] == 0) q.offer(nei);\\n                }\\n            }\\n            \\n        }\\n        return visited == n ? res : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n = colors.length(), visited = 0, res = 0;\\n        Map<Integer, Set<Integer>> dep = new HashMap();\\n        int[] inDegree = new int[n];\\n        int[][] max = new int[n][26];\\n        for(int[]e : edges) {\\n            int u = e[0], v = e[1];\\n            dep.computeIfAbsent(u, x -> new HashSet()).add(v);\\n            inDegree[v]++;\\n        }\\n        Deque<Integer> q = new LinkedList();\\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) q.offer(i);\\n        }\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            visited += size;\\n            while(size-- > 0) {\\n                int cur = q.poll(), color = colors.charAt(cur) -\\'a\\';\\n                max[cur][color]++; \\n                res = Math.max(res, max[cur][color]); // update the result of the current color, since only the number of current color increased\\n                for(int nei : dep.getOrDefault(cur, new HashSet<>())) {\\n                    for(int i = 0; i < 26; i++) {\\n                        max[nei][i] = Math.max(max[cur][i], max[nei][i]); // maximum number of nodes for each color to reach ith node\\n                    }\\n                    inDegree[nei]--;\\n                    if(inDegree[nei] == 0) q.offer(nei);\\n                }\\n            }\\n            \\n        }\\n        return visited == n ? res : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481442,
                "title": "c-solution-for-1857-largest-color-value-in-a-directed-graph",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) \\n    {   \\n        int sz = colors.size();\\n        queue<int> q;\\n        vector<int> indegree(sz,0);\\n        vector<vector<int>> adj(sz);\\n        vector<vector<int>> charCount(sz, vector<int>(26,0));\\n        \\n        for(auto e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            indegree[e[1]]++ ;\\n        }\\n        for(int i=0; i<sz; i++)\\n        {\\n            if(indegree[i] == 0){q.push(i);}\\n        }\\n        int res = 0 ; int visited = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int node = q.front(); q.pop(); visited++ ;\\n            res = max(res, ++charCount[node][colors[node] - \\'a\\']);\\n            for(auto it : adj[node])\\n            {\\n                indegree[it]-- ;\\n                if(indegree[it] == 0){q.push(it);}\\n                for(int c=0; c<26; c++)\\n                {\\n                    charCount[it][c] = max(charCount[node][c], charCount[it][c]) ;\\n                }\\n            }\\n        }\\n        if(visited != sz){return -1;}\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) \\n    {   \\n        int sz = colors.size();\\n        queue<int> q;\\n        vector<int> indegree(sz,0);\\n        vector<vector<int>> adj(sz);\\n        vector<vector<int>> charCount(sz, vector<int>(26,0));\\n        \\n        for(auto e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            indegree[e[1]]++ ;\\n        }\\n        for(int i=0; i<sz; i++)\\n        {\\n            if(indegree[i] == 0){q.push(i);}\\n        }\\n        int res = 0 ; int visited = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int node = q.front(); q.pop(); visited++ ;\\n            res = max(res, ++charCount[node][colors[node] - \\'a\\']);\\n            for(auto it : adj[node])\\n            {\\n                indegree[it]-- ;\\n                if(indegree[it] == 0){q.push(it);}\\n                for(int c=0; c<26; c++)\\n                {\\n                    charCount[it][c] = max(charCount[node][c], charCount[it][c]) ;\\n                }\\n            }\\n        }\\n        if(visited != sz){return -1;}\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412024,
                "title": "java-dfs-memo-easy-solution",
                "content": "```\\nclass Solution {\\n    ArrayList<Integer>[] graph;\\n    int max_color = 0;\\n    boolean isCycle = false;\\n    HashMap<Integer, HashMap<Character, Integer>> dp = new HashMap<>();\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int N = colors.length();\\n        graph = new ArrayList[N];\\n        for(int i = 0 ; i < N ; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] e : edges){\\n            graph[e[0]].add(e[1]);\\n        }\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        boolean[] vis = new boolean[N];\\n        for(int i = 0 ; i < N ; i++){\\n            getPath(colors, vis, i);\\n            \\n            if(isCycle) return -1;\\n        }\\n        return max_color;\\n    }\\n    \\n    public HashMap<Character, Integer> getPath(String color, boolean[] vis, int src){\\n        if(vis[src]){\\n            isCycle = true;\\n            return new HashMap<>();\\n        }\\n        if(dp.containsKey(src)) return dp.get(src);\\n        vis[src] = true;\\n        boolean status = false;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int e : graph[src]){\\n            HashMap<Character, Integer> f = getPath(color, vis, e);\\n            \\n            if(isCycle) return new HashMap<>();\\n            \\n            for(char c : f.keySet()){\\n                int f_val = f.get(c);\\n                int c_val = map.getOrDefault(c, 0);\\n                c_val = Math.max(c_val, f_val);\\n                max_color = Math.max(max_color, c_val);\\n                map.put(c, c_val);\\n            }\\n        }\\n        map.put(color.charAt(src), map.getOrDefault(color.charAt(src), 0) + 1);\\n        max_color = Math.max(max_color, map.get(color.charAt(src)));\\n        vis[src] = false;\\n        dp.put(src, map);\\n        return map;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<Integer>[] graph;\\n    int max_color = 0;\\n    boolean isCycle = false;\\n    HashMap<Integer, HashMap<Character, Integer>> dp = new HashMap<>();\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int N = colors.length();\\n        graph = new ArrayList[N];\\n        for(int i = 0 ; i < N ; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] e : edges){\\n            graph[e[0]].add(e[1]);\\n        }\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        boolean[] vis = new boolean[N];\\n        for(int i = 0 ; i < N ; i++){\\n            getPath(colors, vis, i);\\n            \\n            if(isCycle) return -1;\\n        }\\n        return max_color;\\n    }\\n    \\n    public HashMap<Character, Integer> getPath(String color, boolean[] vis, int src){\\n        if(vis[src]){\\n            isCycle = true;\\n            return new HashMap<>();\\n        }\\n        if(dp.containsKey(src)) return dp.get(src);\\n        vis[src] = true;\\n        boolean status = false;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int e : graph[src]){\\n            HashMap<Character, Integer> f = getPath(color, vis, e);\\n            \\n            if(isCycle) return new HashMap<>();\\n            \\n            for(char c : f.keySet()){\\n                int f_val = f.get(c);\\n                int c_val = map.getOrDefault(c, 0);\\n                c_val = Math.max(c_val, f_val);\\n                max_color = Math.max(max_color, c_val);\\n                map.put(c, c_val);\\n            }\\n        }\\n        map.put(color.charAt(src), map.getOrDefault(color.charAt(src), 0) + 1);\\n        max_color = Math.max(max_color, map.get(color.charAt(src)));\\n        vis[src] = false;\\n        dp.put(src, map);\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407104,
                "title": "o-26-n-still-not-passing",
                "content": "can anyone help , why my code is not running\\n```\\nconst int maxn = 1e5+10;\\nint dp[maxn];\\nint col[maxn];\\nint vis[maxn];\\nclass graph\\n{\\nlist<int>*l;\\nint n;\\npublic:\\n    graph(int n){\\n        this->n = n;\\n        l = new list<int>[n+3];\\n    }\\n    void addedge(int x,int y){\\n        l[x].push_back(y);\\n    }\\n    int iscycle(int src){\\n        vis[src]++;\\n        int ans = 0;\\n        for(auto x:l[src]){\\n            if(vis[x]){\\n                return 1;\\n            }\\n            ans += iscycle(x);\\n        }\\n        vis[src]--;\\n        return ans;\\n    }\\n    int maxval(int src,int val){\\n        if(dp[src]!=-1){\\n            return dp[src];\\n        }\\n        int ans = 0;\\n        for(auto x:l[src]){\\n            ans = max(ans,maxval(x,val));\\n        }\\n        if(col[src]==val)\\n            dp[src] = ans+1;\\n        else\\n            dp[src] = ans;\\n        return dp[src];\\n        \\n    }\\n    ~graph(){\\n        delete[] l;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.length();\\n        graph g(n);\\n        for(int i=0;i<n;i++){\\n            vis[i] = 0;\\n            col[i] = colors[i] - \\'a\\';\\n        }\\n        for(auto x:edges){\\n            g.addedge(x[0],x[1]);\\n        }\\n        int ans = 0;\\n        if(g.iscycle(0)){\\n            return -1;\\n        }\\n        for(int j=0;j<26;j++){\\n            for(int i=0;i<n;i++){\\n                dp[i] = -1;\\n            }\\n            for(int i=0;i<n;i++){\\n                ans = max(ans,g.maxval(i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int maxn = 1e5+10;\\nint dp[maxn];\\nint col[maxn];\\nint vis[maxn];\\nclass graph\\n{\\nlist<int>*l;\\nint n;\\npublic:\\n    graph(int n){\\n        this->n = n;\\n        l = new list<int>[n+3];\\n    }\\n    void addedge(int x,int y){\\n        l[x].push_back(y);\\n    }\\n    int iscycle(int src){\\n        vis[src]++;\\n        int ans = 0;\\n        for(auto x:l[src]){\\n            if(vis[x]){\\n                return 1;\\n            }\\n            ans += iscycle(x);\\n        }\\n        vis[src]--;\\n        return ans;\\n    }\\n    int maxval(int src,int val){\\n        if(dp[src]!=-1){\\n            return dp[src];\\n        }\\n        int ans = 0;\\n        for(auto x:l[src]){\\n            ans = max(ans,maxval(x,val));\\n        }\\n        if(col[src]==val)\\n            dp[src] = ans+1;\\n        else\\n            dp[src] = ans;\\n        return dp[src];\\n        \\n    }\\n    ~graph(){\\n        delete[] l;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.length();\\n        graph g(n);\\n        for(int i=0;i<n;i++){\\n            vis[i] = 0;\\n            col[i] = colors[i] - \\'a\\';\\n        }\\n        for(auto x:edges){\\n            g.addedge(x[0],x[1]);\\n        }\\n        int ans = 0;\\n        if(g.iscycle(0)){\\n            return -1;\\n        }\\n        for(int j=0;j<26;j++){\\n            for(int i=0;i<n;i++){\\n                dp[i] = -1;\\n            }\\n            for(int i=0;i<n;i++){\\n                ans = max(ans,g.maxval(i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353547,
                "title": "python-top-sort-beat-82",
                "content": "Standard Top Sort problem. The only tricky point here is that when processing max number of colors in path at each node, we need to consider all incoming paths to that node, and with only top sort we can\\'t do that. For example: if we have A -> B, D -> B and C -> B, added to queue in respective order, top sort would only consider `C -> B` since that is when `in-degree` of B becomes 0. Thus we need some way to save information from all incoming paths for each node. Beside dictionary, another way is using dynamic programming. However, dictionary is more straight-forward to me. We notice that each color dictionaray would have at max 26 keys (number of letters in alp. ). Thus comparing 2 dictionary is O(1) and mainting dictionary is O(V). Overall time complexity is O(V+E). Space complexity is O(V).\\n\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        graph = collections.defaultdict(list)\\n        inDegree = [0] * len(colors); visited = []; ans = 1\\n        \\n        for source, destination in edges:\\n            graph[source].append(destination)\\n            inDegree[destination] += 1\\n                    \\n        q = deque([])\\n        colorDictByNode = collections.defaultdict(Counter)\\n        \\n        for node in range(len(inDegree)):\\n            if not inDegree[node]:\\n                q.append(node); colorDictByNode[node] = Counter(colors[node])\\n                \\n        while q:\\n            currentNode = q.popleft()\\n            ans = max(ans, colorDictByNode[currentNode].most_common(1)[0][1])\\n            \\n            visited.append(currentNode)\\n            \\n            for destination in graph[currentNode]:\\n                inDegree[destination] -= 1\\n                \\n                # \"merge\" 2 Counters\\n                for color in colorDictByNode[currentNode]:\\n                    colorDictByNode[destination][color] = max(colorDictByNode[destination].get(color,0), colorDictByNode[currentNode][color] if color != colors[destination] else colorDictByNode[currentNode][color] + 1)\\n                    \\n                if colors[destination] not in colorDictByNode[currentNode]:\\n                    colorDictByNode[destination][colors[destination]] = max(colorDictByNode[destination].get(colors[destination], 0), 1)\\n                    \\n                if inDegree[destination] == 0:\\n                    q.append(destination)\\n                \\n        return ans if len(visited) == len(colors) else -1 \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        graph = collections.defaultdict(list)\\n        inDegree = [0] * len(colors); visited = []; ans = 1\\n        \\n        for source, destination in edges:\\n            graph[source].append(destination)\\n            inDegree[destination] += 1\\n                    \\n        q = deque([])\\n        colorDictByNode = collections.defaultdict(Counter)\\n        \\n        for node in range(len(inDegree)):\\n            if not inDegree[node]:\\n                q.append(node); colorDictByNode[node] = Counter(colors[node])\\n                \\n        while q:\\n            currentNode = q.popleft()\\n            ans = max(ans, colorDictByNode[currentNode].most_common(1)[0][1])\\n            \\n            visited.append(currentNode)\\n            \\n            for destination in graph[currentNode]:\\n                inDegree[destination] -= 1\\n                \\n                # \"merge\" 2 Counters\\n                for color in colorDictByNode[currentNode]:\\n                    colorDictByNode[destination][color] = max(colorDictByNode[destination].get(color,0), colorDictByNode[currentNode][color] if color != colors[destination] else colorDictByNode[currentNode][color] + 1)\\n                    \\n                if colors[destination] not in colorDictByNode[currentNode]:\\n                    colorDictByNode[destination][colors[destination]] = max(colorDictByNode[destination].get(colors[destination], 0), 1)\\n                    \\n                if inDegree[destination] == 0:\\n                    q.append(destination)\\n                \\n        return ans if len(visited) == len(colors) else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334126,
                "title": "python-topological-sort",
                "content": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        from collections import defaultdict, Counter\\n        graph = defaultdict(set)\\n        node_indegree = Counter()\\n        color_count = defaultdict(Counter)\\n        for u, v in edges:\\n            node_indegree[v] += 1\\n            graph[u].add(v)\\n        topological_sort = []\\n        ans_set = set()\\n        bfs_list = [node for node in range(len(colors)) if node_indegree[node] == 0]\\n        while bfs_list:\\n            node = bfs_list.pop()\\n            color_count[node][colors[node]] += 1\\n            topological_sort.append(node)\\n            if graph[node]:\\n                for adj_node in graph[node]:\\n                    node_indegree[adj_node] -= 1\\n                    for color, count in color_count[node].items():\\n                        color_count[adj_node][color] = max(color_count[adj_node][color], count)\\n                    if node_indegree[adj_node] == 0:\\n                        bfs_list.append(adj_node)\\n            else:\\n                ans_set.add(max(color_count[node].values()))\\n        return max(ans_set) if len(topological_sort) == len(colors) else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        from collections import defaultdict, Counter\\n        graph = defaultdict(set)\\n        node_indegree = Counter()\\n        color_count = defaultdict(Counter)\\n        for u, v in edges:\\n            node_indegree[v] += 1\\n            graph[u].add(v)\\n        topological_sort = []\\n        ans_set = set()\\n        bfs_list = [node for node in range(len(colors)) if node_indegree[node] == 0]\\n        while bfs_list:\\n            node = bfs_list.pop()\\n            color_count[node][colors[node]] += 1\\n            topological_sort.append(node)\\n            if graph[node]:\\n                for adj_node in graph[node]:\\n                    node_indegree[adj_node] -= 1\\n                    for color, count in color_count[node].items():\\n                        color_count[adj_node][color] = max(color_count[adj_node][color], count)\\n                    if node_indegree[adj_node] == 0:\\n                        bfs_list.append(adj_node)\\n            else:\\n                ans_set.add(max(color_count[node].values()))\\n        return max(ans_set) if len(topological_sort) == len(colors) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232947,
                "title": "kotlin-topological-sort-kahn-s-algorithm",
                "content": "Solution - [github](https://github.com/idiotleon/leetcode-solutions-kotlin-leon/tree/main/src/main/kotlin/com/an7one/leetcode/lvl4/lc1857)\\n\\n<b>By Tag</b>\\n#TopologicalSort - [github](https://github.com/idiotleon/leetcode-problems-by-tag-leon/blob/main/txt/by_algorithm/sort/by_algorithm/topological_sort.txt)\\n#DetectingCycle - [github](https://github.com/idiotleon/leetcode-problems-by-tag-leon/blob/main/txt/by_data_structure/graph/by_topic/detect_cycle.txt)\\n\\n```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/largest-color-value-in-a-directed-graph/\\n *\\n * Time Complexity:     O(V + E) ~ O(`lenC` + `nEdges`)\\n * Space Complexity:    O(V + E) ~ O(`lenC` + `nEdges`)\\n *\\n * Reference:\\n * https://leetcode.com/problems/largest-color-value-in-a-directed-graph/discuss/1198658/C++-Topological-Sort/931674\\n * https://leetcode.com/problems/largest-color-value-in-a-directed-graph/discuss/1198658/C%2B%2B-Topological-Sorts\\n */\\nclass Solution {\\n    fun largestPathValue(colors: String, edges: Array<IntArray>): Int {\\n        // also serves as the number of vertices\\n        val lenC = colors.length\\n\\n        // not used\\n        // val nEdges = edges.size\\n\\n        val (graph, indegrees) = buildGraph(lenC, edges)\\n\\n        val chToChFreqs = Array(lenC) { IntArray(26) }\\n\\n        val queue = ArrayDeque<Int>()\\n        for ((idx, indegree) in indegrees.withIndex()) {\\n            if (indegree == 0) {\\n                queue.addLast(idx)\\n                chToChFreqs[idx][colors[idx] - \\'a\\'] = 1\\n            }\\n        }\\n\\n        var seen = 0\\n        var largest = 0\\n\\n        while (queue.isNotEmpty()) {\\n            val cur = queue.removeFirst()\\n            ++seen\\n\\n            largest = maxOf(largest, chToChFreqs[cur].max()!!)\\n\\n            graph[cur]?.let {\\n                for (next in it) {\\n                    for (i in 0 until 26) {\\n                        chToChFreqs[next][i] =\\n                            maxOf(chToChFreqs[next][i], chToChFreqs[cur][i] + if (colors[next] - \\'a\\' == i) 1 else 0)\\n                    }\\n\\n                    if (--indegrees[next] == 0) queue.addLast(next)\\n                }\\n            }\\n        }\\n\\n        return if (seen == lenC) largest else -1\\n    }\\n\\n    fun buildGraph(nVertices: Int, edges: Array<IntArray>): Pair<Map<Int, HashSet<Int>>, IntArray> {\\n        val graph = HashMap<Int, HashSet<Int>>()\\n        val indegrees = IntArray(nVertices) { 0 }\\n\\n        for ((u, v) in edges) {\\n            graph.getOrPut(u) { HashSet() }.add(v)\\n            ++indegrees[v]\\n        }\\n\\n        return Pair(graph, indegrees)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Topological Sort"
                ],
                "code": "```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/largest-color-value-in-a-directed-graph/\\n *\\n * Time Complexity:     O(V + E) ~ O(`lenC` + `nEdges`)\\n * Space Complexity:    O(V + E) ~ O(`lenC` + `nEdges`)\\n *\\n * Reference:\\n * https://leetcode.com/problems/largest-color-value-in-a-directed-graph/discuss/1198658/C++-Topological-Sort/931674\\n * https://leetcode.com/problems/largest-color-value-in-a-directed-graph/discuss/1198658/C%2B%2B-Topological-Sorts\\n */\\nclass Solution {\\n    fun largestPathValue(colors: String, edges: Array<IntArray>): Int {\\n        // also serves as the number of vertices\\n        val lenC = colors.length\\n\\n        // not used\\n        // val nEdges = edges.size\\n\\n        val (graph, indegrees) = buildGraph(lenC, edges)\\n\\n        val chToChFreqs = Array(lenC) { IntArray(26) }\\n\\n        val queue = ArrayDeque<Int>()\\n        for ((idx, indegree) in indegrees.withIndex()) {\\n            if (indegree == 0) {\\n                queue.addLast(idx)\\n                chToChFreqs[idx][colors[idx] - \\'a\\'] = 1\\n            }\\n        }\\n\\n        var seen = 0\\n        var largest = 0\\n\\n        while (queue.isNotEmpty()) {\\n            val cur = queue.removeFirst()\\n            ++seen\\n\\n            largest = maxOf(largest, chToChFreqs[cur].max()!!)\\n\\n            graph[cur]?.let {\\n                for (next in it) {\\n                    for (i in 0 until 26) {\\n                        chToChFreqs[next][i] =\\n                            maxOf(chToChFreqs[next][i], chToChFreqs[cur][i] + if (colors[next] - \\'a\\' == i) 1 else 0)\\n                    }\\n\\n                    if (--indegrees[next] == 0) queue.addLast(next)\\n                }\\n            }\\n        }\\n\\n        return if (seen == lenC) largest else -1\\n    }\\n\\n    fun buildGraph(nVertices: Int, edges: Array<IntArray>): Pair<Map<Int, HashSet<Int>>, IntArray> {\\n        val graph = HashMap<Int, HashSet<Int>>()\\n        val indegrees = IntArray(nVertices) { 0 }\\n\\n        for ((u, v) in edges) {\\n            graph.getOrPut(u) { HashSet() }.add(v)\\n            ++indegrees[v]\\n        }\\n\\n        return Pair(graph, indegrees)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223639,
                "title": "c-topological-sort-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.size();\\n        \\n        map<int, vector<int>> graph;\\n        \\n        int indegree[n];\\n        \\n        memset(indegree, 0, sizeof(indegree));\\n        for(int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        \\n        int colorCnt[n][26];\\n        \\n        memset(colorCnt, 0, sizeof(colorCnt));\\n        \\n        // topological sort\\n        // at a position\\n        // we keep track of how many max times we encountered colors of each type\\n        // having computed it at each possible node\\n        \\n        \\n        // we finally run one each of the nodes and find max value\\n        // encountered for any color on any node..\\n        // or probably update it while running \\n        // topological sort itself...\\n        \\n        queue<int> Q;\\n        //cout << \"0 indegree :  \"<< endl;\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) {\\n                //cout << i << endl;\\n                Q.push(i);\\n            }\\n        }\\n        \\n        int ans = -1;\\n        \\n        while(!Q.empty()) {\\n            int front = Q.front();\\n            colorCnt[front][colors[front] - \\'a\\']++;\\n            for(int i = 0; i < 26; i++) {\\n               ans = max(ans, colorCnt[front][i]); \\n            }\\n            \\n            Q.pop();\\n            \\n            for(auto node: graph[front]) {\\n                indegree[node]--;\\n                if(indegree[node] == 0) {\\n                    Q.push(node);\\n                }\\n                \\n                for(int i = 0; i < 26; i++) {\\n                    colorCnt[node][i] = max(colorCnt[node][i], colorCnt[front][i]);\\n                }\\n            }    \\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] != 0) {\\n                return -1;\\n            }\\n        }\\n        \\n        // set<char> st(colors.begin(), colors.end());\\n        // vector<char> uc(st.begin(), st.end());\\n        \\n        // for(int i = 0; i < n; i++) {\\n        //     cout << \"node = \" << i << endl;\\n        //     for(char c: uc) {\\n        //         cout << c << \" : \" << colorCnt[i][c - \\'a\\'] << endl; \\n        //     }\\n        // }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.size();\\n        \\n        map<int, vector<int>> graph;\\n        \\n        int indegree[n];\\n        \\n        memset(indegree, 0, sizeof(indegree));\\n        for(int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        \\n        int colorCnt[n][26];\\n        \\n        memset(colorCnt, 0, sizeof(colorCnt));\\n        \\n        // topological sort\\n        // at a position\\n        // we keep track of how many max times we encountered colors of each type\\n        // having computed it at each possible node\\n        \\n        \\n        // we finally run one each of the nodes and find max value\\n        // encountered for any color on any node..\\n        // or probably update it while running \\n        // topological sort itself...\\n        \\n        queue<int> Q;\\n        //cout << \"0 indegree :  \"<< endl;\\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] == 0) {\\n                //cout << i << endl;\\n                Q.push(i);\\n            }\\n        }\\n        \\n        int ans = -1;\\n        \\n        while(!Q.empty()) {\\n            int front = Q.front();\\n            colorCnt[front][colors[front] - \\'a\\']++;\\n            for(int i = 0; i < 26; i++) {\\n               ans = max(ans, colorCnt[front][i]); \\n            }\\n            \\n            Q.pop();\\n            \\n            for(auto node: graph[front]) {\\n                indegree[node]--;\\n                if(indegree[node] == 0) {\\n                    Q.push(node);\\n                }\\n                \\n                for(int i = 0; i < 26; i++) {\\n                    colorCnt[node][i] = max(colorCnt[node][i], colorCnt[front][i]);\\n                }\\n            }    \\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(indegree[i] != 0) {\\n                return -1;\\n            }\\n        }\\n        \\n        // set<char> st(colors.begin(), colors.end());\\n        // vector<char> uc(st.begin(), st.end());\\n        \\n        // for(int i = 0; i < n; i++) {\\n        //     cout << \"node = \" << i << endl;\\n        //     for(char c: uc) {\\n        //         cout << c << \" : \" << colorCnt[i][c - \\'a\\'] << endl; \\n        //     }\\n        // }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1222191,
                "title": "dfs-with-explaination",
                "content": "```\\n/**\\n * @param {string} colors\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar largestPathValue = function(colors, edges) {\\n    /*Here we are populating a dictionary \\'data\\', where data[node] will have max possible count for each color(the colors which are available in paths starting from \\'node\\') in any of the path starting from \\'node\\'\\n    Now lets consider this example \\n         --->1(c)->2(b)->3(a)\\n       / \\n0(a) /\\n    |\\\\\\n    |  \\\\ ---> 4(a)->5(a)->6(b)\\n    |\\n\\t|\\n    |--->7(b)->8(c)->9(c)\\n    \\n    for the above graph\\n    data[3]=>{a:1}\\n    data[2]=>{a:1,b:1}\\n    data[1]=>{a:1,b:1,c:1}\\n    \\n    data[6]=>{b:1}\\n    data[5]=>{a:1,b:1}\\n    data[4]=>{a:2,b:1}\\n    \\n    data[9]=>{c:1}\\n    data[8]=>{c:2}\\n    data[7]=>{b:1,c:2}\\n    \\n    data[0]=>{a:3,b:1,c:2}\\n    \\n    Whenver we call dfs with any \\'node\\' then the output data[node] will have the maximum possible values for all the colors.\\n    */\\n    let data={},maxColorCount=-1,maxColor=-1;\\n    let visited = {},colorCountMap={},edgesMap={},max=-1,res;\\n    for(let i=0;i<edges.length;i++){\\n        if(edgesMap[edges[i][0]]===undefined){\\n            edgesMap[edges[i][0]]=[];\\n        }\\n        edgesMap[edges[i][0]].push(edges[i][1]);\\n    }\\n    for(let i=0;i<colors.length;i++){     \\n        res = dfs(i);\\n        if(res===false){\\n            return -1;\\n        }else{\\n            for(const[key,val] of Object.entries(res)){\\n                if(val>maxColorCount){\\n                    maxColorCount=val;\\n                    maxColor=key;\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxColorCount;\\n    \\n    function dfs(node){\\n        let res=false,map=false;\\n        \\n        if(data[node]!==undefined){//We have already visited all the paths from this node\\n            return data[node];\\n        }\\n        if(visited[node]!==undefined){//This is a cycle, we got this node again while visiting of its paths\\n            return false;\\n        }\\n        visited[node]=true;\\n        if(edgesMap[node]!==undefined){\\n            for(let i=0;i<edgesMap[node].length;i++){\\n                res = dfs(edgesMap[node][i]);\\n                if(res===false){\\n                    return false;\\n                }\\n                if(map===false){\\n                    map=JSON.parse(JSON.stringify(res));\\n                }else{\\n                    for(const[key,val] of Object.entries(res)){\\n                        if(map[key]===undefined){\\n                            map[key]=val;\\n                        }else{\\n                            if(map[key]<val){\\n                                map[key]=val;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(map===false){//If this is an edge node, we dont have any outgoing edge from this node\\n            map={};\\n            map[colors[node]]=1;//So the path starting from this node will have only one color, the color of node itself\\n        }else if(map[colors[node]]===undefined){//If none of the paths starting from this node contains the same color as of this node. \\n            map[colors[node]]=1;\\n        }else{//Increment the max count by 1 for the node\\'s color\\n            map[colors[node]]+=1;\\n        }\\n        delete visited[node];\\n        data[node]=JSON.parse(JSON.stringify(map));\\n        return data[node];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} colors\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar largestPathValue = function(colors, edges) {\\n    /*Here we are populating a dictionary \\'data\\', where data[node] will have max possible count for each color(the colors which are available in paths starting from \\'node\\') in any of the path starting from \\'node\\'\\n    Now lets consider this example \\n         --->1(c)->2(b)->3(a)\\n       / \\n0(a) /\\n    |\\\\\\n    |  \\\\ ---> 4(a)->5(a)->6(b)\\n    |\\n\\t|\\n    |--->7(b)->8(c)->9(c)\\n    \\n    for the above graph\\n    data[3]=>{a:1}\\n    data[2]=>{a:1,b:1}\\n    data[1]=>{a:1,b:1,c:1}\\n    \\n    data[6]=>{b:1}\\n    data[5]=>{a:1,b:1}\\n    data[4]=>{a:2,b:1}\\n    \\n    data[9]=>{c:1}\\n    data[8]=>{c:2}\\n    data[7]=>{b:1,c:2}\\n    \\n    data[0]=>{a:3,b:1,c:2}\\n    \\n    Whenver we call dfs with any \\'node\\' then the output data[node] will have the maximum possible values for all the colors.\\n    */\\n    let data={},maxColorCount=-1,maxColor=-1;\\n    let visited = {},colorCountMap={},edgesMap={},max=-1,res;\\n    for(let i=0;i<edges.length;i++){\\n        if(edgesMap[edges[i][0]]===undefined){\\n            edgesMap[edges[i][0]]=[];\\n        }\\n        edgesMap[edges[i][0]].push(edges[i][1]);\\n    }\\n    for(let i=0;i<colors.length;i++){     \\n        res = dfs(i);\\n        if(res===false){\\n            return -1;\\n        }else{\\n            for(const[key,val] of Object.entries(res)){\\n                if(val>maxColorCount){\\n                    maxColorCount=val;\\n                    maxColor=key;\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxColorCount;\\n    \\n    function dfs(node){\\n        let res=false,map=false;\\n        \\n        if(data[node]!==undefined){//We have already visited all the paths from this node\\n            return data[node];\\n        }\\n        if(visited[node]!==undefined){//This is a cycle, we got this node again while visiting of its paths\\n            return false;\\n        }\\n        visited[node]=true;\\n        if(edgesMap[node]!==undefined){\\n            for(let i=0;i<edgesMap[node].length;i++){\\n                res = dfs(edgesMap[node][i]);\\n                if(res===false){\\n                    return false;\\n                }\\n                if(map===false){\\n                    map=JSON.parse(JSON.stringify(res));\\n                }else{\\n                    for(const[key,val] of Object.entries(res)){\\n                        if(map[key]===undefined){\\n                            map[key]=val;\\n                        }else{\\n                            if(map[key]<val){\\n                                map[key]=val;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(map===false){//If this is an edge node, we dont have any outgoing edge from this node\\n            map={};\\n            map[colors[node]]=1;//So the path starting from this node will have only one color, the color of node itself\\n        }else if(map[colors[node]]===undefined){//If none of the paths starting from this node contains the same color as of this node. \\n            map[colors[node]]=1;\\n        }else{//Increment the max count by 1 for the node\\'s color\\n            map[colors[node]]+=1;\\n        }\\n        delete visited[node];\\n        data[node]=JSON.parse(JSON.stringify(map));\\n        return data[node];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220930,
                "title": "c-dp-topological-sort-kahn-s-algorithm-solution",
                "content": "Solution: Topological Sort using Kahn\\'s Algorithm.\\n\\nIntuition: The graph is a directed graph. Also there may be cycles in graph. We need an algo to detect cycles in graph while visiting the nodes. Also to keep a track of max frequency color in all paths until current node, we need to have dp implementation along with topo sort.\\n\\nFirst model the problem into an adjacency list graph. For each node have the count of incoming edges. Once this is done we can do topological sort using Kahn\\'s algorithm.\\n\\nKahn\\'s Algorithm:\\n```\\nEnqueue vertices with zero incoming degree into a (priority) queue Q;\\nHere in this problem a simple queue works good.\\nwhile (Q is not empty) {\\n\\tnode u = Q.dequeue();     // put node u into a topological sort list;\\n\\tfor (all child nodes of vertex u) {\\n\\t\\tindegree[child]--;          // remove this node u and all outgoing edges from this node;\\t\\n\\t\\tif (indegree[child] == 0)\\n\\t\\t\\tQ.enqueue(child);     // if such removal causes node child to have zero incoming degree, enqueue it in queue;\\n\\t}     \\n}\\n\\nNote: To detect cycle in graph using this algo, if at the end of topo sort, if any node has indegree > 0, there is a cycle present in the graph.\\n\\nbool cyclePresent = false;\\nfor (each node v in graph)\\n\\tif (indegree[v] != 0)\\n\\t\\tcyclePresent = true;\\n\\n```\\n\\n\\n\\nDP approach to store count of colors for each node:\\nWe slightly modify the topo sort algo to store count of color.\\nAt each node we store cnt[node][26] where cnt[node][i] is the maximum frequency count of color i seen in all paths that end on current node.\\n\\nFor example, assume there are two paths reaching the current node- abaca, aaabba. Then cnt[\\'a\\'] = 4, cnt[\\'b\\'] = 2 and cnt[\\'c\\'] = 1.\\nCount of \\'a\\' is 4 because the max appearance of color \\'a\\' is in 2nd path where it  appears 4 times.  Similarly count \\'b\\' is 2 as it appears twice in 2nd path and count \\'c\\' is 1 as it appears only once in path 1.\\nAnswer will be the max value seen in cnt[] of any node.\\n\\nC++ solution:\\n```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.length();\\n        vector<int> in(n, 0);\\n        vector<vector<int>> g(n);\\n        int cnt[n][26];\\n        memset(cnt, 0, sizeof cnt);\\n        int ans = 0; \\n        \\n        // Make adj list graph.\\n        for(auto &edge: edges){\\n            g[edge[0]].push_back(edge[1]);\\n            in[edge[1]]++;\\n        }\\n        \\n        // Push the vertices with 0 indegree to queue.\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(!in[i])\\n                q.push(i);\\n        }\\n        \\n        // Topological sort.\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            int col = colors[node]-\\'a\\';\\n            cnt[node][col]++;                 // Increment the count of color at current node.\\n            ans = max(ans, cnt[node][col]);    // Update answer to max value count value.\\n            for(auto &child: g[node]){\\n                for(int i=0; i<26; i++){    \\n                    cnt[child][i] = max(cnt[child][i], cnt[node][i]);     // Inherit max count value in child node from parent node.\\n                }\\n                in[child]--;                       // Remove the incoming edge by decrementing the indegree of child node.\\n                if(!in[child])                     // Enqueue child node in queue if it\\'s indegree becomes 0.\\n                    q.push(child);\\n            }\\n        }\\n        \\n        // Check for cycle in graph.\\n        for(int i=0; i<n; i++)\\n            if(in[i])\\n                return -1;\\n        \\n        return ans;\\n    }\\n};\\n```\\nTime Complexity: O(V+E)\\nSpace Complexity: O(V+E)",
                "solutionTags": [],
                "code": "```\\nEnqueue vertices with zero incoming degree into a (priority) queue Q;\\nHere in this problem a simple queue works good.\\nwhile (Q is not empty) {\\n\\tnode u = Q.dequeue();     // put node u into a topological sort list;\\n\\tfor (all child nodes of vertex u) {\\n\\t\\tindegree[child]--;          // remove this node u and all outgoing edges from this node;\\t\\n\\t\\tif (indegree[child] == 0)\\n\\t\\t\\tQ.enqueue(child);     // if such removal causes node child to have zero incoming degree, enqueue it in queue;\\n\\t}     \\n}\\n\\nNote: To detect cycle in graph using this algo, if at the end of topo sort, if any node has indegree > 0, there is a cycle present in the graph.\\n\\nbool cyclePresent = false;\\nfor (each node v in graph)\\n\\tif (indegree[v] != 0)\\n\\t\\tcyclePresent = true;\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n = colors.length();\\n        vector<int> in(n, 0);\\n        vector<vector<int>> g(n);\\n        int cnt[n][26];\\n        memset(cnt, 0, sizeof cnt);\\n        int ans = 0; \\n        \\n        // Make adj list graph.\\n        for(auto &edge: edges){\\n            g[edge[0]].push_back(edge[1]);\\n            in[edge[1]]++;\\n        }\\n        \\n        // Push the vertices with 0 indegree to queue.\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(!in[i])\\n                q.push(i);\\n        }\\n        \\n        // Topological sort.\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            int col = colors[node]-\\'a\\';\\n            cnt[node][col]++;                 // Increment the count of color at current node.\\n            ans = max(ans, cnt[node][col]);    // Update answer to max value count value.\\n            for(auto &child: g[node]){\\n                for(int i=0; i<26; i++){    \\n                    cnt[child][i] = max(cnt[child][i], cnt[node][i]);     // Inherit max count value in child node from parent node.\\n                }\\n                in[child]--;                       // Remove the incoming edge by decrementing the indegree of child node.\\n                if(!in[child])                     // Enqueue child node in queue if it\\'s indegree becomes 0.\\n                    q.push(child);\\n            }\\n        }\\n        \\n        // Check for cycle in graph.\\n        for(int i=0; i<n; i++)\\n            if(in[i])\\n                return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220435,
                "title": "java-dfs-graph-colouring-linear-time",
                "content": "```\\nclass Solution {\\n    int maxColor = 0;\\n    public int largestPathValue(String colors, int[][] edges) {\\n        Set<Character> colorSet = new HashSet<>();\\n        for(int i = 0; i < colors.length(); i++) colorSet.add(colors.charAt(i));\\n        int maxCol = 0;\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < edges.length; i++) {\\n            if(graph.containsKey(edges[i][0]) == false) graph.put(edges[i][0], new ArrayList<>());\\n            graph.get(edges[i][0]).add(edges[i][1]);\\n        }\\n        if(checkCycle(graph, colors.length())==true) return -1;\\n        for (char color : colorSet) {\\n            maxColor(graph, color, colors);\\n            maxCol = Math.max(maxCol, maxColor);\\n        }\\n        return maxCol;\\n    }\\n    private boolean checkCycle(Map<Integer, List<Integer>> graph, int nodes) {\\n        int[] states = new int[nodes];\\n        for(int i = 0; i < nodes; i++) if(states[i] == 0 && checkCycleDfs(graph, i, states) == true) return true;\\n        return false;\\n    }\\n    private boolean checkCycleDfs(Map<Integer, List<Integer>> graph, int node, int[] states) {\\n        if(states[node] == 1) return true;\\n        if(states[node] == 2) return false;\\n        states[node] = 1;\\n        List<Integer> nodes = graph.getOrDefault(node, new ArrayList<Integer>());\\n        for(int i = 0; i < nodes.size(); i++) if(checkCycleDfs(graph, nodes.get(i), states) == true) return true;\\n        states[node] = 2;\\n        return false;\\n    }\\n    private void maxColor(Map<Integer, List<Integer>> graph, char color, String colors) {\\n        int[] maxCols = new int[colors.length()];\\n        maxColor = 0;\\n        for(int i = 0; i < colors.length(); i++) maxCols[i] = -1;\\n        for(int i = 0; i < colors.length(); i++) if(maxCols[i] == -1) maxColor = Math.max(maxColor, maxColorDfs(graph, i, maxCols, color, colors));\\n    }\\n    private int maxColorDfs(Map<Integer, List<Integer>> graph, int node, int[] maxCols, char color, String colors) {\\n        if(maxCols[node] > -1) return maxCols[node];\\n        if(colors.charAt(node) == color) maxCols[node] = 1;\\n        else maxCols[node] = 0;\\n        int otherCost = 0;\\n        List<Integer> nodes = graph.getOrDefault(node, new ArrayList<Integer>());\\n        for(int i = 0; i < nodes.size(); i++) otherCost = Math.max(otherCost, maxColorDfs(graph, nodes.get(i), maxCols, color, colors));\\n        maxCols[node] += otherCost;\\n        return maxCols[node];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxColor = 0;\\n    public int largestPathValue(String colors, int[][] edges) {\\n        Set<Character> colorSet = new HashSet<>();\\n        for(int i = 0; i < colors.length(); i++) colorSet.add(colors.charAt(i));\\n        int maxCol = 0;\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < edges.length; i++) {\\n            if(graph.containsKey(edges[i][0]) == false) graph.put(edges[i][0], new ArrayList<>());\\n            graph.get(edges[i][0]).add(edges[i][1]);\\n        }\\n        if(checkCycle(graph, colors.length())==true) return -1;\\n        for (char color : colorSet) {\\n            maxColor(graph, color, colors);\\n            maxCol = Math.max(maxCol, maxColor);\\n        }\\n        return maxCol;\\n    }\\n    private boolean checkCycle(Map<Integer, List<Integer>> graph, int nodes) {\\n        int[] states = new int[nodes];\\n        for(int i = 0; i < nodes; i++) if(states[i] == 0 && checkCycleDfs(graph, i, states) == true) return true;\\n        return false;\\n    }\\n    private boolean checkCycleDfs(Map<Integer, List<Integer>> graph, int node, int[] states) {\\n        if(states[node] == 1) return true;\\n        if(states[node] == 2) return false;\\n        states[node] = 1;\\n        List<Integer> nodes = graph.getOrDefault(node, new ArrayList<Integer>());\\n        for(int i = 0; i < nodes.size(); i++) if(checkCycleDfs(graph, nodes.get(i), states) == true) return true;\\n        states[node] = 2;\\n        return false;\\n    }\\n    private void maxColor(Map<Integer, List<Integer>> graph, char color, String colors) {\\n        int[] maxCols = new int[colors.length()];\\n        maxColor = 0;\\n        for(int i = 0; i < colors.length(); i++) maxCols[i] = -1;\\n        for(int i = 0; i < colors.length(); i++) if(maxCols[i] == -1) maxColor = Math.max(maxColor, maxColorDfs(graph, i, maxCols, color, colors));\\n    }\\n    private int maxColorDfs(Map<Integer, List<Integer>> graph, int node, int[] maxCols, char color, String colors) {\\n        if(maxCols[node] > -1) return maxCols[node];\\n        if(colors.charAt(node) == color) maxCols[node] = 1;\\n        else maxCols[node] = 0;\\n        int otherCost = 0;\\n        List<Integer> nodes = graph.getOrDefault(node, new ArrayList<Integer>());\\n        for(int i = 0; i < nodes.size(); i++) otherCost = Math.max(otherCost, maxColorDfs(graph, nodes.get(i), maxCols, color, colors));\\n        maxCols[node] += otherCost;\\n        return maxCols[node];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208858,
                "title": "ruby-topological-sort",
                "content": "[Link to the problem](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/submissions/)\\n\\n### Idea\\n\\n[Thanks lzl124631x for the original solution](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/discuss/1198658/C%2B%2B-Topological-Sort)\\n\\nWe do normal topo sort. The catch here is to use BFS and make sure that a node is visited only when all of its parents (node that directs to it) are visited. In the code below, we use the array `in_degree` for that purpose and only visit a node `u` if `in_degree[u] == 0`. This way, we can compare all the incoming result and update acordingly for the current node.\\n\\nFor each node `u`, we have `cnt[u][i]` which is the maximum count of color `i` in all paths that ends up at node `u`\\n\\nIf there is a cycle in the graph, we would not visit a node in that cycle at all since the `in_degree` of them woule never be 0. We use this inuiton to detect cycle.\\n\\n### Complexity\\n\\n- Time & Space: O(n)\\n\\n### Code\\n\\n```ruby\\ndef largest_path_value(color, edges)\\n  color = color.split(\"\").map { |c| c.ord - \"a\".ord }\\n  n = color.size\\n  graph = 0.upto(n - 1).map { [] }\\n  in_degree = [0] * n\\n\\n  edges.each do |u, v|\\n    graph[u] << v\\n    in_degree[v] += 1\\n  end\\n\\n  qu = []\\n  cnt = 0.upto(n - 1).map { [0] * 26 }\\n  0.upto(n - 1) do |u|\\n    next if in_degree[u] != 0\\n\\n    qu.push(u)\\n    cnt[u][color[u]] = 1\\n  end\\n\\n  ret, seen = 0, 0\\n  until qu.empty?\\n    u = qu.shift\\n    ret = [ret, cnt[u][color[u]]].max\\n    seen += 1\\n\\n    graph[u].each do |v|\\n      0.upto 25 do |i|\\n        add = i == color[v] ? 1 : 0\\n        cnt[v][i] = [cnt[v][i], cnt[u][i] + add].max\\n      end\\n      qu << v if (in_degree[v] -= 1).zero?\\n    end\\n  end\\n\\n  seen < n ? -1 : ret\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef largest_path_value(color, edges)\\n  color = color.split(\"\").map { |c| c.ord - \"a\".ord }\\n  n = color.size\\n  graph = 0.upto(n - 1).map { [] }\\n  in_degree = [0] * n\\n\\n  edges.each do |u, v|\\n    graph[u] << v\\n    in_degree[v] += 1\\n  end\\n\\n  qu = []\\n  cnt = 0.upto(n - 1).map { [0] * 26 }\\n  0.upto(n - 1) do |u|\\n    next if in_degree[u] != 0\\n\\n    qu.push(u)\\n    cnt[u][color[u]] = 1\\n  end\\n\\n  ret, seen = 0, 0\\n  until qu.empty?\\n    u = qu.shift\\n    ret = [ret, cnt[u][color[u]]].max\\n    seen += 1\\n\\n    graph[u].each do |v|\\n      0.upto 25 do |i|\\n        add = i == color[v] ? 1 : 0\\n        cnt[v][i] = [cnt[v][i], cnt[u][i] + add].max\\n      end\\n      qu << v if (in_degree[v] -= 1).zero?\\n    end\\n  end\\n\\n  seen < n ? -1 : ret\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1208802,
                "title": "topological-sort-bfs-dfs",
                "content": "BFS prune nodes with in-degree 0 via a queue `q`.  Let `last` be the front-most node in the queue `q` which is about to be pruned.  As part of the pruning process, we add `1` onto the `last` pruned node\\'s `best` color count and check if the result is a new `optimal` solution; then each `next` adjacent node\\'s `best` color count is updated to the maximum of itself and the `last` pruned node\\'s `best` color count.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun largestPathValue(colors: String, edges: Array<IntArray>): Int {\\n        var optimal = 0\\n        var N = colors.length\\n        var best = Array(N) { mutableMapOf<Char, Int>() }   // best color count from each node\\'s perspective\\n        var adj = Array(N) { mutableListOf<Int>() }         // adjacency list\\n        var deg = IntArray(N) { 0 }                         // in-degree count for each i-th vertex\\n        for ((u, v) in edges) {\\n            adj[u]!!.add(v); ++deg[v]\\n        }\\n        var q: Queue<Int> = LinkedList<Int>()\\n        var seen = 0\\n        for (i in 0 until N)\\n            if (deg[i] == 0)                               // \\uD83D\\uDE8C bfs prune in-degree 0\\n                q.add(i)\\n        while (0 < q.size) {\\n            var u = q.poll(); ++seen\\n            var color = colors[u]\\n            var last = best[u]\\n            last[color] = 1 + last.getOrDefault(color, 0)  // \\uD83D\\uDCDD +1 onto the count of this last node to be pruned to include the color of the last node in the ongoing maximal tally\\n            optimal = Math.max(optimal, last[color]!!)     // \\uD83C\\uDFAF was the last color count the optimal solution?\\n            for (v in adj[u]!!) {\\n                var next = best[v]                         // \\uD83C\\uDF32 update ongoing bfs branches\\' color counts: ie. take maximum of last node\\'s best color count and adjacent next node\\'s best color count\\n                for ((color, _) in last) {\\n                    next[color] = Math.max(next.getOrDefault(color, 0), last[color]!!)  // \\uD83D\\uDCB0 always take best (ie. maximum color count of next and last)\\n                }\\n                if (--deg[v] == 0)                         // \\uD83D\\uDE8C bfs prune in-degree 0\\n                    q.add(v)\\n            }\\n        }\\n        return if (seen == N) optimal else -1              // \\uD83D\\uDCA5 cycle occurs if we did not see all N vertices \\uD83D\\uDC40\\n    }\\n}\\n```\\n\\n---\\n\\nDFS starting from in-degree zero.  (same concept as above, using DFS instead of BFS)\\n\\n*Python3*\\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]], best = 0) -> int:\\n        N = len(colors)\\n        unique = set(colors)\\n        seen = set()\\n        adj = {}\\n        m = { i: {} for i in range(N) }\\n        deg = [0] * N\\n        for u, v in edges:\\n            if not u in adj: adj[u] = []\\n            adj[u].append(v); deg[v] += 1\\n        seen = set()\\n        def go(u, path = set()):\\n            nonlocal best\\n            if u in seen:\\n                return True\\n            seen.add(u)\\n            pre = m[u]\\n            for v in adj[u] if u in adj else []:\\n                if v in path:\\n                    return False\\n                path.add(v)\\n                if not go(v, path):\\n                    return False\\n                path.remove(v)\\n                cur = m[v]\\n                for x in unique:\\n                    if not x in pre: pre[x] = 0\\n                    if not x in cur: cur[x] = 0\\n                    pre[x] = max(pre[x], cur[x])\\n            color = colors[u]\\n            pre[color] = 1 + (pre[color] if color in pre else 0)\\n            best = max(best, pre[color])\\n            return True\\n        for u in range(N):\\n            if not deg[u]:\\n                if not go(u, set([ u ])):\\n                    return -1\\n        return best if len(seen) == N else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun largestPathValue(colors: String, edges: Array<IntArray>): Int {\\n        var optimal = 0\\n        var N = colors.length\\n        var best = Array(N) { mutableMapOf<Char, Int>() }   // best color count from each node\\'s perspective\\n        var adj = Array(N) { mutableListOf<Int>() }         // adjacency list\\n        var deg = IntArray(N) { 0 }                         // in-degree count for each i-th vertex\\n        for ((u, v) in edges) {\\n            adj[u]!!.add(v); ++deg[v]\\n        }\\n        var q: Queue<Int> = LinkedList<Int>()\\n        var seen = 0\\n        for (i in 0 until N)\\n            if (deg[i] == 0)                               // \\uD83D\\uDE8C bfs prune in-degree 0\\n                q.add(i)\\n        while (0 < q.size) {\\n            var u = q.poll(); ++seen\\n            var color = colors[u]\\n            var last = best[u]\\n            last[color] = 1 + last.getOrDefault(color, 0)  // \\uD83D\\uDCDD +1 onto the count of this last node to be pruned to include the color of the last node in the ongoing maximal tally\\n            optimal = Math.max(optimal, last[color]!!)     // \\uD83C\\uDFAF was the last color count the optimal solution?\\n            for (v in adj[u]!!) {\\n                var next = best[v]                         // \\uD83C\\uDF32 update ongoing bfs branches\\' color counts: ie. take maximum of last node\\'s best color count and adjacent next node\\'s best color count\\n                for ((color, _) in last) {\\n                    next[color] = Math.max(next.getOrDefault(color, 0), last[color]!!)  // \\uD83D\\uDCB0 always take best (ie. maximum color count of next and last)\\n                }\\n                if (--deg[v] == 0)                         // \\uD83D\\uDE8C bfs prune in-degree 0\\n                    q.add(v)\\n            }\\n        }\\n        return if (seen == N) optimal else -1              // \\uD83D\\uDCA5 cycle occurs if we did not see all N vertices \\uD83D\\uDC40\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]], best = 0) -> int:\\n        N = len(colors)\\n        unique = set(colors)\\n        seen = set()\\n        adj = {}\\n        m = { i: {} for i in range(N) }\\n        deg = [0] * N\\n        for u, v in edges:\\n            if not u in adj: adj[u] = []\\n            adj[u].append(v); deg[v] += 1\\n        seen = set()\\n        def go(u, path = set()):\\n            nonlocal best\\n            if u in seen:\\n                return True\\n            seen.add(u)\\n            pre = m[u]\\n            for v in adj[u] if u in adj else []:\\n                if v in path:\\n                    return False\\n                path.add(v)\\n                if not go(v, path):\\n                    return False\\n                path.remove(v)\\n                cur = m[v]\\n                for x in unique:\\n                    if not x in pre: pre[x] = 0\\n                    if not x in cur: cur[x] = 0\\n                    pre[x] = max(pre[x], cur[x])\\n            color = colors[u]\\n            pre[color] = 1 + (pre[color] if color in pre else 0)\\n            best = max(best, pre[color])\\n            return True\\n        for u in range(N):\\n            if not deg[u]:\\n                if not go(u, set([ u ])):\\n                    return -1\\n        return best if len(seen) == N else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205878,
                "title": "50-python-topolgical-sort-bfs-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def getColors(self, color1, color2):\\n        color = [0 for i in range(26)]\\n        for i in range(26):\\n            color[i] = max(color1[i], color2[i])\\n        return color\\n        \\n    def addColor(self, dp, colors, vertex):\\n        new_color = dp.copy()\\n        new_color[ord(colors[vertex]) - 97] += 1\\n        \\n        return new_color\\n    \\n    def getTopSort(self, in_degree, adjList):\\n        counted_so_far, bfs = 0, []\\n        self.topSort = []\\n        for i, degree in enumerate(in_degree):\\n            if not degree:\\n                bfs.append(i)\\n        \\n        while bfs:\\n            node = bfs.pop(-1)\\n            self.topSort.append(node)\\n            counted_so_far += 1\\n            \\n            if node in adjList:\\n                for vertex in adjList[node]:\\n                    in_degree[vertex] -= 1\\n                    if not in_degree[vertex]:\\n                        bfs.append(vertex)\\n                \\n        return counted_so_far == len(in_degree)\\n    \\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        adjList = dict()\\n        in_degree = [0 for i in range(len(colors))]\\n        \\n        for src, dest in edges:\\n            if src not in adjList:\\n                adjList[src] = []\\n            adjList[src].append(dest)\\n            in_degree[dest] += 1\\n        \\n        if not self.getTopSort(in_degree, adjList):\\n            return -1\\n        \\n        ans = 1\\n        dp = [[0 for i in range(26)] for i in range(len(colors))]\\n        for i in self.topSort:\\n            dp[i][ord(colors[i]) - 97] = 1\\n        \\n        for node in self.topSort:\\n            if node in adjList:\\n                for vertex in adjList[node]:\\n                    dp[vertex] = self.getColors(self.addColor(dp[node], colors, vertex), dp[vertex])\\n                    ans = max(ans, max(dp[vertex]))\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getColors(self, color1, color2):\\n        color = [0 for i in range(26)]\\n        for i in range(26):\\n            color[i] = max(color1[i], color2[i])\\n        return color\\n        \\n    def addColor(self, dp, colors, vertex):\\n        new_color = dp.copy()\\n        new_color[ord(colors[vertex]) - 97] += 1\\n        \\n        return new_color\\n    \\n    def getTopSort(self, in_degree, adjList):\\n        counted_so_far, bfs = 0, []\\n        self.topSort = []\\n        for i, degree in enumerate(in_degree):\\n            if not degree:\\n                bfs.append(i)\\n        \\n        while bfs:\\n            node = bfs.pop(-1)\\n            self.topSort.append(node)\\n            counted_so_far += 1\\n            \\n            if node in adjList:\\n                for vertex in adjList[node]:\\n                    in_degree[vertex] -= 1\\n                    if not in_degree[vertex]:\\n                        bfs.append(vertex)\\n                \\n        return counted_so_far == len(in_degree)\\n    \\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        adjList = dict()\\n        in_degree = [0 for i in range(len(colors))]\\n        \\n        for src, dest in edges:\\n            if src not in adjList:\\n                adjList[src] = []\\n            adjList[src].append(dest)\\n            in_degree[dest] += 1\\n        \\n        if not self.getTopSort(in_degree, adjList):\\n            return -1\\n        \\n        ans = 1\\n        dp = [[0 for i in range(26)] for i in range(len(colors))]\\n        for i in self.topSort:\\n            dp[i][ord(colors[i]) - 97] = 1\\n        \\n        for node in self.topSort:\\n            if node in adjList:\\n                for vertex in adjList[node]:\\n                    dp[vertex] = self.getColors(self.addColor(dp[node], colors, vertex), dp[vertex])\\n                    ans = max(ans, max(dp[vertex]))\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201613,
                "title": "c-topo-sort-and-simple-dp",
                "content": "class Solution {\\npublic:\\n    int largestPathValue(string s, vector<vector<int>>& edges) {\\n        \\n        int n=s.length();\\n        int indegree[n];\\n        unordered_map<int, vector<int>> adj;\\n        for(int i=0; i<n; i++) indegree[i]=0;\\n\\n        for(int i=0; i<edges.size(); i++){\\n          int src=edges[i][0];\\n          int des=edges[i][1];\\n            \\n          adj[src].push_back(des);\\n          indegree[des]++; }\\n\\n      int dp[n][26];\\n      memset(dp, 0, sizeof(dp));\\n      queue<int> q;\\n\\nfor(int i=0; i<n; i++){ if(indegree[i]==0){ q.push(i); dp[i][s[i]-\\'a\\']=1;}}\\nint cnt=0;\\nint ans=1;\\n\\nwhile(!q.empty()){\\n int x=q.front();\\n q.pop();\\n cnt++;\\n \\n for(int i:adj[x]){\\n\\n   for(int j=0; j<26; j++){\\n     if(s[i]-\\'a\\'==j) dp[i][j]=max(dp[i][j], 1+dp[x][j]);\\n     else dp[i][j]=max(dp[i][j], dp[x][j]); ans=max(ans, dp[i][j]); }\\n\\n     indegree[i]--;\\n     if(indegree[i]==0) q.push(i);}\\n}\\nif(cnt!=n) return -1;\\nreturn ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestPathValue(string s, vector<vector<int>>& edges) {\\n        \\n        int n=s.length();\\n        int indegree[n];\\n        unordered_map<int, vector<int>> adj;\\n        for(int i=0; i<n; i++) indegree[i]=0;\\n\\n        for(int i=0; i<edges.size(); i++){\\n          int src=edges[i][0];\\n          int des=edges[i][1];\\n            \\n          adj[src].push_back(des);\\n          indegree[des]++; }",
                "codeTag": "Java"
            },
            {
                "id": 1199980,
                "title": "c-topological-sort-onion-peeling-algorithm-100",
                "content": "```\\npublic class Solution {\\n    public int LargestPathValue(string colors, int[][] edges) {\\n        \\n        var parentToChildren = new List<HashSet<int>>();\\n        var childToParents = new List<HashSet<int>>();\\n        var n = colors.Length;\\n        \\n        var outDegree = new int[n];\\n        for(int i = 0; i < n; i++)\\n        {\\n            parentToChildren.Add(new HashSet<int>());\\n            childToParents.Add(new HashSet<int>());\\n        }\\n        foreach(var edge in edges)\\n        {  \\n            parentToChildren[edge[0]].Add(edge[1]);\\n            childToParents[edge[1]].Add(edge[0]);\\n            \\n            outDegree[edge[0]]++;            \\n        }\\n        \\n        var colorMap = new int[n, 26];       \\n        \\n        var q = new Queue<int>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(outDegree[i] == 0)\\n                q.Enqueue(i);\\n        }\\n        \\n        var result = 0;\\n        var count = n; //To Check if we are visiting all nodes or not, also helps to check Cycles.\\n        while(q.Count > 0)\\n        {           \\n            count--;\\n            var node = q.Dequeue();\\n\\n            for(int i = 0; i < 26; i++)\\n            {\\n                foreach(var child in parentToChildren[node])\\n                {\\n                    colorMap[node, i] = Math.Max(colorMap[node, i], colorMap[child, i]);\\n                }\\n            }                \\n            colorMap[node, colors[node] - \\'a\\']++;\\n            result = Math.Max(result, colorMap[node, colors[node] - \\'a\\']);\\n\\n            foreach(var parent in childToParents[node])\\n            {\\n                outDegree[parent]--;\\n                if(outDegree[parent] == 0)\\n                {\\n                    q.Enqueue(parent);\\n                }\\n            }\\n        }\\n        return count > 0 ? -1 : result;   //gotcha\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LargestPathValue(string colors, int[][] edges) {\\n        \\n        var parentToChildren = new List<HashSet<int>>();\\n        var childToParents = new List<HashSet<int>>();\\n        var n = colors.Length;\\n        \\n        var outDegree = new int[n];\\n        for(int i = 0; i < n; i++)\\n        {\\n            parentToChildren.Add(new HashSet<int>());\\n            childToParents.Add(new HashSet<int>());\\n        }\\n        foreach(var edge in edges)\\n        {  \\n            parentToChildren[edge[0]].Add(edge[1]);\\n            childToParents[edge[1]].Add(edge[0]);\\n            \\n            outDegree[edge[0]]++;            \\n        }\\n        \\n        var colorMap = new int[n, 26];       \\n        \\n        var q = new Queue<int>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(outDegree[i] == 0)\\n                q.Enqueue(i);\\n        }\\n        \\n        var result = 0;\\n        var count = n; //To Check if we are visiting all nodes or not, also helps to check Cycles.\\n        while(q.Count > 0)\\n        {           \\n            count--;\\n            var node = q.Dequeue();\\n\\n            for(int i = 0; i < 26; i++)\\n            {\\n                foreach(var child in parentToChildren[node])\\n                {\\n                    colorMap[node, i] = Math.Max(colorMap[node, i], colorMap[child, i]);\\n                }\\n            }                \\n            colorMap[node, colors[node] - \\'a\\']++;\\n            result = Math.Max(result, colorMap[node, colors[node] - \\'a\\']);\\n\\n            foreach(var parent in childToParents[node])\\n            {\\n                outDegree[parent]--;\\n                if(outDegree[parent] == 0)\\n                {\\n                    q.Enqueue(parent);\\n                }\\n            }\\n        }\\n        return count > 0 ? -1 : result;   //gotcha\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199668,
                "title": "easy-java-dfs-memo",
                "content": "class Solution {\\n       boolean cycle=false; \\n       \\n    public int largestPathValue(String colors , int[][] edges) {\\n            \\n            if(edges.length==0){\\n                    return 1;\\n            }\\n            \\n        List<List<Integer>> graph=new ArrayList<>();\\n            int n=colors.length();\\n            \\n            for(int i=0;i<=n;i++){\\n                    graph.add(new ArrayList<>());\\n            }\\n            \\n          for(int i=0;i<edges.length;i++){\\n                  int u=edges[i][0];\\n                  int v=edges[i][1];\\n                 \\n                  \\n                  graph.get(u).add(v);\\n          }  \\n            \\n             int max=0;\\n            HashMap<Integer,int[]> map=new HashMap<>();\\n            boolean[] visited=new boolean[n+1];\\n            \\n            int[] visited2=new int[n+1];\\n        \\n         \\n            \\n            for(int i=0;i<n;i++){\\n                if(!map.containsKey(i)){\\n                         int[] arr= dfs(i,graph,visited,map,colors,visited2);\\n                        \\n                        if(cycle)return -1;\\n                  \\n                    for(int j=0;j<26;j++){\\n                            max=Math.max(arr[j],max);\\n                    }\\n                }\\n                  \\n            }\\n            return max;\\n            \\n            \\n    }\\n        public int[] dfs(int src,List<List<Integer>> graph,boolean[] visited,HashMap<Integer,int[] > map,String colors,int[] visited2){\\n                \\n              \\n                if(map.containsKey(src))return map.get(src);\\n                \\n                visited[src]=true;\\n               visited2[src]=-1;\\n             int[] arr=new int[26];\\n                for(int child:graph.get(src)){\\n                        if(visited2[child]==-1){\\n                                cycle=true;\\n                        }\\n                        if(visited[child]!=true){\\n                            int[] a=    dfs(child,graph,visited,map,colors,visited2);\\n                                for(int i=0;i<26;i++){\\n                                      arr[i]=  Math.max(arr[i],a[i]);\\n                                }\\n                        }\\n                }\\n                visited[src]=false;\\n                visited2[src]=2;\\n                 arr[colors.charAt(src)-\\'a\\']++;\\n                map.put(src,arr);\\n                return  arr;\\n                \\n                \\n                \\n        }\\n        \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n       boolean cycle=false; \\n       \\n    public int largestPathValue(String colors , int[][] edges) {\\n            \\n            if(edges.length==0){\\n                    return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1198936,
                "title": "java-topological-sort-dp",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n = colors.length();\\n        List<List<Integer>> childToParent = new ArrayList<>();\\n        List<List<Integer>> parentToChildren = new ArrayList<>();\\n        int[] outDegree = new int[n];\\n        for(int i = 0; i < n; ++i) {\\n            childToParent.add(new ArrayList<>());\\n            parentToChildren.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges) {\\n            int from = edge[0],\\n                to = edge[1];\\n            childToParent.get(to).add(from);\\n            parentToChildren.get(from).add(to);\\n            outDegree[from]++;\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        int[][] dp = new int[n][26];\\n        for(int i = 0; i < n; ++i) {\\n            if(outDegree[i] == 0) queue.add(i);\\n        }\\n        int count = n;\\n        while(!queue.isEmpty()) {\\n            int node = queue.poll();\\n            count--;\\n            int nodeColor = colors.charAt(node) - \\'a\\';\\n            for(int i = 0; i < 26; ++i) {\\n                for(int prev : parentToChildren.get(node)) {\\n                    dp[node][i] = Math.max(dp[node][i], dp[prev][i]);\\n                }\\n            }\\n            dp[node][nodeColor]++;\\n            res = Math.max(res, dp[node][nodeColor]);\\n            for(int parent : childToParent.get(node)) {\\n                outDegree[parent]--;\\n                if(outDegree[parent] == 0) queue.add(parent);\\n            }\\n        }\\n        return count > 0 ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n = colors.length();\\n        List<List<Integer>> childToParent = new ArrayList<>();\\n        List<List<Integer>> parentToChildren = new ArrayList<>();\\n        int[] outDegree = new int[n];\\n        for(int i = 0; i < n; ++i) {\\n            childToParent.add(new ArrayList<>());\\n            parentToChildren.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges) {\\n            int from = edge[0],\\n                to = edge[1];\\n            childToParent.get(to).add(from);\\n            parentToChildren.get(from).add(to);\\n            outDegree[from]++;\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        int[][] dp = new int[n][26];\\n        for(int i = 0; i < n; ++i) {\\n            if(outDegree[i] == 0) queue.add(i);\\n        }\\n        int count = n;\\n        while(!queue.isEmpty()) {\\n            int node = queue.poll();\\n            count--;\\n            int nodeColor = colors.charAt(node) - \\'a\\';\\n            for(int i = 0; i < 26; ++i) {\\n                for(int prev : parentToChildren.get(node)) {\\n                    dp[node][i] = Math.max(dp[node][i], dp[prev][i]);\\n                }\\n            }\\n            dp[node][nodeColor]++;\\n            res = Math.max(res, dp[node][nodeColor]);\\n            for(int parent : childToParent.get(node)) {\\n                outDegree[parent]--;\\n                if(outDegree[parent] == 0) queue.add(parent);\\n            }\\n        }\\n        return count > 0 ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198854,
                "title": "java-clean-cycle-detection-topological-sort-and-bottom-up-dp",
                "content": "In the first place, we need to detect cycle in the graph and return `-1` accordingly. This can be done in a regular DFS.\\n\\nSuppose we have an directed acyclic graph (dag) as following, where nodes are labeled by their color:\\n\\n![example](https://assets.leetcode.com/users/images/73ef1bd1-440f-4c82-841b-511f4c5e2685_1621011966.7415838.png)\\n\\nObserve that the maximum identically colored nodes on a path would be non-decreasing if the path were extended. In particular, if a path if extended from its head or tail by one node, then the count of the specific color that the node has increments by 1, possibly raising the maximum count of all colors on the extended path. For example, `d -> e` can be extended by node `f` with maximum 1 unchanged, while `b -> a -> c` can be extended by the leftmost `a` and thus raising the maximum from 1 to 2.\\n\\nTherefore, let us consider each separate node as a starting node, corresponding to a subproblem to finding such a path starting from it that has the most identically colored nodes on the path. As the above figure shows, the edge `a -> c` can be used in both the path `b -> a -> c` and `a -> a -> c`, which implies an overlapping subproblem.\\n\\nNote that there\\'re 26 colors (from `a` to `z`) at most, and each of them might be the color that forms the required maximum identically colored path. Hence we shall consider them respectively, examining paths that contains as more nodes of each color as possible.\\n\\nSay for a color `c`, we would like to get the maximum identically colored nodes on any path starting from vertex (node) `v`, for which we have\\n> `maxNodes(v, c) = max { maxNodes(u, c) for u in v\\'s next neighbors } + (v is colored as c ? 1 : 0)`.\\n\\nThus the solution for a node can be derived from its subproblems, which shows optimal substructure. The two key factors in dynamic programming are clear now. To apply a bottom-up version of DP, nodes should be visited in the reverse topological sorting order to solve the subproblems. For example, `f -> e -> d -> b -> c -> a -> b -> a` is a feasible solving order, though it\\'s not unique. Notice that topological sorting can be combined with cycle detection in one pass.\\n\\nThe running time for the DFS of topological sorting and cycle detection is `O(V + E)`, where `|V| = n = vertex number`, `|E| = m = edge number`, and DP takes `O(26 * (V + E))`. In conclusion, the time complexity of the whole procedure is `O(V + E)`.\\n\\n```java\\nclass Solution {\\n    enum State { WHITE, GRAY, BLACK }\\n    \\n\\t// Adjacency list\\n    List<List<Integer>> adjList;\\n\\t// Used in DFS to mark visited nodes as appropriate states\\n    State[] states;\\n    // Reverse topological sorted vertices\\n    List<Integer> sorted;\\n    \\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n = colors.length();\\n        adjList = createAdjList(n, edges);\\n        states = new State[n];\\n        Arrays.fill(states, State.WHITE);\\n        sorted = new ArrayList<>();\\n        \\n        // Cycle detection && (reverse) topological sort\\n        for (int i = 0; i < n; ++i) {\\n            if (states[i] == State.WHITE && !detectCycle(i)) {\\n                return -1;\\n            }\\n        }\\n        \\n        // Bottom-up DP, count maximum nodes of each color respectively on path starting from some node\\n        int[][] count = new int[n][26];\\n        int maxNodes = 0;\\n        for (int node : sorted) {\\n            for (int next : adjList.get(node)) {\\n                for (int i = 0; i < 26; ++i) {\\n                    count[node][i] = Math.max(count[node][i], count[next][i]);\\n                }\\n            }\\n            maxNodes = Math.max(maxNodes, ++count[node][colors.charAt(node) - \\'a\\']);\\n        }\\n        return maxNodes;\\n    }\\n    \\n    private List<List<Integer>> createAdjList(int n, int[][] edges) {\\n        var list = Stream.<List<Integer>>generate(ArrayList::new).limit(n).collect(Collectors.toList());\\n        for (int[] edge : edges) {\\n            list.get(edge[0]).add(edge[1]);\\n        }\\n        return list;\\n    }\\n    \\n    private boolean detectCycle(int node) {\\n        states[node] = State.GRAY;\\n        for (int neighbor : adjList.get(node)) {\\n            if (states[neighbor] == State.GRAY\\n                    || (states[neighbor] == State.WHITE && !detectCycle(neighbor))) {\\n                return false;\\n            }\\n        }\\n        states[node] = State.BLACK;\\n        sorted.add(node);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    enum State { WHITE, GRAY, BLACK }\\n    \\n\\t// Adjacency list\\n    List<List<Integer>> adjList;\\n\\t// Used in DFS to mark visited nodes as appropriate states\\n    State[] states;\\n    // Reverse topological sorted vertices\\n    List<Integer> sorted;\\n    \\n    public int largestPathValue(String colors, int[][] edges) {\\n        int n = colors.length();\\n        adjList = createAdjList(n, edges);\\n        states = new State[n];\\n        Arrays.fill(states, State.WHITE);\\n        sorted = new ArrayList<>();\\n        \\n        // Cycle detection && (reverse) topological sort\\n        for (int i = 0; i < n; ++i) {\\n            if (states[i] == State.WHITE && !detectCycle(i)) {\\n                return -1;\\n            }\\n        }\\n        \\n        // Bottom-up DP, count maximum nodes of each color respectively on path starting from some node\\n        int[][] count = new int[n][26];\\n        int maxNodes = 0;\\n        for (int node : sorted) {\\n            for (int next : adjList.get(node)) {\\n                for (int i = 0; i < 26; ++i) {\\n                    count[node][i] = Math.max(count[node][i], count[next][i]);\\n                }\\n            }\\n            maxNodes = Math.max(maxNodes, ++count[node][colors.charAt(node) - \\'a\\']);\\n        }\\n        return maxNodes;\\n    }\\n    \\n    private List<List<Integer>> createAdjList(int n, int[][] edges) {\\n        var list = Stream.<List<Integer>>generate(ArrayList::new).limit(n).collect(Collectors.toList());\\n        for (int[] edge : edges) {\\n            list.get(edge[0]).add(edge[1]);\\n        }\\n        return list;\\n    }\\n    \\n    private boolean detectCycle(int node) {\\n        states[node] = State.GRAY;\\n        for (int neighbor : adjList.get(node)) {\\n            if (states[neighbor] == State.GRAY\\n                    || (states[neighbor] == State.WHITE && !detectCycle(neighbor))) {\\n                return false;\\n            }\\n        }\\n        states[node] = State.BLACK;\\n        sorted.add(node);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198764,
                "title": "c-dfs-dp-easy",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> adj;\\n    vector<bool> visited;\\n    vector<bool> done;\\n    vector<vector<int>> c;\\n    int answer = 0;\\n    string color = \"\";\\n    bool cycle = false;\\npublic:\\n    void dfs(int node){\\n        visited[node] = true;\\n        for (int v: adj[node]){\\n             if (visited[v]){\\n                cycle = true;\\n                continue;\\n            }\\n            if (done[v]){\\n                for (int i =0;i<26;i++){\\n                    c[node][i] = max(c[node][i],c[v][i]) ;\\n                }\\n                continue;\\n            }\\n            dfs(v);\\n            for (int i =0;i<26;i++){\\n                 c[node][i] = max(c[node][i],c[v][i]) ;\\n            }\\n        }\\n        c[node][color[node]-\\'a\\']++;\\n        answer = max(answer,c[node][color[node]-\\'a\\']);\\n        visited[node] = false;\\n        done[node] = true;\\n    }\\n  \\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        color = colors;\\n        int n = color.length();\\n        adj = vector<vector<int>> (n);\\n        visited = vector<bool> (n);\\n        done = vector<bool> (n);\\n        c = vector<vector<int>> (n,vector<int> (26));\\n        for (auto x: edges){\\n            adj[x[0]].push_back(x[1]);\\n        }\\n        for (int i =0;i<n;i++){\\n            if (!done[i]) dfs(i);\\n        }\\n        if (cycle) return -1;\\n       \\n        return answer;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<vector<int>> adj;\\n    vector<bool> visited;\\n    vector<bool> done;\\n    vector<vector<int>> c;\\n    int answer = 0;\\n    string color = \"\";\\n    bool cycle = false;\\npublic:\\n    void dfs(int node){\\n        visited[node] = true;\\n        for (int v: adj[node]){\\n             if (visited[v]){\\n                cycle = true;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1198739,
                "title": "c",
                "content": "Topological Sort:\\nSInce there are at most 26 colors, and we can either use Topological Sort for 26 times.\\nNote each color is indepdent of other colors.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        n = colors.size();\\n        vector<vector<int>> es(n);\\n        vector<vector<int>> cs(n, vector<int>(26, 0));\\n        vector<int> ind(n, 0);\\n        \\n        for (auto& e : edges)\\n        {\\n            es[e[0]].push_back(e[1]);\\n            ind[e[1]]++;\\n        }\\n        \\n        deque<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (ind[i] == 0)\\n            {\\n                q.push_back(i);\\n            }\\n        }\\n        int cnt = 0;\\n        while (!q.empty())\\n        {\\n            int i = q.front();\\n            q.pop_front();\\n            cs[i][colors[i] - \\'a\\']++;\\n            cnt++;\\n            for (auto& nei : es[i])\\n            {\\n                for (int j = 0; j < 26; j++)\\n                {\\n                    cs[nei][j] = max(cs[nei][j], cs[i][j]);\\n                }\\n                ind[nei]--;\\n                if (ind[nei] == 0)\\n                {\\n                    q.push_back(nei);\\n                }\\n            }\\n        }\\n        if (cnt != n) return -1;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < 26; j++)\\n            {\\n                ans = max(ans, cs[i][j]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        n = colors.size();\\n        vector<vector<int>> es(n);\\n        vector<vector<int>> cs(n, vector<int>(26, 0));\\n        vector<int> ind(n, 0);\\n        \\n        for (auto& e : edges)\\n        {\\n            es[e[0]].push_back(e[1]);\\n            ind[e[1]]++;\\n        }\\n        \\n        deque<int> q;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (ind[i] == 0)\\n            {\\n                q.push_back(i);\\n            }\\n        }\\n        int cnt = 0;\\n        while (!q.empty())\\n        {\\n            int i = q.front();\\n            q.pop_front();\\n            cs[i][colors[i] - \\'a\\']++;\\n            cnt++;\\n            for (auto& nei : es[i])\\n            {\\n                for (int j = 0; j < 26; j++)\\n                {\\n                    cs[nei][j] = max(cs[nei][j], cs[i][j]);\\n                }\\n                ind[nei]--;\\n                if (ind[nei] == 0)\\n                {\\n                    q.push_back(nei);\\n                }\\n            }\\n        }\\n        if (cnt != n) return -1;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < 26; j++)\\n            {\\n                ans = max(ans, cs[i][j]);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086122,
                "title": "why-does-this-dfs-solution-result-in-tle",
                "content": "# Intuition\\r\\nApproach is very similar to the editorial DFS approach.\\r\\nOnly difference being the DFS function returning bool instead of int, and for the nodes that start the DFS I determine the max color outside the DFS instead of returning the value from the DFS function.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int max_color;\\r\\n    vector<vector<int>> dp;\\r\\n\\r\\n    bool dfs(unordered_map<int, unordered_set<int>>& um, vector<int>& visited, vector<int>& done, string& colors, int node)\\r\\n    {\\r\\n        //already processed\\r\\n        if(done[node])\\r\\n            return false;\\r\\n\\r\\n        visited[node] = 1;\\r\\n        char color = colors[node];\\r\\n\\r\\n        for(auto& nbr: um[node])\\r\\n        {\\r\\n            //detect cycle\\r\\n            if(visited[nbr])\\r\\n                return true;\\r\\n            if(dfs(um, visited, done, colors, nbr))\\r\\n                return true;\\r\\n            for(int c=0; c<26; c++)\\r\\n                dp[node][c] = max(dp[node][c], dp[nbr][c]);\\r\\n        }\\r\\n\\r\\n        visited[node] = 0;\\r\\n        dp[node][color - \\'a\\']++;\\r\\n        done[node] = 1;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        const int n = colors.length();\\r\\n        dp.resize(n, vector<int>(26));\\r\\n        unordered_map<int, unordered_set<int>> um;\\r\\n        max_color = -1;\\r\\n\\r\\n        for(auto& e: edges)\\r\\n            um[e[0]].insert(e[1]);\\r\\n\\r\\n        vector<int> done(n, 0);\\r\\n        for(int i=0; i<n; i++)\\r\\n        {\\r\\n            vector<int> visited(n, 0);\\r\\n            if(dfs(um, visited, done, colors, i))\\r\\n                return -1;\\r\\n            for(int c=0; c<26; c++)\\r\\n                max_color = max(max_color, dp[i][c]);\\r\\n        }\\r\\n\\r\\n        return max_color;\\r\\n    }\\r\\n\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int max_color;\\r\\n    vector<vector<int>> dp;\\r\\n\\r\\n    bool dfs(unordered_map<int, unordered_set<int>>& um, vector<int>& visited, vector<int>& done, string& colors, int node)\\r\\n    {\\r\\n        //already processed\\r\\n        if(done[node])\\r\\n            return false;\\r\\n\\r\\n        visited[node] = 1;\\r\\n        char color = colors[node];\\r\\n\\r\\n        for(auto& nbr: um[node])\\r\\n        {\\r\\n            //detect cycle\\r\\n            if(visited[nbr])\\r\\n                return true;\\r\\n            if(dfs(um, visited, done, colors, nbr))\\r\\n                return true;\\r\\n            for(int c=0; c<26; c++)\\r\\n                dp[node][c] = max(dp[node][c], dp[nbr][c]);\\r\\n        }\\r\\n\\r\\n        visited[node] = 0;\\r\\n        dp[node][color - \\'a\\']++;\\r\\n        done[node] = 1;\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        const int n = colors.length();\\r\\n        dp.resize(n, vector<int>(26));\\r\\n        unordered_map<int, unordered_set<int>> um;\\r\\n        max_color = -1;\\r\\n\\r\\n        for(auto& e: edges)\\r\\n            um[e[0]].insert(e[1]);\\r\\n\\r\\n        vector<int> done(n, 0);\\r\\n        for(int i=0; i<n; i++)\\r\\n        {\\r\\n            vector<int> visited(n, 0);\\r\\n            if(dfs(um, visited, done, colors, i))\\r\\n                return -1;\\r\\n            for(int c=0; c<26; c++)\\r\\n                max_color = max(max_color, dp[i][c]);\\r\\n        }\\r\\n\\r\\n        return max_color;\\r\\n    }\\r\\n\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069000,
                "title": "clean-sol-using-dfs",
                "content": "# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n\\r\\n- Space complexity: $$O(n)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        nodes = defaultdict(list)\\r\\n        for src,dst in edges:\\r\\n            nodes[src].append(dst)\\r\\n\\r\\n        def dfs(node):\\r\\n            if node in path:\\r\\n                return float(\\'inf\\')\\r\\n            if node in visit:\\r\\n                return 0\\r\\n\\r\\n            visit.add(node)\\r\\n            path.add(node)\\r\\n\\r\\n            colorIndex = ord(colors[node]) - ord(\\'a\\')\\r\\n            colorscount[node][colorIndex] = 1\\r\\n            for neig in nodes[node]:\\r\\n                if dfs(neig) == float(\\'inf\\'):\\r\\n                    return float(\\'inf\\')\\r\\n\\r\\n                for color in range(26):\\r\\n                    colorscount[node][color] = max(\\r\\n                        colorscount[node][color],\\r\\n                        (1 if color == colorIndex else 0) + colorscount[neig][color]\\r\\n                    )\\r\\n\\r\\n            path.remove(node)\\r\\n            return max(colorscount[node])           \\r\\n\\r\\n        noofnodes,res = len(colors),0\\r\\n        visit,path = set(),set()\\r\\n        colorscount = [[0]*26 for i in range(0,noofnodes)]\\r\\n        for i in range(0, noofnodes):\\r\\n            res = max(dfs(i), res)\\r\\n\\r\\n        return -1 if res == float(\\'inf\\') else res\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        nodes = defaultdict(list)\\r\\n        for src,dst in edges:\\r\\n            nodes[src].append(dst)\\r\\n\\r\\n        def dfs(node):\\r\\n            if node in path:\\r\\n                return float(\\'inf\\')\\r\\n            if node in visit:\\r\\n                return 0\\r\\n\\r\\n            visit.add(node)\\r\\n            path.add(node)\\r\\n\\r\\n            colorIndex = ord(colors[node]) - ord(\\'a\\')\\r\\n            colorscount[node][colorIndex] = 1\\r\\n            for neig in nodes[node]:\\r\\n                if dfs(neig) == float(\\'inf\\'):\\r\\n                    return float(\\'inf\\')\\r\\n\\r\\n                for color in range(26):\\r\\n                    colorscount[node][color] = max(\\r\\n                        colorscount[node][color],\\r\\n                        (1 if color == colorIndex else 0) + colorscount[neig][color]\\r\\n                    )\\r\\n\\r\\n            path.remove(node)\\r\\n            return max(colorscount[node])           \\r\\n\\r\\n        noofnodes,res = len(colors),0\\r\\n        visit,path = set(),set()\\r\\n        colorscount = [[0]*26 for i in range(0,noofnodes)]\\r\\n        for i in range(0, noofnodes):\\r\\n            res = max(dfs(i), res)\\r\\n\\r\\n        return -1 if res == float(\\'inf\\') else res\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060477,
                "title": "o-n-m-time-o-n-m-space-solution-explained",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nDo topological sorting to detect cycles and compute the color value of each node\\'s path. \\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n- set res = 0 to track the max color value \\r\\n- set seen = 0 to track the total visited nodes\\r\\n- set n = total number of nodes\\r\\n- create a hashmap to represent the graph (adjacency list)\\r\\nkey = node, value = list of neighbor nodes\\r\\n- create a queue for BFS for topological sorting\\r\\n- create a list of size n to store the in-degree (total number of incoming edges) of each node\\r\\nindex = node, value = in-degree\\r\\n- create a list to store the frequency of each color for each node\\'s path\\r\\nindex = node, value = hashmap of color values\\r\\nhashmap key = color, value = frequency of the color\\r\\n- add edges to the graph\\r\\n    - for each source node, destination node in the edges\\r\\n        - add an edge from destination node to source node\\r\\n        - increment the in-degree of the destination node\\r\\n- add nodes with 0-indegree to the queue\\r\\n- do topological sort\\r\\n    - loop until q is empty\\r\\n        - pop q to get a node to process\\r\\n        - get the color of the node and increment the count of that color\\r\\n        - update res\\r\\n        - we have visited a new node, increment seen\\r\\n        - visit the neighbors of the current node, update the colors, and reduce the neighbor in-degree by 1. Add neighbor to q if in-degree becomes 0\\r\\n- if we have not visited all n nodes, there is a cycle, return -1\\r\\n- else return res\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(graph (adjacency list) creation + nodes traversal to add nodes with 0 in-degree to queue + BFS) \\u2192 O(E + V + V + E) \\u2192 O(V + E) \\u2192 O(n + m)\\r\\n    - V = total vertices or nodes\\r\\n    - E = total edges\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(graph (adjacency list) + in-degree list + count list + BFS queue) \\u2192 O(V + E + V + V + V) \\u2192 O(V + E) \\u2192 O(n + m)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        res, seen, n = 0, 0, len(colors)\\r\\n        graph, q = defaultdict(list), deque()\\r\\n        in_degree = [0] * n\\r\\n        count = [defaultdict(int) for _ in range(n)]\\r\\n        for u, v in edges:\\r\\n            graph[v].append(u)\\r\\n            in_degree[u] += 1\\r\\n        for node in range(n):\\r\\n            if not in_degree[node]:\\r\\n                q.append(node)\\r\\n        while q:\\r\\n            cur = q.popleft()\\r\\n            count[cur][colors[cur]] += 1\\r\\n            res = max(res, count[cur][colors[cur]])\\r\\n            seen += 1\\r\\n            for v in graph[cur]:\\r\\n                for c in count[cur]:\\r\\n                    count[v][c] = max(count[v][c], count[cur][c])\\r\\n                in_degree[v] -= 1\\r\\n                if not in_degree[v]:\\r\\n                    q.append(v)\\r\\n        if seen < n:\\r\\n            return -1\\r\\n        return res\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        res, seen, n = 0, 0, len(colors)\\r\\n        graph, q = defaultdict(list), deque()\\r\\n        in_degree = [0] * n\\r\\n        count = [defaultdict(int) for _ in range(n)]\\r\\n        for u, v in edges:\\r\\n            graph[v].append(u)\\r\\n            in_degree[u] += 1\\r\\n        for node in range(n):\\r\\n            if not in_degree[node]:\\r\\n                q.append(node)\\r\\n        while q:\\r\\n            cur = q.popleft()\\r\\n            count[cur][colors[cur]] += 1\\r\\n            res = max(res, count[cur][colors[cur]])\\r\\n            seen += 1\\r\\n            for v in graph[cur]:\\r\\n                for c in count[cur]:\\r\\n                    count[v][c] = max(count[v][c], count[cur][c])\\r\\n                in_degree[v] -= 1\\r\\n                if not in_degree[v]:\\r\\n                    q.append(v)\\r\\n        if seen < n:\\r\\n            return -1\\r\\n        return res\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046841,
                "title": "topological-sort-bfs-dp",
                "content": "Intuition:\\r\\n\\r\\nThe problem requires finding the largest path value in a graph given the colors of nodes and edges. We can use dynamic programming to keep track of the count of colors for each node as we traverse the graph. The goal is to find the maximum count of colors in any path.\\r\\n\\r\\nApproach:\\r\\n\\r\\nInitialize variables and data structures:\\r\\n\\r\\nCreate a graph represented as an unordered map where each node is associated with its neighbors.\\r\\nInitialize an array inDegrees to keep track of the in-degrees of nodes.\\r\\nInitialize a 2D DP array dp to keep track of the count of colors for each node.\\r\\nCreate a queue q for BFS traversal.\\r\\nInitialize ans to 0 to store the largest path value.\\r\\nInitialize visited to 0 to count the visited nodes.\\r\\nPopulate the graph and in-degrees:\\r\\n\\r\\nIterate through the given edges and update the graph and inDegrees accordingly.\\r\\nInitialize the queue:\\r\\n\\r\\nIterate through all nodes and push nodes with an in-degree of 0 into the queue.\\r\\nInitialize the count of colors for the starting nodes in the dp array.\\r\\nPerform BFS traversal:\\r\\n\\r\\nWhile the queue is not empty, dequeue a node curr.\\r\\nIncrement the visited count.\\r\\nUpdate the count of colors for curr based on its color.\\r\\nIterate through neighbors of curr and update their in-degrees and dp array.\\r\\nIf a neighbor has an in-degree of 0 after decrementing, enqueue it.\\r\\nCheck if all nodes were visited:\\r\\n\\r\\nIf visited is less than n, return -1 (not all nodes were visited).\\r\\nFind the largest path value:\\r\\n\\r\\nIterate through all nodes and find the maximum count of colors using max_element.\\r\\nUpdate ans with the maximum value found.\\r\\nReturn the largest path value ans.\\r\\n\\r\\nComplexity:\\r\\n\\r\\nTime complexity: O(n) where n is the number of nodes in the graph.\\r\\nSpace complexity: O(n) for the dp array and other data structures used.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        unordered_map<int, vector<int>> graph;\\r\\n        vector<int> inDegrees(n, 0);\\r\\n        vector<vector<int>> dp(n, vector<int>(26, 0));\\r\\n\\r\\n        for (auto edge : edges) {\\r\\n            graph[edge[0]].push_back(edge[1]);\\r\\n            inDegrees[edge[1]]++;\\r\\n        }\\r\\n\\r\\n        queue<int> q;\\r\\n\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (inDegrees[i] == 0) {\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int ans = 0;\\r\\n        int visited = 0;\\r\\n\\r\\n        while (!q.empty()) {\\r\\n            int curr = q.front();\\r\\n            q.pop();\\r\\n            visited++;\\r\\n\\r\\n            dp[curr][colors[curr] - \\'a\\']++;\\r\\n\\r\\n            for (auto neigh : graph[curr]) {\\r\\n                inDegrees[neigh]--;\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    dp[neigh][i] = max(dp[neigh][i], dp[curr][i]);\\r\\n                }\\r\\n                if (inDegrees[neigh] == 0) {\\r\\n                    q.push(neigh);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (visited < n) {\\r\\n            return -1;\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            ans = max(ans, *max_element(dp[i].begin(), dp[i].end()));\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\r\\n        int n = colors.size();\\r\\n        unordered_map<int, vector<int>> graph;\\r\\n        vector<int> inDegrees(n, 0);\\r\\n        vector<vector<int>> dp(n, vector<int>(26, 0));\\r\\n\\r\\n        for (auto edge : edges) {\\r\\n            graph[edge[0]].push_back(edge[1]);\\r\\n            inDegrees[edge[1]]++;\\r\\n        }\\r\\n\\r\\n        queue<int> q;\\r\\n\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            if (inDegrees[i] == 0) {\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int ans = 0;\\r\\n        int visited = 0;\\r\\n\\r\\n        while (!q.empty()) {\\r\\n            int curr = q.front();\\r\\n            q.pop();\\r\\n            visited++;\\r\\n\\r\\n            dp[curr][colors[curr] - \\'a\\']++;\\r\\n\\r\\n            for (auto neigh : graph[curr]) {\\r\\n                inDegrees[neigh]--;\\r\\n                for (int i = 0; i < 26; i++) {\\r\\n                    dp[neigh][i] = max(dp[neigh][i], dp[curr][i]);\\r\\n                }\\r\\n                if (inDegrees[neigh] == 0) {\\r\\n                    q.push(neigh);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (visited < n) {\\r\\n            return -1;\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            ans = max(ans, *max_element(dp[i].begin(), dp[i].end()));\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961154,
                "title": "clean-code-java-topological-sort-with-cycle-detection",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        HashMap<Integer, List<Integer>> adjMap = new HashMap<>();\\r\\n        int n = colors.length();\\r\\n        int[] indegree = new int[n];\\r\\n        int[][] paths = new int[n][26];\\r\\n\\r\\n        for (int[] edge : edges) {\\r\\n            List<Integer> adj = new ArrayList<>(adjMap.getOrDefault(edge[0], new ArrayList<>()));\\r\\n            adj.add(edge[1]);\\r\\n            adjMap.put(edge[0], new ArrayList<>(adj));\\r\\n            indegree[edge[1]]++;\\r\\n        }\\r\\n        \\r\\n        Queue<Integer> q = new LinkedList<>();\\r\\n        for (int i = 0; i < indegree.length; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.add(i);\\r\\n                paths[i][colors.charAt(i) - \\'a\\']++;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if (q.size() == 0) return -1;\\r\\n        \\r\\n        while (q.size() != 0) {\\r\\n            int qSize = q.size();\\r\\n            for (int i = 1; i <= qSize; i++) {\\r\\n                Integer node = q.poll();\\r\\n                List<Integer> adj = new ArrayList<>(adjMap.getOrDefault(node, new ArrayList<>()));\\r\\n                for (int j = 0; j < adj.size(); j++) {\\r\\n                    int adjNode = adj.get(j);\\r\\n                    for (int k = 0; k < 26; k++) {\\r\\n                        paths[adjNode][k] = Math.max(paths[adjNode][k],\\r\\n                         paths[node][k] + (k == colors.charAt(adjNode) - \\'a\\' ? 1 : 0));\\r\\n                    }\\r\\n                    indegree[adjNode]--;\\r\\n                    if (indegree[adjNode] == 0) {\\r\\n                        q.add(adjNode);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if(cycleExist(indegree))return -1;\\r\\n        int res = findMaxOccurringPathColor(paths, n);\\r\\n        return res == 0 || q.size()!=0? -1 : res;\\r\\n    }\\r\\n    private boolean cycleExist(int[] indegree){\\r\\n        for(int i=0; i<indegree.length; i++){\\r\\n            if(indegree[i]!=0)return true;\\r\\n        }\\r\\n        return false;\\r\\n    }    \\r\\n    private int findMaxOccurringPathColor(int[][] paths, int n) {\\r\\n        int max = 0;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            int[] path = paths[i];\\r\\n            for (int j = 0; j < 26; j++) {\\r\\n                max = Math.max(max, path[j]);\\r\\n            }\\r\\n        }\\r\\n        return max;\\r\\n    }\\r\\n}\\r\\n\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int largestPathValue(String colors, int[][] edges) {\\r\\n        HashMap<Integer, List<Integer>> adjMap = new HashMap<>();\\r\\n        int n = colors.length();\\r\\n        int[] indegree = new int[n];\\r\\n        int[][] paths = new int[n][26];\\r\\n\\r\\n        for (int[] edge : edges) {\\r\\n            List<Integer> adj = new ArrayList<>(adjMap.getOrDefault(edge[0], new ArrayList<>()));\\r\\n            adj.add(edge[1]);\\r\\n            adjMap.put(edge[0], new ArrayList<>(adj));\\r\\n            indegree[edge[1]]++;\\r\\n        }\\r\\n        \\r\\n        Queue<Integer> q = new LinkedList<>();\\r\\n        for (int i = 0; i < indegree.length; i++) {\\r\\n            if (indegree[i] == 0) {\\r\\n                q.add(i);\\r\\n                paths[i][colors.charAt(i) - \\'a\\']++;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if (q.size() == 0) return -1;\\r\\n        \\r\\n        while (q.size() != 0) {\\r\\n            int qSize = q.size();\\r\\n            for (int i = 1; i <= qSize; i++) {\\r\\n                Integer node = q.poll();\\r\\n                List<Integer> adj = new ArrayList<>(adjMap.getOrDefault(node, new ArrayList<>()));\\r\\n                for (int j = 0; j < adj.size(); j++) {\\r\\n                    int adjNode = adj.get(j);\\r\\n                    for (int k = 0; k < 26; k++) {\\r\\n                        paths[adjNode][k] = Math.max(paths[adjNode][k],\\r\\n                         paths[node][k] + (k == colors.charAt(adjNode) - \\'a\\' ? 1 : 0));\\r\\n                    }\\r\\n                    indegree[adjNode]--;\\r\\n                    if (indegree[adjNode] == 0) {\\r\\n                        q.add(adjNode);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if(cycleExist(indegree))return -1;\\r\\n        int res = findMaxOccurringPathColor(paths, n);\\r\\n        return res == 0 || q.size()!=0? -1 : res;\\r\\n    }\\r\\n    private boolean cycleExist(int[] indegree){\\r\\n        for(int i=0; i<indegree.length; i++){\\r\\n            if(indegree[i]!=0)return true;\\r\\n        }\\r\\n        return false;\\r\\n    }    \\r\\n    private int findMaxOccurringPathColor(int[][] paths, int n) {\\r\\n        int max = 0;\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            int[] path = paths[i];\\r\\n            for (int j = 0; j < 26; j++) {\\r\\n                max = Math.max(max, path[j]);\\r\\n            }\\r\\n        }\\r\\n        return max;\\r\\n    }\\r\\n}\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948051,
                "title": "python-clean-and-simple-topological-sorting",
                "content": "```\\r\\nfrom collections import Counter, defaultdict\\r\\n\\r\\nNEW = 0\\r\\nACTIVE = 1\\r\\nDONE = 2\\r\\n\\r\\n\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        g = self.create_graph(edges)\\r\\n\\r\\n        color_cnt = [Counter() for _ in range(n)]\\r\\n        status = [NEW] * n\\r\\n\\r\\n        def got_cycle(u: int) -> bool:\\r\\n            if status[u] == DONE:\\r\\n                return False\\r\\n\\r\\n            status[u] = ACTIVE\\r\\n            cnt = color_cnt[u]\\r\\n\\r\\n            for v in g[u]:\\r\\n                if status[v] == NEW:\\r\\n                    if got_cycle(v):\\r\\n                        return True\\r\\n                elif status[v] == ACTIVE:\\r\\n                    return True\\r\\n\\r\\n                cnt |= color_cnt[v]\\r\\n\\r\\n            cnt[colors[u]] += 1\\r\\n            status[u] = DONE\\r\\n\\r\\n            return False\\r\\n\\r\\n        if any(map(got_cycle, range(n))):\\r\\n            return -1\\r\\n        else:\\r\\n            return max(map(self.best_color_value, color_cnt))\\r\\n\\r\\n    @staticmethod\\r\\n    def best_color_value(cnt: Counter[str]) -> int:\\r\\n        return max(cnt.values())\\r\\n\\r\\n    @staticmethod\\r\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\r\\n        g = defaultdict(list)\\r\\n\\r\\n        for u, v in edges:\\r\\n            g[v].append(u)\\r\\n\\r\\n        return g\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\r\\nfrom collections import Counter, defaultdict\\r\\n\\r\\nNEW = 0\\r\\nACTIVE = 1\\r\\nDONE = 2\\r\\n\\r\\n\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        g = self.create_graph(edges)\\r\\n\\r\\n        color_cnt = [Counter() for _ in range(n)]\\r\\n        status = [NEW] * n\\r\\n\\r\\n        def got_cycle(u: int) -> bool:\\r\\n            if status[u] == DONE:\\r\\n                return False\\r\\n\\r\\n            status[u] = ACTIVE\\r\\n            cnt = color_cnt[u]\\r\\n\\r\\n            for v in g[u]:\\r\\n                if status[v] == NEW:\\r\\n                    if got_cycle(v):\\r\\n                        return True\\r\\n                elif status[v] == ACTIVE:\\r\\n                    return True\\r\\n\\r\\n                cnt |= color_cnt[v]\\r\\n\\r\\n            cnt[colors[u]] += 1\\r\\n            status[u] = DONE\\r\\n\\r\\n            return False\\r\\n\\r\\n        if any(map(got_cycle, range(n))):\\r\\n            return -1\\r\\n        else:\\r\\n            return max(map(self.best_color_value, color_cnt))\\r\\n\\r\\n    @staticmethod\\r\\n    def best_color_value(cnt: Counter[str]) -> int:\\r\\n        return max(cnt.values())\\r\\n\\r\\n    @staticmethod\\r\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\r\\n        g = defaultdict(list)\\r\\n\\r\\n        for u, v in edges:\\r\\n            g[v].append(u)\\r\\n\\r\\n        return g\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945317,
                "title": "topological-sorting",
                "content": "## Intuition\\r\\n```\\r\\nEach node has a color. The color is a lowercase letter means each node has a color which is\\r\\na letter among 26 letters.\\r\\n\\r\\nA graph has many paths, the longest path may not contain the most frequent color if that path\\r\\nhas so many colors while a short path may have only 1 frequent color.\\r\\n```\\r\\n![largestColor.png](https://assets.leetcode.com/users/images/af66b8d6-cabd-4816-908a-016f8f5f1459_1692709538.9171963.png)\\r\\n\\r\\n\\r\\n```\\r\\nWe\\'ve to pass information from \\'parent\\' node to it\\'s \\'children\\' nodes such as from 4 we can go to\\r\\n2 with MAXIMUM 2 red and 1 blue and by going to 3 we can have MAXIMUM 4 RED, 1 BLUE AND 1 PURPLE.\\r\\n\\r\\n0 -> 6 -> 8 -> 9 -> 3 : This path contains 4 red which is higher than the path 0 -> 4 -> 2 -> 3\\r\\nwhich only has 3 red. But 0 -> 4 -> 2 -> 3 path has maximum blue color and\\r\\n0 -> 6 -> 8 -> 9 -> 3 path has maximum purple color.\\r\\n\\r\\nWe\\'re reaching 3 via multiple path but at 3 we\\'re saying that we can go from a starting node(0) to\\r\\n3 and we can have maximum 4 red and 1 blue and 1 purple but we don\\'t care by which path you can get\\r\\nthem BUT WE CAN. \\r\\n```\\r\\n\\r\\n## Explanation\\r\\n![largestColor.png](https://assets.leetcode.com/users/images/22d30604-d4ac-4553-855c-4a3ab426bead_1692710635.6835313.png)\\r\\n\\r\\n```\\r\\n0 has 1 red, from 0 we can go to 1, 4, 6 and they all will inherit the info that before going\\r\\nto them we had 1 red.\\r\\n4 -> 2 : 2 will inherit all the info that 4 has \\'1 red 1 blue\\' and also add it\\'s own color red\\r\\nwhen its see the maximum red color it\\'s parent node 4 has.\\r\\n\\r\\nWe can go to 3 earlier by the path 0 -> 4 -> 2 -> 3. So right now 3 has MAXIMUM 3 red, 1 blue.\\r\\n\\r\\nWhen we reach 3 again by the path 0 -> 6 -> 8 -> 9 -> 3 where 3 already has info \\'3 red, 1\\r\\nblue\\', we obviously have to max operation with our new info \\'4 red, 1 purple\\'. So we\\'ve \\'4 red, 1 blue, 1 purple\\'. Again pass this info to it\\'s next children nodes.\\r\\n```\\r\\n\\r\\n\\r\\n```CPP []\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges)\\r\\n    {\\r\\n        int n = colors.size();\\r\\n        vector<unordered_set<int>> adjList(n);\\r\\n        vector<int> inDegree(n, 0);\\r\\n        for(auto &e: edges)\\r\\n            adjList[e[0]].insert(e[1]),\\r\\n            inDegree[e[1]]++;\\r\\n        \\r\\n        queue<int> q;\\r\\n        vector<vector<int>> countColors(n, vector<int>(26));\\r\\n        for(int i = 0; i < n; i++)\\r\\n            if(inDegree[i] == 0)\\r\\n                q.push(i),\\r\\n                countColors[i][colors[i]-\\'a\\']++;\\r\\n        \\r\\n        int parent, colorIndex, maxColor = 1, totalNodes = 0;\\r\\n        for(int size = q.size(); !q.empty(); size = q.size())\\r\\n        {\\r\\n            totalNodes += size;\\r\\n            while(size--)\\r\\n            {\\r\\n                parent = q.front(); q.pop();\\r\\n                for(auto &child: adjList[parent])\\r\\n                {\\r\\n                    colorIndex = colors[child] - \\'a\\'; // index of colors[child] in the \\'countIndex[child]\\' array\\r\\n                    for(int i = 0; i < 26; i++)\\r\\n                        countColors[child][i] = max(countColors[child][i], countColors[parent][i] + (i == colorIndex));\\r\\n                    maxColor = max(maxColor, countColors[child][colorIndex]);\\r\\n                    \\r\\n                    inDegree[child]--;\\r\\n                    if(inDegree[child] == 0)\\r\\n                        q.push(child);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return totalNodes == n? maxColor : -1;\\r\\n    }\\r\\n};\\r\\n```\\r\\n```Python []\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        adjList, inDegree = [set() for _ in range(n)], [0] * n\\r\\n        for (fromm, to) in edges:\\r\\n            adjList[fromm].add(to)\\r\\n            inDegree[to] += 1\\r\\n        \\r\\n        q, countColor = deque(), [ [0]*26 for _ in range(n)]\\r\\n        for i, indegree in enumerate(inDegree):\\r\\n            if indegree == 0:\\r\\n                q.append(i)\\r\\n                countColor[i][ord(colors[i])-ord(\\'a\\')] += 1\\r\\n        \\r\\n        maxColor, totoalNodes = 1, 0\\r\\n        while q:\\r\\n            totoalNodes += len(q)\\r\\n            for _ in range(len(q)):\\r\\n                \\r\\n                parent = q.popleft()\\r\\n                for child in adjList[parent]:\\r\\n                    colorIndex = ord(colors[child]) - ord(\\'a\\')\\r\\n                    for i in range(26):\\r\\n                        countColor[child][i] = max(countColor[child][i], countColor[parent][i] + (i == colorIndex))\\r\\n                    maxColor = max(maxColor, countColor[child][colorIndex])\\r\\n                    inDegree[child] -= 1\\r\\n                    if inDegree[child] == 0:\\r\\n                        q.append(child)\\r\\n        \\r\\n        return -1 if totoalNodes != n else maxColor\\r\\n```\\r\\n### (i == colorIndex) part\\r\\n```\\r\\nWe\\'re copying all the info(MAXIMUM INFO) to the child node as same as parent node has EXCEPT IN CASE\\r\\nOF CHILD NODE\\'S COLOR WE\\'RE GOING TO ADD 1 because 3 had already \\'3 red, 1 blue\\' when we reached 3\\r\\nby 9 and 9 has info \\'3 red 1 purple\\' BUT the moment we reached 3 by 9, now we\\'ve 4 RED. SO\\r\\n\\r\\n3\\'S PREVIOUS INFO - 3 red, 1 blue\\r\\nNow to update 3\\'s information with \\'max()\\' between previous info and current info 9 has brought\\r\\nupon 3 \\'3 red, 1 purple\\' + adding 1 to \\'3 red\\' has 3 has color red. For RED COLOR, NOW THE MAX\\r\\nOPERATION WILL OCCUR BETWEEN 3 AND 4.\\r\\n\\r\\nDON\\'T THINK LET\\'S FIRST DO MAX OPERATION BETWEEN \\'3 HAS PREVIOUSLY\\' AND \\'9 HAS BROUGHT WHATEVER\\', \\r\\nAND THEN WE\\'LL ADD 1 TO THE COLOR CHILD-NODE HAS. NOOO! WE\\'RE DOING MAX() BETWEEN \\'WHAT 3 HAD BEFORE\\' AND \\r\\n\\'WHAT 3 CAN HAVE NOW\\'.\\r\\n```\\r\\n![largestColor.png](https://assets.leetcode.com/users/images/f4d9141a-b947-41c2-bb97-081a270154bb_1692712924.7166944.png)\\r\\n\\r\\n```\\r\\nWe can reach 3 by 2, 6, 9. If we add 1 to color red just because everytime we can reach 3 after\\r\\ndoing the max() between \\'what 3 has now\\' and \\'what 2 or 6 or 9 has brought to 3\\' then we\\'ll have\\r\\n\\r\\n      6 -> 3 : max(0 red, 2 red), then add 1 means 3 red\\r\\n      2 -> 3 : max(3 red, 2 red), then add 1 means 4 red\\r\\n      9 -> 3 : max(4 red, 3 red), then add 1 means 5 red. But we\\'ve maximum 4 red! This logic is \\u274C\\r\\n```\\r\\n\\r\\n### How to find the maxColor?\\r\\n```\\r\\nInitially set maxColor = 1, if a child node\\'s color has value 2 it will be new maxColor.\\r\\nMinimum a child node has the maximum color value and everytime we are updating the the color value\\r\\nwe can just do the max() between old maxColor and the current child node\\'s color value, if that\\r\\nchild node\\'s color value is the highest, it\\'ll get caught in our max()   \\r\\n```\\r\\n\\r\\n```\\r\\n``\\r\\nTime  complexity : O(V+E)\\r\\nSpace complexity : O(V+E)\\r\\n```\\r\\n\\r\\n### If the post was helpful, an vote will really be appreciated. Thank youu",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\r\\nEach node has a color. The color is a lowercase letter means each node has a color which is\\r\\na letter among 26 letters.\\r\\n\\r\\nA graph has many paths, the longest path may not contain the most frequent color if that path\\r\\nhas so many colors while a short path may have only 1 frequent color.\\r\\n```\n```\\r\\nWe\\'ve to pass information from \\'parent\\' node to it\\'s \\'children\\' nodes such as from 4 we can go to\\r\\n2 with MAXIMUM 2 red and 1 blue and by going to 3 we can have MAXIMUM 4 RED, 1 BLUE AND 1 PURPLE.\\r\\n\\r\\n0 -> 6 -> 8 -> 9 -> 3 : This path contains 4 red which is higher than the path 0 -> 4 -> 2 -> 3\\r\\nwhich only has 3 red. But 0 -> 4 -> 2 -> 3 path has maximum blue color and\\r\\n0 -> 6 -> 8 -> 9 -> 3 path has maximum purple color.\\r\\n\\r\\nWe\\'re reaching 3 via multiple path but at 3 we\\'re saying that we can go from a starting node(0) to\\r\\n3 and we can have maximum 4 red and 1 blue and 1 purple but we don\\'t care by which path you can get\\r\\nthem BUT WE CAN. \\r\\n```\n```\\r\\n0 has 1 red, from 0 we can go to 1, 4, 6 and they all will inherit the info that before going\\r\\nto them we had 1 red.\\r\\n4 -> 2 : 2 will inherit all the info that 4 has \\'1 red 1 blue\\' and also add it\\'s own color red\\r\\nwhen its see the maximum red color it\\'s parent node 4 has.\\r\\n\\r\\nWe can go to 3 earlier by the path 0 -> 4 -> 2 -> 3. So right now 3 has MAXIMUM 3 red, 1 blue.\\r\\n\\r\\nWhen we reach 3 again by the path 0 -> 6 -> 8 -> 9 -> 3 where 3 already has info \\'3 red, 1\\r\\nblue\\', we obviously have to max operation with our new info \\'4 red, 1 purple\\'. So we\\'ve \\'4 red, 1 blue, 1 purple\\'. Again pass this info to it\\'s next children nodes.\\r\\n```\n```CPP []\\r\\nclass Solution {\\r\\npublic:\\r\\n    int largestPathValue(string colors, vector<vector<int>>& edges)\\r\\n    {\\r\\n        int n = colors.size();\\r\\n        vector<unordered_set<int>> adjList(n);\\r\\n        vector<int> inDegree(n, 0);\\r\\n        for(auto &e: edges)\\r\\n            adjList[e[0]].insert(e[1]),\\r\\n            inDegree[e[1]]++;\\r\\n        \\r\\n        queue<int> q;\\r\\n        vector<vector<int>> countColors(n, vector<int>(26));\\r\\n        for(int i = 0; i < n; i++)\\r\\n            if(inDegree[i] == 0)\\r\\n                q.push(i),\\r\\n                countColors[i][colors[i]-\\'a\\']++;\\r\\n        \\r\\n        int parent, colorIndex, maxColor = 1, totalNodes = 0;\\r\\n        for(int size = q.size(); !q.empty(); size = q.size())\\r\\n        {\\r\\n            totalNodes += size;\\r\\n            while(size--)\\r\\n            {\\r\\n                parent = q.front(); q.pop();\\r\\n                for(auto &child: adjList[parent])\\r\\n                {\\r\\n                    colorIndex = colors[child] - \\'a\\'; // index of colors[child] in the \\'countIndex[child]\\' array\\r\\n                    for(int i = 0; i < 26; i++)\\r\\n                        countColors[child][i] = max(countColors[child][i], countColors[parent][i] + (i == colorIndex));\\r\\n                    maxColor = max(maxColor, countColors[child][colorIndex]);\\r\\n                    \\r\\n                    inDegree[child]--;\\r\\n                    if(inDegree[child] == 0)\\r\\n                        q.push(child);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return totalNodes == n? maxColor : -1;\\r\\n    }\\r\\n};\\r\\n```\n```Python []\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        adjList, inDegree = [set() for _ in range(n)], [0] * n\\r\\n        for (fromm, to) in edges:\\r\\n            adjList[fromm].add(to)\\r\\n            inDegree[to] += 1\\r\\n        \\r\\n        q, countColor = deque(), [ [0]*26 for _ in range(n)]\\r\\n        for i, indegree in enumerate(inDegree):\\r\\n            if indegree == 0:\\r\\n                q.append(i)\\r\\n                countColor[i][ord(colors[i])-ord(\\'a\\')] += 1\\r\\n        \\r\\n        maxColor, totoalNodes = 1, 0\\r\\n        while q:\\r\\n            totoalNodes += len(q)\\r\\n            for _ in range(len(q)):\\r\\n                \\r\\n                parent = q.popleft()\\r\\n                for child in adjList[parent]:\\r\\n                    colorIndex = ord(colors[child]) - ord(\\'a\\')\\r\\n                    for i in range(26):\\r\\n                        countColor[child][i] = max(countColor[child][i], countColor[parent][i] + (i == colorIndex))\\r\\n                    maxColor = max(maxColor, countColor[child][colorIndex])\\r\\n                    inDegree[child] -= 1\\r\\n                    if inDegree[child] == 0:\\r\\n                        q.append(child)\\r\\n        \\r\\n        return -1 if totoalNodes != n else maxColor\\r\\n```\n```\\r\\nWe\\'re copying all the info(MAXIMUM INFO) to the child node as same as parent node has EXCEPT IN CASE\\r\\nOF CHILD NODE\\'S COLOR WE\\'RE GOING TO ADD 1 because 3 had already \\'3 red, 1 blue\\' when we reached 3\\r\\nby 9 and 9 has info \\'3 red 1 purple\\' BUT the moment we reached 3 by 9, now we\\'ve 4 RED. SO\\r\\n\\r\\n3\\'S PREVIOUS INFO - 3 red, 1 blue\\r\\nNow to update 3\\'s information with \\'max()\\' between previous info and current info 9 has brought\\r\\nupon 3 \\'3 red, 1 purple\\' + adding 1 to \\'3 red\\' has 3 has color red. For RED COLOR, NOW THE MAX\\r\\nOPERATION WILL OCCUR BETWEEN 3 AND 4.\\r\\n\\r\\nDON\\'T THINK LET\\'S FIRST DO MAX OPERATION BETWEEN \\'3 HAS PREVIOUSLY\\' AND \\'9 HAS BROUGHT WHATEVER\\', \\r\\nAND THEN WE\\'LL ADD 1 TO THE COLOR CHILD-NODE HAS. NOOO! WE\\'RE DOING MAX() BETWEEN \\'WHAT 3 HAD BEFORE\\' AND \\r\\n\\'WHAT 3 CAN HAVE NOW\\'.\\r\\n```\n```\\r\\nWe can reach 3 by 2, 6, 9. If we add 1 to color red just because everytime we can reach 3 after\\r\\ndoing the max() between \\'what 3 has now\\' and \\'what 2 or 6 or 9 has brought to 3\\' then we\\'ll have\\r\\n\\r\\n      6 -> 3 : max(0 red, 2 red), then add 1 means 3 red\\r\\n      2 -> 3 : max(3 red, 2 red), then add 1 means 4 red\\r\\n      9 -> 3 : max(4 red, 3 red), then add 1 means 5 red. But we\\'ve maximum 4 red! This logic is \\u274C\\r\\n```\n```\\r\\nInitially set maxColor = 1, if a child node\\'s color has value 2 it will be new maxColor.\\r\\nMinimum a child node has the maximum color value and everytime we are updating the the color value\\r\\nwe can just do the max() between old maxColor and the current child node\\'s color value, if that\\r\\nchild node\\'s color value is the highest, it\\'ll get caught in our max()   \\r\\n```\n```\\r\\n``\\r\\nTime  complexity : O(V+E)\\r\\nSpace complexity : O(V+E)\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909579,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        for u, v in edges:\\n            adj[u].append(v)\\n        visited = defaultdict(bool)\\n        rec = defaultdict(bool)\\n        n = len(colors)\\n        \\n        @lru_cache(None)\\n        def is_cycle(i):\\n            visited[i] = True\\n            rec[i] = True\\n            for j in adj[i]:\\n                if not visited[j] and is_cycle(j):\\n                    return True\\n                elif rec[j]:\\n                    return True\\n            rec[i] = False\\n            return False\\n        \\n        @lru_cache(None)\\n        def dfs(i):\\n            visited[i] = True\\n            cv = Counter()\\n            for j in adj[i]:\\n                if not visited[j]:\\n                    child = dfs(j)\\n                    for k, v in child.items():\\n                        cv[k] = max(v, cv[k])\\n            visited[i] = False\\n            cv[colors[i]] += 1\\n            return cv.copy()\\n        \\n        ans = 0\\n        for i in range(n):\\n            if not visited[i]:\\n                if is_cycle(i):\\n                    return -1\\n        \\n        visited = defaultdict(bool)\\n        for i in range(n):\\n            if not visited[i]:\\n                cv = dfs(i)\\n                ans = max(ans, max(cv.values()))\\n        return ans\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        for u, v in edges:\\n            adj[u].append(v)\\n        visited = defaultdict(bool)\\n        rec = defaultdict(bool)\\n        n = len(colors)\\n        \\n        @lru_cache(None)\\n        def is_cycle(i):\\n            visited[i] = True\\n            rec[i] = True\\n            for j in adj[i]:\\n                if not visited[j] and is_cycle(j):\\n                    return True\\n                elif rec[j]:\\n                    return True\\n            rec[i] = False\\n            return False\\n        \\n        @lru_cache(None)\\n        def dfs(i):\\n            visited[i] = True\\n            cv = Counter()\\n            for j in adj[i]:\\n                if not visited[j]:\\n                    child = dfs(j)\\n                    for k, v in child.items():\\n                        cv[k] = max(v, cv[k])\\n            visited[i] = False\\n            cv[colors[i]] += 1\\n            return cv.copy()\\n        \\n        ans = 0\\n        for i in range(n):\\n            if not visited[i]:\\n                if is_cycle(i):\\n                    return -1\\n        \\n        visited = defaultdict(bool)\\n        for i in range(n):\\n            if not visited[i]:\\n                cv = dfs(i)\\n                ans = max(ans, max(cv.values()))\\n        return ans\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3865250,
                "title": "deep-first-search-and-dictionary-to-avoid-repeat-computation",
                "content": "# Intuition\\r\\nThis is one typical visiting graph problem. Two strategies: deep-first or breadth-first. Here the deep-first is used. \\r\\n\\r\\n# Approach\\r\\n\\r\\n## Clean the graph\\r\\nWe notice that the graph need be cleaned before starting searching. The path should be shortened to one node if:\\r\\n- The out degree of start node is 1\\r\\n- The in degree of end node is 1\\r\\n\\r\\n## Visit the graph using deep-first\\r\\nTo avoid repeating computation, the data structure `maxColorMapArray` is used and it is returned directly if this node is visisted already.\\r\\n\\r\\n### How to design the data structure?\\r\\nIt should be one array to store the map for each output node. The element is the dictionary map, where the key is the color and the value is the frequence.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(N+E)$$\\r\\nWhere N is the number of node and E is the number of edge.\\r\\n\\r\\n- Space complexity:\\r\\n$$O(N)$$\\r\\n\\r\\n\\r\\n# Code\\r\\n```js\\r\\nconst VisistingState = \"Visiting\";\\r\\nconst UnvisistedState = \"Unvisiting\";\\r\\nconst VisitedState = \"Visited\";\\r\\n\\r\\nconst LoopState = -1;\\r\\n\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    if (edges.length < 1) {\\r\\n        return 1;\\r\\n    }\\r\\n    // firstly we need to build a graph\\r\\n\\r\\n    const colorList = [...colors];\\r\\n    let elements = colorList.map((color, index) => new Element(index, color));\\r\\n    edges.forEach(edge => {\\r\\n        const [from, to] = edge;\\r\\n        elements[from].addNext(elements[to]);\\r\\n        elements[to].inDegree++;\\r\\n        elements[from].outDegree++;\\r\\n    });\\r\\n    // clean up the graph\\r\\n    const loop = cleanGraph(elements) == -1;\\r\\n    if (loop) {\\r\\n        return LoopState;\\r\\n    }\\r\\n    elements = elements.filter(ele => !ele.toBeRemoved);\\r\\n    // find the longest path\\r\\n    elements.forEach(ele => ele.unsetVisited());\\r\\n    const maxPathCount = findLongestPath(elements);\\r\\n\\r\\n    return maxPathCount;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Find the longest path\\r\\n * @param {Element[]} elements \\r\\n */\\r\\nconst findLongestPath = function(elements) {\\r\\n    const heads = elements.filter(ele => ele.inDegree === 0);\\r\\n    let maxPathCount = -1;\\r\\n    for (const root of heads) {\\r\\n        const {maxColorMapArray, maxPathCount: pathCount} = findDepthFrist(root);\\r\\n        if (pathCount === LoopState) {\\r\\n            return LoopState;\\r\\n        }\\r\\n        maxPathCount = Math.max(maxPathCount, pathCount);\\r\\n    }\\r\\n    elements.forEach(ele => ele.unsetVisited());\\r\\n    return maxPathCount;\\r\\n}\\r\\n\\r\\n/**\\r\\n * find the longest path from root\\r\\n * @param {Element} root \\r\\n * @returns {{}} return the max color map array and the max path count\\r\\n */\\r\\nconst findDepthFrist = function(root) {\\r\\n    if (root.isVisiting()) {\\r\\n        return {maxColorMapArray: undefined, maxPathCount: LoopState};\\r\\n    }\\r\\n\\r\\n    if (root.isVisited()) {\\r\\n        return {maxColorMapArray: root.maxColorMapArray, maxPathCount: root.maxPathCount};\\r\\n    }\\r\\n\\r\\n    if (root.nextList.length === 0) {\\r\\n        // it is a leaf\\r\\n        root.setVisited();\\r\\n        root.maxColorMapArray = [root.colorMap];\\r\\n        root.maxPathCount = getMaxCountFromColorMapArray(root.maxColorMapArray);\\r\\n        return {maxColorMapArray: root.maxColorMapArray, maxPathCount: root.maxPathCount};\\r\\n    }\\r\\n\\r\\n    root.setVisiting();\\r\\n    let maxColorMapArray = [];\\r\\n\\r\\n    root.nextList.forEach(next => {\\r\\n        const {maxColorMapArray: nextColorMapArray, maxPathCount: nextMaxPathCount} = findDepthFrist(next);\\r\\n        if (nextMaxPathCount === LoopState) {\\r\\n            return {maxColorMapArray: undefined, maxPathCount: LoopState};\\r\\n        }\\r\\n\\r\\n        const maxColorMap = getMaxCountForEachColor(root.colorMap, nextColorMapArray);\\r\\n        maxColorMapArray.push(maxColorMap);\\r\\n    });\\r\\n\\r\\n    root.setVisited();\\r\\n    root.maxColorMapArray = maxColorMapArray;\\r\\n    root.maxPathCount = getMaxCountFromColorMapArray(root.maxColorMapArray);\\r\\n    return {maxColorMapArray: root.maxColorMapArray, maxPathCount: root.maxPathCount};\\r\\n};\\r\\n\\r\\nconst getMaxCountFromColorMapArray = function(colorMapArray) {\\r\\n    return Math.max(\\r\\n        ...Array.from(\\r\\n            colorMapArray.map(\\r\\n                colorMap => Math.max(...Array.from(colorMap.values()) )\\r\\n            )\\r\\n        )\\r\\n    );\\r\\n};\\r\\n\\r\\n/**\\r\\n * Get the max path from colorMapArray\\r\\n * @param {Map} colorMap1 \\r\\n * @param {Map[]} colorMapArray \\r\\n * @returns {Map} the max color map\\r\\n */\\r\\nconst getMaxCountForEachColor = function(colorMap1, colorMapArray) {\\r\\n    let maxColorMap = new Map(colorMap1);\\r\\n    colorMapArray.forEach(colorMap => {\\r\\n        let rawColorMap = new Map(colorMap1);\\r\\n        updateColorMapFromColorMap(rawColorMap, colorMap);\\r\\n\\r\\n        rawColorMap.forEach((count, color) => {\\r\\n            const countNew = maxColorMap.get(color) || 0;\\r\\n            maxColorMap.set(color, Math.max(count, countNew));\\r\\n        });\\r\\n    });\\r\\n    return maxColorMap;\\r\\n}\\r\\n\\r\\nconst updateColorMapFromColorMapArray = function(colorMapIn, colorMapArray) {\\r\\n    colorMapArray.forEach(colorMap => {\\r\\n        updateColorMapFromColorMap(colorMapIn, colorMap);\\r\\n    });\\r\\n};\\r\\n\\r\\nconst updateColorMapFromColorMap = function(colorMapIn, colorMap) {\\r\\n    colorMap.forEach((count, color) => {\\r\\n        const countNew = colorMapIn.get(color) || 0;\\r\\n        colorMapIn.set(color, count + countNew);\\r\\n    });\\r\\n};\\r\\n\\r\\n/**\\r\\n * Clean up the graph\\r\\n * @param {Element[]} elements\\r\\n * @returns 1 if success, -1 if there is a loop\\r\\n */\\r\\nconst cleanGraph = function(elements) {\\r\\n    const unvisitedElements = [...elements];\\r\\n    let unvisitedEle = unvisitedElements.pop();\\r\\n    while (unvisitedEle) {\\r\\n        const {simplifiedEle: simplifiedEle, loop: loop} = simplifyGraph(unvisitedEle);\\r\\n        if (loop) {\\r\\n            return LoopState;\\r\\n        }\\r\\n        unvisitedEle = unvisitedElements.pop();\\r\\n    }\\r\\n    elements = elements.filter(ele => !ele.toBeRemoved);\\r\\n    elements.forEach(ele => ele.unsetVisited());\\r\\n    return 1;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param {Element} root\\r\\n * @returns {{Element, boolean}} return simplified element and whether there is a loop\\r\\n */\\r\\nconst simplifyGraph = function(root) {\\r\\n    if (root.isVisiting()) {\\r\\n        return {simplifiedEle: root, loop: true};\\r\\n    }\\r\\n\\r\\n    if (root.isVisited()) {\\r\\n        return {simplifiedEle: root, loop: false};\\r\\n    }\\r\\n\\r\\n    root.setVisiting();\\r\\n    let loop = false;\\r\\n\\r\\n    if (root.isSingleOutDegree() && root.nextList.length === 1) {\\r\\n        let next = root.nextList[0];\\r\\n        const {simplifiedEle: simplifiedEleNext, loop: nextLoop} = simplifyGraph(next);\\r\\n        loop = loop || nextLoop;\\r\\n        if (!loop && simplifiedEleNext.isSingleInDegree()) {\\r\\n            simplifiedEleNext.toBeRemoved = true;\\r\\n            root.nextList = simplifiedEleNext.nextList;\\r\\n            simplifiedEleNext.colorMap.forEach((count, color) => {\\r\\n                root.setColor(color, count);\\r\\n            });\\r\\n            root.outDegree = simplifiedEleNext.outDegree;\\r\\n        }\\r\\n    }\\r\\n    root.setVisited();\\r\\n    return {simplifiedEle: root, loop};\\r\\n};\\r\\n\\r\\n/**\\r\\n * Print the graph\\r\\n * @param {Element[]} elements\\r\\n */\\r\\nconst printGraph = function(elements) {\\r\\n    const heads = elements.filter(ele => ele.inDegree === 0);\\r\\n    heads.forEach(head => printDepthFrist(head));\\r\\n    elements.forEach(ele => ele.unsetVisited());\\r\\n}\\r\\n\\r\\n/**\\r\\n * Print the graph depth first\\r\\n * @param {Element} root\\r\\n */\\r\\nconst printDepthFrist = function(root) {\\r\\n    if (root.isVisited()) {\\r\\n        return;\\r\\n    }\\r\\n    root.setVisited();\\r\\n    root.print();\\r\\n    root.nextList.forEach(next => printDepthFrist(next));\\r\\n    if (root.nextList.length === 0) {\\r\\n        console.log(\"end\");\\r\\n    }\\r\\n}\\r\\n\\r\\nclass Element {\\r\\n    constructor(index, color) {\\r\\n        this.index = index;\\r\\n        this.colorMap = new Map();\\r\\n        this.setColor(color);\\r\\n        this.nextList = [];\\r\\n        this.state = UnvisistedState;\\r\\n        this.inDegree = 0;\\r\\n        this.outDegree = 0;\\r\\n        this.toBeRemoved = false;\\r\\n        this.maxPathCount = 0;\\r\\n        this.maxColorMapArray = [];\\r\\n    }\\r\\n\\r\\n    print() {\\r\\n        console.log(`index: ${this.index}, colorMap: ${this.colorMap}, nextList: ${this.nextList.map(ele => ele.index)}`);\\r\\n    }\\r\\n\\r\\n    setColor(color, count = 1) {\\r\\n        const countNew = this.colorMap.get(color) || 0;\\r\\n        this.colorMap.set(color, count + countNew);\\r\\n    }\\r\\n\\r\\n    addNext(next) {\\r\\n        this.nextList.push(next);\\r\\n    }\\r\\n\\r\\n    setVisiting() {\\r\\n        this.state = VisistingState;\\r\\n    }\\r\\n\\r\\n    setVisited() {\\r\\n        this.state = VisitedState;\\r\\n    }\\r\\n\\r\\n    unsetVisited() {\\r\\n        this.state = UnvisistedState;\\r\\n    }\\r\\n\\r\\n    isVisited() {\\r\\n        return this.state === VisitedState;\\r\\n    }\\r\\n\\r\\n    isVisiting() {\\r\\n        return this.state === VisistingState;\\r\\n    }\\r\\n\\r\\n    isSingleInDegree() {\\r\\n        return this.inDegree <= 1;\\r\\n    }\\r\\n\\r\\n    isSingleOutDegree() {\\r\\n        return this.outDegree <= 1;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\r\\nconst VisistingState = \"Visiting\";\\r\\nconst UnvisistedState = \"Unvisiting\";\\r\\nconst VisitedState = \"Visited\";\\r\\n\\r\\nconst LoopState = -1;\\r\\n\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    if (edges.length < 1) {\\r\\n        return 1;\\r\\n    }\\r\\n    // firstly we need to build a graph\\r\\n\\r\\n    const colorList = [...colors];\\r\\n    let elements = colorList.map((color, index) => new Element(index, color));\\r\\n    edges.forEach(edge => {\\r\\n        const [from, to] = edge;\\r\\n        elements[from].addNext(elements[to]);\\r\\n        elements[to].inDegree++;\\r\\n        elements[from].outDegree++;\\r\\n    });\\r\\n    // clean up the graph\\r\\n    const loop = cleanGraph(elements) == -1;\\r\\n    if (loop) {\\r\\n        return LoopState;\\r\\n    }\\r\\n    elements = elements.filter(ele => !ele.toBeRemoved);\\r\\n    // find the longest path\\r\\n    elements.forEach(ele => ele.unsetVisited());\\r\\n    const maxPathCount = findLongestPath(elements);\\r\\n\\r\\n    return maxPathCount;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Find the longest path\\r\\n * @param {Element[]} elements \\r\\n */\\r\\nconst findLongestPath = function(elements) {\\r\\n    const heads = elements.filter(ele => ele.inDegree === 0);\\r\\n    let maxPathCount = -1;\\r\\n    for (const root of heads) {\\r\\n        const {maxColorMapArray, maxPathCount: pathCount} = findDepthFrist(root);\\r\\n        if (pathCount === LoopState) {\\r\\n            return LoopState;\\r\\n        }\\r\\n        maxPathCount = Math.max(maxPathCount, pathCount);\\r\\n    }\\r\\n    elements.forEach(ele => ele.unsetVisited());\\r\\n    return maxPathCount;\\r\\n}\\r\\n\\r\\n/**\\r\\n * find the longest path from root\\r\\n * @param {Element} root \\r\\n * @returns {{}} return the max color map array and the max path count\\r\\n */\\r\\nconst findDepthFrist = function(root) {\\r\\n    if (root.isVisiting()) {\\r\\n        return {maxColorMapArray: undefined, maxPathCount: LoopState};\\r\\n    }\\r\\n\\r\\n    if (root.isVisited()) {\\r\\n        return {maxColorMapArray: root.maxColorMapArray, maxPathCount: root.maxPathCount};\\r\\n    }\\r\\n\\r\\n    if (root.nextList.length === 0) {\\r\\n        // it is a leaf\\r\\n        root.setVisited();\\r\\n        root.maxColorMapArray = [root.colorMap];\\r\\n        root.maxPathCount = getMaxCountFromColorMapArray(root.maxColorMapArray);\\r\\n        return {maxColorMapArray: root.maxColorMapArray, maxPathCount: root.maxPathCount};\\r\\n    }\\r\\n\\r\\n    root.setVisiting();\\r\\n    let maxColorMapArray = [];\\r\\n\\r\\n    root.nextList.forEach(next => {\\r\\n        const {maxColorMapArray: nextColorMapArray, maxPathCount: nextMaxPathCount} = findDepthFrist(next);\\r\\n        if (nextMaxPathCount === LoopState) {\\r\\n            return {maxColorMapArray: undefined, maxPathCount: LoopState};\\r\\n        }\\r\\n\\r\\n        const maxColorMap = getMaxCountForEachColor(root.colorMap, nextColorMapArray);\\r\\n        maxColorMapArray.push(maxColorMap);\\r\\n    });\\r\\n\\r\\n    root.setVisited();\\r\\n    root.maxColorMapArray = maxColorMapArray;\\r\\n    root.maxPathCount = getMaxCountFromColorMapArray(root.maxColorMapArray);\\r\\n    return {maxColorMapArray: root.maxColorMapArray, maxPathCount: root.maxPathCount};\\r\\n};\\r\\n\\r\\nconst getMaxCountFromColorMapArray = function(colorMapArray) {\\r\\n    return Math.max(\\r\\n        ...Array.from(\\r\\n            colorMapArray.map(\\r\\n                colorMap => Math.max(...Array.from(colorMap.values()) )\\r\\n            )\\r\\n        )\\r\\n    );\\r\\n};\\r\\n\\r\\n/**\\r\\n * Get the max path from colorMapArray\\r\\n * @param {Map} colorMap1 \\r\\n * @param {Map[]} colorMapArray \\r\\n * @returns {Map} the max color map\\r\\n */\\r\\nconst getMaxCountForEachColor = function(colorMap1, colorMapArray) {\\r\\n    let maxColorMap = new Map(colorMap1);\\r\\n    colorMapArray.forEach(colorMap => {\\r\\n        let rawColorMap = new Map(colorMap1);\\r\\n        updateColorMapFromColorMap(rawColorMap, colorMap);\\r\\n\\r\\n        rawColorMap.forEach((count, color) => {\\r\\n            const countNew = maxColorMap.get(color) || 0;\\r\\n            maxColorMap.set(color, Math.max(count, countNew));\\r\\n        });\\r\\n    });\\r\\n    return maxColorMap;\\r\\n}\\r\\n\\r\\nconst updateColorMapFromColorMapArray = function(colorMapIn, colorMapArray) {\\r\\n    colorMapArray.forEach(colorMap => {\\r\\n        updateColorMapFromColorMap(colorMapIn, colorMap);\\r\\n    });\\r\\n};\\r\\n\\r\\nconst updateColorMapFromColorMap = function(colorMapIn, colorMap) {\\r\\n    colorMap.forEach((count, color) => {\\r\\n        const countNew = colorMapIn.get(color) || 0;\\r\\n        colorMapIn.set(color, count + countNew);\\r\\n    });\\r\\n};\\r\\n\\r\\n/**\\r\\n * Clean up the graph\\r\\n * @param {Element[]} elements\\r\\n * @returns 1 if success, -1 if there is a loop\\r\\n */\\r\\nconst cleanGraph = function(elements) {\\r\\n    const unvisitedElements = [...elements];\\r\\n    let unvisitedEle = unvisitedElements.pop();\\r\\n    while (unvisitedEle) {\\r\\n        const {simplifiedEle: simplifiedEle, loop: loop} = simplifyGraph(unvisitedEle);\\r\\n        if (loop) {\\r\\n            return LoopState;\\r\\n        }\\r\\n        unvisitedEle = unvisitedElements.pop();\\r\\n    }\\r\\n    elements = elements.filter(ele => !ele.toBeRemoved);\\r\\n    elements.forEach(ele => ele.unsetVisited());\\r\\n    return 1;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @param {Element} root\\r\\n * @returns {{Element, boolean}} return simplified element and whether there is a loop\\r\\n */\\r\\nconst simplifyGraph = function(root) {\\r\\n    if (root.isVisiting()) {\\r\\n        return {simplifiedEle: root, loop: true};\\r\\n    }\\r\\n\\r\\n    if (root.isVisited()) {\\r\\n        return {simplifiedEle: root, loop: false};\\r\\n    }\\r\\n\\r\\n    root.setVisiting();\\r\\n    let loop = false;\\r\\n\\r\\n    if (root.isSingleOutDegree() && root.nextList.length === 1) {\\r\\n        let next = root.nextList[0];\\r\\n        const {simplifiedEle: simplifiedEleNext, loop: nextLoop} = simplifyGraph(next);\\r\\n        loop = loop || nextLoop;\\r\\n        if (!loop && simplifiedEleNext.isSingleInDegree()) {\\r\\n            simplifiedEleNext.toBeRemoved = true;\\r\\n            root.nextList = simplifiedEleNext.nextList;\\r\\n            simplifiedEleNext.colorMap.forEach((count, color) => {\\r\\n                root.setColor(color, count);\\r\\n            });\\r\\n            root.outDegree = simplifiedEleNext.outDegree;\\r\\n        }\\r\\n    }\\r\\n    root.setVisited();\\r\\n    return {simplifiedEle: root, loop};\\r\\n};\\r\\n\\r\\n/**\\r\\n * Print the graph\\r\\n * @param {Element[]} elements\\r\\n */\\r\\nconst printGraph = function(elements) {\\r\\n    const heads = elements.filter(ele => ele.inDegree === 0);\\r\\n    heads.forEach(head => printDepthFrist(head));\\r\\n    elements.forEach(ele => ele.unsetVisited());\\r\\n}\\r\\n\\r\\n/**\\r\\n * Print the graph depth first\\r\\n * @param {Element} root\\r\\n */\\r\\nconst printDepthFrist = function(root) {\\r\\n    if (root.isVisited()) {\\r\\n        return;\\r\\n    }\\r\\n    root.setVisited();\\r\\n    root.print();\\r\\n    root.nextList.forEach(next => printDepthFrist(next));\\r\\n    if (root.nextList.length === 0) {\\r\\n        console.log(\"end\");\\r\\n    }\\r\\n}\\r\\n\\r\\nclass Element {\\r\\n    constructor(index, color) {\\r\\n        this.index = index;\\r\\n        this.colorMap = new Map();\\r\\n        this.setColor(color);\\r\\n        this.nextList = [];\\r\\n        this.state = UnvisistedState;\\r\\n        this.inDegree = 0;\\r\\n        this.outDegree = 0;\\r\\n        this.toBeRemoved = false;\\r\\n        this.maxPathCount = 0;\\r\\n        this.maxColorMapArray = [];\\r\\n    }\\r\\n\\r\\n    print() {\\r\\n        console.log(`index: ${this.index}, colorMap: ${this.colorMap}, nextList: ${this.nextList.map(ele => ele.index)}`);\\r\\n    }\\r\\n\\r\\n    setColor(color, count = 1) {\\r\\n        const countNew = this.colorMap.get(color) || 0;\\r\\n        this.colorMap.set(color, count + countNew);\\r\\n    }\\r\\n\\r\\n    addNext(next) {\\r\\n        this.nextList.push(next);\\r\\n    }\\r\\n\\r\\n    setVisiting() {\\r\\n        this.state = VisistingState;\\r\\n    }\\r\\n\\r\\n    setVisited() {\\r\\n        this.state = VisitedState;\\r\\n    }\\r\\n\\r\\n    unsetVisited() {\\r\\n        this.state = UnvisistedState;\\r\\n    }\\r\\n\\r\\n    isVisited() {\\r\\n        return this.state === VisitedState;\\r\\n    }\\r\\n\\r\\n    isVisiting() {\\r\\n        return this.state === VisistingState;\\r\\n    }\\r\\n\\r\\n    isSingleInDegree() {\\r\\n        return this.inDegree <= 1;\\r\\n    }\\r\\n\\r\\n    isSingleOutDegree() {\\r\\n        return this.outDegree <= 1;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861913,
                "title": "easy-topo-sort-dp-c",
                "content": "# Intuition\\r\\nas we can see that it has directed edges so first thing should come in our mind as toposort and then for calculating ans we need previous nodes so here comes the dp part\\r\\n\\r\\n# Approach\\r\\nfirst calculate a topo sort if not possible then return -1\\r\\notherwise lets move to ans calculation part first we will fill the base case as nodes with thier color as 1 and after that we will fill the childs we can reach throught them and take the max as we can reach\\r\\na particular child with many differnt nodes and the end we will find the max values and return \\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(n+m) toposort and O(n*26) overall O(n+m)+O(n*26)\\r\\n\\r\\n- Space complexity:\\r\\nO(n*26)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n   \\r\\n    int largestPathValue(string col, vector<vector<int>>& edges) {\\r\\n        int n=col.size();\\r\\n        vector<int> adj[n];\\r\\n        vector<int> indegree(n,0);\\r\\n        for(int i=0; i<edges.size(); i++){\\r\\n             int x=edges[i][0];\\r\\n             int y=edges[i][1];\\r\\n             adj[x].push_back(y);\\r\\n             indegree[y]++;\\r\\n        }\\r\\n        queue<int> q;\\r\\n        for(int i=0; i<n; i++){\\r\\n            if(indegree[i]==0){\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n        vector<int> v;\\r\\n        // topo sort will be stored in vector v\\r\\n        while(!q.empty()){\\r\\n            int node=q.front();\\r\\n            v.push_back(node);\\r\\n            q.pop();\\r\\n            for(int child:adj[node]){\\r\\n                indegree[child]--;\\r\\n                if(indegree[child]==0){\\r\\n                    q.push(child);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n       // if cycle is there \\r\\n        if(v.size()!=n){\\r\\n            return -1;\\r\\n        }\\r\\n        int fans=0;\\r\\n        vector<vector<int>> dp(n,vector<int> (26,0));\\r\\n        // filling the base case \\r\\n        for(int i=0; i<n; i++){\\r\\n             int j=col[i]-\\'a\\';\\r\\n              dp[i][j]=1;\\r\\n        }\\r\\n       \\r\\n     \\r\\n        for(int i=0; i<v.size(); i++){\\r\\n            int node=v[i];\\r\\n            for(int child:adj[node]){\\r\\n                int cc=col[child]-\\'a\\';\\r\\n                for(int j=0; j<26; j++){\\r\\n                    if(cc==j){\\r\\n                    dp[child][j]=max((1+dp[node][j]),dp[child][j]);\\r\\n                    }\\r\\n                    else{\\r\\n                    dp[child][j]=max(dp[child][j],dp[node][j]);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        for(int i=0; i<n; i++){\\r\\n            for(int j=0; j<26; j++){\\r\\n                // cout<<dp[i][j]<<\" \";\\r\\n                fans=max(fans,dp[i][j]);\\r\\n            }\\r\\n            cout<<endl;\\r\\n        }\\r\\n        return fans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n   \\r\\n    int largestPathValue(string col, vector<vector<int>>& edges) {\\r\\n        int n=col.size();\\r\\n        vector<int> adj[n];\\r\\n        vector<int> indegree(n,0);\\r\\n        for(int i=0; i<edges.size(); i++){\\r\\n             int x=edges[i][0];\\r\\n             int y=edges[i][1];\\r\\n             adj[x].push_back(y);\\r\\n             indegree[y]++;\\r\\n        }\\r\\n        queue<int> q;\\r\\n        for(int i=0; i<n; i++){\\r\\n            if(indegree[i]==0){\\r\\n                q.push(i);\\r\\n            }\\r\\n        }\\r\\n        vector<int> v;\\r\\n        // topo sort will be stored in vector v\\r\\n        while(!q.empty()){\\r\\n            int node=q.front();\\r\\n            v.push_back(node);\\r\\n            q.pop();\\r\\n            for(int child:adj[node]){\\r\\n                indegree[child]--;\\r\\n                if(indegree[child]==0){\\r\\n                    q.push(child);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n       // if cycle is there \\r\\n        if(v.size()!=n){\\r\\n            return -1;\\r\\n        }\\r\\n        int fans=0;\\r\\n        vector<vector<int>> dp(n,vector<int> (26,0));\\r\\n        // filling the base case \\r\\n        for(int i=0; i<n; i++){\\r\\n             int j=col[i]-\\'a\\';\\r\\n              dp[i][j]=1;\\r\\n        }\\r\\n       \\r\\n     \\r\\n        for(int i=0; i<v.size(); i++){\\r\\n            int node=v[i];\\r\\n            for(int child:adj[node]){\\r\\n                int cc=col[child]-\\'a\\';\\r\\n                for(int j=0; j<26; j++){\\r\\n                    if(cc==j){\\r\\n                    dp[child][j]=max((1+dp[node][j]),dp[child][j]);\\r\\n                    }\\r\\n                    else{\\r\\n                    dp[child][j]=max(dp[child][j],dp[node][j]);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        for(int i=0; i<n; i++){\\r\\n            for(int j=0; j<26; j++){\\r\\n                // cout<<dp[i][j]<<\" \";\\r\\n                fans=max(fans,dp[i][j]);\\r\\n            }\\r\\n            cout<<endl;\\r\\n        }\\r\\n        return fans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3860595,
                "title": "js-topological-sort-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    if (!edges.length) return 1\\r\\n\\r\\n    const adList = {}\\r\\n    const inDegree = {}\\r\\n\\r\\n    edges.forEach(edge => {\\r\\n        const [start, end] = edge \\r\\n        if (!adList[start]) adList[start] = new Set()\\r\\n        adList[start].add(end)\\r\\n        if (!inDegree[end]) inDegree[end] = 0 \\r\\n        if (!inDegree[start]) inDegree[start] = 0 \\r\\n        inDegree[end] ++\\r\\n    })\\r\\n\\r\\n    const counts = new Array(colors.length)\\r\\n        .fill(new Array(26).fill(0))\\r\\n        .map(c => new Array(26).fill(0))\\r\\n\\r\\n    const queue = Object.keys(inDegree).filter(k => !inDegree[k])\\r\\n\\r\\n    let answer = 0 \\r\\n    let seen = 0 \\r\\n\\r\\n    while (queue.length) {\\r\\n        const node = queue.shift()\\r\\n        seen ++\\r\\n        counts[node][colors[node].charCodeAt(0) - \\'a\\'.charCodeAt(0)] ++\\r\\n        answer = Math.max(answer, counts[node][colors[node].charCodeAt(0) - \\'a\\'.charCodeAt(0)])\\r\\n\\r\\n        if (!adList[node]) {\\r\\n            continue\\r\\n        }\\r\\n\\r\\n        adList[node].forEach(neig => {\\r\\n            for (let i = 0; i < 26; i++) {\\r\\n                counts[neig][i] = Math.max(counts[neig][i], counts[node][i])\\r\\n            }\\r\\n\\r\\n            inDegree[neig]--\\r\\n            if (inDegree[neig] == 0) {\\r\\n                queue.push(neig)\\r\\n            }\\r\\n        })\\r\\n\\r\\n    }\\r\\n\\r\\n    return seen == colors.length ? answer : -1\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\n/**\\r\\n * @param {string} colors\\r\\n * @param {number[][]} edges\\r\\n * @return {number}\\r\\n */\\r\\nvar largestPathValue = function(colors, edges) {\\r\\n    if (!edges.length) return 1\\r\\n\\r\\n    const adList = {}\\r\\n    const inDegree = {}\\r\\n\\r\\n    edges.forEach(edge => {\\r\\n        const [start, end] = edge \\r\\n        if (!adList[start]) adList[start] = new Set()\\r\\n        adList[start].add(end)\\r\\n        if (!inDegree[end]) inDegree[end] = 0 \\r\\n        if (!inDegree[start]) inDegree[start] = 0 \\r\\n        inDegree[end] ++\\r\\n    })\\r\\n\\r\\n    const counts = new Array(colors.length)\\r\\n        .fill(new Array(26).fill(0))\\r\\n        .map(c => new Array(26).fill(0))\\r\\n\\r\\n    const queue = Object.keys(inDegree).filter(k => !inDegree[k])\\r\\n\\r\\n    let answer = 0 \\r\\n    let seen = 0 \\r\\n\\r\\n    while (queue.length) {\\r\\n        const node = queue.shift()\\r\\n        seen ++\\r\\n        counts[node][colors[node].charCodeAt(0) - \\'a\\'.charCodeAt(0)] ++\\r\\n        answer = Math.max(answer, counts[node][colors[node].charCodeAt(0) - \\'a\\'.charCodeAt(0)])\\r\\n\\r\\n        if (!adList[node]) {\\r\\n            continue\\r\\n        }\\r\\n\\r\\n        adList[node].forEach(neig => {\\r\\n            for (let i = 0; i < 26; i++) {\\r\\n                counts[neig][i] = Math.max(counts[neig][i], counts[node][i])\\r\\n            }\\r\\n\\r\\n            inDegree[neig]--\\r\\n            if (inDegree[neig] == 0) {\\r\\n                queue.push(neig)\\r\\n            }\\r\\n        })\\r\\n\\r\\n    }\\r\\n\\r\\n    return seen == colors.length ? answer : -1\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817184,
                "title": "topological-sort-momoization-pruning-optimization-90-memory-96-cpu",
                "content": "# Approach\\r\\n1. The longer the path, the better the chance we can get the largest color value.\\r\\n2. Since the input graph is a directed acyclic graph (otherwise return -1), there is a valid topological order of nodes. Consider paths 1->2->3: if we can figure out what\\'s the maximum number of color \\'a\\' contained in a previous path leading to node 1, we can figure out what\\'s the maximum number of color \\'a\\' contained in a path leading to node 2. The same goes for node 2 and 3. We define the maximum number of each possible color contained in a previous path leading to node x as the node\\'s \"color portfolio\".\\r\\n3. For \"forks\", e.g. for valid paths 1->2->5 and 3->4->5, both node 2 and 4 will update node 5\\'s color portfolio as described in point 2. In addition, once a node updated all the color portfolios of its children, the node\\'s color portfolio is no longer used. This is crucial for pruning optimization for memory.\\r\\n4. The largest number of each node\\'s color portfolio will be the maximum color value of the problem.\\r\\n\\r\\n# Solution\\r\\n```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        out = -1\\r\\n        graph = {}\\r\\n        in_number = {}\\r\\n        dp = {}\\r\\n        removed_edges = 0\\r\\n\\r\\n        for a, b in edges:\\r\\n            graph[a] = graph.get(a, set())\\r\\n            graph[a].add(b)\\r\\n            graph[b] = graph.get(b, set())\\r\\n            in_number[a] = in_number.get(a,0)\\r\\n            in_number[b] = in_number.get(b,0) + 1\\r\\n\\r\\n        # topological sort\\r\\n        stack = deque()\\r\\n        for node in graph.keys():\\r\\n            if in_number[node] == 0:\\r\\n                stack.append(node)\\r\\n                dp[node] = {}\\r\\n                dp[node][colors[node]] = 1\\r\\n        \\r\\n        while stack:\\r\\n            node = stack.pop()\\r\\n            dp_self = dp.get(node, {})\\r\\n            for nei in list(graph[node]):\\r\\n                color = colors[nei]\\r\\n                dp[nei] = dp.get(nei, {color: 1})\\r\\n                dp_nei = dp[nei]\\r\\n                dp_nei[color] = dp_nei.get(color, 1)\\r\\n                out = max(out, dp_nei[color])\\r\\n                for c in dp_self:\\r\\n                    dp_nei[c] = max(dp_self[c]+(1 if c == color else 0), dp_nei.get(c, 0))\\r\\n                    out = max(out, dp_nei[c])\\r\\n\\r\\n                graph[node].remove(nei)\\r\\n                in_number[nei] -= 1\\r\\n                removed_edges += 1\\r\\n                if not in_number[nei]:\\r\\n                    stack.append(nei)\\r\\n                \\r\\n            del dp[node]\\r\\n        \\r\\n        if removed_edges != len(edges):\\r\\n            return -1\\r\\n\\r\\n        return max(out, 1)\\r\\n\\r\\n```\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(m+n)$$ in the worst case\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(m+n)$$ in the worst case\\r\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        out = -1\\r\\n        graph = {}\\r\\n        in_number = {}\\r\\n        dp = {}\\r\\n        removed_edges = 0\\r\\n\\r\\n        for a, b in edges:\\r\\n            graph[a] = graph.get(a, set())\\r\\n            graph[a].add(b)\\r\\n            graph[b] = graph.get(b, set())\\r\\n            in_number[a] = in_number.get(a,0)\\r\\n            in_number[b] = in_number.get(b,0) + 1\\r\\n\\r\\n        # topological sort\\r\\n        stack = deque()\\r\\n        for node in graph.keys():\\r\\n            if in_number[node] == 0:\\r\\n                stack.append(node)\\r\\n                dp[node] = {}\\r\\n                dp[node][colors[node]] = 1\\r\\n        \\r\\n        while stack:\\r\\n            node = stack.pop()\\r\\n            dp_self = dp.get(node, {})\\r\\n            for nei in list(graph[node]):\\r\\n                color = colors[nei]\\r\\n                dp[nei] = dp.get(nei, {color: 1})\\r\\n                dp_nei = dp[nei]\\r\\n                dp_nei[color] = dp_nei.get(color, 1)\\r\\n                out = max(out, dp_nei[color])\\r\\n                for c in dp_self:\\r\\n                    dp_nei[c] = max(dp_self[c]+(1 if c == color else 0), dp_nei.get(c, 0))\\r\\n                    out = max(out, dp_nei[c])\\r\\n\\r\\n                graph[node].remove(nei)\\r\\n                in_number[nei] -= 1\\r\\n                removed_edges += 1\\r\\n                if not in_number[nei]:\\r\\n                    stack.append(nei)\\r\\n                \\r\\n            del dp[node]\\r\\n        \\r\\n        if removed_edges != len(edges):\\r\\n            return -1\\r\\n\\r\\n        return max(out, 1)\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798140,
                "title": "c-another-kind-of-dp-faster-than-99-58-less-than-97-79-space",
                "content": "```cpp\\nint largestPathValue(string colors, vector<vector<int>>& edges) {\\n\\t//build adjacency list\\n    vector<vector<int>> adj_list(colors.size());\\n    for(const auto &edge: edges)\\n        adj_list[edge[0]].push_back(edge[1]);\\n    \\n\\t//check for cycle using simple bfs\\n    if(isCyclic(adj_list, colors.size()))\\n        return -1;\\n    \\n\\n    vector<int> dp(colors.size(), -1);\\n\\t// f checks path which have max number of nodes with given \\'color\\' param\\n\\t// checking to be done starting from node \\'i\\' param\\n    function<int(char,int)> f = [&](char color, int i){\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        int same_color = colors[i] == color; \\n        int maxi = same_color;\\n        for(int next_node: adj_list[i]){\\n            auto nxt_val = f(color, next_node);\\n            maxi = max(same_color + nxt_val, maxi);\\n        }\\n        return dp[i] = maxi;\\n    };\\n\\n    int maxi = INT_MIN;\\n    unordered_set<char> possible_colors;\\n    for(const auto color: colors) possible_colors.insert(color);\\n    \\n    for(const auto color: possible_colors){\\n        for(auto &x: dp) x = -1;\\n        for(int i=0; i<colors.size(); ++i)\\n            maxi = max(maxi, f(color, i));\\n    }\\n    return maxi;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nint largestPathValue(string colors, vector<vector<int>>& edges) {\\n\\t//build adjacency list\\n    vector<vector<int>> adj_list(colors.size());\\n    for(const auto &edge: edges)\\n        adj_list[edge[0]].push_back(edge[1]);\\n    \\n\\t//check for cycle using simple bfs\\n    if(isCyclic(adj_list, colors.size()))\\n        return -1;\\n    \\n\\n    vector<int> dp(colors.size(), -1);\\n\\t// f checks path which have max number of nodes with given \\'color\\' param\\n\\t// checking to be done starting from node \\'i\\' param\\n    function<int(char,int)> f = [&](char color, int i){\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        int same_color = colors[i] == color; \\n        int maxi = same_color;\\n        for(int next_node: adj_list[i]){\\n            auto nxt_val = f(color, next_node);\\n            maxi = max(same_color + nxt_val, maxi);\\n        }\\n        return dp[i] = maxi;\\n    };\\n\\n    int maxi = INT_MIN;\\n    unordered_set<char> possible_colors;\\n    for(const auto color: colors) possible_colors.insert(color);\\n    \\n    for(const auto color: possible_colors){\\n        for(auto &x: dp) x = -1;\\n        for(int i=0; i<colors.size(); ++i)\\n            maxi = max(maxi, f(color, i));\\n    }\\n    return maxi;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785310,
                "title": "rust-dynamic-programming-beats-100",
                "content": "# Intuition\\r\\n\\r\\nThere are at most 26 colors, so we can simply check the largest value for each color!!\\r\\n\\r\\n# Approach\\r\\n\\r\\n**Top-down Dynamic Programming**. For each node, check the largest color value starting from itself.\\r\\n\\r\\n# Code\\r\\n```\\r\\n#[derive(Clone, Copy)]\\r\\nenum States {\\r\\n    None,\\r\\n    Pending,\\r\\n    Some(usize),\\r\\n}\\r\\n\\r\\npub struct DP {\\r\\n    vec: Vec<Vec<usize>>,\\r\\n    n: usize,\\r\\n\\r\\n    color_vec: Vec<u32>,\\r\\n    target: u32,\\r\\n\\r\\n    memo: Vec<States>,\\r\\n}\\r\\n\\r\\nimpl DP {\\r\\n    pub fn from(\\r\\n        vec: Vec<Vec<usize>>,\\r\\n        color_vec: Vec<u32>,\\r\\n        target: u32,\\r\\n    ) -> Self {\\r\\n        let n = vec.len();\\r\\n        let memo = vec![States::None; n + 1];\\r\\n        Self { vec, n, color_vec, target, memo }\\r\\n    }\\r\\n}\\r\\n\\r\\nimpl DP {\\r\\n    pub fn solve(&mut self, i: usize) -> Option<usize> {\\r\\n        if i > self.n { return None; }\\r\\n        match self.memo[i] {\\r\\n            States::Some(ret) => { return Some(ret); }\\r\\n            States::Pending => { return None; }\\r\\n            _ => {},\\r\\n        }\\r\\n\\r\\n        self.memo[i] = States::Pending;\\r\\n        let ret = self.solve_inner(i)?;\\r\\n        self.memo[i] = States::Some(ret);\\r\\n        Some(ret)\\r\\n    }\\r\\n\\r\\n    fn solve_inner(&mut self, i: usize) -> Option<usize> {\\r\\n        if i >= self.n { return None; }\\r\\n\\r\\n        let mut ret = usize::MIN;\\r\\n        for parent in self.vec[i].clone() {\\r\\n            if let Some(_ret) = self.solve(parent) {\\r\\n                ret = ret.max(_ret);\\r\\n            } else { return None; }\\r\\n        }\\r\\n\\r\\n        if self.color_vec[i] == self.target {\\r\\n            ret += 1;\\r\\n        }\\r\\n\\r\\n        Some(ret)\\r\\n    }\\r\\n}\\r\\n\\r\\nimpl Solution {\\r\\n    fn _impl(\\r\\n        vec: Vec<Vec<usize>>,\\r\\n        color_vec: Vec<u32>,\\r\\n        color_len: usize,\\r\\n    ) -> Option<usize> {\\r\\n        let mut ret = usize::MIN;\\r\\n        for target in 0..color_len {\\r\\n            let mut dp = DP::from(\\r\\n                vec.clone(),\\r\\n                color_vec.clone(),\\r\\n                target as u32\\r\\n            );\\r\\n            for i in 0..color_vec.len() {\\r\\n                ret = ret.max(dp.solve(i)?);\\r\\n            }\\r\\n        }\\r\\n        Some(ret)\\r\\n    }\\r\\n\\r\\n    fn compress(vec: Vec<u32>) -> (Vec<u32>, usize) {\\r\\n        let mut mapping = vec.clone();\\r\\n        mapping.sort_unstable();\\r\\n        mapping.dedup();\\r\\n\\r\\n        let vec = vec.into_iter()\\r\\n            .map(|e| mapping.binary_search(&e).unwrap() as u32)\\r\\n            .collect::<Vec<_>>();\\r\\n        \\r\\n        (vec, mapping.len())\\r\\n    }\\r\\n\\r\\n    fn deps(edges: Vec<Vec<i32>>, n: usize) -> Vec<Vec<usize>> {\\r\\n        let mut vec = vec![vec![]; n];\\r\\n        for edge in edges {\\r\\n            vec[edge[0] as usize].push(edge[1] as usize);\\r\\n        }\\r\\n        vec\\r\\n    }\\r\\n\\r\\n    pub fn largest_path_value(color_str: String, edges: Vec<Vec<i32>>) -> i32 {\\r\\n        let color_vec = color_str.chars()\\r\\n            .map(|c| c as u32 - \\'a\\' as u32)\\r\\n            .collect::<Vec<_>>();\\r\\n        \\r\\n        let (color_vec, color_len) = Self::compress(color_vec);\\r\\n        let vec = Self::deps(edges, color_vec.len());\\r\\n\\r\\n        Self::_impl(vec, color_vec, color_len)\\r\\n            .map(|e| e as i32)\\r\\n            .unwrap_or(-1)\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\r\\n#[derive(Clone, Copy)]\\r\\nenum States {\\r\\n    None,\\r\\n    Pending,\\r\\n    Some(usize),\\r\\n}\\r\\n\\r\\npub struct DP {\\r\\n    vec: Vec<Vec<usize>>,\\r\\n    n: usize,\\r\\n\\r\\n    color_vec: Vec<u32>,\\r\\n    target: u32,\\r\\n\\r\\n    memo: Vec<States>,\\r\\n}\\r\\n\\r\\nimpl DP {\\r\\n    pub fn from(\\r\\n        vec: Vec<Vec<usize>>,\\r\\n        color_vec: Vec<u32>,\\r\\n        target: u32,\\r\\n    ) -> Self {\\r\\n        let n = vec.len();\\r\\n        let memo = vec![States::None; n + 1];\\r\\n        Self { vec, n, color_vec, target, memo }\\r\\n    }\\r\\n}\\r\\n\\r\\nimpl DP {\\r\\n    pub fn solve(&mut self, i: usize) -> Option<usize> {\\r\\n        if i > self.n { return None; }\\r\\n        match self.memo[i] {\\r\\n            States::Some(ret) => { return Some(ret); }\\r\\n            States::Pending => { return None; }\\r\\n            _ => {},\\r\\n        }\\r\\n\\r\\n        self.memo[i] = States::Pending;\\r\\n        let ret = self.solve_inner(i)?;\\r\\n        self.memo[i] = States::Some(ret);\\r\\n        Some(ret)\\r\\n    }\\r\\n\\r\\n    fn solve_inner(&mut self, i: usize) -> Option<usize> {\\r\\n        if i >= self.n { return None; }\\r\\n\\r\\n        let mut ret = usize::MIN;\\r\\n        for parent in self.vec[i].clone() {\\r\\n            if let Some(_ret) = self.solve(parent) {\\r\\n                ret = ret.max(_ret);\\r\\n            } else { return None; }\\r\\n        }\\r\\n\\r\\n        if self.color_vec[i] == self.target {\\r\\n            ret += 1;\\r\\n        }\\r\\n\\r\\n        Some(ret)\\r\\n    }\\r\\n}\\r\\n\\r\\nimpl Solution {\\r\\n    fn _impl(\\r\\n        vec: Vec<Vec<usize>>,\\r\\n        color_vec: Vec<u32>,\\r\\n        color_len: usize,\\r\\n    ) -> Option<usize> {\\r\\n        let mut ret = usize::MIN;\\r\\n        for target in 0..color_len {\\r\\n            let mut dp = DP::from(\\r\\n                vec.clone(),\\r\\n                color_vec.clone(),\\r\\n                target as u32\\r\\n            );\\r\\n            for i in 0..color_vec.len() {\\r\\n                ret = ret.max(dp.solve(i)?);\\r\\n            }\\r\\n        }\\r\\n        Some(ret)\\r\\n    }\\r\\n\\r\\n    fn compress(vec: Vec<u32>) -> (Vec<u32>, usize) {\\r\\n        let mut mapping = vec.clone();\\r\\n        mapping.sort_unstable();\\r\\n        mapping.dedup();\\r\\n\\r\\n        let vec = vec.into_iter()\\r\\n            .map(|e| mapping.binary_search(&e).unwrap() as u32)\\r\\n            .collect::<Vec<_>>();\\r\\n        \\r\\n        (vec, mapping.len())\\r\\n    }\\r\\n\\r\\n    fn deps(edges: Vec<Vec<i32>>, n: usize) -> Vec<Vec<usize>> {\\r\\n        let mut vec = vec![vec![]; n];\\r\\n        for edge in edges {\\r\\n            vec[edge[0] as usize].push(edge[1] as usize);\\r\\n        }\\r\\n        vec\\r\\n    }\\r\\n\\r\\n    pub fn largest_path_value(color_str: String, edges: Vec<Vec<i32>>) -> i32 {\\r\\n        let color_vec = color_str.chars()\\r\\n            .map(|c| c as u32 - \\'a\\' as u32)\\r\\n            .collect::<Vec<_>>();\\r\\n        \\r\\n        let (color_vec, color_len) = Self::compress(color_vec);\\r\\n        let vec = Self::deps(edges, color_vec.len());\\r\\n\\r\\n        Self::_impl(vec, color_vec, color_len)\\r\\n            .map(|e| e as i32)\\r\\n            .unwrap_or(-1)\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1858444,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1857666,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858187,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1857809,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1857903,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1857710,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858724,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858795,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858523,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1698750,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858444,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1857666,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858187,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1857809,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1857903,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1857710,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858724,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858795,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858523,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1698750,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Sunday ruined successfully \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@wangchenmeng09] yeah bro"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Same thing here dude"
                    },
                    {
                        "username": "siddhantdube",
                        "content": "Seems like its a graphs week"
                    },
                    {
                        "username": "pokaChika",
                        "content": "[@elrestbrain](/elrestbrain) this question is not that hard, its tricky but if you know topological sort which you should know for interviews than its medium level"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "My streak is 5 and never do the leetcode hards. LIL SCARED"
                    },
                    {
                        "username": "arghyadas",
                        "content": "First the Contest went bad, Now this \\uD83E\\uDD72"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dear diary:\\n    Today I made the acquaintance of topological sort."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- Create a GraphNode class with integer value and an ArrayList of neighboring nodes. This class will be used to represent each node in the graph.\\n\\n- Initialize an array of GraphNode objects of size n, where n is the length of the colors string. Each GraphNode object will have a unique integer value and an empty ArrayList of neighbors.\\n\\n- Iterate over the edges array and for each edge, add the corresponding nodes to each other\\'s ArrayList of neighbors. Also, keep track of the indegree of each node, i.e., the number of incoming edges for that node.\\n\\n- Initialize a 2D array \"count\" of size n x 26, where n is the number of nodes in the graph and 26 represents the 26 possible colors. This array keeps track of the count of each color along the path leading to that node. - - Initialize the array with 1 in the position corresponding to the node\\'s own color.\\n\\n- Add all nodes with indegree 0 to a queue and initialize a visited counter to 0.\\n\\n- Start a while loop until the queue is empty. In each iteration, dequeue a node from the queue, increment the visited counter and iterate over its neighbors.\\n\\n- For each neighbor, iterate over the 26 possible colors, and update its count by taking the maximum between the current count and the count of the current node plus 1 if the neighbor\\'s color matches the current color. This is essentially a dynamic programming step.\\n\\n- Decrement the indegree of the neighbor node and add it to the queue if its indegree becomes 0.\\n\\n- Also, keep track of the maximum count seen so far in a maxLength variable.\\n\\n- Finally, return the maximum count if all nodes are visited or -1 if some nodes are not visited. This ensures that all nodes are reachable from some node with indegree 0."
                    },
                    {
                        "username": "AryanSapra280",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Hey, I have one question! you used kahn\\'s algo.\\n\\nIn your first step u pushed all the nodes with zero indegree into the queue. I didn\\'t understand the reason why are u checking again if the neighbour\\'s indegree is also zero then you will push the neighbour into the queue. Will it make any difference if the indegree is zero or not for the neighbour\\'s ? We need a path we can even traverse the neighbours even if they are having indegree or not. Correct? \\n\\nbecause of this observation, I thought of applying DFS with DP. Am I correct?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3395897/easiest-solution-topological-sort-dynamic-programming/"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I\\'ve had enough graphs for this month."
                    },
                    {
                        "username": "hello_world98",
                        "content": "yes\\n"
                    },
                    {
                        "username": "tejasX",
                        "content": "after devoting whole evening, finally done with this. Truly amazing question."
                    },
                    {
                        "username": "ada8",
                        "content": "Agreed!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Damn, this was a hard one! "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Those who were already solved this problem are real survivor."
                    },
                    {
                        "username": "featherwind2007",
                        "content": "I am wondering if we change the question to finding the most colorful path, i.e. the number of colors for the path that has most different colors, can we still get the answer in linear time? (Or is there any other similar problem for this?)"
                    },
                    {
                        "username": "featherwind2007",
                        "content": "Just realized the idea is basically the same, but we have to store every path information in each node instead.\nThe time & space complexity is exponential to the vertices but linear to the number of paths O(2^|V|).\n\n'''\nclass Solution {\npublic:\n\n    int colorfulPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        \n        vector<vector<int>> adj (n);\n        vector<int> indegree (n, 0);\n        for (auto& e : edges) {\n            adj[e[0]].push_back(e[1]);\n            indegree[e[1]]++;\n        }\n        \n        // For each node, store path information instead \n        vector<vector<unordered_set<char>>> path_colors;\n        path_colors.resize(n);\n        \n        queue<int> q;\n        for (int i=0; i<n; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n                \n                unordered_set<char> tmp_set;\n                tmp_set.insert(colors[i]);\n                path_colors[i].emplace_back(tmp_set);\n            }\n        }\n        \n        int ans = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            // Find the most colorful one\n            for (int i=0; i<path_colors[node].size(); ++i) {\n                ans = max(ans, (int) path_colors[node][i].size());\n            }\n            \n            for (auto nbr : adj[node]) {\n                // Forward the information of parent\n                for (int i=0; i<path_colors[node].size(); ++i) {\n                    unordered_set<char> tmp_set (path_colors[node][i]);\n                    tmp_set.insert(colors[nbr]);\n                    path_colors[nbr].emplace_back(tmp_set);\n                }\n                \n                --indegree[nbr];\n                if (indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n'''"
                    }
                ]
            },
            {
                "id": 1858138,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 2077084,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1859223,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1859080,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1859030,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1858888,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1858706,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1858698,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1858676,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1858613,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Yeah, another graph problem, please :["
                    },
                    {
                        "username": "realitant",
                        "content": "Am I the only one not seeing what the expected behavior is for a path with two or more equally frequent colors (lets say there are m colors in the path each occurring n times)? Is it 0 because there is no color that is the most frequently occurring. Is it n? I can even see an argument for making it m*n since there are m*n nodes in the path belonging to one of the most frequent colors.\\nThis seems like a really big oversight to not include in the description."
                    },
                    {
                        "username": "Brulans4",
                        "content": "Hello,\n\nI have a test that is not passing and I don't understand why. Can you explain why the answer is 3 instead of 4?\nIt's possible that there is something in the statement that I didn't understand, but I don't see what it could be.\n\nthis is the test :\ncolors = \"hhqhuqhqff\"\nedges =[[0,1],[0,2],[2,3],[3,4],[3,5],[5,6],[2,7],[6,7],[7,8],[3,8],[5,8],[8,9],[3,9],[6,9]]\nOutput: 4\nExpected: 3\n\nThank you in advance."
                    },
                    {
                        "username": "burgikukac",
                        "content": "I guess it\\'s too late, but the only color could count to 4 is H. While the edge 0-1 does not have an outbound connection (and the longest path with it is just 2) so it can\\'t be part of the solution. Therefore one H is out, the optimum could be at most 3. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It took me a while to solve but that was a really neat problem! \nI like it cause it's helping you practise a classic and useful algo like topological sort, while still requiring you to figure out additional stuff to demonstrate that you really understand the algorithm and are able to adapt it (as opposed to having just memorized it)\nI, for one, realized that I had previously understood how toposort works, but not well understood all of its purposes (I didn't realize that it is the key to avoid doing repeated checks when traversing DAG graph) so I learned something new with this :)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "And here I was, genuinely thinking I would get away with a simple dfs on a hard problem...\nYeah, alright, alright, it's not a tree, I guess it can degenerate to O(n^2)... Back to work!"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "What a tough one holy ****"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Did it by myself, kinda proud :)"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "Is it possible that there are multi-inbound and multi-outbound in one node?\nlike: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [8,9], [9, 10], [10, 3], [3,11], [11, 12], [12,13]],\nso node 3 will be the center node of a graph like an X"
                    },
                    {
                        "username": "njalgo",
                        "content": "Yes the mentioned scenario is possible which will result in a cycle. so this should return -1.\\nHowever, if you have an edge from [3,10] instead of [10,3] that will be acyclic."
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "7 galat submissions ke baad hua bc"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Can anyone tell me what is wrong with my code?\\n\\n `class Solution {\\npublic:\\n\\n\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,stack<int>&st){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj,st);\\n            }\\n        }\\n        st.push(node);\\n    }\\n\\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\\n        int n=colors.size();\\n        vector<vector<int>> adj(n);\\n        vector<vector<int>> color_len(n,vector<int>(26,0));\\n        stack<int> st;\\n        vector<int> vis(n,0);\\n        dfs(0,vis,adj,st);\\n        vector<int> topo;\\n        while(!st.empty()){\\n            topo.push_back(st.top());\\n            st.pop();\\n        }\\n        int max_color=-1;\\n        int processed=0;\\n        for(auto node:topo){\\n            processed+=1;\\n            max_color=max(max_color,++color_len[node][colors[node]-\\'a\\']);\\n            for(auto nei:adj[node]){\\n                for(int color=0;color<26;color++){\\n                    color_len[nei][color]=max(color_len[nei][color],color_len[node][color]);\\n                }\\n            }\\n        }\\n        return processed < n ? -1 :max_color;\\n    }\\n};`"
                    }
                ]
            }
        ]
    }
]