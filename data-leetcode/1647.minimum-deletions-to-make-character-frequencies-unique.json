[
    {
        "title": "Shortest Distance to a Character",
        "question_content": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\n&nbsp;\nExample 1:\n\nInput: s = \"loveleetcode\", c = \"e\"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\n\nExample 2:\n\nInput: s = \"aaab\", c = \"b\"\nOutput: [3,2,1,0]\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\ts[i] and c are lowercase English letters.\n\tIt is guaranteed that c occurs at least once in s.",
        "solutions": [
            {
                "id": 125788,
                "title": "c-java-python-2-pass-with-explanation",
                "content": "# Solution 1: Record the Position\\n\\nInitial result array.\\nLoop twice on the string `S`.\\nFirst forward pass to find shortest distant to character on left.\\nSecond backward pass to find shortest distant to character on right.\\n<br>\\n\\nIn python solution,  I merged these two `for` statement.\\nWe can do the same in C++/Java by:\\n```\\nfor (int i = 0; i >= 0; res[n-1] == n ? ++i : --i)\\n```\\nBut it will become less readable.\\n<br>\\n\\nTime complexity `O(N)`\\nSpace complexity `O(N)` for output\\n<br>\\n\\n**C++**\\n```cpp\\n    vector<int> shortestToChar(string S, char C) {\\n        int n = S.size(), pos = -n;\\n        vector<int> res(n, n);\\n        for (int i = 0; i < n; ++i) {\\n            if (S[i] == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S[i] == C)  pos = i;\\n            res[i] = min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java**\\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length(), pos = -n, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (S.charAt(i) == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S.charAt(i) == C)  pos = i;\\n            res[i] = Math.min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def shortestToChar(self, S, C):\\n        n, pos = len(S), -float(\\'inf\\')\\n        res = [n] * n\\n        for i in range(n) + range(n)[::-1]:\\n            if S[i] == C:\\n                pos = i\\n            res[i] = min(res[i], abs(i - pos))\\n        return res\\n```\\n<br><br>\\n\\n# Solution 2: DP\\nAnother idea is quite similar and has a sense of DP.\\n<br>\\n**C++:**\\n```cpp\\n    vector<int> shortestToChar2(string S, char C) {\\n        int n = S.size();\\n        vector<int> res(n);\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S[i] == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S.charAt(i) == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = Math.min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = Math.min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def shortestToChar(self, S, C):\\n        n = len(S)\\n        res = [0 if c == C else n for c in S]\\n        for i in range(1, n):\\n            res[i] = min(res[i], res[i - 1] + 1)\\n        for i in range(n - 2, -1, -1):\\n            res[i] = min(res[i], res[i + 1] + 1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfor (int i = 0; i >= 0; res[n-1] == n ? ++i : --i)\\n```\n```cpp\\n    vector<int> shortestToChar(string S, char C) {\\n        int n = S.size(), pos = -n;\\n        vector<int> res(n, n);\\n        for (int i = 0; i < n; ++i) {\\n            if (S[i] == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S[i] == C)  pos = i;\\n            res[i] = min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length(), pos = -n, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (S.charAt(i) == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S.charAt(i) == C)  pos = i;\\n            res[i] = Math.min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def shortestToChar(self, S, C):\\n        n, pos = len(S), -float(\\'inf\\')\\n        res = [n] * n\\n        for i in range(n) + range(n)[::-1]:\\n            if S[i] == C:\\n                pos = i\\n            res[i] = min(res[i], abs(i - pos))\\n        return res\\n```\n```cpp\\n    vector<int> shortestToChar2(string S, char C) {\\n        int n = S.size();\\n        vector<int> res(n);\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S[i] == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S.charAt(i) == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = Math.min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = Math.min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\n```py\\n    def shortestToChar(self, S, C):\\n        n = len(S)\\n        res = [0 if c == C else n for c in S]\\n        for i in range(1, n):\\n            res[i] = min(res[i], res[i - 1] + 1)\\n        for i in range(n - 2, -1, -1):\\n            res[i] = min(res[i], res[i + 1] + 1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 126116,
                "title": "concise-java-solution-with-detailed-explanation-easy-understand",
                "content": "```\\n/** \"loveleetcode\" \"e\"\\n *  1. put 0 at all position equals to e, and max at all other position\\n *     we will get [max, max, max, 0, max, 0, 0, max, max, max, max, 0]\\n *  2. scan from left to right, if =max, skip, else dist[i+1] = Math.min(dp[i] + 1, dp[i+1]), \\n *     we can get [max, max, max, 0, 1, 0, 0, 1, 2, 3, 4, 0]\\n *  3. scan from right to left, use dp[i-1] = Math.min(dp[i] + 1, dp[i-1])\\n *     we will get[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] \\n */\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == c) continue;\\n            dist[i] = Integer.MAX_VALUE;\\n        }\\n        for (int i = 0; i < n-1; i++) {\\n            if (dist[i] == Integer.MAX_VALUE) continue;\\n            else dist[i + 1] = Math.min(dist[i+1], dist[i] + 1);\\n        }\\n        for (int i = n-1; i > 0; i--) {\\n            dist[i-1] = Math.min(dist[i-1], dist[i] + 1);\\n        }\\n        return dist; \\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == c) continue;\\n            dist[i] = Integer.MAX_VALUE;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1054410,
                "title": "c-two-pass-o-n-0ms-beats-100-easy-explanation",
                "content": "**EXPLANATION**\\n- First, iterate the string **\\'s\\'** and store the **indexes** of **\\'c\\'** present in \\'s\\' into an array or vector ( here **```vector<int>ioc```** ) .\\n- Make a **left** variable for storing the index of **left nearest \\'c\\'** in **```ioc```**  and a **right** variable for storing the index of **right nearest \\'c\\'** in **```ioc```**. Initially, **```left=0```** and **```right=0```**, that is keeping the first index of **```ioc```**.\\n- Then, iterate string **\\'s\\'** again and at each iteration check if *current index* crosses **```ioc[right]```** ( that is *index of \\'c\\' present in ioc pointed by right* ) then we need to make **```left = right```** and **```right=right+1```**.\\n- Also, at each iteration find the **minimum** value between the *following two* and store it in **```ans[i]```**.\\n\\t-  **absolute value of (right nearest \\'c\\' - current index)** represented by **``` abs(ioc[right]-i)```** \\n\\t-   **absolute value of (left nearest \\'c\\' - current index)** represented by **``` abs(ioc[left]-i)```**\\n- Return **ans**.\\n\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ioc; // vector for storing the indexed of c present in s\\n        int n=s.length();\\n        \\n        vector<int>ans(n); // answer vector\\n        \\n        for(int i=0;i<n;++i){\\n            if(s[i]==c) \\n                ioc.push_back(i);\\n        }\\n        \\n        int m=ioc.size(); // size of ioc vector\\n        int left=0,right=0;\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            // if current index has crossed ioc[right] then,\\n            // we need to make the current left to right and \\n            // increment current right for pointing to next index of ioc vector ( if exists )\\n            if(i>ioc[right]){\\n                left=right;\\n                if(right<m-1)\\n                    ++right;\\n            }\\n                        \\n            // difference = min(abs(right nearest \\'c\\' - curr index),abs(left nearest \\'c\\' - curr index))\\n            ans[i]=min(abs(ioc[right]-i),abs(ioc[left]-i)); \\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nConsidering *\\'n\\'* to be the size of the maximum size of the string *\\'s\\'*.\\n\\n**TIME COMPLEXITY**\\nO(n+n)=**O(n)** [ *For iterating the string two times* ]\\n\\n**SPACE COMPLEXITY**\\n**O(n)** [ *In worst case, all characters of \\'s\\' is \\'c\\', at that time ( number of \\'c\\' in \\'s\\' = size of \\'s\\' )* ]",
                "solutionTags": [
                    "C"
                ],
                "code": "```vector<int>ioc```\n```ioc```\n```ioc```\n```left=0```\n```right=0```\n```ioc```\n```ioc[right]```\n```left = right```\n```right=right+1```\n```ans[i]```\n``` abs(ioc[right]-i)```\n``` abs(ioc[left]-i)```\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ioc; // vector for storing the indexed of c present in s\\n        int n=s.length();\\n        \\n        vector<int>ans(n); // answer vector\\n        \\n        for(int i=0;i<n;++i){\\n            if(s[i]==c) \\n                ioc.push_back(i);\\n        }\\n        \\n        int m=ioc.size(); // size of ioc vector\\n        int left=0,right=0;\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            // if current index has crossed ioc[right] then,\\n            // we need to make the current left to right and \\n            // increment current right for pointing to next index of ioc vector ( if exists )\\n            if(i>ioc[right]){\\n                left=right;\\n                if(right<m-1)\\n                    ++right;\\n            }\\n                        \\n            // difference = min(abs(right nearest \\'c\\' - curr index),abs(left nearest \\'c\\' - curr index))\\n            ans[i]=min(abs(ioc[right]-i),abs(ioc[left]-i)); \\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054301,
                "title": "python-o-n-solution-explained",
                "content": "What we need to do in this problem is to iterate our data two times: one time from left to right and second time from right to left. Let us use auxilary function `letter_get(letter, dr)`, where `dr` is direction: `+1` for left->right traversal and `-1` for right -> left traversal.\\n\\nHow this function will work? We initialize it with zeroes first and we keep `cur` value, which represents the last place where we meet symbol `letter`. We traverse string, check each symbol and if it is equal to `letter`, we update `cur` place. We put `abs(i - cur)` to result: this is distance between current place and last place where we meet symbol `letter`.\\n\\nFinally, we apply our function twice for two directions and choose the smallest distance. Note also that we initialized `curr = -n`, because in this case we will have distances `>=n` for symbols for places, where we do not have elements equal to `letter` before, and this value is bigger than all possible values in answer, so it works as infinity here.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(n)` as well.\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        def letter_get(letter, dr):\\n            n = len(S)\\n            res, cur = [0]*n, -n\\n            for i in range(n)[::dr]:\\n                if S[i] == letter: cur = i\\n                res[i] = abs(i - cur)\\n            return res\\n        \\n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        def letter_get(letter, dr):\\n            n = len(S)\\n            res, cur = [0]*n, -n\\n            for i in range(n)[::dr]:\\n                if S[i] == letter: cur = i\\n                res[i] = abs(i - cur)\\n            return res\\n        \\n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054366,
                "title": "javascript-2-pass-simple-solution-with-explanation",
                "content": "The problem becomes really simple if we consider the example.\\n```js\\n0 1 2 3 4 5 6 7 8 9 10 11\\nl o v e l e e t c o d  e\\n```\\nWhat is the shortest distance for index `9` if the character is `e`?\\nThe closest `e` from the left side has the index `6`.\\n`9 - 6 = 3`\\nThe closest `e` from the right side has the index `11`.\\n`11 - 9 = 2`\\nThe minimum distance between them is 2, so the answer is 2. Can we do it for any index?\\nYes we can, all we need to do is to keep track of the previous character index while iterating from the left to the right and vice versa. The only edge case here is that initially we could possibly don\\'t have a previous index, so to mitigate it for such indecies we can put the shortest distance for them as Infinity and once we complete 2 passes at least one non-Infinity value for each index should exist.\\nLet\\'s consider the example again.\\n```js\\ncharacter = \"e\"\\n\\nindex  | 0 1 2 3 4 5 6 7 8 9 10 11\\nchar   | l o v e l e e t c o d  e\\n// shortest distance from left to right\\nl -> r | I I I 0 1 0 0 1 2 3 4  0 // I = Infinity\\n// shortest distance from right to left\\nl <- r | 3 2 1 0 1 0 0 4 3 2 1  0\\n// the minimum between them is the answer\\nresult | 3 2 1 0 1 0 0 1 2 2 1  0\\n```\\n\\n```js\\nvar shortestToChar = function(s, c) {\\n    let n = s.length;\\n    let res = [];\\n        \\n    let prev = Infinity;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) prev = i;\\n        res[i] = Math.abs(prev - i);\\n    }\\n\\n    prev = Infinity;\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n      if (s[i] === c) prev = i;\\n      res[i] = Math.min(res[i], prev - i);\\n    }\\n\\n    return res;\\n}\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n0 1 2 3 4 5 6 7 8 9 10 11\\nl o v e l e e t c o d  e\\n```\n```js\\ncharacter = \"e\"\\n\\nindex  | 0 1 2 3 4 5 6 7 8 9 10 11\\nchar   | l o v e l e e t c o d  e\\n// shortest distance from left to right\\nl -> r | I I I 0 1 0 0 1 2 3 4  0 // I = Infinity\\n// shortest distance from right to left\\nl <- r | 3 2 1 0 1 0 0 4 3 2 1  0\\n// the minimum between them is the answer\\nresult | 3 2 1 0 1 0 0 1 2 2 1  0\\n```\n```js\\nvar shortestToChar = function(s, c) {\\n    let n = s.length;\\n    let res = [];\\n        \\n    let prev = Infinity;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) prev = i;\\n        res[i] = Math.abs(prev - i);\\n    }\\n\\n    prev = Infinity;\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n      if (s[i] === c) prev = i;\\n      res[i] = Math.min(res[i], prev - i);\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2173687,
                "title": "c-solution-simple-easy-understanding",
                "content": "**Explanation:**\\n* create two vectors :- `position` and `answer`.\\n* Traverse the string and collect all the position of given char using the `position` vector.\\n* Now traverse the string and find the shortest distance from the given char to all given positions.\\n* Keep pushing the distance to the `answer` vector and at last return it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> position;\\n        vector<int> answer;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==c)\\n                position.push_back(i);\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            int shortest_dist = INT_MAX;\\n            for(int j=0; j<position.size(); j++)\\n            {\\n                shortest_dist = min(shortest_dist, abs(i-position[j]));\\n            }\\n            answer.push_back(shortest_dist);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> position;\\n        vector<int> answer;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==c)\\n                position.push_back(i);\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            int shortest_dist = INT_MAX;\\n            for(int j=0; j<position.size(); j++)\\n            {\\n                shortest_dist = min(shortest_dist, abs(i-position[j]));\\n            }\\n            answer.push_back(shortest_dist);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054179,
                "title": "c-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> res;\\n        int prev_char = -s.size();\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res.push_back(i - prev_char);\\n        }\\n\\n        for (int i = prev_char; i >= 0; i--) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res[i] = min(res[i], prev_char - i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> res;\\n        int prev_char = -s.size();\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res.push_back(i - prev_char);\\n        }\\n\\n        for (int i = prev_char; i >= 0; i--) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res[i] = min(res[i], prev_char - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527161,
                "title": "python-o-n-by-propagation-85-w-diagram",
                "content": "Python O(n) by propagation\\n\\n---\\n\\n**Hint**:\\n\\nImagine parameter C as a flag on the line.\\n\\nThink of propagation technique:\\n**1st-pass** iteration **propagates distance** from C on the **left hand side**\\n**2nd-pass** iteration **propagates distance** from C on the **right hand side** with min( 1st-pass result, 2nd-pass propagation distance ) in order to update with shortest path.\\n\\n---\\n\\n**Abstract Model**:\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583205184.png)\\n\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        shortest_dist = []\\n        size = len(S)\\n        \\n        if size == 1:\\n            # Quick response for single character test case\\n            # Description guarantee that character C must exist in string S\\n            return [0]\\n        \\n        \\n        # Propagate distance from left to right\\n        for idx, char in enumerate(S):\\n            \\n            if char == C:\\n                shortest_dist.append(0)\\n            else:\\n                if idx == 0:\\n                    shortest_dist.append( size )\\n                else:\\n                    # Propagate distance from C on left hand side\\n                    shortest_dist.append( shortest_dist[-1] + 1)\\n                \\n                \\n                \\n        # Propagate distance from right to left               \\n        for idx in range(2, size+1):\\n            \\n            # Propagate distance from C on right hand side\\n            shortest_dist[-idx] = min(shortest_dist[-idx], shortest_dist[-idx+1]+1 )\\n\\n                \\n        return shortest_dist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        shortest_dist = []\\n        size = len(S)\\n        \\n        if size == 1:\\n            # Quick response for single character test case\\n            # Description guarantee that character C must exist in string S\\n            return [0]\\n        \\n        \\n        # Propagate distance from left to right\\n        for idx, char in enumerate(S):\\n            \\n            if char == C:\\n                shortest_dist.append(0)\\n            else:\\n                if idx == 0:\\n                    shortest_dist.append( size )\\n                else:\\n                    # Propagate distance from C on left hand side\\n                    shortest_dist.append( shortest_dist[-1] + 1)\\n                \\n                \\n                \\n        # Propagate distance from right to left               \\n        for idx in range(2, size+1):\\n            \\n            # Propagate distance from C on right hand side\\n            shortest_dist[-idx] = min(shortest_dist[-idx], shortest_dist[-idx+1]+1 )\\n\\n                \\n        return shortest_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854034,
                "title": "python-99-92-faster-two-pointers-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        a,n=[],len(s)\\n        for i in range(n):\\n            if s[i]==c:\\n                a.append(i)\\n        answer=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                answer.append(0)\\n                j+=1\\n            elif i<a[0]:\\n                answer.append(a[0]-i)\\n            elif i>a[-1]:\\n                answer.append(i-a[-1])\\n            else:\\n                answer.append(min((a[j]-i),(i-a[j-1])))\\n        return answer\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        a,n=[],len(s)\\n        for i in range(n):\\n            if s[i]==c:\\n                a.append(i)\\n        answer=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                answer.append(0)\\n                j+=1\\n            elif i<a[0]:\\n                answer.append(a[0]-i)\\n            elif i>a[-1]:\\n                answer.append(i-a[-1])\\n            else:\\n                answer.append(min((a[j]-i),(i-a[j-1])))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343839,
                "title": "java-98-100",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        char[] arrS=S.toCharArray(); \\n        int[] dist=new int[arrS.length];\\n        int disToL=S.length(), disToR=S.length(); \\n        \\n        for(int i=0;i<arrS.length;i++){ //pass 1, determine distance to nearest C on the left \\n            if(arrS[i]==C)\\n                disToL=0;\\n            dist[i]=disToL;\\n            disToL++;\\n        }\\n        \\n        for(int i=arrS.length-1;i>=0;i--){ //pass 2, determine distance to nearest C on the right, compare with previous pass and take minimum \\n            if(arrS[i]==C)\\n                disToR=0;\\n            dist[i]=Math.min(dist[i],disToR);\\n            disToR++;\\n        }\\n        \\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        char[] arrS=S.toCharArray(); \\n        int[] dist=new int[arrS.length];\\n        int disToL=S.length(), disToR=S.length(); \\n        \\n        for(int i=0;i<arrS.length;i++){ //pass 1, determine distance to nearest C on the left \\n            if(arrS[i]==C)\\n                disToL=0;\\n            dist[i]=disToL;\\n            disToL++;\\n        }\\n        \\n        for(int i=arrS.length-1;i>=0;i--){ //pass 2, determine distance to nearest C on the right, compare with previous pass and take minimum \\n            if(arrS[i]==C)\\n                disToR=0;\\n            dist[i]=Math.min(dist[i],disToR);\\n            disToR++;\\n        }\\n        \\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131816,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        c = []\\n        for i, v in enumerate(S):\\n            if v == C:\\n                c.append(i)\\n\\n        r = []\\n        for i in range(len(S)):\\n            r.append(min([abs(t - i)for t in c]))\\n        return r\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        c = []\\n        for i, v in enumerate(S):\\n            if v == C:\\n                c.append(i)\\n\\n        r = []\\n        for i in range(len(S)):\\n            r.append(min([abs(t - i)for t in c]))\\n        return r\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125850,
                "title": "java-single-pass-with-trailing-pointer-concise",
                "content": "Idea is exactly the same as other solutions using stack or two pointers. Keep track of the last seen target character C as well as a left pointer pointing to the last non C character. \\n\\nIf you hit a nonC character and have not seen any C yet, max out that value.\\n\\nIf you hit a nonC character and have seen a C, the current distance to C is the current position i minus the index of the last seen C.\\n\\nIf you hit a C, update all entries from the left pointer up until the current index with the correct value. This is the minimum between the distance to the current C and the previous distance to another C. Finally, update the last seen C index to the current index.\\n\\n```\\n    public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n        \\n        int lastC = -1;\\n        int lastNonC = 0;\\n        \\n        for(int i = 0; i<S.length(); i++)\\n            if(S.charAt(i) == C){\\n                while(lastNonC<=i)\\n                    result[lastNonC] = Math.min(result[lastNonC], i-lastNonC++);\\n                lastC = i;\\n            }else\\n                result[i] = lastC != -1 ? i-lastC : Integer.MAX_VALUE;\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n        \\n        int lastC = -1;\\n        int lastNonC = 0;\\n        \\n        for(int i = 0; i<S.length(); i++)\\n            if(S.charAt(i) == C){\\n                while(lastNonC<=i)\\n                    result[lastNonC] = Math.min(result[lastNonC], i-lastNonC++);\\n                lastC = i;\\n            }else\\n                result[i] = lastC != -1 ? i-lastC : Integer.MAX_VALUE;\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055960,
                "title": "intuition-leads-to-approach-java-optimize-intuition-to-get-effective-solution",
                "content": "**Intuition:**\\n**Simple intuition**: \\n\\n* Suppose the answer is stored ans array.\\n* ans[i] is minimum of distances from all the positions of character C in string S\\nEx : Input: s = \"loveleetcode\", c = \"e\"\\nIndices of e = {3, 5, 6, 12}\\n* To get the shortest distance, we need to check the nearest from both sides.\\n* Run 2 loops from both end, updating the min value.\\n\\n**Solution**:\\n* We have to traverse the array two times, one from left to right & right to left.\\n\\n**Time Complexity**: Forward loop & Backward Loop : O(N) + O(N) ~ O(N)\\n**Space Complexity**: Without considering answer array : O(1) \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\n**Intuition 2**: \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int[] ans = new int[len];\\n        Arrays.fill(ans, len + 1);\\n        int j;\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                ans[i] = 0;\\n                j = i - 1;\\n                //fill reverse \\n                while(j >= 0 && ans[j] > i - j){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n                //fill forward\\n                j = i + 1;\\n                while( j < len && s.charAt(j) != c){\\n                    ans[j] = j - i;\\n                    j++;\\n                }\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Optimization**: \\nWhile traversing the string, \\n* ans[i] = 0 for all i where s.charAt(i) == c\\n* start filling from the index of character to both ends.\\n1. For forward: start filling {1, 2, 3... } from j = i+1 till we reach to another c or end of the string.\\n2. For backward : From j = i -1 till we reach to another c or start of the string.\\n\\t\\t\\t\\t\\t\\t\\tFill minimum of ans[j] &  i - j (distance of j from i).\\n* If at any point if ans[j] is less than & equal to i-j, for all the elements before jth index i-j is greater than ans[j]\\n\\n**Solution**:\\n* We have to traverse the array from one end, if there is a character c, update in backward too.\\n\\n**Time Complexity**: Forward loop & Backward Loop : O(N) + O(N/2) ~ O(N) where N is number of string.\\n**Space Complexity**: Without considering answer array : O(1) \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int N = s.length();\\n        int[] ans = new int[N];\\n        int prev = N + 1, j;\\n        for (int i = 0; i < N; ++i) {\\n            if (s.charAt(i) == c) {\\n                ans[i] = 0;\\n                prev = 1;\\n                j = i-1;\\n                while( j >= 0 && ans[j] > i - j ){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n            }\\n            else\\n                ans[i] = prev++;\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int[] ans = new int[len];\\n        Arrays.fill(ans, len + 1);\\n        int j;\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                ans[i] = 0;\\n                j = i - 1;\\n                //fill reverse \\n                while(j >= 0 && ans[j] > i - j){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n                //fill forward\\n                j = i + 1;\\n                while( j < len && s.charAt(j) != c){\\n                    ans[j] = j - i;\\n                    j++;\\n                }\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int N = s.length();\\n        int[] ans = new int[N];\\n        int prev = N + 1, j;\\n        for (int i = 0; i < N; ++i) {\\n            if (s.charAt(i) == c) {\\n                ans[i] = 0;\\n                prev = 1;\\n                j = i-1;\\n                while( j >= 0 && ans[j] > i - j ){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n            }\\n            else\\n                ans[i] = prev++;\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264608,
                "title": "c-basic-easy-implementaion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>out;\\n        vector<int>pos;\\n        \\n        //collect all the position of given char\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n                pos.push_back(i);\\n        }\\n        \\n        //traversal and find the min diffrence from the given char to all given pos\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int min_dis=INT_MAX;\\n            for(int j=0;j<pos.size();j++)\\n            {\\n                min_dis=min(min_dis,abs(i-pos[j]));\\n            }\\n            out.push_back(min_dis);\\n        }\\n        return out;\\n        \\n    }\\n};\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>out;\\n        vector<int>pos;\\n        \\n        //collect all the position of given char\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n                pos.push_back(i);\\n        }\\n        \\n        //traversal and find the min diffrence from the given char to all given pos\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int min_dis=INT_MAX;\\n            for(int j=0;j<pos.size();j++)\\n            {\\n                min_dis=min(min_dis,abs(i-pos[j]));\\n            }\\n            out.push_back(min_dis);\\n        }\\n        return out;\\n        \\n    }\\n};\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965854,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1054376,
                "title": "java-2-solutions-self-explained-easy-to-read-2-iterations",
                "content": "1- Using DP\\n* going from left to right, at each position i ans[i] = ans[i-1] + 1\\n* going from right to left, at each position i ans[i] = ans[i+1] + 1\\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, n);\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if(i > 0) ans[i] = Math.min(ans[i], ans[i-1] + 1);\\n        }\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if (i < n-1) ans[i] = Math.min(ans[i], ans[i+1] + 1);\\n        }\\n        return ans;\\n}\\n```\\n\\n2- keep track of last appearance of C\\n* pos = last appearance of c\\n* going from left to right, dist[i] = i - pos\\n* going from right to left, dist[i] = pos - i\\n\\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int pos = -n;\\n        int[] ans = new int[n];\\n\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n\\n        pos = 2*n;\\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = Math.min(ans[i], pos - i);\\n        }\\n\\n        return ans;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, n);\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if(i > 0) ans[i] = Math.min(ans[i], ans[i-1] + 1);\\n        }\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if (i < n-1) ans[i] = Math.min(ans[i], ans[i+1] + 1);\\n        }\\n        return ans;\\n}\\n```\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int pos = -n;\\n        int[] ans = new int[n];\\n\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n\\n        pos = 2*n;\\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = Math.min(ans[i], pos - i);\\n        }\\n\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054157,
                "title": "javascript-simple-1-pass-beats-100",
                "content": "```javascript\\nvar shortestToChar = function(s, c) {\\n    const answer = Array(s.length).fill(Infinity);\\n    let l = Infinity, r = Infinity;\\n    \\n    for(let f = 0; f < s.length; f++) {\\n        const b = s.length-1-f;\\n        \\n        l = s[f] === c ? 0 : l+1;\\n        r = s[b] === c ? 0 : r+1;\\n        \\n        answer[f] = Math.min(answer[f], l);\\n        answer[b] = Math.min(answer[b], r);\\n    }\\n    return answer;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar shortestToChar = function(s, c) {\\n    const answer = Array(s.length).fill(Infinity);\\n    let l = Infinity, r = Infinity;\\n    \\n    for(let f = 0; f < s.length; f++) {\\n        const b = s.length-1-f;\\n        \\n        l = s[f] === c ? 0 : l+1;\\n        r = s[b] === c ? 0 : r+1;\\n        \\n        answer[f] = Math.min(answer[f], l);\\n        answer[b] = Math.min(answer[b], r);\\n    }\\n    return answer;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2170593,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>position;\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                position.push_back(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){ \\n        int mn=INT_MAX;\\n        for(int j=0;j<position.size();j++){\\n            mn=min(mn,abs(i-position[j]));\\n        }\\n             ans.push_back(mn);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>position;\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                position.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 514955,
                "title": "javascript-solution-with-comments",
                "content": "> Runtime: **92 ms**, faster than *51.38%* of JavaScript online submissions\\n> Memory Usage: **40.8 MB**, less than *58.84%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nconst shortestToChar = (s, c) => {\\n  // Create an array to hold the distances the same length as the string\\n  // And fill it with `Infinity` because `Math.min` gets used below\\n  // But filling with `s.length` or `104` (from Constraints) would also work.\\n  const res = new Array(s.length).fill(Infinity);\\n  for (\\n    // Create some variables to use while looping through the string\\n    // - `li` Left Index: Traverse the string from left to right\\n    // - `ld` Left Distance: Reset to `0` every time `c` is seen in the string\\n    // - `ri` Right Index: Traverse the string from right to left\\n    // - `rd` Right Distance: Reset to `0` every time `c` is seen in the string\\n    let li = 0, ld = Infinity, ri = s.length - 1, rd = Infinity;\\n    // Stop the loop before the Left Index goes off the right end of the string\\n    // This also stops the loop before the Right Index goes off the left end\\n    li < s.length;\\n    // After every iteration:\\n    // - The left index moves `1` place to the left\\n    // - The left distance increases by `1`\\n    // - The right index moves `1` place to the right\\n    // - The right distance increases by `1`\\n    li++, ld++, ri--, rd++\\n  ) {\\n    // If the character at the left index is the character we\\'re looking for,\\n    // reset the left distance to `0`\\n    if (s[li] === c) ld = 0;\\n    // As we move left, set the `res` array value to the lesser distance:\\n    // - `res[li]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Right Distance to the sought character\\n    // - `ld` Distance to the sought character looking left\\n    res[li] = Math.min(res[li], ld);\\n    // If the character at the right index is the character we\\'re looking for,\\n    // reset the right distance to `0`\\n    if (s[ri] === c) rd = 0;\\n    // As we move right, set the `res` array value to the lesser distance:\\n    // - `res[ri]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Left Distance to the sought character\\n    // - `rd` Distance to the sought character looking right\\n    res[ri] = Math.min(res[ri], rd);\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nconst shortestToChar = (s, c) => {\\n  // Create an array to hold the distances the same length as the string\\n  // And fill it with `Infinity` because `Math.min` gets used below\\n  // But filling with `s.length` or `104` (from Constraints) would also work.\\n  const res = new Array(s.length).fill(Infinity);\\n  for (\\n    // Create some variables to use while looping through the string\\n    // - `li` Left Index: Traverse the string from left to right\\n    // - `ld` Left Distance: Reset to `0` every time `c` is seen in the string\\n    // - `ri` Right Index: Traverse the string from right to left\\n    // - `rd` Right Distance: Reset to `0` every time `c` is seen in the string\\n    let li = 0, ld = Infinity, ri = s.length - 1, rd = Infinity;\\n    // Stop the loop before the Left Index goes off the right end of the string\\n    // This also stops the loop before the Right Index goes off the left end\\n    li < s.length;\\n    // After every iteration:\\n    // - The left index moves `1` place to the left\\n    // - The left distance increases by `1`\\n    // - The right index moves `1` place to the right\\n    // - The right distance increases by `1`\\n    li++, ld++, ri--, rd++\\n  ) {\\n    // If the character at the left index is the character we\\'re looking for,\\n    // reset the left distance to `0`\\n    if (s[li] === c) ld = 0;\\n    // As we move left, set the `res` array value to the lesser distance:\\n    // - `res[li]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Right Distance to the sought character\\n    // - `ld` Distance to the sought character looking left\\n    res[li] = Math.min(res[li], ld);\\n    // If the character at the right index is the character we\\'re looking for,\\n    // reset the right distance to `0`\\n    if (s[ri] === c) rd = 0;\\n    // As we move right, set the `res` array value to the lesser distance:\\n    // - `res[ri]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Left Distance to the sought character\\n    // - `rd` Distance to the sought character looking right\\n    res[ri] = Math.min(res[ri], rd);\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511187,
                "title": "javascript-2-passes",
                "content": "```\\nvar shortestToChar = function(S, C) {\\n    const dp = new Array(S.length).fill(Infinity);\\n    \\n    dp[0] = S[0] === C ? 0 : Infinity\\n    \\n    for(let i = 1; i < S.length; i++) {\\n        if(S[i] === C) {\\n            dp[i] = 0;\\n        } else {\\n            dp[i] = dp[i-1] === Infinity ? Infinity : dp[i-1] + 1;\\n        }\\n    }\\n\\n    let dist = Infinity;\\n    \\n    for(let i = S.length-1; i >= 0; i--) {\\n        if(S[i] === C) {\\n            dist = 0;\\n        }\\n        dp[i] = Math.min(dist, dp[i]);\\n        dist += 1;\\n    }\\n    \\n    return dp;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    const dp = new Array(S.length).fill(Infinity);\\n    \\n    dp[0] = S[0] === C ? 0 : Infinity\\n    \\n    for(let i = 1; i < S.length; i++) {\\n        if(S[i] === C) {\\n            dp[i] = 0;\\n        } else {\\n            dp[i] = dp[i-1] === Infinity ? Infinity : dp[i-1] + 1;\\n        }\\n    }\\n\\n    let dist = Infinity;\\n    \\n    for(let i = S.length-1; i >= 0; i--) {\\n        if(S[i] === C) {\\n            dist = 0;\\n        }\\n        dp[i] = Math.min(dist, dp[i]);\\n        dist += 1;\\n    }\\n    \\n    return dp;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300191,
                "title": "java-do-check-out-for-explanation-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n\\nThe idea is to find the minimum char say c index from right for all position.\\nAnd again find the minimum char say c index from left for all position.\\nNow, whichever (left or right) gives you the minimum that is the minimum distance for char c for that position.\\n\\n```\\nclass Solution {\\n   \\n    public int[] shortestToChar(String s, char c) {\\n    \\n        int[] ans = new int[s.length()];\\n        int index = 0;\\n        \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.abs(i - index);\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.min(ans[i], Math.abs(i - index));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\n    public int[] shortestToChar(String s, char c) {\\n    \\n        int[] ans = new int[s.length()];\\n        int index = 0;\\n        \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.abs(i - index);\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.min(ans[i], Math.abs(i - index));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226696,
                "title": "python3-any-improvement",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        L = []\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                L.append(idx)\\n        \\n        distance = []\\n        i = 0\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                distance.append(0)\\n                i += 1\\n            elif idx < L[0]:\\n                distance.append(L[0] - idx)\\n            elif idx > L[-1]:\\n                distance.append(idx - L[-1])\\n            else:\\n                distance.append(min((L[i] - idx), (idx - L[i-1])))                    \\n        return distance\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        L = []\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                L.append(idx)\\n        \\n        distance = []\\n        i = 0\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                distance.append(0)\\n                i += 1\\n            elif idx < L[0]:\\n                distance.append(L[0] - idx)\\n            elif idx > L[-1]:\\n                distance.append(idx - L[-1])\\n            else:\\n                distance.append(min((L[i] - idx), (idx - L[i-1])))                    \\n        return distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090998,
                "title": "2-line-python-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        ids = [i for i in range(len(s)) if s[i] == c]\\n        return [min([abs(i-id_) for id_ in ids]) for i in range(len(s))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        ids = [i for i in range(len(s)) if s[i] == c]\\n        return [min([abs(i-id_) for id_ in ids]) for i in range(len(s))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055497,
                "title": "c-two-pass-easy-to-understand-solution",
                "content": "**Approach 1 : Using BFS for shortest distance** \\n\\tTime Complexity - O(n)\\n\\tSpace Complexity - O(n) \\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        queue<vector<int> > q;\\n        for(int i=0;i<len;i++)\\n            if(s[i]==c){\\n                q.push({i,0});\\n                ans[i]=0;\\n            }\\n        while(!q.empty()){\\n            int qsize=q.size();\\n            while(qsize--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                if(v[0]+1<len && ans[v[0]+1]==INT_MAX){\\n                    q.push({v[0]+1,v[1]+1});\\n                    ans[v[0]+1]=v[1]+1;\\n                } \\n                if(v[0]>0 && ans[v[0]-1]==INT_MAX){\\n                    q.push({v[0]-1,v[1]+1});\\n                    ans[v[0]-1]=v[1]+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Approach 2 :  Without extra space , two traversals -one from start , another from end**\\n\\tTime Complexity - O(n)\\n\\tSpace Complexity - O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        int pos_c=len*(-1);\\n        for(int i=0;i<len;i++){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],i-pos_c);\\n        }\\n        pos_c=2*len;\\n        for(int i=len-1;i>=0;i--){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],pos_c-i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHave doubts , please let me know in comments.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        queue<vector<int> > q;\\n        for(int i=0;i<len;i++)\\n            if(s[i]==c){\\n                q.push({i,0});\\n                ans[i]=0;\\n            }\\n        while(!q.empty()){\\n            int qsize=q.size();\\n            while(qsize--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                if(v[0]+1<len && ans[v[0]+1]==INT_MAX){\\n                    q.push({v[0]+1,v[1]+1});\\n                    ans[v[0]+1]=v[1]+1;\\n                } \\n                if(v[0]>0 && ans[v[0]-1]==INT_MAX){\\n                    q.push({v[0]-1,v[1]+1});\\n                    ans[v[0]-1]=v[1]+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        int pos_c=len*(-1);\\n        for(int i=0;i<len;i++){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],i-pos_c);\\n        }\\n        pos_c=2*len;\\n        for(int i=len-1;i>=0;i--){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],pos_c-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914650,
                "title": "python3-100-faster-100-less-memory-20ms-14mb",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        l = [0] * len(S)\\n        prev = None\\n        for i, x in enumerate(S):\\n            if x == C:\\n\\n\\t\\t\\t\\t# only correct the closer half of the indexes between previous and current if previous is not None\\n                start = 0 if prev is None else (i + prev) // 2 + 1\\n\\n\\t\\t\\t\\t# slice assign where corrections are needed to a range\\n                l[start:i + 1] = range(i - start, -1, -1)\\n\\n                prev = i\\n            elif prev is not None:\\n                l[i] = i - prev\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        l = [0] * len(S)\\n        prev = None\\n        for i, x in enumerate(S):\\n            if x == C:\\n\\n\\t\\t\\t\\t# only correct the closer half of the indexes between previous and current if previous is not None\\n                start = 0 if prev is None else (i + prev) // 2 + 1\\n\\n\\t\\t\\t\\t# slice assign where corrections are needed to a range\\n                l[start:i + 1] = range(i - start, -1, -1)\\n\\n                prev = i\\n            elif prev is not None:\\n                l[i] = i - prev\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596450,
                "title": "c-easiest-o-n-time-100-fastest",
                "content": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> v , ans;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            if(s[i] == c)\\n                v.push_back(i);\\n        }\\n        int j = 0;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            \\n            if(j == 0)\\n                ans.push_back(v[j] - i); \\n            else if(j >= v.size())\\n                ans.push_back(i - v[j - 1]);\\n            else\\n                ans.push_back(min(v[j] - i , i - v[j - 1]));\\n            if(s[i] == c)\\n                j++;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> v , ans;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            if(s[i] == c)\\n                v.push_back(i);\\n        }\\n        int j = 0;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            \\n            if(j == 0)\\n                ans.push_back(v[j] - i); \\n            else if(j >= v.size())\\n                ans.push_back(i - v[j - 1]);\\n            else\\n                ans.push_back(min(v[j] - i , i - v[j - 1]));\\n            if(s[i] == c)\\n                j++;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557360,
                "title": "easy-java-o-n-soution",
                "content": "```\\npublic static int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] arr = new int[n];\\n        int c_position = -n;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = i - c_position;\\n        }\\n\\n        for (int i = n-1; i >= 0; i--) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = Math.min(arr[i], Math.abs(i - c_position));\\n        }\\n        return arr;\\n    }\\n\\t\\n\\t// Please Up-Vote\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] arr = new int[n];\\n        int c_position = -n;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = i - c_position;\\n        }\\n\\n        for (int i = n-1; i >= 0; i--) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = Math.min(arr[i], Math.abs(i - c_position));\\n        }\\n        return arr;\\n    }\\n\\t\\n\\t// Please Up-Vote\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226939,
                "title": "easiest-python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # occurence of charachter in the array.\\n        occ = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                occ.append(i)\\n        ans = []\\n        for i in range(len(s)):\\n            #checking distance of each point from occurences ans the selecting the least distance. \\n            tmplst = []\\n            for j in occ:\\n                tmplst.append(abs(i-j))\\n            ans.append(min(tmplst))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # occurence of charachter in the array.\\n        occ = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                occ.append(i)\\n        ans = []\\n        for i in range(len(s)):\\n            #checking distance of each point from occurences ans the selecting the least distance. \\n            tmplst = []\\n            for j in occ:\\n                tmplst.append(abs(i-j))\\n            ans.append(min(tmplst))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007025,
                "title": "python-3-solution-brute-force-and-two-pointers-2-solutions",
                "content": "Brute Force:\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        req = []\\n        ind_list = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                ind_list.append(i)\\n        min_dis = len(s)\\n        for j in range(len(s)):\\n            for k in range(len(ind_list)):\\n                min_dis = min(min_dis, abs(j - ind_list[k]))\\n            req.append(min_dis)\\n            min_dis = len(s)\\n            \\n        return req\\n```\\n\\nTwo Pointers, O(n) Time and Space\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n#         Travelling front to back\\n        result = [\"*\"] * len(s)\\n        i, j = 0, 0\\n        while i < len(s) and j < len(s):\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i += 1\\n                j += 1\\n            elif s[i] != c and s[j] == c:\\n                result[i] = abs(i-j)\\n                i += 1\\n            elif s[i] != c and s[j] != c:\\n                j += 1\\n    \\n#         Travelling back to front\\n        i = j = len(s) - 1\\n        while i >= 0 and j >= 0:\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i -= 1\\n                j -= 1\\n            elif s[i] != c and s[j] == c:\\n                if type(result[i]) == int:\\n                    result[i] = min(result[i], abs(i-j))\\n                else:\\n                    result[i] = abs(i-j)\\n                i -= 1\\n            elif s[i] != c and s[j] != c:\\n                j -= 1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        req = []\\n        ind_list = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                ind_list.append(i)\\n        min_dis = len(s)\\n        for j in range(len(s)):\\n            for k in range(len(ind_list)):\\n                min_dis = min(min_dis, abs(j - ind_list[k]))\\n            req.append(min_dis)\\n            min_dis = len(s)\\n            \\n        return req\\n```\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n#         Travelling front to back\\n        result = [\"*\"] * len(s)\\n        i, j = 0, 0\\n        while i < len(s) and j < len(s):\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i += 1\\n                j += 1\\n            elif s[i] != c and s[j] == c:\\n                result[i] = abs(i-j)\\n                i += 1\\n            elif s[i] != c and s[j] != c:\\n                j += 1\\n    \\n#         Travelling back to front\\n        i = j = len(s) - 1\\n        while i >= 0 and j >= 0:\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i -= 1\\n                j -= 1\\n            elif s[i] != c and s[j] == c:\\n                if type(result[i]) == int:\\n                    result[i] = min(result[i], abs(i-j))\\n                else:\\n                    result[i] = abs(i-j)\\n                i -= 1\\n            elif s[i] != c and s[j] != c:\\n                j -= 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054414,
                "title": "java-2-pointer-o-n-1ms-beats-97",
                "content": "\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int ptr1 = Integer.MAX_VALUE;\\n        int ptr2 = Integer.MAX_VALUE;\\n        int index = -1;\\n        int l = s.length();\\n        int[] ans = new int[l];\\n        \\n        while(index<l-1){\\n            int temp = index+1;\\n            \\n            while(temp<l && s.charAt(temp)!=c)\\n                temp++;\\n            \\n            if(temp == l){\\n                temp = Integer.MAX_VALUE;\\n            }\\n            \\n            ptr2 = ptr1;\\n            ptr1 = temp;\\n            \\n            index++;\\n            while(index<l && index<=temp){\\n                ans[index] = Math.min(Math.abs(ptr1-index),Math.abs(ptr2-index));\\n                index++;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int ptr1 = Integer.MAX_VALUE;\\n        int ptr2 = Integer.MAX_VALUE;\\n        int index = -1;\\n        int l = s.length();\\n        int[] ans = new int[l];\\n        \\n        while(index<l-1){\\n            int temp = index+1;\\n            \\n            while(temp<l && s.charAt(temp)!=c)\\n                temp++;\\n            \\n            if(temp == l){\\n                temp = Integer.MAX_VALUE;\\n            }\\n            \\n            ptr2 = ptr1;\\n            ptr1 = temp;\\n            \\n            index++;\\n            while(index<l && index<=temp){\\n                ans[index] = Math.min(Math.abs(ptr1-index),Math.abs(ptr2-index));\\n                index++;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1054364,
                "title": "2-pass-but-different-and-intuitive-comments-included",
                "content": "```\\nimport kotlin.math.min\\n\\nclass Solution {\\n    fun shortestToChar(s: String, c: Char): IntArray {\\n\\t// tracks postitions of occurences of the character c in string s\\n        var positions = mutableListOf<Int>()\\n\\t\\t\\n        var ans = mutableListOf<Int>()\\n        \\n        for(i in 0..s.length-1){\\n            if(s[i]==c)\\n                positions.add(i)\\n        }\\n\\t\\t\\n\\t// cannot explain this xD\\n        positions.add(-1)\\n        \\n\\t// position of left occurence of c in s\\n        var left = -1\\n\\t\\t\\n\\t// position of right occurence of c in s\\n        var right = positions.removeAt(0)\\n\\t\\t\\n\\t// left distance\\n        var ld : Int\\n\\t\\t\\n\\t// right distance\\n        var rd : Int\\n        \\n        for(i in 0..s.length-1){\\n            ld = Int.MAX_VALUE\\n            rd = Int.MAX_VALUE\\n            if(left!=-1)\\n                ld = i-left\\n            if(right!=-1)\\n                rd = right-i\\n            ans.add(min(ld, rd))\\n            \\n            if(i==right){\\n                left = right\\n                right = positions.removeAt(0)\\n            }\\n        }\\n        \\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.min\\n\\nclass Solution {\\n    fun shortestToChar(s: String, c: Char): IntArray {\\n\\t// tracks postitions of occurences of the character c in string s\\n        var positions = mutableListOf<Int>()\\n\\t\\t\\n        var ans = mutableListOf<Int>()\\n        \\n        for(i in 0..s.length-1){\\n            if(s[i]==c)\\n                positions.add(i)\\n        }\\n\\t\\t\\n\\t// cannot explain this xD\\n        positions.add(-1)\\n        \\n\\t// position of left occurence of c in s\\n        var left = -1\\n\\t\\t\\n\\t// position of right occurence of c in s\\n        var right = positions.removeAt(0)\\n\\t\\t\\n\\t// left distance\\n        var ld : Int\\n\\t\\t\\n\\t// right distance\\n        var rd : Int\\n        \\n        for(i in 0..s.length-1){\\n            ld = Int.MAX_VALUE\\n            rd = Int.MAX_VALUE\\n            if(left!=-1)\\n                ld = i-left\\n            if(right!=-1)\\n                rd = right-i\\n            ans.add(min(ld, rd))\\n            \\n            if(i==right){\\n                left = right\\n                right = positions.removeAt(0)\\n            }\\n        }\\n        \\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054208,
                "title": "shortest-distance-to-a-character-simple-dp-solution-w-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nSince this problem is asking us to reference characters both ahead and behind the current charcter, this should bring to mind a two-pass **dynamic programming** solution. We can iterate through the input string (**S**) once and fill our answer array (**ans**) with the distance from the preceeding occurrence of **C**.\\n\\nThen we can iterate backwards through **S** again so that we can pick the best result between the value we obtained in the first pass with the distance from the preceeding **C** going the opposite direction.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 39.0MB** (beats 99% /100%).\\n```javascript\\nvar shortestToChar = function(S, C) {\\n    let len = S.length, ans = new Uint16Array(len)\\n    ans[0] = S.charAt(0) === C ? 0 : 10001\\n    for (let i = 1; i < len; i++) \\n        ans[i] = S.charAt(i) === C ? 0 : ans[i-1] + 1\\n    for (let i = len - 2; ~i; i--)\\n        ans[i] = Math.min(ans[i], ans[i+1] + 1)\\n    return ans\\n};\\n```\\n\\n---\\n\\n***Python3 Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 99% / 86%).\\n```python\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        ans = []\\n        ans.append(0 if S[0] == C else 10001)\\n        for i in range(1,len(S)):\\n            ans.append(0 if S[i] == C else ans[i-1] + 1)\\n        for i in range(len(S)-2,-1,-1):\\n            ans[i] = min(ans[i], ans[i+1] + 1)\\n        return ans\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.8MB** (beats 97% / 93%).\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int len = S.length();\\n        int[] ans = new int[len];\\n        ans[0] = S.charAt(0) == C ? 0 : 10001;\\n        for (int i = 1; i < len; i++) \\n            ans[i] = S.charAt(i) == C ? 0 : ans[i-1] + 1;\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = Math.min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **0ms /6.5MB** (beats 100% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length();\\n        std::vector<int> ans;\\n        ans.push_back(S[0] == C ? 0 : 10001);\\n        for (int i = 1; i < len; i++) \\n            ans.push_back(S[i] == C ? 0 : ans[i-1] + 1);\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar shortestToChar = function(S, C) {\\n    let len = S.length, ans = new Uint16Array(len)\\n    ans[0] = S.charAt(0) === C ? 0 : 10001\\n    for (let i = 1; i < len; i++) \\n        ans[i] = S.charAt(i) === C ? 0 : ans[i-1] + 1\\n    for (let i = len - 2; ~i; i--)\\n        ans[i] = Math.min(ans[i], ans[i+1] + 1)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        ans = []\\n        ans.append(0 if S[0] == C else 10001)\\n        for i in range(1,len(S)):\\n            ans.append(0 if S[i] == C else ans[i-1] + 1)\\n        for i in range(len(S)-2,-1,-1):\\n            ans[i] = min(ans[i], ans[i+1] + 1)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int len = S.length();\\n        int[] ans = new int[len];\\n        ans[0] = S.charAt(0) == C ? 0 : 10001;\\n        for (int i = 1; i < len; i++) \\n            ans[i] = S.charAt(i) == C ? 0 : ans[i-1] + 1;\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = Math.min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length();\\n        std::vector<int> ans;\\n        ans.push_back(S[0] == C ? 0 : 10001);\\n        for (int i = 1; i < len; i++) \\n            ans.push_back(S[i] == C ? 0 : ans[i-1] + 1);\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054175,
                "title": "c-o-n-simple-easy-understanding-cool-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> shortestToChar(string s, char c) {\\n\\t\\t\\tint n = s.size(), lastC = -n, i = 0;\\n\\t\\t\\tvector<int> ans (n, n);\\n\\t\\t\\tfor (; i < n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = i - lastC;\\n\\t\\t\\t}\\n\\t\\t\\tfor (i = lastC; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = min(ans[i], lastC - i);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> shortestToChar(string s, char c) {\\n\\t\\t\\tint n = s.size(), lastC = -n, i = 0;\\n\\t\\t\\tvector<int> ans (n, n);\\n\\t\\t\\tfor (; i < n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = i - lastC;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 687583,
                "title": "java-two-pointers-one-pass-time-o-n-optimal-faster-than-98-5",
                "content": "Approach:\\n\\nMaintain two pointers (one for the current character in S (sIndex) and the other (cIndex) to track the next occurence of C in S). Also have another variable to hold the previous occurence of C in S (prevCIndex) which is initially set to -1.\\n\\nFirstly, as it\\'s guaranteed to have at least one C in S, find the first occurence of C in S by incrementing C pointer (cIndex). Now, until the S pointer (sIndex) reaches C pointer (cIndex), calculate the shortest distance which is (cIndex - sIndex). Remember at this stage there is no previous occurrence of C in S. Therefore, `result[i] = cIndex - sIndex;`\\n\\nMoving on, there are two cases: \\n1) You might\\'ve a next of occurrence of C in S\\n2) You might not have any more occurrences of C (in the case which cIndex is beyond String length). \\n\\nIn the former, you get the minimum of the previous C Index and the current C Index to the current character in S (`Math.min(cIndex - sIndex, sIndex - prevCIndex)`)\\n& in the latter you just calculate the distance from the previous C Index to the current character in S (`sIndex - prevCIndex`).\\n\\nRefer to the below code for better understanding.\\n\\n```\\n   public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n\\n\\t\\t// Pointers to track C in S & the current moving index in S respectively\\n\\t\\tint cIndex = 0, sIndex = 0;\\n\\n\\t\\t// Pointer to track the previous occurrence of C in S - Initially set to -1\\n\\t\\tint prevCIndex = -1;\\n\\n\\t\\twhile (cIndex < S.length()) {\\n\\t\\t\\t// Find the first/next occurrence of C in S\\n\\t\\t\\twhile (cIndex < S.length() && S.charAt(cIndex) != C) {\\n\\t\\t\\t\\tcIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move the S pointer until C and fill the result with the shortest distance\\n\\t\\t\\twhile (sIndex < cIndex) {\\n\\t\\t\\t\\tif (prevCIndex == -1) {\\n\\t\\t\\t\\t\\t// Initial stage where there is no previous occurrence of C in S yet\\n\\t\\t\\t\\t\\tresult[sIndex] = cIndex - sIndex;\\n\\t\\t\\t\\t} else if (cIndex < S.length() && S.charAt(cIndex) == C) {\\n\\t\\t\\t\\t\\t// You have both previous and the next occurrences of C in S - Get the minimum\\n\\t\\t\\t\\t\\tresult[sIndex] = Math.min(cIndex - sIndex, sIndex - prevCIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Last stage where you crossed the last occurrence of C in S\\n\\t\\t\\t\\t\\tresult[sIndex] = sIndex - prevCIndex;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Increment the current pointer in S\\n\\t\\t\\t\\tsIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the current occurrence of C to previous\\n\\t\\t\\tprevCIndex = cIndex;\\n\\n\\t\\t\\t// Increment both the pointers\\n\\t\\t\\tsIndex++;\\n\\t\\t\\tcIndex++;\\n\\t\\t}\\n        \\n        return result;\\n    }\\n```\\n\\n\\nTime: O(n)\\nSpace: O(1) (Excluding the result array to be returned)",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n   public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n\\n\\t\\t// Pointers to track C in S & the current moving index in S respectively\\n\\t\\tint cIndex = 0, sIndex = 0;\\n\\n\\t\\t// Pointer to track the previous occurrence of C in S - Initially set to -1\\n\\t\\tint prevCIndex = -1;\\n\\n\\t\\twhile (cIndex < S.length()) {\\n\\t\\t\\t// Find the first/next occurrence of C in S\\n\\t\\t\\twhile (cIndex < S.length() && S.charAt(cIndex) != C) {\\n\\t\\t\\t\\tcIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move the S pointer until C and fill the result with the shortest distance\\n\\t\\t\\twhile (sIndex < cIndex) {\\n\\t\\t\\t\\tif (prevCIndex == -1) {\\n\\t\\t\\t\\t\\t// Initial stage where there is no previous occurrence of C in S yet\\n\\t\\t\\t\\t\\tresult[sIndex] = cIndex - sIndex;\\n\\t\\t\\t\\t} else if (cIndex < S.length() && S.charAt(cIndex) == C) {\\n\\t\\t\\t\\t\\t// You have both previous and the next occurrences of C in S - Get the minimum\\n\\t\\t\\t\\t\\tresult[sIndex] = Math.min(cIndex - sIndex, sIndex - prevCIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Last stage where you crossed the last occurrence of C in S\\n\\t\\t\\t\\t\\tresult[sIndex] = sIndex - prevCIndex;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Increment the current pointer in S\\n\\t\\t\\t\\tsIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the current occurrence of C to previous\\n\\t\\t\\tprevCIndex = cIndex;\\n\\n\\t\\t\\t// Increment both the pointers\\n\\t\\t\\tsIndex++;\\n\\t\\t\\tcIndex++;\\n\\t\\t}\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420683,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n     {\\n        vector<int>indexes;\\n        vector<int>sol;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n     {\\n        vector<int>indexes;\\n        vector<int>sol;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686262,
                "title": "java-easy-to-understand",
                "content": "# Happy Coding\\u270C\\uFE0F\\u270C\\uFE0F\\u270C\\uFE0F\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c)\\n    {\\n    int[] arr=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int left=i-1;\\n            int right=i+1;\\n            while(left>=0 || right <s.length())\\n            {\\n                if(s.charAt(i)==c)\\n                {\\n                    arr[i]=0;\\n                    break;\\n                }\\n                \\n                if(right < s.length() && s.charAt(right) == c)\\n                {\\n                    arr[i]=right-i;\\n                    break;\\n                }\\n                if( left >= 0 && s.charAt(left)== c)\\n                {\\n                    arr[i]=i-left;\\n                    break;\\n                }\\n                left--;\\n                right++;\\n            }\\n        }\\n         return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c)\\n    {\\n    int[] arr=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int left=i-1;\\n            int right=i+1;\\n            while(left>=0 || right <s.length())\\n            {\\n                if(s.charAt(i)==c)\\n                {\\n                    arr[i]=0;\\n                    break;\\n                }\\n                \\n                if(right < s.length() && s.charAt(right) == c)\\n                {\\n                    arr[i]=right-i;\\n                    break;\\n                }\\n                if( left >= 0 && s.charAt(left)== c)\\n                {\\n                    arr[i]=i-left;\\n                    break;\\n                }\\n                left--;\\n                right++;\\n            }\\n        }\\n         return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656937,
                "title": "java-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        char c1[] = s.toCharArray();\\n        for(int i = 0;i<c1.length;i++){\\n            if(c1[i] == c){\\n                list.add(i);\\n            }\\n        }\\n        int res[] = new int[c1.length];\\n        for(int i = 0;i<res.length;i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int p : list){\\n                min = Math.min(min, Math.abs(i-p));\\n            }\\n            res[i] = min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        char c1[] = s.toCharArray();\\n        for(int i = 0;i<c1.length;i++){\\n            if(c1[i] == c){\\n                list.add(i);\\n            }\\n        }\\n        int res[] = new int[c1.length];\\n        for(int i = 0;i<res.length;i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int p : list){\\n                min = Math.min(min, Math.abs(i-p));\\n            }\\n            res[i] = min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318807,
                "title": "simple-javascript-solution-faster-than-80-only-1-loop",
                "content": "You just push a 0 if the char is the c, and if not you calculate the min between the distance of the last 0 and the next c in the string using indexOf and lastIndexOf\\n\\n````\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    \\n    let result = []\\n    \\n    for(let i = 0; i< s.length ; i++) {\\n        \\n        if(s.charAt(i) === c) result.push(0)\\n        else {\\n            const next = s.indexOf(c,i) === -1 ? Infinity : s.indexOf(c,i) -i\\n            const prev = result.lastIndexOf(0) === -1 ? Infinity : i- result.lastIndexOf(0) \\n            result.push(Math.min(next,prev))\\n        }\\n        \\n    }\\n    \\n    return result\\n};\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    \\n    let result = []\\n    \\n    for(let i = 0; i< s.length ; i++) {\\n        \\n        if(s.charAt(i) === c) result.push(0)\\n        else {\\n            const next = s.indexOf(c,i) === -1 ? Infinity : s.indexOf(c,i) -i\\n            const prev = result.lastIndexOf(0) === -1 ? Infinity : i- result.lastIndexOf(0) \\n            result.push(Math.min(next,prev))\\n        }\\n        \\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541999,
                "title": "java-98-faster-only-one-loop-simple-efficient",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        \\n        for (int i = 0, j = 0; i < ans.length; i++) {\\n            if (i == 0) j = s.indexOf(c);\\n            if (i > j && s.indexOf(c, i) >= 0 && Math.abs(j-i) > Math.abs(s.indexOf(c, i)-i)) {\\n                j = s.indexOf(c, i);\\n            }\\n            ans[i] = Math.abs(j-i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        \\n        for (int i = 0, j = 0; i < ans.length; i++) {\\n            if (i == 0) j = s.indexOf(c);\\n            if (i > j && s.indexOf(c, i) >= 0 && Math.abs(j-i) > Math.abs(s.indexOf(c, i)-i)) {\\n                j = s.indexOf(c, i);\\n            }\\n            ans[i] = Math.abs(j-i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056605,
                "title": "c-o-n-easy-to-understand",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        int n=s.length();\\n        vector<int>ans(n,0);\\n        int lp=-999999;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=i-lp;\\n        }\\n        \\n        lp=INT_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=min(ans[i],lp-i);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Upvote if found helpful**",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        int n=s.length();\\n        vector<int>ans(n,0);\\n        int lp=-999999;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=i-lp;\\n        }\\n        \\n        lp=INT_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=min(ans[i],lp-i);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055763,
                "title": "python-shortest-distance-to-a-character-runtime-32ms-memory-usage-14-200-kb",
                "content": "\"\"\"\\n        implemented by me \\n        Noted: Time Complexity = 32ms O(n)\\n                Space Complexity = O(n)\\n        \"\"\"\\n\\n        dist = []\\n        c_ind = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                c_ind.append(i)\\n\\n        c_count = 0\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                dist.append(0)\\n                if c_count < len(c_ind)-1:\\n                    c_count += 1\\n            elif c_count == 0:\\n                dist.append(abs(c_ind[c_count]-i))\\n            elif abs(c_ind[c_count-1]-i) <= abs(c_ind[c_count]-i):\\n                dist.append(abs(c_ind[c_count-1]-i))\\n            else:\\n                dist.append(abs(c_ind[c_count]-i))\\n\\n        return dist",
                "solutionTags": [
                    "Python"
                ],
                "code": "\"\"\"\\n        implemented by me \\n        Noted: Time Complexity = 32ms O(n)\\n                Space Complexity = O(n)\\n        \"\"\"\\n\\n        dist = []\\n        c_ind = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                c_ind.append(i)\\n\\n        c_count = 0\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                dist.append(0)\\n                if c_count < len(c_ind)-1:\\n                    c_count += 1\\n            elif c_count == 0:\\n                dist.append(abs(c_ind[c_count]-i))\\n            elif abs(c_ind[c_count-1]-i) <= abs(c_ind[c_count]-i):\\n                dist.append(abs(c_ind[c_count-1]-i))\\n            else:\\n                dist.append(abs(c_ind[c_count]-i))\\n\\n        return dist",
                "codeTag": "Unknown"
            },
            {
                "id": 1055141,
                "title": "any-language-two-pass-o-n-0ms-very-easy-with-detailed-explanation-example-on-golang",
                "content": "How to find a minimal distance? We need to take into consideration only distance from closest letters from left and right side. No need to count distance from far remote letters.\\n\\n\\nNext, when we see a part of a string like here and suppose we want to calculate distance from `o` to closest `e`\\'s.\\n```\\nleetcode\\n     ^\\n```\\nLet\\'s split a task into 2 symmetrical ones: distance from left letter and distance from right letter.\\n\\nHow to calculate and store distance from left `e`? Just walk through the string and check - if we see letter `e` then its distance is 0, and with any another letter distance increments by 1.\\n\\nSo distances between letters `e` will be (I\\'ve added extra space between letters for readibility):\\n\\n```\\nl    e      e      t       c       o       d      e\\n                                   ^\\n\\t\\t    0      1       2       3       4      5\\n```\\n\\nNext, go from right with the same distance calculation. But this time check if there\\'s a closer letter `e` from another side.\\n\\nWe may code this using any language only with standard operators and arrays. \\nHere\\'s an example on Golang.\\n\\n```golang\\nfunc shortestToChar(s string, c byte) []int {\\n\\t// cache string length\\n    var lens = len(s)\\n\\t// prepare a storage for the result \\n\\t// slice (or array, vector) with length equal to len(s) initialized with zeros\\n    var res = make([]int, lens)\\n    \\n    // current distance from last seen letter `c`\\n    // we start with increadibly high value to show it\\'s invalid\\n    var dist = lens + 100\\n    \\n    // scan from left to right, increase distance from last seen letter\\n    // flush distance to zero at every new seen required letter\\n    for i := 0; i < lens; i++ {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        res[i] = dist\\n        dist++\\n    }\\n    \\n    // the same backwards \\n    // but also check if we have less distance from opposite letter\\n    for i := lens-1; i >=0; i-- {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        if dist < res[i] {\\n            res[i] = dist\\n        }\\n        dist++\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nleetcode\\n     ^\\n```\n```\\nl    e      e      t       c       o       d      e\\n                                   ^\\n\\t\\t    0      1       2       3       4      5\\n```\n```golang\\nfunc shortestToChar(s string, c byte) []int {\\n\\t// cache string length\\n    var lens = len(s)\\n\\t// prepare a storage for the result \\n\\t// slice (or array, vector) with length equal to len(s) initialized with zeros\\n    var res = make([]int, lens)\\n    \\n    // current distance from last seen letter `c`\\n    // we start with increadibly high value to show it\\'s invalid\\n    var dist = lens + 100\\n    \\n    // scan from left to right, increase distance from last seen letter\\n    // flush distance to zero at every new seen required letter\\n    for i := 0; i < lens; i++ {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        res[i] = dist\\n        dist++\\n    }\\n    \\n    // the same backwards \\n    // but also check if we have less distance from opposite letter\\n    for i := lens-1; i >=0; i-- {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        if dist < res[i] {\\n            res[i] = dist\\n        }\\n        dist++\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054648,
                "title": "java-solution-linear-time",
                "content": "```\\nclass Solution \\n{\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        int l = -1;\\n        int r = s.indexOf(c);\\n        int[] ans = new int[s.length()];\\n        \\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s.charAt(i) == c )\\n            {\\n                l = r;\\n                \\n                if(s.substring(i+1).indexOf(c) == -1)\\n                    r = -1;\\n                else\\n                    r = (i+1) + s.substring(i+1).indexOf(c);\\n            }\\n            \\n            if(r == -1)\\n                ans[i] = i-l;\\n            else if(l == -1)\\n                ans[i] = r-i;\\n            else if(r != -1 && l != -1)\\n                ans[i] = Math.min(i - l , r - i);\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        int l = -1;\\n        int r = s.indexOf(c);\\n        int[] ans = new int[s.length()];\\n        \\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s.charAt(i) == c )\\n            {\\n                l = r;\\n                \\n                if(s.substring(i+1).indexOf(c) == -1)\\n                    r = -1;\\n                else\\n                    r = (i+1) + s.substring(i+1).indexOf(c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1054131,
                "title": "python-o-n-simple-easy-understanding-cool-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t\\t\\tn = lastC =len(s)\\n\\t\\t\\tans = [n] * n\\n\\t\\t\\tfor i in itertools.chain(range(n), range(n)[::-1]):\\n\\t\\t\\t\\tif s[i] == c: lastC = i\\n\\t\\t\\t\\tans[i] = min(ans[i], abs( i - lastC))\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t\\t\\tn = lastC =len(s)\\n\\t\\t\\tans = [n] * n\\n\\t\\t\\tfor i in itertools.chain(range(n), range(n)[::-1]):\\n\\t\\t\\t\\tif s[i] == c: lastC = i\\n\\t\\t\\t\\tans[i] = min(ans[i], abs( i - lastC))\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 872326,
                "title": "declarative-javascript-solution-using-array-reduce-and-array-map",
                "content": "Modern declarative JavaScript use of string destructuring and array methods.\\n\\nPlease keep in mind, this is an example of declarative JavaScript programming vs imperative solutions.\\nThe solution won\\'t be the fastest or the most memory efficient.\\n\\nHere\\'s some references if you\\'re more interested about what reduce and map can do:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\n\\n```\\nvar shortestToChar = function(S, C) {\\n    \\n    // We create an array of indices of where the character C occurs\\n    //\\n    // [...S] is a string destructuring, we turn the string into an array\\n    // of characters (in JavaScript, it\\'s really just single character strings)\\n    //\\n    // On this new string array, we use Array.reduce(), which is a powerful way of\\n    // exploring arrays with a callback function. The callback function in this example is\\n    // (acc, currC, ind) => currC === C ? [...acc, ind] : acc\\n    // which is stating \"for each element, take the \\'Accumulator\\', \\'Current Element\\', and \\'Index\\'\\n    // and return what our next accumulator will be\". The accumulator was initialized to be\\n    // an empty array and if the character matches, we copy our current accumulator array into\\n    // a new array and append the current Index. If it doesn\\'t match, just return our Accumulator\\n    //\\n    // The ultimate result is our accumulator, which is an array of indices.\\n    \\n    const indexesOfC = [...S].reduce(\\n        (acc, currC, currInd) => currC === C ? [...acc, currInd] : acc\\n        , [])\\n    \\n    // Here, we are mapping each character to a number. This is the perfect time\\n    // to use Array.map()! Array.map also uses a callback function, but this time it\\'s\\n    // (char, ind) => <some code returning what we want to map>\\n    // \"char\" being \"Current Element\" and \"ind\" being an optional parameter \"Current Index\"\\n    //\\n    // We then run an Array.reduce() on our indices of character C. This time the accumulator\\n    // is going to be recording the shortest distance from the current S index to the closest\\n    // C index. We return the smaller of the saved value (acc) and the distance (Math.abs(ind - curr))\\n    //\\n    // Note that the accumulator is initially set to Infinity. You can also use Number.MAX_VALUE.\\n    \\n    return [...S].map((char, ind) => \\n        indexesOfC.reduce((acc, curr) => \\n            Math.min(acc, Math.abs(ind - curr))\\n        , Infinity)\\n    )\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    \\n    // We create an array of indices of where the character C occurs\\n    //\\n    // [...S] is a string destructuring, we turn the string into an array\\n    // of characters (in JavaScript, it\\'s really just single character strings)\\n    //\\n    // On this new string array, we use Array.reduce(), which is a powerful way of\\n    // exploring arrays with a callback function. The callback function in this example is\\n    // (acc, currC, ind) => currC === C ? [...acc, ind] : acc\\n    // which is stating \"for each element, take the \\'Accumulator\\', \\'Current Element\\', and \\'Index\\'\\n    // and return what our next accumulator will be\". The accumulator was initialized to be\\n    // an empty array and if the character matches, we copy our current accumulator array into\\n    // a new array and append the current Index. If it doesn\\'t match, just return our Accumulator\\n    //\\n    // The ultimate result is our accumulator, which is an array of indices.\\n    \\n    const indexesOfC = [...S].reduce(\\n        (acc, currC, currInd) => currC === C ? [...acc, currInd] : acc\\n        , [])\\n    \\n    // Here, we are mapping each character to a number. This is the perfect time\\n    // to use Array.map()! Array.map also uses a callback function, but this time it\\'s\\n    // (char, ind) => <some code returning what we want to map>\\n    // \"char\" being \"Current Element\" and \"ind\" being an optional parameter \"Current Index\"\\n    //\\n    // We then run an Array.reduce() on our indices of character C. This time the accumulator\\n    // is going to be recording the shortest distance from the current S index to the closest\\n    // C index. We return the smaller of the saved value (acc) and the distance (Math.abs(ind - curr))\\n    //\\n    // Note that the accumulator is initially set to Infinity. You can also use Number.MAX_VALUE.\\n    \\n    return [...S].map((char, ind) => \\n        indexesOfC.reduce((acc, curr) => \\n            Math.min(acc, Math.abs(ind - curr))\\n        , Infinity)\\n    )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 605819,
                "title": "2-solutions-easy-to-understand-faster-binary-search-python-solution",
                "content": "```\\n    def using_solution_tab_solution(self, S, C):\\n        out = []\\n        prev = float(\\'inf\\')\\n        for i, v in enumerate(S):\\n            if v == C: prev = i\\n            out.append(abs(prev - i))\\n        prev = float(\\'inf\\')\\n        for i in range(len(S) -1 , -1 , -1):\\n            v = S[i]\\n            if v == C: prev = i\\n            out[i] = min(out[i], abs(prev - i))\\n        return out\\n        \\n    def using_binary_search(self, S, C):\\n        occurences = [i for i,v in enumerate(S) if v == C]\\n        out = []\\n        for i,v in enumerate(S):\\n            closest = self.find_closest(occurences, i)\\n            out.append(abs(closest - i))\\n        return out\\n      \\n    def find_closest(self, arr, target):\\n        # using binary search to find closest\\n        start, end = 0, len(arr) - 1\\n        while start < end - 1:\\n            mid = (start + end) // 2\\n            diff = arr[mid] - target\\n            if diff == 0: return arr[mid]\\n            elif diff < 0: start = mid\\n            else: end = mid\\n        # print(arr[start], arr[end])\\n        return arr[end] if abs(arr[end] - target) <= abs(arr[start] - target) else arr[start]\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n    def using_solution_tab_solution(self, S, C):\\n        out = []\\n        prev = float(\\'inf\\')\\n        for i, v in enumerate(S):\\n            if v == C: prev = i\\n            out.append(abs(prev - i))\\n        prev = float(\\'inf\\')\\n        for i in range(len(S) -1 , -1 , -1):\\n            v = S[i]\\n            if v == C: prev = i\\n            out[i] = min(out[i], abs(prev - i))\\n        return out\\n        \\n    def using_binary_search(self, S, C):\\n        occurences = [i for i,v in enumerate(S) if v == C]\\n        out = []\\n        for i,v in enumerate(S):\\n            closest = self.find_closest(occurences, i)\\n            out.append(abs(closest - i))\\n        return out\\n      \\n    def find_closest(self, arr, target):\\n        # using binary search to find closest\\n        start, end = 0, len(arr) - 1\\n        while start < end - 1:\\n            mid = (start + end) // 2\\n            diff = arr[mid] - target\\n            if diff == 0: return arr[mid]\\n            elif diff < 0: start = mid\\n            else: end = mid\\n        # print(arr[start], arr[end])\\n        return arr[end] if abs(arr[end] - target) <= abs(arr[start] - target) else arr[start]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 465841,
                "title": "javascript-solution",
                "content": "Probably not the best solution but it\\'s straightforward and works \\n\\nSteps:\\n- initialize an array \\n- Loop through the string\\n- find the closest character C with a helper function \\n\\n- at each letter, calculate and return the distance of the closest C \\n- push that value distance to the array \\n\\n\\n```\\nvar shortestToChar = function(S, C) {\\n    let arr = []\\n    for (let i = 0; i < S.length; i++) {\\n        // should return i of the closest character\\n        let closest = findClosest(i, S, C); \\n        \\n        // add to array \\n        arr.push(closest)\\n    }\\n    return arr\\n};\\n\\nvar findClosest = function(i, S, C) {\\n    if (S[i] === C) return 0\\n    \\n    let j = 1\\n\\t// set limits for beginning and end of S string\\n    while (i >= 0 || i <= S.length) {\\n\\t\\t// checks the character in either direction by j units\\n        if (S[i + j] === C || S[i - j] === C) {\\n            return j;\\n        }\\n        j++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    let arr = []\\n    for (let i = 0; i < S.length; i++) {\\n        // should return i of the closest character\\n        let closest = findClosest(i, S, C); \\n        \\n        // add to array \\n        arr.push(closest)\\n    }\\n    return arr\\n};\\n\\nvar findClosest = function(i, S, C) {\\n    if (S[i] === C) return 0\\n    \\n    let j = 1\\n\\t// set limits for beginning and end of S string\\n    while (i >= 0 || i <= S.length) {\\n\\t\\t// checks the character in either direction by j units\\n        if (S[i + j] === C || S[i - j] === C) {\\n            return j;\\n        }\\n        j++;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444317,
                "title": "python-with-comments",
                "content": "\\'\\'\\'\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n\\n        res = []\\n        pos = [] \\n        \\n        # keep indexes of C in S\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                pos.append(i)                \\n        \\n        for i in range(len(S)):\\n            # set default value as length of S\\n\\t\\t\\tmn = len(S) \\n            for p in pos:                \\n                # calculate minimum value of distance\\n\\t\\t\\t\\tmn = min(mn, abs(i-p)) \\n            res.append(mn)\\n        return res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n\\n        res = []\\n        pos = [] \\n        \\n        # keep indexes of C in S\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                pos.append(i)                \\n        \\n        for i in range(len(S)):\\n            # set default value as length of S\\n\\t\\t\\tmn = len(S) \\n            for p in pos:                \\n                # calculate minimum value of distance\\n\\t\\t\\t\\tmn = min(mn, abs(i-p)) \\n            res.append(mn)\\n        return res\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 125798,
                "title": "c-simplest-solution-o-n",
                "content": "    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length(), loc = -1;\\n        vector<int> result(len, INT_MAX);\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], loc != -1 ? abs(i - loc) : INT_MAX);\\n        }\\n        \\n        for(int i = len - 1; i >= 0; i--) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], abs(i - loc));\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length(), loc = -1;\\n        vector<int> result(len, INT_MAX);\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], loc != -1 ? abs(i - loc) : INT_MAX);\\n        }\\n        \\n        for(int i = len - 1; i >= 0; i--) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], abs(i - loc));\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3590757,
                "title": "very-easy-to-understand",
                "content": "# PLEASE UPVOTE IF YOU ANYWAY LIKE IT\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>left(s.size(),-1);\\n        int j=0;\\n        int flag=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                left[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                left[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                left[i]=j++;\\n            }\\n        }\\n        vector<int>right(s.size(),-1);\\n        j=0;\\n        flag=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                right[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                right[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                right[i]=j++;\\n            }\\n        }\\n        vector<int>hny;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(left[i]>=0 && right[i]>=0)\\n            {\\n                hny.push_back(min(left[i],right[i]));\\n            }\\n            else \\n              hny.push_back(max(left[i],right[i]));\\n        }\\n        return hny;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>left(s.size(),-1);\\n        int j=0;\\n        int flag=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                left[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                left[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                left[i]=j++;\\n            }\\n        }\\n        vector<int>right(s.size(),-1);\\n        j=0;\\n        flag=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                right[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                right[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                right[i]=j++;\\n            }\\n        }\\n        vector<int>hny;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(left[i]>=0 && right[i]>=0)\\n            {\\n                hny.push_back(min(left[i],right[i]));\\n            }\\n            else \\n              hny.push_back(max(left[i],right[i]));\\n        }\\n        return hny;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481559,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n\\tvector<int>v;\\n\\tfor (int i = 0;i < n;i++) {\\n\\t\\tint distance = 0;\\n\\t\\tfor (int j = i, k = i;j < n || k >= 0;j++, k--) {\\n\\t\\t\\tif ((k >= 0 && s[k] == c) || (j < n && s[j] == c )) {\\n\\t\\t\\t\\tv.push_back(distance);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdistance++;\\n\\t\\t}\\n\\n\\t}\\n\\treturn v;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        n=len(s)\\n        arr=[i for i in range(n) if s[i]==c]\\n        arr1=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                arr1.append(0)\\n                j=j+1\\n            elif i<arr[0]:\\n                arr1.append(arr[0]-i)\\n            elif i>arr[-1]:\\n                arr1.append(i-arr[-1])\\n            else:\\n                arr1.append(min(arr[j]-i,i-arr[j-1]))\\n        return arr1\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        int currentIndex = -1; \\n        int leftIndex = findNextOccurance(s, -1, c);\\n        fillCreek(result, -leftIndex, leftIndex);\\n        while(true){\\n            int rightIndex = findNextOccurance( s, leftIndex, c);\\n            if( rightIndex == -1){\\n                fillCreek( result, leftIndex, s.length() + ( s.length()-1-leftIndex ));\\n                break;\\n            }\\n            fillCreek(result, leftIndex, rightIndex);\\n            leftIndex = rightIndex; \\n        }\\n        return result;\\n    }\\n    public int findNextOccurance(String s, int fromIndex, char c){\\n        for( int i = fromIndex+1; i< s.length(); i++){\\n            if( s.charAt(i) == c ) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public void fillCreek(int[] result, int leftIndex, int rightIndex){\\n        int from = Math.max( leftIndex, 0);\\n        int to = Math.min( rightIndex, result.length-1);\\n        for( int i = from ; i<= to; i++){\\n            result[i] = Math.min( i - leftIndex ,  rightIndex - i  );\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n\\tvector<int>v;\\n\\tfor (int i = 0;i < n;i++) {\\n\\t\\tint distance = 0;\\n\\t\\tfor (int j = i, k = i;j < n || k >= 0;j++, k--) {\\n\\t\\t\\tif ((k >= 0 && s[k] == c) || (j < n && s[j] == c )) {\\n\\t\\t\\t\\tv.push_back(distance);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdistance++;\\n\\t\\t}\\n\\n\\t}\\n\\treturn v;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        n=len(s)\\n        arr=[i for i in range(n) if s[i]==c]\\n        arr1=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                arr1.append(0)\\n                j=j+1\\n            elif i<arr[0]:\\n                arr1.append(arr[0]-i)\\n            elif i>arr[-1]:\\n                arr1.append(i-arr[-1])\\n            else:\\n                arr1.append(min(arr[j]-i,i-arr[j-1]))\\n        return arr1\\n```\n```Java []\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        int currentIndex = -1; \\n        int leftIndex = findNextOccurance(s, -1, c);\\n        fillCreek(result, -leftIndex, leftIndex);\\n        while(true){\\n            int rightIndex = findNextOccurance( s, leftIndex, c);\\n            if( rightIndex == -1){\\n                fillCreek( result, leftIndex, s.length() + ( s.length()-1-leftIndex ));\\n                break;\\n            }\\n            fillCreek(result, leftIndex, rightIndex);\\n            leftIndex = rightIndex; \\n        }\\n        return result;\\n    }\\n    public int findNextOccurance(String s, int fromIndex, char c){\\n        for( int i = fromIndex+1; i< s.length(); i++){\\n            if( s.charAt(i) == c ) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public void fillCreek(int[] result, int leftIndex, int rightIndex){\\n        int from = Math.max( leftIndex, 0);\\n        int to = Math.min( rightIndex, result.length-1);\\n        for( int i = from ; i<= to; i++){\\n            result[i] = Math.min( i - leftIndex ,  rightIndex - i  );\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287751,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int>ans;\\n        vector<int>temp;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==c)\\n            temp.push_back(i);\\n        }\\n        int ind1=0;\\n        int n=temp.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if(ind1==n-1)\\n            {\\n                ans.push_back(abs(i-temp[ind1]));\\n            }\\n            else{\\n                if (abs(i-temp[ind1])>abs(i-temp[ind1+1]))\\n                {\\n                    ind1++;\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n                else{\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int>ans;\\n        vector<int>temp;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==c)\\n            temp.push_back(i);\\n        }\\n        int ind1=0;\\n        int n=temp.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if(ind1==n-1)\\n            {\\n                ans.push_back(abs(i-temp[ind1]));\\n            }\\n            else{\\n                if (abs(i-temp[ind1])>abs(i-temp[ind1+1]))\\n                {\\n                    ind1++;\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n                else{\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103959,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n      vector<int>ind;\\n      vector<int>ans;\\n      for(int i=0;i<s.size();i++)  {\\n          if(s[i]==c)ind.push_back(i);\\n      }\\n      \\n      for(int i=0;i<s.size();i++){\\n          int d=100000;\\n          for(int j=0;j<ind.size();j++){\\n          int d2 = abs(i-ind[j]);\\n           if(d2<d)d=d2;\\n          }                  \\n          ans.push_back(d);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n      vector<int>ind;\\n      vector<int>ans;\\n      for(int i=0;i<s.size();i++)  {\\n          if(s[i]==c)ind.push_back(i);\\n      }\\n      \\n      for(int i=0;i<s.size();i++){\\n          int d=100000;\\n          for(int j=0;j<ind.size();j++){\\n          int d2 = abs(i-ind[j]);\\n           if(d2<d)d=d2;\\n          }                  \\n          ans.push_back(d);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091201,
                "title": "c-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>ispresent;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)ispresent.push_back(i);\\n        }\\n        vector<int>ans(s.length());\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                ans[i]=0;\\n            }\\n            else{\\n                int val=INT_MAX;\\n                for(int k=0;k<ispresent.size();k++){\\n                    val=min(val,abs(i-ispresent[k]));\\n                }\\n                ans[i]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>ispresent;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)ispresent.push_back(i);\\n        }\\n        vector<int>ans(s.length());\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                ans[i]=0;\\n            }\\n            else{\\n                int val=INT_MAX;\\n                for(int k=0;k<ispresent.size();k++){\\n                    val=min(val,abs(i-ispresent[k]));\\n                }\\n                ans[i]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747153,
                "title": "runs-100-faster-cpp-soln-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(s.size());\\n        int last = -n ;\\n       for(int i = 0 ; i < n ;i++){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(i-last);\\n       }\\n        for(int i = n-1 ; i >= 0 ;i--){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(min(abs(last-i) , ans[i]));\\n       }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(s.size());\\n        int last = -n ;\\n       for(int i = 0 ; i < n ;i++){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(i-last);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2566014,
                "title": "c-fast-and-easy-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int fdist=INT_MAX,bdist=INT_MAX;\\n        vector<int>ans(s.size(),INT_MAX);\\n       for(int i=0,j=s.size()-1;i<s.size();++i,--j)\\n       {\\n           if(s[i]==c) fdist=0;\\n           if(s[j]==c) bdist=0;\\n           \\n           ans[i]=min(fdist,ans[i]);\\n           ans[j]=min(bdist,ans[j]);\\n           \\n           if(fdist!=INT_MAX) fdist++;\\n           if(bdist!=INT_MAX) bdist++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int fdist=INT_MAX,bdist=INT_MAX;\\n        vector<int>ans(s.size(),INT_MAX);\\n       for(int i=0,j=s.size()-1;i<s.size();++i,--j)\\n       {\\n           if(s[i]==c) fdist=0;\\n           if(s[j]==c) bdist=0;\\n           \\n           ans[i]=min(fdist,ans[i]);\\n           ans[j]=min(bdist,ans[j]);\\n           \\n           if(fdist!=INT_MAX) fdist++;\\n           if(bdist!=INT_MAX) bdist++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552819,
                "title": "js-easy-solution-100",
                "content": "```\\nvar shortestToChar = function(s, c) {\\n    const indexOfC = [];\\n    const output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) {\\n            indexOfC.push(i)\\n        }\\n    }\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        output[i] = +Infinity;\\n        for (let j = 0; j < indexOfC.length; j++) {\\n            if (i === indexOfC[j]) {\\n                output[i] = 0;\\n                break;\\n            } else {\\n                if (Math.abs(indexOfC[j] - i) > output[i]) break;\\n                output[i] = Math.min(output[i], Math.abs(indexOfC[j] - i));\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(s, c) {\\n    const indexOfC = [];\\n    const output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) {\\n            indexOfC.push(i)\\n        }\\n    }\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        output[i] = +Infinity;\\n        for (let j = 0; j < indexOfC.length; j++) {\\n            if (i === indexOfC[j]) {\\n                output[i] = 0;\\n                break;\\n            } else {\\n                if (Math.abs(indexOfC[j] - i) > output[i]) break;\\n                output[i] = Math.min(output[i], Math.abs(indexOfC[j] - i));\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394618,
                "title": "easiest-approach-5-ms-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>sk;\\n        vector<int>res;\\n        vector<int>temp;\\n        int ss=0;\\n        int mins;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)\\n\\t\\t\\t//storing all the c character location i.e \\'e\\' in sk i.e [3,5,6,11]\\n             sk.push_back(i);\\n        }\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<sk.size();j++){\\n\\t\\t\\t//now subtracting every i value with all value of character locations and storing the minimum in res vector.\\n\\t\\t\\n                mins=abs(sk[j]-i);\\n                temp.push_back(mins);\\n            }\\n\\t\\t\\t\\t//in first iteration [3-0=3,5-0=5,6-0=6,11-0=0] so removing the minimum elemnet from this that is 3 and stroing is res.\\n            int min=temp[0];\\n            for(auto i:temp){\\n                if(i<min){\\n                    min=i;\\n                }\\n            }\\n            res.push_back(min);\\n            temp.clear();\\n        \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>sk;\\n        vector<int>res;\\n        vector<int>temp;\\n        int ss=0;\\n        int mins;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)\\n\\t\\t\\t//storing all the c character location i.e \\'e\\' in sk i.e [3,5,6,11]\\n             sk.push_back(i);\\n        }\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<sk.size();j++){\\n\\t\\t\\t//now subtracting every i value with all value of character locations and storing the minimum in res vector.\\n\\t\\t\\n                mins=abs(sk[j]-i);\\n                temp.push_back(mins);\\n            }\\n\\t\\t\\t\\t//in first iteration [3-0=3,5-0=5,6-0=6,11-0=0] so removing the minimum elemnet from this that is 3 and stroing is res.\\n            int min=temp[0];\\n            for(auto i:temp){\\n                if(i<min){\\n                    min=i;\\n                }\\n            }\\n            res.push_back(min);\\n            temp.clear();\\n        \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281644,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int a=s.length();\\n        int arr1[a];\\n        int arr2[a];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr1[i]=100000;\\n            arr2[i]=100000;\\n        }\\n        int occur1;\\n        int flag1=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr1[i]=0;\\n                flag1=1;\\n                occur1=i;\\n            }\\n            if (flag1==1)\\n            {\\n                arr1[i]=i-occur1;\\n            }\\n        }\\n        int occur2;\\n        int flag2=0;\\n        for(int i=a-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr2[i]=0;\\n                flag2=1;\\n                occur2=i;\\n            }\\n            if (flag2==1)\\n            {\\n                arr2[i]=occur2-i;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int mele=min(arr1[i],arr2[i]);\\n            ans.push_back(mele);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int a=s.length();\\n        int arr1[a];\\n        int arr2[a];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr1[i]=100000;\\n            arr2[i]=100000;\\n        }\\n        int occur1;\\n        int flag1=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr1[i]=0;\\n                flag1=1;\\n                occur1=i;\\n            }\\n            if (flag1==1)\\n            {\\n                arr1[i]=i-occur1;\\n            }\\n        }\\n        int occur2;\\n        int flag2=0;\\n        for(int i=a-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr2[i]=0;\\n                flag2=1;\\n                occur2=i;\\n            }\\n            if (flag2==1)\\n            {\\n                arr2[i]=occur2-i;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int mele=min(arr1[i],arr2[i]);\\n            ans.push_back(mele);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183851,
                "title": "python3-o-n-o-n-runtime-53ms-78-92-memory-13-9mb-91-60",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, string: str, char: str) -> List[int]:\\n        return self.optimalSolution(string, char)\\n#     O(n) || O(n)\\n# Runtime: 53ms 78.92% Memory: 13.9mb 91.60%\\n    def optimalSolution(self, string, char):\\n        n = len(string)\\n        leftArray, rightArray, result = ([float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n)\\n        temp = float(\\'inf\\')\\n        for i in range(len(string)):\\n            if string[i] == char:\\n                temp = 0\\n            leftArray[i] = temp\\n            temp += 1\\n\\n        temp = float(\\'inf\\')\\n        for i in reversed(range(len(string))):\\n            if string[i] == char:\\n                temp = 0\\n            rightArray[i] = temp\\n            temp += 1\\n\\n\\n        for i in range(len(result)):\\n            result[i] = min(leftArray[i], rightArray[i])\\n\\n        return result\\n\\n    \\n#     O(n^2) || O(n) Runtime: TLE\\n    def bruteForce(self, string, char):\\n        sequence = [float(\\'inf\\')] * len(string)\\n        newList = []\\n        for idx, val in enumerate(string):\\n            if val == char:\\n                newList.append(idx)\\n\\n        for val1 in newList:\\n            for idx2, val2 in enumerate(string):\\n                sequence[idx2] = min(sequence[idx2], abs(idx2-val1))\\n\\n        return sequence\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, string: str, char: str) -> List[int]:\\n        return self.optimalSolution(string, char)\\n#     O(n) || O(n)\\n# Runtime: 53ms 78.92% Memory: 13.9mb 91.60%\\n    def optimalSolution(self, string, char):\\n        n = len(string)\\n        leftArray, rightArray, result = ([float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n)\\n        temp = float(\\'inf\\')\\n        for i in range(len(string)):\\n            if string[i] == char:\\n                temp = 0\\n            leftArray[i] = temp\\n            temp += 1\\n\\n        temp = float(\\'inf\\')\\n        for i in reversed(range(len(string))):\\n            if string[i] == char:\\n                temp = 0\\n            rightArray[i] = temp\\n            temp += 1\\n\\n\\n        for i in range(len(result)):\\n            result[i] = min(leftArray[i], rightArray[i])\\n\\n        return result\\n\\n    \\n#     O(n^2) || O(n) Runtime: TLE\\n    def bruteForce(self, string, char):\\n        sequence = [float(\\'inf\\')] * len(string)\\n        newList = []\\n        for idx, val in enumerate(string):\\n            if val == char:\\n                newList.append(idx)\\n\\n        for val1 in newList:\\n            for idx2, val2 in enumerate(string):\\n                sequence[idx2] = min(sequence[idx2], abs(idx2-val1))\\n\\n        return sequence\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094832,
                "title": "nice-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ans;\\n        int n = s.size();\\n        for(int i=0;i<n;++i){\\n            if(s[i]==c){\\n                ans.push_back(0);\\n            }\\n            else{\\n                int st = i;\\n                int en = i;\\n                bool find1=false,find2=false;\\n                while(st>=0){\\n                    if(s[st]==c){\\n                        find1 = true;\\n                        break;\\n                    }\\n                    st--;\\n                }\\n                while(en<n){\\n                    if(s[en]==c){\\n                        find2 = true;\\n                        break;\\n                    }\\n                    en++;\\n                }\\n                if(find1 && find2){\\n                    ans.push_back(min(en-i,i-st));                    \\n                }else if(find1){\\n                    ans.push_back(i-st);\\n                }else{\\n                    ans.push_back(en-i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ans;\\n        int n = s.size();\\n        for(int i=0;i<n;++i){\\n            if(s[i]==c){\\n                ans.push_back(0);\\n            }\\n            else{\\n                int st = i;\\n                int en = i;\\n                bool find1=false,find2=false;\\n                while(st>=0){\\n                    if(s[st]==c){\\n                        find1 = true;\\n                        break;\\n                    }\\n                    st--;\\n                }\\n                while(en<n){\\n                    if(s[en]==c){\\n                        find2 = true;\\n                        break;\\n                    }\\n                    en++;\\n                }\\n                if(find1 && find2){\\n                    ans.push_back(min(en-i,i-st));                    \\n                }else if(find1){\\n                    ans.push_back(i-st);\\n                }else{\\n                    ans.push_back(en-i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984164,
                "title": "shortest-distance-to-a-character",
                "content": "```\\nvector<int> shortestToChar(string s, char c) {\\n        vector<int> index;\\n        vector<int> ans;\\n        int k1 = 0, k2 = 1;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        index.push_back(INT_MAX);\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(i > index[k2])\\n            {\\n                k1++;\\n                k2++;\\n            }\\n            ans.push_back(min(abs(index[k1]-i),abs(index[k2]-i)));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> shortestToChar(string s, char c) {\\n        vector<int> index;\\n        vector<int> ans;\\n        int k1 = 0, k2 = 1;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        index.push_back(INT_MAX);\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(i > index[k2])\\n            {\\n                k1++;\\n                k2++;\\n            }\\n            ans.push_back(min(abs(index[k1]-i),abs(index[k2]-i)));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1738902,
                "title": "easy-to-understand-java-code",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int min=Integer.MAX_VALUE;\\n        int[] array=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<s.length();j++){\\n                if(s.charAt(j)==c){\\n                    min=Math.min(min,Math.abs(i-j));\\n                }   \\n            }\\n            array[i]=min;\\n            min=Integer.MAX_VALUE;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int min=Integer.MAX_VALUE;\\n        int[] array=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<s.length();j++){\\n                if(s.charAt(j)==c){\\n                    min=Math.min(min,Math.abs(i-j));\\n                }   \\n            }\\n            array[i]=min;\\n            min=Integer.MAX_VALUE;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718249,
                "title": "beats-100-runtime-optimal-2-pass-in-python",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        #Time: O(n)\\n        #Space: O(n)\\n        \\n        #Represents how far a character is away from c (x = inf)\\n        #loveleetcode\\n        #xxx010012340 - first pass\\n        #321010043210 - second pass\\n        #321010012210 - answer (take min of both first and second pass)\\n        \\n        answer = [float(\\'inf\\') for _ in range(len(s))]\\n        \\n        counter = float(\\'inf\\')\\n        for idx in range(len(s)):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n                \\n            answer[idx] = min(answer[idx], counter)\\n        \\n        counter = float(\\'inf\\')\\n        for idx in reversed(range(len(s))):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n            \\n            answer[idx] = min(answer[idx], counter)\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        #Time: O(n)\\n        #Space: O(n)\\n        \\n        #Represents how far a character is away from c (x = inf)\\n        #loveleetcode\\n        #xxx010012340 - first pass\\n        #321010043210 - second pass\\n        #321010012210 - answer (take min of both first and second pass)\\n        \\n        answer = [float(\\'inf\\') for _ in range(len(s))]\\n        \\n        counter = float(\\'inf\\')\\n        for idx in range(len(s)):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n                \\n            answer[idx] = min(answer[idx], counter)\\n        \\n        counter = float(\\'inf\\')\\n        for idx in reversed(range(len(s))):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n            \\n            answer[idx] = min(answer[idx], counter)\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505571,
                "title": "easy-solution-using-c",
                "content": "# vector<int> shortestToChar(string s, char c) {\\n        vector<int> v;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == c)\\n                v.push_back(i);\\n        }\\n\\n        vector<int> result;\\n        int index, diff;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            index = INT_MAX;\\n            for (int j = 0; j < v.size(); j++)\\n            {\\n                diff = abs(i - v[j]);\\n                index = min(index, diff);\\n            }\\n            result.push_back(index);\\n        }\\n\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "# vector<int> shortestToChar(string s, char c) {\\n        vector<int> v;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == c)\\n                v.push_back(i);\\n        }\\n\\n        vector<int> result;\\n        int index, diff;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            index = INT_MAX;\\n            for (int j = 0; j < v.size(); j++)\\n            {\\n                diff = abs(i - v[j]);\\n                index = min(index, diff);\\n            }\\n            result.push_back(index);\\n        }\\n\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1262329,
                "title": "easy-to-understand-o-n-c-java",
                "content": "Implementation\\n\\n**1st Approach in C++**\\nTime Complexity = O(N), Space Complexity = O(N)\\n\\n```\\nvector<int> shortestToChar(string s, char c) {\\n    vector<int> vec, res;\\n    for(int itr = 0; itr < s.size(); itr++){\\n        if(s[itr] == c) vec.push_back(itr);\\n    }\\n    \\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.size(); itr++){\\n        if(vec[jtr] >= itr || jtr+1 == vec.size()) res.push_back(abs(vec[jtr]-itr));\\n        else{\\n            dif1 = abs(vec[jtr+1]-itr);\\n            dif2 = abs(vec[jtr]-itr);\\n            if(dif1 <= dif2){\\n                res.push_back(dif1);\\n                jtr++;\\n            }\\n            else res.push_back(dif2);\\n        }\\n    }\\n    return res;        \\n}\\n```\\n\\n\\n**2nd Approach in Java**\\nTime Complexity = O(N), Space Complexity = O(N)\\n\\n```\\npublic int[] shortestToChar(String s, char c) {\\n    ArrayList<Integer> arr = new ArrayList<Integer>();        \\n    for(int itr = 0; itr < s.length(); itr++){\\n        if(s.charAt(itr) == c) arr.add(itr);\\n    }\\n\\t\\n    int[] res = new int[s.length()];\\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.length(); itr++){\\n        if(arr.get(jtr) >= itr || jtr+1 == arr.size()) res[itr] = Math.abs(arr.get(jtr)-itr);\\n        else{                \\n            dif1 = Math.abs(arr.get(jtr+1)-itr);\\n            dif2 = Math.abs(arr.get(jtr)-itr);\\n            if(dif1 <= dif2){\\n                res[itr] = dif1;\\n                jtr++;\\n            }\\n            else res[itr] = dif2;\\n        }\\n    }\\n    return res; \\n}\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nvector<int> shortestToChar(string s, char c) {\\n    vector<int> vec, res;\\n    for(int itr = 0; itr < s.size(); itr++){\\n        if(s[itr] == c) vec.push_back(itr);\\n    }\\n    \\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.size(); itr++){\\n        if(vec[jtr] >= itr || jtr+1 == vec.size()) res.push_back(abs(vec[jtr]-itr));\\n        else{\\n            dif1 = abs(vec[jtr+1]-itr);\\n            dif2 = abs(vec[jtr]-itr);\\n            if(dif1 <= dif2){\\n                res.push_back(dif1);\\n                jtr++;\\n            }\\n            else res.push_back(dif2);\\n        }\\n    }\\n    return res;        \\n}\\n```\n```\\npublic int[] shortestToChar(String s, char c) {\\n    ArrayList<Integer> arr = new ArrayList<Integer>();        \\n    for(int itr = 0; itr < s.length(); itr++){\\n        if(s.charAt(itr) == c) arr.add(itr);\\n    }\\n\\t\\n    int[] res = new int[s.length()];\\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.length(); itr++){\\n        if(arr.get(jtr) >= itr || jtr+1 == arr.size()) res[itr] = Math.abs(arr.get(jtr)-itr);\\n        else{                \\n            dif1 = Math.abs(arr.get(jtr+1)-itr);\\n            dif2 = Math.abs(arr.get(jtr)-itr);\\n            if(dif1 <= dif2){\\n                res[itr] = dif1;\\n                jtr++;\\n            }\\n            else res[itr] = dif2;\\n        }\\n    }\\n    return res; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063474,
                "title": "c-simplest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n,0);\\n        int prev = -1;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = i - prev; \\n            else\\n                ans[i] = INT_MAX;\\n        }\\n        prev = -1;\\n        for(int i = n-1; i>=0; i--){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = min(ans[i],prev - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n,0);\\n        int prev = -1;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = i - prev; \\n            else\\n                ans[i] = INT_MAX;\\n        }\\n        prev = -1;\\n        for(int i = n-1; i>=0; i--){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = min(ans[i],prev - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054837,
                "title": "easier-to-understand-python-solution",
                "content": "idea is to traverse from left to right and check the distance of character c and in second iteration we traverse from right to left and update the min(right side,  left side)\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\\ndef shortestToChar(self, s, c):\\n        \"\"\"\\n        :type s: str\\n        :type c: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [float(\\'inf\\')] * (len(s))\\n        last = float(\\'inf\\')\\n        for i, v in enumerate(s):\\n            if v ==c:\\n                res[i] = 0\\n                last = 0\\n            else:\\n                if last != float(\\'inf\\'):\\n                    res[i] = last+1\\n                    last = res[i]\\n        last = float(\\'inf\\')                    \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == e:\\n                last = res[i]\\n            elif i+1<len(s):\\n                last = res[i+1]+1\\n            res[i] = min(last, res[i])\\n        return res    \\n```",
                "solutionTags": [],
                "code": "```\\ndef shortestToChar(self, s, c):\\n        \"\"\"\\n        :type s: str\\n        :type c: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [float(\\'inf\\')] * (len(s))\\n        last = float(\\'inf\\')\\n        for i, v in enumerate(s):\\n            if v ==c:\\n                res[i] = 0\\n                last = 0\\n            else:\\n                if last != float(\\'inf\\'):\\n                    res[i] = last+1\\n                    last = res[i]\\n        last = float(\\'inf\\')                    \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == e:\\n                last = res[i]\\n            elif i+1<len(s):\\n                last = res[i+1]+1\\n            res[i] = min(last, res[i])\\n        return res    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1054586,
                "title": "shortest-distance-to-character-c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx) {\\n                    dist = min(dist, abs(d - i));\\n                }\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx) {\\n                    dist = min(dist, abs(d - i));\\n                }\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054571,
                "title": "c-solution",
                "content": "```public class Solution {\\n    public int[] ShortestToChar(string s, char c) {\\n\\n        int sLength = s.Length;\\n        int[] res = new int[sLength];\\n        int distLeft = -1, distRight = -1;\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            res[i] = Int32.MaxValue;\\n        }\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                res[i] = 0;\\n                distLeft = i;\\n            }\\n            else\\n            {\\n                if (distLeft != -1 && Math.Abs(i - distLeft) < res[i])\\n                    res[i] = Math.Abs(i - distLeft);\\n            }\\n            \\n            int j = sLength - i - 1;\\n            if (s[j] == c)\\n            {\\n                res[j] = 0;\\n                distRight = j;\\n            }\\n            else\\n            {\\n                if (distRight != -1 && Math.Abs(j - distRight) < res[j])\\n                    res[j] = Math.Abs(j - distRight);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] ShortestToChar(string s, char c) {\\n\\n        int sLength = s.Length;\\n        int[] res = new int[sLength];\\n        int distLeft = -1, distRight = -1;\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            res[i] = Int32.MaxValue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1054128,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int closest(int elem, List<Integer> list)\\n    {\\n        if(elem<=list.get(0))\\n        {\\n            return Math.abs(list.get(0)-elem);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<list.size();i++)\\n        {\\n            int diff = Math.abs(list.get(i)-elem);\\n            if(min>diff)\\n            {\\n                min = diff;\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    public int[] shortestToChar(String s, char c) {\\n        // storing the index of c character in a list\\n        List<Integer> list =  new ArrayList<>();\\n        int[] res = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                res[i] = 0;\\n            else\\n            {\\n                // finding the nearest distance\\n                int k = closest(i, list);\\n                res[i] = k;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int closest(int elem, List<Integer> list)\\n    {\\n        if(elem<=list.get(0))\\n        {\\n            return Math.abs(list.get(0)-elem);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<list.size();i++)\\n        {\\n            int diff = Math.abs(list.get(i)-elem);\\n            if(min>diff)\\n            {\\n                min = diff;\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    public int[] shortestToChar(String s, char c) {\\n        // storing the index of c character in a list\\n        List<Integer> list =  new ArrayList<>();\\n        int[] res = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                res[i] = 0;\\n            else\\n            {\\n                // finding the nearest distance\\n                int k = closest(i, list);\\n                res[i] = k;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989004,
                "title": "easy-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n=s.size();\\n        vector<int>res(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            if(s[i]==c){\\n                res[i]=0;\\n                for(int j=i-1,k=1;j>=0;j--,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n                for(int j=i+1,k=1;j<n;j++,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n=s.size();\\n        vector<int>res(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            if(s[i]==c){\\n                res[i]=0;\\n                for(int j=i-1,k=1;j>=0;j--,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n                for(int j=i+1,k=1;j<n;j++,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922852,
                "title": "c-easy-100-memory",
                "content": "to solve this problem we need to do the following :\\n1. Store all the positions of C in string S\\n2. Find the min distance between any letter to C\\n```\\nvector<int> shortestToChar(string S, char C) {\\n        vector<int> pos, dist;\\n\\t\\t//storeing all positions of C\\n        for(int i=0; i<S.size(); i++){\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n\\t\\t//finding min distance\\n        for(int i=0; i<S.size(); i++){\\n            int mn=INT_MAX;\\n            for(int j=0; j<pos.size(); j++){\\n                mn = min(mn, abs(pos[j]-i));\\n            }\\n            dist.push_back(mn);\\n        }\\n        return dist;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "to solve this problem we need to do the following :\\n1. Store all the positions of C in string S\\n2. Find the min distance between any letter to C\\n```\\nvector<int> shortestToChar(string S, char C) {\\n        vector<int> pos, dist;\\n\\t\\t//storeing all positions of C\\n        for(int i=0; i<S.size(); i++){\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n\\t\\t//finding min distance\\n        for(int i=0; i<S.size(); i++){\\n            int mn=INT_MAX;\\n            for(int j=0; j<pos.size(); j++){\\n                mn = min(mn, abs(pos[j]-i));\\n            }\\n            dist.push_back(mn);\\n        }\\n        return dist;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 728595,
                "title": "sharing-most-elegant-cpp-solution-12-ms",
                "content": "```\\nvector<int> shortestToChar(string S, char C) {\\n        set<int>s; int currentMin(INT_MAX);vector<int>ans{};\\n        for(int i=0;i<S.length();i++) if(S[i]==C) s.insert(i);\\n        for(int i=0;i<S.length();i++){\\n            for(auto x:s){\\n                if(abs(i-x)<currentMin) currentMin=abs(i-x);\\n            }\\n            ans.push_back(currentMin);\\n            currentMin=INT_MAX;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> shortestToChar(string S, char C) {\\n        set<int>s; int currentMin(INT_MAX);vector<int>ans{};\\n        for(int i=0;i<S.length();i++) if(S[i]==C) s.insert(i);\\n        for(int i=0;i<S.length();i++){\\n            for(auto x:s){\\n                if(abs(i-x)<currentMin) currentMin=abs(i-x);\\n            }\\n            ans.push_back(currentMin);\\n            currentMin=INT_MAX;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 619508,
                "title": "rust-100-with-iterators",
                "content": "```\\nimpl Solution {\\n    pub fn shortest_to_char(s: String, c: char) -> Vec<i32> {\\n        (0..s.len()).map(|i| {\\n            let left = s[0..i+1].chars().rev().position(|k| k == c).unwrap_or(99999usize);\\n            let right = s[i..].find(c).unwrap_or(99999usize);\\n            (if left < right {left} else {right}) as i32\\n        })\\n        .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn shortest_to_char(s: String, c: char) -> Vec<i32> {\\n        (0..s.len()).map(|i| {\\n            let left = s[0..i+1].chars().rev().position(|k| k == c).unwrap_or(99999usize);\\n            let right = s[i..].find(c).unwrap_or(99999usize);\\n            (if left < right {left} else {right}) as i32\\n        })\\n        .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 604194,
                "title": "c-beats-all",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char c) {\\n        vector<int> v;\\n        auto f = find(S.begin(),S.end(),c);\\n        auto i = S.begin();\\n        while(i!=f+1 && i!=S.end())\\n        {\\n            v.push_back(abs(i-f));\\n            i++;\\n        }\\n        auto fe = find(f+1,S.end(),c);\\n        while(i!=S.end())\\n        {\\n            if(*i==c)\\n            {\\n                v.push_back(0);\\n                f = i;\\n                fe = find(f+1,S.end(),c);\\n                i++;\\n            }\\n            else\\n            {\\n                if(fe!=S.end())\\n                    v.push_back(min(abs(fe-i),abs(f-i)));\\n                else\\n                    v.push_back(abs(f-i));\\n                i++;\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char c) {\\n        vector<int> v;\\n        auto f = find(S.begin(),S.end(),c);\\n        auto i = S.begin();\\n        while(i!=f+1 && i!=S.end())\\n        {\\n            v.push_back(abs(i-f));\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 600909,
                "title": "simple-cpp-100-100",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n\\t\\t\\tvector<int> idx,res;\\n\\t\\t\\tbool first = true;\\n\\t\\t\\t//this is just to maintain a  vector to maintain values\\n\\t\\t\\tfor(int  i = 0 ; i < S.size();i++){\\n\\t\\t\\t\\tif(S[i]==C&&first){\\n\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\tfirst=false;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(S[i]==C){\\n\\t\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n        //the below function is the main logic\\n      \\n\\t  int temp = 1 ; \\n        for(int i = 0 ; i  <S.size();i++){\\n            if(S[i]!=C)res.push_back(min(abs(idx[temp-1]-i),abs(idx[temp]-i)));\\n            else{\\n             res.push_back(0);\\n                if(temp!=idx.size()-1) temp++;\\n                else continue;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506937,
                "title": "easy-to-understand-c-solution-8ms",
                "content": "Runtime: 8 ms, faster than 98.14% of C++ online submissions for Shortest Distance to a Character.\\nMemory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Shortest Distance to a Character.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        \\n        vector<int> res;\\n        vector<int> pos;\\n        \\n        for(int i=0; i<S.size(); i++)\\n        {\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < S.size(); i++)\\n        {\\n            int index = lower_bound(pos.begin(), pos.end(), i) - pos.begin();\\n            int prevDiff = (index - 1 >= 0 ? i - pos[index - 1] : INT_MAX);\\n            int nextDiff = (index < pos.size()  ? pos[index] - i : INT_MAX);\\n            \\n            int minDiff = min(prevDiff, nextDiff);\\n            res.push_back(minDiff);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        \\n        vector<int> res;\\n        vector<int> pos;\\n        \\n        for(int i=0; i<S.size(); i++)\\n        {\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429615,
                "title": "python-easy-solution",
                "content": "class Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        output = []\\n        \\n        cins = [index for index, value in enumerate(S) if value == C]\\n        print(cins)\\n        for i in range(len(S)) :\\n            if i in cins :\\n                output.append(0)\\n            else :\\n                output.append(min(map(lambda x : abs(x-i),cins)))\\n            \\n        return output\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        output = []\\n        \\n        cins = [index for index, value in enumerate(S) if value == C]\\n        print(cins)\\n        for i in range(len(S)) :\\n            if i in cins :\\n                output.append(0)\\n            else :\\n                output.append(min(map(lambda x : abs(x-i),cins)))\\n            \\n        return output\\n",
                "codeTag": "Java"
            },
            {
                "id": 416688,
                "title": "simple-intuitive-solution-c",
                "content": "Just keep a check on places of occurences of \\'C\\' and greedily choose the shortest (to left or right)\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> es;\\n        \\n        if(S.size()==1)\\n        {\\n            return {0};\\n        }\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            if(S[i]==C)\\n            {\\n                es.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans(S.size());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(es.size()>1 && abs(i-*es.begin())>abs(i-*(es.begin()+1)))\\n            {\\n                es.erase(es.begin());\\n            }\\n            ans[i]=abs(i-*es.begin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> es;\\n        \\n        if(S.size()==1)\\n        {\\n            return {0};\\n        }\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            if(S[i]==C)\\n            {\\n                es.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans(S.size());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(es.size()>1 && abs(i-*es.begin())>abs(i-*(es.begin()+1)))\\n            {\\n                es.erase(es.begin());\\n            }\\n            ans[i]=abs(i-*es.begin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411160,
                "title": "python-3-o-1-auxiliary-space-one-traversal-algorithm",
                "content": "Instead of keeping O(2N) minimum distance list by traversing twice, I just kept the length of the substring that exists between the character C or edge and output the distance.\\n```\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        r, seen_c, l = [], False, 0\\n        for w in S:\\n            if w == C:\\n                if seen_c:                              # C\"substring\"C\\n                    for i in range(1,l//2+1):\\n                        r.append(i)\\n                    for i in range(l//2+l%2,0,-1):\\n                        r.append(i)\\n                else:                                     # [\"substring\"C\\n                    for i in range(l,0,-1):\\n                        r.append(i)\\n                seen_c, l = True, 0\\n                r.append(0)\\n            else:\\n                l += 1\\n        for i in range(1,l+1):               # C\"substring\"]\\n            r.append(i)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        r, seen_c, l = [], False, 0\\n        for w in S:\\n            if w == C:\\n                if seen_c:                              # C\"substring\"C\\n                    for i in range(1,l//2+1):\\n                        r.append(i)\\n                    for i in range(l//2+l%2,0,-1):\\n                        r.append(i)\\n                else:                                     # [\"substring\"C\\n                    for i in range(l,0,-1):\\n                        r.append(i)\\n                seen_c, l = True, 0\\n                r.append(0)\\n            else:\\n                l += 1\\n        for i in range(1,l+1):               # C\"substring\"]\\n            r.append(i)\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363065,
                "title": "python-bfs-on-graph-commented-and-explained",
                "content": "**Idea**\\n- Shortest distance to a character === Shortest distance from a character\\n- build uniform graph and run a BFS algo\\n- keep a variable r outside the loop to keep track of raduis\\n\\n**## initial ##**\\n- Not aware that the special char could occur multiple times in the string, I intilaly built a graph in which each node is simply a char in S and did a BFS. This approach of building a graph would work only if the characters in the string were unique (duplicates not allowed)\\n\\n**## Modified ##**\\n- In order to count for duplicates, now we must allow duplictaes in the graph. So, Instead of building a graph of chars where a node = char, we make a graph in which each node represents a (char, index) pair. Now we need to run BFS as many times as C occures in S and \\n\\n**Steps**\\n- Build a graph that allows duplicates - node = (char, index) pair\\n- Iterate iver the string S and for every encounter of the desired char C -> run a BFS on the graph with C as the starting point in the queue\\n- keep track of min distance of every char from C in a dictionary\\n\\n**Example to demonstarte idea:**\\nS = \"lovely\", C = \"L\"\\n\\nl   o   v   e   l   y\\n0  1  2   3  4  5  -> distances from C when C = the first incident of l at index 0\\n4  3  2   1  0  1  -> distances from C when C = second incident of l at index 4\\n0  1  2   1  0  1  -> the smaller of the two distances above is the final distance we need to return\\n\\n**Visuals**\\n- ![image](https://assets.leetcode.com/users/abadawi/image_1566317520.png)\\n- ![image](https://assets.leetcode.com/users/abadawi/image_1566317527.png)\\n\\n**Code**\\n\\n```\\ndef shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        # build graph:\\n        from collections import defaultdict\\n        d = defaultdict(set)\\n        for i in range(1, len(S)-1):\\n            if i+1 >= 0 and i+1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i+1], i+1))\\n                d[(S[i+1], i+1)].add((S[i], i)) # undirected\\n            if i-1 >= 0 and i-1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i-1], i-1))\\n                d[(S[i-1], i-1)].add((S[i], i)) # undirected\\n        \\n        # helper bfs #\\n        def bfs(srcNode): # src node format -> (char, index)\\n            from collections import deque\\n            q = deque()\\n            q.append((srcNode, 0)) # node, r\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    node, r = q.popleft()\\n                    visited.add(node)\\n                    # process/update the distances dict\\n                    if node not in distances:\\n                        distances[node] = r\\n                    else:\\n                        if r < distances[node]:\\n                            distances[node] = r\\n                    # expand raduis of bfs\\n                    for nei in d[node]:\\n                        if nei not in visited:\\n                            q.append((nei, r+1))       \\n        \\n        distances = {}\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                bfs((S[i], i))\\n        \\n        # Empty distances dict into list:\\n        res = []\\n        for i in range(len(S)):\\n            res.append(distances[(S[i], i)])\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        # build graph:\\n        from collections import defaultdict\\n        d = defaultdict(set)\\n        for i in range(1, len(S)-1):\\n            if i+1 >= 0 and i+1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i+1], i+1))\\n                d[(S[i+1], i+1)].add((S[i], i)) # undirected\\n            if i-1 >= 0 and i-1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i-1], i-1))\\n                d[(S[i-1], i-1)].add((S[i], i)) # undirected\\n        \\n        # helper bfs #\\n        def bfs(srcNode): # src node format -> (char, index)\\n            from collections import deque\\n            q = deque()\\n            q.append((srcNode, 0)) # node, r\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    node, r = q.popleft()\\n                    visited.add(node)\\n                    # process/update the distances dict\\n                    if node not in distances:\\n                        distances[node] = r\\n                    else:\\n                        if r < distances[node]:\\n                            distances[node] = r\\n                    # expand raduis of bfs\\n                    for nei in d[node]:\\n                        if nei not in visited:\\n                            q.append((nei, r+1))       \\n        \\n        distances = {}\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                bfs((S[i], i))\\n        \\n        # Empty distances dict into list:\\n        res = []\\n        for i in range(len(S)):\\n            res.append(distances[(S[i], i)])\\n        return res\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 359339,
                "title": "java-sliding-window-2-pass-full-details",
                "content": "The 1st pattern that came to mind was to use a **Sliding Window**. We can do it T:O(n), S:O(n) like the accepted solution. The below Java code runs in 1ms. It uses 2 pointers to check for the closest occurence of C from i and the second closest occurence of C (if it exists) from i. Here, we also get the *Mininimum Absolute Distance* between *(curr - i)* and *(next - i)*. As soon as i is closer to next that it is to curr, we update curr with next and next with the next occurene of C (if it exists) in the list of occurences we created earlier.\\n\\n**Algo:**\\n\\n1.  Store all occurences of C in S into a list\\n2.  Go through S once by checking for Min_Absolute_Distance(curr - i, next - i)\\n3.  Update curr and next accordingly as soon as i is closer to next than curr\\n\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];\\n        \\n        // Handle edge cases (0, null, etc)\\n        if (S == null || S.length() == 0)\\n            return output;\\n                                \\n        // Store all positions of C in S\\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n                        \\n        // Sliding window  \\n        int j = 0;\\n        int curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }   \\n        \\n        return output;\\n    }     \\n}\\n```\\nCompact version:\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];        \\n        if (S == null || S.length() == 0) return output;\\n                            \\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n \\n        int j = 0,curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }           \\n        return output;\\n    }     \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];\\n        \\n        // Handle edge cases (0, null, etc)\\n        if (S == null || S.length() == 0)\\n            return output;\\n                                \\n        // Store all positions of C in S\\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n                        \\n        // Sliding window  \\n        int j = 0;\\n        int curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }   \\n        \\n        return output;\\n    }     \\n}\\n```\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];        \\n        if (S == null || S.length() == 0) return output;\\n                            \\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n \\n        int j = 0,curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }           \\n        return output;\\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325759,
                "title": "c-solution-o-n",
                "content": "C# solution. o(n)\\n```\\npublic int[] ShortestToChar(string S, char C) {\\n        int[] result = new int[S.Length];\\n        int head = S.Length + 1;\\n        int tail = S.Length + 1;\\n        \\n        for (int i = 0, j = S.Length - 1; i < S.Length; i++, j--)\\n        {\\n            if (S[i] == C)\\n            {\\n                head = 0;\\n            }\\n            \\n            if (S[j] == C)\\n            {\\n                tail = 0;\\n            }\\n            \\n            if(i < j)\\n            {\\n                result[i] = head++;\\n                result[j] = tail++;\\n            }\\n            else if(i == j)\\n            {\\n                result[i] = Math.Min(head++, tail++);\\n            }\\n            else \\n            {\\n                result[i] = Math.Min(head++, result[i]);\\n                result[j] = Math.Min(tail++, result[j]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ShortestToChar(string S, char C) {\\n        int[] result = new int[S.Length];\\n        int head = S.Length + 1;\\n        int tail = S.Length + 1;\\n        \\n        for (int i = 0, j = S.Length - 1; i < S.Length; i++, j--)\\n        {\\n            if (S[i] == C)\\n            {\\n                head = 0;\\n            }\\n            \\n            if (S[j] == C)\\n            {\\n                tail = 0;\\n            }\\n            \\n            if(i < j)\\n            {\\n                result[i] = head++;\\n                result[j] = tail++;\\n            }\\n            else if(i == j)\\n            {\\n                result[i] = Math.Min(head++, tail++);\\n            }\\n            else \\n            {\\n                result[i] = Math.Min(head++, result[i]);\\n                result[j] = Math.Min(tail++, result[j]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324885,
                "title": "python-easy-two-passes-solution",
                "content": "99.7% speed\\n```\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        indc, dis = float(\\'-inf\\'), [0] * len(S)\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                indc = i\\n            dis[i] = i - indc\\n        \\n        indc = float(\\'inf\\')\\n        for j in range(len(dis))[::-1]:\\n            if S[j] == C:\\n                indc = j\\n            dis[j] = min(dis[j], indc-j)\\n        \\n        return dis\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        indc, dis = float(\\'-inf\\'), [0] * len(S)\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                indc = i\\n            dis[i] = i - indc\\n        \\n        indc = float(\\'inf\\')\\n        for j in range(len(dis))[::-1]:\\n            if S[j] == C:\\n                indc = j\\n            dis[j] = min(dis[j], indc-j)\\n        \\n        return dis\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285409,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        return [min([abs(j-i) for j in [x for x,y in enumerate(S) if y==C]]) for i in range(len(S))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        return [min([abs(j-i) for j in [x for x,y in enumerate(S) if y==C]]) for i in range(len(S))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205746,
                "title": "python-easy-to-understand",
                "content": "```\\ndef shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        if C not in S:\\n            return []\\n        ans = [-1] * len(S)\\n        start = float(\"Inf\")\\n        ind = []\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                ans[i] = 0\\n                ind.append(i)\\n        if len(S) > ind[-1] + 1:\\n            ind.append(float(\"Inf\"))\\n        for j in range(len(S)):\\n            if S[j] != C:\\n                ans[j] = min(abs(j-start), abs(j-ind[0]))\\n            else:\\n                start = ind[0]\\n                ind.pop(0)\\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        if C not in S:\\n            return []\\n        ans = [-1] * len(S)\\n        start = float(\"Inf\")\\n        ind = []\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                ans[i] = 0\\n                ind.append(i)\\n        if len(S) > ind[-1] + 1:\\n            ind.append(float(\"Inf\"))\\n        for j in range(len(S)):\\n            if S[j] != C:\\n                ans[j] = min(abs(j-start), abs(j-ind[0]))\\n            else:\\n                start = ind[0]\\n                ind.pop(0)\\n        return ans\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 156216,
                "title": "2-pass-solution-in-c-beats-100-submissions",
                "content": "For a given element at position `i`, it\\'s shortest distance to the `C` is `min(shortest_distance_to_left_occuence[i], shortest_distance_to_right_occurence[i])`, where `shortest_distance_to_left_occurence[i] = 0 if S[i] == C else shortest_distance_to_left_occurence[i-1] + 1`. Similarly `shortest_distance_to_right_occurence[i] = 0 if S[i] == C else shortest_distance_to_left_occurence[i+1] + 1`.\\n\\nFirst pass keeps track of the shortest distance to the left occurence of the `C` and second pass takes into account right occurences of `C`.\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> distance(S.size(), S.size());\\n        for (int i = 0; i < S.size(); ++i) {\\n            if (S[i] == C) {\\n                distance[i] = 0;\\n            } else if (i > 0) {\\n                distance[i] = distance[i-1] + 1;\\n            }\\n        }\\n        for (int i = S.size() - 2; i >= 0; --i) {\\n            distance[i] = min(distance[i], distance[i+1] + 1);\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> distance(S.size(), S.size());\\n        for (int i = 0; i < S.size(); ++i) {\\n            if (S[i] == C) {\\n                distance[i] = 0;\\n            } else if (i > 0) {\\n                distance[i] = distance[i-1] + 1;\\n            }\\n        }\\n        for (int i = S.size() - 2; i >= 0; --i) {\\n            distance[i] = min(distance[i], distance[i+1] + 1);\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128296,
                "title": "python-solution-from-a-beginner",
                "content": "I am new to Python, I know it is not the most efficient way...but hope you enjoy. :)\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        myList = [i for i,letter in enumerate(S) if letter == C]\\n        result = []\\n        for i in range(len(S)):\\n            min_pos = []\\n            for j in myList:\\n                min_pos.append(abs(j-i))\\n            result.append(min(min_pos))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        myList = [i for i,letter in enumerate(S) if letter == C]\\n        result = []\\n        for i in range(len(S)):\\n            min_pos = []\\n            for j in myList:\\n                min_pos.append(abs(j-i))\\n            result.append(min(min_pos))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125801,
                "title": "python-o-n-solution",
                "content": "* Idea is to move from left to right, right to left and update distance related to seen character\\n``` \\nclass Solution:\\n    def shortestToChar(self, s, c):\\n        res = [float(\"inf\")] * len(s)\\n        dx = 1\\n        cur = i = 0\\n        while i > -1:\\n            if cur:\\n                res[i] = min(res[i], cur)\\n                cur += 1\\n            if s[i] == c:\\n                res[i] = 0\\n                cur = 1\\n            i += dx\\n            if i == len(s):\\n                dx = -1\\n                cur = 0\\n                i -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def shortestToChar(self, s, c):\\n        res = [float(\"inf\")] * len(s)\\n        dx = 1\\n        cur = i = 0\\n        while i > -1:\\n            if cur:\\n                res[i] = min(res[i], cur)\\n                cur += 1\\n            if s[i] == c:\\n                res[i] = 0\\n                cur = 1\\n            i += dx\\n            if i == len(s):\\n                dx = -1\\n                cur = 0\\n                i -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034738,
                "title": "best-java-solution-beats-60",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shortestToChar(String str, char c) {\\n        StringBuilder s = new StringBuilder(str);\\n\\n        int ans[] = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n                continue;\\n            }\\n            String s1 = s.substring(0,i);\\n            String s2 = s.substring(i+1);\\n\\n            int a = s1.lastIndexOf(c);\\n            int b = s2.indexOf(c);\\n\\n            if(a==-1) a = Integer.MAX_VALUE;\\n            else a = s1.length()-a;\\n\\n            if(b==-1) b = Integer.MAX_VALUE;\\n            else b = b+1;\\n\\n\\n            ans[i] = Math.min(a,b);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String str, char c) {\\n        StringBuilder s = new StringBuilder(str);\\n\\n        int ans[] = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n                continue;\\n            }\\n            String s1 = s.substring(0,i);\\n            String s2 = s.substring(i+1);\\n\\n            int a = s1.lastIndexOf(c);\\n            int b = s2.indexOf(c);\\n\\n            if(a==-1) a = Integer.MAX_VALUE;\\n            else a = s1.length()-a;\\n\\n            if(b==-1) b = Integer.MAX_VALUE;\\n            else b = b+1;\\n\\n\\n            ans[i] = Math.min(a,b);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899350,
                "title": "simple-solution-using-two-pointers-o-n-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using two pointer approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We need to store previous and next closest occurrence of the character `c` in both the sides of the current index, `i`.\\n- `previous` will have the closest occurrence of `c` to the left side of `i`.\\n- `next` will have the closest occurrence of `c` to the right side of `i`. \\n- Everytime `i` moves past `next`, the following operations will be made\\n  * `prev = next` \\n  * `next` moves forward in searching the next occurrence of `c` \\n- At every index, the absolute minumum of `next - i` and `i - previous` gives the shortest distance to `c` \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) (for result array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        \\n        // Find the first occurrence of c\\n        int next = moveForward(s, c, 0);\\n        int previous = next;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (i > next) {\\n                previous = next;\\n                next = moveForward(s, c, next + 1);\\n            }\\n\\n            result[i] = Math.abs(Math.min(next - i, i - previous));\\n        }\\n\\n        return result;\\n    }\\n\\n    private int moveForward(String s, char c, int position) {\\n        while(position < s.length()) {\\n            if (s.charAt(position) == c) {\\n                break;\\n            }\\n            ++position;\\n        }\\n\\n        // When `c` does not occur further in the string, return MAX value\\n        // This makes `previous` as the only valid closest occurrence\\n        if (position == s.length()) {\\n            return Integer.MAX_VALUE;\\n        }\\n        return position;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        \\n        // Find the first occurrence of c\\n        int next = moveForward(s, c, 0);\\n        int previous = next;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (i > next) {\\n                previous = next;\\n                next = moveForward(s, c, next + 1);\\n            }\\n\\n            result[i] = Math.abs(Math.min(next - i, i - previous));\\n        }\\n\\n        return result;\\n    }\\n\\n    private int moveForward(String s, char c, int position) {\\n        while(position < s.length()) {\\n            if (s.charAt(position) == c) {\\n                break;\\n            }\\n            ++position;\\n        }\\n\\n        // When `c` does not occur further in the string, return MAX value\\n        // This makes `previous` as the only valid closest occurrence\\n        if (position == s.length()) {\\n            return Integer.MAX_VALUE;\\n        }\\n        return position;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765194,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, i + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, i + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566001,
                "title": "two-pointer-o-n-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Using two pointer approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->We will have two pointers, and change them over when the right one will be more closer, the right one will become left pointer , and we\\'ll get a  new right pointer if there exists one.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) {for solution array only}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int[] shortestToChar(String s, char c)\\n    {\\n        char[] arr=s.toCharArray();\\n        boolean f2=false; //flag for telling if there is second right available\\n        int ptr1=0,ptr2=0;\\n        for(int i=0;i<arr.length;i++) //gets the first occurence\\n            if(c==arr[i])\\n            {\\n                ptr1=i;\\n                break;\\n            }\\n\\n        for(int i=ptr1+1;i<arr.length;i++) //gets the second occurence if there is one , thats why the flag is used which is false by default\\n            if(c==arr[i])\\n            {\\n                ptr2=i;\\n                f2=true;\\n                break;\\n            }\\n\\n        int[] result=new int[s.length()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(f2) //if second occurence exists\\n            {\\n                if((Math.abs(ptr1-i)>=(Math.abs(ptr2-i)))) //gets triggered if the right one is more closer or equally closer\\n                { //inside we are changing the pointers\\n                    int j;\\n                    boolean flag=false; //tells if we have another occurence of given character\\n                    for(j=ptr2+1;j<arr.length;j++)\\n                        if(arr[j]==c)\\n                        {\\n                            flag=true;\\n                            break;\\n                        }\\n                    if(flag) //updates both pointers if we get an occurence\\n                    {\\n                        ptr1=ptr2;\\n                        ptr2=j;\\n                    }\\n                    else //else only ptr1 will be changed , and this this if will not be triggered again\\n                    {\\n                        ptr1=ptr2;\\n                        f2=false;\\n                    }\\n                }\\n            }\\n            result[i]=Math.abs(ptr1-i);\\n        }\\n        return result\\n        ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[] shortestToChar(String s, char c)\\n    {\\n        char[] arr=s.toCharArray();\\n        boolean f2=false; //flag for telling if there is second right available\\n        int ptr1=0,ptr2=0;\\n        for(int i=0;i<arr.length;i++) //gets the first occurence\\n            if(c==arr[i])\\n            {\\n                ptr1=i;\\n                break;\\n            }\\n\\n        for(int i=ptr1+1;i<arr.length;i++) //gets the second occurence if there is one , thats why the flag is used which is false by default\\n            if(c==arr[i])\\n            {\\n                ptr2=i;\\n                f2=true;\\n                break;\\n            }\\n\\n        int[] result=new int[s.length()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(f2) //if second occurence exists\\n            {\\n                if((Math.abs(ptr1-i)>=(Math.abs(ptr2-i)))) //gets triggered if the right one is more closer or equally closer\\n                { //inside we are changing the pointers\\n                    int j;\\n                    boolean flag=false; //tells if we have another occurence of given character\\n                    for(j=ptr2+1;j<arr.length;j++)\\n                        if(arr[j]==c)\\n                        {\\n                            flag=true;\\n                            break;\\n                        }\\n                    if(flag) //updates both pointers if we get an occurence\\n                    {\\n                        ptr1=ptr2;\\n                        ptr2=j;\\n                    }\\n                    else //else only ptr1 will be changed , and this this if will not be triggered again\\n                    {\\n                        ptr1=ptr2;\\n                        f2=false;\\n                    }\\n                }\\n            }\\n            result[i]=Math.abs(ptr1-i);\\n        }\\n        return result\\n        ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317704,
                "title": "c-unique-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>indexes;\\n        vector<int>sol;\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n\\n        return sol;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>indexes;\\n        vector<int>sol;\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n\\n        return sol;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316847,
                "title": "shortest-distance-to-a-character-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j;\\n        vector<int> ans;\\n        vector<int> pos;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos.push_back(i);\\n            }\\n        }\\n        j=0;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(j==pos.size()-1)\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else if(abs(i-pos[j])>abs(i-pos[j+1]))\\n            {\\n                j++;\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j;\\n        vector<int> ans;\\n        vector<int> pos;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos.push_back(i);\\n            }\\n        }\\n        j=0;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(j==pos.size()-1)\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else if(abs(i-pos[j])>abs(i-pos[j+1]))\\n            {\\n                j++;\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316820,
                "title": "shortest-distance-to-a-character-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j, k, min;\\n        vector<int> ans;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            min = 100000;\\n            for(j=0 ; j<s.length() ; j++)\\n            {\\n                if(s[j]==c && abs(i-j)<min)\\n                {\\n                    min = abs(i-j);\\n                    for(k=j+1 ; k<s.length() ; k++)\\n                    {\\n                        if(s[k]==c && abs(k-i)<min)\\n                        {\\n                            min = abs(k-i);\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(min);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j, k, min;\\n        vector<int> ans;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            min = 100000;\\n            for(j=0 ; j<s.length() ; j++)\\n            {\\n                if(s[j]==c && abs(i-j)<min)\\n                {\\n                    min = abs(i-j);\\n                    for(k=j+1 ; k<s.length() ; k++)\\n                    {\\n                        if(s[k]==c && abs(k-i)<min)\\n                        {\\n                            min = abs(k-i);\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(min);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149079,
                "title": "best-explained-solution",
                "content": "\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Go",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901189,
                "title": "javascript-js-simple-easy-to-understand",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, prev + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, prev + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874523,
                "title": "python3-long-but-fast-faster-than-97-10",
                "content": "# Code\\n```\\nclass Solution:\\n    def getIndicies(self, s, c):\\n        indicies = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                indicies.append(i)\\n        return indicies\\n    def getShortest(self, idx, indicies):\\n        if idx in indicies: return 0\\n        if idx < indicies[0]: return abs(idx - indicies[0])\\n        elif idx > indicies[-1]: return abs(indicies[-1] - idx)\\n        for index in range(len(indicies)):\\n            if indicies[index] > idx:\\n                minDistance = min(abs(idx - indicies[index]), abs(idx - indicies[index - 1]))\\n                return minDistance\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        indicies = sorted(self.getIndicies(s, c), key=lambda x:x)\\n        result = []\\n        for i in range(len(s)):\\n            result.append(self.getShortest(i, indicies))\\n        return result\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/821d480c-a58b-418b-8032-8aec83439aa7_1670107858.6099043.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIndicies(self, s, c):\\n        indicies = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                indicies.append(i)\\n        return indicies\\n    def getShortest(self, idx, indicies):\\n        if idx in indicies: return 0\\n        if idx < indicies[0]: return abs(idx - indicies[0])\\n        elif idx > indicies[-1]: return abs(indicies[-1] - idx)\\n        for index in range(len(indicies)):\\n            if indicies[index] > idx:\\n                minDistance = min(abs(idx - indicies[index]), abs(idx - indicies[index - 1]))\\n                return minDistance\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        indicies = sorted(self.getIndicies(s, c), key=lambda x:x)\\n        result = []\\n        for i in range(len(s)):\\n            result.append(self.getShortest(i, indicies))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632244,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n  = s.length();\\n        vector<int > res(n,INT_MAX),v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == c){\\n                res[i] = 0;\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=c)\\n            {\\n                for(int j=0;j<v.size();j++)\\n                {\\n                    res[i] = min(res[i],abs(v[j]-i));\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n  = s.length();\\n        vector<int > res(n,INT_MAX),v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == c){\\n                res[i] = 0;\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=c)\\n            {\\n                for(int j=0;j<v.size();j++)\\n                {\\n                    res[i] = min(res[i],abs(v[j]-i));\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592295,
                "title": "python-simplest-solution",
                "content": "```\\n\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp = []\\n        ind = s.index(c)\\n        for i in range(len(s)):\\n            if abs(ind-i)>abs(s.find(c,i)-i):\\n                ind = s.index(c,i)\\n            if s[i]!=c:\\n                temp.append(abs(ind-i))\\n            else:\\n                temp.append(0)\\n        return temp\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp = []\\n        ind = s.index(c)\\n        for i in range(len(s)):\\n            if abs(ind-i)>abs(s.find(c,i)-i):\\n                ind = s.index(c,i)\\n            if s[i]!=c:\\n                temp.append(abs(ind-i))\\n            else:\\n                temp.append(0)\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533533,
                "title": "o-1-space-prefix-suffix-with-comments",
                "content": "\\n# Python\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t    \"\"\"\\n        Q. Min/Max distance to closest character [left or right]\\n        \\n        Character can be present to left or right both\\n        \\n        1. Trace from left  to right & count distance from last char found\\n        2. Trace from right to left:\\n           Three cases would be there: \\n        \\n            Case1:  [a _ _ _ _ _ a]  -> already non-zero & flag true from right, take min\\n            Case2:  [a _ _ _ _ _ _]  -> already non-zero & flag false, then leave\\n            Case3:  [_ _ _ _ _ _ a]  -> already zero & flag true, update the sum  \\n        \"\"\"\\n        n= len(s)\\n        pre=  [0 for i in range(0,n)]\\n        flag= False\\n        \\n        for i in range(0,n):\\n            if s[i]==c: flag=True\\n            elif flag: pre[i]= pre[i-1]+1\\n        \\n        flag=False;\\n        \\n        for i in range(n-1,-1,-1):\\n            if s[i]==c: flag=True \\n            elif flag and pre[i]==0: pre[i]= pre[i+1]+1\\n            elif flag and pre[i]>0:   pre[i]= min(pre[i],pre[i+1]+1)        \\n        return pre",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n# Python\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t    \"\"\"\\n        Q. Min/Max distance to closest character [left or right]\\n        \\n        Character can be present to left or right both\\n        \\n        1. Trace from left  to right & count distance from last char found\\n        2. Trace from right to left:\\n           Three cases would be there: \\n        \\n            Case1:  [a _ _ _ _ _ a]  -> already non-zero & flag true from right, take min\\n            Case2:  [a _ _ _ _ _ _]  -> already non-zero & flag false, then leave\\n            Case3:  [_ _ _ _ _ _ a]  -> already zero & flag true, update the sum  \\n        \"\"\"\\n        n= len(s)\\n        pre=  [0 for i in range(0,n)]\\n        flag= False\\n        \\n        for i in range(0,n):\\n            if s[i]==c: flag=True\\n            elif flag: pre[i]= pre[i-1]+1\\n        \\n        flag=False;\\n        \\n        for i in range(n-1,-1,-1):\\n            if s[i]==c: flag=True \\n            elif flag and pre[i]==0: pre[i]= pre[i+1]+1\\n            elif flag and pre[i]>0:   pre[i]= min(pre[i],pre[i+1]+1)        \\n        return pre",
                "codeTag": "Python3"
            },
            {
                "id": 2497968,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans=new int[s.length()];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=c){\\n                for(int j=i+1;j<s.length();j++){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=j-i;\\n                        break;\\n                    }\\n                    \\n                }\\n                for(int j=i-1;j>=0;j--){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=Math.min(ans[i],Math.abs(i-j));\\n                        break;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans=new int[s.length()];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=c){\\n                for(int j=i+1;j<s.length();j++){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=j-i;\\n                        break;\\n                    }\\n                    \\n                }\\n                for(int j=i-1;j>=0;j--){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=Math.min(ans[i],Math.abs(i-j));\\n                        break;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467922,
                "title": "c-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> ans(s.size());\\n        int pos=-s.size();\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos=i;\\n            }\\n            ans[i]=i-pos;\\n        }\\n        for(int i=pos-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                pos=i;\\n            ans[i]=min(ans[i],pos-i);\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> ans(s.size());\\n        int pos=-s.size();\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2460480,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        vector<int>index;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int idx=i;\\n            int dis=INT_MAX;\\n            for(int j=0;j<index.size();j++)\\n            {\\n               dis=min(dis,abs(idx-index[j]));\\n            }\\n            ans.push_back(dis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        vector<int>index;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int idx=i;\\n            int dis=INT_MAX;\\n            for(int j=0;j<index.size();j++)\\n            {\\n               dis=min(dis,abs(idx-index[j]));\\n            }\\n            ans.push_back(dis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429280,
                "title": "2-simple-and-concise-python-solutions-with-in-depth-explanation",
                "content": "Solution 1:\\nWe will create a list called indices or storing the indices of c. Then we will find the closest absolute distance\\nbetween the current character and the c. We will use another list named res to store the result. Now we will run a for loop from i=0 to i=len(s). Every time we put minIndex to some random large number let\\'s say 99999. We have to choose this random number such that it is always greater than the len(s). In this for loop if s[i]==c i.e if currecnt character in s is equal to c then we know that the closest distacnce is obviously 0. If s[i] !=c , then we will run a for loop from the indices list which we got previously. This for loop checks for the minimum index among all the available indices. At last we will return our res list.  \\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        for i in range(len(s):\\n\\t\\t\\tif s[i]==c:\\n\\t\\t\\t\\tindices.append(i)\\n\\t    print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                for index in indices:\\n                    minIndex=min(abs(i-index),minIndex)\\n                res.append(minIndex)\\n        return res\\n```\\nSolution 2:\\nThis is same as solution 1 except that we use one liner for creating indices list and checking the minimum Index in the else part of for loop.\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        indices=[i for i, x in enumerate(s) if x == c]\\n        print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                res.append(min(abs(i-index) for index in indices))\\n        return res\\n```\\nPlease upvote if you like the solution. \\nConnect with me at https://www.linkedin.com/in/podilichaitanyaakhilkumar/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        for i in range(len(s):\\n\\t\\t\\tif s[i]==c:\\n\\t\\t\\t\\tindices.append(i)\\n\\t    print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                for index in indices:\\n                    minIndex=min(abs(i-index),minIndex)\\n                res.append(minIndex)\\n        return res\\n```\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        indices=[i for i, x in enumerate(s) if x == c]\\n        print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                res.append(min(abs(i-index) for index in indices))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416137,
                "title": "easy-javascript-solution-beats-92",
                "content": "```\\nvar shortestToChar = function(s, c) {\\n    const newarr = new Array(s.length).fill(null);\\n    let position = [];\\n    for(let i =0; i<s.length; i++) {\\n        if(s[i] === c) {\\n           position.push(i); \\n            newarr[i] = 0;\\n        }\\n    }\\n    let i =0;\\n    let j =0;\\n    while(i<s.length) {\\n        const currentVal = Math.abs(i - position[j]);\\n        const nextVal =  Math.abs(isNaN(i - position[j + 1]) ? i -position[j] : i - position[j + 1]);  \\n        if( currentVal < nextVal) {\\n            newarr[i] = s[i] === c ? 0 : currentVal\\n        } else {\\n            newarr[i] = s[i] === c ? 0 : nextVal\\n            if(j < position.length -1) {\\n             j++   \\n            }\\n            \\n        }\\n        i++\\n    }\\n    return newarr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(s, c) {\\n    const newarr = new Array(s.length).fill(null);\\n    let position = [];\\n    for(let i =0; i<s.length; i++) {\\n        if(s[i] === c) {\\n           position.push(i); \\n            newarr[i] = 0;\\n        }\\n    }\\n    let i =0;\\n    let j =0;\\n    while(i<s.length) {\\n        const currentVal = Math.abs(i - position[j]);\\n        const nextVal =  Math.abs(isNaN(i - position[j + 1]) ? i -position[j] : i - position[j + 1]);  \\n        if( currentVal < nextVal) {\\n            newarr[i] = s[i] === c ? 0 : currentVal\\n        } else {\\n            newarr[i] = s[i] === c ? 0 : nextVal\\n            if(j < position.length -1) {\\n             j++   \\n            }\\n            \\n        }\\n        i++\\n    }\\n    return newarr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379300,
                "title": "c-solution-easy-to-understand",
                "content": "\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> answer;\\n        int mi = INT_MAX;\\n        bool found = false;\\n        \\n        for(int i=0;i<s.length();i++) {\\n            found = false;\\n            mi = INT_MAX;\\n            for(int j=0;j<s.length();j++) {\\n                \\n\\t\\t\\t\\t//pushing 0 if the current index itself contains the required character\\n                if(s[i] == c) {\\n                    answer.push_back(0);\\n                    break;\\n                }\\n                \\n\\t\\t\\t\\t//storing minimum distance everytime the character is found\\n                if(s[j] == c) {\\n                    mi = min(mi, abs(i-j));\\n                    found = true;\\n                }\\n                \\n\\t\\t\\t\\t//when the whole string is iterated and we found the matching character atleast once\\n                if(found && j==s.length()-1) {\\n                    answer.push_back(mi);\\n                    break;\\n                }           \\n            }         \\n        }\\n        return answer;\\n     }",
                "solutionTags": [],
                "code": "\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> answer;\\n        int mi = INT_MAX;\\n        bool found = false;\\n        \\n        for(int i=0;i<s.length();i++) {\\n            found = false;\\n            mi = INT_MAX;\\n            for(int j=0;j<s.length();j++) {\\n                \\n\\t\\t\\t\\t//pushing 0 if the current index itself contains the required character\\n                if(s[i] == c) {\\n                    answer.push_back(0);\\n                    break;\\n                }\\n                \\n\\t\\t\\t\\t//storing minimum distance everytime the character is found\\n                if(s[j] == c) {\\n                    mi = min(mi, abs(i-j));\\n                    found = true;\\n                }\\n                \\n\\t\\t\\t\\t//when the whole string is iterated and we found the matching character atleast once\\n                if(found && j==s.length()-1) {\\n                    answer.push_back(mi);\\n                    break;\\n                }           \\n            }         \\n        }\\n        return answer;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 2283509,
                "title": "python-simple-solution-explained",
                "content": "Hello,\\n\\nI did submit my simple solution.\\n\\nI try to find all the **indexes** of the **character** and then i loop over the string again to calculate the shortest distance based of the **indexes**. \\n\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res = []\\n        index = []\\n        for i in range(len(s)):\\n            if s[i]  == c:\\n                index.append(i)\\n        for i in range(len(s)):\\n            if len(index) > 1:\\n                if abs(i-index[0])>abs(i-index[1]):\\n                    index.pop(0)\\n            res.append(abs(i-index[0]))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res = []\\n        index = []\\n        for i in range(len(s)):\\n            if s[i]  == c:\\n                index.append(i)\\n        for i in range(len(s)):\\n            if len(index) > 1:\\n                if abs(i-index[0])>abs(i-index[1]):\\n                    index.pop(0)\\n            res.append(abs(i-index[0]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260097,
                "title": "two-pass-technique-c-o-n-o-1",
                "content": "```\\n// Two pass technique:\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n, -1);\\n        \\n        // from right to left, maintain lastOccurence of c and update ans[i] accordingly.\\n        int lastOcc = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == c){\\n                lastOcc = i;\\n                ans[i] = 0;\\n            } \\n            else{\\n                ans[i] = abs(lastOcc - i);\\n            }\\n        }\\n        \\n         // from left to right, maintain firstOccurence of c and update ans[i] accordingly if found minimum.\\n        int firstOcc = lastOcc;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == c){\\n                firstOcc = i;\\n                ans[i] = 0;\\n            }\\n            else{\\n                ans[i] = min(ans[i], abs(firstOcc - i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Two pass technique:\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n, -1);\\n        \\n        // from right to left, maintain lastOccurence of c and update ans[i] accordingly.\\n        int lastOcc = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == c){\\n                lastOcc = i;\\n                ans[i] = 0;\\n            } \\n            else{\\n                ans[i] = abs(lastOcc - i);\\n            }\\n        }\\n        \\n         // from left to right, maintain firstOccurence of c and update ans[i] accordingly if found minimum.\\n        int firstOcc = lastOcc;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == c){\\n                firstOcc = i;\\n                ans[i] = 0;\\n            }\\n            else{\\n                ans[i] = min(ans[i], abs(firstOcc - i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207577,
                "title": "easy-o-n",
                "content": "```\\nfunc shortestToChar(s string, c byte) []int {\\n    var res []int\\n    \\n    firstOccurennce, lastOccurence := -1, -1\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            if firstOccurennce == -1 {\\n                firstOccurennce = i\\n            }\\n            \\n            lastOccurence = i\\n        }\\n    }\\n\\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            res = append(res, 0)\\n            firstOccurennce = i\\n        } else {\\n            res = append(res, abs(i - firstOccurennce))\\n        }\\n    }\\n    \\n    for i := len(s) - 1; i > -1; i-- {\\n        if s[i] == c {\\n            lastOccurence = i\\n        } else {\\n            res[i] = min(res[i], abs(i - lastOccurence))\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 {\\n        return a\\n    }\\n    \\n    return -a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Go"
                ],
                "code": "```\\nfunc shortestToChar(s string, c byte) []int {\\n    var res []int\\n    \\n    firstOccurennce, lastOccurence := -1, -1\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            if firstOccurennce == -1 {\\n                firstOccurennce = i\\n            }\\n            \\n            lastOccurence = i\\n        }\\n    }\\n\\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            res = append(res, 0)\\n            firstOccurennce = i\\n        } else {\\n            res = append(res, abs(i - firstOccurennce))\\n        }\\n    }\\n    \\n    for i := len(s) - 1; i > -1; i-- {\\n        if s[i] == c {\\n            lastOccurence = i\\n        } else {\\n            res[i] = min(res[i], abs(i - lastOccurence))\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 {\\n        return a\\n    }\\n    \\n    return -a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117263,
                "title": "javascript-infinity-solution-2-pointers-v-s-2-pass",
                "content": "**2 Pointers**\\n\\nRecord all indexes of `c`, then determine the **NEAREST distance from BOTH SIDES** for each `s[i]`.\\n> Note: for BOUNDARY condition, I add `-Infinity` and `Infinity` at both ends.\\n\\n```\\ns=loveleetcode, c=\"e\"\\nind=[-Infinity,3,5,6,11,Infinity]\\n\\ns[0]~[3]:  compare i with left=-Infinity, right=3\\ns[4]~[5]:  compare i with left=3, right=5\\ns[6]:      compare i with left=5, right=6\\ns[7]~[11]: compare i with left=6, right=11\\n```\\n\\n```\\nvar shortestToChar = function(s, c) {\\n    let ind=[-Infinity];\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]==c){ind.push(i)};\\n    }\\n    ind.push(Infinity);\\n\\t\\n    let now=0, output=[];\\n    for(let j=0; j<s.length; j++){\\n        if(j>ind[now]){now++};\\n\\t\\t// now-1=LEFT pointer, now=RIGHT pointer\\n        output.push(Math.min(Math.abs(j-ind[now-1]), Math.abs(j-ind[now])));\\n    }\\n    return output;\\n};\\n```\\n\\n**2 Pass**\\n\\nLoop from left to get **NEAREST distance from LEFT**.\\nThen loop from right again, update the **MINIMUM of two**.\\n```\\ns=loveleetcode, c=\"e\"\\n            l o v e l e e t c o d e\\nfrom left   X X X 0 1 0 0 1 2 3 4 0\\nfrom right  3 2 1 0 1 0 0 4 3 2 1 0\\nMIN         3 2 1 0 1 0 0 1 2 2 1 0\\n```\\n\\n```\\nvar shortestToChar = function(s, c) {\\n    let output=[], dis=Infinity;\\n    for(let i=0; i<s.length; i++){\\n        dis=s[i]==c? 0: ++dis;\\n        output.push(dis);\\n    }\\n    dis=Infinity;\\n    for(let j=s.length-1; j>=0; j--){\\n        dis=s[j]==c? 0: ++dis;\\n\\t\\t// compare MIN of dis(left) & dis(right)\\n        output[j]=Math.min(dis, output[j]);\\n    }\\n    return output;\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\ns=loveleetcode, c=\"e\"\\nind=[-Infinity,3,5,6,11,Infinity]\\n\\ns[0]~[3]:  compare i with left=-Infinity, right=3\\ns[4]~[5]:  compare i with left=3, right=5\\ns[6]:      compare i with left=5, right=6\\ns[7]~[11]: compare i with left=6, right=11\\n```\n```\\nvar shortestToChar = function(s, c) {\\n    let ind=[-Infinity];\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]==c){ind.push(i)};\\n    }\\n    ind.push(Infinity);\\n\\t\\n    let now=0, output=[];\\n    for(let j=0; j<s.length; j++){\\n        if(j>ind[now]){now++};\\n\\t\\t// now-1=LEFT pointer, now=RIGHT pointer\\n        output.push(Math.min(Math.abs(j-ind[now-1]), Math.abs(j-ind[now])));\\n    }\\n    return output;\\n};\\n```\n```\\ns=loveleetcode, c=\"e\"\\n            l o v e l e e t c o d e\\nfrom left   X X X 0 1 0 0 1 2 3 4 0\\nfrom right  3 2 1 0 1 0 0 4 3 2 1 0\\nMIN         3 2 1 0 1 0 0 1 2 2 1 0\\n```\n```\\nvar shortestToChar = function(s, c) {\\n    let output=[], dis=Infinity;\\n    for(let i=0; i<s.length; i++){\\n        dis=s[i]==c? 0: ++dis;\\n        output.push(dis);\\n    }\\n    dis=Infinity;\\n    for(let j=s.length-1; j>=0; j--){\\n        dis=s[j]==c? 0: ++dis;\\n\\t\\t// compare MIN of dis(left) & dis(right)\\n        output[j]=Math.min(dis, output[j]);\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2107104,
                "title": "821-shortest-distance-to-a-character-array-java-solution",
                "content": "Hi, in this problem i follow below steps :------>\\n\\n*First create a list to store the location of character c in given array.\\n*Create an array for result and the traverse again the array and calculate the minimum distance using created list. See Below Code ---->\\n\\nHappy Coding :)\\n\\nCODE ------>\\n\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        int n = s.length();\\n        \\n        list.add(-10000);\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i)==c){\\n                list.add(i);\\n            }\\n        }\\n        list.add(10000);\\n        \\n        int first = list.get(0);\\n        int second = list.get(1);\\n        int j = 2;\\n        int[] res = new int[n];\\n        \\n        for (int i=0; i<n; i++){\\n            if(s.charAt(i)!=c){\\n                res[i] = Math.min(i-first, second-i);\\n            }else{\\n                first = second;\\n                second = list.get(j++);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        int n = s.length();\\n        \\n        list.add(-10000);\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i)==c){\\n                list.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2078271,
                "title": "java-1ms-99-09",
                "content": "```\\nclass Solution {\\n    int getIndex(String s, char c, int start){\\n        for(int i = start;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        int prev = getIndex(s, c, 0);\\n        int next = prev;\\n        \\n        for (int k = 0; k<s.length(); k++){\\n            ans[k] = Math.min(Math.abs(k-prev), Math.abs(next-k));\\n            if(next==k){\\n                prev = next;\\n                next = getIndex(s,c,k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    int getIndex(String s, char c, int start){\\n        for(int i = start;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        int prev = getIndex(s, c, 0);\\n        int next = prev;\\n        \\n        for (int k = 0; k<s.length(); k++){\\n            ans[k] = Math.min(Math.abs(k-prev), Math.abs(next-k));\\n            if(next==k){\\n                prev = next;\\n                next = getIndex(s,c,k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025617,
                "title": "java-too-easy-solution",
                "content": "//do upvote :)\\n\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int ans[]=new int[s.length()];\\n        ArrayList<Integer> li=new ArrayList<>();\\n        //Store the index of the character\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                li.add(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<li.size();j++){\\n                int x=Math.abs(i-li.get(j));\\n                if(x<min){\\n                    min=x;\\n                }\\n            }\\n            ans[i]=min;\\n        }\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int ans[]=new int[s.length()];\\n        ArrayList<Integer> li=new ArrayList<>();\\n        //Store the index of the character\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                li.add(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<li.size();j++){\\n                int x=Math.abs(i-li.get(j));\\n                if(x<min){\\n                    min=x;\\n                }\\n            }\\n            ans[i]=min;\\n        }\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2022757,
                "title": "it-s-beginner-s-thinking",
                "content": "\\tc_index = [i for i, value in enumerate(list(s)) if value == c]\\n\\tanswer = []\\n\\tfor i in range(len(s)):\\n\\t\\ttemp = []\\n\\t\\tfor j in c_index:\\n\\t\\t\\ttemp.append(abs(i - j))\\n\\t\\tanswer.append(min(temp))\\n\\treturn answer",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tc_index = [i for i, value in enumerate(list(s)) if value == c]\\n\\tanswer = []\\n\\tfor i in range(len(s)):\\n\\t\\ttemp = []\\n\\t\\tfor j in c_index:\\n\\t\\t\\ttemp.append(abs(i - j))\\n\\t\\tanswer.append(min(temp))\\n\\treturn answer",
                "codeTag": "Unknown"
            },
            {
                "id": 1973716,
                "title": "scan-twice-easy-to-read",
                "content": "Below was my thought process although I could not find optimized solution at once\\n\\nto find closet distance\\n1. init array with maximum distance of len(n)\\n2. scan left to right find distance and store previous occurence index\\n3. scan right to left and store previous occurence index\\n\\n```\\n public int[] shortestToChar(String s, char c) {\\n        int n=s.length();\\n        int[] res= new int[n];\\n        Arrays.fill(res,n);\\n        int prev=-n;\\n        \\n        for(int i=0;i<n;i++){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n                \\n        for(int i=n-1;i>=0;i--){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n        \\n        return res;\\n    }\\n\\t\\n\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] shortestToChar(String s, char c) {\\n        int n=s.length();\\n        int[] res= new int[n];\\n        Arrays.fill(res,n);\\n        int prev=-n;\\n        \\n        for(int i=0;i<n;i++){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n                \\n        for(int i=n-1;i>=0;i--){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n        \\n        return res;\\n    }\\n\\t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929483,
                "title": "c-simple-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len = s.size();\\n        vector<int> ans(len , INT_MAX);\\n        int pos = -1;\\n        \\n        for(int i = 0 ; i<len ; i++){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = (i-pos);\\n            }\\n        }\\n            pos = -1;\\n        \\n        \\n        for(int i = len-1 ; i>=0 ; i--){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = min(ans[i] , (pos-i));\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len = s.size();\\n        vector<int> ans(len , INT_MAX);\\n        int pos = -1;\\n        \\n        for(int i = 0 ; i<len ; i++){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = (i-pos);\\n            }\\n        }\\n            pos = -1;\\n        \\n        \\n        for(int i = len-1 ; i>=0 ; i--){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = min(ans[i] , (pos-i));\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830996,
                "title": "javascript-straight-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   const arr = s.split(\"\")\\n   let count = 0;\\n   const answer = []\\n    const newArr = arr.map( (item, index) => {\\n        if(item === c) { \\n            count = count + 1;\\n           return arr[index] = count\\n        }else { \\n            return arr[index] = item\\n        }\\n    })\\n    \\n    for(let i=0; i<arr.length; i++) { \\n        let min = 0;\\n        for(let j=1; j<=count;j++) {\\n            const index = newArr.indexOf(j)\\n            const distance = Math.abs(i - index);\\n            if( arr[i] === j) { \\n                min = 0;\\n                break;\\n            }else if(distance < min || min ===0) { \\n                min = distance\\n            }\\n        }\\n        answer.push(min)\\n        \\n    }\\n    \\n    return answer\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   const arr = s.split(\"\")\\n   let count = 0;\\n   const answer = []\\n    const newArr = arr.map( (item, index) => {\\n        if(item === c) { \\n            count = count + 1;\\n           return arr[index] = count\\n        }else { \\n            return arr[index] = item\\n        }\\n    })\\n    \\n    for(let i=0; i<arr.length; i++) { \\n        let min = 0;\\n        for(let j=1; j<=count;j++) {\\n            const index = newArr.indexOf(j)\\n            const distance = Math.abs(i - index);\\n            if( arr[i] === j) { \\n                min = 0;\\n                break;\\n            }else if(distance < min || min ===0) { \\n                min = distance\\n            }\\n        }\\n        answer.push(min)\\n        \\n    }\\n    \\n    return answer\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816678,
                "title": "c-simple-solution",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx)    dist = min(dist, abs(d - i));\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx)    dist = min(dist, abs(d - i));\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748946,
                "title": "c-two-pointer-approach",
                "content": "```\\n\\n\\n public int[] ShortestToChar(string s, char c) {\\n\\n    if (s == null || s == \"\" || c == null) {\\n      return new int[] {\\n        0\\n      };\\n    }\\n\\n    int[] values = new int[s.Length];\\n\\n    int l = 0, r = 0, n = s.Length, short_dist_sofar = 0, curr_dist_sofar = 0;\\n    int visitcount = 0;\\n\\n    while (r < n) {\\n      if (s[r] == c) {\\n        curr_dist_sofar = r;\\n        short_dist_sofar = (short_dist_sofar == 0 && visitcount == 0) ? r : short_dist_sofar;\\n        while (l <= r) {\\n          int prev_dist = Math.Abs(l - short_dist_sofar);\\n          int curr_dist = Math.Abs(l - curr_dist_sofar);\\n          int min_dist = Math.Min(prev_dist, curr_dist);\\n          values[l] = min_dist;\\n          short_dist_sofar = (l == r) ? curr_dist_sofar : short_dist_sofar;\\n          l++;\\n          visitcount++;\\n        }\\n      }\\n      r++;\\n    }\\n\\n    while (visitcount < n) {\\n      values[visitcount] = Math.Abs(visitcount - short_dist_sofar);\\n      visitcount++;\\n    }\\n\\n    return values;\\n  }\\n\\n```\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n\\n\\n public int[] ShortestToChar(string s, char c) {\\n\\n    if (s == null || s == \"\" || c == null) {\\n      return new int[] {\\n        0\\n      };\\n    }\\n\\n    int[] values = new int[s.Length];\\n\\n    int l = 0, r = 0, n = s.Length, short_dist_sofar = 0, curr_dist_sofar = 0;\\n    int visitcount = 0;\\n\\n    while (r < n) {\\n      if (s[r] == c) {\\n        curr_dist_sofar = r;\\n        short_dist_sofar = (short_dist_sofar == 0 && visitcount == 0) ? r : short_dist_sofar;\\n        while (l <= r) {\\n          int prev_dist = Math.Abs(l - short_dist_sofar);\\n          int curr_dist = Math.Abs(l - curr_dist_sofar);\\n          int min_dist = Math.Min(prev_dist, curr_dist);\\n          values[l] = min_dist;\\n          short_dist_sofar = (l == r) ? curr_dist_sofar : short_dist_sofar;\\n          l++;\\n          visitcount++;\\n        }\\n      }\\n      r++;\\n    }\\n\\n    while (visitcount < n) {\\n      values[visitcount] = Math.Abs(visitcount - short_dist_sofar);\\n      visitcount++;\\n    }\\n\\n    return values;\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715270,
                "title": "java-solution",
                "content": "```class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0; i< s.length();i++){\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        int j=0;\\n        int k=0;\\n        List<Integer> list2=new ArrayList<>();\\n        while(j < s.length()){\\n            if(k==0){\\n                list2.add(Math.abs(list.get(k)-j));\\n            }\\n            else{\\n                int val1=Math.abs(list.get(k-1)-j);\\n                int val2=Math.abs(list.get(k)-j);\\n                if(val1 < val2)\\n                    list2.add(val1);\\n                else\\n                    list2.add(val2);\\n            }\\n            if(j==list.get(k) && k < list.size()-1)\\n                k++;\\n            j++;\\n        }\\n        int[] result=new int[list2.size()];\\n        int i=0;\\n        for(int ele:list2)\\n            result[i++]=ele;\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0; i< s.length();i++){\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1706047,
                "title": "java-using-a-list-to-store-indexes-of-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len=s.length();\\n        int[] ans=new int[len];\\n        List<Integer> list=new ArrayList();\\n        for(int i=0;i<len;i++)\\n        {\\n            if(s.charAt(i)==c)\\n            {\\n                list.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(j==0)\\n                ans[i]=Math.abs(list.get(j)-i);\\n            else\\n                ans[i]=Math.min(Math.abs(list.get(j-1)-i),Math.abs(list.get(j)-i));\\n            if(ans[i]==0 && j<list.size()-1)\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len=s.length();\\n        int[] ans=new int[len];\\n        List<Integer> list=new ArrayList();\\n        for(int i=0;i<len;i++)\\n        {\\n            if(s.charAt(i)==c)\\n            {\\n                list.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(j==0)\\n                ans[i]=Math.abs(list.get(j)-i);\\n            else\\n                ans[i]=Math.min(Math.abs(list.get(j-1)-i),Math.abs(list.get(j)-i));\\n            if(ans[i]==0 && j<list.size()-1)\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704001,
                "title": "java-simple-easy",
                "content": "```\\n    public int[] shortestToChar(String s, char c) {\\n        char[] arr = s.toCharArray();\\n        int[] result = new int[s.length()];\\n        \\n        int first = Integer.MAX_VALUE;\\n        int second = Integer.MAX_VALUE;\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            for (int j=i; j<s.length(); j++) {\\n                if (arr[j] == c && first == Integer.MAX_VALUE) {\\n                    first = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            for (int j=i; j>=0; j--) {\\n                if (arr[j] == c && second == Integer.MAX_VALUE) {\\n                    second = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            result[i] = Math.min(first, second);\\n            first = Integer.MAX_VALUE;\\n            second = Integer.MAX_VALUE;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] shortestToChar(String s, char c) {\\n        char[] arr = s.toCharArray();\\n        int[] result = new int[s.length()];\\n        \\n        int first = Integer.MAX_VALUE;\\n        int second = Integer.MAX_VALUE;\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            for (int j=i; j<s.length(); j++) {\\n                if (arr[j] == c && first == Integer.MAX_VALUE) {\\n                    first = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            for (int j=i; j>=0; j--) {\\n                if (arr[j] == c && second == Integer.MAX_VALUE) {\\n                    second = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            result[i] = Math.min(first, second);\\n            first = Integer.MAX_VALUE;\\n            second = Integer.MAX_VALUE;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678713,
                "title": "cpp-soln",
                "content": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n      vector<int> ans;\\n      vector<int> v;\\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==c)\\n          v.push_back(i);\\n      }\\n      \\n      \\n      \\n      for(int j=0;j<s.size();j++)\\n      {\\n        int t,l=100000;\\n        for(int k=0;k<v.size();k++)\\n        {\\n          \\n          t=abs(j-v[k]);\\n          l=min(l,t);\\n          \\n        }\\n        ans.push_back(l);\\n        \\n      }\\n      \\n   return ans;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n      vector<int> ans;\\n      vector<int> v;\\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==c)\\n          v.push_back(i);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1650522,
                "title": "100-fast-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n         vector<int> res(s.length(),INT_MAX);\\n        \\n         int pos = -1;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(s[i] == c)\\n             {\\n                 pos = i;\\n                 res[i] = 0;\\n             }\\n             \\n             if(pos !=-1 && abs(i-pos) < res[i])\\n                 res[i] = abs(i-pos);\\n         }\\n        \\n        \\n        for(int i=s.length() - 1;i>=0 ;i--)\\n        {\\n            if(s[i] == c)\\n            {\\n                pos = i;\\n            }\\n            if(res[i] > abs(pos - i))\\n                res[i] = abs(pos -i);\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n         vector<int> res(s.length(),INT_MAX);\\n        \\n         int pos = -1;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(s[i] == c)\\n             {\\n                 pos = i;\\n                 res[i] = 0;\\n             }\\n             \\n             if(pos !=-1 && abs(i-pos) < res[i])\\n                 res[i] = abs(i-pos);\\n         }\\n        \\n        \\n        for(int i=s.length() - 1;i>=0 ;i--)\\n        {\\n            if(s[i] == c)\\n            {\\n                pos = i;\\n            }\\n            if(res[i] > abs(pos - i))\\n                res[i] = abs(pos -i);\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643399,
                "title": "c-faster-than-100-of-solutions",
                "content": "```\\n// simple solution just need to keep track of \\n// nearest left and nearest right done using 2\\n// ask me in comments if you have any query \\n// will try my best \\n// please upvote !!!\\n\\n  vector<int> shortestToChar(string s, char c) \\n    {\\n       int l=0,r=0,i=0,n=s.length();\\n        vector<int>ans(n);\\n      \\n        while(i<s.length())\\n        {      \\n            if(s[i]==c)\\n            {   \\n                l=i;\\n                r=i+1;\\n            }\\n             while(r<n && s[r]!=c) r++;\\n             while(l<n && s[l]!=c) l++;\\n         \\n            if(r==n) r=INT_MAX;\\n            ans[i]=min(abs(l-i),abs(r-i));\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n// simple solution just need to keep track of \\n// nearest left and nearest right done using 2\\n// ask me in comments if you have any query \\n// will try my best \\n// please upvote !!!\\n\\n  vector<int> shortestToChar(string s, char c) \\n    {\\n       int l=0,r=0,i=0,n=s.length();\\n        vector<int>ans(n);\\n      \\n        while(i<s.length())\\n        {      \\n            if(s[i]==c)\\n            {   \\n                l=i;\\n                r=i+1;\\n            }\\n             while(r<n && s[r]!=c) r++;\\n             while(l<n && s[l]!=c) l++;\\n         \\n            if(r==n) r=INT_MAX;\\n            ans[i]=min(abs(l-i),abs(r-i));\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1619364,
                "title": "python-simple-solution-with-help-of-list-comprehension",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        s = list(s)\\n        x = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                s[i] = 0\\n                x.append(i)\\n        for i in range(len(s)):\\n            s[i] = min([abs(j-i) for j in x])\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        s = list(s)\\n        x = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                s[i] = 0\\n                x.append(i)\\n        for i in range(len(s)):\\n            s[i] = min([abs(j-i) for j in x])\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618164,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                count++;\\n            }\\n        } \\n        int[] array = new int[count];\\n        \\n        int j = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                array[j] = i;\\n                j++;\\n            }\\n        }\\n        \\n        \\n        int[] answer = new int[s.length()];\\n        int k = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            \\n            if(s.charAt(i) != c){\\n                if(k > 0){\\n                    answer[i] = Math.min(Math.abs(array[k] - i), Math.abs(array[k-1] - i));\\n                }\\n                else{\\n                    answer[i] = Math.abs(array[k] - i);\\n                }\\n            }\\n            else if(s.charAt(i) == c){\\n                answer[i] = 0;\\n                if(k < array.length-1){\\n                    k++;   \\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                count++;\\n            }\\n        } \\n        int[] array = new int[count];\\n        \\n        int j = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                array[j] = i;\\n                j++;\\n            }\\n        }\\n        \\n        \\n        int[] answer = new int[s.length()];\\n        int k = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            \\n            if(s.charAt(i) != c){\\n                if(k > 0){\\n                    answer[i] = Math.min(Math.abs(array[k] - i), Math.abs(array[k-1] - i));\\n                }\\n                else{\\n                    answer[i] = Math.abs(array[k] - i);\\n                }\\n            }\\n            else if(s.charAt(i) == c){\\n                answer[i] = 0;\\n                if(k < array.length-1){\\n                    k++;   \\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616196,
                "title": "c-two-pointer-easy-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int start = 0,end= 0;\\n        int len = s.size();\\n        vector<int> ans(len, INT_MAX);\\n        bool flag = 0;\\n        while(start <= end && end < len){\\n            if(flag){\\n                ans[end] = end-start+1;\\n            }\\n            while(start <= end && s[end] == c){\\n                flag = 1;\\n                ans[start] = min(ans[start],end-start);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please don\\'t forget to upvote.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int start = 0,end= 0;\\n        int len = s.size();\\n        vector<int> ans(len, INT_MAX);\\n        bool flag = 0;\\n        while(start <= end && end < len){\\n            if(flag){\\n                ans[end] = end-start+1;\\n            }\\n            while(start <= end && s[end] == c){\\n                flag = 1;\\n                ans[start] = min(ans[start],end-start);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603964,
                "title": "javascript-easy-to-understand",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   s = s.split(\\'\\')\\n  let position = []\\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          position.push(i)\\n      }\\n  }  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          s[i] = 0\\n      } else {\\n          let min = Infinity\\n          for(let j = 0; j < position.length; j++) {\\n              let num = position[j]\\n              if(Math.abs(num - i) < min) {\\n                  min = Math.abs(num - i)\\n              }\\n          }\\n          s[i] = min\\n      }\\n  }\\n\\n  return s\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   s = s.split(\\'\\')\\n  let position = []\\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          position.push(i)\\n      }\\n  }  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          s[i] = 0\\n      } else {\\n          let min = Infinity\\n          for(let j = 0; j < position.length; j++) {\\n              let num = position[j]\\n              if(Math.abs(num - i) < min) {\\n                  min = Math.abs(num - i)\\n              }\\n          }\\n          s[i] = min\\n      }\\n  }\\n\\n  return s\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596687,
                "title": "python-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        from collections import defaultdict\\n        mydict=defaultdict(list)\\n        for i in range(len(s)):\\n            mydict[s[i]].append(i)\\n        \\n        res=[]\\n        for j in range(len(s)):\\n            if len(mydict[c])==1:\\n                res.append(abs(j-mydict[c][0]))\\n            else:\\n                mn=len(s)\\n                for val in mydict[c]:\\n                    mn=min(mn,abs(j-val))\\n                res.append(mn)\\n        \\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        from collections import defaultdict\\n        mydict=defaultdict(list)\\n        for i in range(len(s)):\\n            mydict[s[i]].append(i)\\n        \\n        res=[]\\n        for j in range(len(s)):\\n            if len(mydict[c])==1:\\n                res.append(abs(j-mydict[c][0]))\\n            else:\\n                mn=len(s)\\n                for val in mydict[c]:\\n                    mn=min(mn,abs(j-val))\\n                res.append(mn)\\n        \\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525508,
                "title": "c-easy-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> answer(s.length());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n                answer[i]=0;\\n            else\\n            {\\n                //left side\\n                int j=i-1;\\n                int left=0;\\n                bool leftflag=false;\\n                \\n                while(j>=0)\\n                {\\n                    if(s[j]==c)\\n                    {\\n                        leftflag=true;\\n                        left++;\\n                        break;\\n                    }\\n                    left++;\\n                    j--;\\n                }\\n                //right side\\n                bool rightflag=false;\\n                int k=i+1;\\n                int right=0;\\n                while(k<s.length())\\n                {\\n                    if(s[k]==c)\\n                    {\\n                        rightflag=true;\\n                        right++;\\n                        break;\\n                    }\\n                    right++;\\n                    k++;\\n                }\\n                if(leftflag==true && rightflag==true)\\n                    answer[i]=min(left,right);\\n                else if(leftflag==false && rightflag==true)\\n                {\\n                    answer[i]=right;\\n                }\\n                else if(rightflag==false && leftflag==true)\\n                {\\n                    answer[i]=left;\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> answer(s.length());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n                answer[i]=0;\\n            else\\n            {\\n                //left side\\n                int j=i-1;\\n                int left=0;\\n                bool leftflag=false;\\n                \\n                while(j>=0)\\n                {\\n                    if(s[j]==c)\\n                    {\\n                        leftflag=true;\\n                        left++;\\n                        break;\\n                    }\\n                    left++;\\n                    j--;\\n                }\\n                //right side\\n                bool rightflag=false;\\n                int k=i+1;\\n                int right=0;\\n                while(k<s.length())\\n                {\\n                    if(s[k]==c)\\n                    {\\n                        rightflag=true;\\n                        right++;\\n                        break;\\n                    }\\n                    right++;\\n                    k++;\\n                }\\n                if(leftflag==true && rightflag==true)\\n                    answer[i]=min(left,right);\\n                else if(leftflag==false && rightflag==true)\\n                {\\n                    answer[i]=right;\\n                }\\n                else if(rightflag==false && leftflag==true)\\n                {\\n                    answer[i]=left;\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456750,
                "title": "two-pass-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int[] res = new int[s.length()];\\n        Arrays.fill(res, Integer.MAX_VALUE); // all the distances are MAX for initilization\\n        int pos = -1; // if we haven\\'t seen c yet, mark it as -1\\n        \\n        // after each c, update distance\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) {\\n                pos = i;\\n                res[i] = 0;\\n            }\\n            else if (pos != -1 && chars[i] != c) {\\n                res[i] = Math.abs(i - pos);\\n            }\\n        }\\n        // before each c, update distance\\n        for (int i = chars.length - 1; i >= 0; i--) {\\n            if (chars[i] == c) {\\n                pos = i;\\n            }\\n            else {\\n                res[i] = Math.min(res[i], Math.abs(i - pos));\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int[] res = new int[s.length()];\\n        Arrays.fill(res, Integer.MAX_VALUE); // all the distances are MAX for initilization\\n        int pos = -1; // if we haven\\'t seen c yet, mark it as -1\\n        \\n        // after each c, update distance\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) {\\n                pos = i;\\n                res[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1431570,
                "title": "java-easy-solution-o-n-time",
                "content": "\\n    public int[] shortestToChar(String s, char c) {\\n        int[] res = new int[s.length()];\\n        int dist = 0;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0)\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        for (int i = s.length() - 1; i >= 0 ; i--)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0 && (res[i] == 0  || dist < res[i]))\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] shortestToChar(String s, char c) {\\n        int[] res = new int[s.length()];\\n        int dist = 0;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0)\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        for (int i = s.length() - 1; i >= 0 ; i--)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0 && (res[i] == 0  || dist < res[i]))\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1430002,
                "title": "intuitive-approach-c",
                "content": "\\n \\n \\n \\n \\n \\n \\n \\n vector<int> ans;\\n    vector<int> v;\\n    for(int i=0;i<s.length();i++)\\n    {\\n        if(s[i]==c)\\n            v.push_back(i);\\n    }\\n    \\n    for(int i =0;i<s.length();i++)\\n    {\\n        int mindist = INT_MAX;\\n        for(int x =0;x<size(v);x++)\\n        {\\n            mindist = min(mindist,abs(i-v[x]));\\n        }\\n        ans.push_back(mindist);\\n    }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n \\n \\n \\n \\n \\n \\n \\n vector<int> ans;\\n    vector<int> v;\\n    for(int i=0;i<s.length();i++)\\n    {\\n        if(s[i]==c)\\n            v.push_back(i);\\n    }\\n    \\n    for(int i =0;i<s.length();i++)\\n    {\\n        int mindist = INT_MAX;\\n        for(int x =0;x<size(v);x++)\\n        {\\n            mindist = min(mindist,abs(i-v[x]));\\n        }\\n        ans.push_back(mindist);\\n    }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1402373,
                "title": "java-2-pass-solution-o-n-time",
                "content": "**Runtime: 2 ms\\nMemory Usage: 39.8 MB**\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int res[] = new int[s.length()];\\n        int idx = -1;\\n        \\n        //left scan \\n        for(int i = 0;i< s.length();i++){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx == -1)res[i] = Integer.MAX_VALUE;\\n            else res[i] = Math.abs(idx - i);\\n        }\\n        \\n        //right scan\\n        idx = -1;\\n        for(int i = s.length() - 1;i>=0;i--){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx != -1)res[i] = Math.min(res[i],Math.abs(i - idx));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n**Time Complexity : 2*O(N) -> O(N)\\nSpace Complexity : O(N) (for output)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int res[] = new int[s.length()];\\n        int idx = -1;\\n        \\n        //left scan \\n        for(int i = 0;i< s.length();i++){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx == -1)res[i] = Integer.MAX_VALUE;\\n            else res[i] = Math.abs(idx - i);\\n        }\\n        \\n        //right scan\\n        idx = -1;\\n        for(int i = s.length() - 1;i>=0;i--){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx != -1)res[i] = Math.min(res[i],Math.abs(i - idx));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394746,
                "title": "2-pointers-java-scan-for-occurrences-easy",
                "content": "**Flow**\\n1. scan for occurrences of char c\\n2. Then init pointer current \\n3. Compare abs for pointer and nextPointer for each char a \\n4. If next is smaller then increase pointer\\n! Also check for out of bounds if so just place asb for current pointer no need for the next one \\n\\n\\n ```\\n        char[] chars = s.toCharArray();\\n        int[] result = new int[chars.length];\\n        List<Integer> occurrences = new ArrayList<>();\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) occurrences.add(i);\\n        }\\n\\n        int curOcIndx = 0;\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            Integer curOcr = occurrences.get(curOcIndx);\\n            if (curOcIndx+1 < occurrences.size()) {\\n                Integer nextOcr = occurrences.get(curOcIndx+1);\\n                if (Math.abs(curOcr - i) < Math.abs(nextOcr - i)) {\\n                    result[i] = Math.abs(curOcr - i);\\n                } else {\\n                    result[i] = Math.abs(nextOcr - i);\\n                    curOcIndx++;\\n                }\\n            } else result[i] = Math.abs(curOcr - i);\\n        }\\n        return result;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n        char[] chars = s.toCharArray();\\n        int[] result = new int[chars.length];\\n        List<Integer> occurrences = new ArrayList<>();\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) occurrences.add(i);\\n        }\\n\\n        int curOcIndx = 0;\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            Integer curOcr = occurrences.get(curOcIndx);\\n            if (curOcIndx+1 < occurrences.size()) {\\n                Integer nextOcr = occurrences.get(curOcIndx+1);\\n                if (Math.abs(curOcr - i) < Math.abs(nextOcr - i)) {\\n                    result[i] = Math.abs(curOcr - i);\\n                } else {\\n                    result[i] = Math.abs(nextOcr - i);\\n                    curOcIndx++;\\n                }\\n            } else result[i] = Math.abs(curOcr - i);\\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382699,
                "title": "cpp-solution-faster-than-97-cpp-solutions-and-memory-consumption-less-than-98-8-cpp-solutions",
                "content": "vector<int> shortestToChar(string s, char c) {\\n        // naive approach:(faster)-----------------------------------\\n        vector<int>ans(s.length(),100000);\\n        vector<int>index;\\n        for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        for(int i = 0;i<s.length();i++)if(s[i] == c) ans[i] = 0;\\n            else \\n                for(int j = 0;j<index.size();j++)\\n                  ans[i] = min(ans[i],abs(i-index[j]));\\n        return ans;\\n        // binary search using lower_bound:(slower)-------------------\\n        // vector<int>ans(s.length());\\n        // vector<int>index;\\n        // for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        // for(int i = 0;i<s.length();i++){\\n        //     if(s[i] == c){\\n        //         ans[i] = 0;\\n        //         continue;\\n        //     }\\n        //     int x  =lower_bound(index.begin(),index.end(),i)-index.begin();\\n        //     if(x == index.size() or x == 0)\\n        //         ans[i] = abs(index[x]-i);\\n        //     else ans[i] = min(abs(index[x]-i),abs(index[x-1]-i));\\n        // }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<int> shortestToChar(string s, char c) {\\n        // naive approach:(faster)-----------------------------------\\n        vector<int>ans(s.length(),100000);\\n        vector<int>index;\\n        for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        for(int i = 0;i<s.length();i++)if(s[i] == c) ans[i] = 0;\\n            else \\n                for(int j = 0;j<index.size();j++)\\n                  ans[i] = min(ans[i],abs(i-index[j]));\\n        return ans;\\n        // binary search using lower_bound:(slower)-------------------\\n        // vector<int>ans(s.length());\\n        // vector<int>index;\\n        // for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        // for(int i = 0;i<s.length();i++){\\n        //     if(s[i] == c){\\n        //         ans[i] = 0;\\n        //         continue;\\n        //     }\\n        //     int x  =lower_bound(index.begin(),index.end(),i)-index.begin();\\n        //     if(x == index.size() or x == 0)\\n        //         ans[i] = abs(index[x]-i);\\n        //     else ans[i] = min(abs(index[x]-i),abs(index[x-1]-i));\\n        // }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1379201,
                "title": "c-binary-search-o-nlogm-0ms-beats-100",
                "content": "Make an array store all the presence of c in it,after that use binary search to find the shortest distance\\n```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> vec;\\n        vec.push_back(INT_MIN);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==c){\\n                vec.push_back(i);\\n            }\\n        }\\n        vec.push_back(INT_MAX);\\n     \\n        if(vec.size()==2){\\n            return {};\\n        }\\n        else{\\n            vector<int> nums;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==c){\\n                    nums.push_back(0);\\n                    continue;\\n                }\\n                auto x=lower_bound(vec.begin(),vec.end(),i);\\n                int lb=x-vec.begin();\\n                lb--;\\n                auto y=upper_bound(vec.begin(),vec.end(),i);\\n                int ub=y-vec.begin();\\n                if(vec[lb]==INT_MIN){\\n                    nums.push_back(min(*x-0,abs(vec[ub]-i)));\\n                }\\n                else if(vec[ub]==INT_MAX){\\n                    nums.push_back(abs(i-vec[lb]));\\n                }\\n                else{\\n                    nums.push_back(min(abs(i-vec[lb]),abs(vec[ub]-i)));\\n                }\\n            }\\n            return nums;   \\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> vec;\\n        vec.push_back(INT_MIN);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==c){\\n                vec.push_back(i);\\n            }\\n        }\\n        vec.push_back(INT_MAX);\\n     \\n        if(vec.size()==2){\\n            return {};\\n        }\\n        else{\\n            vector<int> nums;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==c){\\n                    nums.push_back(0);\\n                    continue;\\n                }\\n                auto x=lower_bound(vec.begin(),vec.end(),i);\\n                int lb=x-vec.begin();\\n                lb--;\\n                auto y=upper_bound(vec.begin(),vec.end(),i);\\n                int ub=y-vec.begin();\\n                if(vec[lb]==INT_MIN){\\n                    nums.push_back(min(*x-0,abs(vec[ub]-i)));\\n                }\\n                else if(vec[ub]==INT_MAX){\\n                    nums.push_back(abs(i-vec[lb]));\\n                }\\n                else{\\n                    nums.push_back(min(abs(i-vec[lb]),abs(vec[ub]-i)));\\n                }\\n            }\\n            return nums;   \\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352511,
                "title": "100-faster-java-2-pass-solution",
                "content": "```\\n public static int[] shortestToChar2Pass(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        char[] arr = s.toCharArray();\\n        int pos = -arr.length;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; i--) {\\n            if (arr[i] == c) pos = i;\\n            if (pos - i < ans[i]) {\\n                ans[i] = pos - i;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public static int[] shortestToChar2Pass(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        char[] arr = s.toCharArray();\\n        int pos = -arr.length;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; i--) {\\n            if (arr[i] == c) pos = i;\\n            if (pos - i < ans[i]) {\\n                ans[i] = pos - i;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349618,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        //c[ l o, v, e, l, e, e, t, c, o, d, e]\\n        //t[ 0, 1, 2,3 ,4, 5, 6, 7, 8, 9, 10, 11]\\n        //   i\\n        //v[3, 5, 6, 11]\\n        //  iB jF\\n        vector<int> v, ans;\\n        int m = s.size();\\n        for(int i = 0; i<m; i++)\\n            if(s[i] == c)\\n                v.push_back(i);\\n        int  n = v.size();\\n        int iB = 0, iF = 1;\\n        for(int i = 0; i<m; i++ ){\\n            if(iF<n){\\n                ans.push_back(min(abs(i-  v[iB]), abs(v[iF]- i)));\\n                if(abs(i-  v[iB])>= abs(v[iF]- i)){\\n                    iF++;\\n                    iB++;\\n                }\\n            }\\n            else\\n                ans.push_back(abs(i- v[iB]));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        //c[ l o, v, e, l, e, e, t, c, o, d, e]\\n        //t[ 0, 1, 2,3 ,4, 5, 6, 7, 8, 9, 10, 11]\\n        //   i\\n        //v[3, 5, 6, 11]\\n        //  iB jF\\n        vector<int> v, ans;\\n        int m = s.size();\\n        for(int i = 0; i<m; i++)\\n            if(s[i] == c)\\n                v.push_back(i);\\n        int  n = v.size();\\n        int iB = 0, iF = 1;\\n        for(int i = 0; i<m; i++ ){\\n            if(iF<n){\\n                ans.push_back(min(abs(i-  v[iB]), abs(v[iF]- i)));\\n                if(abs(i-  v[iB])>= abs(v[iF]- i)){\\n                    iF++;\\n                    iB++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1337089,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp=[]\\n        result =[]\\n        for char in range(len(s)):\\n            if s[char]==c:\\n                temp.append(char)\\n        for j in range(len(s)):\\n            result.append(min(list(map(lambda x:abs(x-j), temp))))\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp=[]\\n        result =[]\\n        for char in range(len(s)):\\n            if s[char]==c:\\n                temp.append(char)\\n        for j in range(len(s)):\\n            result.append(min(list(map(lambda x:abs(x-j), temp))))\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332255,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        char chr[]=s.toCharArray();\\n        int len=s.length();\\n        int ans[]=new int[len];\\n        \\n        for(int i=0; i<len; i++)\\n        {\\n            if(chr[i]==c)\\n            {\\n                ans[i]=0;\\n                continue;\\n            }\\n            int shortestDist=Integer.MAX_VALUE;\\n            for(int j=0; j<len; j++)\\n            {\\n                if(chr[j]==c)\\n                {\\n                    int dist = Math.abs(i-j);\\n                    if(dist < shortestDist)\\n                        shortestDist=dist;\\n                    else if(dist > shortestDist)\\n                        break;\\n                }\\n            }\\n            ans[i]=shortestDist;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n// By Arindam Ghosh\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        char chr[]=s.toCharArray();\\n        int len=s.length();\\n        int ans[]=new int[len];\\n        \\n        for(int i=0; i<len; i++)\\n        {\\n            if(chr[i]==c)\\n            {\\n                ans[i]=0;\\n                continue;\\n            }\\n            int shortestDist=Integer.MAX_VALUE;\\n            for(int j=0; j<len; j++)\\n            {\\n                if(chr[j]==c)\\n                {\\n                    int dist = Math.abs(i-j);\\n                    if(dist < shortestDist)\\n                        shortestDist=dist;\\n                    else if(dist > shortestDist)\\n                        break;\\n                }\\n            }\\n            ans[i]=shortestDist;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n// By Arindam Ghosh\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302503,
                "title": "c-2-approaches-using-map-without-map-2-pass",
                "content": "```\\n//Approach-1 (Using map)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        map<char, vector<int>> mp;\\n        int n = s.length();\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                mp[c].push_back(i); //store all indices of char c\\n        }\\n        \\n        \\n            \\n        vector<int> result(n, 0);\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] != c) {\\n                int dis = INT_MAX;\\n                for(int &idx : mp[c]) {\\n                    dis = min(dis, abs(i-idx)); //find the best index which gives min distance\\n                }\\n                result[i] = dis;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Simple 2 pass solution)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n        vector<int> result(n, 0);\\n        int prev =  -10001;\\n        \\n\\t\\t//find closest to left\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = abs(i-prev);\\n        }\\n        \\n\\t\\t//Find closest to right and choose minimum from left and right\\n\\t\\tprev = 10001;\\n        for(int i = n-1; i>=0; i--) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = min(result[i], abs(prev-i));\\n        }       \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using map)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        map<char, vector<int>> mp;\\n        int n = s.length();\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                mp[c].push_back(i); //store all indices of char c\\n        }\\n        \\n        \\n            \\n        vector<int> result(n, 0);\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] != c) {\\n                int dis = INT_MAX;\\n                for(int &idx : mp[c]) {\\n                    dis = min(dis, abs(i-idx)); //find the best index which gives min distance\\n                }\\n                result[i] = dis;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Simple 2 pass solution)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n        vector<int> result(n, 0);\\n        int prev =  -10001;\\n        \\n\\t\\t//find closest to left\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = abs(i-prev);\\n        }\\n        \\n\\t\\t//Find closest to right and choose minimum from left and right\\n\\t\\tprev = 10001;\\n        for(int i = n-1; i>=0; i--) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = min(result[i], abs(prev-i));\\n        }       \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291395,
                "title": "solution-for-slow-learner-like-me-o-n2-solution-intuitive",
                "content": "I recently had this question at an interview and came up with this solution, suprisingly the interviewer gave me a pass. I was facing trouble reaching O(n) but was helped a lot to reach a similar solution as @lee215\\n\\n```\\npublic int[] shortestToCha1r(String s, char c) {\\n       \\n        // save position of c in arraylist\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i =0;i< s.length();i++)\\n        {   if(s.charAt(i)==c) {\\n                arr.add(i);\\n            }\\n        }\\n        \\n        int brr[] = new int[s.length()];\\n        for(int i =0;i<s.length();i++) {\\n            // cal shortest distance from i to nearest c\\n            int min=Integer.max;\\n            for(int j=0;j<arr.size();j++) {\\n                if(Math.abs(i-arr.get(j))<min) {\\n                    min= Math.abs(i-arr.get(j));\\n                }\\n            }\\n            brr[i]=min;\\n        }\\n    return brr;\\n    \\n    }\\n",
                "solutionTags": [],
                "code": "I recently had this question at an interview and came up with this solution, suprisingly the interviewer gave me a pass. I was facing trouble reaching O(n) but was helped a lot to reach a similar solution as @lee215\\n\\n```\\npublic int[] shortestToCha1r(String s, char c) {\\n       \\n        // save position of c in arraylist\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i =0;i< s.length();i++)\\n        {   if(s.charAt(i)==c) {\\n                arr.add(i);\\n            }\\n        }\\n        \\n        int brr[] = new int[s.length()];\\n        for(int i =0;i<s.length();i++) {\\n            // cal shortest distance from i to nearest c\\n            int min=Integer.max;\\n            for(int j=0;j<arr.size();j++) {\\n                if(Math.abs(i-arr.get(j))<min) {\\n                    min= Math.abs(i-arr.get(j));\\n                }\\n            }\\n            brr[i]=min;\\n        }\\n    return brr;\\n    \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1265996,
                "title": "java-solution-in-10-lines-with-explanation",
                "content": "**Explanation** - We first create a TreeSet containing the positions of character c in string s. Then we iterate through all the indices of string s and find the nearest two values from the current position in the string using this set. One of these two values is less than the current position and the other greater. We calculate the difference of both from the current position. The lower one is the answer. We do this for all positions in the string.\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        var posSet = IntStream.range(0,s.length()).filter(i -> s.charAt(i) == c)\\n            .collect(TreeSet<Integer>::new,TreeSet::add,TreeSet::addAll);\\n        \\n        return IntStream.range(0,s.length()).map(i -> {\\n            var floor = Objects.requireNonNullElse(posSet.floor(i), Integer.MAX_VALUE);\\n            var ceil  = Objects.requireNonNullElse(posSet.ceiling(i), Integer.MAX_VALUE);\\n            return Integer.min(Math.abs(floor - i), Math.abs(ceil - i));\\n        }).toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        var posSet = IntStream.range(0,s.length()).filter(i -> s.charAt(i) == c)\\n            .collect(TreeSet<Integer>::new,TreeSet::add,TreeSet::addAll);\\n        \\n        return IntStream.range(0,s.length()).map(i -> {\\n            var floor = Objects.requireNonNullElse(posSet.floor(i), Integer.MAX_VALUE);\\n            var ceil  = Objects.requireNonNullElse(posSet.ceiling(i), Integer.MAX_VALUE);\\n            return Integer.min(Math.abs(floor - i), Math.abs(ceil - i));\\n        }).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237231,
                "title": "python-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # create answer list\\n        length = len(s)\\n        ans = [length] * length\\n        \\n        # work left to right        \\n        for i in range(length):\\n            if s[i]==c:\\n                ans[i]=0\\n            elif i > 0:\\n                ans[i]=ans[i-1] + 1\\n        \\n        # work right to left (using negative indexing)\\n        for i in range(1, length+1):\\n            if i > 1:\\n                ans[-i]=min(ans[-i+1] + 1, ans[-i])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # create answer list\\n        length = len(s)\\n        ans = [length] * length\\n        \\n        # work left to right        \\n        for i in range(length):\\n            if s[i]==c:\\n                ans[i]=0\\n            elif i > 0:\\n                ans[i]=ans[i-1] + 1\\n        \\n        # work right to left (using negative indexing)\\n        for i in range(1, length+1):\\n            if i > 1:\\n                ans[-i]=min(ans[-i+1] + 1, ans[-i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231753,
                "title": "c-1-o-n-optimized-brute-force-2-dp-based-o-n",
                "content": "**1. O(n) based optimized**\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        int lastPosC = -n;\\n        vector<int> ans(n, n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = i - lastPosC;\\n        }\\n        for (int i = lastPosC - 1; i >= 0; i--)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = min(lastPosC - i, ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2. DP BASED**\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = s[i] == c ? 0 : n;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = min(ans[i], ans[i - 1] + 1);\\n        }\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            ans[i] = min(ans[i], ans[i + 1] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        int lastPosC = -n;\\n        vector<int> ans(n, n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = i - lastPosC;\\n        }\\n        for (int i = lastPosC - 1; i >= 0; i--)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = min(lastPosC - i, ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = s[i] == c ? 0 : n;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = min(ans[i], ans[i - 1] + 1);\\n        }\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            ans[i] = min(ans[i], ans[i + 1] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1810314,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1972844,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1568015,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1662769,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2053090,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1955192,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1790666,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Substrings Between Each Pair of Parentheses",
        "question_content": "<p>You are given a string <code>s</code> that consists of lower case English letters and brackets.</p>\n\n<p>Reverse the strings in each pair of matching parentheses, starting from the innermost one.</p>\n\n<p>Your result should <strong>not</strong> contain any brackets.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(abcd)&quot;\n<strong>Output:</strong> &quot;dcba&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(u(love)i)&quot;\n<strong>Output:</strong> &quot;iloveu&quot;\n<strong>Explanation:</strong> The substring &quot;love&quot; is reversed first, then the whole string is reversed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(ed(et(oc))el)&quot;\n<strong>Output:</strong> &quot;leetcode&quot;\n<strong>Explanation:</strong> First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> only contains lower case English characters and parentheses.</li>\n\t<li>It is guaranteed that all parentheses are balanced.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 383670,
                "title": "java-c-python-tenet-o-n-solution",
                "content": "# **Solution 1: Brute Force**\\nHere is the **brute force** solution, which seems really easy to write.\\nNothing more to talk about.\\n\\nTime `O(N^2)`, Space `O(N)`\\n<br>\\n\\n**Python**\\n```py\\n    def reverseParentheses(self, s):\\n        res = [\\'\\']\\n        for c in s:\\n            if c == \\'(\\':\\n                res.append(\\'\\')\\n            elif c == \\')\\':\\n                res[len(res) - 2] += res.pop()[::-1]\\n            else:\\n                res[-1] += c\\n        return \"\".join(res)\\n```\\n\\n**C++**\\n```cpp\\n    string reverseParentheses(string s) {\\n        vector<int> opened;\\n        string res;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s[i] == \\'(\\')\\n                opened.push_back(res.length());\\n            else if (s[i] == \\')\\') {\\n                int j = opened.back();\\n                opened.pop_back();\\n                reverse(res.begin() + j, res.end());\\n            } else {\\n                res += s[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\\n<br>\\n\\n# **Solution 2: Wormholes**\\n\\n## **Intuition**\\nNice. I got a green accpeted with solution 1.\\nNow before move on, let us check the solutions in the discuss.\\n\\nHey hey hey wait, `ALL` solutions are **BRUTE FORCE** ?\\nHmmmm... why not `O(N)`?\\n\\nFine fine fine, here comes an easy `O(N)` solution.\\n\\n## **Explanation**\\n\\nIn the first pass,\\nuse a stack to find all paired parentheses,\\nI assume you can do this.\\n\\nNow just imgine that all parentheses are wormholes.\\nAs you can see in the diagram,\\nthe paired parentheses are connected to each other.\\n\\n![image](https://assets.leetcode.com/users/lee215/image_1571315420.png)\\n\\nFirst it follows the left green arrrow,\\ngo into the left wormhole and get out from the right wormhole.\\nThen it iterates the whole content between parentheses.\\nFinally it follows the right arrow,\\ngo into the left wormhole,\\nget out from the right wormhole and finish the whole trip.\\n\\nSo in the second pass of our solution,\\nit traverses through the paired parentheses\\nand generate the result string `res`.\\n\\n`i` is the index of current position.\\n`d` is the direction of traversing.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)` for two passes\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public String reverseParentheses(String s) {\\n        int n = s.length();\\n        Stack<Integer> opened = new Stack<>();\\n        int[] pair = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (s.charAt(i) == \\'(\\')\\n                opened.push(i);\\n            if (s.charAt(i) == \\')\\') {\\n                int j = opened.pop();\\n                pair[i] = j;\\n                pair[j] = i;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, d = 1; i < n; i += d) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\')\\') {\\n                i = pair[i];\\n                d = -d;\\n            } else {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    string reverseParentheses(string s) {\\n        int n = s.length();\\n        vector<int> opened, pair(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\')\\n                opened.push_back(i);\\n            if (s[i] == \\')\\') {\\n                int j = opened.back();\\n                opened.pop_back();\\n                pair[i] = j;\\n                pair[j] = i;\\n            }\\n        }\\n        string res;\\n        for (int i = 0, d = 1; i < n; i += d) {\\n            if (s[i] == \\'(\\' || s[i] == \\')\\')\\n                i = pair[i], d = -d;\\n            else\\n                res += s[i];\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def reverseParentheses(self, s):\\n        opened = []\\n        pair = {}\\n        for i, c in enumerate(s):\\n            if c == \\'(\\':\\n                opened.append(i)\\n            if c == \\')\\':\\n                j = opened.pop()\\n                pair[i], pair[j] = j, i\\n        res = []\\n        i, d = 0, 1\\n        while i < len(s):\\n            if s[i] in \\'()\\':\\n                i = pair[i]\\n                d = -d\\n            else:\\n                res.append(s[i])\\n            i += d\\n        return \\'\\'.join(res)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def reverseParentheses(self, s):\\n        res = [\\'\\']\\n        for c in s:\\n            if c == \\'(\\':\\n                res.append(\\'\\')\\n            elif c == \\')\\':\\n                res[len(res) - 2] += res.pop()[::-1]\\n            else:\\n                res[-1] += c\\n        return \"\".join(res)\\n```\n```cpp\\n    string reverseParentheses(string s) {\\n        vector<int> opened;\\n        string res;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s[i] == \\'(\\')\\n                opened.push_back(res.length());\\n            else if (s[i] == \\')\\') {\\n                int j = opened.back();\\n                opened.pop_back();\\n                reverse(res.begin() + j, res.end());\\n            } else {\\n                res += s[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public String reverseParentheses(String s) {\\n        int n = s.length();\\n        Stack<Integer> opened = new Stack<>();\\n        int[] pair = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (s.charAt(i) == \\'(\\')\\n                opened.push(i);\\n            if (s.charAt(i) == \\')\\') {\\n                int j = opened.pop();\\n                pair[i] = j;\\n                pair[j] = i;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, d = 1; i < n; i += d) {\\n            if (s.charAt(i) == \\'(\\' || s.charAt(i) == \\')\\') {\\n                i = pair[i];\\n                d = -d;\\n            } else {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\n```cpp\\n    string reverseParentheses(string s) {\\n        int n = s.length();\\n        vector<int> opened, pair(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\')\\n                opened.push_back(i);\\n            if (s[i] == \\')\\') {\\n                int j = opened.back();\\n                opened.pop_back();\\n                pair[i] = j;\\n                pair[j] = i;\\n            }\\n        }\\n        string res;\\n        for (int i = 0, d = 1; i < n; i += d) {\\n            if (s[i] == \\'(\\' || s[i] == \\')\\')\\n                i = pair[i], d = -d;\\n            else\\n                res += s[i];\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def reverseParentheses(self, s):\\n        opened = []\\n        pair = {}\\n        for i, c in enumerate(s):\\n            if c == \\'(\\':\\n                opened.append(i)\\n            if c == \\')\\':\\n                j = opened.pop()\\n                pair[i], pair[j] = j, i\\n        res = []\\n        i, d = 0, 1\\n        while i < len(s):\\n            if s[i] in \\'()\\':\\n                i = pair[i]\\n                d = -d\\n            else:\\n                res.append(s[i])\\n            i += d\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 382775,
                "title": "python3-straightforward-easiest-on-discussion",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = [\\'\\']\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(\\'\\')\\n            elif c == \\')\\':\\n                add = stack.pop()[::-1]\\n                stack[-1] += add\\n            else:\\n                stack[-1] += c\\n        return stack.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = [\\'\\']\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(\\'\\')\\n            elif c == \\')\\':\\n                add = stack.pop()[::-1]\\n                stack[-1] += add\\n            else:\\n                stack[-1] += c\\n        return stack.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382367,
                "title": "simple-stack-and-queue-solution",
                "content": "```\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(char c: s.toCharArray()){\\n            if( c == \\')\\'){\\n                Queue<Character> p = new LinkedList<>();\\n                while(!st.isEmpty() && st.peek() != \\'(\\') p.add(st.pop());\\n                if(!st.isEmpty()) st.pop();\\n                while(!p.isEmpty()) st.push(p.remove());\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()) sb.append(st.pop());\\n        \\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(char c: s.toCharArray()){\\n            if( c == \\')\\'){\\n                Queue<Character> p = new LinkedList<>();\\n                while(!st.isEmpty() && st.peek() != \\'(\\') p.add(st.pop());\\n                if(!st.isEmpty()) st.pop();\\n                while(!p.isEmpty()) st.push(p.remove());\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()) sb.append(st.pop());\\n        \\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382422,
                "title": "0-ms-stack-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        string res;\\n        for (int i = 0; i < s.size(); i ++) {\\n            if (s[i] == \\'(\\') {\\n                st.push(i);    \\n            } else if (s[i] == \\')\\') {\\n                int top = st.top();\\n                st.pop();\\n                reverse(s.begin() + top + 1, s.begin() + i);\\n            }\\n        }\\n        for (auto it: s) {\\n            if (it != \\'(\\' && it != \\')\\') {\\n                res.push_back(it);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        string res;\\n        for (int i = 0; i < s.size(); i ++) {\\n            if (s[i] == \\'(\\') {\\n                st.push(i);    \\n            } else if (s[i] == \\')\\') {\\n                int top = st.top();\\n                st.pop();\\n                reverse(s.begin() + top + 1, s.begin() + i);\\n            }\\n        }\\n        for (auto it: s) {\\n            if (it != \\'(\\' && it != \\')\\') {\\n                res.push_back(it);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382358,
                "title": "simple-java-sol-recursion",
                "content": "```\\npublic String reverseParentheses(String s) {\\n        int begin = 0;\\n        int end;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\')\\n                begin = i;\\n            if(s.charAt(i) == \\')\\'){\\n                end = i;\\n                String temp = s.substring(begin + 1, end);\\n                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));\\n            }\\n        }\\n        return s;\\n    }\\n\\n    String reverseString(String s){\\n        char[] temp = s.toCharArray();\\n        StringBuilder r = new StringBuilder();\\n        for (int i = temp.length-1; i>=0; i--)\\n            r.append(temp[i]);\\n\\n        return r.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String reverseParentheses(String s) {\\n        int begin = 0;\\n        int end;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\')\\n                begin = i;\\n            if(s.charAt(i) == \\')\\'){\\n                end = i;\\n                String temp = s.substring(begin + 1, end);\\n                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));\\n            }\\n        }\\n        return s;\\n    }\\n\\n    String reverseString(String s){\\n        char[] temp = s.toCharArray();\\n        StringBuilder r = new StringBuilder();\\n        for (int i = temp.length-1; i>=0; i--)\\n            r.append(temp[i]);\\n\\n        return r.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382421,
                "title": "java-python-3-iterative-short-o-n-2-codes-w-comment-and-analysis",
                "content": "E.g, `s` = `\"(ed(et(oc))el)\"`, output = `\"leetcode\"`\\nPlease refer to the following vivid picture drawn by **@dragonfire** for the code logic.\\n\\n![image](https://assets.leetcode.com/users/rock/image_1568917464.png)\\n**Java**\\nUse a StringBuilder to save substring in a pair of matched brackets and a Deque to save StringBuilders. \\n\\n```\\n    public String reverseParentheses(String s) {\\n        Deque<StringBuilder> dq = new ArrayDeque<>();\\n        dq.push(new StringBuilder()); // In case the first char is NOT \\'(\\', need an empty StringBuilder.\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') { // need a new StringBuilder to save substring in brackets pair\\n                dq.offer(new StringBuilder());\\n            }else if (c == \\')\\') { // found a matched brackets pair and reverse the substring between them.\\n                StringBuilder end = dq.pollLast();\\n                dq.peekLast().append(end.reverse());\\n            }else { // append the char to the last StringBuilder.\\n                dq.peekLast().append(c);\\n            } \\n        }\\n        return dq.pollLast().toString();\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\nUse a List to save substring in a pair of matched brackets and a stack to save Lists. \\n```\\n    def reverseParentheses(self, s: str) -> str:\\n        stk = [[]]\\n        for c in s:\\n            if c == \\'(\\':\\n                stk.append([])\\n            elif c == \\')\\':\\n                end = stk.pop()\\n                stk[-1].extend(reversed(end))\\n            else:\\n                stk[-1].append(c)    \\n        return \\'\\'.join(stk.pop())\\n```\\n\\n**Analysis:**\\n\\nTime: O(n ^ 2), space: O(n), where n = s.length().",
                "solutionTags": [],
                "code": "```\\n    public String reverseParentheses(String s) {\\n        Deque<StringBuilder> dq = new ArrayDeque<>();\\n        dq.push(new StringBuilder()); // In case the first char is NOT \\'(\\', need an empty StringBuilder.\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') { // need a new StringBuilder to save substring in brackets pair\\n                dq.offer(new StringBuilder());\\n            }else if (c == \\')\\') { // found a matched brackets pair and reverse the substring between them.\\n                StringBuilder end = dq.pollLast();\\n                dq.peekLast().append(end.reverse());\\n            }else { // append the char to the last StringBuilder.\\n                dq.peekLast().append(c);\\n            } \\n        }\\n        return dq.pollLast().toString();\\n    }\\n```\n```\\n    def reverseParentheses(self, s: str) -> str:\\n        stk = [[]]\\n        for c in s:\\n            if c == \\'(\\':\\n                stk.append([])\\n            elif c == \\')\\':\\n                end = stk.pop()\\n                stk[-1].extend(reversed(end))\\n            else:\\n                stk[-1].append(c)    \\n        return \\'\\'.join(stk.pop())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 382530,
                "title": "simple-stack-java-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> st = new Stack<>();\\n        String str = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) >= \\'a\\' && s.charAt(i) <= \\'z\\'){\\n                str += s.charAt(i);\\n            }else if(s.charAt(i) == \\'(\\'){\\n                st.push(str);\\n                str = \"\";\\n            }else{\\n                String p = st.pop();\\n                String r = new StringBuilder(str).reverse().toString();\\n                str = p + r;               \\n            }                \\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> st = new Stack<>();\\n        String str = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) >= \\'a\\' && s.charAt(i) <= \\'z\\'){\\n                str += s.charAt(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 834725,
                "title": "c-4ms-clean-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        deque<string> st;\\n        string cur = \"\";\\n        for(int i=0;i<s.size();++i){\\n            if(s[i] == \\'(\\'){\\n                st.push_back(cur);\\n                cur = \"\";\\n            }\\n            else if(s[i] == \\')\\'){\\n                reverse(cur.begin(),cur.end());\\n                cur = st.back()+cur;\\n                st.pop_back();\\n            }else cur += s[i];\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        deque<string> st;\\n        string cur = \"\";\\n        for(int i=0;i<s.size();++i){\\n            if(s[i] == \\'(\\'){\\n                st.push_back(cur);\\n                cur = \"\";\\n            }\\n            else if(s[i] == \\')\\'){\\n                reverse(cur.begin(),cur.end());\\n                cur = st.back()+cur;\\n                st.pop_back();\\n            }else cur += s[i];\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010219,
                "title": "java-using-stack-character",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n    Stack<Character> stack = new Stack<>();\\n\\n    for (char symbol : s.toCharArray()) {\\n      if (symbol == \\')\\')\\n        reverseLast(stack);\\n      else\\n        stack.push(symbol);\\n    }\\n\\n    return stackToString(stack);\\n  }\\n\\n  private void reverseLast(Stack<Character> stack) {\\n    StringBuilder reversed = new StringBuilder();\\n    while (!stack.isEmpty() && stack.peek() != \\'(\\') \\n      reversed.append(stack.pop());\\n\\n    stack.pop();\\n\\n    for (char symbol : reversed.toString().toCharArray()) \\n      stack.push(symbol);\\n  }\\n\\n  private String stackToString(Stack<Character> stack) {\\n    StringBuilder result = new StringBuilder();\\n    \\n    while (!stack.isEmpty()) \\n      result.insert(0, stack.pop());\\n\\n    return result.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n    Stack<Character> stack = new Stack<>();\\n\\n    for (char symbol : s.toCharArray()) {\\n      if (symbol == \\')\\')\\n        reverseLast(stack);\\n      else\\n        stack.push(symbol);\\n    }\\n\\n    return stackToString(stack);\\n  }\\n\\n  private void reverseLast(Stack<Character> stack) {\\n    StringBuilder reversed = new StringBuilder();\\n    while (!stack.isEmpty() && stack.peek() != \\'(\\') \\n      reversed.append(stack.pop());\\n\\n    stack.pop();\\n\\n    for (char symbol : reversed.toString().toCharArray()) \\n      stack.push(symbol);\\n  }\\n\\n  private String stackToString(Stack<Character> stack) {\\n    StringBuilder result = new StringBuilder();\\n    \\n    while (!stack.isEmpty()) \\n      result.insert(0, stack.pop());\\n\\n    return result.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055548,
                "title": "java-stack-3ms",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n       for(char c : s.toCharArray()){\\n           if(c == \\')\\'){\\n               StringBuilder stringBuilder = new StringBuilder();\\n               while (stack.peek() != \\'(\\'){\\n                   stringBuilder.append(stack.pop());\\n               }\\n               stack.pop();\\n               int i = 0;\\n               while (i < stringBuilder.length()){\\n                   stack.push(stringBuilder.charAt(i++));\\n               }\\n           }\\n           else\\n               stack.push(c);\\n       }\\n       StringBuilder stringBuilder = new StringBuilder();\\n       while (!stack.empty()){\\n           stringBuilder.append(stack.pop());\\n       }\\n       return stringBuilder.reverse().toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n       for(char c : s.toCharArray()){\\n           if(c == \\')\\'){\\n               StringBuilder stringBuilder = new StringBuilder();\\n               while (stack.peek() != \\'(\\'){\\n                   stringBuilder.append(stack.pop());\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 382766,
                "title": "python-stack-solution-faster-than-100",
                "content": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        reverse = []\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\')\\':  # pop the substring between nearest parentheses\\n                p = stack.pop()\\n                while p != \\'(\\':\\n                    reverse.append(p)\\n                    p = stack.pop()\\n                stack += reverse\\n                reverse = []\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        reverse = []\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\')\\':  # pop the substring between nearest parentheses\\n                p = stack.pop()\\n                while p != \\'(\\':\\n                    reverse.append(p)\\n                    p = stack.pop()\\n                stack += reverse\\n                reverse = []\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742862,
                "title": "java-straightforward-stack-vs-o-n",
                "content": "StraightForward Stack:\\n\\n```\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(sb);\\n                sb = new StringBuilder();\\n            } else if (c == \\')\\') {\\n                String str = sb.reverse().toString();\\n                sb = st.pop();\\n                sb.append(str);\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\nsolution O(n);\\nref: https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/383670/JavaC%2B%2BPython-Why-not-O(N)\\n```\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') st.push(i);\\n            else if (c == \\')\\') {\\n                int j = st.pop();\\n                map.put(i, j);\\n                map.put(j, i);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, d = 1; i < s.length(); i += d) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\' || c == \\')\\') {\\n                i = map.get(i);\\n                d = -d;\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(sb);\\n                sb = new StringBuilder();\\n            } else if (c == \\')\\') {\\n                String str = sb.reverse().toString();\\n                sb = st.pop();\\n                sb.append(str);\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```\n```\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') st.push(i);\\n            else if (c == \\')\\') {\\n                int j = st.pop();\\n                map.put(i, j);\\n                map.put(j, i);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, d = 1; i < s.length(); i += d) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\' || c == \\')\\') {\\n                i = map.get(i);\\n                d = -d;\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382353,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    std::string reverseParentheses(std::string s) {\\n        int n=s.size();\\n        int begin=0, end=n-1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\')\\n                begin = i;\\n            if(s[i] == \\')\\'){\\n                end = i;\\n                string temp = s.substr(begin + 1, end - begin - 1);\\n                reverse(temp.begin(),temp.end());\\n                return reverseParentheses(s.substr(0, begin) + temp + s.substr(end + 1));\\n             }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::string reverseParentheses(std::string s) {\\n        int n=s.size();\\n        int begin=0, end=n-1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\')\\n                begin = i;\\n            if(s[i] == \\')\\'){\\n                end = i;\\n                string temp = s.substr(begin + 1, end - begin - 1);\\n                reverse(temp.begin(),temp.end());\\n                return reverseParentheses(s.substr(0, begin) + temp + s.substr(end + 1));\\n             }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393124,
                "title": "straightforward-iterative-solution-java-99-runtime-100-memory",
                "content": "#### Intuition\\n\\nBasicaly for each character in string, we need to consider the three following cases:\\n- every `\\'(\\'` starts a new level to be reversed;\\n- and `\\')\\'` will pop that level, then we do reverse on the popped level, and append it to its parent level;\\n- and for any other characters, we simply append it to current level.\\n\\n#### Analysis\\n\\nSpace: `O(n)` to store all characters other than brackets\\nTime: best case `O(n)` to worst case `O(n^2)`\\n- `O(n)`to loop through the string\\n- each `StringBuilder.append` takes an amortized constant time, so best case will be `O(n)`, e.g. for `\"abcd\"`\\n- each `StringBuilder.reverse` takes linear time, so worst case will be `O(n^2)`, e.g. for `\"((abcd))\"`\\n\\n#### Optimization [TODO]\\n\\nIn this solution, even levels will be reversed even number of times back to its original form, so they do not need to be reversed, and we can omit reversing these levels by adding them directly to odd levels between the reversed head and tail. Thus reversal wil be reduced to minimum, and time complexity wil be on average `O(n)` (constant time append and at most one constant time swap for each character other than brackets).\\n\\n```java\\npublic String reverseParentheses(String s) {\\n    Deque<StringBuilder> levels = new ArrayDeque<>();\\n    levels.push(new StringBuilder());  // level 0\\n    for (int i = 0; i < s.length(); i++) {\\n        char ch = s.charAt(i);\\n        if (ch == \\'(\\') {\\n            // add level on \\'(\\'\\n            levels.push(new StringBuilder());\\n        } else if (ch == \\')\\') {\\n            // reverse deeper level and append to current level on \\')\\'\\n            StringBuilder deeperLevel = levels.pop().reverse();\\n            levels.peek().append(deeperLevel);\\n        } else {\\n            // simply append chars to current level\\n            levels.peek().append(ch);\\n        }\\n    }\\n    return levels.pop().toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic String reverseParentheses(String s) {\\n    Deque<StringBuilder> levels = new ArrayDeque<>();\\n    levels.push(new StringBuilder());  // level 0\\n    for (int i = 0; i < s.length(); i++) {\\n        char ch = s.charAt(i);\\n        if (ch == \\'(\\') {\\n            // add level on \\'(\\'\\n            levels.push(new StringBuilder());\\n        } else if (ch == \\')\\') {\\n            // reverse deeper level and append to current level on \\')\\'\\n            StringBuilder deeperLevel = levels.pop().reverse();\\n            levels.peek().append(deeperLevel);\\n        } else {\\n            // simply append chars to current level\\n            levels.peek().append(ch);\\n        }\\n    }\\n    return levels.pop().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642951,
                "title": "python3-stack-buffer-w-trace-t-m-98-69",
                "content": "See the comment lines in the code. Looking at the trace of stack and buffer may be the best way to understand the process.\\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n    \\n        stack, buffer = [], \\'\\'\\n      \\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)               \\n\\n            else:\\n                buffer = \\'\\'\\n                while stack[-1] != \\'(\\':\\n                    buffer+= stack.pop()\\n                stack.pop()\\n                    \\n                for ss in buffer:\\n                    stack.append(ss)\\n\\n            # remove the # below to see a trace of the stack and buffer\\n            #print(\\'\\\\tch: \\',ch, \\'\\\\tbuffer: \\', buffer, \\'\\\\tstack: \\', stack)\\n\\n        return \\'\\'.join(stack)\\n```\\n\\n[https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/](http://)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n    \\n        stack, buffer = [], \\'\\'\\n      \\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)               \\n\\n            else:\\n                buffer = \\'\\'\\n                while stack[-1] != \\'(\\':\\n                    buffer+= stack.pop()\\n                stack.pop()\\n                    \\n                for ss in buffer:\\n                    stack.append(ss)\\n\\n            # remove the # below to see a trace of the stack and buffer\\n            #print(\\'\\\\tch: \\',ch, \\'\\\\tbuffer: \\', buffer, \\'\\\\tstack: \\', stack)\\n\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464852,
                "title": "c-0ms-100-faster-using-stack",
                "content": "```\\nstring reverseParentheses(string str)\\n{\\n    stack<int> s;\\n\\n    for (int i = 0; i < str.size(); i++){\\n        if (str[i] == \\'(\\') s.push(i);\\n        else if (str[i] == \\')\\'){\\n            int beg = s.top() + 1;\\n            int end = i;\\n            reverse(str.begin() + beg, str.begin() + end);\\n            s.pop(); \\n\\t\\t\\t}}\\n\\t\\t\\t\\n    string ans; \\n    for (int i = 0; i < str.size(); i++){ \\n        if (str[i] == \\'(\\' || str[i] == \\')\\') continue;\\n        else ans.push_back(str[i]);\\n        }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nstring reverseParentheses(string str)\\n{\\n    stack<int> s;\\n\\n    for (int i = 0; i < str.size(); i++){\\n        if (str[i] == \\'(\\') s.push(i);\\n        else if (str[i] == \\')\\'){\\n            int beg = s.top() + 1;\\n            int end = i;\\n            reverse(str.begin() + beg, str.begin() + end);\\n            s.pop(); \\n\\t\\t\\t}}\\n\\t\\t\\t\\n    string ans; \\n    for (int i = 0; i < str.size(); i++){ \\n        if (str[i] == \\'(\\' || str[i] == \\')\\') continue;\\n        else ans.push_back(str[i]);\\n        }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 787034,
                "title": "runtime-0-ms-faster-than-100-00-easy-understanding-c",
                "content": "\\n      class Solution {\\n      public:\\n          string reverseParentheses(string s) {\\n              stack<char> st;\\n              for(int i=0;i<s.size();i++){\\n                  if(s[i]!=\\')\\'){\\n                      st.push(s[i]);\\n                  }else{\\n                      string w=\"\";\\n                      while(!st.empty()&&st.top()!=\\'(\\'){\\n                          w+=st.top();\\n                          st.pop();\\n                      }\\n                      st.pop();\\n                      for(int j=0;j<w.size();j++){\\n                          st.push(w[j]);\\n                      }\\n                  }\\n              }\\n              s.clear();\\n              while(!st.empty()){\\n                  s+=st.top();\\n                  st.pop();\\n              }\\n              reverse(s.begin(),s.end());\\n              return s;\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n      public:\\n          string reverseParentheses(string s) {\\n              stack<char> st;\\n              for(int i=0;i<s.size();i++){\\n                  if(s[i]!=\\')\\'){\\n                      st.push(s[i]);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 382373,
                "title": "nostack-recursive-method-in-java",
                "content": "```\\n0 <= s.length <= 2000\\n```\\nThis BruteForce will work as length of S is less\\n```\\npublic static String reverseParentheses(String S) {\\n        StringBuilder res = new StringBuilder(S);\\n        int s = -1, e = -1;\\n        for (int i = 0; i < res.length(); i++) {\\n            if (res.charAt(i) == \\'(\\')\\n                s = i;\\n            if (res.charAt(i) == \\')\\') {\\n                e = i;\\n                break;\\n            }\\n        }\\n        if (s == -1)\\n            return res.toString();\\n        StringBuilder temp = new StringBuilder(res.substring(s + 1, e)).reverse();\\n        res = new StringBuilder(res.substring(0, s) + temp + res.substring(e + 1));\\n        return reverseParentheses(res.toString());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n0 <= s.length <= 2000\\n```\n```\\npublic static String reverseParentheses(String S) {\\n        StringBuilder res = new StringBuilder(S);\\n        int s = -1, e = -1;\\n        for (int i = 0; i < res.length(); i++) {\\n            if (res.charAt(i) == \\'(\\')\\n                s = i;\\n            if (res.charAt(i) == \\')\\') {\\n                e = i;\\n                break;\\n            }\\n        }\\n        if (s == -1)\\n            return res.toString();\\n        StringBuilder temp = new StringBuilder(res.substring(s + 1, e)).reverse();\\n        res = new StringBuilder(res.substring(0, s) + temp + res.substring(e + 1));\\n        return reverseParentheses(res.toString());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2570657,
                "title": "c-simplest-solution-for-beginners",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nstring reverseParentheses(string s) \\n    {\\n        stack<int> st;\\n        string answer=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(s.begin()+st.top()+1,s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!= \\'(\\' && s[i]!=\\')\\')\\n                answer=answer+s[i];\\n        }\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring reverseParentheses(string s) \\n    {\\n        stack<int> st;\\n        string answer=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(s.begin()+st.top()+1,s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!= \\'(\\' && s[i]!=\\')\\')\\n                answer=answer+s[i];\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2290806,
                "title": "python-sol-recursion-and-stack-sol-detailed-explanation-with-pictrue",
                "content": "# PICTURE EXPLANATION\\n![image](https://assets.leetcode.com/users/images/c39bab87-d055-4d70-b1fe-39b1eddb38c0_1657984760.4599788.png)\\n\\n\\n\\n\\n\\n# RECURSION BASED CODE\\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        def solve(string):\\n            n = len(string)\\n            word = \"\"\\n            i = 0\\n            while i <n:\\n                if string[i] == \\'(\\':\\n                    new = \"\"\\n                    count = 0\\n                    while True:\\n                        count += 1 if string[i] == \\'(\\' else -1 if string[i] == \\')\\' else 0\\n                        if count == 0: break\\n                        new += string[i]\\n                        i += 1\\n                    i += 1\\n                    word += solve(new[1:])\\n                else:\\n                    word += string[i]\\n                    i += 1\\n            return word[::-1]\\n        return solve(s)[::-1]\\n    \\n```\\n\\n# STACK BASED CODE \\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        for i in s:\\n            if i == \\')\\':\\n                tmp = \"\"\\n                while stack[-1] != \\'(\\':\\n                    tmp += stack.pop()\\n                stack.pop()\\n                for j in tmp: stack.append(j)\\n            else:\\n                stack.append(i)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        def solve(string):\\n            n = len(string)\\n            word = \"\"\\n            i = 0\\n            while i <n:\\n                if string[i] == \\'(\\':\\n                    new = \"\"\\n                    count = 0\\n                    while True:\\n                        count += 1 if string[i] == \\'(\\' else -1 if string[i] == \\')\\' else 0\\n                        if count == 0: break\\n                        new += string[i]\\n                        i += 1\\n                    i += 1\\n                    word += solve(new[1:])\\n                else:\\n                    word += string[i]\\n                    i += 1\\n            return word[::-1]\\n        return solve(s)[::-1]\\n    \\n```\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        for i in s:\\n            if i == \\')\\':\\n                tmp = \"\"\\n                while stack[-1] != \\'(\\':\\n                    tmp += stack.pop()\\n                stack.pop()\\n                for j in tmp: stack.append(j)\\n            else:\\n                stack.append(i)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811247,
                "title": "actual-o-n-solution-for-humans-using-dfs-explanation-with-pictures",
                "content": "Out of all of the current posts, there is exactly **one** that is actually `O(n)`, which is Lee\\'s amazing post using wormholes. Every other claimed `O(n)` solution is either a copy of Lee\\'s code, or not a real `O(n)` solution (they all assume that reversing a string can be done in constant time, which is false). \\n\\nHere, I want to present a true `O(n)` solution for mortal humans, that you or I could actually come up with in an interview. The idea is to build an n-ary tree to represent our string. Each \\'level\\' of the tree represents one layer of nested parentheses.\\n\\nThe top level tree-nodes are either: \\n1.  A letter that is not contained in parentheses\\n\\n2.  A tree-node representing a pair of parentheses at the outermost layer of our string.\\n\\n\\n\\nAs an example:\\n\\n```python\\ns = \"(ED(ET(OC))EL)\"\\n```\\n\\n![image](https://assets.leetcode.com/users/images/38d079d5-dc97-4b06-a208-1e337f3a3b1a_1646185360.2967298.png)\\n\\n\\n\\nThere is one node for each set of parentheses, and one node for each letter. Therefore there are `O(n)` nodes in our tree. \\n\\nTo get the effect of reversals, we can traverse the tree in a **depth-first** way recursively. Besides knowing our current node, we just need to know if we\\'re in \\'reverse mode\\': a boolean to tell us whether to visit our node\\'s children from left to right, or right to left. **Every time we go down a level in our tree, whether we\\'re in reverse mode or not is flipped**.\\n\\n\\nTraversal Order:\\n\\n![image](https://assets.leetcode.com/users/images/8218de26-f09f-445b-9292-344d8c506e89_1646186056.9728265.png)\\n\\n\\n****\\n**Python code**:\\n\\n```python\\nclass TreeNode:\\n    def __init__(self, parent=None):\\n        self.parent = parent\\n        self.children = []\\n\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        root_node = TreeNode()\\n        curr_node = root_node\\n\\n        for let in s:\\n            if let == \\'(\\':\\n                new_child = TreeNode(parent=curr_node)\\n                curr_node.children.append(new_child)\\n                curr_node = new_child\\n            elif let == \\')\\':\\n                curr_node = curr_node.parent\\n            else:\\n                curr_node.children.append(let)\\n\\n        answer = []\\n\\n        def dfs(node, is_reversed: bool):\\n            nonlocal answer\\n            num_children = len(node.children)\\n            \\n            if is_reversed:\\n                range_start, range_end, range_step = num_children-1, -1, -1\\n            else:\\n                range_start, range_end, range_step = 0, num_children, 1\\n                \\n            for i in range(range_start, range_end, range_step):\\n                if isinstance(node.children[i], str):\\n                    answer.append(node.children[i])\\n                else:\\n                    dfs(node.children[i], not is_reversed)\\n\\n        dfs(root_node, False)\\n\\n        return \\'\\'.join(answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\ns = \"(ED(ET(OC))EL)\"\\n```\n```python\\nclass TreeNode:\\n    def __init__(self, parent=None):\\n        self.parent = parent\\n        self.children = []\\n\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        root_node = TreeNode()\\n        curr_node = root_node\\n\\n        for let in s:\\n            if let == \\'(\\':\\n                new_child = TreeNode(parent=curr_node)\\n                curr_node.children.append(new_child)\\n                curr_node = new_child\\n            elif let == \\')\\':\\n                curr_node = curr_node.parent\\n            else:\\n                curr_node.children.append(let)\\n\\n        answer = []\\n\\n        def dfs(node, is_reversed: bool):\\n            nonlocal answer\\n            num_children = len(node.children)\\n            \\n            if is_reversed:\\n                range_start, range_end, range_step = num_children-1, -1, -1\\n            else:\\n                range_start, range_end, range_step = 0, num_children, 1\\n                \\n            for i in range(range_start, range_end, range_step):\\n                if isinstance(node.children[i], str):\\n                    answer.append(node.children[i])\\n                else:\\n                    dfs(node.children[i], not is_reversed)\\n\\n        dfs(root_node, False)\\n\\n        return \\'\\'.join(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489765,
                "title": "easy-to-understand-code-in-c-stack",
                "content": "class Solution {\\npublic:\\n\\n\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        for (int i = 0; i < s.size(); i++){\\n        if (s[i] == \\'(\\') {\\n\\t\\t   st.push(i);\\n\\t\\t }\\n        else if (s[i] == \\')\\'){\\n            int beg = st.top();\\n            int end = i;\\n            reverse(s.begin() + beg, s.begin() + end);\\n            st.pop();\\n        }\\n    }\\n\\t\\t\\t\\n    string ans; \\n    for (int i = 0; i < s.size(); i++){ \\n        if (s[i] == \\'(\\' || s[i] == \\')\\'){\\n\\t\\t    continue;\\n\\t\\t}\\n        else ans.push_back(s[i]);\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        for (int i = 0; i < s.size(); i++){\\n        if (s[i] == \\'(\\') {\\n\\t\\t   st.push(i);\\n\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 1167670,
                "title": "100-efficient-solution-using-stack",
                "content": "**Approach**:  As we have to reverse the substring beween every pair, so we store the index whenever we get an open parenthesis and since it is given that it is balanced means if we encounter any closed parenthesis then the we must have a index of its matching open \\'(\\' parenthesis at the tos. we pop it and reverse from the index at tos and \\nthe current index we are on and the process repeats.\\n\\n**Time** : O(n^2) **space** : O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<int>st;\\n        for(int i=0;i<s.size();i++){\\n          \\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\'){\\n                int j=st.top();\\n                st.pop();\\n                s[i]=\\'$\\',s[j]=\\'$\\';\\n                reverse(s.begin()+j+1,s.begin()+i);\\n            }\\n        }\\n        string res=\"\";\\n        for(auto x:s){\\n            if(x!=\\'$\\') res+=x;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nUpvote if you like it!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<int>st;\\n        for(int i=0;i<s.size();i++){\\n          \\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\'){\\n                int j=st.top();\\n                st.pop();\\n                s[i]=\\'$\\',s[j]=\\'$\\';\\n                reverse(s.begin()+j+1,s.begin()+i);\\n            }\\n        }\\n        string res=\"\";\\n        for(auto x:s){\\n            if(x!=\\'$\\') res+=x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968285,
                "title": "c-code-that-is-faster-than-100-online-users-and-runtime-0ms",
                "content": "<h2>Solution using Stack data structure </h2>\\n<hr>\\n\\nI used stack to store the index of previous paranthesis and then just reverse the string in the range of the open and close paranthesis.\\nThen just remove the paranthesis and return the string .\\n<hr>\\n\\n## C++ Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack <int> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size())\\n                {\\n                    int idx = st.top();\\n                    st.pop();\\n                    reverse(s.begin() + idx+1 , s.begin() + i);\\n                }\\n            }\\n        }\\n        string s1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n            {\\n                s1.push_back(s[i]);\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```\\n\\n<code>C++</code>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack <int> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            else if(s[i] == \\')\\')\\n            {\\n                if(st.size())\\n                {\\n                    int idx = st.top();\\n                    st.pop();\\n                    reverse(s.begin() + idx+1 , s.begin() + i);\\n                }\\n            }\\n        }\\n        string s1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n            {\\n                s1.push_back(s[i]);\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785690,
                "title": "0ms-c-using-stack-commented-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        //Stack to hold all the strings when \\'(\\' comes;\\n        stack<string> st;\\n        //intially assume current string empty\\n        string curr_s = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            //if somewhere u find \\'(\\' store curr_s into stack\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(curr_s);\\n                curr_s = \"\";\\n            }\\n            //as brackets are closed reverse the curr_s and concatenate with stack top value\\n            else if(s[i] == \\')\\')\\n            {\\n                reverse(curr_s.begin(), curr_s.end());\\n                string top = st.top();\\n                st.pop();\\n                top.append(curr_s);\\n                curr_s = top;\\n            }\\n            else\\n                curr_s.push_back(s[i]);\\n        }\\n        //return the curr_s\\n        return curr_s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        //Stack to hold all the strings when \\'(\\' comes;\\n        stack<string> st;\\n        //intially assume current string empty\\n        string curr_s = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            //if somewhere u find \\'(\\' store curr_s into stack\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(curr_s);\\n                curr_s = \"\";\\n            }\\n            //as brackets are closed reverse the curr_s and concatenate with stack top value\\n            else if(s[i] == \\')\\')\\n            {\\n                reverse(curr_s.begin(), curr_s.end());\\n                string top = st.top();\\n                st.pop();\\n                top.append(curr_s);\\n                curr_s = top;\\n            }\\n            else\\n                curr_s.push_back(s[i]);\\n        }\\n        //return the curr_s\\n        return curr_s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395921,
                "title": "c-stack-o-n-lazy-reversals-with-explanation-100-runtime-memory",
                "content": "I maintain a stack of tuples, where each tuple consists of a string and a boolean value (a reverse bit). So, the moment I see the first \\'(\\' single parenthesis, I set the reverse bit to 1 for it and for subsequent characters until I either come across a single \\')\\' parenthesis or another single \\'(\\' parenthesis. A \\')\\' denotes that the characters between the last seen pair of parentheses are to be \\'reversed\\'. Also, such a setup guarantees that all the strings between a pair of parentheses will have the same reverse bit.\\n\\nIf I come across another single \\'(\\' parenthesis, I flip the reverse bit for it and for subsequent characters until interrupted like explained above. However, if I come across a single \\')\\' parenthesis, I decide to build the substring that lies between this last seen pair of parentheses, which would mean popping off entries from the stack.\\n\\nNow, the direction of concatenation is key too. If the reverse bit is set for such a sequence of characters, I try to produce a reversed sequence of characters, which means I append each popped element to the right of the string I build. Otherwise, I append it to the left to build a string that reads normal. Once I reach the end of this sequence, I put this built  string, which is just a substring of the result (probably reversed too) back onto the stack and set its reverse bit to the complement of the reverse bits of all its characters from before. \\n\\nHere\\'s an example where I breakdown my process upon encountering each single \\')\\' parenthesis :\\n\\nInput : s = \"(ed(et(oc))el)\"\\n\\n- Stack = Top -> {\"c\",T} {\"o\",T} {\"(\",T} {\"t\",F} {\"e\",F} {\"(\",F} {\"d\",T} {\"e\",T} {\"(\",T}\\nPopping until I get rid of the corresponding \\'(\\' from the stack and building a substring too.\\nGrowth of the substring with each pop until \\'(\\' is popped : \"c\" -> \"co\"\\nNote that all of them had their reverse bit set to the same value of true.\\n\\nPutting this substring back on the stack with the reverse bit complemented. So now the stack looks as follows :\\n- Stack = Top -> {\"co\",F} {\"t\",F} {\"e\",F} {\"(\",F} {\"d\",T} {\"e\",T} {\"(\",T}\\nThe next character in the string is another single \\')\\' parenthesis. So we repeat our process of popping and building the substring.\\nGrowth of the substring with each pop until \\'(\\' is popped : \"co\" -> \"tco\" -> \"etco\"\\nNote that all of the popped entries had their reverse bit set to the same value of false.\\n\\nPutting this substring back on the stack with the reverse bit complemented. So now the stack looks as follows :\\n- Stack = Top -> {\"etco\",T} {\"d\",T} {\"e\",T} {\"(\",T}\\nBy the time we come across the last single \\')\\' parenthesis, the stack looks as follows :\\n- Stack = Top -> {\"l\",T} {\"e\",T} {\"etco\",T} {\"d\",T} {\"e\",T} {\"(\",T}\\nPopping and building the substring :\\n\"l\" -> \"le\" -> \"leetco\" -> \"leetcod\" -> \"leetcode\"\\n\\nSo we have \"leetcode\" as the final output string.\\n\\nThis solution did show to beat 100% of C++ solutions, both in terms of time and memory used. Although, I am not a 100% certain about the O(n) complexity claim because of all the string concatenations. Any thoughts or possible confirmation of this would be great. This was a fun question and I hope you guys would enjoy reading through my solution and solving it too. Cheers!\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        bool curr = false;\\n        string ans = \"\", temp;\\n        stack<pair<string,bool> > st;\\n        for (auto &x : s) {\\n            temp = x;\\n            if (x == \\'(\\') {\\n                curr = !curr;\\n                st.push({temp,curr});\\n            }\\n            else if (x != \\')\\')\\n                st.push({temp,curr});\\n            else {\\n                temp = \"\";\\n                while(st.top().first != \"(\") {\\n                    if (curr)\\n                        temp = temp + st.top().first;\\n                    else\\n                        temp = st.top().first + temp;\\n                    st.pop();\\n                }\\n                st.pop();\\n                curr = !curr;\\n                st.push({temp,curr});\\n            }\\n        }\\n        while (!st.empty()) {\\n            if (st.top().second)\\n                ans = ans + st.top().first;\\n            else\\n                ans = st.top().first + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        bool curr = false;\\n        string ans = \"\", temp;\\n        stack<pair<string,bool> > st;\\n        for (auto &x : s) {\\n            temp = x;\\n            if (x == \\'(\\') {\\n                curr = !curr;\\n                st.push({temp,curr});\\n            }\\n            else if (x != \\')\\')\\n                st.push({temp,curr});\\n            else {\\n                temp = \"\";\\n                while(st.top().first != \"(\") {\\n                    if (curr)\\n                        temp = temp + st.top().first;\\n                    else\\n                        temp = st.top().first + temp;\\n                    st.pop();\\n                }\\n                st.pop();\\n                curr = !curr;\\n                st.push({temp,curr});\\n            }\\n        }\\n        while (!st.empty()) {\\n            if (st.top().second)\\n                ans = ans + st.top().first;\\n            else\\n                ans = st.top().first + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382364,
                "title": "easy-python-t-o-n-2-s-o-n",
                "content": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        st = [collections.deque([])]               \\n        for i in s:            \\n            if i==\\'(\\':\\n                st.append(collections.deque([]))\\n            elif i==\\')\\':        \\n                last = st.pop()\\n                st[-1].extendleft(last)\\n            else:\\n                st[-1].appendleft(i)\\n        \\n        return \\'\\'.join(st[-1])[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        st = [collections.deque([])]               \\n        for i in s:            \\n            if i==\\'(\\':\\n                st.append(collections.deque([]))\\n            elif i==\\')\\':        \\n                last = st.pop()\\n                st[-1].extendleft(last)\\n            else:\\n                st[-1].appendleft(i)\\n        \\n        return \\'\\'.join(st[-1])[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489526,
                "title": "best-solution-easy-to-understand-cpp-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing stack data structure\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nopertions on string like push pop..\\n\\n# Complexity\\n- time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n=s.size();\\n        string ans,temp;\\n        stack<char>stack;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                stack.push(s[i]);\\n            }\\n            else\\n            {\\n                temp=\"\";\\n                while(stack.top()!=\\'(\\')\\n                {\\n                    temp+=stack.top();\\n                    stack.pop();\\n                }\\n                stack.pop();\\n                for(int j=0;j<temp.size();j++)\\n                {\\n                    stack.push(temp[j]);\\n                }\\n            }\\n        }\\n        ans=\"\";\\n        while(!stack.empty())\\n        {\\n            ans+=stack.top();\\n            stack.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n=s.size();\\n        string ans,temp;\\n        stack<char>stack;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                stack.push(s[i]);\\n            }\\n            else\\n            {\\n                temp=\"\";\\n                while(stack.top()!=\\'(\\')\\n                {\\n                    temp+=stack.top();\\n                    stack.pop();\\n                }\\n                stack.pop();\\n                for(int j=0;j<temp.size();j++)\\n                {\\n                    stack.push(temp[j]);\\n                }\\n            }\\n        }\\n        ans=\"\";\\n        while(!stack.empty())\\n        {\\n            ans+=stack.top();\\n            stack.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768062,
                "title": "runtime-0-ms-faster-than-100-00-memory-usage-6-5-mb-less-than-35-59-of-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        vector<string> v;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(ans);\\n                ans=\"\";\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(ans.begin(),ans.end());\\n                ans=v.back()+ans;\\n                v.pop_back();\\n            }\\n            else\\n                ans+=s[i];\\n        }\\n   return ans; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        vector<string> v;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(ans);\\n                ans=\"\";\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(ans.begin(),ans.end());\\n                ans=v.back()+ans;\\n                v.pop_back();\\n            }\\n            else\\n                ans+=s[i];\\n        }\\n   return ans; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003420,
                "title": "c-stacks-100-fastest",
                "content": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int>index;\\n        stack<char>brackets;\\n        \\n        if(s.length()==1)\\n            return s;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\'){\\n                brackets.push(s[i]);\\n                index.push(i+1);\\n            }\\n            if(s[i]==\\')\\' && brackets.top()==\\'(\\')\\n            {\\n                int ind=i-1;\\n                reverse(s.begin() + index.top(), s.begin() + ind+1);\\n                index.pop();\\n                brackets.pop();\\n            }   \\n        }\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\')\\n                ans+=s[i];\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int>index;\\n        stack<char>brackets;\\n        \\n        if(s.length()==1)\\n            return s;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\'){\\n                brackets.push(s[i]);\\n                index.push(i+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1610773,
                "title": "c-beats-100-reverse-substrings-between-each-pair-of-parentheses-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n         stack<char> stk;\\n        string st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\')\\')stk.push(s[i]);\\n            else {\\n                while(stk.top()!=\\'(\\'){\\n                    st+=stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop();\\n                int i=0;\\n                while(i<st.size()){\\n                    stk.push(st[i]);\\n                    i++;\\n                } \\n                    st.clear();\\n            }\\n            \\n        }\\n        while(stk.size()>0){\\n            st+=stk.top();\\n                    stk.pop();\\n        }\\n        reverse(st.begin(),st.end());\\n        return st;\\n    }\\n};\\n```\\nupvote if get ;)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n         stack<char> stk;\\n        string st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\')\\')stk.push(s[i]);\\n            else {\\n                while(stk.top()!=\\'(\\'){\\n                    st+=stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop();\\n                int i=0;\\n                while(i<st.size()){\\n                    stk.push(st[i]);\\n                    i++;\\n                } \\n                    st.clear();\\n            }\\n            \\n        }\\n        while(stk.size()>0){\\n            st+=stk.top();\\n                    stk.pop();\\n        }\\n        reverse(st.begin(),st.end());\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464844,
                "title": "c-0ms-beats-100-submissions-can-it-be-done-in-even-less-space-10-line",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(int index = 0 ; index < s.size() ; index++)\\n        {\\n            if(s[index] == \\'(\\')\\n                st.push(index);\\n            else if(s[index] == \\')\\'){\\n                reverse(s.begin() + st.top() , s.begin() + index);\\n                st.pop();\\n            }\\n        }\\n         s.erase(remove(s.begin(), s.end(), \\'(\\'),s.end());\\n         s.erase(remove(s.begin(), s.end(), \\')\\'),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(int index = 0 ; index < s.size() ; index++)\\n        {\\n            if(s[index] == \\'(\\')\\n                st.push(index);\\n            else if(s[index] == \\')\\'){\\n                reverse(s.begin() + st.top() , s.begin() + index);\\n                st.pop();\\n            }\\n        }\\n         s.erase(remove(s.begin(), s.end(), \\'(\\'),s.end());\\n         s.erase(remove(s.begin(), s.end(), \\')\\'),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869064,
                "title": "very-easy-js-solution",
                "content": "```\\nvar reverseParentheses = function(s) {\\n    let stack = [[]];\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') stack.push([]);    \\n        else if (s[i] === \\')\\') {\\n            let cur = stack.pop().reverse();\\n            stack[stack.length-1].push(...cur);\\n        }\\n        else stack[stack.length-1].push(s[i]);    \\n    }\\n    return stack[0].join(\"\");\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseParentheses = function(s) {\\n    let stack = [[]];\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'(\\') stack.push([]);    \\n        else if (s[i] === \\')\\') {\\n            let cur = stack.pop().reverse();\\n            stack[stack.length-1].push(...cur);\\n        }\\n        else stack[stack.length-1].push(s[i]);    \\n    }\\n    return stack[0].join(\"\");\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765616,
                "title": "1ms-java-solution-with-stringbuilder-and-stack",
                "content": "```\\npublic String reverseParentheses(String s) {\\n        Stack<String> stack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: s.toCharArray()){\\n            if(c ==\\'(\\'){\\n                stack.push(sb.toString());\\n                sb = new StringBuilder();\\n            } else if(c ==\\')\\'){\\n                sb = sb.reverse();\\n                sb.insert(0,stack.pop());\\n            } else {\\n                sb.append(c);\\n            } \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic String reverseParentheses(String s) {\\n        Stack<String> stack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        for(char c: s.toCharArray()){\\n            if(c ==\\'(\\'){\\n                stack.push(sb.toString());\\n                sb = new StringBuilder();\\n            } else if(c ==\\')\\'){\\n                sb = sb.reverse();\\n                sb.insert(0,stack.pop());\\n            } else {\\n                sb.append(c);\\n            } \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683940,
                "title": "java-solution-stack-with-comments",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char c : s.toCharArray()) {\\n            // Find an inner word between two ( ) needs to be reversed.\\n            if (c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\t// Reverse it in a StringBuilder until you reach (\\n                while(stack.peek() != \\'(\\') {\\n                    sb.append(stack.pop());\\n                }\\n                // Pop ( we donot needed it anymore\\n                stack.pop();\\n                // Push the reversed word again inside the stack.\\n                for(char insideC : sb.toString().toCharArray()){\\n                    stack.push(insideC);\\n                }\\n            } else {\\n                // Any character simply push to Stack.\\n                stack.push(c);\\n            }\\n        }\\n        // Here I\\'m done but my word is inside the stack, needs one more reverse. \\n        StringBuilder result = new StringBuilder();\\n        while(!stack.isEmpty()) {\\n            result.insert(0, stack.pop());\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char c : s.toCharArray()) {\\n            // Find an inner word between two ( ) needs to be reversed.\\n            if (c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\t// Reverse it in a StringBuilder until you reach (\\n                while(stack.peek() != \\'(\\') {\\n                    sb.append(stack.pop());\\n                }\\n                // Pop ( we donot needed it anymore\\n                stack.pop();\\n                // Push the reversed word again inside the stack.\\n                for(char insideC : sb.toString().toCharArray()){\\n                    stack.push(insideC);\\n                }\\n            } else {\\n                // Any character simply push to Stack.\\n                stack.push(c);\\n            }\\n        }\\n        // Here I\\'m done but my word is inside the stack, needs one more reverse. \\n        StringBuilder result = new StringBuilder();\\n        while(!stack.isEmpty()) {\\n            result.insert(0, stack.pop());\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570144,
                "title": "c-beats-100-in-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n    string res;\\n    stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                res=\"\";\\n                while(!st.empty() && st.top()!=\\'(\\')\\n                {\\n                    res+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j=0;j<res.length();j++)\\n                    st.push(res[j]);\\n            }\\n        }\\n        res=\"\";\\n        while(!st.empty())\\n        {\\n            res+=st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n    string res;\\n    stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                res=\"\";\\n                while(!st.empty() && st.top()!=\\'(\\')\\n                {\\n                    res+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j=0;j<res.length();j++)\\n                    st.push(res[j]);\\n            }\\n        }\\n        res=\"\";\\n        while(!st.empty())\\n        {\\n            res+=st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382499,
                "title": "c-using-stack-and-reverse-function",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void reverse(std::string& s,int i,int j)\\n    {\\n        while(i <= j)\\n        {\\n            std::swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string s) {\\n        std::string ret;\\n        if(s.empty())\\n            return \"\";\\n        std::stack<int> stack;\\n        for(int i = 0; i < s.size();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                stack.push(i);\\n            }else if(s[i] == \\')\\')\\n            {\\n                auto top = stack.top();\\n                stack.pop();\\n                reverse(s,top+1,i-1);\\n            }\\n        }\\n        for(int i = 0; i < s.size();i++)\\n        {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n            {\\n                ret += s[i];\\n            }\\n        }\\n        return ret;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void reverse(std::string& s,int i,int j)\\n    {\\n        while(i <= j)\\n        {\\n            std::swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 382379,
                "title": "python3-regex-find",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        while \\'(\\' in s:\\n            posopen=s.rfind(\\'(\\')\\n            posclose=s.find(\\')\\',posopen+1)\\n            s=s[:posopen]+s[posopen+1:posclose][::-1]+s[posclose+1:]\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        while \\'(\\' in s:\\n            posopen=s.rfind(\\'(\\')\\n            posclose=s.find(\\')\\',posopen+1)\\n            s=s[:posopen]+s[posopen+1:posclose][::-1]+s[posclose+1:]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282686,
                "title": "easy-to-understand-for-beginners-with-approach",
                "content": "1. Create a Stack to store characters that are not within parentheses.\\n2. Iterate through each character in the input string s.\\n3. If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n4. If the current character is not a parentheses, push it onto the Stack.\\n5. After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n6. Return the result StringBuilder in reverse order.\\n```\\npublic String reverseParentheses(String s) {\\n   Stack<Character> stack = new Stack<>();\\n   // Iterate through each character in the string\\n   for (char c : s.toCharArray()) {\\n       // If the character is a closing parentheses, reverse the string within the parentheses\\n       if (c == \\')\\') {\\n           StringBuilder sb = new StringBuilder();\\n           // Pop characters from the stack until an opening parentheses is found\\n           while (!stack.isEmpty() && stack.peek() != \\'(\\') {\\n               sb.append(stack.pop());\\n           }\\n           // Pop the opening parentheses\\n           stack.pop();\\n           // Add the reversed string within parentheses back to the stack\\n           while (!sb.isEmpty()) {\\n               stack.add(sb.charAt(0));\\n               sb.deleteCharAt(0);\\n           }\\n       }\\n       // If the character is not a closing parentheses, add it to the stack\\n       else {\\n           stack.add(c);\\n       }\\n   }\\n   // Create a StringBuilder to store the final output\\n   StringBuilder ans = new StringBuilder();\\n   // Pop all the characters from the stack and add them to the StringBuilder\\n   while (!stack.isEmpty()) {\\n       ans.append(stack.pop());\\n   } \\n   // Reverse the StringBuilder and convert it to a String\\n   return ans.reverse().toString();\\n}\\n```\\n# UpVoting is Much Appreciated",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic String reverseParentheses(String s) {\\n   Stack<Character> stack = new Stack<>();\\n   // Iterate through each character in the string\\n   for (char c : s.toCharArray()) {\\n       // If the character is a closing parentheses, reverse the string within the parentheses\\n       if (c == \\')\\') {\\n           StringBuilder sb = new StringBuilder();\\n           // Pop characters from the stack until an opening parentheses is found\\n           while (!stack.isEmpty() && stack.peek() != \\'(\\') {\\n               sb.append(stack.pop());\\n           }\\n           // Pop the opening parentheses\\n           stack.pop();\\n           // Add the reversed string within parentheses back to the stack\\n           while (!sb.isEmpty()) {\\n               stack.add(sb.charAt(0));\\n               sb.deleteCharAt(0);\\n           }\\n       }\\n       // If the character is not a closing parentheses, add it to the stack\\n       else {\\n           stack.add(c);\\n       }\\n   }\\n   // Create a StringBuilder to store the final output\\n   StringBuilder ans = new StringBuilder();\\n   // Pop all the characters from the stack and add them to the StringBuilder\\n   while (!stack.isEmpty()) {\\n       ans.append(stack.pop());\\n   } \\n   // Reverse the StringBuilder and convert it to a String\\n   return ans.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3126635,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\')\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                while(stack.peek()!=\\'(\\'){\\n                ans+=stack.pop();\\n                }\\n                stack.pop();\\n                // if(!stack.isEmpty()){\\n                    for(int j=0;j<ans.length();j++){\\n                        stack.push(ans.charAt(j));\\n                    }\\n                    ans=\"\";\\n                // }\\n                \\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            ans=stack.pop()+ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=\\')\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                while(stack.peek()!=\\'(\\'){\\n                ans+=stack.pop();\\n                }\\n                stack.pop();\\n                // if(!stack.isEmpty()){\\n                    for(int j=0;j<ans.length();j++){\\n                        stack.push(ans.charAt(j));\\n                    }\\n                    ans=\"\";\\n                // }\\n                \\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            ans=stack.pop()+ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920435,
                "title": "c-easy-to-understand-well-explained",
                "content": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n       \\n\\t   // initalize a stack\\n\\t\\t\\n        stack<int>st;\\n        int i;\\n        int n = s.size();\\n\\t// the main logic is that every time we encounter \\'(\\' open bracket we will store it index in the stack\\n\\t// when we encounter \\')\\' close bracket then we will reverse the string from st.top()+1 to current index \\'i\\'.\\n\\t\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                int start = st.top() + 1;\\n                int end = i;\\n\\t\\t\\t\\t// will reverse the string  and pop the top index stored in stack.\\n                reverse(s.begin()+start,s.begin()+end);\\n                st.pop();\\n            }\\n        }\\n\\t\\t// at last we will initalize a new string and store all characters except open and close bracket and will return the final string.\\n        string v = \"\";\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\' || s[i] == \\')\\')\\n            {\\n                continue;\\n            }\\n            v.push_back(s[i]);\\n        }\\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n       \\n\\t   // initalize a stack\\n\\t\\t\\n        stack<int>st;\\n        int i;\\n        int n = s.size();\\n\\t// the main logic is that every time we encounter \\'(\\' open bracket we will store it index in the stack\\n\\t// when we encounter \\')\\' close bracket then we will reverse the string from st.top()+1 to current index \\'i\\'.\\n\\t\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                st.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2912845,
                "title": "reverse-substrings-between-each-pair-of-parentheses-beats-100-time-complexity",
                "content": "# Intuition\\njust observer the position of opening and closing index in the string \\n\\n\\n# Approach\\non observing the position you can see that betweeen each opening and closing bracket we can use reverse function just by storing the indec of opening bracket and when we find cloasing bracket we have to reverse the string.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\nless than  o(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string ans=\"\";\\n        stack<int>st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n\\n            else if(s[i]==\\')\\'){\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\')\\')\\n            continue;\\n                 ans+=s[i];\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string ans=\"\";\\n        stack<int>st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n\\n            else if(s[i]==\\')\\'){\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'||s[i]==\\')\\')\\n            continue;\\n                 ans+=s[i];\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756606,
                "title": "python-o-n-2-solution-one-pass-very-easy",
                "content": "First, I was so obsessed about keeping the order of the parentheses while solving the problem. But after solving it, I have found out that the problem does not necessarily demand for ordering, do it? Anyways, I will post it.\\n# Algorithm\\nThe problem can easily be solved using **stack**. The algorithm is a **one-pass** algorithm and is a piece of cake.\\n1. We will push the indices of open brackets, ``(``\\n2. Whenever we have found a closed bracket, ``)``, we will:\\n\\t* pop the last index in the stack\\n\\t* reverse the substring from popped index to the current index\\n\\t* Then, the whole input string becomes the subarray until the popped index plus the reversed subarray plus the remaining subarray after, but not including, the current index. This step is **in-place**, meaning the input string is completely changed.\\n\\t* Finally, we will substract two from the running index, ``i=i-2 ``, this is because we have removed two brackets from the running string.\\n\\nI don\\'t think you need a better explanation than this, do you? Well, I have one, a visual explanation :)\\n\\n**Testcase1:** s = \"(ed(et(oc))el)\"\\n\\n![image](https://assets.leetcode.com/users/images/71436d06-b7dd-4a5a-a009-20bfaef3f3c2_1667058442.120432.png)\\nWhen index is 8, we have ``stack = [0, 3, 6]``\\n\\n![image](https://assets.leetcode.com/users/images/ea4eb560-81fa-4fe2-85f6-c987087e464a_1667060514.6186016.png)\\n\\n\\nWhen index `i=9`, we have found a closed bracket, so:\\n\\t* pop the last index in the stack, 6\\n\\t* reverse the string from `i=6` to `i=9`, meaning reverse the string `co` to `oc`\\n\\t* now, the input string becomes `s=(ed(etco)el)`\\n\\t* index becomes, `i=i-2`, `i=9-2`, `i=7`\\nThis process continues while the index is less than length of the string, more formally `while i < len(s)` \\n\\n# Implementation in Python\\n**Time Complexity:** `O(n^2)`\\n**Space Complexity:** `O(stack)`*\\n\\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        i = 0\\n        while i < len(s):\\n            c = s[i]\\n            if c == \\'(\\':\\n                stack.append(i)\\n            elif c == \\')\\':\\n                p = stack.pop()\\n                s = s[:p] + s[i-1:p:-1] + s[i+1:]\\n                i -= 2\\n            i += 1\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        i = 0\\n        while i < len(s):\\n            c = s[i]\\n            if c == \\'(\\':\\n                stack.append(i)\\n            elif c == \\')\\':\\n                p = stack.pop()\\n                s = s[:p] + s[i-1:p:-1] + s[i+1:]\\n                i -= 2\\n            i += 1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583722,
                "title": "python-easy-to-understand-approach-using-a-while-and-for-loop",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        while \\'(\\' in s:\\n            indeks = 0\\n            for i in range(len(s)):\\n                if s[i] == \\'(\\':\\n                    indeks = i\\n                elif s[i] == \\')\\':\\n                    s = s.replace(s[indeks:i+1], s[indeks+1:i][::-1])\\n                    break\\n        return s",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        while \\'(\\' in s:\\n            indeks = 0\\n            for i in range(len(s)):\\n                if s[i] == \\'(\\':\\n                    indeks = i\\n                elif s[i] == \\')\\':\\n                    s = s.replace(s[indeks:i+1], s[indeks+1:i][::-1])\\n                    break\\n        return s",
                "codeTag": "Java"
            },
            {
                "id": 2297815,
                "title": "java-stack-linear-time-with-explanation",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> stack = new Stack<>();\\n        \\n        int j = 0;\\n        while(j < s.length()){\\n            /*\\n                We need to keep on adding whatever comes\\n                as long as it is not a \\')\\'.\\n            */\\n            if(s.charAt(j) != \\')\\')\\n                stack.push(s.charAt(j)+\"\");\\n            \\n            /*\\n                Now that we have encountered an \\')\\', its time\\n                to start popping from top of stack unless we find an opening\\n                parenthesis\\n                \\n                then we just need to reverse the string formed by popping\\n                and put it back on stack. \\n                \\n                Try dry running and it will all make sense\\n            */\\n            else{\\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && !stack.peek().equals(\"(\")){\\n                    sb.append(stack.pop());\\n                }\\n                \\n                stack.pop();\\n                stack.push(sb.reverse().toString());\\n            }\\n            j++;\\n        }\\n        \\n        /*\\n            We have our result string in the stack now,\\n            we just need to pop it and return the reverse of it.\\n        */\\n        StringBuilder res = new StringBuilder();\\n        while(!stack.isEmpty())\\n            res.append(stack.pop());\\n        \\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> stack = new Stack<>();\\n        \\n        int j = 0;\\n        while(j < s.length()){\\n            /*\\n                We need to keep on adding whatever comes\\n                as long as it is not a \\')\\'.\\n            */\\n            if(s.charAt(j) != \\')\\')\\n                stack.push(s.charAt(j)+\"\");\\n            \\n            /*\\n                Now that we have encountered an \\')\\', its time\\n                to start popping from top of stack unless we find an opening\\n                parenthesis\\n                \\n                then we just need to reverse the string formed by popping\\n                and put it back on stack. \\n                \\n                Try dry running and it will all make sense\\n            */\\n            else{\\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && !stack.peek().equals(\"(\")){\\n                    sb.append(stack.pop());\\n                }\\n                \\n                stack.pop();\\n                stack.push(sb.reverse().toString());\\n            }\\n            j++;\\n        }\\n        \\n        /*\\n            We have our result string in the stack now,\\n            we just need to pop it and return the reverse of it.\\n        */\\n        StringBuilder res = new StringBuilder();\\n        while(!stack.isEmpty())\\n            res.append(stack.pop());\\n        \\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203392,
                "title": "stack-simple-solution-cpp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring reverseParentheses(string s) {\\n\\t\\t\\tstack<char> st;\\n\\t\\t\\tstring tmp,str;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\' || (s[i]>=\\'a\\' && s[i]<=\\'z\\'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttmp=\"\";\\n\\t\\t\\t\\t\\twhile(st.top()!=\\'(\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttmp+=st.top();\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tfor(int j=0;j<tmp.size();j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tst.push(tmp[j]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstr=\"\";\\n\\t\\t\\twhile(!st.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tstr+=(st.top());\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}\\n\\t\\t\\treverse(str.begin(),str.end());\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring reverseParentheses(string s) {\\n\\t\\t\\tstack<char> st;\\n\\t\\t\\tstring tmp,str;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\' || (s[i]>=\\'a\\' && s[i]<=\\'z\\'))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2150424,
                "title": "java-solution-using-stacks-o-n",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                // push the pre string to the stack. works if we have nested brackets\\n                st.push(sb.toString());\\n                sb.setLength(0);\\n            } else if (c == \\')\\') {\\n                // reverse the String if we get close ) bracket\\n                sb = sb.reverse();\\n                // insert the before(pre) string to sb from the stack\\n                sb.insert(0, st.pop());\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n/* for eg: \"(u(love)i)\"\\n1) st - \\n   sb - u\\n2) st - u\\n   sb - love.reverse() -> evol\\n   st - \\n   sb - u + evol\\n3) st - \\n   sb - uevol + i\\n   st - \\n   sb - uevoli.reverse() -> iloveu\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<String> st = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                // push the pre string to the stack. works if we have nested brackets\\n                st.push(sb.toString());\\n                sb.setLength(0);\\n            } else if (c == \\')\\') {\\n                // reverse the String if we get close ) bracket\\n                sb = sb.reverse();\\n                // insert the before(pre) string to sb from the stack\\n                sb.insert(0, st.pop());\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n/* for eg: \"(u(love)i)\"\\n1) st - \\n   sb - u\\n2) st - u\\n   sb - love.reverse() -> evol\\n   st - \\n   sb - u + evol\\n3) st - \\n   sb - uevol + i\\n   st - \\n   sb - uevoli.reverse() -> iloveu\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132645,
                "title": "easiest-ever-using-stack-queue-python-list",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        Q = []\\n        for c in s : \\n            if c!=\\')\\' :\\n                stack.append(c)\\n            else:\\n                d= stack.pop()\\n                while d!=\\'(\\':\\n                    Q.append(d)\\n                    d=stack.pop()\\n                while  Q :\\n                    stack.append(Q.pop(0))       \\n        rev_s = \"\".join(stack)\\n        return rev_s",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = []\\n        Q = []\\n        for c in s : \\n            if c!=\\')\\' :\\n                stack.append(c)\\n            else:\\n                d= stack.pop()\\n                while d!=\\'(\\':\\n                    Q.append(d)\\n                    d=stack.pop()\\n                while  Q :\\n                    stack.append(Q.pop(0))       \\n        rev_s = \"\".join(stack)\\n        return rev_s",
                "codeTag": "Java"
            },
            {
                "id": 2109884,
                "title": "very-easy-method-stack-sol-c",
                "content": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n      stack<pair<int,int>> st;\\n      \\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==\\'(\\')\\n          st.push({s[i],i});\\n        else if(s[i]==\\')\\')\\n        {\\n          reverse(s.begin()+st.top().second,s.begin()+i);\\n          st.pop();\\n        }\\n      }\\n      \\n      string ans;\\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==\\')\\' || s[i]==\\'(\\')\\n          continue;\\n        ans+=s[i];\\n      }\\n      \\n      return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n      stack<pair<int,int>> st;\\n      \\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==\\'(\\')\\n          st.push({s[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1619670,
                "title": "java-simple-stack-one-pass-solution",
                "content": "Simple stack one pass solution\\n```\\nclass Solution {\\n    \\n    public String reverseParentheses(String s) {\\n        \\n        Deque<StringBuilder> dq=new ArrayDeque<>();\\n        dq.offerLast(new StringBuilder());\\n        \\n        for(int i=0; i<s.length();i++){\\n            char x=s.charAt(i);\\n            if(x==\\'(\\'){\\n                dq.offerLast(new StringBuilder());\\n            }else if(x==\\')\\'){\\n                StringBuilder curr=dq.pollLast().reverse();\\n                dq.peekLast().append(curr);\\n            }else{\\n                dq.peekLast().append(x);\\n            }\\n            \\n        }\\n        return dq.pollLast().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String reverseParentheses(String s) {\\n        \\n        Deque<StringBuilder> dq=new ArrayDeque<>();\\n        dq.offerLast(new StringBuilder());\\n        \\n        for(int i=0; i<s.length();i++){\\n            char x=s.charAt(i);\\n            if(x==\\'(\\'){\\n                dq.offerLast(new StringBuilder());\\n            }else if(x==\\')\\'){\\n                StringBuilder curr=dq.pollLast().reverse();\\n                dq.peekLast().append(curr);\\n            }else{\\n                dq.peekLast().append(x);\\n            }\\n            \\n        }\\n        return dq.pollLast().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546686,
                "title": "c-solution-0ms-100-faster-80-73-less-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(make_pair(s[i],i+1));\\n            }\\n            else if(s[i]==\\')\\'){\\n                int x=st.top().second;\\n                reverse(s.begin()+x,s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\'(\\'&&s[i]!=\\')\\')\\n                res+=s[i];\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(make_pair(s[i],i+1));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1498122,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.size();\\n        stack<int>m;\\n        \\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                m.push(i);\\n                \\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n               \\n                int r = m.top();\\n                m.pop();\\n                reverse(s.begin()+r,s.begin()+i);\\n               \\n            }\\n            else\\n                ans+=s[i];\\n        }\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n                res+=s[i];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.size();\\n        stack<int>m;\\n        \\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                m.push(i);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1473257,
                "title": "java-easy-solution-o-n-2",
                "content": "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        ArrayList<Character> list=new ArrayList<>();\\n        for(int i =0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\')\\'){\\n               while(st.size()!=0 && st.peek()!=\\'(\\'){\\n                   list.add(st.pop());\\n               } \\n               if(st.size()!=0){\\n                   st.pop();\\n               }\\n               Collections.reverse(list);\\n              for(int a =list.size()-1;a>=0;a--){\\n                //   System.out.print(list.get(a)+\"\\\\t\");\\n                  st.push(list.remove(a));\\n              }\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n        }\\n        String str=\"\";\\n      while(st.size()!=0){\\n          str+=st.pop();\\n      }\\n       char[] try1 = str.toCharArray();\\n       String ss=\"\";\\n        for (int i = try1.length - 1; i >= 0; i--)\\n            ss+=try1[i];\\n        return ss;\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n        ArrayList<Character> list=new ArrayList<>();\\n        for(int i =0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\')\\'){\\n               while(st.size()!=0 && st.peek()!=\\'(\\'){\\n                   list.add(st.pop());\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1435776,
                "title": "python-for-beginners",
                "content": "\\tdef reverseParentheses(s):\\n    while \"(\" in s:  \\n        for i in range(len(s)-1,-1,-1):            \\n            if s[i]==\")\":\\n                j=i              \\n            elif s[i]==\"(\":\\n                ans=s[i+1:j][::-1]\\n                break\\n        s=s[:i]+ans+s[j+1:]\\n    return s",
                "solutionTags": [],
                "code": "\\tdef reverseParentheses(s):\\n    while \"(\" in s:  \\n        for i in range(len(s)-1,-1,-1):            \\n            if s[i]==\")\":\\n                j=i              \\n            elif s[i]==\"(\":\\n                ans=s[i+1:j][::-1]\\n                break\\n        s=s[:i]+ans+s[j+1:]\\n    return s",
                "codeTag": "Python3"
            },
            {
                "id": 1418917,
                "title": "java-deque-based",
                "content": "**Steps:**\\n1. Create a `Stack` s\\n2. For each `char` in input:\\n\\t1.  if it is not `)`: push to `s`\\n\\t2.  else \\n\\t\\t1. reverse Stack `s` content from latest `(` to current stack top\\n3. ans = reverse of `s`\\n\\n\\n**DRY-RUN**:\\nInput: **(ed(et(oc))el)**\\n\\n1.  First `)`\\n\\t1. Before reverse: stack : `(ed(et(oc`\\n\\t2. After reverse: stack : `(ed(etco`\\n2. Second `)`\\n\\t1. Before reverse: stack : `(ed(etco`\\n\\t2. After reverse: stack : `(edocte`\\n3. Third `)`\\n\\t1. Before reverse: stack : `(edocteel`\\n\\t2. After reverse: stack : `leetcode`\\n\\nBelow is the implementation of above approach:\\n\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Deque<Character> stack = new LinkedList<>();\\n        Queue<Character> reverseHelper = new LinkedList<>();\\n        for(char ch: s.toCharArray()) {\\n            if(ch == \\')\\') {\\n                reverse(stack,reverseHelper);\\n            } else {\\n                stack.push(ch);\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\t\\t/*\\n\\t\\tAt this point, we use stack as a deque to avoid extra reverse of stack content\\n\\t\\tKeep popping from the rear of deque\\n\\t\\t*/\\n        Deque<Character> deque = stack;\\n        \\n        while(deque.size() > 0) {\\n            sb.append(deque.pollLast());\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n\\t/*\\n\\tPush everything to queue and push it back to stack\\n\\t*/\\n    void reverse(Deque<Character> st, Queue<Character> q) {\\n        while(st.peek() != \\'(\\') {\\n            q.offer(st.pop());\\n        }\\n        st.pop();\\n        \\n        while(q.size() > 0) {\\n            st.push(q.poll());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Deque<Character> stack = new LinkedList<>();\\n        Queue<Character> reverseHelper = new LinkedList<>();\\n        for(char ch: s.toCharArray()) {\\n            if(ch == \\')\\') {\\n                reverse(stack,reverseHelper);\\n            } else {\\n                stack.push(ch);\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\t\\t/*\\n\\t\\tAt this point, we use stack as a deque to avoid extra reverse of stack content\\n\\t\\tKeep popping from the rear of deque\\n\\t\\t*/\\n        Deque<Character> deque = stack;\\n        \\n        while(deque.size() > 0) {\\n            sb.append(deque.pollLast());\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n\\t/*\\n\\tPush everything to queue and push it back to stack\\n\\t*/\\n    void reverse(Deque<Character> st, Queue<Character> q) {\\n        while(st.peek() != \\'(\\') {\\n            q.offer(st.pop());\\n        }\\n        st.pop();\\n        \\n        while(q.size() > 0) {\\n            st.push(q.poll());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412218,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        n = len(s)\\n        stack = []\\n        for i in range(n):\\n            if s[i] != \\')\\':\\n                stack.append(s[i])\\n            else:\\n                temp = \\'\\'\\n                while stack and stack[-1] != \\'(\\':\\n                    cur = stack.pop()\\n                    temp += str(cur)\\n                stack.pop()\\n                for j in temp:\\n                    stack.append(j)\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        n = len(s)\\n        stack = []\\n        for i in range(n):\\n            if s[i] != \\')\\':\\n                stack.append(s[i])\\n            else:\\n                temp = \\'\\'\\n                while stack and stack[-1] != \\'(\\':\\n                    cur = stack.pop()\\n                    temp += str(cur)\\n                stack.pop()\\n                for j in temp:\\n                    stack.append(j)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207911,
                "title": "c-easy-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        \\n        string temp=\"\";\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                temp=\"\";\\n               while(st.top()!=\\'(\\')\\n               {\\n                    temp+=st.top();\\n                   st.pop();\\n               }\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    for(int j=0;j<temp.length();j++)\\n                        st.push(temp[j]);\\n                }\\n                else\\n                {\\n                    ans+=temp;\\n                }\\n                    \\n                \\n            }\\n            else\\n            {\\n                if(!st.empty())\\n                    st.push(s[i]); \\n                else{\\n                    ans+=s[i];\\n                }\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        \\n        string temp=\"\";\\n        string ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1083877,
                "title": "java-1ms-stack-iterative-stringbuffer",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<StringBuffer> st = new Stack();\\n        st.push(new StringBuffer(\"\"));\\n        for(char ch : s.toCharArray()) {\\n            \\n            if( ch == \\'(\\' ) {\\n                st.push(new StringBuffer(\"\"));\\n            }\\n            else if( ch == \\')\\') {\\n                StringBuffer sb = st.pop(); \\n                sb.reverse();\\n                StringBuffer temp = st.pop();\\n                temp.append(sb);\\n                st.push(temp);\\n            }\\n            else {\\n                st.peek().append(ch);\\n            }\\n            \\n        }\\n        return st.pop().toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<StringBuffer> st = new Stack();\\n        st.push(new StringBuffer(\"\"));\\n        for(char ch : s.toCharArray()) {\\n            \\n            if( ch == \\'(\\' ) {\\n                st.push(new StringBuffer(\"\"));\\n            }\\n            else if( ch == \\')\\') {\\n                StringBuffer sb = st.pop(); \\n                sb.reverse();\\n                StringBuffer temp = st.pop();\\n                temp.append(sb);\\n                st.push(temp);\\n            }\\n            else {\\n                st.peek().append(ch);\\n            }\\n            \\n        }\\n        return st.pop().toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082417,
                "title": "1-ms-java-solution-with-stack-and-stringbuilder-properly-explained-comments",
                "content": "Here\\'s the solution:\\n\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int l = s.length();\\n        /* If length is 0 means there is no character so empty string is returned\\n           if length is 1 means there is no parentheses(since parentheses are balanced) so the string is returned*/\\n        if(l==0||l==1){return s;}\\n        \\n        /* If length is 2 either there will be 2 parentheses or 2 characters */\\n        if(l==2){\\n            if(s.charAt(0)==\\'(\\'){return \"\";}\\n            return s;\\n        }\\n        \\n        String subs;\\n        \\n        /* StringBuilder is used since string is immutable*/\\n        StringBuilder str = new StringBuilder(s), substr;\\n        \\n        /* This stack is used to store the indices of opening brackets */\\n        Stack<Integer> st = new Stack<>();\\n        int x;\\n        Character ch;\\n        \\n        /* Idea here is quite simple: \\n        - Find the matching closing bracket (by help of stack)\\n        - Get index of opening bracket (from stack)\\n          and index of closing bracket (from str)\\n        - Replace the substring from opening bracket index to closing bracket index(both inclusive) by the reverse of substring from opening bracket index + 1 to closing bracket index-1(both inclusive) \\n        - Repeat above process for every pair of matching parantheses\\n        */\\n        \\n        for(int i=0;i<str.length();i++){\\n            ch = str.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(i);\\n            }\\n            else if(ch==\\')\\'){\\n                x = st.pop();\\n                subs = str.substring(x+1,i);\\n                substr = new StringBuilder(subs);\\n                str.replace(x,i+1, substr.reverse().toString());\\n                i-=2;\\n            }\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```\\n\\nDo let me know in comments if there is any suggestions/queries.\\nThanks",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int l = s.length();\\n        /* If length is 0 means there is no character so empty string is returned\\n           if length is 1 means there is no parentheses(since parentheses are balanced) so the string is returned*/\\n        if(l==0||l==1){return s;}\\n        \\n        /* If length is 2 either there will be 2 parentheses or 2 characters */\\n        if(l==2){\\n            if(s.charAt(0)==\\'(\\'){return \"\";}\\n            return s;\\n        }\\n        \\n        String subs;\\n        \\n        /* StringBuilder is used since string is immutable*/\\n        StringBuilder str = new StringBuilder(s), substr;\\n        \\n        /* This stack is used to store the indices of opening brackets */\\n        Stack<Integer> st = new Stack<>();\\n        int x;\\n        Character ch;\\n        \\n        /* Idea here is quite simple: \\n        - Find the matching closing bracket (by help of stack)\\n        - Get index of opening bracket (from stack)\\n          and index of closing bracket (from str)\\n        - Replace the substring from opening bracket index to closing bracket index(both inclusive) by the reverse of substring from opening bracket index + 1 to closing bracket index-1(both inclusive) \\n        - Repeat above process for every pair of matching parantheses\\n        */\\n        \\n        for(int i=0;i<str.length();i++){\\n            ch = str.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(i);\\n            }\\n            else if(ch==\\')\\'){\\n                x = st.pop();\\n                subs = str.substring(x+1,i);\\n                substr = new StringBuilder(subs);\\n                str.replace(x,i+1, substr.reverse().toString());\\n                i-=2;\\n            }\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818312,
                "title": "javascript-beats-98-of-the-runtime-with-comments",
                "content": "```\\nvar reverseParentheses = function(s) {\\n    while (s.includes(\"(\")) { // Check if s has parentheses;\\n        s = s.replace(/\\\\([^\\\\(\\\\)]+\\\\)|\\\\(\\\\)/g, (match) => { \\n\\t\\t\\n\\t\\t\\t// If parentheses are detected, remove them and reverse all of the content inside \\n            return match.slice(1, -1).split(\"\").reverse().join(\"\");\\n        })\\n    }\\n    \\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseParentheses = function(s) {\\n    while (s.includes(\"(\")) { // Check if s has parentheses;\\n        s = s.replace(/\\\\([^\\\\(\\\\)]+\\\\)|\\\\(\\\\)/g, (match) => { \\n\\t\\t\\n\\t\\t\\t// If parentheses are detected, remove them and reverse all of the content inside \\n            return match.slice(1, -1).split(\"\").reverse().join(\"\");\\n        })\\n    }\\n    \\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 784049,
                "title": "java-stack",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stk = new Stack();\\n        String ans =\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\')\\')\\n            {\\n                while(stk.peek()!=\\'(\\')\\n                    ans+=stk.pop();\\n                stk.pop();\\n                for(int j=0;j<ans.length();j++)\\n                    stk.push(ans.charAt(j));\\n                ans=\"\";\\n            }\\n           else{\\n               stk.push(s.charAt(i));\\n           }\\n        }\\n        while(!stk.isEmpty())\\n            ans=stk.pop()+ans;\\n        return ans;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stk = new Stack();\\n        String ans =\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\')\\')\\n            {\\n                while(stk.peek()!=\\'(\\')\\n                    ans+=stk.pop();\\n                stk.pop();\\n                for(int j=0;j<ans.length();j++)\\n                    stk.push(ans.charAt(j));\\n                ans=\"\";\\n            }\\n           else{\\n               stk.push(s.charAt(i));\\n           }\\n        }\\n        while(!stk.isEmpty())\\n            ans=stk.pop()+ans;\\n        return ans;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774385,
                "title": "simple-c-solution-0ms-solution-with-explanation",
                "content": "The order of reversal doesnt matter. So we first reverse the inner most bracket and then the outer ones. Brute force would be to find the inner brackets first and then the outer ones and so on. Better approach will be to use stack. \\nWhenever we encounter an opening bracket, we push the current string to stack. We will use this string when the inner brackets are reversed. \\nClosing bracket means the current string needs to be reversed. So just reverse it and append the older string from stack\\'s top to front of it. Dry the process on the given examples to understand better. Comment for any doubt.\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack <string> st;\\n        string curr=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(curr);\\n                curr=\"\";\\n                continue;\\n            }\\n            if(s[i]==\\')\\')\\n            {\\n                reverse(curr.begin(),curr.end());\\n                curr= st.top()+curr;\\n                st.pop();\\n                continue;\\n            }\\n            curr+=s[i];\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack <string> st;\\n        string curr=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(curr);\\n                curr=\"\";\\n                continue;\\n            }\\n            if(s[i]==\\')\\')\\n            {\\n                reverse(curr.begin(),curr.end());\\n                curr= st.top()+curr;\\n                st.pop();\\n                continue;\\n            }\\n            curr+=s[i];\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515988,
                "title": "simple-python-solution-using-dict-faster-than-91-84",
                "content": "```from collections import defaultdict\\nclass Solution:\\n    def reverseParentheses(self, string: str) -> str:\\n        level = 0\\n        words = defaultdict(str)\\n        for s in string:\\n            if s== \"(\":\\n                level += 1\\n            elif s==\")\":\\n                level -= 1\\n                words[level] += words[level+1][::-1]\\n                del words[level+1]\\n            else:\\n                words[level] += s\\n                \\n        return words[0]\\n    ```",
                "solutionTags": [],
                "code": "```from collections import defaultdict\\nclass Solution:\\n    def reverseParentheses(self, string: str) -> str:\\n        level = 0\\n        words = defaultdict(str)\\n        for s in string:\\n            if s== \"(\":\\n                level += 1\\n            elif s==\")\":\\n                level -= 1\\n                words[level] += words[level+1][::-1]\\n                del words[level+1]\\n            else:\\n                words[level] += s\\n                \\n        return words[0]\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 500492,
                "title": "simple-stack-solution-o-n-space",
                "content": "```\\npublic String reverseParentheses(String s) \\n    {\\n        Stack<Character> stack = new Stack<>();        \\n        for(char c : s.toCharArray()) {\\n            if(c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && stack.peek() != \\'(\\')  sb.append(stack.pop());                \\n                stack.pop();\\n                \\n                for(char c1 : sb.toString().toCharArray()) stack.push(c1);                                \\n                continue;\\n            } \\n            \\n            stack.push(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n        \\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String reverseParentheses(String s) \\n    {\\n        Stack<Character> stack = new Stack<>();        \\n        for(char c : s.toCharArray()) {\\n            if(c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && stack.peek() != \\'(\\')  sb.append(stack.pop());                \\n                stack.pop();\\n                \\n                for(char c1 : sb.toString().toCharArray()) stack.push(c1);                                \\n                continue;\\n            } \\n            \\n            stack.push(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n        \\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402234,
                "title": "java-easy-solution-with-stack",
                "content": "```\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> stack = new Stack();\\n        stack.push(new StringBuilder());\\n        for(char c : s.toCharArray()){\\n            if(c==\\'(\\'){\\n                stack.push(new StringBuilder());\\n            }\\n            else if(c==\\')\\'){\\n                String inside = stack.pop().reverse().toString();\\n                stack.peek().append(inside);\\n            }\\n            else{\\n                stack.peek().append(c);\\n            }\\n        }\\n        return stack.peek().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> stack = new Stack();\\n        stack.push(new StringBuilder());\\n        for(char c : s.toCharArray()){\\n            if(c==\\'(\\'){\\n                stack.push(new StringBuilder());\\n            }\\n            else if(c==\\')\\'){\\n                String inside = stack.pop().reverse().toString();\\n                stack.peek().append(inside);\\n            }\\n            else{\\n                stack.peek().append(c);\\n            }\\n        }\\n        return stack.peek().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386179,
                "title": "easy-and-clean-code-java-o-n-2-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Deque<StringBuilder> stack = new ArrayDeque<>();\\n\\t\\t// put a empty stringbuilder as place holder to avoid empty stack.\\n        stack.push(new StringBuilder());\\n        char[] arr = s.toCharArray();\\n        for (char c : arr) {\\n            if (c == \\'(\\') {\\n                stack.push(new StringBuilder());\\n            } else if (c == \\')\\') {\\n                StringBuilder curr = stack.pop();\\n                stack.peek().append(curr.reverse().toString());   \\n            } else {\\n                stack.peek().append(c);          \\n            }\\n        }\\n        return stack.peek().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Deque<StringBuilder> stack = new ArrayDeque<>();\\n\\t\\t// put a empty stringbuilder as place holder to avoid empty stack.\\n        stack.push(new StringBuilder());\\n        char[] arr = s.toCharArray();\\n        for (char c : arr) {\\n            if (c == \\'(\\') {\\n                stack.push(new StringBuilder());\\n            } else if (c == \\')\\') {\\n                StringBuilder curr = stack.pop();\\n                stack.peek().append(curr.reverse().toString());   \\n            } else {\\n                stack.peek().append(c);          \\n            }\\n        }\\n        return stack.peek().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383244,
                "title": "javascript-easy-to-understand-48ms-using-stack",
                "content": "- Loop the whole string and push into a stack for non-\")\" character.\\n- If we get a \")\" in the loop, we pop all characters until meets \"(\", and push them into stack again in sequence to reverse them.\\n\\n```js\\nconst reverseParentheses = s => {\\n  const stack = [];\\n  for (let char of s) {\\n    if (char !== \")\") {\\n      stack.push(char);\\n      continue;\\n    }\\n    let c = stack.pop();\\n    let queue = [];\\n    while (c !== \"(\") {\\n      queue.push(c);\\n      c = stack.pop();\\n    }\\n    while (queue.length) {\\n      stack.push(queue.shift());\\n    }\\n  }\\n  return stack.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst reverseParentheses = s => {\\n  const stack = [];\\n  for (let char of s) {\\n    if (char !== \")\") {\\n      stack.push(char);\\n      continue;\\n    }\\n    let c = stack.pop();\\n    let queue = [];\\n    while (c !== \"(\") {\\n      queue.push(c);\\n      c = stack.pop();\\n    }\\n    while (queue.length) {\\n      stack.push(queue.shift());\\n    }\\n  }\\n  return stack.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382985,
                "title": "python-solution-without-stack",
                "content": "```\\n\\n\\ndef reverseParentheses(self, s: str) -> str:\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \"(\":\\n\\t\\t\\tstart = i\\n\\t\\tif s[i] == \")\":\\n\\t\\t\\tend = i\\n\\t\\t\\treturn self.reverseParentheses(s[:start] + s[start+1:end][::-1] + s[end+1:])\\n\\treturn s\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\\n\\ndef reverseParentheses(self, s: str) -> str:\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \"(\":\\n\\t\\t\\tstart = i\\n\\t\\tif s[i] == \")\":\\n\\t\\t\\tend = i\\n\\t\\t\\treturn self.reverseParentheses(s[:start] + s[start+1:end][::-1] + s[end+1:])\\n\\treturn s\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 382649,
                "title": "my-stack-javascript-solution-52-ms",
                "content": "This algorithm can be used for bunch of similar problems with some minor modifications:\\n```\\nvar reverseParentheses = function(s) {\\n    var data = [\"\"];\\n    var from;\\n    var to;\\n    var next;\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            data.push(\"\");\\n        } else if (s[i] === \")\") {\\n            data[data.length - 2] += data.pop().split(\"\").reverse().join(\"\");\\n        } else {\\n            from = i;\\n            to = i;\\n            while ((next = to + 1) < s.length && s[next] !== \"(\" && s[next] !== \")\") {\\n                to++;\\n            }\\n            i = to;\\n            data[data.length - 1] += s.substring(from, to + 1);\\n        }\\n    }\\n    \\n    return data[0]; \\n};\\n```\\nOr using arrays (without string concatenation):\\n```\\nvar reverseParentheses = function(s) {\\n    var data = [[]];\\n    var index;\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            data.push([]);\\n        } else if (s[i] === \")\") {\\n            index = data.length - 2;\\n            data.pop().reverse().forEach(o => data[index].push(o));\\n        } else {\\n            data[data.length - 1].push(s[i]);\\n        }\\n    }\\n    \\n    return data[0].join(\"\"); \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseParentheses = function(s) {\\n    var data = [\"\"];\\n    var from;\\n    var to;\\n    var next;\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            data.push(\"\");\\n        } else if (s[i] === \")\") {\\n            data[data.length - 2] += data.pop().split(\"\").reverse().join(\"\");\\n        } else {\\n            from = i;\\n            to = i;\\n            while ((next = to + 1) < s.length && s[next] !== \"(\" && s[next] !== \")\") {\\n                to++;\\n            }\\n            i = to;\\n            data[data.length - 1] += s.substring(from, to + 1);\\n        }\\n    }\\n    \\n    return data[0]; \\n};\\n```\n```\\nvar reverseParentheses = function(s) {\\n    var data = [[]];\\n    var index;\\n    \\n    for (var i = 0; i < s.length; i++) {\\n        if (s[i] === \"(\") {\\n            data.push([]);\\n        } else if (s[i] === \")\") {\\n            index = data.length - 2;\\n            data.pop().reverse().forEach(o => data[index].push(o));\\n        } else {\\n            data[data.length - 1].push(s[i]);\\n        }\\n    }\\n    \\n    return data[0].join(\"\"); \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382346,
                "title": "simplest-python-stack-solution",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = collections.deque([])\\n        temp = \"\"\\n        for i in s:\\n            if i == \"(\":\\n                stack += temp,\\n                temp = \"\"\\n            elif i == \")\":\\n                temp = stack.pop() + temp[::-1]\\n            else:\\n                temp += i\\n        return temp",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = collections.deque([])\\n        temp = \"\"\\n        for i in s:\\n            if i == \"(\":\\n                stack += temp,\\n                temp = \"\"\\n            elif i == \")\":\\n                temp = stack.pop() + temp[::-1]\\n            else:\\n                temp += i\\n        return temp",
                "codeTag": "Java"
            },
            {
                "id": 4060724,
                "title": "easy-to-understand-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char>st;\\n        for(int i =0; i< s.size(); i++){\\n            st.push(s[i]);\\n            if(s[i] == \\')\\'){\\n                st.pop();\\n                string temp = \"\";\\n                while(st.top() != \\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j = 0; j<temp.size(); j++){\\n                    st.push(temp[j]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans ;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char>st;\\n        for(int i =0; i< s.size(); i++){\\n            st.push(s[i]);\\n            if(s[i] == \\')\\'){\\n                st.pop();\\n                string temp = \"\";\\n                while(st.top() != \\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j = 0; j<temp.size(); j++){\\n                    st.push(temp[j]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans ;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981189,
                "title": "simple-solution-using-stack-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            char ch =s[i];\\n            if(ch==\\'(\\' ||  ch!=\\')\\'){\\n                st.push(ch);\\n            }\\n\\n            if(ch==\\')\\' && !st.empty()){\\n                string temp =\"\";\\n                while(st.top()!=\\'(\\'){\\n                     temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n\\n                if(st.empty() && i==s.length()-1){\\n                    return temp;\\n                }else{\\n                    for(int i=0;i<temp.length();i++){\\n                        st.push(temp[i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        string ans =\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            if(st.top()==\\'(\\' || st.top()==\\')\\'){\\n                return \"\";\\n            }\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            char ch =s[i];\\n            if(ch==\\'(\\' ||  ch!=\\')\\'){\\n                st.push(ch);\\n            }\\n\\n            if(ch==\\')\\' && !st.empty()){\\n                string temp =\"\";\\n                while(st.top()!=\\'(\\'){\\n                     temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n\\n                if(st.empty() && i==s.length()-1){\\n                    return temp;\\n                }else{\\n                    for(int i=0;i<temp.length();i++){\\n                        st.push(temp[i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        string ans =\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            if(st.top()==\\'(\\' || st.top()==\\')\\'){\\n                return \"\";\\n            }\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889104,
                "title": "stack-easy-c-o-n-short-and-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very Simple, When you find a **close bracket** then **reverse** the **substring** from the **last open bracket position** to the **current position**.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        string ans = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\') \\n            {\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(auto c : s) if(c!=\\')\\' && c!=\\'(\\') ans+=c;\\n        return ans;\\n\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/c70146ba-e292-438d-b36a-37841c9159d8_1691647409.4300852.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> st;\\n        string ans = \"\";\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(i);\\n            else if(s[i]==\\')\\') \\n            {\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            }\\n        }\\n        for(auto c : s) if(c!=\\')\\' && c!=\\'(\\') ans+=c;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630615,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string ans = \"\";\\n\\n        stack<char> st;\\n\\n        for (char ch : s){\\n            if (ch != \\')\\'){\\n                st.push(ch);\\n            }\\n            else{\\n                string w = \"\";\\n                while (st.top() != \\'(\\'){\\n                    w += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n\\n                for (char i : w)\\n                    st.push(i);\\n            }\\n        } \\n\\n        while (!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string ans = \"\";\\n\\n        stack<char> st;\\n\\n        for (char ch : s){\\n            if (ch != \\')\\'){\\n                st.push(ch);\\n            }\\n            else{\\n                string w = \"\";\\n                while (st.top() != \\'(\\'){\\n                    w += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n\\n                for (char i : w)\\n                    st.push(i);\\n            }\\n        } \\n\\n        while (!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608701,
                "title": "c-o-n-stack",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince it is given that the parantheses are balanced, it is only required to know the where each valid parantheses\\' pair exists. Use a stack to keep track of this, similar to problems where the task is to determine whether the given string is a valid parantheses arrangement or not.\\n\\nMaintain a stack```s```of integers that stores the indices of all```(```characters. Iterate through the input string```t```. Let the iterator be```i```.\\nIf```t[i]==\\'(\\'```push ```i```to the stack. If```t[i]==\\')\\'```reverse the string from the index```s.top()```to the index```i```.\\nFinally, copy all alphabet characters to a new output string and return the so-obtained string.\\n\\n## Complexity\\n- Time complexity\\n    - Given the length of the input string is *n*: *O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - Given the length of the input string is *n*: *O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    string reverseParentheses(string t) {\\n        int n = t.length();\\n        string out = \"\";\\n        stack<int> s;\\n\\n        for(int i=0; i<n; i++){\\n            if(t[i]==\\'(\\') s.push(i);\\n            else if(t[i]==\\')\\'){\\n                reverse(t.begin()+s.top()+1,t.begin()+i);\\n                s.pop();\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++) if(t[i]!=\\'(\\' && t[i]!=\\')\\') out = out + t[i];\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```s```\n```(```\n```t```\n```i```\n```t[i]==\\'(\\'```\n```i```\n```t[i]==\\')\\'```\n```s.top()```\n```i```\n```cpp []\\nclass Solution {\\npublic:\\n    string reverseParentheses(string t) {\\n        int n = t.length();\\n        string out = \"\";\\n        stack<int> s;\\n\\n        for(int i=0; i<n; i++){\\n            if(t[i]==\\'(\\') s.push(i);\\n            else if(t[i]==\\')\\'){\\n                reverse(t.begin()+s.top()+1,t.begin()+i);\\n                s.pop();\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++) if(t[i]!=\\'(\\' && t[i]!=\\')\\') out = out + t[i];\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295291,
                "title": "java-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        return reverseParenthesis(s);\\n    }\\n    public static String reverseParenthesis(String str){\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            //if it\\'s not a closing parenthesis push it to stack\\n            char ch = str.charAt(i);\\n            if(ch != \\')\\'){\\n                stack.push(ch);\\n                continue;\\n            }\\n            //when ever we get a closing bracket\\n            //pop out all the elements until we get opening\\n            String popped = \"\";\\n            while (!stack.isEmpty() && stack.peek() != \\'(\\'){\\n                popped += stack.pop();\\n            }\\n            if(!stack.isEmpty()){\\n                stack.pop();\\n            }\\n            if(popped.length() > 0){\\n                //push the character back to stack\\n                //one by one\\n                for (int j = 0; j < popped.length(); j++) {\\n                    stack.push(popped.charAt(j));\\n                }\\n            }\\n        }\\n        //now pop out all the characters from stack\\n        StringBuilder res = new StringBuilder();\\n        while (!stack.isEmpty()){\\n            res.append(stack.pop());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        return reverseParenthesis(s);\\n    }\\n    public static String reverseParenthesis(String str){\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            //if it\\'s not a closing parenthesis push it to stack\\n            char ch = str.charAt(i);\\n            if(ch != \\')\\'){\\n                stack.push(ch);\\n                continue;\\n            }\\n            //when ever we get a closing bracket\\n            //pop out all the elements until we get opening\\n            String popped = \"\";\\n            while (!stack.isEmpty() && stack.peek() != \\'(\\'){\\n                popped += stack.pop();\\n            }\\n            if(!stack.isEmpty()){\\n                stack.pop();\\n            }\\n            if(popped.length() > 0){\\n                //push the character back to stack\\n                //one by one\\n                for (int j = 0; j < popped.length(); j++) {\\n                    stack.push(popped.charAt(j));\\n                }\\n            }\\n        }\\n        //now pop out all the characters from stack\\n        StringBuilder res = new StringBuilder();\\n        while (!stack.isEmpty()){\\n            res.append(stack.pop());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290732,
                "title": "easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverse(string &s,int i,int j){\\n        while(i<j){\\n            swap(s[i],s[j]) ;\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string s) {\\n        stack<int> st ;\\n        int n = s.length() , i ;\\n        i = 0 ;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\'){\\n                st.push(i) ;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                int ind = st.top() ;\\n                st.pop() ;\\n                reverse(s,ind+1,i-1) ;\\n                cout<<\"s = \"<<s<<\" \" ;\\n                s.erase(s.begin()+ind) ;\\n                s.erase(s.begin()+i-1) ;\\n                i-=2 ;\\n            }\\n            i++ ;\\n        }\\n        return s ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse(string &s,int i,int j){\\n        while(i<j){\\n            swap(s[i],s[j]) ;\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string s) {\\n        stack<int> st ;\\n        int n = s.length() , i ;\\n        i = 0 ;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\'){\\n                st.push(i) ;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                int ind = st.top() ;\\n                st.pop() ;\\n                reverse(s,ind+1,i-1) ;\\n                cout<<\"s = \"<<s<<\" \" ;\\n                s.erase(s.begin()+ind) ;\\n                s.erase(s.begin()+i-1) ;\\n                i-=2 ;\\n            }\\n            i++ ;\\n        }\\n        return s ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3150196,
                "title": "0ms-runtime-beats-100-using-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char>st;\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\')\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                string temp=\"\";\\n                while(!st.empty() && st.top()!=\\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                if(!st.empty() && st.top()==\\'(\\')st.pop();\\n                for(int i=0;i<temp.length();i++){\\n                    st.push(temp[i]);\\n                }\\n                \\n            }\\n        }\\n        while(!st.empty()){\\n            res+=st.top();st.pop();\\n        }\\n        \\n        reverse(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char>st;\\n        string res=\"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\')\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                string temp=\"\";\\n                while(!st.empty() && st.top()!=\\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                if(!st.empty() && st.top()==\\'(\\')st.pop();\\n                for(int i=0;i<temp.length();i++){\\n                    st.push(temp[i]);\\n                }\\n                \\n            }\\n        }\\n        while(!st.empty()){\\n            res+=st.top();st.pop();\\n        }\\n        \\n        reverse(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994965,
                "title": "c-using-stack",
                "content": "# Approach\\nIterate over string once found balanced parenthesis start reversal from opening bracket index till closing bracket index\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public string ReverseParentheses(string s)\\n    {\\n        Stack<int> bracketsStack = new();\\n        char[] result = s.ToCharArray();\\n        \\n        for (int i = 0; i < s.Length; i++){\\n            var c = s[i];\\n            if (c == \\'(\\') bracketsStack.Push(i);\\n            else if (c == \\')\\'){\\n                // Reverse\\n                for(int l= bracketsStack.Pop()+1,r=i-1; l<r;l++,r--){\\n                    var tmp = result[l];\\n                    result[l] = result[r];\\n                    result[r] = tmp;\\n                }\\n            }\\n        }\\n\\n        return new string(result.Where(c=>c!=\\')\\' && c!=\\'(\\').ToArray());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string ReverseParentheses(string s)\\n    {\\n        Stack<int> bracketsStack = new();\\n        char[] result = s.ToCharArray();\\n        \\n        for (int i = 0; i < s.Length; i++){\\n            var c = s[i];\\n            if (c == \\'(\\') bracketsStack.Push(i);\\n            else if (c == \\')\\'){\\n                // Reverse\\n                for(int l= bracketsStack.Pop()+1,r=i-1; l<r;l++,r--){\\n                    var tmp = result[l];\\n                    result[l] = result[r];\\n                    result[r] = tmp;\\n                }\\n            }\\n        }\\n\\n        return new string(result.Where(c=>c!=\\')\\' && c!=\\'(\\').ToArray());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909786,
                "title": "beats-100-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse string reverse function and when you find a balanced paranthesis reverse only that part .\\n\\nhint-->use pair in stack and store with index of opening bracket\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# please upvote if you find it helpful!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( s[i]==\\'(\\')\\n            {\\n                st.push({s[i],i});\\n            }\\n            else if(!st.empty() && s[i]==\\')\\' && st.top().first==\\'(\\')\\n            {\\n                reverse(s.begin()+st.top().second,s.begin()+i);\\n                st.pop();\\n            }\\n\\n        }\\n        string  str;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\' || s[i]==\\')\\')\\n            continue;\\n            else\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if( s[i]==\\'(\\')\\n            {\\n                st.push({s[i],i});\\n            }\\n            else if(!st.empty() && s[i]==\\')\\' && st.top().first==\\'(\\')\\n            {\\n                reverse(s.begin()+st.top().second,s.begin()+i);\\n                st.pop();\\n            }\\n\\n        }\\n        string  str;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\' || s[i]==\\')\\')\\n            continue;\\n            else\\n            str.push_back(s[i]);\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637754,
                "title": "java-stringbuilder-easy-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int index1=-1,index2=-1;\\n        while(s.contains(\"(\")){\\n            for(int i=0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                if(ch==\\'(\\')\\n                    index1=i;\\n                if(ch==\\')\\'){\\n                    index2=i;\\n                    String str1 = s.substring(0,index1);\\n                    String str2 = s.substring(index2+1);\\n                    StringBuilder sb = new StringBuilder(s.substring(index1+1,index2));\\n                    s=str1+sb.reverse().toString()+str2;\\n                    break;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int index1=-1,index2=-1;\\n        while(s.contains(\"(\")){\\n            for(int i=0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                if(ch==\\'(\\')\\n                    index1=i;\\n                if(ch==\\')\\'){\\n                    index2=i;\\n                    String str1 = s.substring(0,index1);\\n                    String str2 = s.substring(index2+1);\\n                    StringBuilder sb = new StringBuilder(s.substring(index1+1,index2));\\n                    s=str1+sb.reverse().toString()+str2;\\n                    break;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448284,
                "title": "golang-simple-stack-based-solution",
                "content": "```go\\nfunc reverseParentheses(s string) string {\\n  var stack [][]byte\\n  var top []byte\\n  stack = append(stack, []byte{}) // Initial segment in case we have any before the first parentheses\\n  for i := 0; i < len(s); i++ {\\n    if s[i] == \\'(\\' { // start the next segment\\n      stack = append(stack, []byte{})\\n    } else if s[i] == \\')\\' { // end of a segment; pop it, reverse it, and append it to the previous segment\\n      top, stack = stack[len(stack)-1], stack[:len(stack)-1]\\n      rev(top)\\n      stack[len(stack)-1] = append(stack[len(stack)-1], top...)\\n    } else { // append to current segment\\n      stack[len(stack)-1] = append(stack[len(stack)-1], s[i])\\n    }\\n  }\\n  return string(stack[0])\\n}\\n\\nfunc rev(seg []byte) {\\n  i, j := 0, len(seg)-1\\n  for i < j {\\n    seg[i], seg[j] = seg[j], seg[i]\\n    i++\\n    j--\\n  }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Stack"
                ],
                "code": "```go\\nfunc reverseParentheses(s string) string {\\n  var stack [][]byte\\n  var top []byte\\n  stack = append(stack, []byte{}) // Initial segment in case we have any before the first parentheses\\n  for i := 0; i < len(s); i++ {\\n    if s[i] == \\'(\\' { // start the next segment\\n      stack = append(stack, []byte{})\\n    } else if s[i] == \\')\\' { // end of a segment; pop it, reverse it, and append it to the previous segment\\n      top, stack = stack[len(stack)-1], stack[:len(stack)-1]\\n      rev(top)\\n      stack[len(stack)-1] = append(stack[len(stack)-1], top...)\\n    } else { // append to current segment\\n      stack[len(stack)-1] = append(stack[len(stack)-1], s[i])\\n    }\\n  }\\n  return string(stack[0])\\n}\\n\\nfunc rev(seg []byte) {\\n  i, j := 0, len(seg)-1\\n  for i < j {\\n    seg[i], seg[j] = seg[j], seg[i]\\n    i++\\n    j--\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379161,
                "title": "c-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    void revString(string& s, int start, int end) {\\n        while(start < end) {\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> startIdx;\\n        string ans = \"\";\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (s[i] == \\'(\\') {\\n                startIdx.push(i);\\n            }\\n            \\n            if (s[i] == \\')\\') {\\n                revString(s, startIdx.top(), i);\\n                startIdx.pop();\\n            }\\n        }\\n        \\n        for (auto ch : s) {\\n            if (ch != \\'(\\' && ch != \\')\\') {\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void revString(string& s, int start, int end) {\\n        while(start < end) {\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> startIdx;\\n        string ans = \"\";\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (s[i] == \\'(\\') {\\n                startIdx.push(i);\\n            }\\n            \\n            if (s[i] == \\')\\') {\\n                revString(s, startIdx.top(), i);\\n                startIdx.pop();\\n            }\\n        }\\n        \\n        for (auto ch : s) {\\n            if (ch != \\'(\\' && ch != \\')\\') {\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333034,
                "title": "c-easy-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n=s.size();\\n        \\n        stack<char>st;\\n        \\n        for(int i=0;i<n;i++){\\n           if(s[i]!=\\')\\')\\n               st.push(s[i]);\\n            else{\\n                string temp=\"\";\\n                \\n                while(!st.empty() && st.top()!=\\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j=0;j<temp.size();j++)\\n                st.push(temp[j]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n=s.size();\\n        \\n        stack<char>st;\\n        \\n        for(int i=0;i<n;i++){\\n           if(s[i]!=\\')\\')\\n               st.push(s[i]);\\n            else{\\n                string temp=\"\";\\n                \\n                while(!st.empty() && st.top()!=\\'(\\'){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int j=0;j<temp.size();j++)\\n                st.push(temp[j]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227686,
                "title": "o-n-stack-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st ;\\n        int i = 0;\\n        string ans = \"\" ; \\n        while(i < s.size()) // Very similar to balanced parentheses problem \\n        {\\n            if (s[i] != \\')\\')\\n                st.push(s[i]) ;\\n            else\\n            {\\n                string temp = \"\" ;\\n                while(st.top() != \\'(\\')\\n                {\\n                    temp.push_back(st.top()) ;\\n                    st.pop() ; \\n                }\\n                st.pop() ; \\n                for(auto c : temp) // string gets reversed, and pushed back into the stack \\n                    st.push(c) ; \\n            }\\n            i ++ ; \\n        }\\n        while(st.empty() == false) \\n        {\\n            ans.push_back(st.top()) ; \\n            st.pop() ;\\n        }\\n        reverse(ans.begin(), ans.end()) ; // popped from stack, so ans needs to be reversed \\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st ;\\n        int i = 0;\\n        string ans = \"\" ; \\n        while(i < s.size()) // Very similar to balanced parentheses problem \\n        {\\n            if (s[i] != \\')\\')\\n                st.push(s[i]) ;\\n            else\\n            {\\n                string temp = \"\" ;\\n                while(st.top() != \\'(\\')\\n                {\\n                    temp.push_back(st.top()) ;\\n                    st.pop() ; \\n                }\\n                st.pop() ; \\n                for(auto c : temp) // string gets reversed, and pushed back into the stack \\n                    st.push(c) ; \\n            }\\n            i ++ ; \\n        }\\n        while(st.empty() == false) \\n        {\\n            ans.push_back(st.top()) ; \\n            st.pop() ;\\n        }\\n        reverse(ans.begin(), ans.end()) ; // popped from stack, so ans needs to be reversed \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147681,
                "title": "how-to-calculate-time-complexity-of-this-solution-in-worst-case",
                "content": "\\n    def reverseParentheses(self, s: str) -> str:\\n        \"\"\"\\n        if it is opening bracket or char we will push it into the stack\\n        if it is closing bracket then we will pop elements\\n        and will push into the queue untill there is opening bracket\\n        \\n        then pop the opening bracket\\n        and push all the elements from the queue to the stack\\n        \"\"\"\\n        from collections import deque\\n        q = deque()\\n        stack = []\\n        \\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    q.append(stack.pop())\\n                stack.pop()\\n                while q:\\n                    front = q.popleft()\\n                    stack.append(front)\\n        return \\'\\'.join(stack)",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "\\n    def reverseParentheses(self, s: str) -> str:\\n        \"\"\"\\n        if it is opening bracket or char we will push it into the stack\\n        if it is closing bracket then we will pop elements\\n        and will push into the queue untill there is opening bracket\\n        \\n        then pop the opening bracket\\n        and push all the elements from the queue to the stack\\n        \"\"\"\\n        from collections import deque\\n        q = deque()\\n        stack = []\\n        \\n        for ch in s:\\n            if ch != \\')\\':\\n                stack.append(ch)\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    q.append(stack.pop())\\n                stack.pop()\\n                while q:\\n                    front = q.popleft()\\n                    stack.append(front)\\n        return \\'\\'.join(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 2118082,
                "title": "c-simple-solution-100-faster-with-comments",
                "content": "Approach: Recursion without stack\\n\\n```\\nstring reverseParentheses(string s) {\\n\\tint l=s.length();\\n\\tif(l<=1)\\n\\t\\treturn s;\\n\\tstring ans,temp;\\n\\tint i=0,par_count=0;   //index and parentheses count to avoid stack\\n\\n\\twhile(i<l){\\n\\t\\tif(s[i]==\\'(\\'){      // substring between this and it\\'s closing bracket will be sent into recursion\\n\\t\\t\\tpar_count=1,i++;\\n\\t\\t\\ttemp.clear();    // temp is the substring\\n\\t\\t\\twhile(i<l&&par_count){    // When par_count is 0 means we found the substring till the closing bracket \\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t\\tpar_count++;\\n\\t\\t\\t\\tif(s[i]==\\')\\')\\n\\t\\t\\t\\t\\tpar_count--;\\n\\t\\t\\t\\ttemp+=s[i++];\\n\\t\\t\\t}\\n\\t\\t\\ttemp.pop_back();          //remove closing bracket at the end\\n\\t\\t\\ttemp= reverseParentheses(temp);      \\n\\t\\t\\treverse(temp.begin(),temp.end());     // reverse the result\\n\\t\\t\\tans+=temp;    \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tans+=s[i++];\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstring reverseParentheses(string s) {\\n\\tint l=s.length();\\n\\tif(l<=1)\\n\\t\\treturn s;\\n\\tstring ans,temp;\\n\\tint i=0,par_count=0;   //index and parentheses count to avoid stack\\n\\n\\twhile(i<l){\\n\\t\\tif(s[i]==\\'(\\'){      // substring between this and it\\'s closing bracket will be sent into recursion\\n\\t\\t\\tpar_count=1,i++;\\n\\t\\t\\ttemp.clear();    // temp is the substring\\n\\t\\t\\twhile(i<l&&par_count){    // When par_count is 0 means we found the substring till the closing bracket \\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t\\tpar_count++;\\n\\t\\t\\t\\tif(s[i]==\\')\\')\\n\\t\\t\\t\\t\\tpar_count--;\\n\\t\\t\\t\\ttemp+=s[i++];\\n\\t\\t\\t}\\n\\t\\t\\ttemp.pop_back();          //remove closing bracket at the end\\n\\t\\t\\ttemp= reverseParentheses(temp);      \\n\\t\\t\\treverse(temp.begin(),temp.end());     // reverse the result\\n\\t\\t\\tans+=temp;    \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tans+=s[i++];\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067890,
                "title": "simple-stack-approach-c",
                "content": "**Approach :** \\nSince the string is balanced , we can use stack to keep a record of encountered ```open and close brackets``` and reverse the substring in between ```each corresponding pair of open - close bracket.```\\nWe keep pushing ```index of open brackets``` in the stack till we face our first ```close``` bracket.\\nAs soon as we find our first ```close``` bracket , this means we can reverse substring between ```this close bracket and its corresponding open bracket``` (the index of this corresponding open bracket is the top of the stack).\\nAlso , alongside this , we keep changing all the brackets ( open and closed both ) to any single common character so that at the end we can simply erase this common character from the whole string.\\n\\n**STL :**\\n--> ```reverse(s.begin()+st.top()+1,s.begin()+i); // to reverse the substring between a pair of open and close bracket```\\n--> ```s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end()); // to erase every \\'*\\' from the string```\\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\'){\\n                reverse(s.begin()+st.top()+1,s.begin()+i);\\n                s[st.top()] = \\'*\\';\\n                s[i] = \\'*\\';\\n                st.pop();\\n            }\\n        }\\n        s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end());\\n        return s;\\n    }\\n};\\n```\\n\\nTHANK YOU!!\\n\\nOther related problems :\\nLC. 1249 https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nLC. 1963 https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/\\nLC. 1541 https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```open and close brackets```\n```each corresponding pair of open - close bracket.```\n```index of open brackets```\n```close```\n```close```\n```this close bracket and its corresponding open bracket```\n```reverse(s.begin()+st.top()+1,s.begin()+i); // to reverse the substring between a pair of open and close bracket```\n```s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end()); // to erase every \\'*\\' from the string```\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\'){\\n                reverse(s.begin()+st.top()+1,s.begin()+i);\\n                s[st.top()] = \\'*\\';\\n                s[i] = \\'*\\';\\n                st.pop();\\n            }\\n        }\\n        s.erase(remove(s.begin(),s.end(),\\'*\\'),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036658,
                "title": "simple-c-code",
                "content": "# Please help me by increasing my reputation. By clicking the up arrow on the left of my image.\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        deque<char> st;\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\')\\')\\n            {\\n                while(st.back() != \\'(\\')\\n                {\\n                    ans += st.back();\\n                    st.pop_back();\\n                }\\n                st.pop_back();\\n                for(char &ch : ans)\\n                {\\n                    st.push_back(ch);\\n                }\\n                ans = \"\";\\n            }\\n            else\\n            {\\n                st.push_back(s[i]);\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans+=st.front();\\n            st.pop_front();\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        deque<char> st;\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\')\\')\\n            {\\n                while(st.back() != \\'(\\')\\n                {\\n                    ans += st.back();\\n                    st.pop_back();\\n                }\\n                st.pop_back();\\n                for(char &ch : ans)\\n                {\\n                    st.push_back(ch);\\n                }\\n                ans = \"\";\\n            }\\n            else\\n            {\\n                st.push_back(s[i]);\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            ans+=st.front();\\n            st.pop_front();\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008916,
                "title": "python-stack-approach",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        stack = []\\n        result = \"\"\\n        for i in range(len(s)):\\n            if s[i] != \")\":\\n                stack.append(s[i])\\n            else:\\n                temp = \"\"\\n                while stack[-1] != \"(\":\\n                    temp = stack.pop() + temp\\n                stack.pop()    \\n                temp = temp[::-1]\\n                    \\n                for i in range(len(temp)):\\n                    stack.append(temp[i])\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        stack = []\\n        result = \"\"\\n        for i in range(len(s)):\\n            if s[i] != \")\":\\n                stack.append(s[i])\\n            else:\\n                temp = \"\"\\n                while stack[-1] != \"(\":\\n                    temp = stack.pop() + temp\\n                stack.pop()    \\n                temp = temp[::-1]\\n                    \\n                for i in range(len(temp)):\\n                    stack.append(temp[i])\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008194,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'*\\');\\n            }\\n            else if(s[i] == \\')\\'){\\n                if(st.top() == \\'*\\') st.pop();\\n                else{\\n                    string str;\\n                    while(st.top() != \\'*\\'){\\n                       str = str + st.top();\\n                       st.pop();\\n                    }\\n                    st.pop();\\n                    for(int k = 0; k<str.size(); k++){\\n                        st.push(str[k]);\\n                    }\\n                }\\n            }\\n            else{\\n               st.push(s[i]);\\n            }\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'*\\');\\n            }\\n            else if(s[i] == \\')\\'){\\n                if(st.top() == \\'*\\') st.pop();\\n                else{\\n                    string str;\\n                    while(st.top() != \\'*\\'){\\n                       str = str + st.top();\\n                       st.pop();\\n                    }\\n                    st.pop();\\n                    for(int k = 0; k<str.size(); k++){\\n                        st.push(str[k]);\\n                    }\\n                }\\n            }\\n            else{\\n               st.push(s[i]);\\n            }\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987312,
                "title": "c-simple-solution-easy-to-understand-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string str;\\n        stack<char> a;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                while(a.top()!=\\'(\\')\\n                {\\n                    str+=a.top();\\n                    a.pop();\\n                }\\n                a.pop();\\n                for(int j=0;j<str.size();j++)\\n                {\\n                    a.push(str[j]);\\n                }\\n                str.clear();\\n            }\\n            else\\n            {\\n                a.push(s[i]);\\n            }\\n        }\\n        while(!a.empty())\\n        {\\n            str+=a.top();\\n            a.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string str;\\n        stack<char> a;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                while(a.top()!=\\'(\\')\\n                {\\n                    str+=a.top();\\n                    a.pop();\\n                }\\n                a.pop();\\n                for(int j=0;j<str.size();j++)\\n                {\\n                    a.push(str[j]);\\n                }\\n                str.clear();\\n            }\\n            else\\n            {\\n                a.push(s[i]);\\n            }\\n        }\\n        while(!a.empty())\\n        {\\n            str+=a.top();\\n            a.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955588,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        z=[]\\n        for i,j in enumerate(s):\\n            if j==\"(\":\\n                z.append(i)\\n            elif j==\")\":\\n                s=s[:z[-1]]+s[z[-1]:i][::-1]+s[i:]\\n                z.pop()\\n        s=s.replace(\"(\",\"\")\\n        s=s.replace(\")\",\"\")\\n        return s",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        z=[]\\n        for i,j in enumerate(s):\\n            if j==\"(\":\\n                z.append(i)\\n            elif j==\")\":\\n                s=s[:z[-1]]+s[z[-1]:i][::-1]+s[i:]\\n                z.pop()\\n        s=s.replace(\"(\",\"\")\\n        s=s.replace(\")\",\"\")\\n        return s",
                "codeTag": "Java"
            },
            {
                "id": 1939925,
                "title": "easy-soln-stacks-3ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> org;\\n        stack<char> cpy;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\')\\')\\n                org.push(s[i]);\\n            else if(s[i]==\\')\\'){\\n                while(org.top()!=\\'(\\'){\\n                    cpy.push(org.top());\\n                    org.pop(); \\n                }\\n                org.pop();\\n                stack<char> reverse;\\n                while(!cpy.empty()){\\n                    reverse.push(cpy.top());\\n                    cpy.pop();\\n                }\\n                while(!reverse.empty()){\\n                    org.push(reverse.top());\\n                    reverse.pop();\\n                }\\n            }\\n        }\\n        string rev=\"\";\\n        while(!org.empty()){\\n            if(org.top()!=\\'(\\')\\n                rev+=org.top();\\n            org.pop();\\n        }\\n        int i=0,j=rev.size()-1;\\n        while(i<j){\\n            swap(rev[i],rev[j]);\\n            i++;j--;\\n        }\\n        return rev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> org;\\n        stack<char> cpy;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\')\\')\\n                org.push(s[i]);\\n            else if(s[i]==\\')\\'){\\n                while(org.top()!=\\'(\\'){\\n                    cpy.push(org.top());\\n                    org.pop(); \\n                }\\n                org.pop();\\n                stack<char> reverse;\\n                while(!cpy.empty()){\\n                    reverse.push(cpy.top());\\n                    cpy.pop();\\n                }\\n                while(!reverse.empty()){\\n                    org.push(reverse.top());\\n                    reverse.pop();\\n                }\\n            }\\n        }\\n        string rev=\"\";\\n        while(!org.empty()){\\n            if(org.top()!=\\'(\\')\\n                rev+=org.top();\\n            org.pop();\\n        }\\n        int i=0,j=rev.size()-1;\\n        while(i<j){\\n            swap(rev[i],rev[j]);\\n            i++;j--;\\n        }\\n        return rev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935433,
                "title": "c-intuitions-explained-stack-clean-code-similar-to-q-decode-string",
                "content": "## ****Intuitions : - \\n## ********Take the stack data structure , stores the \\'(\\' and letters ,  while(s[i]!=\\')\\' ).\\n## Start popping the element from stack and stores in the string str=\"\" variable .\\n## Now we will again push back it into the stack , characters from string str . but this time it will be reversed , each time we taking all the string till it found \\'(\\' in the stack .\\n\\n## Push back again to stack , it will be reversed of their previous versions , as for if we operating it even times it will give same string as newest one , if having odd no. of brackets outside leads to reverse in this way .\\n\\n## finally the answer will be the reversed version of string stored in stack .\\n```\\n string reverseParentheses(string s) {\\n        int n=s.size();\\n        stack<char> stk;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else\\n            {\\n                string str=\"\";\\n                while(!stk.empty() && stk.top()!=\\'(\\')\\n                {\\n                    str+=stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop(); // pop the \\'(\\' element from the stack\\n                for(int i=0;i<str.size();i++)\\n                {\\n                    stk.push(str[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!stk.empty())\\n        {\\n            ans=stk.top() + ans;\\n            stk.pop();\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n string reverseParentheses(string s) {\\n        int n=s.size();\\n        stack<char> stk;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\')\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else\\n            {\\n                string str=\"\";\\n                while(!stk.empty() && stk.top()!=\\'(\\')\\n                {\\n                    str+=stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop(); // pop the \\'(\\' element from the stack\\n                for(int i=0;i<str.size();i++)\\n                {\\n                    stk.push(str[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!stk.empty())\\n        {\\n            ans=stk.top() + ans;\\n            stk.pop();\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910468,
                "title": "java-easy-clean-and-concise-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n    \\tfor(char ch : s.toCharArray()) {\\n    \\t\\tif(ch != \\')\\')\\n    \\t\\t\\tst.push(ch);\\n    \\t\\telse {\\n    \\t\\t\\tQueue<Character> que = new ArrayDeque<>();\\n    \\t\\t\\twhile(st.peek() != \\'(\\')\\n    \\t\\t\\t\\tque.add(st.pop());\\n    \\t\\t\\tst.pop();\\n    \\t\\t\\twhile(que.size() > 0)\\n    \\t\\t\\t\\tst.push(que.remove());\\n    \\t\\t}\\n    \\t}\\n    \\tchar[] ans = new char[st.size()];\\n    \\tfor(int i = ans.length - 1; i >= 0; i--)\\n    \\t\\tans[i] = st.pop();\\n    \\treturn new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> st = new Stack<>();\\n    \\tfor(char ch : s.toCharArray()) {\\n    \\t\\tif(ch != \\')\\')\\n    \\t\\t\\tst.push(ch);\\n    \\t\\telse {\\n    \\t\\t\\tQueue<Character> que = new ArrayDeque<>();\\n    \\t\\t\\twhile(st.peek() != \\'(\\')\\n    \\t\\t\\t\\tque.add(st.pop());\\n    \\t\\t\\tst.pop();\\n    \\t\\t\\twhile(que.size() > 0)\\n    \\t\\t\\t\\tst.push(que.remove());\\n    \\t\\t}\\n    \\t}\\n    \\tchar[] ans = new char[st.size()];\\n    \\tfor(int i = ans.length - 1; i >= 0; i--)\\n    \\t\\tans[i] = st.pop();\\n    \\treturn new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848592,
                "title": "using-string-as-stack-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                "content": "Not really I believe , incase we have inputs like (((((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)))))\\nthis code will probably be o(n^2) then .\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string stk;\\n        for(auto c:s){\\n            if(c==\\')\\'){\\n               string t;\\n               while(stk.back()!=\\'(\\'){\\n                   t+=stk.back();\\n                   stk.pop_back();\\n               }\\n               stk.pop_back();\\n               stk+=t;\\n            }\\n            else{\\n                stk.push_back(c);\\n            }\\n        }\\n        return stk;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        string stk;\\n        for(auto c:s){\\n            if(c==\\')\\'){\\n               string t;\\n               while(stk.back()!=\\'(\\'){\\n                   t+=stk.back();\\n                   stk.pop_back();\\n               }\\n               stk.pop_back();\\n               stk+=t;\\n            }\\n            else{\\n                stk.push_back(c);\\n            }\\n        }\\n        return stk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827439,
                "title": "c-easy-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int>st;\\n        string ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                int top=st.top();\\n                 st.pop();\\n                reverse(s.begin()+top+1,s.begin()+i);\\n               \\n            }\\n        } \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\' )\\n                ans+=s[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int>st;\\n        string ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else if(s[i]==\\')\\')\\n            {\\n                int top=st.top();\\n                 st.pop();\\n                reverse(s.begin()+top+1,s.begin()+i);\\n               \\n            }\\n        } \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\' )\\n                ans+=s[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814759,
                "title": "java-solution-with-recursion",
                "content": "```\\n\\n\\tint index = 0;\\n    public String reverseParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        while(index < s.length()){\\n            char c = s.charAt(index++);\\n            if(c == \\'(\\'){\\n                sb.append(reverseParentheses(s));\\n            }else if(c ==\\')\\'){\\n                return sb.reverse().toString();\\n            }else{\\n                sb.append(c);\\n            }  \\n        }\\n        return sb.toString();\\n    }\\n```\\n\\nSame method used to deal with parenthesis pair \\n224.https://leetcode.com/problems/basic-calculator/\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\n\\tint index = 0;\\n    public String reverseParentheses(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        while(index < s.length()){\\n            char c = s.charAt(index++);\\n            if(c == \\'(\\'){\\n                sb.append(reverseParentheses(s));\\n            }else if(c ==\\')\\'){\\n                return sb.reverse().toString();\\n            }else{\\n                sb.append(c);\\n            }  \\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709099,
                "title": "java-stack-99-easy",
                "content": "We use a stack to keep track of indices we want to swap within. The rest of the code is pretty self explanatory\\n\\n```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n\\n            if (c == \\'(\\') \\n                stack.push(i);\\n            else if (c == \\')\\')\\n                reverseSubstring(arr, stack.pop(), i);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : arr) {\\n            if (c != \\'(\\' && c != \\')\\')\\n                sb.append(c);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public static void reverseSubstring(char[] arr, int start, int end) {\\n        int l = start;\\n        int h = end;\\n\\n        while (l <= h) {\\n            char t = arr[l];\\n            arr[l] = arr[h];\\n            arr[h] = t;\\n            l++;\\n            h--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n\\n            if (c == \\'(\\') \\n                stack.push(i);\\n            else if (c == \\')\\')\\n                reverseSubstring(arr, stack.pop(), i);\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : arr) {\\n            if (c != \\'(\\' && c != \\')\\')\\n                sb.append(c);\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public static void reverseSubstring(char[] arr, int start, int end) {\\n        int l = start;\\n        int h = end;\\n\\n        while (l <= h) {\\n            char t = arr[l];\\n            arr[l] = arr[h];\\n            arr[h] = t;\\n            l++;\\n            h--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626022,
                "title": "python3-with-1-pass-runtime-beats-89-82",
                "content": "\\n```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str: \\n        return reverse(s)[0] \\n\\ndef reverse(s, i=0): \\n    new_word = \\'\\' \\n    while i < len(s): \\n        if s[i] == \\'(\\': \\n            result, i = reverse(s, i+1) \\n            new_word += result \\n        elif s[i] == \\')\\': \\n            new_word = reversed(new_word)\\n            new_word = \\'\\'.join([char for char in new_word])\\n            return new_word, i+1\\n        else: \\n            new_word += s[i] \\n            i += 1 \\n    return new_word, i  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str: \\n        return reverse(s)[0] \\n\\ndef reverse(s, i=0): \\n    new_word = \\'\\' \\n    while i < len(s): \\n        if s[i] == \\'(\\': \\n            result, i = reverse(s, i+1) \\n            new_word += result \\n        elif s[i] == \\')\\': \\n            new_word = reversed(new_word)\\n            new_word = \\'\\'.join([char for char in new_word])\\n            return new_word, i+1\\n        else: \\n            new_word += s[i] \\n            i += 1 \\n    return new_word, i  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623084,
                "title": "simple-code-in-python-using-stack-75-fast",
                "content": "class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        \\n        st=[]\\n       \\n        for i in s:\\n            \\n            if i!=\\')\\':\\n                st.append(i)\\n                print(st)\\n                \\n            else:\\n                a=\\'\\'\\n                while(st!=[] and st[-1]!=\\'(\\'):\\n                      a+=st.pop()\\n                st.pop()\\n                st.append(a[::-1])\\n       \\n    \\n    \\n        for i in range(len(st)):\\n            st[i]=st[i][::-1]\\n            \\n            \\n        return \"\".join(st)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        \\n        st=[]\\n       \\n        for i in s:\\n            \\n            if i!=\\')\\':\\n                st.append(i)\\n                print(st)\\n                \\n            else:\\n                a=\\'\\'\\n                while(st!=[] and st[-1]!=\\'(\\'):\\n                      a+=st.pop()\\n                st.pop()\\n                st.append(a[::-1])\\n       \\n    \\n    \\n        for i in range(len(st)):\\n            st[i]=st[i][::-1]\\n            \\n            \\n        return \"\".join(st)",
                "codeTag": "Java"
            },
            {
                "id": 1539721,
                "title": "faster-than-100-c-submissions",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(\"\");\\n            }\\n            else if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                if(stk.empty())\\n                {\\n                    string tmp=\"\";\\n                    tmp.push_back(s[i]);\\n                    stk.push(tmp);\\n                }\\n                else\\n                {\\n                    stk.top().push_back(s[i]);\\n                }\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                string tmp=stk.top();\\n                stk.pop();\\n                reverse(tmp.begin(),tmp.end());\\n                if(stk.empty())\\n                {\\n                    stk.push(tmp);\\n                }\\n                else\\n                {\\n                    stk.top()+=tmp;\\n                }\\n            }\\n        }\\n        return stk.top();\\n    }\\n};\\n```\\n***Please upvote if you\\'ve got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        stack<string>stk;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(\"\");\\n            }\\n            else if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                if(stk.empty())\\n                {\\n                    string tmp=\"\";\\n                    tmp.push_back(s[i]);\\n                    stk.push(tmp);\\n                }\\n                else\\n                {\\n                    stk.top().push_back(s[i]);\\n                }\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                string tmp=stk.top();\\n                stk.pop();\\n                reverse(tmp.begin(),tmp.end());\\n                if(stk.empty())\\n                {\\n                    stk.push(tmp);\\n                }\\n                else\\n                {\\n                    stk.top()+=tmp;\\n                }\\n            }\\n        }\\n        return stk.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528874,
                "title": "easy-c-solution-faster-than-100",
                "content": "stack< char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n             string str;\\n            if(s[i]==\\')\\')\\n            {\\n                while(st.top()!=\\'(\\')\\n                {\\n                    str.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int i=0;i<str.size();i++)\\n                {\\n                    st.push(str[i]);\\n                }\\n            }\\n            else\\n                st.push(s[i]);\\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            if(st.top()!=\\'(\\' && st.top()!=\\')\\')\\n                ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;",
                "solutionTags": [],
                "code": "stack< char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n             string str;\\n            if(s[i]==\\')\\')\\n            {\\n                while(st.top()!=\\'(\\')\\n                {\\n                    str.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int i=0;i<str.size();i++)\\n                {\\n                    st.push(str[i]);\\n                }\\n            }\\n            else\\n                st.push(s[i]);\\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            if(st.top()!=\\'(\\' && st.top()!=\\')\\')\\n                ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1516551,
                "title": "stack-and-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        queue<char> q;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\')\\'){\\n                st.push(s[i]);\\n            }\\n            if(s[i]==\\')\\'){\\n                while(st.top()!=\\'(\\'){\\n                    q.push(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                while(!q.empty()){\\n                    st.push(q.front());\\n                    q.pop();\\n                }}\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        queue<char> q;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\')\\'){\\n                st.push(s[i]);\\n            }\\n            if(s[i]==\\')\\'){\\n                while(st.top()!=\\'(\\'){\\n                    q.push(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                while(!q.empty()){\\n                    st.push(q.front());\\n                    q.pop();\\n                }}\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507107,
                "title": "simplest-and-straightforward",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.push(i);\\n            }\\n            if (arr[i] == \\')\\') {\\n                reverse(arr, stack.pop(), i);\\n            }\\n            \\n        }\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : arr) {\\n            if (c == \\'(\\' ||  c == \\')\\') {\\n               continue; \\n            }\\n            else {\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n    \\n    private void reverse(char[] arr, int i, int j) {\\n        while (i < j){\\n            char temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.push(i);\\n            }\\n            if (arr[i] == \\')\\') {\\n                reverse(arr, stack.pop(), i);\\n            }\\n            \\n        }\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : arr) {\\n            if (c == \\'(\\' ||  c == \\')\\') {\\n               continue; \\n            }\\n            else {\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n    \\n    private void reverse(char[] arr, int i, int j) {\\n        while (i < j){\\n            char temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448227,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<char> st;\\n        for(auto el : s)\\n        {\\n            if(el == \\')\\')\\n            {\\n                string tmp = \"\";\\n                while(st.top() != \\'(\\')\\n                {\\n                    tmp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                for(auto el2 : tmp)\\n                    st.push(el2);\\n            }\\n            else\\n                st.push(el);\\n                 \\n        }\\n        \\n        string ans = \"\";\\n        while(st.size())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<char> st;\\n        for(auto el : s)\\n        {\\n            if(el == \\')\\')\\n            {\\n                string tmp = \"\";\\n                while(st.top() != \\'(\\')\\n                {\\n                    tmp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                for(auto el2 : tmp)\\n                    st.push(el2);\\n            }\\n            else\\n                st.push(el);\\n                 \\n        }\\n        \\n        string ans = \"\";\\n        while(st.size())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385145,
                "title": "c-100-fast-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n         stack<char> st;\\n        string g=\"\";\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\')\\'){\\n                string k=\"\";\\n                while (!st.empty() && st.top()!=\\'(\\' ){\\n                    k+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                for (auto i : k){\\n                    st.push(i);\\n                }\\n            }\\n            if (s[i]!=\\')\\'){\\n               st.push(s[i]);\\n            }\\n        }\\n        while (!st.empty()){\\n            g+=st.top();\\n            st.pop();\\n        }\\n        reverse(g.begin(),g.end());\\n        return g;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n         stack<char> st;\\n        string g=\"\";\\n        for (int i=0;i<s.length();i++){\\n            if (s[i]==\\')\\'){\\n                string k=\"\";\\n                while (!st.empty() && st.top()!=\\'(\\' ){\\n                    k+=st.top();\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1375927,
                "title": "faster-than-100-space-0-n-c-solution-with-comment",
                "content": "```\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n       \\n        for(int i=0;i<s.size();i++)\\n        {\\n            //If closing means need to reverse the string;\\n        if(s[i]==\\')\\')\\n        {\\n            string tmps;\\n            //pop until ( comes\\n            while(st.top()!=\\'(\\')\\n            {\\n                tmps.push_back(st.top());\\n                st.pop();\\n            }\\n            st.pop();\\n            //now again push the reverse order in stack\\n             for(auto it:tmps)\\n             {\\n                 st.push(it);\\n             }\\n        }\\n        else \\n        {\\n            st.push(s[i]);\\n        }\\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        //reverse the string as we need the order opposite to what stack stores\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n       \\n        for(int i=0;i<s.size();i++)\\n        {\\n            //If closing means need to reverse the string;\\n        if(s[i]==\\')\\')\\n        {\\n            string tmps;\\n            //pop until ( comes\\n            while(st.top()!=\\'(\\')\\n            {\\n                tmps.push_back(st.top());\\n                st.pop();\\n            }\\n            st.pop();\\n            //now again push the reverse order in stack\\n             for(auto it:tmps)\\n             {\\n                 st.push(it);\\n             }\\n        }\\n        else \\n        {\\n            st.push(s[i]);\\n        }\\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        //reverse the string as we need the order opposite to what stack stores\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370868,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> stk;\\n        string res = \"\";\\n        int len = s.length();\\n        for(int i=0;i<len;i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);\\n            else if(s[i] == \\')\\') {\\n                // Reverse substring.\\n                int t = stk.top();\\n                stk.pop();\\n                reverse(s.begin()+t, s.begin()+i);\\n            }\\n        }\\n        for(int i=0;i<len;i++) {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n                res += s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<int> stk;\\n        string res = \"\";\\n        int len = s.length();\\n        for(int i=0;i<len;i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);\\n            else if(s[i] == \\')\\') {\\n                // Reverse substring.\\n                int t = stk.top();\\n                stk.pop();\\n                reverse(s.begin()+t, s.begin()+i);\\n            }\\n        }\\n        for(int i=0;i<len;i++) {\\n            if(s[i] != \\'(\\' && s[i] != \\')\\')\\n                res += s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368481,
                "title": "python-o-n-faster-than-96-less-space-than-84-easy-stack",
                "content": "```class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        id_stack = []\\n        orig_string = s\\n        for i, ele in enumerate(orig_string):\\n            if ele == \\'(\\':\\n                id_stack.append(i)\\n            if ele == \\')\\':\\n                start = id_stack.pop()\\n                end = i\\n                s = s[0:start+1]+s[start+1:end][::-1]+s[end:]\\n\\n        return \"\".join([ele for ele in s if ele not in [\\'(\\',\\')\\']])",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        id_stack = []\\n        orig_string = s\\n        for i, ele in enumerate(orig_string):\\n            if ele == \\'(\\':\\n                id_stack.append(i)\\n            if ele == \\')\\':\\n                start = id_stack.pop()\\n                end = i\\n                s = s[0:start+1]+s[start+1:end][::-1]+s[end:]\\n\\n        return \"\".join([ele for ele in s if ele not in [\\'(\\',\\')\\']])",
                "codeTag": "Java"
            },
            {
                "id": 1306793,
                "title": "should-be-in-easy-section",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        string s1;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(st.empty() or s[i] == \\'(\\' or isalpha(s[i]))\\n                st.push(s[i]);\\n            else{\\n                string temp;\\n                while(st.top() != \\'(\\')\\n                {\\n                    temp.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int i = 0; i < temp.size(); i++)\\n                    st.push(temp[i]);\\n            }\\n                \\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(begin(ans), end(ans));\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<char> st;\\n        string s1;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(st.empty() or s[i] == \\'(\\' or isalpha(s[i]))\\n                st.push(s[i]);\\n            else{\\n                string temp;\\n                while(st.top() != \\'(\\')\\n                {\\n                    temp.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                for(int i = 0; i < temp.size(); i++)\\n                    st.push(temp[i]);\\n            }\\n                \\n        }\\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(begin(ans), end(ans));\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267825,
                "title": "using-stack-and-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        queue<char> qu;\\n        stack<char> st;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                while(st.top()!=\\'(\\')\\n                {\\n                    qu.push(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                while(!qu.empty())\\n                {\\n                    st.push(qu.front());\\n                    qu.pop();\\n                }\\n                \\n\\n            }\\n            else\\n                st.push(s[i]);\\n        }\\n        \\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans = st.top()+ans;\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        queue<char> qu;\\n        stack<char> st;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                while(st.top()!=\\'(\\')\\n                {\\n                    qu.push(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                while(!qu.empty())\\n                {\\n                    st.push(qu.front());\\n                    qu.pop();\\n                }\\n                \\n\\n            }\\n            else\\n                st.push(s[i]);\\n        }\\n        \\n        string ans;\\n        while(!st.empty())\\n        {\\n            ans = st.top()+ans;\\n            st.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261798,
                "title": "c-stack-o-n-time-and-space-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n =s.length();\\n        stack<char> st;\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\')\\') {\\n                string temp =\"\";\\n                while(!st.empty()&&st.top()!=\\'(\\') {\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop(); //remove bracket. \\n                for(int j=0;j<temp.length();j++) {\\n                    st.push(temp[j]);\\n                }\\n            }\\n            else \\n                st.push(s[i]);\\n        }\\n        string ans=\"\";\\n        while(!st.empty()) {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        int n =s.length();\\n        stack<char> st;\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\')\\') {\\n                string temp =\"\";\\n                while(!st.empty()&&st.top()!=\\'(\\') {\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop(); //remove bracket. \\n                for(int j=0;j<temp.length();j++) {\\n                    st.push(temp[j]);\\n                }\\n            }\\n            else \\n                st.push(s[i]);\\n        }\\n        string ans=\"\";\\n        while(!st.empty()) {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230308,
                "title": "python-stack-only",
                "content": "class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        \\n        stack = []\\n        \\n        \\n        for i in s:\\n            #print(stack)\\n            if(i!=\")\"):\\n                stack.append(i)\\n                continue\\n            \\n            s = \"\"\\n            x = stack.pop()\\n            \\n            while(x!=\"(\"):\\n                s+=x[::-1]\\n                x = stack.pop()\\n            \\n            stack.append(s)\\n        \\n        \\n        return \"\".join(stack)",
                "solutionTags": [],
                "code": "class Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        \\n        \\n        stack = []\\n        \\n        \\n        for i in s:\\n            #print(stack)\\n            if(i!=\")\"):\\n                stack.append(i)\\n                continue\\n            \\n            s = \"\"\\n            x = stack.pop()\\n            \\n            while(x!=\"(\"):\\n                s+=x[::-1]\\n                x = stack.pop()\\n            \\n            stack.append(s)\\n        \\n        \\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1223343,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    /*\\n    \"(ed(et(oc))el)\"\\n    stack (ed(etco)el\\n    edocteel\\n    */\\n    public String reverseParentheses(String s) {\\n        if(s == null || s.length() == 0)\\n        {\\n            return s;\\n        }\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(char c : s.toCharArray())\\n        {\\n            if(c != \\')\\')\\n            {\\n                stack.push(c);\\n            }\\n            else\\n            {\\n                Queue<Character> queue = new LinkedList<>();\\n                while(!stack.isEmpty() && stack.peek() != \\'(\\')\\n                {\\n                    queue.add(stack.pop());\\n                }\\n                \\n                stack.pop();\\n                \\n                while(!queue.isEmpty())\\n                {\\n                    stack.push(queue.poll());\\n                }\\n            }\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        while(!stack.isEmpty())\\n        {\\n            result.append(stack.pop());\\n        }\\n        \\n        return result.reverse().toString();\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    /*\\n    \"(ed(et(oc))el)\"\\n    stack (ed(etco)el\\n    edocteel\\n    */\\n    public String reverseParentheses(String s) {\\n        if(s == null || s.length() == 0)\\n        {\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1219626,
                "title": "c-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<char>st;\\n        \\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                \\n                string a=\"\";\\n                while(st.top()!=\\'(\\')\\n                {\\n                    a+=st.top();\\n                    st.pop();\\n                }\\n                \\n                st.pop();\\n                \\n                for(int i=0;i<a.length();i++)\\n                {\\n                    st.push(a[i]);\\n                }\\n                \\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        \\n        while(st.size())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack<char>st;\\n        \\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                \\n                string a=\"\";\\n                while(st.top()!=\\'(\\')\\n                {\\n                    a+=st.top();\\n                    st.pop();\\n                }\\n                \\n                st.pop();\\n                \\n                for(int i=0;i<a.length();i++)\\n                {\\n                    st.push(a[i]);\\n                }\\n                \\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        \\n        while(st.size())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212741,
                "title": "easy-and-simplest-o-n-stack-solution",
                "content": "```\\nstring reverseParentheses(string s) {\\n        stack<char> st;\\n        \\n        string temp=\"\";\\n        string ans=\"\";\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                temp=\"\";\\n               while(st.top()!=\\'(\\')\\n               {\\n                    temp+=st.top();\\n                    st.pop();\\n               }\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    for(int j=0;j<temp.length();j++)\\n                        st.push(temp[j]);\\n                }\\n                else\\n                {\\n                    ans+=temp;\\n                }\\n                                   \\n            }\\n            else\\n            {\\n                if(!st.empty())\\n                    st.push(s[i]); \\n                else{\\n                    ans+=s[i];\\n                }\\n            }\\n        }\\n      \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring reverseParentheses(string s) {\\n        stack<char> st;\\n        \\n        string temp=\"\";\\n        string ans=\"\";\\n        for(int i=0;s[i]!=\\'\\\\0\\';i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n                \\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                temp=\"\";\\n               while(st.top()!=\\'(\\')\\n               {\\n                    temp+=st.top();\\n                    st.pop();\\n               }\\n                st.pop();\\n                if(!st.empty())\\n                {\\n                    for(int j=0;j<temp.length();j++)\\n                        st.push(temp[j]);\\n                }\\n                else\\n                {\\n                    ans+=temp;\\n                }\\n                                   \\n            }\\n            else\\n            {\\n                if(!st.empty())\\n                    st.push(s[i]); \\n                else{\\n                    ans+=s[i];\\n                }\\n            }\\n        }\\n      \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207655,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> st=new Stack<StringBuilder>();\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               st.push(sb);\\n               sb=new StringBuilder();\\n            }\\n            else if(s.charAt(i)==\\')\\')\\n            {\\n                String rev=sb.reverse().toString();\\n                sb=st.pop();\\n                sb.append(rev);\\n            }\\n            else\\n            {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<StringBuilder> st=new Stack<StringBuilder>();\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               st.push(sb);\\n               sb=new StringBuilder();\\n            }\\n            else if(s.charAt(i)==\\')\\')\\n            {\\n                String rev=sb.reverse().toString();\\n                sb=st.pop();\\n                sb.append(rev);\\n            }\\n            else\\n            {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201061,
                "title": "java-easy-solution-stack",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\' || s.charAt(i)!=\\')\\'){\\n            stack.push(s.charAt(i));\\n          }\\n          else{\\n            Queue<Character> q=new LinkedList<>();\\n            while(stack.size()>0 && stack.peek()!=\\'(\\'){\\n              q.add(stack.pop());\\n            }\\n            if(stack.size()>0) stack.pop();\\n            while(q.size()>0){\\n              stack.push(q.remove());\\n            }\\n          }\\n            \\n          }\\n         StringBuffer sb=new StringBuffer();\\n         while(stack.size()>0){\\n           sb.append(stack.pop());\\n         }\\n         sb.reverse();\\n      return sb.toString();\\n        \\n          \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\' || s.charAt(i)!=\\')\\'){\\n            stack.push(s.charAt(i));\\n          }\\n          else{\\n            Queue<Character> q=new LinkedList<>();\\n            while(stack.size()>0 && stack.peek()!=\\'(\\'){\\n              q.add(stack.pop());\\n            }\\n            if(stack.size()>0) stack.pop();\\n            while(q.size()>0){\\n              stack.push(q.remove());\\n            }\\n          }\\n            \\n          }\\n         StringBuffer sb=new StringBuffer();\\n         while(stack.size()>0){\\n           sb.append(stack.pop());\\n         }\\n         sb.reverse();\\n      return sb.toString();\\n        \\n          \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199755,
                "title": "faster-than-100-c-solution-think-creative",
                "content": "```c++\\nclass Solution {\\npublic:\\n    void reverse(int i,int j,string &s){\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string str) {\\n        stack<int>s;\\n        for(int i = 0;i<str.size();i++){\\n            if(str[i]==\\'(\\'){\\n                s.push(i);\\n            }\\n            else if(str[i]==\\')\\'){\\n                int t = s.top();\\n                s.pop();\\n                reverse(t,i,str);\\n            }\\n        }\\n        string res = \"\";\\n        for(int i = 0;i<str.size();i++){\\n            if(str[i]==\\'(\\'||str[i]==\\')\\') continue;\\n            res+=str[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void reverse(int i,int j,string &s){\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    string reverseParentheses(string str) {\\n        stack<int>s;\\n        for(int i = 0;i<str.size();i++){\\n            if(str[i]==\\'(\\'){\\n                s.push(i);\\n            }\\n            else if(str[i]==\\')\\'){\\n                int t = s.top();\\n                s.pop();\\n                reverse(t,i,str);\\n            }\\n        }\\n        string res = \"\";\\n        for(int i = 0;i<str.size();i++){\\n            if(str[i]==\\'(\\'||str[i]==\\')\\') continue;\\n            res+=str[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174433,
                "title": "simple-c-solution-using-stack-0ms-100-faster",
                "content": "```class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack < int > v;\\n        \\n        for (int i=0;i < s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push(i);\\n            }\\n            \\n            if(s[i]==\\')\\')\\n            {\\n                int x = v.top();\\n                v.pop();\\n                reverse(s.begin()+x,s.begin()+i);\\n            }\\n        }\\n        \\n        string ans;\\n        for (int i=0;i < s.length();i++)\\n        {\\n            if(s[i]!=\\'(\\' && s[i]!=\\')\\')\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        \\n        stack < int > v;\\n        \\n        for (int i=0;i < s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1156827,
                "title": "c-solution-with-stack",
                "content": "```\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Reverse Substrings Between Each Pair of Parentheses.\\n// Memory Usage: 6.2 MB, less than 64.88% of C++ online submissions for Reverse Substrings Between Each Pair of Parentheses.\\nstring reverseParentheses(string s) {\\n\\tstack<int> stPos;\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == \\'(\\')\\n\\t\\t\\tstPos.push(i);\\n\\t\\telse if (s[i] == \\')\\') {\\n\\t\\t\\treverse(s.begin() + stPos.top() + 1, s.begin() + i);\\n\\t\\t\\tstPos.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tstring result = \"\";\\n\\tfor (char c : s)\\n\\t\\tif (c != \\'(\\' && c != \\')\\')\\n\\t\\t\\tresult += c;\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Reverse Substrings Between Each Pair of Parentheses.\\n// Memory Usage: 6.2 MB, less than 64.88% of C++ online submissions for Reverse Substrings Between Each Pair of Parentheses.\\nstring reverseParentheses(string s) {\\n\\tstack<int> stPos;\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == \\'(\\')\\n\\t\\t\\tstPos.push(i);\\n\\t\\telse if (s[i] == \\')\\') {\\n\\t\\t\\treverse(s.begin() + stPos.top() + 1, s.begin() + i);\\n\\t\\t\\tstPos.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tstring result = \"\";\\n\\tfor (char c : s)\\n\\t\\tif (c != \\'(\\' && c != \\')\\')\\n\\t\\t\\tresult += c;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156290,
                "title": "easy-to-understand-solution-in-java-beats-97-42-solutions",
                "content": "```\\nclass Solution {\\n    public  String reverseParentheses(String s) {\\n        if(s.length() == 0){\\n            return \"\";\\n        }\\n        \\n        Stack<StringBuilder> stack = new Stack<>();\\n        stack.push(new StringBuilder(\"\"));\\n        \\n        for(int i = 0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'(\\'){\\n                stack.push(new StringBuilder(\"\"));\\n            }else {\\n                if(c == \\')\\'){\\n                    StringBuilder ss = stack.pop();\\n                    ss.reverse();\\n                    StringBuilder temp = stack.pop();\\n                    temp.append(ss);\\n                    stack.push(temp);\\n                }else{\\n                    stack.peek().append(c);\\n                }\\n            }\\n        }\\n        \\n      return stack.pop().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public  String reverseParentheses(String s) {\\n        if(s.length() == 0){\\n            return \"\";\\n        }\\n        \\n        Stack<StringBuilder> stack = new Stack<>();\\n        stack.push(new StringBuilder(\"\"));\\n        \\n        for(int i = 0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'(\\'){\\n                stack.push(new StringBuilder(\"\"));\\n            }else {\\n                if(c == \\')\\'){\\n                    StringBuilder ss = stack.pop();\\n                    ss.reverse();\\n                    StringBuilder temp = stack.pop();\\n                    temp.append(ss);\\n                    stack.push(temp);\\n                }else{\\n                    stack.peek().append(c);\\n                }\\n            }\\n        }\\n        \\n      return stack.pop().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144452,
                "title": "python-runtime-16-ms-memory-usage-14-3-mb-chupa-chinesada",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n\\n        while \\'(\\' in s:\\n            fim = s.find(\\')\\')+1\\n            inicio = s[:fim].rfind(\\'(\\')\\n            \\n            s = s.replace(s[inicio: fim], s[inicio+1: fim-1][::-1])\\n        \\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n\\n        while \\'(\\' in s:\\n            fim = s.find(\\')\\')+1\\n            inicio = s[:fim].rfind(\\'(\\')\\n            \\n            s = s.replace(s[inicio: fim], s[inicio+1: fim-1][::-1])\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142326,
                "title": "simple-javascript-solution-using-stack",
                "content": "```\\nvar reverseParentheses = function(s) {\\n    \\n    // 1. using stack \\n    // create arrays of stack\\n    // for every \\'(\\' initisalise new stack\\n    // return/ pop() the reverse of stack on encountering \\')\\'\\n    \\n    // Time complexity O(N)\\n    // Space complexity O(N) for stacks\\n    \\n    \\n    let stack = [];\\n    // initialise with []\\n    stack.push([]);\\n    \\n    for (let char of s) {\\n        if (char === \\'(\\') {\\n            stack.push([])\\n        } else if (char === \\')\\') {\\n            const reverse = stack.pop().reverse();\\n            stack[stack.length - 1].push(...reverse);\\n        } else {\\n            stack[stack.length - 1].push(char);\\n        }\\n    }\\n    \\n    return stack.pop().join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseParentheses = function(s) {\\n    \\n    // 1. using stack \\n    // create arrays of stack\\n    // for every \\'(\\' initisalise new stack\\n    // return/ pop() the reverse of stack on encountering \\')\\'\\n    \\n    // Time complexity O(N)\\n    // Space complexity O(N) for stacks\\n    \\n    \\n    let stack = [];\\n    // initialise with []\\n    stack.push([]);\\n    \\n    for (let char of s) {\\n        if (char === \\'(\\') {\\n            stack.push([])\\n        } else if (char === \\')\\') {\\n            const reverse = stack.pop().reverse();\\n            stack[stack.length - 1].push(...reverse);\\n        } else {\\n            stack[stack.length - 1].push(char);\\n        }\\n    }\\n    \\n    return stack.pop().join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138216,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        int n=s.size();\\n        vector<int>backet,pair(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                backet.push_back(i);\\n            }\\n           if(s[i]==\\')\\')\\n           {\\n               int val=backet.back();\\n               backet.pop_back();\\n               pair[i]=val;\\n               pair[val]=i;\\n           }\\n        }\\n        string ans=\"\";\\n        for(int i=0,d=1;i<n;i+=d)\\n        {\\n            if(s[i]==\\')\\'||s[i]==\\'(\\')\\n            {\\n                d=-d;\\n                i=pair[i];\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        int n=s.size();\\n        vector<int>backet,pair(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                backet.push_back(i);\\n            }\\n           if(s[i]==\\')\\')\\n           {\\n               int val=backet.back();\\n               backet.pop_back();\\n               pair[i]=val;\\n               pair[val]=i;\\n           }\\n        }\\n        string ans=\"\";\\n        for(int i=0,d=1;i<n;i+=d)\\n        {\\n            if(s[i]==\\')\\'||s[i]==\\'(\\')\\n            {\\n                d=-d;\\n                i=pair[i];\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118085,
                "title": "python-solution-28ms-faster-than-88-using-single-stack-with-clear-explanation",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        i, n, stack = 0, len(s), []\\n        \\n        while i < n:\\n            if  s[i] == \\'(\\':  # if its opening parentheses, just append\\n                stack.append(s[i])\\n            elif s[i] == \\')\\': # if its closing parentheses\\n                st = \\'\\'\\n                while stack!=[] and stack[-1]!=\\'(\\': #while stack is not empty and stack\\'s top is NOT an opening parentheses\\n                    st += stack.pop() #pop the element and append to a temporary string\\n                stack.pop() #pop the last remaining ( in some cases\\n                stack += list(st) #append the popped elements to stack\\n            else:\\n                stack.append(s[i]) #pushing all letters into stack\\n            i += 1\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        i, n, stack = 0, len(s), []\\n        \\n        while i < n:\\n            if  s[i] == \\'(\\':  # if its opening parentheses, just append\\n                stack.append(s[i])\\n            elif s[i] == \\')\\': # if its closing parentheses\\n                st = \\'\\'\\n                while stack!=[] and stack[-1]!=\\'(\\': #while stack is not empty and stack\\'s top is NOT an opening parentheses\\n                    st += stack.pop() #pop the element and append to a temporary string\\n                stack.pop() #pop the last remaining ( in some cases\\n                stack += list(st) #append the popped elements to stack\\n            else:\\n                stack.append(s[i]) #pushing all letters into stack\\n            i += 1\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079296,
                "title": "python-faster-than-98-submission-using-stack-and-array",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stk,arr=[],[]\\n        for i in s:\\n            if i!=\\')\\':\\n                stk.append(i)\\n            else:\\n                popele=stk.pop()\\n                while popele!=\\'(\\':\\n                    arr.append(popele)\\n                    popele=stk.pop()\\n\\n                for j in arr:\\n                    stk.append(j)\\n                arr=[]\\n        ans=\\'\\'\\n        for k in stk:\\n            ans+=k\\n        return ans\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stk,arr=[],[]\\n        for i in s:\\n            if i!=\\')\\':\\n                stk.append(i)\\n            else:\\n                popele=stk.pop()\\n                while popele!=\\'(\\':\\n                    arr.append(popele)\\n                    popele=stk.pop()\\n\\n                for j in arr:\\n                    stk.append(j)\\n                arr=[]\\n        ans=\\'\\'\\n        for k in stk:\\n            ans+=k\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1039699,
                "title": "python-easy-to-understand-stack-solution",
                "content": "Simple stack solution.\\n\\n    def reverseParentheses(self, s):\\n\\t\\n        stack=[]\\n        cur_str=\"\"\\n        \\n        for char in s:\\n            if char==\\'(\\':\\n                stack.append(cur_str)\\n                cur_str=\"\"\\n                \\n            elif char==\\')\\':\\n                cur_str=cur_str[::-1]\\n                cur_str=stack.pop()+cur_str\\n                \\n            else:\\n                cur_str+=char\\n        \\n        return cur_str\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simple stack solution.\\n\\n    def reverseParentheses(self, s):\\n\\t\\n        stack=[]\\n        cur_str=\"\"\\n        \\n        for char in s:\\n            if char==\\'(\\':\\n                stack.append(cur_str)\\n                cur_str=\"\"\\n                \\n            elif char==\\')\\':\\n                cur_str=cur_str[::-1]\\n                cur_str=stack.pop()+cur_str\\n                \\n            else:\\n                cur_str+=char\\n        \\n        return cur_str\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1026850,
                "title": "javascript-o-n-time-and-space-stack-of-parentheses",
                "content": "Using stack:\\n```\\nvar reverseParentheses = function (s) {\\n\\n  const levelsStack = [[]];\\n  let lastLevelIndex = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\'(\\') {\\n      levelsStack.push([]);\\n      lastLevelIndex++;\\n    } else if (s[i] === \\')\\') {\\n      const lastLevel = levelsStack.pop();\\n      lastLevelIndex--;\\n      for (let j = lastLevel.length - 1; j >= 0; j--) {\\n        levelsStack[lastLevelIndex].push(lastLevel[j]);\\n      }\\n    } else {\\n      levelsStack[lastLevelIndex].push(s[i]);\\n    }\\n  }\\n  return levelsStack[lastLevelIndex].join(\\'\\');\\n}\\n```\\n\\nOr using recursion:\\n```\\nvar reverseParentheses = function (s) {\\n\\n  function reversePart(startIndex, firstLevel) {\\n    let part = [];\\n\\n    for (let i = startIndex; i < s.length; i++) {\\n      if (s[i] === \\'(\\') {\\n        const { partToReverse, finishedOn } = reversePart(i + 1, false);\\n        for (let j = partToReverse.length - 1; j >= 0; j--) {\\n          part.push(partToReverse[j]);\\n        }\\n        i = finishedOn;\\n      } else if (s[i] === \\')\\' && !firstLevel) {\\n        return { part: part.join(\\'\\'), finishedOn: i };\\n      } else {\\n        part.push(s[i]);\\n      }\\n    }\\n    return part.join(\\'\\');\\n  }\\n  \\n  return reversePart(0, true);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nvar reverseParentheses = function (s) {\\n\\n  const levelsStack = [[]];\\n  let lastLevelIndex = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\'(\\') {\\n      levelsStack.push([]);\\n      lastLevelIndex++;\\n    } else if (s[i] === \\')\\') {\\n      const lastLevel = levelsStack.pop();\\n      lastLevelIndex--;\\n      for (let j = lastLevel.length - 1; j >= 0; j--) {\\n        levelsStack[lastLevelIndex].push(lastLevel[j]);\\n      }\\n    } else {\\n      levelsStack[lastLevelIndex].push(s[i]);\\n    }\\n  }\\n  return levelsStack[lastLevelIndex].join(\\'\\');\\n}\\n```\n```\\nvar reverseParentheses = function (s) {\\n\\n  function reversePart(startIndex, firstLevel) {\\n    let part = [];\\n\\n    for (let i = startIndex; i < s.length; i++) {\\n      if (s[i] === \\'(\\') {\\n        const { partToReverse, finishedOn } = reversePart(i + 1, false);\\n        for (let j = partToReverse.length - 1; j >= 0; j--) {\\n          part.push(partToReverse[j]);\\n        }\\n        i = finishedOn;\\n      } else if (s[i] === \\')\\' && !firstLevel) {\\n        return { part: part.join(\\'\\'), finishedOn: i };\\n      } else {\\n        part.push(s[i]);\\n      }\\n    }\\n    return part.join(\\'\\');\\n  }\\n  \\n  return reversePart(0, true);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997582,
                "title": "simple-python-stack-solution",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = list()\\n        stack.append(\"\")\\n        for c in s:\\n            if c == \"(\":\\n                stack.append(\"\")\\n            elif c == \")\":\\n                tmp = stack.pop()[::-1]\\n                stack[-1] += tmp\\n            else:\\n                stack[-1] += c\\n        \\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = list()\\n        stack.append(\"\")\\n        for c in s:\\n            if c == \"(\":\\n                stack.append(\"\")\\n            elif c == \")\":\\n                tmp = stack.pop()[::-1]\\n                stack[-1] += tmp\\n            else:\\n                stack[-1] += c\\n        \\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986883,
                "title": "java-solution-using-stacks-deque-with-comments",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Character> stack = new Stack<Character>();\\n        StringBuilder str = new StringBuilder(); \\n        Deque<Character> d = new ArrayDeque();\\n        \\n        for(int i=0; i<s.length();i++){\\n            if(s.charAt(i) == \\')\\'){\\n                //reverse the string ( a b c d\\n                \\n                while(!stack.isEmpty() && stack.peek() != \\'(\\'){\\n                       d.add(stack.pop()); //d c b a                    \\n                }\\n                \\n\\t\\t\\t\\t//remove the open bracket\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n                // pollFirst() method of deque remvoes the first element of deque\\n                while(!d.isEmpty()){\\n                    stack.push(d.pollFirst()); // d c b a\\n                }\\n                \\n            } else{\\n                stack.push(s.charAt(i)); // (,a,b,c,d,l\\n            }\\n        }\\n        \\n        // d c b a\\n        while(!stack.isEmpty()){\\n            str.append(stack.pop()); // a b c d\\n        }\\n        \\n        \\n        return str.reverse().toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Character> stack = new Stack<Character>();\\n        StringBuilder str = new StringBuilder(); \\n        Deque<Character> d = new ArrayDeque();\\n        \\n        for(int i=0; i<s.length();i++){\\n            if(s.charAt(i) == \\')\\'){\\n                //reverse the string ( a b c d\\n                \\n                while(!stack.isEmpty() && stack.peek() != \\'(\\'){\\n                       d.add(stack.pop()); //d c b a                    \\n                }\\n                \\n\\t\\t\\t\\t//remove the open bracket\\n                if(!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n                \\n                // pollFirst() method of deque remvoes the first element of deque\\n                while(!d.isEmpty()){\\n                    stack.push(d.pollFirst()); // d c b a\\n                }\\n                \\n            } else{\\n                stack.push(s.charAt(i)); // (,a,b,c,d,l\\n            }\\n        }\\n        \\n        // d c b a\\n        while(!stack.isEmpty()){\\n            str.append(stack.pop()); // a b c d\\n        }\\n        \\n        \\n        return str.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980540,
                "title": "python-simple-and-easy",
                "content": "```\\ndef reverseParentheses(s):\\n\\ts = list(s)\\n\\tstack = []\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \\'(\\':\\n\\t\\t\\tstack.append(i)\\n\\t\\telif s[i] == \\')\\':\\n\\t\\t\\tj = stack.pop()\\n\\t\\t\\ts[j+1:i]= s[j+1:i][::-1]\\n\\treturn \\'\\'.join([t for t in s if t != \\'(\\' and t != \\')\\'])\\n```",
                "solutionTags": [],
                "code": "```\\ndef reverseParentheses(s):\\n\\ts = list(s)\\n\\tstack = []\\n\\tfor i in range(len(s)):\\n\\t\\tif s[i] == \\'(\\':\\n\\t\\t\\tstack.append(i)\\n\\t\\telif s[i] == \\')\\':\\n\\t\\t\\tj = stack.pop()\\n\\t\\t\\ts[j+1:i]= s[j+1:i][::-1]\\n\\treturn \\'\\'.join([t for t in s if t != \\'(\\' and t != \\')\\'])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 972075,
                "title": "only-save-the-position-of-by-stack-c-code-faster-than-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string reverseParentheses(string str) {\\n        stack<int> s;\\n        string ret;\\n        for (char ch : str) {\\n            if (ch != \\'(\\' && ch != \\')\\') {\\n                ret += ch;\\n            } else if (ch == \\'(\\') {\\n                s.push(ret.size());\\n            } else if (ch == \\')\\') {\\n                int pos = s.top();\\n                s.pop();\\n                reverse(ret.begin() + pos, ret.end());\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string reverseParentheses(string str) {\\n        stack<int> s;\\n        string ret;\\n        for (char ch : str) {\\n            if (ch != \\'(\\' && ch != \\')\\') {\\n                ret += ch;\\n            } else if (ch == \\'(\\') {\\n                s.push(ret.size());\\n            } else if (ch == \\')\\') {\\n                int pos = s.top();\\n                s.pop();\\n                reverse(ret.begin() + pos, ret.end());\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971970,
                "title": "simple-java-stack-soln",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char present = s.charAt(i);\\n            if(present == \\')\\')\\n            {\\n                String temp = \"\";\\n                while(stack.peek()!=\\'(\\')\\n                {\\n                    temp = temp+stack.pop();\\n                }\\n                stack.pop(); //removing the )\\n                \\n                int j=0;\\n                while(j<temp.length())\\n                {\\n                    stack.push(temp.charAt(j));\\n                    j++;\\n                }\\n            }\\n            else\\n                stack.push(present);\\n        }\\n        \\n        String res = \"\";\\n        while(!stack.isEmpty())\\n            res = stack.pop() + res;\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char present = s.charAt(i);\\n            if(present == \\')\\')\\n            {\\n                String temp = \"\";\\n                while(stack.peek()!=\\'(\\')\\n                {\\n                    temp = temp+stack.pop();\\n                }\\n                stack.pop(); //removing the )\\n                \\n                int j=0;\\n                while(j<temp.length())\\n                {\\n                    stack.push(temp.charAt(j));\\n                    j++;\\n                }\\n            }\\n            else\\n                stack.push(present);\\n        }\\n        \\n        String res = \"\";\\n        while(!stack.isEmpty())\\n            res = stack.pop() + res;\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951392,
                "title": "reverse-the-string-using-two-pointers",
                "content": "not much different than https://leetcode.com/problems/reverse-string/discuss/951401/two-pointers\\n```\\ntime = O(n^2),  space = O(n)\\nclass Solution {\\n    \\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack();    \\n        char[] a = s.toCharArray();\\n        for(int i =0;i<s.length();i++) {\\n            char c = a[i];\\n            if(c == \\'(\\') {\\n                st.push(i);\\n            } else if(c==\\')\\') {\\n                int index = st.pop();\\n                reverse(a,index,i);\\n            }\\n        }\\n        \\n        //reversing is done.\\n        //now keep only alphabets.\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0;i<s.length();i++) {\\n            char c = a[i];\\n            if(c != \\'(\\'&&c!=\\')\\') {\\n                sb.append(c);\\n            } \\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void reverse (char[] a, int i, int j) {\\n      //two-pointers\\n        while(i<j) {\\n           while(i<a.length && (a[i]==\\'(\\'||a[i]==\\')\\')) {\\n               i++;\\n           }\\n            while(j>=0 && (a[j]==\\'(\\'||a[j]==\\')\\')) {\\n               j--;\\n           }\\n            if(i>j) break;\\n            \\n            //swap\\n            char temp = a[i];\\n            a[i]  = a[j];\\n            a[j]  = temp;\\n            \\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\ntime = O(n^2),  space = O(n)\\nclass Solution {\\n    \\n    public String reverseParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack();    \\n        char[] a = s.toCharArray();\\n        for(int i =0;i<s.length();i++) {\\n            char c = a[i];\\n            if(c == \\'(\\') {\\n                st.push(i);\\n            } else if(c==\\')\\') {\\n                int index = st.pop();\\n                reverse(a,index,i);\\n            }\\n        }\\n        \\n        //reversing is done.\\n        //now keep only alphabets.\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0;i<s.length();i++) {\\n            char c = a[i];\\n            if(c != \\'(\\'&&c!=\\')\\') {\\n                sb.append(c);\\n            } \\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void reverse (char[] a, int i, int j) {\\n      //two-pointers\\n        while(i<j) {\\n           while(i<a.length && (a[i]==\\'(\\'||a[i]==\\')\\')) {\\n               i++;\\n           }\\n            while(j>=0 && (a[j]==\\'(\\'||a[j]==\\')\\')) {\\n               j--;\\n           }\\n            if(i>j) break;\\n            \\n            //swap\\n            char temp = a[i];\\n            a[i]  = a[j];\\n            a[j]  = temp;\\n            \\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948644,
                "title": "javascript-recursive-and-stack-solution",
                "content": "```\\nvar reverseParentheses = function(S) {\\n  const open = \\'(\\' , close = \\')\\'\\n  const stack = [], openStack = []\\n  \\n  for(let i=0;i<S.length;i++){\\n    const s = S[i]\\n    if(s === open){\\n      openStack.push(i)\\n      continue\\n    }\\n    if(s === close){\\n      let openIdx = openStack.pop()\\n      let arr = S.slice(openIdx+1, i).split(\\'\\')\\n      const newS = S.slice(0,openIdx) + arr.reverse().join(\\'\\') + S.slice(i+1)\\n      return reverseParentheses(newS)\\n    }\\n  }\\n  return S\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar reverseParentheses = function(S) {\\n  const open = \\'(\\' , close = \\')\\'\\n  const stack = [], openStack = []\\n  \\n  for(let i=0;i<S.length;i++){\\n    const s = S[i]\\n    if(s === open){\\n      openStack.push(i)\\n      continue\\n    }\\n    if(s === close){\\n      let openIdx = openStack.pop()\\n      let arr = S.slice(openIdx+1, i).split(\\'\\')\\n      const newS = S.slice(0,openIdx) + arr.reverse().join(\\'\\') + S.slice(i+1)\\n      return reverseParentheses(newS)\\n    }\\n  }\\n  return S\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941410,
                "title": "c-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        const int n = s.size();\\n        \\n        stack<int> open;\\n        for(int i = 0 ; i < n ; ++i)\\n        {\\n            if(s[i] == \\'(\\') open.push(i);\\n            if(s[i] == \\')\\') \\n            {\\n                int index = open.top();\\n                open.pop();\\n                \\n                reverse(s.begin() + index, s.begin() + i);\\n            }\\n        }\\n        string t;\\n        for(char c: s)\\n        {\\n            if(c == \\'(\\' || c == \\')\\') continue;\\n            t += c;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) \\n    {\\n        const int n = s.size();\\n        \\n        stack<int> open;\\n        for(int i = 0 ; i < n ; ++i)\\n        {\\n            if(s[i] == \\'(\\') open.push(i);\\n            if(s[i] == \\')\\') \\n            {\\n                int index = open.top();\\n                open.pop();\\n                \\n                reverse(s.begin() + index, s.begin() + i);\\n            }\\n        }\\n        string t;\\n        for(char c: s)\\n        {\\n            if(c == \\'(\\' || c == \\')\\') continue;\\n            t += c;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906506,
                "title": "simple-solution-by-using-stack-c-o-n-beat-100",
                "content": "SIMPLE SOLUTION BY USING STACK : C++ O(N) beat 100%\\n```\\n//please upvote if u like this approach.\\n//good understanding of stack data structure is pre-request.\\n//step - 1 : when ever u encounter \\'(\\' store index of that char in stack and reverse the string between \\')\\' char index and top of the stack.\\n//step - 2 : return all char except \\'(\\' and \\')\\' after traversing whole string.\\nstring reverseParentheses(string s) {\\n        stack<int> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            } \\n        }\\n        string ans=\"\";\\n        for(auto i : s)\\n        {\\n            if(i!=\\'(\\'&&i!=\\')\\')\\n                ans+=i;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//please upvote if u like this approach.\\n//good understanding of stack data structure is pre-request.\\n//step - 1 : when ever u encounter \\'(\\' store index of that char in stack and reverse the string between \\')\\' char index and top of the stack.\\n//step - 2 : return all char except \\'(\\' and \\')\\' after traversing whole string.\\nstring reverseParentheses(string s) {\\n        stack<int> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                reverse(s.begin()+st.top(),s.begin()+i);\\n                st.pop();\\n            } \\n        }\\n        string ans=\"\";\\n        for(auto i : s)\\n        {\\n            if(i!=\\'(\\'&&i!=\\')\\')\\n                ans+=i;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 894676,
                "title": "c-with-one-stack",
                "content": "```\\npublic class Solution {\\n    string reverseInParentheses(string inputString) {\\n        if (inputString == null || inputString.Length <= 1) return inputString;\\n        \\n        var stack = new Stack<string>();\\n        string str = \"\";\\n        foreach (var c in inputString) {\\n            if (c <= \\'z\\' && c >= \\'a\\') {\\n                str += c;\\n            } else if (c == \\'(\\') {\\n                stack.Push(str);\\n                str = \"\";\\n            } else {\\n                var p = stack.Pop();\\n                var arr = str.ToCharArray();\\n                Array.Reverse(arr);\\n                var newstr = new string(arr); // reverse current\\n                str = p + newstr;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    string reverseInParentheses(string inputString) {\\n        if (inputString == null || inputString.Length <= 1) return inputString;\\n        \\n        var stack = new Stack<string>();\\n        string str = \"\";\\n        foreach (var c in inputString) {\\n            if (c <= \\'z\\' && c >= \\'a\\') {\\n                str += c;\\n            } else if (c == \\'(\\') {\\n                stack.Push(str);\\n                str = \"\";\\n            } else {\\n                var p = stack.Pop();\\n                var arr = str.ToCharArray();\\n                Array.Reverse(arr);\\n                var newstr = new string(arr); // reverse current\\n                str = p + newstr;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887111,
                "title": "java-solution-4-lines-logic",
                "content": "class Solution {\\n    public String reverseParentheses(String inputString) {\\n        StringBuilder str = new StringBuilder(inputString);\\n    int start, end;\\n    while(str.indexOf(\"(\") != -1){\\n        start = str.lastIndexOf(\"(\");\\n        end = str.indexOf(\")\", start);\\n        str.replace(start, end + 1, new StringBuilder(str.substring(start+1, end)).reverse().toString());\\n    }\\n    return str.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String reverseParentheses(String inputString) {\\n        StringBuilder str = new StringBuilder(inputString);\\n    int start, end;\\n    while(str.indexOf(\"(\") != -1){\\n        start = str.lastIndexOf(\"(\");\\n        end = str.indexOf(\")\", start);\\n        str.replace(start, end + 1, new StringBuilder(str.substring(start+1, end)).reverse().toString());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 881014,
                "title": "super-easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        temp = []\\n        rev  = []\\n        \\n        for c in s:\\n            if c != \")\":\\n                rev.append(c)\\n            else: # c == \")\"\\n                temp_char = \"\"\\n                while(rev and temp_char!=\"(\"):\\n                    temp_char = rev.pop()\\n                    if temp_char!=\"(\":\\n                        temp.append(temp_char)\\n            rev+=temp\\n            temp = []\\n            \\n        return \"\".join(rev)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reverseParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        temp = []\\n        rev  = []\\n        \\n        for c in s:\\n            if c != \")\":\\n                rev.append(c)\\n            else: # c == \")\"\\n                temp_char = \"\"\\n                while(rev and temp_char!=\"(\"):\\n                    temp_char = rev.pop()\\n                    if temp_char!=\"(\":\\n                        temp.append(temp_char)\\n            rev+=temp\\n            temp = []\\n            \\n        return \"\".join(rev)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866723,
                "title": "simple-recursion",
                "content": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int n = s.length();\\n        int begin =-1, end =-1;\\n        for(int i =0;i<n;i++) { \\n            char c = s.charAt(i);\\n            if(c==\\'(\\')\\n                begin=i;\\n            if(c==\\')\\') {\\n                end=i;\\n                return reverseParentheses(s.substring(0,begin) + reverse(s.substring(begin+1,end)) + s.substring(end+1,n ));\\n            }\\n            \\n        }\\n        return s;\\n    }\\n    \\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseParentheses(String s) {\\n        int n = s.length();\\n        int begin =-1, end =-1;\\n        for(int i =0;i<n;i++) { \\n            char c = s.charAt(i);\\n            if(c==\\'(\\')\\n                begin=i;\\n            if(c==\\')\\') {\\n                end=i;\\n                return reverseParentheses(s.substring(0,begin) + reverse(s.substring(begin+1,end)) + s.substring(end+1,n ));\\n            }\\n            \\n        }\\n        return s;\\n    }\\n    \\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844737,
                "title": "swift-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\n    func reverseParentheses(_ s: String) -> String {\\n        var stack = [Character]()\\n        \\n        for char in s {\\n            if char == \")\" {\\n                var str = \"\"\\n                while stack.last != \"(\" {\\n                    str.append(stack.removeLast())\\n                }\\n                // Remove \"(\" as well\\n                stack.removeLast()\\n                stack += str\\n            }\\n            else {\\n                stack.append(char)\\n            }\\n        }\\n        \\n        return String(stack)\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func reverseParentheses(_ s: String) -> String {\\n        var stack = [Character]()\\n        \\n        for char in s {\\n            if char == \")\" {\\n                var str = \"\"\\n                while stack.last != \"(\" {\\n                    str.append(stack.removeLast())\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 782010,
                "title": "0ms-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string reverseParentheses(string s) \\n    {\\n     stack<pair<char,int>> bracket;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                bracket.push(make_pair(s[i],i));\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n            reverse(s.begin()+bracket.top().second + 1,s.begin()+i);\\n                bracket.pop();\\n            }\\n        }\\n        string answer=\"\";\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]!=\\'(\\' && s[i]!=\\')\\')\\n                    answer.push_back(s[i]);\\n            }\\n        return answer;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string reverseParentheses(string s) \\n    {\\n     stack<pair<char,int>> bracket;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                bracket.push(make_pair(s[i],i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 775472,
                "title": "swift-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\n    func reverseParentheses(_ s: String) -> String {\\n        var stack = [Character]()\\n        \\n        for str in s {\\n            if str == \")\" {\\n\\t\\t\\t// as soon as we get a closing bracket, we start popping elements and saving into a new stack until we get an opening bracket\\n\\t\\t\\t// since we\\'re following a stack, removing from a stack and adding into a new, it already reversed the elements for us\\n                var revStr = [Character]()\\n                while stack.last != \"(\" {\\n                    revStr.append(stack.removeLast())\\n                }\\n\\t\\t\\t\\t// we\\'re removing the last because it\\'s an opening bracket and we don\\'t need it anymore\\n                stack.removeLast()\\n\\t\\t\\t\\t// simply adding the reversedString into our main stack\\n                stack += revStr\\n            } else {\\n\\t\\t\\t// appending everything else\\n                stack.append(str)\\n            }\\n        }\\n\\t\\t\\n        return String(stack)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseParentheses(_ s: String) -> String {\\n        var stack = [Character]()\\n        \\n        for str in s {\\n            if str == \")\" {\\n\\t\\t\\t// as soon as we get a closing bracket, we start popping elements and saving into a new stack until we get an opening bracket\\n\\t\\t\\t// since we\\'re following a stack, removing from a stack and adding into a new, it already reversed the elements for us\\n                var revStr = [Character]()\\n                while stack.last != \"(\" {\\n                    revStr.append(stack.removeLast())\\n                }\\n\\t\\t\\t\\t// we\\'re removing the last because it\\'s an opening bracket and we don\\'t need it anymore\\n                stack.removeLast()\\n\\t\\t\\t\\t// simply adding the reversedString into our main stack\\n                stack += revStr\\n            } else {\\n\\t\\t\\t// appending everything else\\n                stack.append(str)\\n            }\\n        }\\n\\t\\t\\n        return String(stack)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746527,
                "title": "beat-99-python-easy-time-o-n",
                "content": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = [\\'\\']\\n        \\n        for e in s:\\n            if e == \\'(\\':\\n                stack.append(\\'\\')\\n            elif e == \\')\\':\\n                tmp = stack.pop()\\n                stack[-1] += tmp[::-1]\\n            else:\\n                stack[-1] += e\\n        \\n        return stack[-1]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseParentheses(self, s: str) -> str:\\n        stack = [\\'\\']\\n        \\n        for e in s:\\n            if e == \\'(\\':\\n                stack.append(\\'\\')\\n            elif e == \\')\\':\\n                tmp = stack.pop()\\n                stack[-1] += tmp[::-1]\\n            else:\\n                stack[-1] += e\\n        \\n        return stack[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706428,
                "title": "java-solution",
                "content": "```\\npublic String reverseParentheses(String s) {\\n\\tif (!s.contains(\"(\")) {\\n\\t\\treturn s;\\n\\t}\\n\\n\\t// find the innermost bracket\\n\\tint end = s.indexOf(\\')\\');\\n\\tint start = s.substring(0, end).lastIndexOf(\\'(\\');\\n\\tif (end == s.length()) { // a(123)\\n\\t\\treturn reverseParentheses(s.substring(0, start) + reverseString(s.substring(start + 1, end)));\\n\\t} else { // // a(123)b\\n\\t\\treturn reverseParentheses(s.substring(0, start) + reverseString(s.substring(start + 1, end)) + s.substring(end + 1));\\n\\t}\\n}\\n\\n// reverse string\\npublic String reverseString(String s) {\\n\\tStringBuilder sb = new StringBuilder(s);\\n\\treturn sb.reverse().toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String reverseParentheses(String s) {\\n\\tif (!s.contains(\"(\")) {\\n\\t\\treturn s;\\n\\t}\\n\\n\\t// find the innermost bracket\\n\\tint end = s.indexOf(\\')\\');\\n\\tint start = s.substring(0, end).lastIndexOf(\\'(\\');\\n\\tif (end == s.length()) { // a(123)\\n\\t\\treturn reverseParentheses(s.substring(0, start) + reverseString(s.substring(start + 1, end)));\\n\\t} else { // // a(123)b\\n\\t\\treturn reverseParentheses(s.substring(0, start) + reverseString(s.substring(start + 1, end)) + s.substring(end + 1));\\n\\t}\\n}\\n\\n// reverse string\\npublic String reverseString(String s) {\\n\\tStringBuilder sb = new StringBuilder(s);\\n\\treturn sb.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 695027,
                "title": "c-simple-intuitive-using-stacks",
                "content": "This soluting beats 100% in time\\n```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>> stk;\\n        vector<pair<int,int>> pos;\\n        //find the index pairs of closing brackets using stacks\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\') stk.push(make_pair(s[i],i));\\n            else if(s[i] == \\')\\'){\\n                pos.push_back(make_pair(stk.top().second,i));\\n                stk.pop();\\n            }\\n        }\\n        for(int i=0;i<pos.size();i++){\\n            cout<<pos[i].first<<\" \"<<pos[i].second<<\" \\\\n\";\\n        }\\n        //sort the pos vector acc to the length of the interval\\n        sort(pos.begin(),pos.end(),[](pair<int,int> p1,pair<int,int> p2){\\n            return abs(p1.first - p1.second) < abs(p2.first - p2.second); \\n        });\\n        for(int i=0;i<pos.size();i++){\\n            cout<<pos[i].first<<\" \"<<pos[i].second<<\" \\\\n\";\\n        }\\n        //reverse the string(in place) for each interval\\n        for(int i=0;i<pos.size();i++){\\n            //string temp = s.substr(pos[i].first, pos[i].second - pos[i].first + 1);\\n            auto start = s.begin() + pos[i].first;\\n            auto end = start + pos[i].second - pos[i].first;\\n            reverse(start, end);\\n            cout<<s<<\"\\\\n\";\\n        }\\n        //form the final result string\\n        string res = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] != \\'(\\' && s[i] != \\')\\') res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseParentheses(string s) {\\n        stack<pair<char,int>> stk;\\n        vector<pair<int,int>> pos;\\n        //find the index pairs of closing brackets using stacks\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\') stk.push(make_pair(s[i],i));\\n            else if(s[i] == \\')\\'){\\n                pos.push_back(make_pair(stk.top().second,i));\\n                stk.pop();\\n            }\\n        }\\n        for(int i=0;i<pos.size();i++){\\n            cout<<pos[i].first<<\" \"<<pos[i].second<<\" \\\\n\";\\n        }\\n        //sort the pos vector acc to the length of the interval\\n        sort(pos.begin(),pos.end(),[](pair<int,int> p1,pair<int,int> p2){\\n            return abs(p1.first - p1.second) < abs(p2.first - p2.second); \\n        });\\n        for(int i=0;i<pos.size();i++){\\n            cout<<pos[i].first<<\" \"<<pos[i].second<<\" \\\\n\";\\n        }\\n        //reverse the string(in place) for each interval\\n        for(int i=0;i<pos.size();i++){\\n            //string temp = s.substr(pos[i].first, pos[i].second - pos[i].first + 1);\\n            auto start = s.begin() + pos[i].first;\\n            auto end = start + pos[i].second - pos[i].first;\\n            reverse(start, end);\\n            cout<<s<<\"\\\\n\";\\n        }\\n        //form the final result string\\n        string res = \"\";\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] != \\'(\\' && s[i] != \\')\\') res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1751760,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1793963,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1568212,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1776456,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1573007,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1959093,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1828830,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            },
            {
                "id": 1828809,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "Is this just me or is this really tricky? Or do I need to practice more stack?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Stack is pretty tricky. I practiced a bunch of stack questions and it still stumps me "
                    },
                    {
                        "username": "dPQKLtBzhi",
                        "content": "I don\\'t understand why \\'love\\' is not reversed in the answer:\\n\\nInput: s = \"(u(love)i)\"\\nOutput: \"iloveu\"\\n\\nShouldn\\'t it be:\\n\\nOutput: \"ievolu\" \\n\\n?\\n "
                    },
                    {
                        "username": "MinMint01",
                        "content": "It\\'s because \"love\" is reversed twice~\\nFor easy understanding, first lets split the string w.r.t inner and outer \"( )\"s :\\n\\n(u   (love)   i)\\n\\nAccording to the question, we should start reversing from the innermost \"( )\" so \"love\" becomes \"evol\"\\nNow the string is : \\n\\n(u   evol   i)\\n\\ni.e it becomes \"(uevoli)\"~\\n\\nThen, apply the final reversal to the string as a whole! therefore we get the final answer as : s=\"iloveu\""
                    },
                    {
                        "username": "dragonfire",
                        "content": "![image](https://assets.leetcode.com/users/psmadhankumar/image_1568693792.png)\\n\\nThis derived from the logic given in https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382421/JavaPython-3-Iterative-short-codes-w-comment-and-analysis."
                    },
                    {
                        "username": "Kratos50",
                        "content": "beautiful problem to mind fuck you "
                    },
                    {
                        "username": "dragonpolice",
                        "content": "I learned stack solution from here, https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/discuss/382367/Simple-Stack-and-Queue-Solution and tried a Queue, a simple ArrayList solution from commend.\\nBelow is my process for the example \"(ed(et(oc))el)\" but eventually I got \"lecotede\", anyone can help me correct it? Thank you in advance!\\n![image](https://assets.leetcode.com/users/dragonpolice/image_1568574589.png)\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This problem is similar to Problem No 394. Decode Strings.\\n"
                    },
                    {
                        "username": "parmarakshat111",
                        "content": "how it is similiar can you explain\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1.Create a Stack to store characters that are not within parentheses.\\n\\n2.Iterate through each character in the input string s.\\n\\n3.If the current character is a closing parentheses, pop all the characters from the Stack until the matching opening parentheses is found. Append the popped characters to a new StringBuilder in reverse order.\\n\\n4.If the current character is not a parentheses, push it onto the Stack.\\n\\n5.After iterating through all the characters in s, pop all the remaining characters from the Stack and append them to the end of the result StringBuilder.\\n\\n6.Return the result StringBuilder in reverse order."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\n\\nhttps://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/3282686/easy-to-understand-for-beginners-with-approach/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Deletions to Make Character Frequencies Unique",
        "question_content": "<p>A string <code>s</code> is called <strong>good</strong> if there are no two different characters in <code>s</code> that have the same <strong>frequency</strong>.</p>\n\n<p>Given a string <code>s</code>, return<em> the <strong>minimum</strong> number of characters you need to delete to make </em><code>s</code><em> <strong>good</strong>.</em></p>\n\n<p>The <strong>frequency</strong> of a character in a string is the number of times it appears in the string. For example, in the string <code>&quot;aab&quot;</code>, the <strong>frequency</strong> of <code>&#39;a&#39;</code> is <code>2</code>, while the <strong>frequency</strong> of <code>&#39;b&#39;</code> is <code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> <code>s</code> is already good.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aaabbbcc&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You can delete two &#39;b&#39;s resulting in the good string &quot;aaabcc&quot;.\nAnother way it to delete one &#39;b&#39; and one &#39;c&#39; resulting in the good string &quot;aaabbc&quot;.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ceabaacb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You can delete both &#39;c&#39;s resulting in the good string &quot;eabaab&quot;.\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 927549,
                "title": "c-java-python-3-greedy",
                "content": "Greedy works since we can only delete characters (we cannot add or replace characters).\\n\\nSo, count each character first. For each 26 characters, check if it\\'s count is already `used`. If so, delete characters until you find unused count, or reach zero.\\n\\n**C++**\\n```cpp\\nint minDeletions(string s) {\\n    int cnt[26] = {}, res = 0;\\n    unordered_set<int> used;\\n    for (char ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    for (int i = 0; i < 26; ++i)\\n        for (; cnt[i] > 0 && !used.insert(cnt[i]).second; --cnt[i])\\n            ++res;\\n    return res;\\n}\\n```\\n**C++ without hash set**\\nWe can sort `cnt`, go from largest to smallest count, and figure out how many characters we need to remove. \\n\\n```cpp\\nint minDeletions(string s) {\\n    int cnt[26] = {}, res = 0;\\n    for (char ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    sort(begin(cnt), end(cnt));\\n    for (int i = 24; i >= 0 && cnt[i] > 0; --i) {\\n        res += max(0, cnt[i] - max(0, cnt[i + 1] - 1));\\n        cnt[i] = min(cnt[i], max(0, cnt[i + 1] - 1));\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int minDeletions(String s) {\\n    int cnt[] = new int[26], res = 0;\\n    Set<Integer> used = new HashSet<>();\\n    for (int i = 0; i < s.length(); ++i)\\n        ++cnt[s.charAt(i) - \\'a\\'];\\n    for (int i = 0; i < 26; ++i) {\\n        while (cnt[i] > 0 && !used.add(cnt[i])) {\\n            --cnt[i];\\n            ++res;\\n        }\\n    }        \\n    return res;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt, res, used = collections.Counter(s), 0, set()\\n        for ch, freq in cnt.items():\\n            while freq > 0 and freq in used:\\n                freq -= 1\\n                res += 1\\n            used.add(freq)\\n        return res\\n```\\n**Complexity Analysis**\\n- Time: O(n); note that the second loop will not have more than 26 * 26 total operations.\\n- Memory: O(1) as we will not store more than 26 different frequencies.",
                "solutionTags": [],
                "code": "```cpp\\nint minDeletions(string s) {\\n    int cnt[26] = {}, res = 0;\\n    unordered_set<int> used;\\n    for (char ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    for (int i = 0; i < 26; ++i)\\n        for (; cnt[i] > 0 && !used.insert(cnt[i]).second; --cnt[i])\\n            ++res;\\n    return res;\\n}\\n```\n```cpp\\nint minDeletions(string s) {\\n    int cnt[26] = {}, res = 0;\\n    for (char ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    sort(begin(cnt), end(cnt));\\n    for (int i = 24; i >= 0 && cnt[i] > 0; --i) {\\n        res += max(0, cnt[i] - max(0, cnt[i + 1] - 1));\\n        cnt[i] = min(cnt[i], max(0, cnt[i + 1] - 1));\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int minDeletions(String s) {\\n    int cnt[] = new int[26], res = 0;\\n    Set<Integer> used = new HashSet<>();\\n    for (int i = 0; i < s.length(); ++i)\\n        ++cnt[s.charAt(i) - \\'a\\'];\\n    for (int i = 0; i < 26; ++i) {\\n        while (cnt[i] > 0 && !used.add(cnt[i])) {\\n            --cnt[i];\\n            ++res;\\n        }\\n    }        \\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt, res, used = collections.Counter(s), 0, set()\\n        for ch, freq in cnt.items():\\n            while freq > 0 and freq in used:\\n                freq -= 1\\n                res += 1\\n            used.add(freq)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207106,
                "title": "c-easy-solution-full-explanation-least-space",
                "content": "Time Complexity : O(N), Space Complexity : O(1) \\n\\n## *Clean Code at the end of the post*\\n\\n***Upvote if Found Helpful :***\\n\\n**Intuition an Implementation :**\\n\\nIt can be easyly stated that at first we have to count the frequencies of each character in the string. After that we have to change the equal frequencies so that all become unique. But doing this in the most optimesd way and using least space is the process which will be discussed here.\\n\\n* So as stated first step is to find the frequencies of the characters the string. Which can be done using least space using a vector/ array of size 26. (As there are 26 characters in alpabet which can be in the string). Time Taken = O(N). Space used = O(26) which is constant i.e. O(1).\\n\\n* Now we can\\'t increase the frequency of any character in the string as only deletion is allowed. So we have to check the frequencies from greatest to smallest. So sort the array. Time Taken = O(26 log 26) which is constant. So total time till now = O(N).\\n\\t\\n\\tNote : We have to only deal with the frequencies not the characters. So position of the frequencies in the vector doesnt matter as we will never need which character\\'s frequency are dealt with. \\n\\n* Now traverse the array from right to left as rightmost element is the greatest. We dont need to change the greatest element. So start traversing fron 24th position. (As 25th is the last element). Time taken = O(25) which is again constant so total time is O(N).\\n\\n* Now we will continue till frequencies become 0 for any element in the array as other elements left of it will also be 0. So break at the position where frequency is 0.\\n\\n* If the current frequency (`freq[i]`) is equal or greater than the previous one (`freq[i+1`) then we have to make the current frequency less than previous one but it should be also greater than or equal to 0. (Frequency can not be less than 0). `So freq[i] = max(0, freq[i+1] -1)`.\\n\\t\\n\\t**In case of doubt** : So here a question may arise that why so much headache as it is sorted freq[i] cannot be more than freq[i+1] just do ans++ ans reduce the frequncy by 1 i.e. freq[i]--. Yes in many cases it will work but think in case of more than 2 frequencies are equal then if we decrease a frequency then in next iteration the frequency will be more than the previous one ans if we only reduce 1 then the answer will not correct. So we make the frequency simply 1 less than previous and check the difference. \\n\\tExample : If frequencies be [2,2,2,2] then if we just decrease the freq by 1 en each step then next step becomes `[2,2,1,2], del = 1 -> [2,1,1,2], del = 2 -> [1,1,1,2], del = 3` which is not the desired result. Insted when difference is taken the result becomes `[2,2,2,2] -> [2,2,1,2], del = 1 -> [2,0,1,2], del = 3 -> [0,0,1,2], del = 5` which is the desired ans.\\n\\n* But we also need the previous value of the frequency so that we can calculate the number of frequency decreased i.e. characters deleted. So we store the previous freq as `prev` before the step mentioned before. \\n\\n* So we add the reduced freq to the ans as `del +=  prev - freq[i]` (del is the answer). \\n\\n* Return `del` at the end which will contain the total number of frequency decreased i.e. total characters deleted.\\n\\n**Example :**\\n\\n```\\nLet the string be  : abbccdddeeffffggg \\nSo count of a=1, b=2, c=2, d=3, e=2, f=4, g=3. So freq = {1,2,2,3,2,4,3,0,......,0}\\nSo after sorting the elements of the freq array are = {0,......, 0, 1,2,2,2,3,3,4}\\n\\nSo at each step in the loop : [ Element of consideration is included in \\' \\', ans next element included in ( )]\\n\\n[0, .... ,0,1,2,2,2,3,\\'3\\',(4)] -> \\'3\\' != 0, \\'3\\' < (4), So continue.\\n[0, .... ,0,1,2,2,2,\\'3\\',(3),4] -> \\'3\\' != 0, \\'3\\' == (3), So prev = \\'3\\', freq[i] = max(0, (3)-1) = 2, del += 3-2 i.e. del = 1\\n[0, .... ,0,1,2,2,\\'2\\',(2),3,4] -> \\'2\\' != 0, \\'2\\' == (2), So prev = \\'2\\', freq[i] = max(0, (2)-1) = 1, del += 2-1 i.e. del = 2\\n[0, .... ,0,1,2,\\'2\\',(1),2,3,4] -> \\'2\\' != 0, \\'2\\' > (1), So prev = \\'2\\', freq[i] = max(0, (1)-1) = 0, del += 2-0 i.e. del = 4\\n[0, .... ,0,1,\\'2\\',(0),1,2,3,4] -> \\'2\\' != 0, \\'2\\' > (0), So prev = \\'2\\', freq[i] = max(0, (0)-1) = 0, del += 2-0 i.e. del = 6\\n[0, .... ,0,\\'1\\',(0),0,1,2,3,4] -> \\'1\\' != 0, \\'1\\' > (0), So prev = \\'1\\', freq[i] = max(0, (0)-1) = 0, del += 1-0 i.e. del = 7\\n[0, .... ,\\'0\\',(0),0,0,1,2,3,4] -> \\'0\\' == 0, break;\\n\\nSee all frequencies become distinct so return del i.e. 7\\n```\\n\\n**Code with Full Explanation :**\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        //Array to store the count of each character.\\n        vector<int> freq (26, 0);\\n        \\n        //Calculatimg frequency of all characters.\\n        for (char c : s){\\n            freq[c - \\'a\\']++;\\n        }\\n        \\n        //sorting the frequencies. So the greatest frequencies are in right side.\\n        sort(freq.begin(), freq.end());\\n        \\n        int del = 0; //to store the deletions.\\n        \\n        //Checking if 2 frequencies are same, if same then decrease the frequency so that it becomes less than the next greater one.So Start from the 2nd greatest frequency that is at freq[24].\\n        for (int i = 24; i >= 0; i--) {\\n            \\n            if(freq[i] == 0) break; // if frequency is 0 that means no more character is left.\\n            \\n            if(freq[i] >= freq[i+1]){\\n                int prev = freq[i]; //To store the frequency before deletion.\\n                freq[i] = max(0, freq[i+1] -1); //New frequency should be 1 less than the previous frequency in the array.\\n                del += prev - freq[i]; //Calculating deleted characters \\n            }\\n        }\\n        return del;\\n    }\\n};\\n```\\n\\n**Clean Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq (26, 0);        \\n        for (char c : s) freq[c - \\'a\\']++;\\n        sort(freq.begin(), freq.end());\\n        int del = 0;\\n        for (int i = 24; i >= 0; i--) {\\n            if(freq[i] == 0) break;            \\n            if(freq[i] >= freq[i+1]){\\n                int prev = freq[i];\\n                freq[i] = max(0, freq[i+1] -1);\\n                del += prev - freq[i]; \\n            }\\n        }\\n        return del;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet the string be  : abbccdddeeffffggg \\nSo count of a=1, b=2, c=2, d=3, e=2, f=4, g=3. So freq = {1,2,2,3,2,4,3,0,......,0}\\nSo after sorting the elements of the freq array are = {0,......, 0, 1,2,2,2,3,3,4}\\n\\nSo at each step in the loop : [ Element of consideration is included in \\' \\', ans next element included in ( )]\\n\\n[0, .... ,0,1,2,2,2,3,\\'3\\',(4)] -> \\'3\\' != 0, \\'3\\' < (4), So continue.\\n[0, .... ,0,1,2,2,2,\\'3\\',(3),4] -> \\'3\\' != 0, \\'3\\' == (3), So prev = \\'3\\', freq[i] = max(0, (3)-1) = 2, del += 3-2 i.e. del = 1\\n[0, .... ,0,1,2,2,\\'2\\',(2),3,4] -> \\'2\\' != 0, \\'2\\' == (2), So prev = \\'2\\', freq[i] = max(0, (2)-1) = 1, del += 2-1 i.e. del = 2\\n[0, .... ,0,1,2,\\'2\\',(1),2,3,4] -> \\'2\\' != 0, \\'2\\' > (1), So prev = \\'2\\', freq[i] = max(0, (1)-1) = 0, del += 2-0 i.e. del = 4\\n[0, .... ,0,1,\\'2\\',(0),1,2,3,4] -> \\'2\\' != 0, \\'2\\' > (0), So prev = \\'2\\', freq[i] = max(0, (0)-1) = 0, del += 2-0 i.e. del = 6\\n[0, .... ,0,\\'1\\',(0),0,1,2,3,4] -> \\'1\\' != 0, \\'1\\' > (0), So prev = \\'1\\', freq[i] = max(0, (0)-1) = 0, del += 1-0 i.e. del = 7\\n[0, .... ,\\'0\\',(0),0,0,1,2,3,4] -> \\'0\\' == 0, break;\\n\\nSee all frequencies become distinct so return del i.e. 7\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        //Array to store the count of each character.\\n        vector<int> freq (26, 0);\\n        \\n        //Calculatimg frequency of all characters.\\n        for (char c : s){\\n            freq[c - \\'a\\']++;\\n        }\\n        \\n        //sorting the frequencies. So the greatest frequencies are in right side.\\n        sort(freq.begin(), freq.end());\\n        \\n        int del = 0; //to store the deletions.\\n        \\n        //Checking if 2 frequencies are same, if same then decrease the frequency so that it becomes less than the next greater one.So Start from the 2nd greatest frequency that is at freq[24].\\n        for (int i = 24; i >= 0; i--) {\\n            \\n            if(freq[i] == 0) break; // if frequency is 0 that means no more character is left.\\n            \\n            if(freq[i] >= freq[i+1]){\\n                int prev = freq[i]; //To store the frequency before deletion.\\n                freq[i] = max(0, freq[i+1] -1); //New frequency should be 1 less than the previous frequency in the array.\\n                del += prev - freq[i]; //Calculating deleted characters \\n            }\\n        }\\n        return del;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq (26, 0);        \\n        for (char c : s) freq[c - \\'a\\']++;\\n        sort(freq.begin(), freq.end());\\n        int del = 0;\\n        for (int i = 24; i >= 0; i--) {\\n            if(freq[i] == 0) break;            \\n            if(freq[i] >= freq[i+1]){\\n                int prev = freq[i];\\n                freq[i] = max(0, freq[i+1] -1);\\n                del += prev - freq[i]; \\n            }\\n        }\\n        return del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033214,
                "title": "99-32-greedy-heap-beginner-friendly-full-explanation-c-java-python",
                "content": "# Problem Understanding\\nThe given problem **asks you to find the minimum number of characters you need to delete from a string s to make it \"good.\"** A string is **considered \"good\" if there are no two different characters in it that have the same frequency.**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is that by **sorting the frequencies in non-decreasing order**, you can start from the highest frequency characters **and gradually decrease their frequencies by deleting characters until they become unique.** This ensures that you delete the minimum number of characters necessary to satisfy the condition of having no two different characters with the same frequency.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Initialize a vector freq of size 26** (for the lowercase English letters) to store the frequency of each character in the input string s. Initialize all elements of freq to 0.\\n\\n2. **Iterate through the characters of the string s and update the frequency of each character in the freq vector**.\\n\\n3. **Sort the freq vector** in ascending order. This will arrange the frequencies in non-decreasing order.\\n\\n4. Initialize a **variable del to keep track of the minimum deletions** required and set it to 0.\\n\\n5. Iterate through the sorted freq vector in reverse order, starting **from index 24 (since there are 26 lowercase English letters).**\\n\\n6. Inside the loop, check **if the current frequency freq[i] is greater than or equal to the next frequency freq[i+1]**. If it is, then you need to delete some characters to make them unique.\\n\\n7. Calculate the number of characters to delete to make freq[i] less than freq[i+1]. **This is done by subtracting freq[i+1] - 1 from freq[i] and setting freq[i] to this new value**. Update the del variable by adding this difference.\\n\\n8. Continue this process until you have iterated through all frequencies, or until you encounter a frequency of 0, indicating that there are no more characters of that frequency.\\n\\n9. **Finally, return the value of del**, which represents the minimum number of deletions required to make the string \"good.\"\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k), where k=26\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n# Code(Greedy Approach)\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create a vector to store the frequency of each lowercase English letter (fixed size of 26).\\n        vector<int> freq(26, 0);\\n\\n        // Iterate through the characters of the input string s to count their frequencies.\\n        for (char c : s) {\\n            freq[c - \\'a\\']++; // Increment the corresponding frequency counter.\\n        }\\n\\n        // Sort the frequency vector in non-decreasing order.\\n        sort(freq.begin(), freq.end());\\n\\n        // Initialize a variable to keep track of the minimum number of deletions needed.\\n        int del = 0;\\n\\n        // Iterate through the sorted frequency vector in reverse order.\\n        for (int i = 24; i >= 0; i--) {\\n            // If the current frequency is 0, break the loop (no more characters with this frequency).\\n            if (freq[i] == 0) {\\n                break;\\n            }\\n            \\n            // Check if the current frequency is greater than or equal to the next frequency.\\n            if (freq[i] >= freq[i + 1]) {\\n                int prev = freq[i];\\n                // Reduce the current frequency to make it one less than the next frequency.\\n                freq[i] = max(0, freq[i + 1] - 1);\\n                // Update the deletion count by the difference between previous and current frequency.\\n                del += prev - freq[i];\\n            }\\n        }\\n\\n        // Return the minimum number of deletions required to make the string \"good.\"\\n        return del;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minDeletions(String s) {\\n        int[] freq = new int[26]; // Create an array to store character frequencies\\n        \\n        for (char c : s.toCharArray()) {\\n            freq[c - \\'a\\']++; // Count the frequency of each character\\n        }\\n        \\n        Arrays.sort(freq); // Sort frequencies in ascending order\\n        \\n        int del = 0; // Initialize the deletion count\\n        \\n        for (int i = 24; i >= 0; i--) {\\n            if (freq[i] == 0) {\\n                break; // No more characters with this frequency\\n            }\\n            \\n            if (freq[i] >= freq[i + 1]) {\\n                int prev = freq[i];\\n                freq[i] = Math.max(0, freq[i + 1] - 1);\\n                del += prev - freq[i]; // Update the deletion count\\n            }\\n        }\\n        \\n        return del; // Return the minimum deletions required\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = [0] * 26 # Create a list to store character frequencies\\n        \\n        for c in s:\\n            freq[ord(c) - ord(\\'a\\')] += 1 # Count the frequency of each character\\n        \\n        freq.sort() # Sort frequencies in ascending order\\n        \\n        del_count = 0 # Initialize the deletion count\\n        \\n        for i in range(24, -1, -1):\\n            if freq[i] == 0:\\n                break # No more characters with this frequency\\n            \\n            if freq[i] >= freq[i + 1]:\\n                prev = freq[i]\\n                freq[i] = max(0, freq[i + 1] - 1)\\n                del_count += prev - freq[i] # Update the deletion count\\n        \\n        return del_count # Return the minimum deletions required\\n\\n```\\n```Javascript []\\nvar minDeletions = function(s) {\\n    let freq = new Array(26).fill(0); // Create an array to store character frequencies\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        freq[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)]++; // Count the frequency of each character\\n    }\\n    \\n    freq.sort((a, b) => a - b); // Sort frequencies in ascending order\\n    \\n    let del = 0; // Initialize the deletion count\\n    \\n    for (let i = 24; i >= 0; i--) {\\n        if (freq[i] === 0) {\\n            break; // No more characters with this frequency\\n        }\\n        \\n        if (freq[i] >= freq[i + 1]) {\\n            let prev = freq[i];\\n            freq[i] = Math.max(0, freq[i + 1] - 1);\\n            del += prev - freq[i]; // Update the deletion count\\n        }\\n    }\\n    \\n    return del; // Return the minimum deletions required\\n};\\n\\n```\\n# Code using Heap Method\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create an unordered map to count the frequency of each character.\\n        unordered_map<char, int> mp;\\n\\n        // Iterate through the characters in the input string \\'s\\'.\\n        for (auto &it : s) {\\n            mp[it]++; // Increment the character\\'s frequency in the map.\\n        }\\n\\n        // Create a max-heap (priority queue) to store character frequencies in decreasing order.\\n        priority_queue<int> pq;\\n\\n        // Populate the max-heap with character frequencies from the map.\\n        for (auto &it : mp) {\\n            pq.push(it.second);\\n        }\\n\\n        // Initialize a variable to keep track of the minimum number of deletions needed.\\n        int count = 0;\\n\\n        // Continue as long as there are at least two frequencies in the max-heap.\\n        while (pq.size() != 1) {\\n            int top = pq.top(); // Get the character frequency with the highest count.\\n            pq.pop(); // Remove it from the max-heap.\\n\\n            // Check if the next character in the max-heap has the same frequency as \\'top\\' (and it\\'s not zero).\\n            if (pq.top() == top && top != 0) {\\n                count++; // Increment the deletion count.\\n                pq.push(top - 1); // Decrease \\'top\\' frequency by 1 and push it back into the max-heap.\\n            }\\n        }\\n\\n        // Return the minimum number of deletions required to make the string \"good.\"\\n        return count;\\n    }\\n};\\n\\n```\\n```java []\\nimport java.util.HashMap;\\nimport java.util.PriorityQueue;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    public int minDeletions(String s) {\\n        // Create a HashMap to count the frequency of each character.\\n        Map<Character, Integer> frequencyMap = new HashMap<>();\\n\\n        // Iterate through the characters in the input string \\'s\\'.\\n        for (char c : s.toCharArray()) {\\n            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        // Create a max-heap (PriorityQueue) to store character frequencies in decreasing order.\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\\n\\n        // Populate the max-heap with character frequencies from the map.\\n        maxHeap.addAll(frequencyMap.values());\\n\\n        // Initialize a variable to keep track of the minimum number of deletions needed.\\n        int count = 0;\\n\\n        // Continue as long as there are at least two frequencies in the max-heap.\\n        while (maxHeap.size() > 1) {\\n            int top = maxHeap.poll(); // Get the character frequency with the highest count.\\n\\n            // Check if the next character in the max-heap has the same frequency as \\'top\\' (and it\\'s not zero).\\n            if (maxHeap.peek() != null && maxHeap.peek() == top && top != 0) {\\n                count++; // Increment the deletion count.\\n                maxHeap.add(top - 1); // Decrease \\'top\\' frequency by 1 and push it back into the max-heap.\\n            }\\n        }\\n\\n        // Return the minimum number of deletions required to make the string \"good.\"\\n        return count;\\n    }\\n}\\n\\n```\\n---\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n![upvotememe.png](https://assets.leetcode.com/users/images/8fe1f84f-c04f-45e9-8490-2b1ac00bf3e6_1694478768.0009294.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create a vector to store the frequency of each lowercase English letter (fixed size of 26).\\n        vector<int> freq(26, 0);\\n\\n        // Iterate through the characters of the input string s to count their frequencies.\\n        for (char c : s) {\\n            freq[c - \\'a\\']++; // Increment the corresponding frequency counter.\\n        }\\n\\n        // Sort the frequency vector in non-decreasing order.\\n        sort(freq.begin(), freq.end());\\n\\n        // Initialize a variable to keep track of the minimum number of deletions needed.\\n        int del = 0;\\n\\n        // Iterate through the sorted frequency vector in reverse order.\\n        for (int i = 24; i >= 0; i--) {\\n            // If the current frequency is 0, break the loop (no more characters with this frequency).\\n            if (freq[i] == 0) {\\n                break;\\n            }\\n            \\n            // Check if the current frequency is greater than or equal to the next frequency.\\n            if (freq[i] >= freq[i + 1]) {\\n                int prev = freq[i];\\n                // Reduce the current frequency to make it one less than the next frequency.\\n                freq[i] = max(0, freq[i + 1] - 1);\\n                // Update the deletion count by the difference between previous and current frequency.\\n                del += prev - freq[i];\\n            }\\n        }\\n\\n        // Return the minimum number of deletions required to make the string \"good.\"\\n        return del;\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minDeletions(String s) {\\n        int[] freq = new int[26]; // Create an array to store character frequencies\\n        \\n        for (char c : s.toCharArray()) {\\n            freq[c - \\'a\\']++; // Count the frequency of each character\\n        }\\n        \\n        Arrays.sort(freq); // Sort frequencies in ascending order\\n        \\n        int del = 0; // Initialize the deletion count\\n        \\n        for (int i = 24; i >= 0; i--) {\\n            if (freq[i] == 0) {\\n                break; // No more characters with this frequency\\n            }\\n            \\n            if (freq[i] >= freq[i + 1]) {\\n                int prev = freq[i];\\n                freq[i] = Math.max(0, freq[i + 1] - 1);\\n                del += prev - freq[i]; // Update the deletion count\\n            }\\n        }\\n        \\n        return del; // Return the minimum deletions required\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = [0] * 26 # Create a list to store character frequencies\\n        \\n        for c in s:\\n            freq[ord(c) - ord(\\'a\\')] += 1 # Count the frequency of each character\\n        \\n        freq.sort() # Sort frequencies in ascending order\\n        \\n        del_count = 0 # Initialize the deletion count\\n        \\n        for i in range(24, -1, -1):\\n            if freq[i] == 0:\\n                break # No more characters with this frequency\\n            \\n            if freq[i] >= freq[i + 1]:\\n                prev = freq[i]\\n                freq[i] = max(0, freq[i + 1] - 1)\\n                del_count += prev - freq[i] # Update the deletion count\\n        \\n        return del_count # Return the minimum deletions required\\n\\n```\n```Javascript []\\nvar minDeletions = function(s) {\\n    let freq = new Array(26).fill(0); // Create an array to store character frequencies\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        freq[s.charCodeAt(i) - \\'a\\'.charCodeAt(0)]++; // Count the frequency of each character\\n    }\\n    \\n    freq.sort((a, b) => a - b); // Sort frequencies in ascending order\\n    \\n    let del = 0; // Initialize the deletion count\\n    \\n    for (let i = 24; i >= 0; i--) {\\n        if (freq[i] === 0) {\\n            break; // No more characters with this frequency\\n        }\\n        \\n        if (freq[i] >= freq[i + 1]) {\\n            let prev = freq[i];\\n            freq[i] = Math.max(0, freq[i + 1] - 1);\\n            del += prev - freq[i]; // Update the deletion count\\n        }\\n    }\\n    \\n    return del; // Return the minimum deletions required\\n};\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create an unordered map to count the frequency of each character.\\n        unordered_map<char, int> mp;\\n\\n        // Iterate through the characters in the input string \\'s\\'.\\n        for (auto &it : s) {\\n            mp[it]++; // Increment the character\\'s frequency in the map.\\n        }\\n\\n        // Create a max-heap (priority queue) to store character frequencies in decreasing order.\\n        priority_queue<int> pq;\\n\\n        // Populate the max-heap with character frequencies from the map.\\n        for (auto &it : mp) {\\n            pq.push(it.second);\\n        }\\n\\n        // Initialize a variable to keep track of the minimum number of deletions needed.\\n        int count = 0;\\n\\n        // Continue as long as there are at least two frequencies in the max-heap.\\n        while (pq.size() != 1) {\\n            int top = pq.top(); // Get the character frequency with the highest count.\\n            pq.pop(); // Remove it from the max-heap.\\n\\n            // Check if the next character in the max-heap has the same frequency as \\'top\\' (and it\\'s not zero).\\n            if (pq.top() == top && top != 0) {\\n                count++; // Increment the deletion count.\\n                pq.push(top - 1); // Decrease \\'top\\' frequency by 1 and push it back into the max-heap.\\n            }\\n        }\\n\\n        // Return the minimum number of deletions required to make the string \"good.\"\\n        return count;\\n    }\\n};\\n\\n```\n```java []\\nimport java.util.HashMap;\\nimport java.util.PriorityQueue;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    public int minDeletions(String s) {\\n        // Create a HashMap to count the frequency of each character.\\n        Map<Character, Integer> frequencyMap = new HashMap<>();\\n\\n        // Iterate through the characters in the input string \\'s\\'.\\n        for (char c : s.toCharArray()) {\\n            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        // Create a max-heap (PriorityQueue) to store character frequencies in decreasing order.\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\\n\\n        // Populate the max-heap with character frequencies from the map.\\n        maxHeap.addAll(frequencyMap.values());\\n\\n        // Initialize a variable to keep track of the minimum number of deletions needed.\\n        int count = 0;\\n\\n        // Continue as long as there are at least two frequencies in the max-heap.\\n        while (maxHeap.size() > 1) {\\n            int top = maxHeap.poll(); // Get the character frequency with the highest count.\\n\\n            // Check if the next character in the max-heap has the same frequency as \\'top\\' (and it\\'s not zero).\\n            if (maxHeap.peek() != null && maxHeap.peek() == top && top != 0) {\\n                count++; // Increment the deletion count.\\n                maxHeap.add(top - 1); // Decrease \\'top\\' frequency by 1 and push it back into the max-heap.\\n            }\\n        }\\n\\n        // Return the minimum number of deletions required to make the string \"good.\"\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033205,
                "title": "98-18-greedy-heap-sorting",
                "content": "# Comprehensive Guide to Solving \"Minimum Deletions to Make Character Frequencies Unique\"\\n\\n## Introduction & Problem Statement\\n\\nWelcome, code enthusiasts! Today, we\\'re tackling an intriguing problem: **Minimum Deletions to Make Character Frequencies Unique**. Given a string  `s` , the goal is to delete the minimum number of characters so that no two characters have the same frequency.\\n\\nFor instance, if the input string is \"aaabbbcc\", you can delete two \\'b\\'s to make the string \"aaabcc\", ensuring that each character has a unique frequency.\\n\\n## Key Concepts and Constraints\\n\\n### What Makes this Problem Unique?\\n\\n1. **Character Frequency**: \\n   Each character in the string  `s`  has a frequency, and we need to make sure no two characters share the same frequency after deletions.\\n\\n2. **Minimum Deletions**:\\n   The goal is to achieve this with the fewest number of deletions.\\n\\n3. **Constraints**: \\n   - The length of the string `s` ,  `n` , is between `1` and  `10^5` .\\n   - The string  `s` contains only lowercase English letters.\\n\\n---\\n\\n# Strategies to Tackle the Problem:\\n\\n## Live Coding & Explain Greedy\\nhttps://youtu.be/QkCo8HhiwYU?si=zPPAMxrpL0a0c4Ns\\n\\n## Greedy Algorithm 1/3: Minimizing Deletions Step by Step\\n\\n### What is a Greedy Algorithm?\\nA Greedy Algorithm makes choices that seem the best at the moment. In the context of this problem, we\\'ll try to make each character frequency unique by making the fewest number of changes to the existing frequencies.\\n\\n### Detailed Steps\\n\\n1. **Step 1: Count Frequencies**  \\n   - **Why Count Frequencies?**:  \\n     Before we can decide which characters to delete, we need to know how often each character appears. This is done using a frequency counter, stored in a dictionary `cnt`.\\n  \\n2. **Step 2: Iterate and Minimize**\\n   - **Why Iterate Through Frequencies?**:  \\n     We need to ensure that all character frequencies are unique. To do this, we iterate through the `cnt` dictionary. If a frequency is already used, we decrement it by 1 until it becomes unique, keeping track of these decrements in a variable `deletions`.\\n\\n3. **Step 3: Return Deletions**\\n   - **What is the Output?**:  \\n     The function returns the total number of deletions (`deletions`) required to make all character frequencies unique.\\n\\n#### Time and Space Complexity\\n- **Time Complexity**: $$O(n)$$, as you only iterate through the list once.\\n- **Space Complexity**: $$O(n)$$, to store the frequencies in `cnt` and the used frequencies in `used_frequencies`.\\n\\n## Code Greedy\\n``` Python []\\n# Greedy Approach\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        for char, freq in cnt.items():\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```\\n``` Go []\\nfunc minDeletions(s string) int {\\n    cnt := make(map[rune]int)\\n    deletions := 0\\n    used_frequencies := make(map[int]bool)\\n    \\n    for _, c := range s {\\n        cnt[c]++\\n    }\\n    \\n    for _, freq := range cnt {\\n        for freq > 0 && used_frequencies[freq] {\\n            freq--\\n            deletions++\\n        }\\n        used_frequencies[freq] = true\\n    }\\n    \\n    return deletions\\n}\\n```\\n``` Rust []\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn min_deletions(s: String) -> i32 {\\n        let mut cnt = HashMap::new();\\n        let mut deletions = 0;\\n        let mut used_frequencies = HashSet::new();\\n        \\n        for c in s.chars() {\\n            *cnt.entry(c).or_insert(0) += 1;\\n        }\\n        \\n        for freq in cnt.values() {\\n            let mut f = *freq;\\n            while f > 0 && used_frequencies.contains(&f) {\\n                f -= 1;\\n                deletions += 1;\\n            }\\n            used_frequencies.insert(f);\\n        }\\n        \\n        deletions\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(std::string s) {\\n        std::unordered_map<char, int> cnt;\\n        int deletions = 0;\\n        std::unordered_set<int> used_frequencies;\\n        \\n        for (char c : s) {\\n            cnt[c]++;\\n        }\\n        \\n        for (auto& kv : cnt) {\\n            int freq = kv.second;\\n            while (freq > 0 && used_frequencies.find(freq) != used_frequencies.end()) {\\n                freq--;\\n                deletions++;\\n            }\\n            used_frequencies.insert(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int minDeletions(String s) {\\n        HashMap<Character, Integer> cnt = new HashMap<>();\\n        int deletions = 0;\\n        HashSet<Integer> used_frequencies = new HashSet<>();\\n        \\n        for (char c : s.toCharArray()) {\\n            cnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        for (int freq : cnt.values()) {\\n            while (freq > 0 && used_frequencies.contains(freq)) {\\n                freq--;\\n                deletions++;\\n            }\\n            used_frequencies.add(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    const cnt = {};\\n    let deletions = 0;\\n    const used_frequencies = new Set();\\n    \\n    for (const c of s) {\\n        cnt[c] = (cnt[c] || 0) + 1;\\n    }\\n    \\n    for (const freq of Object.values(cnt)) {\\n        let f = freq;\\n        while (f > 0 && used_frequencies.has(f)) {\\n            f--;\\n            deletions++;\\n        }\\n        used_frequencies.add(f);\\n    }\\n    \\n    return deletions;\\n}\\n```\\n``` PHP []\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minDeletions($s) {\\n    $cnt = [];\\n    $deletions = 0;\\n    $used_frequencies = [];\\n    \\n    foreach (str_split($s) as $c) {\\n        $cnt[$c] = ($cnt[$c] ?? 0) + 1;\\n    }\\n    \\n    foreach ($cnt as $freq) {\\n        while ($freq > 0 && in_array($freq, $used_frequencies)) {\\n            $freq--;\\n            $deletions++;\\n        }\\n        $used_frequencies[] = $freq;\\n    }\\n    \\n    return $deletions;\\n}\\n}\\n```\\n``` C# []\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution {\\n    public int MinDeletions(string s) {\\n        Dictionary<char, int> cnt = new Dictionary<char, int>();\\n        int deletions = 0;\\n        HashSet<int> used_frequencies = new HashSet<int>();\\n        \\n        foreach (char c in s) {\\n            if (cnt.ContainsKey(c)) cnt[c]++;\\n            else cnt[c] = 1;\\n        }\\n        \\n        foreach (int freqReadOnly in cnt.Values) {\\n            int freq = freqReadOnly;\\n            while (freq > 0 && used_frequencies.Contains(freq)) {\\n                freq--;\\n                deletions++;\\n            }\\n            used_frequencies.Add(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n}\\n```\\n\\n---\\n\\n## Sorting Algorithm 2/3: Sort and Minimize\\n\\n### Detailed Steps\\n\\n#### Step 1: Count and Sort Frequencies\\n\\n- **Why Sort?**:  \\n  Sorting brings an order to the chaos. When you sort the frequencies in descending order, you can start adjusting from the highest frequency downwards. This is beneficial because higher frequencies have a greater range of potential unique lower frequencies they can be adjusted to. For example, a frequency of 10 can be decreased to any of 9, 8, 7, ... until it becomes unique, giving us more \"room\" to make adjustments.\\n\\n#### Step 2: Iterate and Minimize\\n\\n- **Why Iterate Through Sorted Frequencies?**:  \\n  After sorting, the frequencies are now in an ordered list, `sorted_freqs`. We iterate through this list, and for each frequency, we decrease it until it becomes unique. The advantage of working with sorted frequencies is that we can minimize the number of operations by taking advantage of the \"room\" lower frequencies offer for adjustment.\\n\\n#### Step 3: Early Exit Optimization\\n\\n- **Why Early Exit?**:  \\n  An important optimization is to exit the loop early when you find a frequency that is already unique. In a sorted list, if you encounter a frequency that is unique, then all frequencies that come after it in the list will also be unique. This is because they will all be smaller and we have already confirmed that larger frequencies are unique.\\n\\n#### Step 4: Return Deletions\\n\\n- **What is the output?**:  \\n  After iterating through `sorted_freqs` and making the necessary adjustments, we return the total number of deletions required to make the frequencies unique.\\n\\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$ O(n \\\\log n) $$ due to sorting. Sorting the frequencies is the most time-consuming part here.\\n- **Space Complexity**: $$ O(n) $$ for storing frequencies and used frequencies.\\n\\n## Code Sorting\\n``` Python []\\n# Sorting Approach\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        sorted_freqs = sorted(cnt.values(), reverse=True)\\n        \\n        for freq in sorted_freqs:\\n            if freq not in used_frequencies:  # Early exit condition\\n                used_frequencies.add(freq)\\n                continue  \\n\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```\\n``` Go []\\nfunc minDeletions(s string) int {\\n\\tcnt := make(map[rune]int)\\n\\tdeletions := 0\\n\\tused_frequencies := make(map[int]bool)\\n\\n\\tfor _, c := range s {\\n\\t\\tcnt[c]++\\n\\t}\\n\\n\\tsortedFreqs := make([]int, 0, len(cnt))\\n\\tfor _, freq := range cnt {\\n\\t\\tsortedFreqs = append(sortedFreqs, freq)\\n\\t}\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(sortedFreqs)))\\n\\n\\tfor _, freq := range sortedFreqs {\\n\\t\\tfor freq > 0 && used_frequencies[freq] {\\n\\t\\t\\tfreq--\\n\\t\\t\\tdeletions++\\n\\t\\t}\\n\\t\\tused_frequencies[freq] = true\\n\\t}\\n\\n\\treturn deletions\\n}\\n```\\n\\n---\\n\\n## Heap / Priority Queue 3/3: Prioritize Frequencies to Adjust\\n\\n### Detailed Steps\\n\\n#### Step 1: Count Frequencies and Build Heap\\n\\n- **Why Use a Heap?**:  \\n  A min-heap is a specialized tree-based data structure that keeps the smallest element at the top. In the context of this problem, the smallest frequency will always be at the top of the heap. This allows us to focus on making the smallest frequencies unique first, which is generally easier and requires fewer adjustments.\\n\\n#### Step 2: Iterate and Minimize Using Heap\\n\\n- **Why Heap?**:  \\n  The heap automatically \"tells\" us which frequency should be adjusted next (it will be the smallest one). We pop this smallest frequency and make it unique by decrementing it until it no longer matches any other frequency. The advantage here is that the heap dynamically updates, so after each adjustment, the next smallest frequency is ready for us to examine.\\n\\n### Time and Space Complexity\\n\\n- **Time Complexity**: $$ O(n \\\\log n) $$ due to heap operations. Each insertion and removal from the heap takes $$ \\\\log n $$ time, and we may need to do this $$ n $$ times.\\n- **Space Complexity**: $$ O(n) $$ for storing the frequencies in `cnt` and the used frequencies in `used_frequencies`.\\n\\n\\n## Code Heap\\n``` Python []\\n# Heap / Priority Queue Approach\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        heap = list(cnt.values())\\n        heapq.heapify(heap)\\n        \\n        while heap:\\n            freq = heapq.heappop(heap)\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```\\n``` Go []\\nimport (\\n\\t\"container/heap\"\\n\\t\"fmt\"\\n)\\n\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc minDeletions(s string) int {\\n\\tcnt := make(map[rune]int)\\n\\tdeletions := 0\\n\\tused_frequencies := make(map[int]bool)\\n\\n\\tfor _, c := range s {\\n\\t\\tcnt[c]++\\n\\t}\\n\\n\\th := &IntHeap{}\\n\\theap.Init(h)\\n\\n\\tfor _, freq := range cnt {\\n\\t\\theap.Push(h, freq)\\n\\t}\\n\\n\\tfor h.Len() > 0 {\\n\\t\\tfreq := heap.Pop(h).(int)\\n\\t\\tfor freq > 0 && used_frequencies[freq] {\\n\\t\\t\\tfreq--\\n\\t\\t\\tdeletions++\\n\\t\\t}\\n\\t\\tused_frequencies[freq] = true\\n\\t}\\n\\n\\treturn deletions\\n}\\n```\\n\\n---\\n\\n## Performance\\n\\n| Language   | Approach  | Execution Time (ms) | Memory Usage (MB) |\\n|------------|-----------|---------------------|-------------------|\\n| Rust       | Greedy    | 31                  | 2.5               |\\n| Go         | Heap      | 51                  | 6.8               |\\n| Java       | Greedy    | 50                  | 45                |\\n| C++        | Greedy    | 75                  | 17.5              |\\n| Go         | Greedy    | 62                  | 6.6               |\\n| PHP        | Greedy    | 95                  | 26.2              |\\n| Python3    | Heap      | 99                  | 17.1              |\\n| Python3    | Greedy    | 105                 | 17.2              |\\n| C#         | Greedy    | 105                 | 42.8              |\\n| Python3    | Sorting   | 106                 | 17.1              |\\n| JavaScript | Greedy    | 125                 | 48.4              |\\n\\n![b12.png](https://assets.leetcode.com/users/images/1d3bb7a3-365f-489a-8909-69411159c31a_1694479615.9085221.png)\\n\\n\\n## Live Coding & Explain Heap & Sort\\nhttps://youtu.be/myQ6RGLyaDM?si=5nfp8jnnsp_srtCz\\n\\n## Code Highlights and Best Practices\\n\\n- The Greedy Algorithm is simple and efficient, making it a go-to approach for this problem.\\n- The Sorting Algorithm provides another effective way to tackle this problem but with a slight overhead due to sorting.\\n- The Heap / Priority Queue approach adds a layer of optimization by prioritizing which frequencies to adjust first.\\n\\nBy mastering these approaches, you\\'ll be well-equipped to tackle other frequency-based or deletion-minimizing problems, which are common in coding interviews and competitive programming. So, are you ready to make some string frequencies unique? Let\\'s get coding!\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Greedy",
                    "Sorting"
                ],
                "code": "``` Python []\\n# Greedy Approach\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        for char, freq in cnt.items():\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```\n``` Go []\\nfunc minDeletions(s string) int {\\n    cnt := make(map[rune]int)\\n    deletions := 0\\n    used_frequencies := make(map[int]bool)\\n    \\n    for _, c := range s {\\n        cnt[c]++\\n    }\\n    \\n    for _, freq := range cnt {\\n        for freq > 0 && used_frequencies[freq] {\\n            freq--\\n            deletions++\\n        }\\n        used_frequencies[freq] = true\\n    }\\n    \\n    return deletions\\n}\\n```\n``` Rust []\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn min_deletions(s: String) -> i32 {\\n        let mut cnt = HashMap::new();\\n        let mut deletions = 0;\\n        let mut used_frequencies = HashSet::new();\\n        \\n        for c in s.chars() {\\n            *cnt.entry(c).or_insert(0) += 1;\\n        }\\n        \\n        for freq in cnt.values() {\\n            let mut f = *freq;\\n            while f > 0 && used_frequencies.contains(&f) {\\n                f -= 1;\\n                deletions += 1;\\n            }\\n            used_frequencies.insert(f);\\n        }\\n        \\n        deletions\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(std::string s) {\\n        std::unordered_map<char, int> cnt;\\n        int deletions = 0;\\n        std::unordered_set<int> used_frequencies;\\n        \\n        for (char c : s) {\\n            cnt[c]++;\\n        }\\n        \\n        for (auto& kv : cnt) {\\n            int freq = kv.second;\\n            while (freq > 0 && used_frequencies.find(freq) != used_frequencies.end()) {\\n                freq--;\\n                deletions++;\\n            }\\n            used_frequencies.insert(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int minDeletions(String s) {\\n        HashMap<Character, Integer> cnt = new HashMap<>();\\n        int deletions = 0;\\n        HashSet<Integer> used_frequencies = new HashSet<>();\\n        \\n        for (char c : s.toCharArray()) {\\n            cnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        for (int freq : cnt.values()) {\\n            while (freq > 0 && used_frequencies.contains(freq)) {\\n                freq--;\\n                deletions++;\\n            }\\n            used_frequencies.add(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    const cnt = {};\\n    let deletions = 0;\\n    const used_frequencies = new Set();\\n    \\n    for (const c of s) {\\n        cnt[c] = (cnt[c] || 0) + 1;\\n    }\\n    \\n    for (const freq of Object.values(cnt)) {\\n        let f = freq;\\n        while (f > 0 && used_frequencies.has(f)) {\\n            f--;\\n            deletions++;\\n        }\\n        used_frequencies.add(f);\\n    }\\n    \\n    return deletions;\\n}\\n```\n``` PHP []\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minDeletions($s) {\\n    $cnt = [];\\n    $deletions = 0;\\n    $used_frequencies = [];\\n    \\n    foreach (str_split($s) as $c) {\\n        $cnt[$c] = ($cnt[$c] ?? 0) + 1;\\n    }\\n    \\n    foreach ($cnt as $freq) {\\n        while ($freq > 0 && in_array($freq, $used_frequencies)) {\\n            $freq--;\\n            $deletions++;\\n        }\\n        $used_frequencies[] = $freq;\\n    }\\n    \\n    return $deletions;\\n}\\n}\\n```\n``` C# []\\nusing System;\\nusing System.Collections.Generic;\\n\\npublic class Solution {\\n    public int MinDeletions(string s) {\\n        Dictionary<char, int> cnt = new Dictionary<char, int>();\\n        int deletions = 0;\\n        HashSet<int> used_frequencies = new HashSet<int>();\\n        \\n        foreach (char c in s) {\\n            if (cnt.ContainsKey(c)) cnt[c]++;\\n            else cnt[c] = 1;\\n        }\\n        \\n        foreach (int freqReadOnly in cnt.Values) {\\n            int freq = freqReadOnly;\\n            while (freq > 0 && used_frequencies.Contains(freq)) {\\n                freq--;\\n                deletions++;\\n            }\\n            used_frequencies.Add(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n}\\n```\n``` Python []\\n# Sorting Approach\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        sorted_freqs = sorted(cnt.values(), reverse=True)\\n        \\n        for freq in sorted_freqs:\\n            if freq not in used_frequencies:  # Early exit condition\\n                used_frequencies.add(freq)\\n                continue  \\n\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```\n``` Go []\\nfunc minDeletions(s string) int {\\n\\tcnt := make(map[rune]int)\\n\\tdeletions := 0\\n\\tused_frequencies := make(map[int]bool)\\n\\n\\tfor _, c := range s {\\n\\t\\tcnt[c]++\\n\\t}\\n\\n\\tsortedFreqs := make([]int, 0, len(cnt))\\n\\tfor _, freq := range cnt {\\n\\t\\tsortedFreqs = append(sortedFreqs, freq)\\n\\t}\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(sortedFreqs)))\\n\\n\\tfor _, freq := range sortedFreqs {\\n\\t\\tfor freq > 0 && used_frequencies[freq] {\\n\\t\\t\\tfreq--\\n\\t\\t\\tdeletions++\\n\\t\\t}\\n\\t\\tused_frequencies[freq] = true\\n\\t}\\n\\n\\treturn deletions\\n}\\n```\n``` Python []\\n# Heap / Priority Queue Approach\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        heap = list(cnt.values())\\n        heapq.heapify(heap)\\n        \\n        while heap:\\n            freq = heapq.heappop(heap)\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```\n``` Go []\\nimport (\\n\\t\"container/heap\"\\n\\t\"fmt\"\\n)\\n\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc minDeletions(s string) int {\\n\\tcnt := make(map[rune]int)\\n\\tdeletions := 0\\n\\tused_frequencies := make(map[int]bool)\\n\\n\\tfor _, c := range s {\\n\\t\\tcnt[c]++\\n\\t}\\n\\n\\th := &IntHeap{}\\n\\theap.Init(h)\\n\\n\\tfor _, freq := range cnt {\\n\\t\\theap.Push(h, freq)\\n\\t}\\n\\n\\tfor h.Len() > 0 {\\n\\t\\tfreq := heap.Pop(h).(int)\\n\\t\\tfor freq > 0 && used_frequencies[freq] {\\n\\t\\t\\tfreq--\\n\\t\\t\\tdeletions++\\n\\t\\t}\\n\\t\\tused_frequencies[freq] = true\\n\\t}\\n\\n\\treturn deletions\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927654,
                "title": "c-java-python3-simple-time-o-n-space-o-1-a-small-array-is-all-you-need",
                "content": "#### Steps\\n\\n1. Count frequency of each letter\\n2. Sort the frequencies\\n3. From the letter with highest frequency, for each letter we keep no more than previous letter\\n4. Total number - number we kept = number we want to delete\\n\\n#### C++\\n\\n```cpp\\nint minDeletions(string s) {\\n\\tarray<int, 26> freq{};\\n\\tfor (char c : s) ++freq[c - \\'a\\'];\\n\\tsort(freq.begin(), freq.end(), greater<int>());\\n\\tint keep = 0, prev = INT_MAX;\\n\\tfor (int f : freq) {\\n\\t\\tif (!f || !prev) break;\\n\\t\\tprev = min(f, prev - 1);\\n\\t\\tkeep += prev;\\n\\t}\\n\\treturn s.size() - keep;\\n}\\n```\\n\\n#### Java\\n\\n```java\\npublic int minDeletions(String s) {\\n\\tint freq[] = new int[26];\\n\\tfor (char c : s.toCharArray())\\n\\t\\tfreq[c - \\'a\\']++;\\n\\tArrays.sort(freq);\\n\\tint keep = freq[25], prev = keep;\\n\\tfor (int i = 24; i >= 0 && freq[i] != 0 && prev != 0; i--) {\\n\\t\\tprev = Math.min(freq[i], prev - 1);\\n\\t\\tkeep += prev;\\n\\t}\\n\\treturn s.length() - keep;\\n}\\n```\\n\\n#### Python3\\n\\n> Update (01/Aug/2021): Added a python3 solution. This solution uses `collections.Counter` instead `array`, just for convenience. Same theory.\\n\\n```python\\ndef minDeletions(self, s: str) -> int:\\n    prev, keep = inf, 0\\n    for freq in sorted(Counter(s).values(), reverse=True):\\n        freq = min(prev - 1, freq)\\n        if freq == 0:\\n            break\\n        keep += freq\\n        prev = freq\\n    return len(s) - keep\\n```\\n\\n#### Complexity\\n\\nTime: step 1 is O(n), other steps are O(1) (sorting/checking 26 numbers) - overall **O(n)**\\nspace: using array of size 26 - **O(1)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint minDeletions(string s) {\\n\\tarray<int, 26> freq{};\\n\\tfor (char c : s) ++freq[c - \\'a\\'];\\n\\tsort(freq.begin(), freq.end(), greater<int>());\\n\\tint keep = 0, prev = INT_MAX;\\n\\tfor (int f : freq) {\\n\\t\\tif (!f || !prev) break;\\n\\t\\tprev = min(f, prev - 1);\\n\\t\\tkeep += prev;\\n\\t}\\n\\treturn s.size() - keep;\\n}\\n```\n```java\\npublic int minDeletions(String s) {\\n\\tint freq[] = new int[26];\\n\\tfor (char c : s.toCharArray())\\n\\t\\tfreq[c - \\'a\\']++;\\n\\tArrays.sort(freq);\\n\\tint keep = freq[25], prev = keep;\\n\\tfor (int i = 24; i >= 0 && freq[i] != 0 && prev != 0; i--) {\\n\\t\\tprev = Math.min(freq[i], prev - 1);\\n\\t\\tkeep += prev;\\n\\t}\\n\\treturn s.length() - keep;\\n}\\n```\n```python\\ndef minDeletions(self, s: str) -> int:\\n    prev, keep = inf, 0\\n    for freq in sorted(Counter(s).values(), reverse=True):\\n        freq = min(prev - 1, freq)\\n        if freq == 0:\\n            break\\n        keep += freq\\n        prev = freq\\n    return len(s) - keep\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1107954,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] charCount = new int[26];\\n        \\n        for(char ch : s.toCharArray()){\\n            charCount[ ch - \\'a\\'] ++;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        int deletion = 0;\\n        \\n        for(int val : charCount){\\n            while(val !=0 && set.contains(val)){\\n                val--;\\n                deletion++;\\n            }\\n            set.add(val);          \\n        }\\n       \\n        return deletion;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minDeletions(String s) {\\n        int[] charCount = new int[26];\\n        \\n        for(char ch : s.toCharArray()){\\n            charCount[ ch - \\'a\\'] ++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 927553,
                "title": "java-greedy-o-n",
                "content": "Sort the frequency, count from largest and always set a expectation for each frequency in decreasing order.\\n```\\n// Example:  freq = [50, 50, 49, 6, 5]\\n// So for the second 50, exp = 49; And for 49, exp = 48;\\n// And for 6, exp = 47, but 47 > 6 let\\'s re-adjust exp = 6.\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] freq = new int[26];\\n        for (char c : s.toCharArray()) {\\n            freq[c - \\'a\\']++;\\n        }\\n\\t\\tArrays.sort(freq);\\n        int exp = freq[25];\\n        int res = 0;\\n        for (int i = 25; i >= 0; i--) {\\n            if (freq[i] == 0) break;\\n            if (freq[i] > exp) {\\n                res += freq[i] - exp;\\n            } else {\\n                exp = freq[i];\\n            }\\n            if (exp > 0) exp--; // Lowest exp is zero, cannot be negative\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Example:  freq = [50, 50, 49, 6, 5]\\n// So for the second 50, exp = 49; And for 49, exp = 48;\\n// And for 6, exp = 47, but 47 > 6 let\\'s re-adjust exp = 6.\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] freq = new int[26];\\n        for (char c : s.toCharArray()) {\\n            freq[c - \\'a\\']++;\\n        }\\n\\t\\tArrays.sort(freq);\\n        int exp = freq[25];\\n        int res = 0;\\n        for (int i = 25; i >= 0; i--) {\\n            if (freq[i] == 0) break;\\n            if (freq[i] > exp) {\\n                res += freq[i] - exp;\\n            } else {\\n                exp = freq[i];\\n            }\\n            if (exp > 0) exp--; // Lowest exp is zero, cannot be negative\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223602,
                "title": "python-easy-sol-with-explanation",
                "content": "\\n        \\n        So the basic idea is that we are firslt gonna make a dictionary and along with it we will keep a set \\n        \\n        where we will store the unique freq of all the ele after deletion and then we ill keep a counter for     \\n        \\n        number of deletion made othen we will see if the current ele freq is unqiue we will add it to set\\n        \\n        the freq of current ele is in \\n        \\n        S = collections.Counter(s)\\n        \\n        count= 0\\n        \\n        unique = set()\\n        \\n        for char, freq in S.items():\\n            while freq >0 and freq in unique:\\n                freq-=1\\n                count+=1\\n                \\n            unique.add(freq)\\n            \\n        return count\\n\\n*Time complexity O(n) and Memory : O(n)\\t\\t\\n**if you like it or find it helpful kindly upvote**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "\\n        \\n        So the basic idea is that we are firslt gonna make a dictionary and along with it we will keep a set \\n        \\n        where we will store the unique freq of all the ele after deletion and then we ill keep a counter for     \\n        \\n        number of deletion made othen we will see if the current ele freq is unqiue we will add it to set\\n        \\n        the freq of current ele is in \\n        \\n        S = collections.Counter(s)\\n        \\n        count= 0\\n        \\n        unique = set()\\n        \\n        for char, freq in S.items():\\n            while freq >0 and freq in unique:\\n                freq-=1\\n                count+=1\\n                \\n            unique.add(freq)\\n            \\n        return count\\n\\n*Time complexity O(n) and Memory : O(n)\\t\\t\\n**if you like it or find it helpful kindly upvote**",
                "codeTag": "Unknown"
            },
            {
                "id": 1203425,
                "title": "problem-1647-c-solution-with-clear-explanations",
                "content": "### Solution\\n\\nIt\\'s clear that it would be useful to have the count of each character because that\\'s how we will determine if a string is good. A map is a natural choice for doing this. We could also use a fixed-size array because we know there are 26 letters but I prefer using a map because it\\'s more general.\\n\\nNow we want to figure out if we\\'ve seen a given count before. A set is a natural data structure for keeping track of what we\\'ve seen. So we go through our counts and insert any new un-seen numbers into the set. If we\\'ve seen a certain count before, we decrement it until we haven\\'t seen it before.\\n\\nWe just need to be careful with 0. Imagine if our frequencies are all 1. We put the first 1 into our set. Then we decrement the second 1 to avoid a collision. So that count became 0, which means we don\\'t have the associated letter at all anymore. We shouldn\\'t put 0 into our set because otherwise the next 1 would need to be decremented twice to become unique, which doesn\\'t make sense. Once we get to 0, we stop decrementing because the letter doesn\\'t exist anymore.\\n\\nAnother idea would be to sort our frequencies. See some of the other posts for this idea.\\n\\n```cpp\\nint minDeletions(string s) {\\n  int ans = 0;\\n  // count each char\\n  unordered_map<char, int> char_counts;\\n  for (const char& c : s) char_counts[c]++;\\n  unordered_set<int> seen;\\n\\n  for (auto[k, v] : char_counts) {\\n    // if we\\'ve seen it, decrement it until we haven\\'t\\n    while (seen.find(v) != seen.end()) {\\n      v--;\\n      ans++;\\n    }\\n    if (v > 0) seen.insert(v);\\n  }\\n\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minDeletions(string s) {\\n  int ans = 0;\\n  // count each char\\n  unordered_map<char, int> char_counts;\\n  for (const char& c : s) char_counts[c]++;\\n  unordered_set<int> seen;\\n\\n  for (auto[k, v] : char_counts) {\\n    // if we\\'ve seen it, decrement it until we haven\\'t\\n    while (seen.find(v) != seen.end()) {\\n      v--;\\n      ans++;\\n    }\\n    if (v > 0) seen.insert(v);\\n  }\\n\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 927527,
                "title": "python3-most-to-least-frequent-characters",
                "content": "Algo\\nCollect the frequency of letters in `s` in a frequency table. Examine the frequencies from highest to lowest. If a frequency has been seen, lower it by one by reducing its character. Repeat the operation until all frequencies are unique (possibly removing some characters completely). \\n\\nImplementation \\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = {} # frequency table \\n        for c in s: freq[c] = 1 + freq.get(c, 0)\\n        \\n        ans = 0\\n        seen = set()\\n        for k in sorted(freq.values(), reverse=True): \\n            while k in seen: \\n                k -= 1 \\n                ans += 1\\n            if k: seen.add(k)\\n        return ans \\n```\\n\\nAnalysis\\nTime complexity `O(NlogN)` due to sorting \\nSpace complexity `O(N)` due to frequency table\\n\\nEdited on 11/08/2020\\nHere, sorting is not necessary as we are recording the seen values. So if one omits the sorting part, it still works. \\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = {} # frequency table \\n        for c in s: freq[c] = 1 + freq.get(c, 0)\\n        \\n        ans = 0\\n        seen = set()\\n        for k in freq.values(): \\n            while k in seen: \\n                k -= 1 \\n                ans += 1\\n            if k: seen.add(k)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = {} # frequency table \\n        for c in s: freq[c] = 1 + freq.get(c, 0)\\n        \\n        ans = 0\\n        seen = set()\\n        for k in sorted(freq.values(), reverse=True): \\n            while k in seen: \\n                k -= 1 \\n                ans += 1\\n            if k: seen.add(k)\\n        return ans \\n```\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = {} # frequency table \\n        for c in s: freq[c] = 1 + freq.get(c, 0)\\n        \\n        ans = 0\\n        seen = set()\\n        for k in freq.values(): \\n            while k in seen: \\n                k -= 1 \\n                ans += 1\\n            if k: seen.add(k)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033516,
                "title": "o-n-time-o-1-space-solution-python-javascript-java-c",
                "content": "# Intuition\\nUsing HashMap to count each character and Set to keep unique frequency of chracters.\\n\\n---\\n\\n# Solution Video\\n\\nhttps://youtu.be/2CXjNZa0ldo\\n\\nMinor update:\\nIn the video, I use Set and variable name is \"uniq_set\". It\\'s a little bit weird because values in Set are usually unique, so we should use variable name like \"freq_set\".\\n\\nIn the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\nThe next subscriber is exact 2300.\\n\\u2B50\\uFE0F Today is my birthday. Please give me the gift of subscribing to my channel\\uFF01\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2299\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n```\\nInput: s = \"aaabbbcc\"\\n```\\n\\n## \\u25A0 Step 1\\nCreate HashMap`chars`. key is character and value is frequency of the character.\\n```\\nchars = {\"a\": 3, \"b\": 3, \"c\": 2}\\n```\\n\\nInitialize `freq_set` with Set and `count` with 0. `freq_set` is used to keep unique frequency of chracters and `count` is return value.\\n\\n## \\u25A0 Step 2\\nStart iteration with `chars`.\\n\\n##### 2-1\\nReagarding `\"a\": 3` in HashMap, `freq` is now `3`. `freq` doesn\\'t meet the condition below\\n```\\nwhile freq > 0 and freq in freq_set:\\n```\\nSo, just add `3` to `freq_set`\\n```\\nNow freq_set = {3}, count = 0\\n```\\n\\n##### 2-2\\nReagarding `\"b\": 3` in HashMap, `freq` is now `3`. `freq` meets the `while condition` above, so we need to add `-1` to `freq`. Now `freq = 2` and add `1` to `count`. Then, check the `while condition` again. `freq` doesn\\'t meet the condition, so add `freq = 2` to `freq_set` .\\n\\n```\\nNow freq_set = {2, 3}, count = 1\\n```\\n\\n##### 2-3\\nReagarding `\"c\": 2` in HashMap, `freq` is now `2`. `freq` meets the `while condition` above, so we need to add `-1` to `freq`. Now `freq = 1` and add `1` to `count`. Then check the `while condition` again. `freq` doesn\\'t meet the condition, so add `1` to `freq_set`.\\n```\\nNow freq_set = {1, 2, 3}, count = 2\\n```\\n\\n```\\nOutput: 2\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\nWe count frequency of each character and store them to HashMap. For example, `Input: s = \"aaabbbcc\"`, we count them 8 times. `Input: s = \"aaabbbccdd\"`, we count them 10 times. It depends on length of input string.\\n\\n- Space complexity: O(1)\\nWe will not store more than 26 different frequencies. Because we have constraint saying \"s contains only lowercase English letters\". It does not grow with length of input string or something. In the worst case O(26) \\u2192 O(1)\\n\\n```python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        chars = Counter(s)\\n\\n        freq_set = set()\\n        count = 0\\n\\n        for freq in chars.values():\\n            while freq > 0 and freq in freq_set:\\n                freq -= 1\\n                count += 1\\n            \\n            freq_set.add(freq)\\n\\n        return count\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    const chars = new Map();\\n    for (const char of s) {\\n        chars.set(char, (chars.get(char) || 0) + 1);\\n    }\\n\\n    const freqSet = new Set();\\n    let count = 0;\\n\\n    for (let freq of chars.values()) {\\n        while (freq > 0 && freqSet.has(freq)) {\\n            freq--;\\n            count++;\\n        }\\n\\n      freqSet.add(freq);\\n    }\\n\\n    return count;    \\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        Map<Character, Integer> chars = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            chars.put(c, chars.getOrDefault(c, 0) + 1);\\n        }\\n\\n        Set<Integer> freqSet = new HashSet<>();\\n        int count = 0;\\n\\n        for (int freq : chars.values()) {\\n            while (freq > 0 && freqSet.contains(freq)) {\\n                freq--;\\n                count++;\\n            }\\n            freqSet.add(freq);\\n        }\\n\\n        return count;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char, int> chars;\\n        for (char c : s) {\\n            chars[c]++;\\n        }\\n\\n        unordered_set<int> freqSet;\\n        int count = 0;\\n\\n        for (const auto& pair : chars) {\\n            int freq = pair.second;\\n            while (freq > 0 && freqSet.count(freq)) {\\n                freq--;\\n                count++;\\n            }\\n            freqSet.insert(freq);\\n        }\\n\\n        return count;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nInput: s = \"aaabbbcc\"\\n```\n```\\nchars = {\"a\": 3, \"b\": 3, \"c\": 2}\\n```\n```\\nwhile freq > 0 and freq in freq_set:\\n```\n```\\nNow freq_set = {3}, count = 0\\n```\n```\\nNow freq_set = {2, 3}, count = 1\\n```\n```\\nNow freq_set = {1, 2, 3}, count = 2\\n```\n```\\nOutput: 2\\n```\n```python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        chars = Counter(s)\\n\\n        freq_set = set()\\n        count = 0\\n\\n        for freq in chars.values():\\n            while freq > 0 and freq in freq_set:\\n                freq -= 1\\n                count += 1\\n            \\n            freq_set.add(freq)\\n\\n        return count\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    const chars = new Map();\\n    for (const char of s) {\\n        chars.set(char, (chars.get(char) || 0) + 1);\\n    }\\n\\n    const freqSet = new Set();\\n    let count = 0;\\n\\n    for (let freq of chars.values()) {\\n        while (freq > 0 && freqSet.has(freq)) {\\n            freq--;\\n            count++;\\n        }\\n\\n      freqSet.add(freq);\\n    }\\n\\n    return count;    \\n};\\n```\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        Map<Character, Integer> chars = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            chars.put(c, chars.getOrDefault(c, 0) + 1);\\n        }\\n\\n        Set<Integer> freqSet = new HashSet<>();\\n        int count = 0;\\n\\n        for (int freq : chars.values()) {\\n            while (freq > 0 && freqSet.contains(freq)) {\\n                freq--;\\n                count++;\\n            }\\n            freqSet.add(freq);\\n        }\\n\\n        return count;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char, int> chars;\\n        for (char c : s) {\\n            chars[c]++;\\n        }\\n\\n        unordered_set<int> freqSet;\\n        int count = 0;\\n\\n        for (const auto& pair : chars) {\\n            int freq = pair.second;\\n            while (freq > 0 && freqSet.count(freq)) {\\n                freq--;\\n                count++;\\n            }\\n            freqSet.insert(freq);\\n        }\\n\\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207282,
                "title": "python-c-o-n-with-interview-time-complexity-tips",
                "content": "**Intuition**\\nThe characters themselves don\\'t matter in this problem, just the number of times each character appears. A character\\'s frequency cannot increase, since we can only delete not add characters.\\n\\nWe want to find the minimum number of deletions, so we should only delete characters when another character has the same frequency while minimizing the number of deletes used.\\n\\n**Implementation**\\n1. Count the frequencies of each character.\\n2. Sort the frequencies so it\\'s easy to find the next unused frequency.\\n3. Initialize `next_unused_freq` to `s.length`. There could be as many as `s.length` characters of the same frequency.\\n4. We can\\'t add characters, so we always need to set `next_unused_freq` to be `<=freq`.\\n5. The number of deletions we need to make this frequency unique is `freq - next_unused_freq`.\\n\\n\\n**Python**\\n```python\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        # Get the frequency of each character sorted in reverse order\\n        frequencies = sorted(Counter(s).values(), reverse=True)\\n        \\n        total_deletions = 0\\n        next_unused_freq = len(s)\\n        for freq in frequencies:\\n            # It is impossible for the frequency to be higher\\n            next_unused_freq = min(next_unused_freq, freq)\\n            total_deletions += freq - next_unused_freq\\n\\n            # We cannot have another character with this frequency,\\n            # so decrement next_unused_freq\\n            if next_unused_freq > 0:\\n                next_unused_freq -= 1\\n\\n        return total_deletions\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // There are 26 lowercase letters, each element in frequencies\\n        // stores the frequency of a character\\n        vector<int> frequencies(26);\\n        for (char ch: s) frequencies[ch - \\'a\\'] += 1;\\n        \\n        // Sort frequencies in reverse order\\n        sort(frequencies.rbegin(), frequencies.rend());\\n        \\n        int total_deletions = 0;\\n        int next_unused_freq = s.length();\\n        for (int freq: frequencies) {\\n            // We cannot add characters, so the frequency cannot be higher\\n            next_unused_freq = min(next_unused_freq, freq);\\n            total_deletions += freq - next_unused_freq;\\n            \\n            // We cannot have another character with this frequency,\\n            // so decrement next_unused_freq\\n            if (next_unused_freq > 0) {\\n                next_unused_freq -= 1;\\n            }\\n        }\\n        return total_deletions;\\n    }\\n};\\n```\\n\\n**Time Complexity**: O(n) - We loop over the string once to get the frequencies. We\\'re sorting `frequencies`, but there can be at most 26 letters, which is constant.\\n\\n**Space Complexity**: O(1) - The `frequencies` array is at most length 26, one for each letter, which is constant.\\n\\nYour interviewer might ask you, \"What\\'s the time/space complexity if you did not restrict `s` to contain only lowercase letter\". How would you answer this?\\n\\nBe sure to join our discord to find the answer to this follow-up question!\\n**https://discord.gg/m9MRe9ZR**\\n\\nLike the post if you found this explanation helpful!",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        # Get the frequency of each character sorted in reverse order\\n        frequencies = sorted(Counter(s).values(), reverse=True)\\n        \\n        total_deletions = 0\\n        next_unused_freq = len(s)\\n        for freq in frequencies:\\n            # It is impossible for the frequency to be higher\\n            next_unused_freq = min(next_unused_freq, freq)\\n            total_deletions += freq - next_unused_freq\\n\\n            # We cannot have another character with this frequency,\\n            # so decrement next_unused_freq\\n            if next_unused_freq > 0:\\n                next_unused_freq -= 1\\n\\n        return total_deletions\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // There are 26 lowercase letters, each element in frequencies\\n        // stores the frequency of a character\\n        vector<int> frequencies(26);\\n        for (char ch: s) frequencies[ch - \\'a\\'] += 1;\\n        \\n        // Sort frequencies in reverse order\\n        sort(frequencies.rbegin(), frequencies.rend());\\n        \\n        int total_deletions = 0;\\n        int next_unused_freq = s.length();\\n        for (int freq: frequencies) {\\n            // We cannot add characters, so the frequency cannot be higher\\n            next_unused_freq = min(next_unused_freq, freq);\\n            total_deletions += freq - next_unused_freq;\\n            \\n            // We cannot have another character with this frequency,\\n            // so decrement next_unused_freq\\n            if (next_unused_freq > 0) {\\n                next_unused_freq -= 1;\\n            }\\n        }\\n        return total_deletions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927582,
                "title": "java-solution-using-max-heap",
                "content": "In first go, it seemed to be the problem related to string manipulation, but its not.\\nIt just about making unique frequencies. Nothing solves this problem better than PriorityQueue. (Max heap).\\n\\nWe would create max heap of frequencies and just manipulate them.\\n\\n For keeping track of frequencies, I have used HashMap here. Feel free to use anything else, like a simple char array from a-z or HashSet would also serve the same purpose. It doesn\\'t matter.\\n\\nAnways, so while going over our priority queue whenever I find two frequencies equal, I would increment my answer `count` and decrement that frequency. Insert this decremented frequency again to the priority queue for rearrangement. This way it is ensured that we have unique freq in our queue.\\n\\n```\\n public int minDeletions(String s) {\\n        int count = 0;\\n\\t\\t\\n\\t\\tMap<Character,Integer> map = new HashMap<>();\\n        for (int i = 0 ; i < s.length(); i++) {\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        \\n\\t\\t// creating max heap of frequencies\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder()); ;\\n\\n\\t\\t//queue.addAll(map.keySet());\\n\\t\\t\\n        for (Map.Entry<Character,Integer> entry : map.entrySet())\\n        {\\n            queue.add(entry.getValue()); \\n        }\\n\\n\\t\\t while (queue.size() > 0) {\\n\\t\\t\\tint most_frequent = queue.remove();\\n\\t\\t\\tif (queue.size() == 0 ) {\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (most_frequent == queue.peek()) {\\n\\t\\t\\t\\tif (most_frequent > 1) {\\n\\t\\t\\t\\t\\tqueue.add(most_frequent - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n public int minDeletions(String s) {\\n        int count = 0;\\n\\t\\t\\n\\t\\tMap<Character,Integer> map = new HashMap<>();\\n        for (int i = 0 ; i < s.length(); i++) {\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        \\n\\t\\t// creating max heap of frequencies\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder()); ;\\n\\n\\t\\t//queue.addAll(map.keySet());\\n\\t\\t\\n        for (Map.Entry<Character,Integer> entry : map.entrySet())\\n        {\\n            queue.add(entry.getValue()); \\n        }\\n\\n\\t\\t while (queue.size() > 0) {\\n\\t\\t\\tint most_frequent = queue.remove();\\n\\t\\t\\tif (queue.size() == 0 ) {\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (most_frequent == queue.peek()) {\\n\\t\\t\\t\\tif (most_frequent > 1) {\\n\\t\\t\\t\\t\\tqueue.add(most_frequent - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033920,
                "title": "easy-to-understand-beginner-friendly-beats-90-python-java-c",
                "content": "# Beats\\n![image.png](https://assets.leetcode.com/users/images/3c18d907-0c92-4f42-98ea-4479115503f4_1694495379.425722.png)\\n\\n# Java code Beats 100% Explanation is along with the code!!!\\n\\n# Upvote If u Like !!!\\n\\n# Intuition\\nThe intuition behind this problem is to find the minimum number of deletions required to make all character frequencies in the string unique. To do this, we need to count the frequencies of each character and then adjust those frequencies to ensure uniqueness while minimizing deletions.\\n\\n# Approach\\nThe approach to solving this problem is as follows:\\n\\n1. Count the frequency of each character in the input string \\'s\\' using a Counter object.\\n2. Initialize a variable \\'deletions\\' to keep track of the number of deletions needed.\\n3. Create an empty set \\'unique_frequencies\\' to store unique frequencies encountered.\\n4. Iterate through each character and its frequency in \\'char_count\\'.\\n5. For each character, enter a loop while its current frequency is greater than 0 and it is already in \\'unique_frequencies\\'.\\n6. Decrement the frequency by 1, indicating that we are considering deleting one occurrence of this character.\\n7. Increment \\'deletions\\' by 1, as we are performing a deletion operation.\\n8. Add the current frequency to \\'unique_frequencies\\' to mark it as seen.\\n9. After processing all characters, return the total number of deletions needed\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is $$O(n)$$, where \\'n\\' is the length of the input string \\'s\\'. This is because we iterate through the string once to count character frequencies.\\n- Space complexity: The space complexity is $$O(n)$$ as well, as we use additional space to store the \\'char_count\\' dictionary and \\'unique_frequencies\\' set.\\n\\n# Code\\n# Python\\n```\\n# Define a class called Solution.\\nclass Solution:\\n    # Define a method called minDeletions within the Solution class.\\n    # This method takes a string \\'s\\' as input and returns an integer.\\n    def minDeletions(self, s: str) -> int:\\n        # Create a Counter object \\'char_count\\' to count the frequency of each character in the input string \\'s\\'.\\n        char_count = Counter(s)\\n        # Initialize a variable \\'deletions\\' to keep track of the number of deletions needed.\\n        deletions = 0\\n        # Create an empty set \\'unique_frequencies\\' to store unique frequencies encountered.\\n\\n        unique_frequencies = set()\\n\\n        # Iterate through each character and its frequency in \\'char_count\\'.\\n        for char, freq in char_count.items():\\n            # Enter a loop while the current frequency \\'freq\\' is greater than 0 and it is already in \\'unique_frequencies\\'.\\n            while freq > 0 and freq in unique_frequencies:\\n                # Decrement \\'freq\\' by 1, indicating that we are considering deleting one occurrence of this character.\\n                freq -= 1\\n                # Increment \\'deletions\\' by 1, as we are performing a deletion operation.\\n                deletions += 1\\n            # Add the current \\'freq\\' to \\'unique_frequencies\\' to mark it as seen.\\n            unique_frequencies.add(freq)\\n            \\n        # After processing all characters, return the total number of deletions needed.\\n        return deletions\\n\\n```\\n# Java\\n```\\n// Define a class called Solution.\\nclass Solution {\\n    // Define a method called minDeletions within the Solution class.\\n    // This method takes a String \\'s\\' as input and returns an integer.\\n    public int minDeletions(String s) {\\n        // Create an array \\'charFrequency\\' to store the frequency of characters (assuming only lowercase English letters).\\n        int[] charFrequency = new int[26]; \\n        // Create a boolean array \\'hasSeen\\' to keep track of whether a frequency has been seen.\\n        boolean[] hasSeen = new boolean[s.length() + 1]; \\n        // Initialize a variable \\'count\\' to keep track of the number of deletions needed.\\n        int count = 0;\\n        \\n        // Iterate through each byte of the input string.\\n        for (byte i : s.getBytes()) {\\n            // Increment the corresponding frequency in \\'charFrequency\\' based on the character\\'s ASCII value.\\n            charFrequency[i - 97]++; \\n        }\\n        \\n        // Iterate through the frequencies of characters (assuming only lowercase English letters).\\n        for (int i = 0; i < 26; i++) {\\n            // Enter a loop while the current frequency has been seen and is not zero.\\n            while (hasSeen[charFrequency[i]] && charFrequency[i] != 0) { \\n                // Decrement the frequency in \\'charFrequency\\' to make it unique.\\n                charFrequency[i]--; \\n                // Increment the \\'count\\' as we are performing a deletion operation.\\n                count++;\\n            }\\n            // Mark the current frequency as seen in \\'hasSeen\\'.\\n            hasSeen[charFrequency[i]] = true; \\n        }\\n        \\n        // After processing all characters, return the total number of deletions needed.\\n        return count;\\n    }\\n}\\n\\n\\n```\\n# C++\\n```\\n// Define a class named Solution.\\nclass Solution {\\npublic:\\n    // Define a method named minDeletions.\\n    int minDeletions(string s) {\\n        int deletionsCount = 0; // Initialize a variable to keep track of deletions.\\n        unordered_map<int, bool> frequencyMap; // Create a map to track seen frequencies.\\n        vector<int> charFrequencyCount(26, 0); // Create a vector to count character frequencies (assuming lowercase English letters).\\n        int n = s.size(); // Get the length of the input string.\\n\\n        // Iterate through the characters in the input string to count their frequencies.\\n        for (int i = 0; i < n; i++)\\n            charFrequencyCount[s[i] - \\'a\\']++;\\n\\n        // Iterate through the possible frequencies (assuming lowercase English letters).\\n        for (int i = 0; i < 26; i++) {\\n            int frequency = charFrequencyCount[i];\\n\\n            // If this frequency has been seen before in the map, make it unique.\\n            if (frequencyMap[frequency] == true) {\\n                while (frequencyMap[frequency] == true && frequency > 0) {\\n                    frequency--;\\n                    deletionsCount++;\\n                }\\n                if (frequency > 0)\\n                    frequencyMap[frequency] = true;\\n            }\\n            else\\n                frequencyMap[frequency] = true;\\n        }\\n\\n        // Return the total number of deletions needed to make frequencies unique.\\n        return deletionsCount;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n# Define a class called Solution.\\nclass Solution:\\n    # Define a method called minDeletions within the Solution class.\\n    # This method takes a string \\'s\\' as input and returns an integer.\\n    def minDeletions(self, s: str) -> int:\\n        # Create a Counter object \\'char_count\\' to count the frequency of each character in the input string \\'s\\'.\\n        char_count = Counter(s)\\n        # Initialize a variable \\'deletions\\' to keep track of the number of deletions needed.\\n        deletions = 0\\n        # Create an empty set \\'unique_frequencies\\' to store unique frequencies encountered.\\n\\n        unique_frequencies = set()\\n\\n        # Iterate through each character and its frequency in \\'char_count\\'.\\n        for char, freq in char_count.items():\\n            # Enter a loop while the current frequency \\'freq\\' is greater than 0 and it is already in \\'unique_frequencies\\'.\\n            while freq > 0 and freq in unique_frequencies:\\n                # Decrement \\'freq\\' by 1, indicating that we are considering deleting one occurrence of this character.\\n                freq -= 1\\n                # Increment \\'deletions\\' by 1, as we are performing a deletion operation.\\n                deletions += 1\\n            # Add the current \\'freq\\' to \\'unique_frequencies\\' to mark it as seen.\\n            unique_frequencies.add(freq)\\n            \\n        # After processing all characters, return the total number of deletions needed.\\n        return deletions\\n\\n```\n```\\n// Define a class called Solution.\\nclass Solution {\\n    // Define a method called minDeletions within the Solution class.\\n    // This method takes a String \\'s\\' as input and returns an integer.\\n    public int minDeletions(String s) {\\n        // Create an array \\'charFrequency\\' to store the frequency of characters (assuming only lowercase English letters).\\n        int[] charFrequency = new int[26]; \\n        // Create a boolean array \\'hasSeen\\' to keep track of whether a frequency has been seen.\\n        boolean[] hasSeen = new boolean[s.length() + 1]; \\n        // Initialize a variable \\'count\\' to keep track of the number of deletions needed.\\n        int count = 0;\\n        \\n        // Iterate through each byte of the input string.\\n        for (byte i : s.getBytes()) {\\n            // Increment the corresponding frequency in \\'charFrequency\\' based on the character\\'s ASCII value.\\n            charFrequency[i - 97]++; \\n        }\\n        \\n        // Iterate through the frequencies of characters (assuming only lowercase English letters).\\n        for (int i = 0; i < 26; i++) {\\n            // Enter a loop while the current frequency has been seen and is not zero.\\n            while (hasSeen[charFrequency[i]] && charFrequency[i] != 0) { \\n                // Decrement the frequency in \\'charFrequency\\' to make it unique.\\n                charFrequency[i]--; \\n                // Increment the \\'count\\' as we are performing a deletion operation.\\n                count++;\\n            }\\n            // Mark the current frequency as seen in \\'hasSeen\\'.\\n            hasSeen[charFrequency[i]] = true; \\n        }\\n        \\n        // After processing all characters, return the total number of deletions needed.\\n        return count;\\n    }\\n}\\n\\n\\n```\n```\\n// Define a class named Solution.\\nclass Solution {\\npublic:\\n    // Define a method named minDeletions.\\n    int minDeletions(string s) {\\n        int deletionsCount = 0; // Initialize a variable to keep track of deletions.\\n        unordered_map<int, bool> frequencyMap; // Create a map to track seen frequencies.\\n        vector<int> charFrequencyCount(26, 0); // Create a vector to count character frequencies (assuming lowercase English letters).\\n        int n = s.size(); // Get the length of the input string.\\n\\n        // Iterate through the characters in the input string to count their frequencies.\\n        for (int i = 0; i < n; i++)\\n            charFrequencyCount[s[i] - \\'a\\']++;\\n\\n        // Iterate through the possible frequencies (assuming lowercase English letters).\\n        for (int i = 0; i < 26; i++) {\\n            int frequency = charFrequencyCount[i];\\n\\n            // If this frequency has been seen before in the map, make it unique.\\n            if (frequencyMap[frequency] == true) {\\n                while (frequencyMap[frequency] == true && frequency > 0) {\\n                    frequency--;\\n                    deletionsCount++;\\n                }\\n                if (frequency > 0)\\n                    frequencyMap[frequency] = true;\\n            }\\n            else\\n                frequencyMap[frequency] = true;\\n        }\\n\\n        // Return the total number of deletions needed to make frequencies unique.\\n        return deletionsCount;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207605,
                "title": "clean-java-code-with-step-by-step-explanation",
                "content": "**Step 1: Take all the characters and their count in a HashMap \\nStep 2: Now take a Hash Set to store the unique frequencies and initialize delete count to 0\\nStep 3: Now check if the frequency is present in the set . If not then simply add\\nStep 4: If it contains then take a loop and keep on decreasing the frequency & increasing the delete count by 1 until the value is not contained in the set and if the final value of frequency  is greater than 0 then add it in the set.**\\n\\n**Please Upvote if you find this useful.**\\n\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int count = 0;\\n        \\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        char ch[] = s.toCharArray();\\n        for(int i = 0; i<ch.length ; i++)\\n        {\\n            hm.put(ch[i],hm.getOrDefault(ch[i],0)+1);\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(char c: hm.keySet())\\n        {\\n            int freq = hm.get(c);\\n            if(!set.contains(freq))set.add(freq);\\n            else{\\n                while(freq> 0 && set.contains(freq))\\n                {\\n                    freq--;\\n                    count++;\\n                }\\n                if(freq>0)set.add(freq);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int minDeletions(String s) {\\n        int count = 0;\\n        \\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        char ch[] = s.toCharArray();\\n        for(int i = 0; i<ch.length ; i++)\\n        {\\n            hm.put(ch[i],hm.getOrDefault(ch[i],0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2207169,
                "title": "more-efficient-max-heap-solution-java-explained",
                "content": "### Logic:\\nIn this question, we need to completely get rid of the idea that we\\'re working with characters. From now on, we\\'ll be working with integers; primarily the frequencies of each character.\\n\\nWe\\'ll use the below example to help us walk through the process of finding the minimum number of deletions (Again, we\\'re just going to be working with the frequencies `3,3,2` since the characters they\\'re associated with aren\\'t important): \\n\\n![image](https://assets.leetcode.com/users/images/d99cba0f-3073-4e8a-a676-e0f653fa8303_1656378971.5318668.png)\\n\\n\\nWhat\\'s weird here is we can actually find the frequencies of each frequency. We can store this in a map as such (in other words, we have two 3\\'s, and one 2):\\n![image](https://assets.leetcode.com/users/images/8bdd28a0-5c63-4269-bef8-0fea40659b39_1656378999.9571304.png)\\n\\nWhy are we doing this? Well, this is where our <ins>max-heap</ins> comes in. Notice how if we had the example \"aab\", we need not perform any deletions. The same applies to \"aaabbc\". \\n\\n**A Key Observation:**\\n> If the highest-frequency letter is unique, we will never need to perform any operations on it. If this is true for the highest-frequency letter, it is also true for the second highest-frequency letter as long as it is also a unique frequency.\\n\\nFor example, the \"a\" in \"aaabbc\" is the highest-frequency letter and it\\'s completely unique so we don\\'t need to delete anything here. Next, we look at \"b\" and the same applies. Finally, we look at \"c\" and the same applies.\\n\\nIf we had instead \"aaabbb\", we see that the rule is broken and something needs to be done about this.\\n\\n___\\n### What do we do with letters that share the same frequency?\\nSo far we have two data structures: A map storing the frequency of our frequencies and a priority queue to act as our max-heap. Let\\'s follow the above example in the following process (`pq` is our priority queue):\\n\\n![image](https://assets.leetcode.com/users/images/a94f3aa6-4a17-4459-95b4-282bc69076e7_1656379378.0879953.png)\\n\\nNow we poll() the 3 off the priority queue. Let\\'s now process the frequency 2. Since we subtracted 1 from one of the 3\\'s, our number of deletion operations so far is 1.\\n![image](https://assets.leetcode.com/users/images/1c74e17a-edf1-45cb-a795-b2cccac07e2e_1656379029.372549.png)\\n\\nWe poll() from the priority queue again. Let\\'s now process the frequency 1 which was recently added to the `freqMap` and `pq`. The number of deletions so far is 2.\\n![image](https://assets.leetcode.com/users/images/99e03aef-4c6b-4504-9bf1-e3dafc2cc2e4_1656379048.3797462.png)\\n\\nOne final thing to keep in mind is that we need to make sure we don\\'t add any frequencies (or frequencies of frequencies) of 0 into `pq` or `freqMap`.\\n\\nThis was definitely one of the harder solutions for me to explain. While I hope that the diagrams answer most of your questions, please do comment if anything is confusing to you or needs more elaboration. \\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n```java\\npublic int minDeletions(String s) {\\n\\tint[] count = new int[26];\\n\\tfor (char c: s.toCharArray()) count[c - \\'a\\']++;\\n\\n\\tMap<Integer, Integer> freqsMap = new HashMap<>();\\n\\tfor (int n: count) if (n != 0) freqsMap.put(n, freqsMap.getOrDefault(n,0) + 1);\\n\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor (int key: freqsMap.keySet()) pq.add(key);\\n\\n\\tint deletions = 0;\\n\\twhile (!pq.isEmpty()) {\\n\\t\\tint val = pq.poll(), freq = freqsMap.get(val);\\n\\t\\tdeletions += freq - 1;\\n\\t\\tif (freq > 1 && val > 1) {\\n\\t\\t\\tif (!freqsMap.containsKey(val-1)) pq.add(val-1);\\n\\t\\t\\tfreqsMap.put(val-1, freqsMap.getOrDefault(val-1,0) + freq-1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn deletions;\\n}\\n```\\n**Time complexity:** `O(n + klogk)` where `k` represents the number of frequencies.\\n**Space complexity:** `O(k)` since each data structure is storing up to `k` different frequencies.",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\npublic int minDeletions(String s) {\\n\\tint[] count = new int[26];\\n\\tfor (char c: s.toCharArray()) count[c - \\'a\\']++;\\n\\n\\tMap<Integer, Integer> freqsMap = new HashMap<>();\\n\\tfor (int n: count) if (n != 0) freqsMap.put(n, freqsMap.getOrDefault(n,0) + 1);\\n\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor (int key: freqsMap.keySet()) pq.add(key);\\n\\n\\tint deletions = 0;\\n\\twhile (!pq.isEmpty()) {\\n\\t\\tint val = pq.poll(), freq = freqsMap.get(val);\\n\\t\\tdeletions += freq - 1;\\n\\t\\tif (freq > 1 && val > 1) {\\n\\t\\t\\tif (!freqsMap.containsKey(val-1)) pq.add(val-1);\\n\\t\\t\\tfreqsMap.put(val-1, freqsMap.getOrDefault(val-1,0) + freq-1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn deletions;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207108,
                "title": "c-detailed-and-easy-explaination-clean-code",
                "content": "\\u2B06\\uFE0F\\u2B06\\uFE0F ***Please Upvote if you like it***  \\u2B06\\uFE0F\\u2B06\\uFE0F\\n\\n\\n**Approach and Process:**\\n\\n\\n* We are **storing all the character frequency of the given string** by using an unordered map. \\n\\n* Now we have the frequency of all characters of the given string. So by just traversing the unordered map **we can easily check which characters\\' frequencies are actually repeating**. We have just taken another unordered map to check the frequencies are unique or not. ( We can even take a vector also for checking this, here we have taken an unordered map for better understanding)\\n\\n* Now **if a frequency is not unique** (like any other characters\\' frequency in the string is same as current frequency) , then we have to **check if its any lower frequency spot is available** **or not** i.e. we can delete some of that same characters from the string to get any lower frequency spot. If we can\\'t find any lower frequency spot then we have to make that frequency 0 i.e we have to delete all that particular characters to make the frequencies unique.\\n \\n* **Return the count of the total frequency reduction. Simple :)**\\n\\n\\n**Time Complexity - O(N)[For worst case O(N) + O(26*26)] , Space Complexity - O(1)**\\n\\n\\n**CLEAN CODE :**\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<int,int>charcnt;\\n        unordered_map<int,int>uniquefreq;\\n        int count=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            charcnt[s[i]-\\'a\\']++;\\n        }\\n        \\n        for(auto &it : charcnt)\\n        {\\n            int x= it.second;\\n            if(uniquefreq[x]!=0)\\n            {\\n                while(x>0 && uniquefreq[x]!=0)\\n                {\\n                    x--;\\n                    count++;\\n                }\\n            }\\n            if(x>0)\\n            {\\n                uniquefreq[x]++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<int,int>charcnt;\\n        unordered_map<int,int>uniquefreq;\\n        int count=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            charcnt[s[i]-\\'a\\']++;\\n        }\\n        \\n        for(auto &it : charcnt)\\n        {\\n            int x= it.second;\\n            if(uniquefreq[x]!=0)\\n            {\\n                while(x>0 && uniquefreq[x]!=0)\\n                {\\n                    x--;\\n                    count++;\\n                }\\n            }\\n            if(x>0)\\n            {\\n                uniquefreq[x]++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033452,
                "title": "python3-98-24-greedy-approach-easy-to-understand",
                "content": "# Python3 | 98.24% | Greedy Approach | Easy to Understand\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        for char, freq in cnt.items():\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        for char, freq in cnt.items():\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033221,
                "title": "98-85-priority-queue-sorting-greedy-explained-intuition-commented-code",
                "content": "# Problem Description\\nGiven a string `s`. A string is considered `good` if no two different characters in the string have the same frequency. **In other words**, all characters in the string must have **distinct frequencies**.\\n\\nThe task is to determine the **minimum** number of characters you need to **delete** from the string `s` in order to make it `good`.\\n\\n**The frequency** of a character in a string is defined as the number of times it appears in the string.\\nFor example, in the string `aab`, the frequency of `a` is `2`, and the frequency of `b` is `1`.\\n\\n---\\n\\n\\n\\n# Intuition\\n**The key** behind the solution of this problem is `existingFrequencies` set in all of our proposed approacehs. Let\\'s see why.\\n\\nLike the problem said we have an old string and we are building a new string from it with one condition that for all characters in the string each one of them has a **unique** frequency.\\n\\nHow does our `existingFrequencies` set help us in that?\\nWe can think of this set as a **reservation book** that have the reserved ferquencies for our new string such that if we are putting new char in the new string we **check** if its frequency reserved or not. if reserved then we must make some **deletions** until its frequency its not reservered or we delete it all.\\n\\nHow does that help us in each approach?\\nLike I said before, In each approach we have a **reservation book** to make us sure that the inserted character has a **distinct** frequency.\\n\\nThis GIF will explain how we use existingFrequencies set.\\n\\n![1.gif](https://assets.leetcode.com/users/images/d519f166-8373-4d5c-a328-f9945254cf45_1694484721.6650743.gif)\\n\\n\\n---\\n\\n\\n\\n# Approach\\n## 1. Priority Queue\\n### Steps\\n- **Create** an map `charFrequency` to store character frequencies.\\n- **Create** an set `existingFrequencies` to keep track of frequencies that already exist in the set.\\n- **Iterate** through each character `c` in the input string `s` and increment the frequency of character `c` in the **charFrequency** map.\\n- **Create** a Priority Queue `maxHeap` and push charFrequency map values onto the maxHeap .\\n- Initialize a variable `deletions`.\\n- Enter a loop that continues as long as the maxHeap is **not empty**:\\n    - Get the **top** (maximum) frequency `curFreq` from the maxHeap and     remove it from the heap.\\n    - If `curFreq` is already in the set, **decrement** it and **increment** the     `deletions` count. Repeat this step until `curFreq` is no longer in the     set.\\n    - Add the adjusted frequency `curFreq` to the `existingFrequencies` set.\\n- **Return** the `deletions` count as the result of the function, representing the minimum number of character deletions needed to make the string **good**.\\n\\n### Complexity\\n**- Time complexity:**$$O(Nlog(N))$$\\nSince the priority queue operations occur has time complexity `Nlog(N)`.where `N` is the number of alphabet which is `26`.\\n**- Space complexity:**$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince we are storing the frequencies in a map and in priority queue.\\n.where `N` is the number of alphabet which is `26`.\\n\\n\\n\\n---\\n\\n## 2. Sorting\\n\\n### Steps\\n- **Create** an array `charFrequency` to store character frequencies, initialized with zeros for each letter of the alphabet.\\n- **Create** an empty set `existingFrequencies` to keep track of existing frequencies.\\n- **Increment** the frequency of each character `c` in `s` in the `charFrequency` array using its alphabetical position.\\n- **Initialize** a variable `deletions` to zero.\\n- **Sort** the `charFrequency` array in descending order to prioritize characters with higher frequencies.\\n- **Iterate** through the sorted frequencies:\\n    - Get the current frequency `curFreq`.\\n    - While `curFreq` is greater than zero and already exists in    `existingFrequencies`, decrement `curFreq` and increment deletions.\\n    - Add the adjusted `frequency` curFreq to `existingFrequencies`.\\n- **Return** the `deletions` count as the result, representing the minimum number of character deletions needed to make the string **good**.\\n\\n### Complexity\\n**- Time complexity:**$$O(Nlog(N))$$\\nSince the sort operation has time complexity `Nlog(N)`.where `N` is the number of alphabet which is `26`.\\n**- Space complexity:**$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince we are storing the frequencies in a map and in priority queue.\\n.where `N` is the number of alphabet which is `26`.\\n\\n---\\n\\n## 2. Greedy\\n### Steps\\n- **Create** an array `charFrequency` to store character frequencies, initialized with zeros for each letter of the alphabet.\\n- **Create** an empty set `existingFrequencies` to keep track of existing frequencies.\\n- **Increment** the frequency of each character `c` in `s` in the `charFrequency` array using its alphabetical position.\\n- **Initialize** a variable `deletions` to zero.\\n- **Iterate** through the frequencies:\\n    - Get the current frequency `curFreq`.\\n    - While `curFreq` is greater than zero and already exists in    `existingFrequencies`, decrement `curFreq` and increment deletions.\\n    - Add the adjusted `frequency` curFreq to `existingFrequencies`.\\n- **Return** the `deletions` count as the result, representing the minimum number of character deletions needed to make the string **good**.\\n\\n### Complexity\\n**- Time complexity:**$$O(N)$$\\nwhere `N` is the number of alphabet which is `26`.\\n**- Space complexity:**$$O(N)$$\\nSince we are storing the frequencies in a map and in priority queue.\\n.where `N` is the number of alphabet which is `26`.\\n\\n\\n---\\n\\n\\n\\n# Code\\n## 1. Priority Queue\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create a map to store character frequencies\\n        unordered_map<char, int> charFrequency;\\n        \\n        // Create a set to keep track of existing frequencies\\n        unordered_set<int> existingFrequencies;\\n        \\n        // Count character frequencies\\n        for (char c : s) {\\n            charFrequency[c]++;\\n        }\\n\\n        // Create a max heap to store frequencies\\n        priority_queue<int> maxHeap;\\n\\n        // Push frequencies into the max heap\\n        for (auto freq : charFrequency) {\\n            maxHeap.push(freq.second);\\n        }\\n\\n        int deletions = 0;\\n        while (!maxHeap.empty()) {\\n            int curFreq = maxHeap.top();\\n            maxHeap.pop();\\n            \\n            // Adjust frequency if it already exists in the set\\n            while (curFreq > 0 && existingFrequencies.count(curFreq)) {\\n                curFreq--;\\n                deletions++;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.insert(curFreq);\\n        }\\n        return deletions;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        // Create a map to store character frequencies\\n        Map<Character, Integer> charFrequency = new HashMap<>();\\n        \\n        // Create a set to keep track of existing frequencies in new string\\n        Set<Integer> existingFrequencies = new HashSet<>();\\n        \\n        // Count character frequencies\\n        for (char c : s.toCharArray()) {\\n            charFrequency.put(c, charFrequency.getOrDefault(c, 0) + 1);\\n        }\\n\\n        // Create a max heap to store frequencies\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\\n\\n        // Push frequencies into the max heap\\n        for (int freq : charFrequency.values()) {\\n            maxHeap.offer(freq);\\n        }\\n\\n        int deletions = 0;\\n        while (!maxHeap.isEmpty()) {\\n            int curFreq = maxHeap.poll();\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while (curFreq > 0 && existingFrequencies.contains(curFreq)) {\\n                curFreq--;\\n                deletions++;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq);\\n        }\\n        return deletions;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        # Create a dictionary to store character frequencies\\n        charFrequency = collections.defaultdict(int)\\n        \\n        # Create a set to keep track of existing frequencies in new string\\n        existingFrequencies = set()\\n        \\n        # Count character frequencies\\n        for c in s:\\n            charFrequency[c] += 1\\n\\n        # Create a max heap to store frequencies\\n        maxHeap = []\\n\\n        # Push frequencies into the max heap\\n        for freq in charFrequency.values():\\n            heapq.heappush(maxHeap, -freq)  # Use negative values for max heap\\n\\n        deletions = 0\\n        while maxHeap:\\n            curFreq = -heapq.heappop(maxHeap)  # Use negative values for max heap\\n            \\n            # Adjust frequency if it already exists in the new string\\n            while curFreq > 0 and curFreq in existingFrequencies:\\n                curFreq -= 1\\n                deletions += 1\\n            \\n            # Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq)\\n        \\n        return deletions\\n```\\n\\n## 2. Sort\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create an array to store character frequencies (one for each letter of the alphabet)\\n        vector<int> charFrequency(26) ;\\n        \\n        // Create a set to keep track of existing frequencies in new string\\n        unordered_set<int> existingFrequencies;\\n        \\n        // Count character frequencies\\n        for (char c : s) {\\n            charFrequency[c - \\'a\\']++;\\n        }\\n        \\n        int deletions = 0 ;\\n\\n        // Sort character frequencies in descending order\\n        sort(charFrequency.rbegin(), charFrequency.rend()) ;\\n\\n        // Iterate through the sorted frequencies\\n        for(int i = 0 ; i < charFrequency.size() ; i ++){\\n            int curFreq = charFrequency[i] ;\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while(curFreq > 0 && existingFrequencies.find(curFreq) != existingFrequencies.end()){\\n                deletions ++ ;\\n                curFreq -- ;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.insert(curFreq) ;\\n        }\\n\\n        return deletions;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        // Create an array to store character frequencies (one for each letter of the alphabet)\\n        int[] charFrequency = new int[26];\\n        \\n        // Create a set to keep track of existing frequencies in the new string\\n        Set<Integer> existingFrequencies = new HashSet<>();\\n        \\n        // Count character frequencies\\n        for (char c : s.toCharArray()) {\\n            charFrequency[c - \\'a\\']++;\\n        }\\n        \\n        int deletions = 0 ;\\n\\n        // Sort character frequencies in descending order\\n        Arrays.sort(charFrequency);\\n\\n        // Iterate through the sorted frequencies in reverse order\\n        for(int i = charFrequency.length - 1; i >= 0 ; i --){\\n            int curFreq = charFrequency[i] ;\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while(curFreq > 0 && existingFrequencies.contains(curFreq)){\\n                deletions ++ ;\\n                curFreq -- ;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq) ;\\n        }\\n\\n        return deletions;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        # Create an array to store character frequencies (one for each letter of the alphabet)\\n        charFrequency = [0] * 26\\n        \\n        # Create a set to keep track of existing frequencies in the new string\\n        existingFrequencies = set()\\n        \\n        # Count character frequencies\\n        for c in s:\\n            charFrequency[ord(c) - ord(\\'a\\')] += 1\\n        \\n        deletions = 0\\n\\n        # Sort character frequencies in descending order\\n        charFrequency.sort(reverse=True)\\n\\n        # Iterate through the sorted frequencies\\n        for i in range(len(charFrequency)):\\n            curFreq = charFrequency[i]\\n            \\n            # Adjust frequency if it already exists in the new string\\n            while curFreq > 0 and curFreq in existingFrequencies:\\n                deletions += 1\\n                curFreq -= 1\\n            \\n            # Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq)\\n\\n        return deletions\\n```\\n\\n## 3. Greedy\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create an array to store character frequencies (one for each letter of the alphabet)\\n        vector<int> charFrequency(26) ;\\n        \\n        // Create a set to keep track of existing frequencies in new string\\n        unordered_set<int> existingFrequencies;\\n        \\n        // Count character frequencies\\n        for (char c : s) {\\n            charFrequency[c - \\'a\\']++;\\n        }\\n        \\n        int deletions = 0 ;\\n        // Iterate through the sorted frequencies\\n        for(int i = 0 ; i < charFrequency.size() ; i ++){\\n            int curFreq = charFrequency[i] ;\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while(curFreq > 0 && existingFrequencies.find(curFreq) != existingFrequencies.end()){\\n                deletions ++ ;\\n                curFreq -- ;\\n            }\\n            // Add the adjusted frequency to the set\\n            existingFrequencies.insert(curFreq) ;\\n        }\\n\\n        return deletions;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        // Create an array to store character frequencies (one for each letter of the alphabet)\\n        int[] charFrequency = new int[26];\\n        \\n        // Create a set to keep track of existing frequencies in the new string\\n        Set<Integer> existingFrequencies = new HashSet<>();\\n        \\n        // Count character frequencies\\n        for (char c : s.toCharArray()) {\\n            charFrequency[c - \\'a\\']++;\\n        }\\n        \\n        int deletions = 0 ;\\n\\n        // Iterate through the sorted frequencies in reverse order\\n        for(int i = 0; i < charFrequency.length ; i ++){\\n            int curFreq = charFrequency[i] ;\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while(curFreq > 0 && existingFrequencies.contains(curFreq)){\\n                deletions ++ ;\\n                curFreq -- ;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq) ;\\n        }\\n\\n        return deletions;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        # Create an array to store character frequencies (one for each letter of the alphabet)\\n        charFrequency = [0] * 26\\n        \\n        # Create a set to keep track of existing frequencies in the new string\\n        existingFrequencies = set()\\n        \\n        # Count character frequencies\\n        for c in s:\\n            charFrequency[ord(c) - ord(\\'a\\')] += 1\\n        \\n        deletions = 0\\n        # Iterate through the sorted frequencies\\n        for i in range(len(charFrequency)):\\n            curFreq = charFrequency[i]\\n            \\n            # Adjust frequency if it already exists in the new string\\n            while curFreq > 0 and curFreq in existingFrequencies:\\n                deletions += 1\\n                curFreq -= 1\\n            \\n            # Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq)\\n\\n        return deletions\\n```\\n\\n\\n\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/7145df63-b6ec-4632-bf96-3b74c993b048_1694478347.0898125.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create a map to store character frequencies\\n        unordered_map<char, int> charFrequency;\\n        \\n        // Create a set to keep track of existing frequencies\\n        unordered_set<int> existingFrequencies;\\n        \\n        // Count character frequencies\\n        for (char c : s) {\\n            charFrequency[c]++;\\n        }\\n\\n        // Create a max heap to store frequencies\\n        priority_queue<int> maxHeap;\\n\\n        // Push frequencies into the max heap\\n        for (auto freq : charFrequency) {\\n            maxHeap.push(freq.second);\\n        }\\n\\n        int deletions = 0;\\n        while (!maxHeap.empty()) {\\n            int curFreq = maxHeap.top();\\n            maxHeap.pop();\\n            \\n            // Adjust frequency if it already exists in the set\\n            while (curFreq > 0 && existingFrequencies.count(curFreq)) {\\n                curFreq--;\\n                deletions++;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.insert(curFreq);\\n        }\\n        return deletions;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        // Create a map to store character frequencies\\n        Map<Character, Integer> charFrequency = new HashMap<>();\\n        \\n        // Create a set to keep track of existing frequencies in new string\\n        Set<Integer> existingFrequencies = new HashSet<>();\\n        \\n        // Count character frequencies\\n        for (char c : s.toCharArray()) {\\n            charFrequency.put(c, charFrequency.getOrDefault(c, 0) + 1);\\n        }\\n\\n        // Create a max heap to store frequencies\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\\n\\n        // Push frequencies into the max heap\\n        for (int freq : charFrequency.values()) {\\n            maxHeap.offer(freq);\\n        }\\n\\n        int deletions = 0;\\n        while (!maxHeap.isEmpty()) {\\n            int curFreq = maxHeap.poll();\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while (curFreq > 0 && existingFrequencies.contains(curFreq)) {\\n                curFreq--;\\n                deletions++;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq);\\n        }\\n        return deletions;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        # Create a dictionary to store character frequencies\\n        charFrequency = collections.defaultdict(int)\\n        \\n        # Create a set to keep track of existing frequencies in new string\\n        existingFrequencies = set()\\n        \\n        # Count character frequencies\\n        for c in s:\\n            charFrequency[c] += 1\\n\\n        # Create a max heap to store frequencies\\n        maxHeap = []\\n\\n        # Push frequencies into the max heap\\n        for freq in charFrequency.values():\\n            heapq.heappush(maxHeap, -freq)  # Use negative values for max heap\\n\\n        deletions = 0\\n        while maxHeap:\\n            curFreq = -heapq.heappop(maxHeap)  # Use negative values for max heap\\n            \\n            # Adjust frequency if it already exists in the new string\\n            while curFreq > 0 and curFreq in existingFrequencies:\\n                curFreq -= 1\\n                deletions += 1\\n            \\n            # Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq)\\n        \\n        return deletions\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create an array to store character frequencies (one for each letter of the alphabet)\\n        vector<int> charFrequency(26) ;\\n        \\n        // Create a set to keep track of existing frequencies in new string\\n        unordered_set<int> existingFrequencies;\\n        \\n        // Count character frequencies\\n        for (char c : s) {\\n            charFrequency[c - \\'a\\']++;\\n        }\\n        \\n        int deletions = 0 ;\\n\\n        // Sort character frequencies in descending order\\n        sort(charFrequency.rbegin(), charFrequency.rend()) ;\\n\\n        // Iterate through the sorted frequencies\\n        for(int i = 0 ; i < charFrequency.size() ; i ++){\\n            int curFreq = charFrequency[i] ;\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while(curFreq > 0 && existingFrequencies.find(curFreq) != existingFrequencies.end()){\\n                deletions ++ ;\\n                curFreq -- ;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.insert(curFreq) ;\\n        }\\n\\n        return deletions;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        // Create an array to store character frequencies (one for each letter of the alphabet)\\n        int[] charFrequency = new int[26];\\n        \\n        // Create a set to keep track of existing frequencies in the new string\\n        Set<Integer> existingFrequencies = new HashSet<>();\\n        \\n        // Count character frequencies\\n        for (char c : s.toCharArray()) {\\n            charFrequency[c - \\'a\\']++;\\n        }\\n        \\n        int deletions = 0 ;\\n\\n        // Sort character frequencies in descending order\\n        Arrays.sort(charFrequency);\\n\\n        // Iterate through the sorted frequencies in reverse order\\n        for(int i = charFrequency.length - 1; i >= 0 ; i --){\\n            int curFreq = charFrequency[i] ;\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while(curFreq > 0 && existingFrequencies.contains(curFreq)){\\n                deletions ++ ;\\n                curFreq -- ;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq) ;\\n        }\\n\\n        return deletions;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        # Create an array to store character frequencies (one for each letter of the alphabet)\\n        charFrequency = [0] * 26\\n        \\n        # Create a set to keep track of existing frequencies in the new string\\n        existingFrequencies = set()\\n        \\n        # Count character frequencies\\n        for c in s:\\n            charFrequency[ord(c) - ord(\\'a\\')] += 1\\n        \\n        deletions = 0\\n\\n        # Sort character frequencies in descending order\\n        charFrequency.sort(reverse=True)\\n\\n        # Iterate through the sorted frequencies\\n        for i in range(len(charFrequency)):\\n            curFreq = charFrequency[i]\\n            \\n            # Adjust frequency if it already exists in the new string\\n            while curFreq > 0 and curFreq in existingFrequencies:\\n                deletions += 1\\n                curFreq -= 1\\n            \\n            # Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq)\\n\\n        return deletions\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create an array to store character frequencies (one for each letter of the alphabet)\\n        vector<int> charFrequency(26) ;\\n        \\n        // Create a set to keep track of existing frequencies in new string\\n        unordered_set<int> existingFrequencies;\\n        \\n        // Count character frequencies\\n        for (char c : s) {\\n            charFrequency[c - \\'a\\']++;\\n        }\\n        \\n        int deletions = 0 ;\\n        // Iterate through the sorted frequencies\\n        for(int i = 0 ; i < charFrequency.size() ; i ++){\\n            int curFreq = charFrequency[i] ;\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while(curFreq > 0 && existingFrequencies.find(curFreq) != existingFrequencies.end()){\\n                deletions ++ ;\\n                curFreq -- ;\\n            }\\n            // Add the adjusted frequency to the set\\n            existingFrequencies.insert(curFreq) ;\\n        }\\n\\n        return deletions;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        // Create an array to store character frequencies (one for each letter of the alphabet)\\n        int[] charFrequency = new int[26];\\n        \\n        // Create a set to keep track of existing frequencies in the new string\\n        Set<Integer> existingFrequencies = new HashSet<>();\\n        \\n        // Count character frequencies\\n        for (char c : s.toCharArray()) {\\n            charFrequency[c - \\'a\\']++;\\n        }\\n        \\n        int deletions = 0 ;\\n\\n        // Iterate through the sorted frequencies in reverse order\\n        for(int i = 0; i < charFrequency.length ; i ++){\\n            int curFreq = charFrequency[i] ;\\n            \\n            // Adjust frequency if it already exists in the new string\\n            while(curFreq > 0 && existingFrequencies.contains(curFreq)){\\n                deletions ++ ;\\n                curFreq -- ;\\n            }\\n            \\n            // Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq) ;\\n        }\\n\\n        return deletions;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        # Create an array to store character frequencies (one for each letter of the alphabet)\\n        charFrequency = [0] * 26\\n        \\n        # Create a set to keep track of existing frequencies in the new string\\n        existingFrequencies = set()\\n        \\n        # Count character frequencies\\n        for c in s:\\n            charFrequency[ord(c) - ord(\\'a\\')] += 1\\n        \\n        deletions = 0\\n        # Iterate through the sorted frequencies\\n        for i in range(len(charFrequency)):\\n            curFreq = charFrequency[i]\\n            \\n            # Adjust frequency if it already exists in the new string\\n            while curFreq > 0 and curFreq in existingFrequencies:\\n                deletions += 1\\n                curFreq -= 1\\n            \\n            # Add the adjusted frequency to the set\\n            existingFrequencies.add(curFreq)\\n\\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033444,
                "title": "c-greedy-98-04-fast-easy-to-understand",
                "content": "# C++ | Greedy | 98.04% | Fast | Easy to Understand\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(std::string s) {\\n        std::unordered_map<char, int> cnt;\\n        int deletions = 0;\\n        std::unordered_set<int> used_frequencies;\\n        \\n        for (char c : s) {\\n            cnt[c]++;\\n        }\\n        \\n        for (auto& kv : cnt) {\\n            int freq = kv.second;\\n            while (freq > 0 && used_frequencies.find(freq) != used_frequencies.end()) {\\n                freq--;\\n                deletions++;\\n            }\\n            used_frequencies.insert(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(std::string s) {\\n        std::unordered_map<char, int> cnt;\\n        int deletions = 0;\\n        std::unordered_set<int> used_frequencies;\\n        \\n        for (char c : s) {\\n            cnt[c]++;\\n        }\\n        \\n        for (auto& kv : cnt) {\\n            int freq = kv.second;\\n            while (freq > 0 && used_frequencies.find(freq) != used_frequencies.end()) {\\n                freq--;\\n                deletions++;\\n            }\\n            used_frequencies.insert(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927530,
                "title": "easy-to-understand-greedy-solution",
                "content": "To solve this problem, we first need to **count the occurence** of each character in the given string.\\nNext we use a **set to de-duplicate**:\\n\\twe will continue to remove once if there is a duplicate occurence, until 0. We **do need to add the new occurence to the set if it is not 0**.\\nFinally, we return the total removal times, that is it!\\n```\\n    public int minDeletions(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i=0; i<s.length(); i++) {\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0)  + 1);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        int res = 0;\\n        for (char c : map.keySet()) {\\n            int t = map.get(c);\\n            while (set.contains(t)) {\\n                t--;\\n                res++;\\n            }\\n            if (t != 0) {\\n                set.add(t);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minDeletions(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i=0; i<s.length(); i++) {\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0)  + 1);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        int res = 0;\\n        for (char c : map.keySet()) {\\n            int t = map.get(c);\\n            while (set.contains(t)) {\\n                t--;\\n                res++;\\n            }\\n            if (t != 0) {\\n                set.add(t);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033990,
                "title": "easy-solution-with-explanation-and-visualization-99-87",
                "content": "\\n# Approach\\nWe need to find the number of ```deletion operations``` to make the frequencies unique. So let\\'s first divide the problem into sub problem-\\n- ```Subproblem 1``` - We need to find ```frequencies``` of all characters and store them in a map. We do this by creating a map ```charFreq``` and iterating over the ```string s``` and incrementing its count in ```charFreq```.\\n- ```Subproblem 2``` - We need to check ```if any of the frequency is repeating```. To check this we will create a set and ```add a frequency which is not already present```.\\n- ```Subproblem 3``` - What to do if frequency is already present? Now, we need to perform the ```delete``` operations so that the character\\'s frequency is not equal to any of the frequencies already present in freqSet.\\n\\nThe ```main crux``` of the problem lies in ```Subproblem 3```, we solve it by running a while loop which will decrease the frequency of a character till its frequency is unique and at the same time increment the ```count``` which stores the ```number of delete operations```.\\n\\nIf the frequency after decrementing is greater than 0 i.e ```p.second > 0 ```, we ```insert p.second``` into our ```freqSet```, we don\\'t insert 0 because if some character gets its frequency reduced to 0, i.e the character is no longer present, still 0 is present in set so our while loop will reduce its frequency to ```-1``` which is not possible.\\n\\nAt last ```return count```.\\n\\n# I\\'ve solved the second test case for a better understanding below!\\n![image.png](https://assets.leetcode.com/users/images/8d35eaa9-fbd9-4ed8-a68d-bee917550f36_1694497030.9481966.png)\\n\\n\\n# Upvote if you liked the explanation\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int n = s.length();\\n\\n        unordered_map<char, int> charFreq;\\n        for(int i = 0; i < n; i++){\\n            charFreq[s[i]]++;\\n        }\\n\\n        unordered_set<int> freqSet;\\n        int count = 0;\\n        for(auto& p : charFreq){\\n            if(freqSet.find(p.second) == freqSet.end()){\\n                freqSet.insert(p.second);\\n            }else{\\n                while(freqSet.find(p.second) != freqSet.end()){\\n                    count++;\\n                    p.second--;\\n                }\\n                if(p.second > 0){\\n                    freqSet.insert(p.second);\\n                }\\n                \\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\npublic class Solution {\\n    public int minDeletions(String s) {\\n        HashMap<Character, Integer> mp = new HashMap<>();\\n        int deletions = 0;\\n        HashSet<Integer> mySet = new HashSet<>();\\n        \\n        for (char c : s.toCharArray()) {\\n            mp.put(c, cnt.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        for (int freq : mp.values()) {\\n            while (freq > 0 && mySet.contains(freq)) {\\n                freq--;\\n                deletions++;\\n            }\\n            mySet.add(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n}\\n```\\n\\n# Python Code\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        for char, freq in cnt.items():\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```deletion operations```\n```Subproblem 1```\n```frequencies```\n```charFreq```\n```string s```\n```charFreq```\n```Subproblem 2```\n```if any of the frequency is repeating```\n```add a frequency which is not already present```\n```Subproblem 3```\n```delete```\n```main crux```\n```Subproblem 3```\n```count```\n```number of delete operations```\n```p.second > 0 ```\n```insert p.second```\n```freqSet```\n```-1```\n```return count```\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int n = s.length();\\n\\n        unordered_map<char, int> charFreq;\\n        for(int i = 0; i < n; i++){\\n            charFreq[s[i]]++;\\n        }\\n\\n        unordered_set<int> freqSet;\\n        int count = 0;\\n        for(auto& p : charFreq){\\n            if(freqSet.find(p.second) == freqSet.end()){\\n                freqSet.insert(p.second);\\n            }else{\\n                while(freqSet.find(p.second) != freqSet.end()){\\n                    count++;\\n                    p.second--;\\n                }\\n                if(p.second > 0){\\n                    freqSet.insert(p.second);\\n                }\\n                \\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int minDeletions(String s) {\\n        HashMap<Character, Integer> mp = new HashMap<>();\\n        int deletions = 0;\\n        HashSet<Integer> mySet = new HashSet<>();\\n        \\n        for (char c : s.toCharArray()) {\\n            mp.put(c, cnt.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        for (int freq : mp.values()) {\\n            while (freq > 0 && mySet.contains(freq)) {\\n                freq--;\\n                deletions++;\\n            }\\n            mySet.add(freq);\\n        }\\n        \\n        return deletions;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = Counter(s)\\n        deletions = 0\\n        used_frequencies = set()\\n        \\n        for char, freq in cnt.items():\\n            while freq > 0 and freq in used_frequencies:\\n                freq -= 1\\n                deletions += 1\\n            used_frequencies.add(freq)\\n            \\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208095,
                "title": "c-detailed-explaination-beats-100-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> vec(26); // create a vector of size 26 to store frequencies of char elements\\n        \\n        for(auto element : s){ \\n            vec[element - \\'a\\']++; // traverse the entire string s and increment freq of each char element\\n        }\\n        \\n        // sort the frequencies in descending order to get largest freq in 0th index\\n        sort(vec.begin(),vec.end(), greater<int>());\\n        \\n        // keep max_allowed_freq with largest frequency\\n        int max_allowed_freq = vec[0];\\n        int ans=0;\\n        \\n        for(auto freq : vec) {\\n            if(freq > max_allowed_freq) // if this freq is greater than max_allowed_freq\\n            {\\n                if(max_allowed_freq>0)\\n                    ans+=(freq-max_allowed_freq); // lower down the frequency of current element to freq\\n                else\\n                    ans+=freq; //if it is smaller than or equal to zero we have to delete\\n            }\\n            max_allowed_freq=min(max_allowed_freq-1,freq-1); //reducing max_allowed_freq\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTC -> O(nlogn) -> O(26*log26) -> O(26) -> O(n)\\nSC -> O(n)\\nhere n is the size of vector i.e 26",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> vec(26); // create a vector of size 26 to store frequencies of char elements\\n        \\n        for(auto element : s){ \\n            vec[element - \\'a\\']++; // traverse the entire string s and increment freq of each char element\\n        }\\n        \\n        // sort the frequencies in descending order to get largest freq in 0th index\\n        sort(vec.begin(),vec.end(), greater<int>());\\n        \\n        // keep max_allowed_freq with largest frequency\\n        int max_allowed_freq = vec[0];\\n        int ans=0;\\n        \\n        for(auto freq : vec) {\\n            if(freq > max_allowed_freq) // if this freq is greater than max_allowed_freq\\n            {\\n                if(max_allowed_freq>0)\\n                    ans+=(freq-max_allowed_freq); // lower down the frequency of current element to freq\\n                else\\n                    ans+=freq; //if it is smaller than or equal to zero we have to delete\\n            }\\n            max_allowed_freq=min(max_allowed_freq-1,freq-1); //reducing max_allowed_freq\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207148,
                "title": "c-beginner-friendly-solution-with-comments",
                "content": "Upvote if you find it useful\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n       int n=s.size();\\n        unordered_map<char,int>mp;\\n        // insert all elements in map\\n        for(int i=0;i<n;i++)\\n            mp[s[i]]++;\\n        \\n          int ans=0;\\n        // set to have count of frequencies of each element , we can also use map or vector\\n          set<int>st;\\n          for (auto[i,j] :mp)\\n        {\\n           while(st.find(j)!=st.end())     //   if we\\'ve seen the count of char  before, decrement it until we haven\\'t\\n            {\\n                 j--;\\n                 ans++;\\n            }\\n        // if this frequency has not been encountered before we will insert it in set \\n               if(j>0)\\n                st.insert(j); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n       int n=s.size();\\n        unordered_map<char,int>mp;\\n        // insert all elements in map\\n        for(int i=0;i<n;i++)\\n            mp[s[i]]++;\\n        \\n          int ans=0;\\n        // set to have count of frequencies of each element , we can also use map or vector\\n          set<int>st;\\n          for (auto[i,j] :mp)\\n        {\\n           while(st.find(j)!=st.end())     //   if we\\'ve seen the count of char  before, decrement it until we haven\\'t\\n            {\\n                 j--;\\n                 ans++;\\n            }\\n        // if this frequency has not been encountered before we will insert it in set \\n               if(j>0)\\n                st.insert(j); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957534,
                "title": "super-easy-java",
                "content": "1. Count the frequency of all the letters.\\n2. Go through all the frequencies, and add them to a set.  If a number already exists in a set, it will return false if you try to add it.  If it does return false decrease its frequency, and try and add it again.  Repeat this until it gets added, and then move on to the next number.\\n3. Everytime you remove an item increase the count.\\n\\n```\\n    public int minDeletions(String s) {\\n        int count = 0;\\n        int[] letterCounts = new int[26];\\n        \\n        for(char c : s.toCharArray()){ \\n            letterCounts[c-\\'a\\']++;\\n        }\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        for(int c : letterCounts){\\n            while(c != 0 && !set.add(c--)){\\n                count++;\\n            }\\n        }  \\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "1. Count the frequency of all the letters.\\n2. Go through all the frequencies, and add them to a set.  If a number already exists in a set, it will return false if you try to add it.  If it does return false decrease its frequency, and try and add it again.  Repeat this until it gets added, and then move on to the next number.\\n3. Everytime you remove an item increase the count.\\n\\n```\\n    public int minDeletions(String s) {\\n        int count = 0;\\n        int[] letterCounts = new int[26];\\n        \\n        for(char c : s.toCharArray()){ \\n            letterCounts[c-\\'a\\']++;\\n        }\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        for(int c : letterCounts){\\n            while(c != 0 && !set.add(c--)){\\n                count++;\\n            }\\n        }  \\n        \\n        return count;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 932768,
                "title": "simple-javascript-o-26-space-o-n-time-no-hashset",
                "content": "Remember that sorting and looping through O(26) size array is O(1). Also O(26) space is constant space. i.e O(1)\\n```\\nvar minDeletions = function(s) {\\n    let arr = Array(26).fill(0)\\n    let res = 0\\n    \\n    for(let i=0;i<s.length; i++){\\n        let index = s[i].charCodeAt(0) - \\'a\\'.charCodeAt(0)\\n        arr[index]++\\n    }\\n    \\n    arr.sort((a,b)=>b-a)\\n    \\n    for(let i=1; i<26; i++){\\n        while(arr[i] && arr[i] >= arr[i-1]){\\n            arr[i]--\\n            res++\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minDeletions = function(s) {\\n    let arr = Array(26).fill(0)\\n    let res = 0\\n    \\n    for(let i=0;i<s.length; i++){\\n        let index = s[i].charCodeAt(0) - \\'a\\'.charCodeAt(0)\\n        arr[index]++\\n    }\\n    \\n    arr.sort((a,b)=>b-a)\\n    \\n    for(let i=1; i<26; i++){\\n        while(arr[i] && arr[i] >= arr[i-1]){\\n            arr[i]--\\n            res++\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 928137,
                "title": "python-best-simple-solution",
                "content": "Runtime: 92 ms, faster than 100.00% of Python3 online submissions for Minimum Deletions to Make Character Frequencies Unique.\\nMemory Usage: 14.9 MB, less than 100.00% of Python3 online submissions for Minimum Deletions to Make Character Frequencies Unique.\\n\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        ans=0 \\n        d={}\\n        for i in set(s):\\n            d[i]=s.count(i) \\n        helper=set()\\n        for i in sorted(d.values(),reverse=True):\\n            while i in helper:\\n                i-=1 \\n                ans+=1 \\n            if i:\\n                helper.add(i)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        ans=0 \\n        d={}\\n        for i in set(s):\\n            d[i]=s.count(i) \\n        helper=set()\\n        for i in sorted(d.values(),reverse=True):\\n            while i in helper:\\n                i-=1 \\n                ans+=1 \\n            if i:\\n                helper.add(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207824,
                "title": "java-set-with-comments",
                "content": "If you understood the solution then please do a upvote, so I can see if my answer is helping someone!\\n```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        \\n\\t\\t//to store frequencies of each element\\n\\t\\t// it is given in constraints that we\\'ll have only lowercase alphabets hence took size = 26\\n        int[] freq = new int[26];\\n        \\n\\t\\t//counting frequency of each letter\\n        for(int i=0; i<s.length(); i++){\\n            int index = s.charAt(i) - \\'a\\';\\n            freq[index]++;\\n        }\\n        \\n\\t\\t// using hashset because we want unique elements only in our answer\\n\\t\\t// you may use hashmap\\n        Set<Integer> set = new HashSet<>();\\n        int ans = 0; //if there are nothing to delete then our ans will be 0\\n        \\n        for(int i=0; i<26; i++){\\n\\t\\t//if we have freq as 0 then we can not decrease its freq further\\n\\t\\t//if we can not add the freqenecy means we\\'re having duplicate frequence hence decrease the frequency by 1;\\n\\t\\t//it means that we\\'ve performed one deletion and hence increase the ans by 1\\n            while(freq[i] != 0  && !set.add(freq[i])){\\n                --freq[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        \\n\\t\\t//to store frequencies of each element\\n\\t\\t// it is given in constraints that we\\'ll have only lowercase alphabets hence took size = 26\\n        int[] freq = new int[26];\\n        \\n\\t\\t//counting frequency of each letter\\n        for(int i=0; i<s.length(); i++){\\n            int index = s.charAt(i) - \\'a\\';\\n            freq[index]++;\\n        }\\n        \\n\\t\\t// using hashset because we want unique elements only in our answer\\n\\t\\t// you may use hashmap\\n        Set<Integer> set = new HashSet<>();\\n        int ans = 0; //if there are nothing to delete then our ans will be 0\\n        \\n        for(int i=0; i<26; i++){\\n\\t\\t//if we have freq as 0 then we can not decrease its freq further\\n\\t\\t//if we can not add the freqenecy means we\\'re having duplicate frequence hence decrease the frequency by 1;\\n\\t\\t//it means that we\\'ve performed one deletion and hence increase the ans by 1\\n            while(freq[i] != 0  && !set.add(freq[i])){\\n                --freq[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927513,
                "title": "java-set-solution",
                "content": "```java\\nclass Solution {\\n    private int N = 26;\\n    public int minDeletions(String s) {\\n        int[] array = new int[N];\\n        for (char ch : s.toCharArray()) {\\n            array[ch - \\'a\\']++;\\n        }\\n        int ans = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : array) {\\n            if (i == 0) continue;\\n            while (set.contains(i)) {\\n                i--;\\n                ans++;\\n            }\\n            if (i != 0) {\\n                set.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    private int N = 26;\\n    public int minDeletions(String s) {\\n        int[] array = new int[N];\\n        for (char ch : s.toCharArray()) {\\n            array[ch - \\'a\\']++;\\n        }\\n        int ans = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : array) {\\n            if (i == 0) continue;\\n            while (set.contains(i)) {\\n                i--;\\n                ans++;\\n            }\\n            if (i != 0) {\\n                set.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207501,
                "title": "c-similar-2-approach-brute-force-map-of-freq",
                "content": "All of the points are covered ;\\nPLEASE READ whole code with comments and enjoy !!\\n**BUT I guess NO need of map;Please clarify**\\n# APPROACH1\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) \\n    {\\n        unordered_map<char,int> m;                                // map to store freq\\n        for(auto e:s)\\n        {\\n            m[e]++;\\n        }\\n        vector<int> v;                                                                  // same store in vector\\n        for(auto e:m)\\n        {\\n            v.push_back(e.second);\\n        }\\n        sort(v.begin(),v.end());                                                   // sort to figure out same element (freq)print vector\\n        int count=0;                                                                       // maintain  count for no. of operation\\n        bool check=1,maincheck=1;                    // maincheck check the condition that while loop or not (not means all freq are different)\\n        while(maincheck)\\n        {\\n            for(int i=1;i<v.size();i++)\\n            {\\n                if(v[i]==v[i-1] && v[i]!=0 && v[i-1]!=0 )                              // check for equal freq  but not equal to 0,0\\n                {\\n                    count++;                                                                      // increment count need to delete\\n                    v[i-1]--;                                                                        // decrement freq for that element\\n                }\\n            }\\n            sort(v.begin(),v.end());                                                           // try to sort if v is unsorted but i guess no need \\n//             for(auto e:v)\\n//         {\\n//             cout<<e<<\" \";                                                                 // print vector just for what happen inside\\n//         }\\n//         cout<<endl;\\n            check=0;                                                                        // temp check for same freq\\n            for(int i=1;i<v.size();i++)\\n            {\\n                if(v[i]==v[i-1] && v[i]!=0 && v[i-1]!=0 )\\n                {\\n                    check=1;                                                                 // if yes then one more time while loop have to run\\n                    break;                                                                       // break out from that point it have to delete \\n                }\\n            }\\n            if(check)\\n            {\\n                maincheck=1;                                                        // maincheck must =1 to run while loop again and skip and go for run while loop\\n                continue;\\n            }\\n            maincheck=0;                                                             // if check=0 means no freq equal or ( all different)\\n        }\\n        return count;                                                                   // just return count\\n    }\\n};\\n```\\n**Discussion :**\\nNow that where i have added 0,0 condition :\\nYour input\\n\"bbcebab\"\\nstdout\\n1 1 1 4 \\n0 0 1 4 \\n\\nOutput\\n2\\nExpected\\n2\\nif not added it will go further more time and v is \\n1 1 1 4 \\n0 0 1 4 \\n-1 0 1 4\\nand count =3 \\nWA \\nto avoid this condition  use ( && v[i]!=0 && v[i-1]!=0)\\nI have covered all points that are needed and try to taught everything \\nPLEASE UPVOTE\\n\\n\\nSIMPLER VERSION using two map\\nmap of frequency and it should be 1frequnced map in final\\n# APPROACH2\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) \\n    {\\n        unordered_map<char,int>m;\\n        unordered_map<int,int> mp;\\n        for(auto e:s)\\n        {\\n            m[e]++;\\n        }\\n        for(auto e:m)\\n        {\\n            mp[e.second]++;\\n        }\\n        int cnt=0;\\n        while(true)\\n        {\\n            bool check=1;\\n            for(auto e:mp)\\n            {\\n                \\n                if(e.second>1)\\n                {\\n                    check=0;\\n                    break;\\n                }\\n            }\\n            if(check) return cnt;\\n            for(auto &e:mp)\\n            {\\n                \\n                if(e.second>1)\\n                {\\n                    int temp=e.second-1;\\n                    cnt+=temp;\\n                    e.second=1;\\n                    if(e.first!=1)\\n                    {\\n                        mp[e.first-1]+=temp;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) \\n    {\\n        unordered_map<char,int> m;                                // map to store freq\\n        for(auto e:s)\\n        {\\n            m[e]++;\\n        }\\n        vector<int> v;                                                                  // same store in vector\\n        for(auto e:m)\\n        {\\n            v.push_back(e.second);\\n        }\\n        sort(v.begin(),v.end());                                                   // sort to figure out same element (freq)print vector\\n        int count=0;                                                                       // maintain  count for no. of operation\\n        bool check=1,maincheck=1;                    // maincheck check the condition that while loop or not (not means all freq are different)\\n        while(maincheck)\\n        {\\n            for(int i=1;i<v.size();i++)\\n            {\\n                if(v[i]==v[i-1] && v[i]!=0 && v[i-1]!=0 )                              // check for equal freq  but not equal to 0,0\\n                {\\n                    count++;                                                                      // increment count need to delete\\n                    v[i-1]--;                                                                        // decrement freq for that element\\n                }\\n            }\\n            sort(v.begin(),v.end());                                                           // try to sort if v is unsorted but i guess no need \\n//             for(auto e:v)\\n//         {\\n//             cout<<e<<\" \";                                                                 // print vector just for what happen inside\\n//         }\\n//         cout<<endl;\\n            check=0;                                                                        // temp check for same freq\\n            for(int i=1;i<v.size();i++)\\n            {\\n                if(v[i]==v[i-1] && v[i]!=0 && v[i-1]!=0 )\\n                {\\n                    check=1;                                                                 // if yes then one more time while loop have to run\\n                    break;                                                                       // break out from that point it have to delete \\n                }\\n            }\\n            if(check)\\n            {\\n                maincheck=1;                                                        // maincheck must =1 to run while loop again and skip and go for run while loop\\n                continue;\\n            }\\n            maincheck=0;                                                             // if check=0 means no freq equal or ( all different)\\n        }\\n        return count;                                                                   // just return count\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) \\n    {\\n        unordered_map<char,int>m;\\n        unordered_map<int,int> mp;\\n        for(auto e:s)\\n        {\\n            m[e]++;\\n        }\\n        for(auto e:m)\\n        {\\n            mp[e.second]++;\\n        }\\n        int cnt=0;\\n        while(true)\\n        {\\n            bool check=1;\\n            for(auto e:mp)\\n            {\\n                \\n                if(e.second>1)\\n                {\\n                    check=0;\\n                    break;\\n                }\\n            }\\n            if(check) return cnt;\\n            for(auto &e:mp)\\n            {\\n                \\n                if(e.second>1)\\n                {\\n                    int temp=e.second-1;\\n                    cnt+=temp;\\n                    e.second=1;\\n                    if(e.first!=1)\\n                    {\\n                        mp[e.first-1]+=temp;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2207147,
                "title": "c-easy-sol-with-explanation-using-only-vector",
                "content": "**PLEASE UPVOTE IF YOU FIND IT HELEPFUL**\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int>v(26); //creating a vector of  size 26\\n        for(auto a:s){ \\n            v[a-\\'a\\']++; //now we will go to each char of s and increment frequency\\n        }\\n        //sorting frequencies in descending order\\n        sort(v.rbegin(),v.rend());\\n        //keeping f as greatest frequency (max)\\n        int f=v[0];\\n        int ans=0;\\n        for(auto a: v) {\\n            if(a>f) // if this frequency is greater than max allowed freq\\n            {\\n                if(f>0)\\n                    ans+=(a-f); // lower downing the freq of current element to f\\n                else ans+=a; //if it is smaller than or equal to zero we have to delete\\n            }\\n            f=min(f-1,a-1); //reducing max allowed freq\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int>v(26); //creating a vector of  size 26\\n        for(auto a:s){ \\n            v[a-\\'a\\']++; //now we will go to each char of s and increment frequency\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2207086,
                "title": "python-easy-sorting-approach",
                "content": "I have added comments to understand it better\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freqs=[0]*26 # capture count of all lowercase characters\\n        \\n        for c in s:\\n            freqs[ord(c)-ord(\\'a\\')]+=1\\n        \\n        freqs.sort(reverse=True) # reverse sort: O(nlogn)\\n        \\n        deletions=0\\n        \\n        #initialize with max allowed frequency\\n        # eg: if 5 is taken, then the next best frequency count is 4\\n        # hence, max_freq = 5 - 1 = 4        \\n        max_freq=freqs[0]-1  # set max frequency upper limit\\n        \\n        for freq in freqs[1:]:\\n            # if a character frequency is above freq, it means it needs to be reduced\\n            # eg: if max_freq=4, then it means all counts above 4 has been already allotted\\n            # So we need to reduce the current frequency\\n            \\n            if freq>max_freq:\\n                deletions+=freq-max_freq # update the deletions count\\n                freq=max_freq\\n            max_freq=max(0, freq-1) # update the max frequency upper limit\\n        \\n        return deletions        \\n```\\n\\nIf `m` is the size of the char set which is `26` in this case and `n` is the length of the input `s`, then\\n**Time - O(n+mlogm)** - We can also say its **O(n)** as the sorting is bound by 26 i.e number of lowercase characters.\\n**Space - O(m)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freqs=[0]*26 # capture count of all lowercase characters\\n        \\n        for c in s:\\n            freqs[ord(c)-ord(\\'a\\')]+=1\\n        \\n        freqs.sort(reverse=True) # reverse sort: O(nlogn)\\n        \\n        deletions=0\\n        \\n        #initialize with max allowed frequency\\n        # eg: if 5 is taken, then the next best frequency count is 4\\n        # hence, max_freq = 5 - 1 = 4        \\n        max_freq=freqs[0]-1  # set max frequency upper limit\\n        \\n        for freq in freqs[1:]:\\n            # if a character frequency is above freq, it means it needs to be reduced\\n            # eg: if max_freq=4, then it means all counts above 4 has been already allotted\\n            # So we need to reduce the current frequency\\n            \\n            if freq>max_freq:\\n                deletions+=freq-max_freq # update the deletions count\\n                freq=max_freq\\n            max_freq=max(0, freq-1) # update the max frequency upper limit\\n        \\n        return deletions        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216194,
                "title": "c-greedy-sorting-very-simple-code-with-detailed-explanation",
                "content": "First of all let us understand, what the question is telling. We have to** delete** the character such that frequency of every character becomes unique. So, a simple greedy approach will that, we store the frequencies of every char in a array, And then, we will sort it in reverse order. Let us take a example, \\ns = \" abbcbcca \"\\ncnt[a] = 2, cnt[ b ]=3 & cnt [ c ] = 3.\\nAfter sorting our frequency array will look like [ 3, 3, 2 ], Now, to make every char unique we will start from index 1 and if the value is greater than or equal to its previous value, we will change it to a value 1 less than the previous value and we will find count of number we removed. The array becomes, [3, 2, 1] after doing all the operations.\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int n=s.size();\\n        vector<int>cnt(26,0);        //Storing the frequecy of the characters in the string. \\n        for(auto p:s)cnt[p-\\'a\\']++;  // Frequecy of each chars is stored in the vector.\\n        vector<int>v; \\n        for(int i=0;i<26;i++){\\n            if(cnt[i])v.push_back(cnt[i]);  // all frequencies are stored in an array and sorted in reverse order.\\n        }\\n        sort(v.rbegin(),v.rend());\\n        int c=0;        // count variable set to 0 initially\\n      \\n        for(int i=1;i<v.size();i++){\\n            if(v[i]>=v[i-1]){\\n                if(v[i-1]==0){       // A case when the prev value becomes 0, then we have to delete all the furthur elements afterwards.\\n\\t\\t\\t\\t  c+=v[i];\\n                  v[i]=0;\\n                  continue;\\n                }\\n                c+=(v[i]-v[i-1]+1);    // storing the number of chars removed\\n                v[i]=v[i-1]-1;             // changing the current value to prev-1\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int n=s.size();\\n        vector<int>cnt(26,0);        //Storing the frequecy of the characters in the string. \\n        for(auto p:s)cnt[p-\\'a\\']++;  // Frequecy of each chars is stored in the vector.\\n        vector<int>v; \\n        for(int i=0;i<26;i++){\\n            if(cnt[i])v.push_back(cnt[i]);  // all frequencies are stored in an array and sorted in reverse order.\\n        }\\n        sort(v.rbegin(),v.rend());\\n        int c=0;        // count variable set to 0 initially\\n      \\n        for(int i=1;i<v.size();i++){\\n            if(v[i]>=v[i-1]){\\n                if(v[i-1]==0){       // A case when the prev value becomes 0, then we have to delete all the furthur elements afterwards.\\n\\t\\t\\t\\t  c+=v[i];\\n                  v[i]=0;\\n                  continue;\\n                }\\n                c+=(v[i]-v[i-1]+1);    // storing the number of chars removed\\n                v[i]=v[i-1]-1;             // changing the current value to prev-1\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258412,
                "title": "c-clear-solution",
                "content": "```\\npublic class Solution {\\n    public int MinDeletions(string s) {\\n        int res = 0;\\n        Dictionary<char, int> dict = s.GroupBy(o => o).ToDictionary(o => o.Key, o => o.Count());\\n        HashSet<int> hs = new HashSet<int>();\\n        foreach(var item in dict)\\n        {\\n            int cur = item.Value;\\n            while(!hs.Add(cur) && cur > 0)\\n            {\\n                res++;\\n                cur--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinDeletions(string s) {\\n        int res = 0;\\n        Dictionary<char, int> dict = s.GroupBy(o => o).ToDictionary(o => o.Key, o => o.Count());\\n        HashSet<int> hs = new HashSet<int>();\\n        foreach(var item in dict)\\n        {\\n            int cur = item.Value;\\n            while(!hs.Add(cur) && cur > 0)\\n            {\\n                res++;\\n                cur--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234822,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MinDeletions(string s) {\\n        \\n        if(s == null || s.Length == 0)\\n            return 0;\\n        \\n        // record unique frquencies \\n        HashSet<int> freqSet = new HashSet<int>();\\n        int res = 0;\\n        \\n        // calculate frequencies\\n        int[] freq = new int[26];\\n        foreach(var c in s)\\n            freq[c - \\'a\\']++;\\n        \\n        for(int i = 0; i < freq.Length; i++)\\n        {\\n            // if there is another character has the same frequence\\n            // we need to keep delete the current character until its frequncey is unique\\n            // example 1: input is {(a,3), {b,3}, {c,2}}\\n            // then we need to delete 2 a or 2 b\\n            // example 2: input is {(a,3), {b,3}, {c,2},{d,2}}\\n            // then we need to delete 2 a or 2 b, then delete 2 c or 2d\\n            while(freqSet.Contains(freq[i]) && freq[i] > 0)\\n            {\\n                freq[i]--;\\n                res++;\\n            }\\n            freqSet.Add(freq[i]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinDeletions(string s) {\\n        \\n        if(s == null || s.Length == 0)\\n            return 0;\\n        \\n        // record unique frquencies \\n        HashSet<int> freqSet = new HashSet<int>();\\n        int res = 0;\\n        \\n        // calculate frequencies\\n        int[] freq = new int[26];\\n        foreach(var c in s)\\n            freq[c - \\'a\\']++;\\n        \\n        for(int i = 0; i < freq.Length; i++)\\n        {\\n            // if there is another character has the same frequence\\n            // we need to keep delete the current character until its frequncey is unique\\n            // example 1: input is {(a,3), {b,3}, {c,2}}\\n            // then we need to delete 2 a or 2 b\\n            // example 2: input is {(a,3), {b,3}, {c,2},{d,2}}\\n            // then we need to delete 2 a or 2 b, then delete 2 c or 2d\\n            while(freqSet.Contains(freq[i]) && freq[i] > 0)\\n            {\\n                freq[i]--;\\n                res++;\\n            }\\n            freqSet.Add(freq[i]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034925,
                "title": "simple-java-solution-using-hashset-beats-98-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int minDeletions(String s) {\\n        int[] arr = new int[26];\\n        for(char ch : s.toCharArray()) {\\n            arr[ch - \\'a\\']++;\\n        }\\n        int count = 0;\\n        Set<Integer> set = new HashSet();\\n        for(int i = 0; i < 26; i++) {\\n            int frequency = arr[i];\\n            while(frequency > 0 && set.contains(frequency)) {\\n                frequency--;\\n                count++;\\n            }\\n            set.add(frequency);\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n     public int minDeletions(String s) {\\n        int[] arr = new int[26];\\n        for(char ch : s.toCharArray()) {\\n            arr[ch - \\'a\\']++;\\n        }\\n        int count = 0;\\n        Set<Integer> set = new HashSet();\\n        for(int i = 0; i < 26; i++) {\\n            int frequency = arr[i];\\n            while(frequency > 0 && set.contains(frequency)) {\\n                frequency--;\\n                count++;\\n            }\\n            set.add(frequency);\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209836,
                "title": "python3-basic-intuition-decrease-frequency-until-unique",
                "content": "```\\nfrom collections import Counter\\nfrom string import ascii_lowercase\\nclass Solution:\\n    def minDeletions(self, s: str) -> int: \\n        freq = Counter(s)\\n        result = 0\\n        seen = set()\\n        \\n        for i in ascii_lowercase:\\n            while freq[i] and freq[i] in seen:\\n                freq[i]-=1\\n                result+=1\\n            seen.add(freq[i])\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom string import ascii_lowercase\\nclass Solution:\\n    def minDeletions(self, s: str) -> int: \\n        freq = Counter(s)\\n        result = 0\\n        seen = set()\\n        \\n        for i in ascii_lowercase:\\n            while freq[i] and freq[i] in seen:\\n                freq[i]-=1\\n                result+=1\\n            seen.add(freq[i])\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803591,
                "title": "javascript-simple-0-n-solution-with-explanation",
                "content": "Solution:\\n    step 1: Create a Map \\'charFrequency\\' to store each character in the string along with its frequency\\n    step 2: Create a Set \\'used\\' to check if the frequency of character has already occured\\n    step 3: Iterate through the Map, and check if the frequency of character is already present in the Set,\\n            If No, then add the frequency to the set.\\n            If Yes, then decrement the frequency till it reaches either a freq which is not present in the set or 0, meanwhile also increment the counter \\'res\\' so we can keep track of the number of deletions required\\n    step 4: Finally return the \\'res\\'\\n\\t\\n\\t\\n\\t\\n\\tvar minDeletions = function(s) {\\n   \\n\\t\\tlet charFrequency = new Map(), used = new Set(), res = 0;\\n\\n\\t\\t//Iterate through all the characters & store the char along with frequency in map\\n\\t\\tfor(const char of s){\\n\\t\\t\\t//If the character is already present in map, increment the frequency\\n\\t\\t\\tif(charFrequency.has(char))\\n\\t\\t\\t\\tcharFrequency.set(char, charFrequency.get(char)+1);\\n\\n\\t\\t\\t//If the character is not present, add it to map with frequency set to 1\\n\\t\\t\\telse\\n\\t\\t\\t\\tcharFrequency.set(char, 1);\\n\\t\\t}\\n\\n\\n\\t\\t//Now iterate through the Map created in above steps\\n\\t\\tfor(let [char, freq] of charFrequency.entries()){\\n\\n\\t\\t\\t//Check if the frequency is already present for any other character, decrement the frequency till it reaches either a frequency which is not used already or 0 (because if frequency reaches 0 the character is no more present) \\n\\t\\t\\t//Meanwhile increment the \\'res\\', so we will get to know the count of deletions required\\n\\t\\t\\twhile(used.has(freq) && freq > 0){\\n\\t\\t\\t\\tfreq--;\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Add the frequency to the set \\'used\\', so for the next characters we can check the already used frequency\\n\\t\\t\\tused.add(freq);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Solution:\\n    step 1: Create a Map \\'charFrequency\\' to store each character in the string along with its frequency\\n    step 2: Create a Set \\'used\\' to check if the frequency of character has already occured\\n    step 3: Iterate through the Map, and check if the frequency of character is already present in the Set,\\n            If No, then add the frequency to the set.\\n            If Yes, then decrement the frequency till it reaches either a freq which is not present in the set or 0, meanwhile also increment the counter \\'res\\' so we can keep track of the number of deletions required\\n    step 4: Finally return the \\'res\\'\\n\\t\\n\\t\\n\\t\\n\\tvar minDeletions = function(s) {\\n   \\n\\t\\tlet charFrequency = new Map(), used = new Set(), res = 0;\\n\\n\\t\\t//Iterate through all the characters & store the char along with frequency in map\\n\\t\\tfor(const char of s){\\n\\t\\t\\t//If the character is already present in map, increment the frequency\\n\\t\\t\\tif(charFrequency.has(char))\\n\\t\\t\\t\\tcharFrequency.set(char, charFrequency.get(char)+1);\\n\\n\\t\\t\\t//If the character is not present, add it to map with frequency set to 1\\n\\t\\t\\telse\\n\\t\\t\\t\\tcharFrequency.set(char, 1);\\n\\t\\t}\\n\\n\\n\\t\\t//Now iterate through the Map created in above steps\\n\\t\\tfor(let [char, freq] of charFrequency.entries()){\\n\\n\\t\\t\\t//Check if the frequency is already present for any other character, decrement the frequency till it reaches either a frequency which is not used already or 0 (because if frequency reaches 0 the character is no more present) \\n\\t\\t\\t//Meanwhile increment the \\'res\\', so we will get to know the count of deletions required\\n\\t\\t\\twhile(used.has(freq) && freq > 0){\\n\\t\\t\\t\\tfreq--;\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Add the frequency to the set \\'used\\', so for the next characters we can check the already used frequency\\n\\t\\t\\tused.add(freq);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122198,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func minDeletions(_ s: String) -> Int {\\n        guard !s.isEmpty else { return 0 }\\n        var res = 0, set = Set<Int>()\\n        let dict = Dictionary(s.map({($0, 1)}), uniquingKeysWith: +)\\n        dict.forEach {\\n            guard var idx = dict[$0.key] else { return }\\n            while set.contains(idx) {\\n                idx -= 1\\n                res += 1\\n            }\\n            if idx > 0 { set.insert(idx) }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.021 (0.023) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let res = solution.minDeletions(\"aab\")\\n        XCTAssertEqual(res, 0)\\n    }\\n    \\n    func test1() {\\n        let res = solution.minDeletions(\"aaabbbcc\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    \\n    func test2() {\\n        let res = solution.minDeletions(\"ceabaacb\")\\n        XCTAssertEqual(res, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minDeletions(_ s: String) -> Int {\\n        guard !s.isEmpty else { return 0 }\\n        var res = 0, set = Set<Int>()\\n        let dict = Dictionary(s.map({($0, 1)}), uniquingKeysWith: +)\\n        dict.forEach {\\n            guard var idx = dict[$0.key] else { return }\\n            while set.contains(idx) {\\n                idx -= 1\\n                res += 1\\n            }\\n            if idx > 0 { set.insert(idx) }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let res = solution.minDeletions(\"aab\")\\n        XCTAssertEqual(res, 0)\\n    }\\n    \\n    func test1() {\\n        let res = solution.minDeletions(\"aaabbbcc\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    \\n    func test2() {\\n        let res = solution.minDeletions(\"ceabaacb\")\\n        XCTAssertEqual(res, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033918,
                "title": "simple-greedy-solution",
                "content": "# Intuition\\nBe greedy\\n\\n# Approach\\n1.First create a count dictonary which stores the frequency of each element\\n2.After that now create a new set that stores all the used frequencies\\n3.Now iterate over the count dictonary and check whether it is present in user frequencies set or not if so decrement the value by 1 until the frequency is not present in used frequency or frequency > 0\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    var countDict = {};\\n    for(var ele of s){\\n        countDict[ele] = (countDict[ele] || 0)+1;\\n    }\\n    var usedFreq = new Set();\\n    var deletion = 0;\\n    for(var ele of Object.entries(countDict)){\\n        let currFreq = ele[1];\\n        while(currFreq>0 &&usedFreq.has(currFreq)){\\n            deletion++;\\n            currFreq--;\\n        }\\n        if(currFreq>0)\\n            usedFreq.add(currFreq);\\n    }\\n    return deletion;\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    var countDict = {};\\n    for(var ele of s){\\n        countDict[ele] = (countDict[ele] || 0)+1;\\n    }\\n    var usedFreq = new Set();\\n    var deletion = 0;\\n    for(var ele of Object.entries(countDict)){\\n        let currFreq = ele[1];\\n        while(currFreq>0 &&usedFreq.has(currFreq)){\\n            deletion++;\\n            currFreq--;\\n        }\\n        if(currFreq>0)\\n            usedFreq.add(currFreq);\\n    }\\n    return deletion;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2213395,
                "title": "8ms-100-faster-only-sorting-easy-java",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] freq = new int[26];\\n        for(char ch:s.toCharArray()) freq[ch-\\'a\\']++;\\n        Arrays.sort(freq);\\n        int res = 0;\\n        for(int i=24;i>=0;i--){\\n            if(freq[i] == 0) break;\\n            if(freq[i] >= freq[i+1]){\\n                int count = freq[i] - freq[i+1] + 1;\\n                freq[i] -= count;\\n                res += count;\\n                if(freq[i] < 0) res += freq[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] freq = new int[26];\\n        for(char ch:s.toCharArray()) freq[ch-\\'a\\']++;\\n        Arrays.sort(freq);\\n        int res = 0;\\n        for(int i=24;i>=0;i--){\\n            if(freq[i] == 0) break;\\n            if(freq[i] >= freq[i+1]){\\n                int count = freq[i] - freq[i+1] + 1;\\n                freq[i] -= count;\\n                res += count;\\n                if(freq[i] < 0) res += freq[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209264,
                "title": "daily-leetcode-challenge-28-june",
                "content": "1)We created a frequency array to store the frequency of each character\\n2)We reverse sorted the freq array to bring alike count together and 0\\'s to the end\\n3)check the adjusent elements and reduced the next one if found same and increment the count\\n4)repeat step 2&3 untill all elements are unique\\n->\"aabbc\"\\n2 2 1 | c = 0\\n2 1 1 | c = 1\\n2 1 0 | c = 2\\n\\n\\n```class Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int  n = s.size();\\n        int a[27] = {0};\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            a[s[i] - 97]++;\\n        }\\n        sort(a,a+27,greater<int>());\\n        int count = 0;\\n        int i = 0;\\n        while(i < 25)\\n        {\\n            if(a[i] == a[i+1])\\n            {\\n                if(a[i] == 0 && a[i+1] == 0)\\n                {\\n                    i++;\\n                    continue;\\n                }\\n                a[i+1]--;\\n                sort(a,a+27,greater<int>());\\n                count++;\\n                continue;\\n            }    \\n            i++;\\n        }\\n        return count;\\n            \\n    \\n        \\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int  n = s.size();\\n        int a[27] = {0};\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            a[s[i] - 97]++;\\n        }\\n        sort(a,a+27,greater<int>());\\n        int count = 0;\\n        int i = 0;\\n        while(i < 25)\\n        {\\n            if(a[i] == a[i+1])\\n            {\\n                if(a[i] == 0 && a[i+1] == 0)\\n                {\\n                    i++;\\n                    continue;\\n                }\\n                a[i+1]--;\\n                sort(a,a+27,greater<int>());\\n                count++;\\n                continue;\\n            }    \\n            i++;\\n        }\\n        return count;\\n            \\n    \\n        \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2207214,
                "title": "c-hashmap-and-map-and-stuff",
                "content": "get the freqMap of the string\\n\\nmap the values -> keys in the freqMap in another map called freqMapMap;\\n\\niterate thru the freqMapMap from the largest key to the smallest\\n\\n**Solved LIVE ON TWITCH. EVERYDAY 6pm PT.  Link in profile.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<int, int> freqMap;\\n        \\n        for(char c : s) {\\n            freqMap[c]++;\\n        }\\n        //freqMapMap\\n        map<int, vector<char>>  fmm;\\n        \\n        for(auto& [c, count] : freqMap) {\\n            fmm[count].push_back(c);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto it = fmm.rbegin(); it != fmm.rend(); it++) {\\n            \\n            int size = it->second.size();\\n            int count = it->first;\\n            if(count == 0) continue;\\n            for(int i = 1; i < size; i++) {\\n                fmm[count-1].push_back(it->second[i]);\\n            }\\n            \\n            ans += size-1;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<int, int> freqMap;\\n        \\n        for(char c : s) {\\n            freqMap[c]++;\\n        }\\n        //freqMapMap\\n        map<int, vector<char>>  fmm;\\n        \\n        for(auto& [c, count] : freqMap) {\\n            fmm[count].push_back(c);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto it = fmm.rbegin(); it != fmm.rend(); it++) {\\n            \\n            int size = it->second.size();\\n            int count = it->first;\\n            if(count == 0) continue;\\n            for(int i = 1; i < size; i++) {\\n                fmm[count-1].push_back(it->second[i]);\\n            }\\n            \\n            ans += size-1;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207088,
                "title": "two-approaches-time-o-n-space-o-1-c",
                "content": "**Approach #1**\\nWe can make a frequency array which keeps track of how many characters are occuring at this freq *( for  `aabb ` `freq[2] = 2 `)* .Now our task is to perform deletions , therefore if we found more than 1 character with same frequency *i.e.* `freq[i]>1` ,then we need to delete the characters and make it equal to frequency `x (x<i)` where `freq[x]==0 `.Also , in order to ensure minimum number of deletions,we need to find the` x `as close as possible to `i`.\\n**Time Complexity : O(n)\\nSpace Complexity : O(n)**\\n```\\n    unordered_map<char,int> hm;\\n        for(char c:s)hm[c]++;\\n        \\n    vector<int> freq(1e5+1);   // as the |s| can be at max 1e5 \\n      for(auto x:hm){\\n          freq[x.second]++;\\n      }  \\n       \\n        int count = 0;\\n        queue<int> q;\\n        for(int i =s.size();i>=0;i--){\\n            if(freq[i]==0){      // since no element found here so we can put our extra elements .\\n                if(q.size()){   \\n                    count+= (q.front()-i);   \\n                    q.pop();\\n               }\\n            }\\n            if(freq[i]==1)continue;\\n            for(int j=1;j<freq[i];j++)q.push(i);  // let 1 element stay at this freq and put others in queue\\n        }\\n        \\n        while(q.size()){\\n            count+= q.front();\\n            q.pop();\\n        }\\n         \\n        return count;\\n```\\n\\n**Approach #2** \\n\\nWe can also store the freq for all the 26 characters.After that we can greedily find out what is the maximum zero frequency present below the duplicate frequency.\\n\\n```\\n   unordered_map<int,int> hm;\\n        vector<int> vec(26,0);\\n        for(char c:s){                   // storing frequencies of all characters\\n            vec[c-\\'a\\']++;}\\n        for(int i=0;i<26;i++){\\n            hm[vec[i]]++;}            // storing frequencies of all frequencies\\n        hm[0]=0;\\n        int count = 0;\\n        for(int i =0;i<26;i++){\\n            int f = vec[i];\\n        \\n            if(hm[f]>1 ){                        \\n                for(int j=f-1;j>=0;j--){               // find out the frequency below f that is not yet recordes (this loop won\\'t iterate more than 25 times \\n                    if(j==0){\\n                        count  +=f;}\\n                    else if(hm.count(j)==0){\\n                        hm[j] = 1;\\n                        count += f-j;\\n                        break;\\n                    } \\n                }\\n                hm[f]--;\\n            }   \\n        } \\n        return count ;\\n```\\n\\n**Time Complexity : O(n)\\nSpace Complexity : O(1) *(array of length 26 always)***\\n\\n*Approach #2  is  faster as the compution is done only for 26 characters whereas in approach#1 the computation was done for s.size() frequencies.*\\n.\\n.\\n.\\n.\\n ***Please upvote if it helped !***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    unordered_map<char,int> hm;\\n        for(char c:s)hm[c]++;\\n        \\n    vector<int> freq(1e5+1);   // as the |s| can be at max 1e5 \\n      for(auto x:hm){\\n          freq[x.second]++;\\n      }  \\n       \\n        int count = 0;\\n        queue<int> q;\\n        for(int i =s.size();i>=0;i--){\\n            if(freq[i]==0){      // since no element found here so we can put our extra elements .\\n                if(q.size()){   \\n                    count+= (q.front()-i);   \\n                    q.pop();\\n               }\\n            }\\n            if(freq[i]==1)continue;\\n            for(int j=1;j<freq[i];j++)q.push(i);  // let 1 element stay at this freq and put others in queue\\n        }\\n        \\n        while(q.size()){\\n            count+= q.front();\\n            q.pop();\\n        }\\n         \\n        return count;\\n```\n```\\n   unordered_map<int,int> hm;\\n        vector<int> vec(26,0);\\n        for(char c:s){                   // storing frequencies of all characters\\n            vec[c-\\'a\\']++;}\\n        for(int i=0;i<26;i++){\\n            hm[vec[i]]++;}            // storing frequencies of all frequencies\\n        hm[0]=0;\\n        int count = 0;\\n        for(int i =0;i<26;i++){\\n            int f = vec[i];\\n        \\n            if(hm[f]>1 ){                        \\n                for(int j=f-1;j>=0;j--){               // find out the frequency below f that is not yet recordes (this loop won\\'t iterate more than 25 times \\n                    if(j==0){\\n                        count  +=f;}\\n                    else if(hm.count(j)==0){\\n                        hm[j] = 1;\\n                        count += f-j;\\n                        break;\\n                    } \\n                }\\n                hm[f]--;\\n            }   \\n        } \\n        return count ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573356,
                "title": "c-straightforward-o-n-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> cache(26);\\n        for (char c:s)\\n            cache[c-\\'a\\'] ++;\\n        sort(cache.begin(), cache.end(), greater<int>());\\n        int res = 0;\\n        for (int i = 1; i < cache.size(); i++)\\n        {\\n            if (cache[i-1] <= 1)\\n            {\\n                res += cache[i];\\n                cache[i] = 0;\\n            }\\n            else if (cache[i-1] <= cache[i])\\n            {\\n                res = res + cache[i] - cache[i-1] + 1;\\n                cache[i] = cache[i-1] -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nTime complexity -> o(n) + o(26log26) + o(26) = o(n)\\n\\nIf frequencies are like [26,26,26,26,26,0....], it will change as follows.\\n[26,25,26,26,26,0....] res += 1\\n[26,25,24,26,26,0....] res += 2\\n[26,25,24,23,26,0....] res += 3\\n[26,25,24,23,22,0....] res += 4\\n\\nIf you like the solution, please help to upvote!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> cache(26);\\n        for (char c:s)\\n            cache[c-\\'a\\'] ++;\\n        sort(cache.begin(), cache.end(), greater<int>());\\n        int res = 0;\\n        for (int i = 1; i < cache.size(); i++)\\n        {\\n            if (cache[i-1] <= 1)\\n            {\\n                res += cache[i];\\n                cache[i] = 0;\\n            }\\n            else if (cache[i-1] <= cache[i])\\n            {\\n                res = res + cache[i] - cache[i-1] + 1;\\n                cache[i] = cache[i-1] -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460621,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] count = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int res = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(int i=0; i<count.length;i++){\\n            while(count[i] > 0 && set.contains(count[i])){\\n                count[i]--;\\n                res++;\\n            }\\n            set.add(count[i]);\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] count = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int res = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(int i=0; i<count.length;i++){\\n            while(count[i] > 0 && set.contains(count[i])){\\n                count[i]--;\\n                res++;\\n            }\\n            set.add(count[i]);\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927535,
                "title": "clean-python-3-stack-o-n",
                "content": "Count the frequency of each characters.\\nAnd save empty bucket when iterating the frequencies.\\nOnce we found there is an overflow of this bucket, just pop the stack to find the closest empty bucket for it.\\nTime: `O(N)`, where `N` is the length of `s`\\nSpace: `O(N)`\\n```\\nimport collections\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counter = collections.Counter(s)\\n        bucket = collections.Counter(counter.values())\\n        result, stack = 0, []\\n        for i in range(1, len(s)):\\n            if bucket[i] == 0:\\n                stack.append(i)\\n                continue\\n            while bucket[i] > 1:\\n                result += i - (stack.pop() if stack else 0)\\n                bucket[i] -= 1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counter = collections.Counter(s)\\n        bucket = collections.Counter(counter.values())\\n        result, stack = 0, []\\n        for i in range(1, len(s)):\\n            if bucket[i] == 0:\\n                stack.append(i)\\n                continue\\n            while bucket[i] > 1:\\n                result += i - (stack.pop() if stack else 0)\\n                bucket[i] -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036259,
                "title": "beginner-friendly-solution-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to play with the frequency of the characters in the given string so the first thaught would have to come that we can use hash map in this problem.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Step 1 :** First we will store the frequency of each character of the string in a map.\\n\\n**Step 2 :** Now we will take another map so that we can have an idea or we can store the frequency of every count of a particular character. \\neg : if for string \"aaabbbcc\" first we will count the frequency of every character like :\\n\\na -> 3\\nb -> 3\\nc -> 2\\n\\nNow in step 2 we have done :\\n\\n3 occured 2 times\\n2 occured 1 time\\n\\n**Step 3 :** If all frequency of all count are unique the we don\\'t have to worry but if not unique then we have to check if the lower slot of character count if present or not (because we have to delete the character).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            mp[s[i]]++;\\n        }\\n        unordered_map<int,int> freqCnt;\\n        int ans = 0;\\n        for(auto it : mp) {\\n            int cnt = it.second;\\n            if(freqCnt[cnt] != 0) {\\n                while(cnt > 0 && freqCnt[cnt] != 0) {\\n                    cnt--;\\n                    ans++;\\n                }\\n            }\\n            freqCnt[cnt]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            mp[s[i]]++;\\n        }\\n        unordered_map<int,int> freqCnt;\\n        int ans = 0;\\n        for(auto it : mp) {\\n            int cnt = it.second;\\n            if(freqCnt[cnt] != 0) {\\n                while(cnt > 0 && freqCnt[cnt] != 0) {\\n                    cnt--;\\n                    ans++;\\n                }\\n            }\\n            freqCnt[cnt]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035302,
                "title": "c-priority-queue-vs-set-vs-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse C++ priority_queue & set (using unordered_set is slower)!\\n3rd Solution uses sort.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n+26\\\\log(26))=O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(26)=O(1)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26, 0);\\n        for(char c: s)\\n            freq[c-\\'a\\']++;\\n        priority_queue<int> pq;\\n        for(int f: freq)\\n            if (f>0) pq.push(f);\\n\\n        int upper=pq.top();\\n     //   cout<<upper<<endl;\\n        pq.pop();\\n        int ans=0;\\n        while(!pq.empty() && upper>=1){\\n            int top=pq.top();\\n            pq.pop();\\n            int del=top+1-upper;\\n            if (del<0) upper=top;\\n            else{\\n                ans+=del;\\n                upper--;\\n            }\\n        //    cout<<upper<<endl;\\n        }\\n        while(!pq.empty()){\\n            int top=pq.top();\\n            pq.pop();\\n            ans+=top;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# code using set without sorting\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26, 0);\\n        for(char c: s)\\n            freq[c-\\'a\\']++;\\n        set<int> freq_seen;\\n        int ans=0;\\n        for(int i=0; i<26; i++){\\n            int f=freq[i];\\n            if (f==0) continue;\\n            while(freq_seen.count(f) && f>0){\\n                f--;\\n                ans++;\\n            }\\n            if (f>0) freq_seen.insert(f);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Using sorting\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26, 0);\\n        for(char c: s)\\n            freq[c-\\'a\\']++;\\n        sort(freq.begin(), freq.end(), greater());\\n        int upper=freq[0];\\n        int ans=0;\\n        int i, f;\\n        for(i=1; i<26 && upper>=1; i++){\\n            f=freq[i];\\n            int del=f+1-upper;\\n            if (del<0) upper=f;\\n            else{\\n                ans+=del;\\n                upper--;\\n            }\\n        //    cout<<upper<<endl;\\n        }\\n        while(f>0 && i<26){\\n            f=freq[i];\\n            ans+=f;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26, 0);\\n        for(char c: s)\\n            freq[c-\\'a\\']++;\\n        priority_queue<int> pq;\\n        for(int f: freq)\\n            if (f>0) pq.push(f);\\n\\n        int upper=pq.top();\\n     //   cout<<upper<<endl;\\n        pq.pop();\\n        int ans=0;\\n        while(!pq.empty() && upper>=1){\\n            int top=pq.top();\\n            pq.pop();\\n            int del=top+1-upper;\\n            if (del<0) upper=top;\\n            else{\\n                ans+=del;\\n                upper--;\\n            }\\n        //    cout<<upper<<endl;\\n        }\\n        while(!pq.empty()){\\n            int top=pq.top();\\n            pq.pop();\\n            ans+=top;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26, 0);\\n        for(char c: s)\\n            freq[c-\\'a\\']++;\\n        set<int> freq_seen;\\n        int ans=0;\\n        for(int i=0; i<26; i++){\\n            int f=freq[i];\\n            if (f==0) continue;\\n            while(freq_seen.count(f) && f>0){\\n                f--;\\n                ans++;\\n            }\\n            if (f>0) freq_seen.insert(f);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26, 0);\\n        for(char c: s)\\n            freq[c-\\'a\\']++;\\n        sort(freq.begin(), freq.end(), greater());\\n        int upper=freq[0];\\n        int ans=0;\\n        int i, f;\\n        for(i=1; i<26 && upper>=1; i++){\\n            f=freq[i];\\n            int del=f+1-upper;\\n            if (del<0) upper=f;\\n            else{\\n                ans+=del;\\n                upper--;\\n            }\\n        //    cout<<upper<<endl;\\n        }\\n        while(f>0 && i<26){\\n            f=freq[i];\\n            ans+=f;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4034026,
                "title": "92-fast-c-solution-cpp-c-fast-veryfast-unordered-set-vector-iterator",
                "content": "# Intuition\\nJust like yesterday\\'s question, this one too provides same or different frequencies for different alphabets.\\nHence, we need to know corresponding frequencies for each alphabet in order to find number of minimum deletions.\\n\\n# Approach\\n1. Find the frequencies for each alphabet from a-z beforehand and store it in a 26-sized vector.\\n2. Iterate over the frequency vector.\\n3. For every new frequency, simply insert it into the set.\\n4. If you encounter a frequency which has occured earlier, reduce it until it becomes the one not occured yet.\\n5. Every time you reduce a frequency, increase minDel, as that is the count of frequencies you are deleting to get a good string according to the question. \\n6. Return the minDel value;\\n\\n# Complexity\\n- Time complexity:\\n**O(N + 26logN) in the worst case**\\nThis is for the first for loop to store the occurences and for inserting at most 26 entries in set. Rest all loops (for/while) run for a constant time.\\nThis is because freq vector has constant size, set can go at max till 26 for 26 different alphabets.\\n\\n- Space complexity:\\n**O(26\\\\*sizeOf(freq[0]) + 26)** for constant sizes of freq vector and unordered_set\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int minDel = 0;\\n        vector<int> freq(26, 0);\\n        unordered_set<int> st;\\n        // this is freq of each alphabet, like a-\\'a\\' = 0th index till z(25th index)\\n        for(auto it : s){\\n            freq[it - \\'a\\']++;\\n        }\\n        for(auto it : freq){\\n            if(it == 0) continue;   // for no occurence of an alphabet\\n            if(st.find(it) != st.end()){   // if this freq has occured before\\n                while(st.find(it) != st.end() && it > 0){  // until it is there or doesn\\'t boil down to zero\\n                    it--;\\n                    minDel++;\\n                }\\n                if(it!=0) st.insert(it);  // once a new freq value occurs after some deletions (non-zero), which wasn\\'t in the set before, insert it in the set\\n            }else{\\n                st.insert(it);  // not occured before? straightaway put it in the set\\n            } \\n        }\\n        for(auto it : st){\\n            cout << it << endl;\\n        }\\n        return minDel;\\n    }\\n};\\n```\\n\\n# **Please Upvote if you liked the solution or it helped you !!!** \\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int minDel = 0;\\n        vector<int> freq(26, 0);\\n        unordered_set<int> st;\\n        // this is freq of each alphabet, like a-\\'a\\' = 0th index till z(25th index)\\n        for(auto it : s){\\n            freq[it - \\'a\\']++;\\n        }\\n        for(auto it : freq){\\n            if(it == 0) continue;   // for no occurence of an alphabet\\n            if(st.find(it) != st.end()){   // if this freq has occured before\\n                while(st.find(it) != st.end() && it > 0){  // until it is there or doesn\\'t boil down to zero\\n                    it--;\\n                    minDel++;\\n                }\\n                if(it!=0) st.insert(it);  // once a new freq value occurs after some deletions (non-zero), which wasn\\'t in the set before, insert it in the set\\n            }else{\\n                st.insert(it);  // not occured before? straightaway put it in the set\\n            } \\n        }\\n        for(auto it : st){\\n            cout << it << endl;\\n        }\\n        return minDel;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4033548,
                "title": "simple-approach-using-map-and-set",
                "content": "# Intuition\\n- Given a string. We have to check whether it is good or not.\\n- It is good iff every character\\'s freqency in the string is dfferent.\\n- We need to determine minimum number of deletions need to do so as to make the string good.\\n- Intuition is to keep a track of frequency of all previous characters that we have kept in our string. We can do this using set.\\n\\n# Approach\\n- We are using a unordered_map to store the frequency of different characters in the string.\\n- Then we will iterate over the map and check if current frequency exists in map or not. If it exists then we decrement the current frequency and again check.\\n- We will continue this untill either the freqency becomes unique or zero.\\n- Once the frequency of character becomes unique, we will be adding that in our set\\nThen we move to next character. \\n- We continue this for all characters.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char, int> m;\\n        for(auto i : s){\\n            m[i]++;\\n        }\\n        unordered_set<int> st;\\n        int ans = 0;\\n        for(auto i : m){\\n            int temp = i.second;\\n            while(temp > 0 && st.find(temp) != st.end()){\\n                temp--;\\n                ans++;\\n            }\\n            if(temp != 0){\\n                st.insert(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# IMP: Kindly Upvote if u like the solution! Even a single upvote will motivate me write a solution daily!",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char, int> m;\\n        for(auto i : s){\\n            m[i]++;\\n        }\\n        unordered_set<int> st;\\n        int ans = 0;\\n        for(auto i : m){\\n            int temp = i.second;\\n            while(temp > 0 && st.find(temp) != st.end()){\\n                temp--;\\n                ans++;\\n            }\\n            if(temp != 0){\\n                st.insert(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033200,
                "title": "simplest-python-solution-counter-check-for-values",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        d = Counter(s)\\n        ans = 0\\n        seen = set()\\n        for k, v in d.items():\\n            while v and v in seen:\\n                ans += 1\\n                v -= 1\\n            seen.add(v)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        d = Counter(s)\\n        ans = 0\\n        seen = set()\\n        for k, v in d.items():\\n            while v and v in seen:\\n                ans += 1\\n                v -= 1\\n            seen.add(v)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319299,
                "title": "c-easy-solution-100-faster",
                "content": "**C++ Easy Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int freq[26]={0};\\n        \\n        int l=s.length();\\n        \\n        for(int i=0;i<l;i++)\\n            freq[s[i]-\\'a\\']++;\\n        \\n        int ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(freq[i]==0)\\n                continue;\\n            for(int j=0;j<26;j++)\\n            {\\n                if(i!=j && freq[i]==freq[j])\\n                {\\n                    freq[i]--,ans++,i--;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If You Find it Hepful Kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int freq[26]={0};\\n        \\n        int l=s.length();\\n        \\n        for(int i=0;i<l;i++)\\n            freq[s[i]-\\'a\\']++;\\n        \\n        int ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(freq[i]==0)\\n                continue;\\n            for(int j=0;j<26;j++)\\n            {\\n                if(i!=j && freq[i]==freq[j])\\n                {\\n                    freq[i]--,ans++,i--;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452734,
                "title": "java-simple-solution-hashmap-hashset",
                "content": "# Attempt 1 : \\n```\\nclass Solution {\\n    public int minDeletions(String s) {\\n\\t\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0)+1);\\n        }\\n        \\n        HashSet<Integer> counts = new HashSet<>();\\n        \\n\\t\\t// check if we have same freq chars\\n\\t\\t// if yes, keep on removing them\\n\\t\\t\\n\\t\\t// we are maintaining a set to check the unique freq counts\\n        int toDelete = 0;\\n        for(char ch : map.keySet()) {\\n            int freq = map.get(ch);\\n            if(!counts.contains(freq)) counts.add(freq);\\n            else {\\n                while(counts.contains(freq) && freq > 0) {\\n                    toDelete++;\\n                    freq--;\\n                } \\n                if(freq > 0) counts.add(freq);\\n            }\\n        }\\n        \\n        return toDelete;\\n    }\\n}\\n```\\n\\nTC : `O(n)`\\nSC : `O(n)`\\n\\n# Attempt 2 : \\nWe can remove redundant code.\\n\\n```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        HashMap<Character, Integer> freq = new HashMap<>();\\n        for(char ch : s.toCharArray()) {\\n            freq.put(ch, freq.getOrDefault(ch, 0)+1);\\n        }\\n        \\n        HashSet<Integer> counts = new HashSet<>();\\n        \\n        int toDelete = 0;\\n        for(char ch : freq.keySet()) {\\n            int cnt = freq.get(ch);\\n            while(counts.contains(cnt)) {\\n                toDelete++;\\n                cnt--;\\n            }\\n            if(cnt > 0) counts.add(cnt);\\n        }\\n        return toDelete;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n\\t\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0)+1);\\n        }\\n        \\n        HashSet<Integer> counts = new HashSet<>();\\n        \\n\\t\\t// check if we have same freq chars\\n\\t\\t// if yes, keep on removing them\\n\\t\\t\\n\\t\\t// we are maintaining a set to check the unique freq counts\\n        int toDelete = 0;\\n        for(char ch : map.keySet()) {\\n            int freq = map.get(ch);\\n            if(!counts.contains(freq)) counts.add(freq);\\n            else {\\n                while(counts.contains(freq) && freq > 0) {\\n                    toDelete++;\\n                    freq--;\\n                } \\n                if(freq > 0) counts.add(freq);\\n            }\\n        }\\n        \\n        return toDelete;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        HashMap<Character, Integer> freq = new HashMap<>();\\n        for(char ch : s.toCharArray()) {\\n            freq.put(ch, freq.getOrDefault(ch, 0)+1);\\n        }\\n        \\n        HashSet<Integer> counts = new HashSet<>();\\n        \\n        int toDelete = 0;\\n        for(char ch : freq.keySet()) {\\n            int cnt = freq.get(ch);\\n            while(counts.contains(cnt)) {\\n                toDelete++;\\n                cnt--;\\n            }\\n            if(cnt > 0) counts.add(cnt);\\n        }\\n        return toDelete;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138318,
                "title": "python-with-comments-no-need-to-sort",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        \\'\\'\\'\\n        create a dictionary that contains character as key\\n        and value as the freq of the char \\n        \\n        Now forget the char all together as the question asks\\n        for minimum no of chars to remove and nothing concerning the \\n        ordering or string formation \\n        \\n        Once you have freq values iterate through them, if the \\n        freq value is not present in set add to it else keep reducing the freq value \\n        until you get a value that is not present in freq set\\n        \\n        while reducing the freqValue by one also keep track of how many times we are\\n        reducing, this count will be added to the overall count for removal\\n        \\n        \\'\\'\\'\\n        frequency = Counter(s)\\n        frequencyValues = frequency.values()\\n        frequencySet = set()\\n        count = 0\\n        for frequencyValue in frequencyValues:\\n            while frequencyValue and frequencyValue in frequencySet:\\n                count += 1\\n                frequencyValue -= 1\\n            frequencySet.add(frequencyValue)\\n                \\n        return(count)\\n        \\n        ```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        \\'\\'\\'\\n        create a dictionary that contains character as key\\n        and value as the freq of the char \\n        \\n        Now forget the char all together as the question asks\\n        for minimum no of chars to remove and nothing concerning the \\n        ordering or string formation \\n        \\n        Once you have freq values iterate through them, if the \\n        freq value is not present in set add to it else keep reducing the freq value \\n        until you get a value that is not present in freq set\\n        \\n        while reducing the freqValue by one also keep track of how many times we are\\n        reducing, this count will be added to the overall count for removal\\n        \\n        \\'\\'\\'\\n        frequency = Counter(s)\\n        frequencyValues = frequency.values()\\n        frequencySet = set()\\n        count = 0\\n        for frequencyValue in frequencyValues:\\n            while frequencyValue and frequencyValue in frequencySet:\\n                count += 1\\n                frequencyValue -= 1\\n            frequencySet.add(frequencyValue)\\n                \\n        return(count)\\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 932021,
                "title": "python-maxheap-o-n",
                "content": "```\\nfrom collections import Counter\\ndef minDeletions(s):\\n    heap = sorted(-x for x in Counter(s).values())\\n    count = 0\\n    while len(heap) >=2:\\n        max_ = heappop(heap)\\n        if max_ == heap[0]:\\n            count+=1\\n            if max_+1 !=0:\\n                heappush(heap, max_+1)\\n    return count\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\ndef minDeletions(s):\\n    heap = sorted(-x for x in Counter(s).values())\\n    count = 0\\n    while len(heap) >=2:\\n        max_ = heappop(heap)\\n        if max_ == heap[0]:\\n            count+=1\\n            if max_+1 !=0:\\n                heappush(heap, max_+1)\\n    return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 4034767,
                "title": "simple-approach-using-sorteddict",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedDict\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freqToCnt = SortedDict(Counter(Counter(s).values()))\\n        deletions = 0\\n        i = -1\\n        while i >= -len(freqToCnt):\\n            freq, cnt = freqToCnt.peekitem(i)\\n            if cnt > 1:\\n                deletions += cnt - 1\\n                if freq > 1:\\n                    freqToCnt[freq-1] = freqToCnt.get(freq-1, 0) + cnt - 1\\n\\n            i -= 1\\n        \\n        return deletions\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nfrom sortedcontainers import SortedDict\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freqToCnt = SortedDict(Counter(Counter(s).values()))\\n        deletions = 0\\n        i = -1\\n        while i >= -len(freqToCnt):\\n            freq, cnt = freqToCnt.peekitem(i)\\n            if cnt > 1:\\n                deletions += cnt - 1\\n                if freq > 1:\\n                    freqToCnt[freq-1] = freqToCnt.get(freq-1, 0) + cnt - 1\\n\\n            i -= 1\\n        \\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033943,
                "title": "c-easy-soln",
                "content": "\\n\\n# Approach\\nWe will count the frequency and will make one container which will store our unique frequency. We will travel through our freq array and we will check if that freq is already in our unique freq.If no we will diretly go ahead and if yes we will decrease it and try it again.\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(1), constant space ...No matter what is size of string we are always using at max of 26 space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n       vector<int> freq(26,0);\\n       int n = s.size();\\n        for(int i=0;i<n;i++){\\n           freq[s[i]-\\'a\\']++;\\n        } \\n        int ans=0;\\n        unordered_set<int> used;\\n        for(int i=0;i<26;i++){\\n            int temp = freq[i];\\n            while(temp>0 && used.find(temp)!=used.end()){\\n                temp--;\\n                ans++;\\n            }\\n            used.insert(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n       vector<int> freq(26,0);\\n       int n = s.size();\\n        for(int i=0;i<n;i++){\\n           freq[s[i]-\\'a\\']++;\\n        } \\n        int ans=0;\\n        unordered_set<int> used;\\n        for(int i=0;i<26;i++){\\n            int temp = freq[i];\\n            while(temp>0 && used.find(temp)!=used.end()){\\n                temp--;\\n                ans++;\\n            }\\n            used.insert(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033813,
                "title": "python-easy-solution-by-using-frequency-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        frq=[0]*26\\n        for i in s:\\n            frq[ord(i)-97]+=1\\n        frq.sort(reverse=True)\\n        \\n        i=1\\n        count=0\\n        while i<26 and i!=0:\\n            if frq[i]==0:\\n                i+=1\\n                continue\\n            if frq[i]==frq[i-1] or frq[i]>frq[i-1]:\\n\\n                frq[i]-=1\\n                count+=1\\n            else:\\n                i+=1\\n        return count\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        frq=[0]*26\\n        for i in s:\\n            frq[ord(i)-97]+=1\\n        frq.sort(reverse=True)\\n        \\n        i=1\\n        count=0\\n        while i<26 and i!=0:\\n            if frq[i]==0:\\n                i+=1\\n                continue\\n            if frq[i]==frq[i-1] or frq[i]>frq[i-1]:\\n\\n                frq[i]-=1\\n                count+=1\\n            else:\\n                i+=1\\n        return count\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033584,
                "title": "simple-c-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the minimum number of deletions needed to make all characters in the given string appear distinct. To solve this problem, we can start by counting the frequency of each character in the string and then remove duplicate frequencies until all frequencies are unique. This way, we keep the character with the highest frequency and decrement it until it becomes unique.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a vector `v` of size 26 (for lowercase English letters) to count the frequency of each character in the string s.\\n\\n2. Iterate through the characters of the string s and increment the corresponding element in the v vector.\\n\\n3. Create a set `st` to keep track of unique frequencies encountered.\\n\\n4. Initialize a variable `res` to store the result (the minimum number of deletions).\\n\\n5. Sort the v vector in `descending` order.\\n\\n6. Iterate through the sorted vector v:\\n\\n    - If the current frequency ele is 0, continue to the next element.\\n    - If ele is not in the set st, insert it into the set.\\n    - If ele is already in the set, keep decrementing it until it becomes `unique (not in the set)`. Increment the res counter for each decrement.\\n7. Return the res, which represents the minimum number of deletions needed to make all frequencies unique.\\n# Complexity\\n- Time complexity: $$O(n)$$ +  $$O(nlogn)$$ =  ***$$O(nlogn)$$***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(n)` where n is the length of the input string s. We iterate through the string once to count frequencies and then iterate through the sorted vector.\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) since the size of the vector and set is fixed (26 for lowercase English letters).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int>v(26,0);\\n\\n        for(auto ch : s) v[ch-\\'a\\']++;\\n        set<int>st;\\n        int res = 0;\\n        sort(v.begin() , v.end() , greater<int>());\\n        // for(auto ele : v)cout<<ele<<\" \";\\n        for(auto ele : v){\\n            if(ele ==0)continue;\\n            if(st.find(ele) == st.end()) st.insert(ele);\\n            else{\\n                while(st.find(ele) != st.end() ){\\n                    ele--;\\n                    res++;\\n                }\\n                if(ele != 0)st.insert(ele);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int>v(26,0);\\n\\n        for(auto ch : s) v[ch-\\'a\\']++;\\n        set<int>st;\\n        int res = 0;\\n        sort(v.begin() , v.end() , greater<int>());\\n        // for(auto ele : v)cout<<ele<<\" \";\\n        for(auto ele : v){\\n            if(ele ==0)continue;\\n            if(st.find(ele) == st.end()) st.insert(ele);\\n            else{\\n                while(st.find(ele) != st.end() ){\\n                    ele--;\\n                    res++;\\n                }\\n                if(ele != 0)st.insert(ele);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4033441,
                "title": "using-map-simple-solution-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# PLEASE UPVOTE\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create a hash map to store the frequency of each character in the input string\\n        unordered_map<char, int> mp;\\n        int n = s.length(); // Get the length of the input string\\n        unordered_set<int> st; // Create an unordered set to track encountered frequencies\\n        \\n        // Count the frequency of each character in the input string\\n        for(int i = 0; i < n; i++) {\\n            mp[s[i]]++;\\n        }\\n        \\n        int ans = 0; // Initialize a variable to store the number of deletions\\n        \\n        // Iterate through the character frequencies in the map\\n        for(auto &it : mp) {\\n            int temp = it.second; // Get the frequency of the current character\\n            \\n            // Check if the current frequency is already in the set\\n            while(temp > 0 and st.find(temp) != st.end()) {\\n                ans++; // Increment the deletion count\\n                temp--; // Reduce the frequency\\n            }\\n            \\n            // Insert the updated frequency into the set to mark it as encountered\\n            st.insert(temp);\\n        }\\n        \\n        return ans; // Return the minimum number of deletions required\\n    }\\n};\\n\\n```\\n# PLEASE UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // Create a hash map to store the frequency of each character in the input string\\n        unordered_map<char, int> mp;\\n        int n = s.length(); // Get the length of the input string\\n        unordered_set<int> st; // Create an unordered set to track encountered frequencies\\n        \\n        // Count the frequency of each character in the input string\\n        for(int i = 0; i < n; i++) {\\n            mp[s[i]]++;\\n        }\\n        \\n        int ans = 0; // Initialize a variable to store the number of deletions\\n        \\n        // Iterate through the character frequencies in the map\\n        for(auto &it : mp) {\\n            int temp = it.second; // Get the frequency of the current character\\n            \\n            // Check if the current frequency is already in the set\\n            while(temp > 0 and st.find(temp) != st.end()) {\\n                ans++; // Increment the deletion count\\n                temp--; // Reduce the frequency\\n            }\\n            \\n            // Insert the updated frequency into the set to mark it as encountered\\n            st.insert(temp);\\n        }\\n        \\n        return ans; // Return the minimum number of deletions required\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033239,
                "title": "c-o-n-time-o-1-space-solution-explained",
                "content": "# Intuition: Greedily take the maximum possible frequency for each character\\n\\n# Approach: If a characters frequency is used, decrement it to the closest unused frequency\\n\\n**1. Count Frequencys for each character**\\n- This is essential as the whole question is based around the frequencys opf characters\\n- we will store these in a hashmap of <char, int> pairs\\n- a slight optimization is to use a vector of size 26 to represent every charcater, however for simplicity this soloution utilises a hashmap\\n```\\nunordered_map<char,int> hmap;\\nfor(char c : s) hmap[c]++;\\n```\\n\\nLets step through an example of this process\\n```\\ns = \"aaabbbcc\"\\n\\nhashmap:\\n    a : 3\\n    b : 3\\n    c : 2\\n```\\n\\n**2. Iterate through our hashmap and see if this freuency has been used or we need to make deletions**\\n- This is done in a some what greedy approach. If a characters frequency is unused, it takes it straight away. Otherwie we decrement its count by 1 untill it reaches an unused frequency or it becomes 0. We keep track of the deletions we do\\n- We will use another hashmap, this time a set to keep track of the used frequencys. A set is used as it has O(1) lookup time to see if a frequency has been used, aswell as O(1) insertion when we use a new frequency\\n```\\n // iterate through hmap\\nfor(auto& [c, freq] : hmap) {\\n\\n    // decrement untill we find a unused frequency or it becomes -\\n    while(used.count(freq) && freq > 0) {\\n        count++; // increment deletions\\n        freq--; // decrement frequency of this character since we are removing one\\n    }\\n    // insert this valid frequency\\n        if(freq > 0)used.insert(freq);\\n}\\n```\\n\\n- lets continue our example to illustrate this process\\n```\\nhashmap = a : 3, b : 3, c : 2\\nused = \\n\\nFIRST ITERATION\\n    character = a\\n    freq = 3\\n    3 has not been used so we add it to our set\\n\\nSECOND ITERATION\\nused = 3\\n\\n    character = b\\n    freq = 3\\n\\n    3 has been used so we decrement it\\n    freq = 2                        decrements = 1\\n\\n    2 has not been used so we place it in the used set\\n\\nTHIRD ITERATION\\nused = 3, 2\\n\\n    character = c\\n    freq = 2\\n\\n    2 has been used so we decrement it\\n    freq = 1                        decrements = 2\\n\\n    1 has not been used so we add it to our used set\\n\\nFINAL:\\ndecrements = 2\\nused = 3 , 2 , 1\\n\\n```\\n\\nafter this process we can return the number of decrements we had to make\\n\\n# Complexity\\n**Time complexity: O(n)**  \\n- we iterate through input string of size n = O(n)\\n- iterating through hashmap is O(26) in the worst case when every character is a unique lower case = O(26) = O(1)\\n- Set lookups and insertions are O(1)\\n\\n**Space complexity: O(1)**\\n- we always use a hashmap which in the worst case contains 26 characters (every lower case letter) = O(26) = O(1)\\n- The set will never exceed size 26 since if we only have 26 characters it is impossible to have more then 26 unique frequencys = O(26) = O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // store frequencys of every character\\n        unordered_map<char,int> hmap;\\n        for(char c : s) hmap[c]++;\\n\\n        // used frequencys set\\n        unordered_set<int> used;\\n\\n        int deletions = 0;  // counter of how many deletions we need to do\\n\\n        // iterate through hmap\\n        for(auto& [c, freq] : hmap) {\\n\\n            // decrement untill we find a unused frequency or it becomes -\\n            while(used.count(freq) && freq > 0) {\\n                deletions++; // increment deletions\\n                freq--; // decrement frequency of this character since we are removing one\\n            }\\n            // insert this valid frequency\\n            if(freq > 0)used.insert(freq);\\n        }\\n\\n        return deletions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nunordered_map<char,int> hmap;\\nfor(char c : s) hmap[c]++;\\n```\n```\\ns = \"aaabbbcc\"\\n\\nhashmap:\\n    a : 3\\n    b : 3\\n    c : 2\\n```\n```\\n // iterate through hmap\\nfor(auto& [c, freq] : hmap) {\\n\\n    // decrement untill we find a unused frequency or it becomes -\\n    while(used.count(freq) && freq > 0) {\\n        count++; // increment deletions\\n        freq--; // decrement frequency of this character since we are removing one\\n    }\\n    // insert this valid frequency\\n        if(freq > 0)used.insert(freq);\\n}\\n```\n```\\nhashmap = a : 3, b : 3, c : 2\\nused = \\n\\nFIRST ITERATION\\n    character = a\\n    freq = 3\\n    3 has not been used so we add it to our set\\n\\nSECOND ITERATION\\nused = 3\\n\\n    character = b\\n    freq = 3\\n\\n    3 has been used so we decrement it\\n    freq = 2                        decrements = 1\\n\\n    2 has not been used so we place it in the used set\\n\\nTHIRD ITERATION\\nused = 3, 2\\n\\n    character = c\\n    freq = 2\\n\\n    2 has been used so we decrement it\\n    freq = 1                        decrements = 2\\n\\n    1 has not been used so we add it to our used set\\n\\nFINAL:\\ndecrements = 2\\nused = 3 , 2 , 1\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // store frequencys of every character\\n        unordered_map<char,int> hmap;\\n        for(char c : s) hmap[c]++;\\n\\n        // used frequencys set\\n        unordered_set<int> used;\\n\\n        int deletions = 0;  // counter of how many deletions we need to do\\n\\n        // iterate through hmap\\n        for(auto& [c, freq] : hmap) {\\n\\n            // decrement untill we find a unused frequency or it becomes -\\n            while(used.count(freq) && freq > 0) {\\n                deletions++; // increment deletions\\n                freq--; // decrement frequency of this character since we are removing one\\n            }\\n            // insert this valid frequency\\n            if(freq > 0)used.insert(freq);\\n        }\\n\\n        return deletions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209612,
                "title": "python-greedy-explained",
                "content": "We are going to create a counter to count the number of times each character occurred in the string.\\n\\nWe will also have a set `filled` that is going to save the frequencies that we already \"used\". Meaning that some character that we already processed has that number of occurrences, so we need to delete occurrences from the current character.\\n\\nWe will greedily subtract `counter[c] -=1` until we reach a frequency that wasn\\'t added.\\n\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counter = Counter(s)\\n        filled = set()\\n        deletions = 0\\n        \\n        for c in counter.keys():\\n            while counter[c] in filled and counter[c] != 0:\\n                deletions += 1\\n                counter[c] -= 1\\n            filled.add(counter[c])\\n        \\n        return deletions\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counter = Counter(s)\\n        filled = set()\\n        deletions = 0\\n        \\n        for c in counter.keys():\\n            while counter[c] in filled and counter[c] != 0:\\n                deletions += 1\\n                counter[c] -= 1\\n            filled.add(counter[c])\\n        \\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208226,
                "title": "minimum-deletions-to-make-character-frequencies-unique-java-solution",
                "content": "**Approach:**\\n* Store the frequencies of each character in the string.\\n* Sort the frequency array in ascending order.\\n* Store the maximum frequency of character i.e. keep=f[25].\\n* Store the previous frequency i.e. prev=keep.\\n* Iterate through the frequency array from f[24]....f[0].\\n* for each element from 24 to 0, store the minimum out of prev frquency-1 and f[i] in prev.\\n* and add prev to keep.(P.s: keep variable is for no of elements we are choosing to keep)\\n* return the total no of characters in string - keep. \\n```\\nclass Solution \\n{\\n    public int minDeletions(String s) \\n    {\\n        int freq[] = new int[26];\\n        for (char c : s.toCharArray())\\n            freq[c - \\'a\\']++;\\n        Arrays.sort(freq);\\n        int keep = freq[25], prev = keep;\\n        for (int i = 24; i >= 0 && freq[i] != 0 && prev != 0; i--) \\n        {\\n            prev = Math.min(freq[i], prev - 1);\\n            keep += prev;\\n        }\\n        return s.length() - keep;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minDeletions(String s) \\n    {\\n        int freq[] = new int[26];\\n        for (char c : s.toCharArray())\\n            freq[c - \\'a\\']++;\\n        Arrays.sort(freq);\\n        int keep = freq[25], prev = keep;\\n        for (int i = 24; i >= 0 && freq[i] != 0 && prev != 0; i--) \\n        {\\n            prev = Math.min(freq[i], prev - 1);\\n            keep += prev;\\n        }\\n        return s.length() - keep;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207985,
                "title": "java-most-simple-and-understandable-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int arr[] = new int[26];\\n      HashSet<Integer> set = new HashSet<>();\\n      for(char ch : s.toCharArray()) {\\n        arr[ch - \\'a\\'] ++;\\n      }\\n      int deletion = 0;\\n      for(int val : arr) {\\n        while(val != 0 && set.contains(val)){\\n            val --;\\n            deletion ++;\\n        }\\n        set.add(val);\\n      }\\n      return deletion;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int minDeletions(String s) {\\n        int arr[] = new int[26];\\n      HashSet<Integer> set = new HashSet<>();\\n      for(char ch : s.toCharArray()) {\\n        arr[ch - \\'a\\'] ++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2207827,
                "title": "c-using-2-maps",
                "content": "First of all store the characters in  a map . Them store the count of the map elements in another map(map2) if any element in map2 has count >1 then we need to reduce the number of count from map1 and map2 and add the reduced number in map2 and paralelly we will increse the counter(c) as long as we are reducing the characters.\\n\\nFor an example,\\n\\nceabaacb->\\n(in map1)\\na-3\\nb-2\\nc-2\\ne-1\\n(in map2)\\n1-1\\n2-2\\n3-1\\n\\nwe need to reduce the char b or c so decrease it from map1 and map 2 \\nafter 1 iteration\\n(in map1)\\na-3\\nb-1\\nc-2\\ne-1\\n(in map2)\\n1-2\\n2-1\\n3-1\\nagain we need to reduce since we r getting the count of 1 as 2\\nin this way we do this operatins\\n(in map1)\\na-3\\nb-0\\nc-2\\ne-1\\n(in map2)\\n0-1\\n1-1\\n2-1\\n3-1\\nso in map 1 we dont have equal frequency of elements.\\nFor more clear idea head over to the code given below ;)\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n         map<char,int>m;\\n        for(int i=0;i<s.size();i++){\\n            m[s[i]]++;\\n        }\\n        map<int,int>m1;\\n        \\n        for(auto i:m){\\n            m1[i.second]++;\\n        }\\n        sort(s.begin(),s.end());\\n        int c=0;\\n        for(int i=0;i<s.size();i++){\\n            if(m1[m[s[i]]]>1){\\n                c++;\\n                m1[m[s[i]]]--;\\n                m[s[i]]--;\\n                m1[m[s[i]]]++;                \\n            }   \\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n         map<char,int>m;\\n        for(int i=0;i<s.size();i++){\\n            m[s[i]]++;\\n        }\\n        map<int,int>m1;\\n        \\n        for(auto i:m){\\n            m1[i.second]++;\\n        }\\n        sort(s.begin(),s.end());\\n        int c=0;\\n        for(int i=0;i<s.size();i++){\\n            if(m1[m[s[i]]]>1){\\n                c++;\\n                m1[m[s[i]]]--;\\n                m[s[i]]--;\\n                m1[m[s[i]]]++;                \\n            }   \\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809634,
                "title": "100-faster-solution-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> v(26,0);\\n        for(auto i:s) v[i-\\'a\\']++;\\n        sort(v.begin(),v.end());\\n        int ans{};\\n        for(int i=v.size()-1;i>=1 && v[i];i--){\\n            int j=i-1;\\n            while(j>=0 && v[i]==v[j]){\\n                v[j--]--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> v(26,0);\\n        for(auto i:s) v[i-\\'a\\']++;\\n        sort(v.begin(),v.end());\\n        int ans{};\\n        for(int i=v.size()-1;i>=1 && v[i];i--){\\n            int j=i-1;\\n            while(j>=0 && v[i]==v[j]){\\n                v[j--]--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722726,
                "title": "python-easy-to-understand-using-collections-counter-o-n-running-time-o-n-space-using-set",
                "content": "Intuition - Greedy\\n1) Use counter() to get all frequencies\\n2) Initialize and empty set where you want to update the unique frequencies\\n3) Iterate each frequency, if that freq is present in unique set, decrease till you get an unique (or till 0)\\n4) Update the deletions along with the freq decrease\\n5) Add the new frequency to your unique set\\n\\nThat\\'s it.\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        #Find the freq of all characters\\n        #Iterate the freq\\n        #For each freq, keep decreasing freq till its unique and update counter (Compare with set for uniqueness)\\n        \\n        freq = Counter(s)\\n        \\n        #Set to maintain unique frequencies\\n        u_freq = set()\\n        \\n        #Counter for deletions\\n        ctr = 0\\n        \\n        for c, f in freq.items():\\n            while f > 0 and f in u_freq:\\n                f -= 1\\n                ctr += 1\\n            u_freq.add(f)\\n        \\n        return ctr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        #Find the freq of all characters\\n        #Iterate the freq\\n        #For each freq, keep decreasing freq till its unique and update counter (Compare with set for uniqueness)\\n        \\n        freq = Counter(s)\\n        \\n        #Set to maintain unique frequencies\\n        u_freq = set()\\n        \\n        #Counter for deletions\\n        ctr = 0\\n        \\n        for c, f in freq.items():\\n            while f > 0 and f in u_freq:\\n                f -= 1\\n                ctr += 1\\n            u_freq.add(f)\\n        \\n        return ctr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606333,
                "title": "java-10ms-solution-using-priority-queue-max-heap",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        if(s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray()) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b-a);\\n        for(int num : freq) {\\n            if(num>0) {\\n                pq.offer(num);\\n            }\\n        }\\n        int min = 0;\\n        while(!pq.isEmpty()) {\\n            int top = pq.poll();\\n            if(!pq.isEmpty() && top == pq.peek()) {\\n                top = top-1;\\n                if(top>0) {\\n                    pq.offer(top);\\n                }\\n                min++;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        if(s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray()) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b-a);\\n        for(int num : freq) {\\n            if(num>0) {\\n                pq.offer(num);\\n            }\\n        }\\n        int min = 0;\\n        while(!pq.isEmpty()) {\\n            int top = pq.poll();\\n            if(!pq.isEmpty() && top == pq.peek()) {\\n                top = top-1;\\n                if(top>0) {\\n                    pq.offer(top);\\n                }\\n                min++;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508008,
                "title": "python-greedy-method-easy-to-understand",
                "content": "Use a set to record the frequencies already existed.\\nUse collections.Counter() to get the frequency of each character\\n\\nThen loop through frequencies in the dictionary\\nHere we only need to verify whether the current frequency already existed in the set.\\nIf so, keep reducing the current frequency by 1 (till we reach **zero**) and increasing the count by 1\\nOtherwise, add the qulified frequency into the set \\nLastly, return the count\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = 0\\n        seen = set()\\n        for freq in collections.Counter(s).values():\\n            while freq > 0 and freq in seen:\\n                freq -= 1\\n                cnt += 1\\n            seen.add(freq)\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        cnt = 0\\n        seen = set()\\n        for freq in collections.Counter(s).values():\\n            while freq > 0 and freq in seen:\\n                freq -= 1\\n                cnt += 1\\n            seen.add(freq)\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347684,
                "title": "easy-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        \\n        vector<int>v(26);\\n        \\n        for(auto x: s){\\n            v[x-\\'a\\']++;  // storing the frequency of letters\\n        }\\n        \\n//         sorting in decending order\\n        sort(v.begin(),v.end(),greater<int>());\\n        \\n        int freq=v[0]; // max freq allowed\\n        int ans=0;\\n        \\n        for(auto x:v){\\n            if(x > freq){\\n//                 it means decreament of character is required\\n                if(freq >0)\\n                  ans+=(x-freq);\\n                \\n                else\\n//                     if my freq becomes 0 than entire freq of character is to be removed\\n                ans+=x;\\n            }\\n            \\n            freq=min(freq-1,x-1); // for cases like\\n//             a->10\\n//             b->4\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletions(string s) {\\n        \\n        vector<int>v(26);\\n        \\n        for(auto x: s){\\n            v[x-\\'a\\']++;  // storing the frequency of letters\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1106671,
                "title": "javascript-solution",
                "content": "```\\nvar minDeletions = function(s) {\\n    let dict = {};\\n    \\n    for (let char of s) {\\n        dict[char] ? dict[char] += 1: dict[char] = 1;\\n    }\\n    \\n    let arr = Object.values(dict).sort((a, b) => a - b);\\n    let seen = new Set();\\n    let deletions = 0;\\n    \\n    for (let count of arr) {\\n        if (!seen.has(count)) seen.add(count);\\n        else {\\n            while (seen.has(count)) {\\n                count--;\\n                deletions++;\\n            }\\n            if (count > 0) seen.add(count);\\n        }\\n    }\\n    return deletions;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDeletions = function(s) {\\n    let dict = {};\\n    \\n    for (let char of s) {\\n        dict[char] ? dict[char] += 1: dict[char] = 1;\\n    }\\n    \\n    let arr = Object.values(dict).sort((a, b) => a - b);\\n    let seen = new Set();\\n    let deletions = 0;\\n    \\n    for (let count of arr) {\\n        if (!seen.has(count)) seen.add(count);\\n        else {\\n            while (seen.has(count)) {\\n                count--;\\n                deletions++;\\n            }\\n            if (count > 0) seen.add(count);\\n        }\\n    }\\n    return deletions;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069236,
                "title": "c-used-map-and-vectors",
                "content": "step 1 : Count the Frequencies of elements\\nstep 2 : store the frequency for frequency of chars ...... ( Think abt it ) ----> use ordered_map.\\nstep 3 : Traverse map from backwards , and make the freq_count[i] = 1 ,\\nthis would increase the freq_count[i-1]\\'s frequency .\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // step1 count the frequencies\\n        vector<int> counter(26,0);\\n        for(auto it : s){\\n            counter[it-\\'a\\'] ++;\\n        }\\n        \\n        // step2 , store the freq. elements\\n        map <int,int> freq_count;\\n        \\n        for(int i = 0; i < 26; i++){\\n            freq_count[counter[i]] ++;\\n        }\\n        \\n        int ans = 0;\\n        // Traverse from backwards\\n        for(auto it = freq_count.rbegin(); it != freq_count.rend(); it++){\\n            \\n            int key = it->first;\\n            int value = it->second;\\n            \\n            if(value == 1 || key == 0){\\n                continue;\\n            }\\n            int new_val = value-1;\\n            freq_count[key - 1] += new_val;\\n            ans += new_val;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // step1 count the frequencies\\n        vector<int> counter(26,0);\\n        for(auto it : s){\\n            counter[it-\\'a\\'] ++;\\n        }\\n        \\n        // step2 , store the freq. elements\\n        map <int,int> freq_count;\\n        \\n        for(int i = 0; i < 26; i++){\\n            freq_count[counter[i]] ++;\\n        }\\n        \\n        int ans = 0;\\n        // Traverse from backwards\\n        for(auto it = freq_count.rbegin(); it != freq_count.rend(); it++){\\n            \\n            int key = it->first;\\n            int value = it->second;\\n            \\n            if(value == 1 || key == 0){\\n                continue;\\n            }\\n            int new_val = value-1;\\n            freq_count[key - 1] += new_val;\\n            ans += new_val;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067770,
                "title": "simple-java-solution-o-n-time-o-1-space",
                "content": "\\n```\\n    public int minDeletions(String s) {\\n        // to hold frequencies\\n        int[] freq = new int[26];\\n        \\n        for(char c: s.toCharArray()) {\\n            freq[c - \\'a\\'] += 1;\\n        }\\n        \\n        // to make sure of unique frequencies, if not adjust\\n        int deletions = 0;\\n        HashSet<Integer> freqSet = new HashSet<>();\\n        for (int i = 0; i < freq.length; i++) {\\n            // subtract till it\\'s unique\\n            while(freq[i] != 0 && freqSet.contains(freq[i])) {\\n                freq[i]--;\\n                deletions++;\\n            }\\n            freqSet.add(freq[i]);\\n        }\\n        \\n        return deletions;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minDeletions(String s) {\\n        // to hold frequencies\\n        int[] freq = new int[26];\\n        \\n        for(char c: s.toCharArray()) {\\n            freq[c - \\'a\\'] += 1;\\n        }\\n        \\n        // to make sure of unique frequencies, if not adjust\\n        int deletions = 0;\\n        HashSet<Integer> freqSet = new HashSet<>();\\n        for (int i = 0; i < freq.length; i++) {\\n            // subtract till it\\'s unique\\n            while(freq[i] != 0 && freqSet.contains(freq[i])) {\\n                freq[i]--;\\n                deletions++;\\n            }\\n            freqSet.add(freq[i]);\\n        }\\n        \\n        return deletions;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034272,
                "title": "python-java-c-100-map",
                "content": "```Python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counts=Counter(s)\\n        res=0\\n        set1=set()\\n        for i in counts:\\n            frec=counts[i]\\n            if frec  in set1:\\n                while frec in set1 and frec>0: \\n                    frec-=1\\n                    res+=1\\n                    \\n            set1.add(frec)         \\n        return res\\n```\\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        if(s.length() == 0) return  0 ;\\n            \\n        int[] arr = new int[26] ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i) ;\\n            arr[ch - \\'a\\'] ++ ;\\n        }\\n        HashSet<Integer> mp = new HashSet<>() ;\\n        int count = 0 ;\\n        for(int i = 0 ; i < 26 ; i++){\\n            int f = arr[i] ;\\n            \\n            if(! mp.contains(f) )\\n                mp.add(f) ;\\n            else{\\n                while(f > 0 &&  mp.contains(f) ){\\n                    f -- ;\\n                    count ++ ;\\n                }\\n                mp.add(f) ;\\n            }\\n        }\\n        return count ;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        map<int , vector<char> , greater<int>> m;\\n        int curr = 1;\\n        unordered_map<char , int> mp;\\n        for(int i =0 ; i< s.size() ; i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto e : mp){\\n            m[e.second].push_back(e.first);\\n        }\\n        int count = 0;\\n        for( auto e : m){\\n            if(e.second.size() > 1){\\n                for( int i = 1 ; i< e.second.size() ; i++ ){\\n                    if( e.first > 0){\\n                        m[e.first-1].push_back(e.second[i]);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counts=Counter(s)\\n        res=0\\n        set1=set()\\n        for i in counts:\\n            frec=counts[i]\\n            if frec  in set1:\\n                while frec in set1 and frec>0: \\n                    frec-=1\\n                    res+=1\\n                    \\n            set1.add(frec)         \\n        return res\\n```\n```Java []\\nclass Solution {\\n    public int minDeletions(String s) {\\n        if(s.length() == 0) return  0 ;\\n            \\n        int[] arr = new int[26] ;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            char ch = s.charAt(i) ;\\n            arr[ch - \\'a\\'] ++ ;\\n        }\\n        HashSet<Integer> mp = new HashSet<>() ;\\n        int count = 0 ;\\n        for(int i = 0 ; i < 26 ; i++){\\n            int f = arr[i] ;\\n            \\n            if(! mp.contains(f) )\\n                mp.add(f) ;\\n            else{\\n                while(f > 0 &&  mp.contains(f) ){\\n                    f -- ;\\n                    count ++ ;\\n                }\\n                mp.add(f) ;\\n            }\\n        }\\n        return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033570,
                "title": "most-detailed-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### [https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()\\n### [https://www.instagram.com/pratay_nandy/]()\\n# Approach\\nC++ code is for solving a problem where you are given a string s, and you need to find the minimum number of deletions required to make all characters in the string have unique frequencies. In other words, you want to minimize the number of character deletions such that no two characters have the same frequency in the string.\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\n```\\nint charFreq[26] = {};\\n```\\n- This line initializes an array charFreq of size 26 to store the frequency of each character in the English alphabet. Each element in the array corresponds to a character (\\'a\\' to \\'z\\').\\n```\\nint deletionCount = 0;\\n```\\n- This variable deletionCount is used to keep track of the total number of deletions required.\\n\\nLoop to count character frequencies:\\n\\n\\n```\\nfor (char c : s) {\\n    ++charFreq[c - \\'a\\'];\\n}\\n```\\n- This loop iterates through the characters of the input string s. For each character c, it increments the corresponding frequency in the charFreq array. The expression c - \\'a\\' is used to convert the character c to an index in the charFreq array. This works because \\'a\\' has an ASCII value of 97, and \\'a\\' - \\'a\\' equals 0, \\'b\\' - \\'a\\' equals 1, and so on. Therefore, it maps characters \\'a\\' to \\'z\\' to indices 0 to 25 in the array.\\n\\n```\\nsort(begin(charFreq), end(charFreq));\\n```\\n- After counting the character frequencies, the code sorts the charFreq array in ascending order. Sorting the frequencies will help in the next step when we try to make them unique.\\n\\nLoop to calculate deletions:\\n```\\nfor (int i = 24; i >= 0 && charFreq[i] > 0; --i) {\\n    int deletions = charFreq[i] - max(0, charFreq[i + 1] - 1);\\n    deletionCount += max(0, deletions);\\n    charFreq[i] = min(charFreq[i], max(0, charFreq[i + 1] - 1));\\n}\\n```\\n- This loop starts from the second to last element of the sorted charFreq array and moves towards the first element. The loop continues until it reaches the first element with a frequency greater than 0.\\n```\\n int deletions = charFreq[i] - max(0, charFreq[i + 1] - 1);\\n```\\n- This line calculates the number of deletions required to make the frequency of the current character unique. It does this by taking the difference between the current character\\'s frequency (charFreq[i]) and the maximum of 0 and the next character\\'s frequency minus 1 (charFreq[i + 1] - 1). This is done to ensure that the frequency remains non-negative.\\n\\n```\\ndeletionCount += max(0, deletions);\\n```\\n- This line adds the calculated deletions to the total deletionCount. It uses max(0, deletions) to ensure that only positive values are added.\\n\\n```\\ncharFreq[i] = min(charFreq[i], max(0, charFreq[i + 1] - 1));\\n```\\n- This line updates the current character\\'s frequency in the charFreq array to be the minimum of its current frequency and the maximum of 0 and the next character\\'s frequency minus 1. This step ensures that the current character\\'s frequency is made unique.\\n\\n- Finally, the function returns the deletionCount, which represents the minimum number of deletions required to make all character frequencies unique.\\n\\nIn summary, this code counts the frequencies of characters in the input string, sorts them in ascending order, and then iterates through the sorted frequencies to calculate the minimum deletions needed to make each frequency unique. It accumulates the deletions in deletionCount and returns the result.\\n\\n# Complexity\\n- Time complexity:***O(N)** *\\n the sorting step does indeed have a time complexity of O(26 * log(26)), which simplifies to O(1) not 0(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:***0(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n    int cnt[26] = {}, res = 0;\\n    for (char ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    sort(begin(cnt), end(cnt));\\n    for (int i = 24; i >= 0 && cnt[i] > 0; --i) {\\n        res += max(0, cnt[i] - max(0, cnt[i + 1] - 1));\\n        cnt[i] = min(cnt[i], max(0, cnt[i + 1] - 1));\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nint charFreq[26] = {};\\n```\n```\\nint deletionCount = 0;\\n```\n```\\nfor (char c : s) {\\n    ++charFreq[c - \\'a\\'];\\n}\\n```\n```\\nsort(begin(charFreq), end(charFreq));\\n```\n```\\nfor (int i = 24; i >= 0 && charFreq[i] > 0; --i) {\\n    int deletions = charFreq[i] - max(0, charFreq[i + 1] - 1);\\n    deletionCount += max(0, deletions);\\n    charFreq[i] = min(charFreq[i], max(0, charFreq[i + 1] - 1));\\n}\\n```\n```\\n int deletions = charFreq[i] - max(0, charFreq[i + 1] - 1);\\n```\n```\\ndeletionCount += max(0, deletions);\\n```\n```\\ncharFreq[i] = min(charFreq[i], max(0, charFreq[i + 1] - 1));\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n    int cnt[26] = {}, res = 0;\\n    for (char ch : s)\\n        ++cnt[ch - \\'a\\'];\\n    sort(begin(cnt), end(cnt));\\n    for (int i = 24; i >= 0 && cnt[i] > 0; --i) {\\n        res += max(0, cnt[i] - max(0, cnt[i + 1] - 1));\\n        cnt[i] = min(cnt[i], max(0, cnt[i + 1] - 1));\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033278,
                "title": "simple-javascript-typescript-solution-with-and-without-sort",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n## With Sort\\n```typescript\\nconst minDeletions = (s: string): number => {\\n  const charCounter: { [char: string]: number } = {};\\n  for (const char of s) charCounter[char] = (charCounter[char] ?? 0) + 1;\\n  const counts = Object.values(charCounter).sort((a, b) => b - a);\\n  let minDeletions = 0;\\n  for (let i = 1; i < counts.length; i++) {\\n    if (counts[i] < counts[i - 1]) continue;\\n    const deletions = Math.min(counts[i], counts[i] - counts[i - 1] + 1);\\n    counts[i] -= deletions;\\n    minDeletions += deletions;\\n  }\\n  return minDeletions;\\n};\\n\\n```\\n\\n## Without Sort\\n```typescript\\nconst minDeletions = (s: string): number => {\\n  const charCounter: { [char: string]: number } = {};\\n  for (const char of s) charCounter[char] = (charCounter[char] ?? 0) + 1;\\n  const frequencies = new Set<number>();\\n  let minDeletions = 0;\\n  for (const count of Object.values(charCounter)) {\\n    let frequency = count;\\n    while (frequency && frequencies.has(frequency)) frequency--;\\n    minDeletions += count - frequency;\\n    frequencies.add(frequency);\\n  }\\n  return minDeletions;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nconst minDeletions = (s: string): number => {\\n  const charCounter: { [char: string]: number } = {};\\n  for (const char of s) charCounter[char] = (charCounter[char] ?? 0) + 1;\\n  const counts = Object.values(charCounter).sort((a, b) => b - a);\\n  let minDeletions = 0;\\n  for (let i = 1; i < counts.length; i++) {\\n    if (counts[i] < counts[i - 1]) continue;\\n    const deletions = Math.min(counts[i], counts[i] - counts[i - 1] + 1);\\n    counts[i] -= deletions;\\n    minDeletions += deletions;\\n  }\\n  return minDeletions;\\n};\\n\\n```\n```typescript\\nconst minDeletions = (s: string): number => {\\n  const charCounter: { [char: string]: number } = {};\\n  for (const char of s) charCounter[char] = (charCounter[char] ?? 0) + 1;\\n  const frequencies = new Set<number>();\\n  let minDeletions = 0;\\n  for (const count of Object.values(charCounter)) {\\n    let frequency = count;\\n    while (frequency && frequencies.has(frequency)) frequency--;\\n    minDeletions += count - frequency;\\n    frequencies.add(frequency);\\n  }\\n  return minDeletions;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3482903,
                "title": "awesome-solution-c",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> v(26,0);\\n        int l=s.size();\\n        for(int i=0;i<l;i++){\\n            v[int(s[i])-97]+=1;\\n        }\\n        int maxx=0;\\n\\n        for(int i=0;i<26;i++){\\n            maxx=max(maxx,v[i]);\\n        }\\n        vector<int> ar(maxx+1,0);\\n        for(int i=0;i<26;i++){\\n            ar[v[i]]+=v[i]>0?1:0;\\n        }\\n        int count=0;\\n        for(int i=maxx;i>=1;i--){\\n            \\n            if(ar[i]>1){\\n                count+=ar[i]-1;\\n                ar[i-1]+=ar[i]-1;\\n                ar[i]=1;\\n            }\\n            \\n        }    \\n        return count;                                                        \\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> v(26,0);\\n        int l=s.size();\\n        for(int i=0;i<l;i++){\\n            v[int(s[i])-97]+=1;\\n        }\\n        int maxx=0;\\n\\n        for(int i=0;i<26;i++){\\n            maxx=max(maxx,v[i]);\\n        }\\n        vector<int> ar(maxx+1,0);\\n        for(int i=0;i<26;i++){\\n            ar[v[i]]+=v[i]>0?1:0;\\n        }\\n        int count=0;\\n        for(int i=maxx;i>=1;i--){\\n            \\n            if(ar[i]>1){\\n                count+=ar[i]-1;\\n                ar[i-1]+=ar[i]-1;\\n                ar[i]=1;\\n            }\\n            \\n        }    \\n        return count;                                                        \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662784,
                "title": "python-easy-solution-for-beginners-using-hashmap",
                "content": "1. First we find the count of each and every element making use of a hashmap\\n2. We then define a variable res = 0 to store the count\\n3. We also make a set (used) to check if we have all unique elements.\\n4. We then make use of a while loop to check the condition\\n5. We make use of a while loop instead of making use of if condition because we may have to do more than 1 deletion operation.\\n6. If the value is greater than 0 and if it already exists in the set (used) then increment the result and decrement the value by 1.\\n7. Return the result.\\n\\n![image](https://assets.leetcode.com/users/images/1434b0e4-0dae-4413-8fb0-6bbcc31009c4_1664950120.01914.png)\\n\\n\\n        table = {}\\n        for i in s:\\n            if i in table:\\n                table[i] += 1\\n            else:\\n                table[i] = 1\\n                \\n        res = 0\\n        used = set() # for checking that we only hvae unique values \\n        for k,v in table.items():\\n            while v > 0 and v in used:\\n                v -= 1\\n                res += 1\\n            used.add(v)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "1. First we find the count of each and every element making use of a hashmap\\n2. We then define a variable res = 0 to store the count\\n3. We also make a set (used) to check if we have all unique elements.\\n4. We then make use of a while loop to check the condition\\n5. We make use of a while loop instead of making use of if condition because we may have to do more than 1 deletion operation.\\n6. If the value is greater than 0 and if it already exists in the set (used) then increment the result and decrement the value by 1.\\n7. Return the result.\\n\\n![image](https://assets.leetcode.com/users/images/1434b0e4-0dae-4413-8fb0-6bbcc31009c4_1664950120.01914.png)\\n\\n\\n        table = {}\\n        for i in s:\\n            if i in table:\\n                table[i] += 1\\n            else:\\n                table[i] = 1\\n                \\n        res = 0\\n        used = set() # for checking that we only hvae unique values \\n        for k,v in table.items():\\n            while v > 0 and v in used:\\n                v -= 1\\n                res += 1\\n            used.add(v)\\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 2284320,
                "title": "1ms-accepted-count-frequency-of-each-character",
                "content": "```\\nclass Solution {\\n\\tpublic int minDeletions(String s) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(freq);\\n\\n\\t\\tint sum = 0;\\n\\t\\tint max = s.length();\\n\\n\\t\\tfor (int i = 25; i >= 0 && freq[i] > 0; i--) {\\n\\t\\t\\tif (freq[i] > max) {\\n\\t\\t\\t\\tsum += freq[i] - max;\\n\\t\\t\\t\\tfreq[i] = max;\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(0, freq[i] - 1);\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int minDeletions(String s) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(freq);\\n\\n\\t\\tint sum = 0;\\n\\t\\tint max = s.length();\\n\\n\\t\\tfor (int i = 25; i >= 0 && freq[i] > 0; i--) {\\n\\t\\t\\tif (freq[i] > max) {\\n\\t\\t\\t\\tsum += freq[i] - max;\\n\\t\\t\\t\\tfreq[i] = max;\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(0, freq[i] - 1);\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211189,
                "title": "well-commented-guaranteed-easy-to-understand-approach-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char, int> mpp;\\n\\t\\t\\n        for(auto alphabet : s){ // store all the distinct alphabets with their frequencies in map\\n            mpp[alphabet]++;\\n        }\\n        \\n        multiset<int> len;\\n        for(auto it : mpp){ // store all the frequencies of distinct characters in multiset\\n            len.insert(it.second);\\n        }\\n        \\n        int cnt = 0; // this will keep count of deleted characters\\n        \\n        for(auto it : mpp){ // iterate over map\\n            char c = it.first;\\n            int freq = it.second;\\n            if(len.count(freq) > 1){ // if frequency of this char matches with another char then we reduce it\\'s freq\\n                len.erase(len.find(freq));\\n                while(len.find(freq) != len.end()){\\n                    freq--;\\n                    cnt++;\\n                }\\n                if(freq > 0) len.insert(freq); // suppose after reducing we get a non zero number which is not the freq of any other char, then we store it in the multiset so that no one else acquires the same frequency after reduction of another character\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\n**If you found it useful then please upvote, keep LeetCoding!**\\nIf you know the time complexity of the code then please tell because I was too lazy to figure it out XD",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char, int> mpp;\\n\\t\\t\\n        for(auto alphabet : s){ // store all the distinct alphabets with their frequencies in map\\n            mpp[alphabet]++;\\n        }\\n        \\n        multiset<int> len;\\n        for(auto it : mpp){ // store all the frequencies of distinct characters in multiset\\n            len.insert(it.second);\\n        }\\n        \\n        int cnt = 0; // this will keep count of deleted characters\\n        \\n        for(auto it : mpp){ // iterate over map\\n            char c = it.first;\\n            int freq = it.second;\\n            if(len.count(freq) > 1){ // if frequency of this char matches with another char then we reduce it\\'s freq\\n                len.erase(len.find(freq));\\n                while(len.find(freq) != len.end()){\\n                    freq--;\\n                    cnt++;\\n                }\\n                if(freq > 0) len.insert(freq); // suppose after reducing we get a non zero number which is not the freq of any other char, then we store it in the multiset so that no one else acquires the same frequency after reduction of another character\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208850,
                "title": "c-greedy-approach-o-26-space-with-dry-run",
                "content": "**Code:**\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26); // take a frequency array\\n        for(auto& ch:s) freq[ch-\\'a\\']++; // find freqency of each alphabate\\n        sort(freq.begin(),freq.end()); // sort the freq array\\n        // now traverse from the back of freq array\\n        int max=freq[25],res=0;\\n        for(int i=24;i>=0;i--){\\n            if(freq[i]==0) break;\\n            if(freq[i]>=max){\\n                int diff;\\n                if(max==0) diff=freq[i]; // if max is already 0, then freq[i] is gonna be 0 also\\n                else diff=(freq[i]-max+1); // else freq[i] is gonna be less than 1 from max\\n                freq[i]-=diff; // update freq\\n                res+=diff; // add diff with res\\n            }\\n            max=freq[i]; // update max\\n        }\\n        return res;\\n    }\\n};\\n```\\n```\\nTC: O(NlogN)\\nSC: O(26)\\n```\\n\\n**Let\\'s have a dry run:**\\nfor example, freq array is like :  `11144566`\\nThen iteration wise updating the freq array is given below:-\\nmax=6  res=0 [initilization]\\n```\\n11144566     -> freq[i]=6    max=6   diff=6-6+1=1     res=0+1=1  freq[i]=6-1=5 \\n11144556     -> freq[i]=5    max=5   diff=5-5+1=1     res=1+1=2  freq[i]=5-1=4\\n11144456     -> freq[i]=4    max=4   diff=4-4+1=1     res=2+1=3  freq[i]=4-1=3\\n11143456     -> freq[i]=4    max=3   diff=4-3+1=2     res=3+2=5  freq[i]=4-2=2\\n11123456     -> freq[i]=1    max=2   (max>freq[i])    res=5      freq[i]=1\\n11123456     -> freq[i]=1    max=1   diff=1-1+1=1     res=5+1=6  freq[i]=1-1=0\\n10123456     -> freq[i]=1   [max=0]  diff=1-0=1       res=6+1=7  freq[i]=1-1=0\\n00123456     -> this is the final form and the res=7\\n```\\n\\n**If you like it, Do a Upvote!**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26); // take a frequency array\\n        for(auto& ch:s) freq[ch-\\'a\\']++; // find freqency of each alphabate\\n        sort(freq.begin(),freq.end()); // sort the freq array\\n        // now traverse from the back of freq array\\n        int max=freq[25],res=0;\\n        for(int i=24;i>=0;i--){\\n            if(freq[i]==0) break;\\n            if(freq[i]>=max){\\n                int diff;\\n                if(max==0) diff=freq[i]; // if max is already 0, then freq[i] is gonna be 0 also\\n                else diff=(freq[i]-max+1); // else freq[i] is gonna be less than 1 from max\\n                freq[i]-=diff; // update freq\\n                res+=diff; // add diff with res\\n            }\\n            max=freq[i]; // update max\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nTC: O(NlogN)\\nSC: O(26)\\n```\n```\\n11144566     -> freq[i]=6    max=6   diff=6-6+1=1     res=0+1=1  freq[i]=6-1=5 \\n11144556     -> freq[i]=5    max=5   diff=5-5+1=1     res=1+1=2  freq[i]=5-1=4\\n11144456     -> freq[i]=4    max=4   diff=4-4+1=1     res=2+1=3  freq[i]=4-1=3\\n11143456     -> freq[i]=4    max=3   diff=4-3+1=2     res=3+2=5  freq[i]=4-2=2\\n11123456     -> freq[i]=1    max=2   (max>freq[i])    res=5      freq[i]=1\\n11123456     -> freq[i]=1    max=1   diff=1-1+1=1     res=5+1=6  freq[i]=1-1=0\\n10123456     -> freq[i]=1   [max=0]  diff=1-0=1       res=6+1=7  freq[i]=1-1=0\\n00123456     -> this is the final form and the res=7\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208780,
                "title": "minimum-deletion-greedy-set-easy-understanding",
                "content": "Hi,\\n\\nFrom the question we understand that the problem is to delete the charecters in the given string such that frequecy of each charecter is unique.\\n\\nKnown facts:\\n1. we know that there are only 26 charecters\\n2. we know to maintain unique values -> set could be the best option.\\n\\nApproach:\\n1. First things first, we will find the frequency of all the charecters in the given string by itrating through the string and increasing a array.\\n2. Next we can maintain a set and see if that particular frequency is already available in that set, if yes then try to remove the frequency by one and increase the result by 1.\\n3. Repeat the step 2 till we get a unique frequency and till the frequency is greater than 0.\\n4. Return the result after itrating through all the frequencies.\\n\\nHope this is helpful, kindly upvote if you reached till this point..\\n\\nLets look at the code now..\\n```\\n    public int minDeletions(String s) {\\n        int[] alpha = new int[26];\\n        for(char ch: s.toCharArray()){\\n        \\talpha[ch-\\'a\\']++;\\n        }\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        int res=0;\\n        for(int i:alpha){\\n        \\twhile(set.contains(i) && i>0){\\n        \\t\\ti--;\\n        \\t\\tres++;\\n        \\t}\\n        \\tset.add(i);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "Hi,\\n\\nFrom the question we understand that the problem is to delete the charecters in the given string such that frequecy of each charecter is unique.\\n\\nKnown facts:\\n1. we know that there are only 26 charecters\\n2. we know to maintain unique values -> set could be the best option.\\n\\nApproach:\\n1. First things first, we will find the frequency of all the charecters in the given string by itrating through the string and increasing a array.\\n2. Next we can maintain a set and see if that particular frequency is already available in that set, if yes then try to remove the frequency by one and increase the result by 1.\\n3. Repeat the step 2 till we get a unique frequency and till the frequency is greater than 0.\\n4. Return the result after itrating through all the frequencies.\\n\\nHope this is helpful, kindly upvote if you reached till this point..\\n\\nLets look at the code now..\\n```\\n    public int minDeletions(String s) {\\n        int[] alpha = new int[26];\\n        for(char ch: s.toCharArray()){\\n        \\talpha[ch-\\'a\\']++;\\n        }\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        int res=0;\\n        for(int i:alpha){\\n        \\twhile(set.contains(i) && i>0){\\n        \\t\\ti--;\\n        \\t\\tres++;\\n        \\t}\\n        \\tset.add(i);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2208006,
                "title": "c-code-using-vector-set-and-easy-to-understand",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int l=s.size();\\n        int del=0;\\n        if(l==1)return 0;\\n        vector<int>v(26,0);\\n        for(int i=0;i<l;i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        sort(v.begin(),v.end());\\n        unordered_set<int>se;\\n        for(int i=0;i<26;i++){\\n            se.insert(v[i]);\\n        }\\n        for(int i=0;i<25;i++){\\n            if(v[i]==v[i+1]){\\n                int temp=v[i];\\n                while(se.find(temp)!=se.end() && temp>0){\\n                    temp--;\\n                }\\n                se.insert(temp);\\n                del+=v[i]-temp;\\n            }\\n        }\\n        return del;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int l=s.size();\\n        int del=0;\\n        if(l==1)return 0;\\n        vector<int>v(26,0);\\n        for(int i=0;i<l;i++){\\n            v[s[i]-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2207589,
                "title": "python3-greedy-faster-solution",
                "content": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counts = collections.Counter(s)\\n        freq, ans = set(), 0\\n        for i, j in counts.items():\\n            while j > 0 and j in freq:\\n                j -= 1\\n                ans += 1\\n            freq.add(j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counts = collections.Counter(s)\\n        freq, ans = set(), 0\\n        for i, j in counts.items():\\n            while j > 0 and j in freq:\\n                j -= 1\\n                ans += 1\\n            freq.add(j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207113,
                "title": "java-kotlin-solutions",
                "content": "# Java\\n\\tclass Solution {\\n    public int minDeletions(String s) {\\n        int arr[] = new int[26];\\n        \\n        for(char ch : s.toCharArray())  arr[ch - \\'a\\']++;\\n        \\n        \\n        Arrays.sort(arr);\\n        \\n        int delete = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int freq : arr){\\n            \\n            while(set.contains(freq) && freq > 0){\\n                delete++;\\n                freq--;\\n            }\\n            \\n            if(freq > 0)  set.add(freq);\\n        }\\n        \\n        return delete;\\n    }\\n}\\n\\n# Kotlin\\n\\tclass Solution {\\n    fun minDeletions(s: String): Int {\\n        var arr = Array<Int>(26){0}\\n        \\n        for(i in s.indices){\\n            var ch = s.get(i)\\n            arr[ch - \\'a\\']++\\n        }  \\n        \\n        \\n        arr.sort()\\n        \\n        var delete = 0\\n        val set = hashSetOf<Int>();\\n        for(i in 0..25){\\n            var freq = arr[i]\\n            while(set.contains(freq) && freq > 0){\\n                delete++\\n                freq--\\n            }\\n            \\n            if(freq > 0)  set.add(freq);\\n        }\\n        \\n        return delete\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "class Solution {\\n    public int minDeletions(String s) {\\n        int arr[] = new int[26];\\n        \\n        for(char ch : s.toCharArray())  arr[ch - \\'a\\']++;\\n        \\n        \\n        Arrays.sort(arr);\\n        \\n        int delete = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int freq : arr){\\n            \\n            while(set.contains(freq) && freq > 0){\\n                delete++;\\n                freq--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2181620,
                "title": "c",
                "content": "```\\n   unordered_map<char,int>ump;\\n        for(int i=0;i<s.size();i++) ump[s[i]]++;\\n        priority_queue<int>pq;\\n        for(auto x:ump){\\n            pq.push(x.second);\\n        }\\n        int count=0;\\n        while(!pq.empty()){\\n            int top=pq.top();\\n            pq.pop();\\n            if(pq.empty()) return count;\\n            if(pq.top()==top){\\n             count++;\\n               if(top>1) pq.push(top-1);\\n            }\\n        }\\n        return count;\\n\\t\\t",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n   unordered_map<char,int>ump;\\n        for(int i=0;i<s.size();i++) ump[s[i]]++;\\n        priority_queue<int>pq;\\n        for(auto x:ump){\\n            pq.push(x.second);\\n        }\\n        int count=0;\\n        while(!pq.empty()){\\n            int top=pq.top();\\n            pq.pop();\\n            if(pq.empty()) return count;\\n            if(pq.top()==top){\\n             count++;\\n               if(top>1) pq.push(top-1);\\n            }\\n        }\\n        return count;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2089847,
                "title": "java-solution-using-array-creative-explanation",
                "content": "to delete/ reduce a frequency value, we must know the frequency of each variable so i created an array of size 26 which will keep a record of frequency of each character and this process is done by using a for loop and  ``` ++a[s.charAt[i] - \\'a\\'] ``` now i need to sort this array so that it will become easy for me to delete/manipulate the value. let the array is -> [0,0,0,......,0,1,1,2,2,4,6,6] \\nthe question now become we are given a sorted array, reduce the value of arr[i] so that no element is repeated .\\n<img  src=\"https://assets.leetcode.com/users/images/4382afc3-531a-4877-8333-72c371235246_1653893123.4169319.png\" width = 700>\\n\\ni will start from second last element and assign res to the last element. i will keep on reducing the ith element if it is greater than or equal to res. after doing so res will equal to a[i] for every iteration. \\n\\n<img src=\"https://assets.leetcode.com/users/images/43639287-455c-40f2-8e12-fc37fb249fa3_1653893424.5446413.png\" width =800>\\n\\nthis thing will work for all element but we have a corner case when a[i] == 1 and a[i+1] ==1/0 so in this case we need to reduce a[i] till 0. and also there is another check that if a[i] ==0 then i don\\'t need to consider so that i m doing in the for loop.\\n<img src=\"https://assets.leetcode.com/users/images/7aa78fb4-d2d5-41b5-b1ee-da2288ed7d46_1653893521.5879085.png\" width =800>\\n\\neverytime I reduce a[i] then i am also incrementing count value and in the end i will return count.\\n\\n**Please upvote my solution if it helped you**\\n\\n```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int a[] = new int[26];\\n        for(int i = 0 ; i < s.length() ; ++i){\\n            ++a[s.charAt(i) - \\'a\\'];\\n        }\\n        Arrays.sort(a);\\n        // [3 3 3] or  [1,1,2,2,4,6,6]\\n        int res= a[25];\\n        int count = 0;\\n        for(int i = 24 ; i >= 0 &&  a[i] != 0; --i){\\n            while(a[i] >= res && a[i] >0){\\n                --a[i];\\n                ++count;\\n            }\\n            res = a[i];\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n*Time complexicity = O(n) + O(26) -> O(n)*\\n*Space complexicity =  O(26) -> O(26)*",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` ++a[s.charAt[i] - \\'a\\'] ```\n```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int a[] = new int[26];\\n        for(int i = 0 ; i < s.length() ; ++i){\\n            ++a[s.charAt(i) - \\'a\\'];\\n        }\\n        Arrays.sort(a);\\n        // [3 3 3] or  [1,1,2,2,4,6,6]\\n        int res= a[25];\\n        int count = 0;\\n        for(int i = 24 ; i >= 0 &&  a[i] != 0; --i){\\n            while(a[i] >= res && a[i] >0){\\n                --a[i];\\n                ++count;\\n            }\\n            res = a[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759892,
                "title": "java-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        //Create array of fixed size to store frequency of characters\\n\\t\\tint frequency[] = new int[26];\\n        for(char currentChar:s.toCharArray()){\\n            frequency[currentChar-\\'a\\']++;\\n        }\\n\\t\\t//Create HashSet to store unique frequencies\\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n\\t\\t//final answer is stored in below variable\\n\\t\\tint ans = 0;\\n\\t\\t\\n\\t\\t//traverse the frequency array\\n        for(int val : frequency){\\n\\t\\t\\t//if frequency is 0, do nothing\\n            if(val == 0)\\n                continue;\\n\\t\\t\\telse if(!hs.contains(val)){\\n\\t\\t\\t\\t//if frequency value is not present in HashSet then add it into hashset\\n                hs.add(val);    \\n            }else{\\n\\t\\t\\t\\t//check if current frequency is present in hashSet then traverse until it finds frequency not present in hashset\\n                while(hs.contains(val) && val > 0){\\n                    val--;\\n                    ans++;\\n                }\\n                hs.add(val);\\n            }\\n        }\\n        //Return answer\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        //Create array of fixed size to store frequency of characters\\n\\t\\tint frequency[] = new int[26];\\n        for(char currentChar:s.toCharArray()){\\n            frequency[currentChar-\\'a\\']++;\\n        }\\n\\t\\t//Create HashSet to store unique frequencies\\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n\\t\\t//final answer is stored in below variable\\n\\t\\tint ans = 0;\\n\\t\\t\\n\\t\\t//traverse the frequency array\\n        for(int val : frequency){\\n\\t\\t\\t//if frequency is 0, do nothing\\n            if(val == 0)\\n                continue;\\n\\t\\t\\telse if(!hs.contains(val)){\\n\\t\\t\\t\\t//if frequency value is not present in HashSet then add it into hashset\\n                hs.add(val);    \\n            }else{\\n\\t\\t\\t\\t//check if current frequency is present in hashSet then traverse until it finds frequency not present in hashset\\n                while(hs.contains(val) && val > 0){\\n                    val--;\\n                    ans++;\\n                }\\n                hs.add(val);\\n            }\\n        }\\n        //Return answer\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664856,
                "title": "fully-explained-javascript-greedy-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n * \\n * For this solution we are going to be using a greedy approach. \\n \\n * Time Complexity: O(n) Space Complexity: O(1)\\n \\n * First map all the characters to an array with their corrensponding place in the aphebet\\n *\\n * Once that is done, we can use the fact that we are only allowed to delete characters to our advantage.\\n \\n * We will iterate through the count tracker array and at each count level there are two options:\\n * a. this count hasn\\'t been seen before and therefore we can use that count\\n * b. this count has been used before, decrease the count until we find a count that hasn\\'t been found yet\\n * Keep in mind that we have to stop decreasing the value if the value hits 0\\n \\n * Create a variable to keep track of how many times you have decremented a value.\\n * Return that count when done iterating\\n */\\nvar minDeletions = function(s) {\\n    \\n    // initialize array for all of the characters;\\n    const chars = [];\\n    for (let i = 0; i < 26; ++i) chars.push(0);\\n    \\n    // iterate through all the characters in the string and map them to the array\\n    for (let i = 0; i < s.length; ++i) {\\n        const code = s.charCodeAt(i) - 97;\\n        \\n        chars[code]++;\\n    }\\n    \\n    // create a new set that will contain all the used numbers\\n    const used = new Set();\\n    \\n    // initialize the result tracker, for every character we need to delete, add one to this\\n    let result = 0;\\n    \\n    // iterate through our character tracker array\\n    for (let i = 0; i < 26; ++i) {\\n        \\n        // get the count of the current character\\n        let current = chars[i];\\n        \\n        // iterate until it is either 0 or it finds a count that hasn\\'t been used\\n        while (current && current in used) {\\n            --current;\\n           ++result; \\n        }\\n        used[current] = used.add(current);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n * \\n * For this solution we are going to be using a greedy approach. \\n \\n * Time Complexity: O(n) Space Complexity: O(1)\\n \\n * First map all the characters to an array with their corrensponding place in the aphebet\\n *\\n * Once that is done, we can use the fact that we are only allowed to delete characters to our advantage.\\n \\n * We will iterate through the count tracker array and at each count level there are two options:\\n * a. this count hasn\\'t been seen before and therefore we can use that count\\n * b. this count has been used before, decrease the count until we find a count that hasn\\'t been found yet\\n * Keep in mind that we have to stop decreasing the value if the value hits 0\\n \\n * Create a variable to keep track of how many times you have decremented a value.\\n * Return that count when done iterating\\n */\\nvar minDeletions = function(s) {\\n    \\n    // initialize array for all of the characters;\\n    const chars = [];\\n    for (let i = 0; i < 26; ++i) chars.push(0);\\n    \\n    // iterate through all the characters in the string and map them to the array\\n    for (let i = 0; i < s.length; ++i) {\\n        const code = s.charCodeAt(i) - 97;\\n        \\n        chars[code]++;\\n    }\\n    \\n    // create a new set that will contain all the used numbers\\n    const used = new Set();\\n    \\n    // initialize the result tracker, for every character we need to delete, add one to this\\n    let result = 0;\\n    \\n    // iterate through our character tracker array\\n    for (let i = 0; i < 26; ++i) {\\n        \\n        // get the count of the current character\\n        let current = chars[i];\\n        \\n        // iterate until it is either 0 or it finds a count that hasn\\'t been used\\n        while (current && current in used) {\\n            --current;\\n           ++result; \\n        }\\n        used[current] = used.add(current);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623220,
                "title": "python3-80-beats-o-n-using-heap",
                "content": "```python\\nfrom collections import Counter\\nimport heapq\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counter = Counter(s) # O(n)\\n        heap = [-x for x in counter.values()] # max heap\\n        heapq.heapify(heap) # O(1) : only 26 alphabet exists\\n        \\n        prev = -1\\n        cnt = 0\\n        while heap:\\n            now = -heapq.heappop(heap)  # O(1) : only 26 alphabet exists\\n            if prev == now:\\n                now -= 1\\n                cnt += 1\\n                if now != 0:\\n                    heapq.heappush(heap, -now)  # O(1) : only 26 alphabet exists\\n            else:\\n                prev = now\\n        return cnt\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nfrom collections import Counter\\nimport heapq\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counter = Counter(s) # O(n)\\n        heap = [-x for x in counter.values()] # max heap\\n        heapq.heapify(heap) # O(1) : only 26 alphabet exists\\n        \\n        prev = -1\\n        cnt = 0\\n        while heap:\\n            now = -heapq.heappop(heap)  # O(1) : only 26 alphabet exists\\n            if prev == now:\\n                now -= 1\\n                cnt += 1\\n                if now != 0:\\n                    heapq.heappush(heap, -now)  # O(1) : only 26 alphabet exists\\n            else:\\n                prev = now\\n        return cnt\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458165,
                "title": "python-o-nlogn-solution",
                "content": "\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = dict(sorted(Counter(s).items(), key=lambda x: x[1], reverse=True))\\n        prev = []\\n        count = delete = 0\\n        for key in freq:\\n            if count == 0:\\n                prev.append(freq[key])\\n                count+=1\\n                continue\\n            if freq[key] in prev:\\n                prev.append(0) if prev[-1] == 0 else prev.append(prev[-1] - 1)\\n                delete += freq[key] - prev[-1] \\n            else:\\n                prev.append(freq[key])\\n        return delete\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = dict(sorted(Counter(s).items(), key=lambda x: x[1], reverse=True))\\n        prev = []\\n        count = delete = 0\\n        for key in freq:\\n            if count == 0:\\n                prev.append(freq[key])\\n                count+=1\\n                continue\\n            if freq[key] in prev:\\n                prev.append(0) if prev[-1] == 0 else prev.append(prev[-1] - 1)\\n                delete += freq[key] - prev[-1] \\n            else:\\n                prev.append(freq[key])\\n        return delete\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350412,
                "title": "java-o-n-faster-than-100-without-hashmap",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] arr = new int[26];\\n        for(char ch : s.toCharArray())\\n            arr[ch - \\'a\\']++;\\n        int max = 0, count = 0;\\n        for(int i = 0; i < 26; i++)\\n            max = Math.max(max, arr[i]);\\n        int[] freq = new int[max + 1];\\n        for(int i = 0; i < 26; i++)\\n            freq[arr[i]]++;\\n        for(int i = max; i > 0; i--){\\n            if(freq[i] > 1){\\n                count += freq[i] - 1;\\n                freq[i - 1] += freq[i] - 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] arr = new int[26];\\n        for(char ch : s.toCharArray())\\n            arr[ch - \\'a\\']++;\\n        int max = 0, count = 0;\\n        for(int i = 0; i < 26; i++)\\n            max = Math.max(max, arr[i]);\\n        int[] freq = new int[max + 1];\\n        for(int i = 0; i < 26; i++)\\n            freq[arr[i]]++;\\n        for(int i = max; i > 0; i--){\\n            if(freq[i] > 1){\\n                count += freq[i] - 1;\\n                freq[i - 1] += freq[i] - 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225681,
                "title": "100-faster-in-python3",
                "content": "![image](https://assets.leetcode.com/users/images/82543f5b-9bc7-47de-a537-e83cf0fb7f86_1621770546.578679.png)\\n\\n\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        p = [s.count(chr(97 + i)) for i in range(26)]\\n\\n        p.sort(reverse=True)\\n        ans = 0\\n        for i in range(1, 26):\\n            if p[i - 1] == 0:\\n                ans += sum(p[i:])\\n                break\\n            elif p[i] >= p[i - 1]:\\n                ans += p[i] - p[i - 1] + 1\\n                p[i] = p[i - 1] - 1\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        p = [s.count(chr(97 + i)) for i in range(26)]\\n\\n        p.sort(reverse=True)\\n        ans = 0\\n        for i in range(1, 26):\\n            if p[i - 1] == 0:\\n                ans += sum(p[i:])\\n                break\\n            elif p[i] >= p[i - 1]:\\n                ans += p[i] - p[i - 1] + 1\\n                p[i] = p[i - 1] - 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217109,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] arr=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n           arr[s.charAt(i)-\\'a\\']++;//count frequency\\n        }\\n        HashSet<Integer> freq=new HashSet<>();\\n        int del=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            while(arr[i]!=0 && freq.contains(arr[i]))//if set already contains that frequency then deletion is performed and frequency of that character will be reduced so arr[i]--,del++\\n            {\\n               arr[i]--;\\n               del++;\\n            }\\n            freq.add(arr[i]);\\n        }\\n        return del;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] arr=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n           arr[s.charAt(i)-\\'a\\']++;//count frequency\\n        }\\n        HashSet<Integer> freq=new HashSet<>();\\n        int del=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            while(arr[i]!=0 && freq.contains(arr[i]))//if set already contains that frequency then deletion is performed and frequency of that character will be reduced so arr[i]--,del++\\n            {\\n               arr[i]--;\\n               del++;\\n            }\\n            freq.add(arr[i]);\\n        }\\n        return del;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186579,
                "title": "java-no-set-straightfoward-solution-with-explanation",
                "content": "```\\n    public int minDeletions(String s) {\\n        int [] counts = new int[26];\\n        \\n        for (char c : s.toCharArray()) {\\n            counts[c - \\'a\\']++;\\n        }\\n        \\n        Arrays.sort(counts);\\n        \\n        int operation = 0;\\n        // start with the biggest frequency, try to find a \"room\" for every letter\\n        // 5->4->4->4->3->3->1\\n        // 5->4->3->4->3->3->1\\n        // 5->4->3->2->3->3->1\\n        // 5->4->3->2->1->3->1\\n        // 5->4->3->2->1->0->1\\n        // 5->4->3->2->1->0->0\\n        for (int i = counts.length - 1;  i > 0 ; i--) {\\n            if (counts[i - 1] >= counts[i]) {\\n                // spare i - 1 if it\\'s already 0\\n                while (counts[i - 1] != 0 && counts[i - 1] >= counts[i]) {\\n                    counts[i - 1]--;\\n                    operation++;\\n                }\\n            }\\n        }\\n        \\n        return operation;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minDeletions(String s) {\\n        int [] counts = new int[26];\\n        \\n        for (char c : s.toCharArray()) {\\n            counts[c - \\'a\\']++;\\n        }\\n        \\n        Arrays.sort(counts);\\n        \\n        int operation = 0;\\n        // start with the biggest frequency, try to find a \"room\" for every letter\\n        // 5->4->4->4->3->3->1\\n        // 5->4->3->4->3->3->1\\n        // 5->4->3->2->3->3->1\\n        // 5->4->3->2->1->3->1\\n        // 5->4->3->2->1->0->1\\n        // 5->4->3->2->1->0->0\\n        for (int i = counts.length - 1;  i > 0 ; i--) {\\n            if (counts[i - 1] >= counts[i]) {\\n                // spare i - 1 if it\\'s already 0\\n                while (counts[i - 1] != 0 && counts[i - 1] >= counts[i]) {\\n                    counts[i - 1]--;\\n                    operation++;\\n                }\\n            }\\n        }\\n        \\n        return operation;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084360,
                "title": "java-using-hashtable-hashmap-commented-code-with-clear-explanation-of-the-logic",
                "content": "import java.util.Hashtable;\\nclass Solution {\\n    \\n\\tpublic int minDeletions(String s) {\\n       \\n\\t   HashMap<Character,Integer> hm = new HashMap<>();\\n       ArrayList<Integer> arr = new ArrayList<>();\\n       \\n\\t   int i=0;\\n       int val;\\n       Hashtable<Integer,Integer> ht = new Hashtable<>();\\n       int count=0;        \\n        //create a hashmap and store :  how many times each character appeard in the given string.\\n        \\n        for(i=0;i<s.length();i++){\\n            hm.put(s.charAt(i),hm.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        \\n        // iterate over the hashmap table created in above step.        \\n        Iterator hmIterator = hm.entrySet().iterator(); \\n        i=0;\\n               \\n        // lets store the information: <how many times an alphabet/character appeard>\\n        // in an arrayList \"arr\"   \\n        while (hmIterator.hasNext()) { \\n            Map.Entry mapElement = (Map.Entry)hmIterator.next(); \\n            val = ((int)mapElement.getValue());            \\n            arr.add(val);           \\n            i++;        \\n        } \\n        // sort the array\\n        arr.sort(Comparator.naturalOrder());     \\n        i = 0;        \\n              \\n        // now we need to find the duplicates .. for that \\n        // create a hashmap table for each value in the array, \\n        //representing the number of occurance of \\n        // each character in the array\\n        // for ex: \"bbcebab\" , our arrylist would be : 1 1 1 4 ( as we have : a c e bbbb )\\n        // below logic will try to put above arraylist in a hashtable\\n        // while putting in hashtable it try to find if the entry already exist , if it\\n        // exists already then we need to decrement the counter and it is equivalent to \\n        //deleting an element - as our requirement is to have each character count to be unique\\n        // once we decrement , then we check again if our hashtable has that entry , if not\\n        // then we should include that value in our hashtable \\n        // ex: first we read 1 from arraylist we dont have it in HT then we insert it\\n        // next we read second 1 from arraylist , we see it already exist in HT \\n        // so we decrement it and it becomes 0 , so we ignore as this is equal to deleting a character completely\\n        // next we read 1 from arraylist , we see it already existing in HT \\n        // so we decrement it and it becomes 0 , so we ignore this .. we also increment \"count\" \\n        // whenever we decrement the value of element in arraylist \\n        // next we read 4 .. we dont hae 4 in our HT , so we insert it in HT . \\n        \\n        for(i=0;i<arr.size();i++){                     \\n            if(!ht.containsKey(arr.get(i))){\\n                ht.put(arr.get(i),1);               \\n            }\\n            else{\\n                do{\\n                    arr.set(i,arr.get(i)-1);\\n                    count++;                   \\n                }while(ht.containsKey(arr.get(i)) && arr.get(i) > 0);    \\n                \\n                ht.put(arr.get(i),1);\\n            }            \\n        }\\n        return count;      \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int minDeletions(String s) {\\n       \\n\\t   HashMap<Character,Integer> hm = new HashMap<>();\\n       ArrayList<Integer> arr = new ArrayList<>();\\n       \\n\\t   int i=0;\\n       int val;\\n       Hashtable<Integer,Integer> ht = new Hashtable<>();\\n       int count=0;        \\n        //create a hashmap and store :  how many times each character appeard in the given string.\\n        \\n        for(i=0;i<s.length();i++){\\n            hm.put(s.charAt(i),hm.getOrDefault(s.charAt(i),0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 927511,
                "title": "c-stl-map-easy-to-understand-beginner-short-concise-interview-with-explanation",
                "content": "```\\n/*\\n\\n[C++]-EASY TO UNDERSTAND-BEGINNER-SHORT CONCISE-INTERVIEW-WITH EXPLANATION\\nExplanation: Minimum Deletions to Make Character Frequencies Unique\\n\\nFind the frequencies of each letter and store it in a count array, here i have used vector c;\\nThen store each frequency as key in a map, let the value be 1/any random value;\\n\\nThen we check if that frequency is already existing in the map or not,by if(mm.find(cou)!=mm.end()).\\nIf it exists, then increase ans and decrease the frequency and again check for its existance in map.\\n\\nDo the same till, everything is unique.\\n\\n*/\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> c(26,0);\\n        for(auto x:s)\\n            c[x-\\'a\\']++;\\n        map<int,int> mm;\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            int cou=c[i];\\n            if(cou==0)\\n                continue;\\n            if(mm.find(cou)!=mm.end()){\\n                ans++;\\n                c[i]--;\\n                i--;\\n            } else {\\n                mm[cou]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\n[C++]-EASY TO UNDERSTAND-BEGINNER-SHORT CONCISE-INTERVIEW-WITH EXPLANATION\\nExplanation: Minimum Deletions to Make Character Frequencies Unique\\n\\nFind the frequencies of each letter and store it in a count array, here i have used vector c;\\nThen store each frequency as key in a map, let the value be 1/any random value;\\n\\nThen we check if that frequency is already existing in the map or not,by if(mm.find(cou)!=mm.end()).\\nIf it exists, then increase ans and decrease the frequency and again check for its existance in map.\\n\\nDo the same till, everything is unique.\\n\\n*/\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> c(26,0);\\n        for(auto x:s)\\n            c[x-\\'a\\']++;\\n        map<int,int> mm;\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            int cou=c[i];\\n            if(cou==0)\\n                continue;\\n            if(mm.find(cou)!=mm.end()){\\n                ans++;\\n                c[i]--;\\n                i--;\\n            } else {\\n                mm[cou]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037287,
                "title": "c-using-two-maps",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int> m1;\\n        unordered_map<int,int>m2;\\n        for(auto c:s)\\n        {\\n           m1[c]++; \\n        }\\n        int ans=0;\\n        for(auto i:m1)\\n        {\\n            int f=i.second;\\n                if(m2[f])\\n                {\\n                    while(f)\\n                    {\\n                        f--;\\n                        ans++;\\n                        if(!(m2[f]))\\n                             {\\n                                m2[f]=1;\\n                                break;\\n                             }\\n                     }      \\n                 }\\n            else{\\n                m2[f]=1;\\n            }\\n         }\\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int> m1;\\n        unordered_map<int,int>m2;\\n        for(auto c:s)\\n        {\\n           m1[c]++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4037194,
                "title": "plain-c-o-n-solution",
                "content": "In order not to get **Took too long** error avoid calculating input string length.\\n\\n```\\nint compare(const void *x, const void *y) {\\n    return *(int*)x - *(int*)y;\\n}\\n\\nint minDeletions(char *s) {\\n    int xs[26] = {0};\\n\\n    while (*s != \\'\\\\0\\') ++xs[*s++ - \\'a\\'];\\n\\n    qsort(xs, 26, sizeof(int), compare);\\n\\n    int res = 0;\\n    for (int i = 24; i >= 0 && xs[i] != 0; --i) {\\n        if (xs[i] < xs[i + 1]) continue;\\n\\n        if (xs[i + 1] != 0) {\\n            res += xs[i] - xs[i + 1] + 1;\\n            xs[i] = xs[i + 1] - 1;\\n        } else {\\n            res += xs[i];\\n            xs[i] = 0;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint compare(const void *x, const void *y) {\\n    return *(int*)x - *(int*)y;\\n}\\n\\nint minDeletions(char *s) {\\n    int xs[26] = {0};\\n\\n    while (*s != \\'\\\\0\\') ++xs[*s++ - \\'a\\'];\\n\\n    qsort(xs, 26, sizeof(int), compare);\\n\\n    int res = 0;\\n    for (int i = 24; i >= 0 && xs[i] != 0; --i) {\\n        if (xs[i] < xs[i + 1]) continue;\\n\\n        if (xs[i + 1] != 0) {\\n            res += xs[i] - xs[i + 1] + 1;\\n            xs[i] = xs[i + 1] - 1;\\n        } else {\\n            res += xs[i];\\n            xs[i] = 0;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036675,
                "title": "minimum-deletions-to-make-character-frequencies-unique-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            mp[s[i]]++;\\n        }\\n        unordered_map<int,int> freqCnt;\\n        int ans = 0;\\n        for(auto it : mp) {\\n            int cnt = it.second;\\n            if(freqCnt[cnt] != 0) {\\n                while(cnt > 0 && freqCnt[cnt] != 0) {\\n                    cnt--;\\n                    ans++;\\n                }\\n            }\\n            freqCnt[cnt]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            mp[s[i]]++;\\n        }\\n        unordered_map<int,int> freqCnt;\\n        int ans = 0;\\n        for(auto it : mp) {\\n            int cnt = it.second;\\n            if(freqCnt[cnt] != 0) {\\n                while(cnt > 0 && freqCnt[cnt] != 0) {\\n                    cnt--;\\n                    ans++;\\n                }\\n            }\\n            freqCnt[cnt]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036489,
                "title": "simple-solution-hash-map-c-sorting",
                "content": "```\\n\\tint minDeletions(string s) {\\n        int ans = 0;\\n        vector<int> mpp(26,0);\\n        for(int i=0;i<s.size();++i){\\n            mpp[s[i]-\\'a\\']+=1;\\n        }\\n        sort(mpp.begin(),mpp.end());\\n        int mf = mpp[25];\\n        for(int i=25;~i;--i){\\n            if(mpp[i]==0){break;}\\n            if(mpp[i]>mf){\\n                if(mf>=0){ans+=mpp[i]-mf;}\\n                else{ans+=mpp[i];}\\n            }\\n            mf = min(mf,mpp[i])-1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\tint minDeletions(string s) {\\n        int ans = 0;\\n        vector<int> mpp(26,0);\\n        for(int i=0;i<s.size();++i){\\n            mpp[s[i]-\\'a\\']+=1;\\n        }\\n        sort(mpp.begin(),mpp.end());\\n        int mf = mpp[25];\\n        for(int i=25;~i;--i){\\n            if(mpp[i]==0){break;}\\n            if(mpp[i]>mf){\\n                if(mf>=0){ans+=mpp[i]-mf;}\\n                else{ans+=mpp[i];}\\n            }\\n            mf = min(mf,mpp[i])-1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036466,
                "title": "minimum-deletion-to-make-character-frequencies-unique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> count(26,0);\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            count[c-\\'a\\']++;\\n        }\\n\\n        vector<int> uniqueFreq;\\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            int frq = count[i];\\n            while(find(uniqueFreq.begin(),uniqueFreq.end(),frq)!=uniqueFreq.end()){\\n                frq--;\\n                ans++;\\n            }\\n            if(frq>0){\\n                uniqueFreq.push_back(frq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> count(26,0);\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            count[c-\\'a\\']++;\\n        }\\n\\n        vector<int> uniqueFreq;\\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            int frq = count[i];\\n            while(find(uniqueFreq.begin(),uniqueFreq.end(),frq)!=uniqueFreq.end()){\\n                frq--;\\n                ans++;\\n            }\\n            if(frq>0){\\n                uniqueFreq.push_back(frq);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036323,
                "title": "easy-to-understand-c-daily-lc-sept-12-brute",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        unordered_map<int,char>x;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            int a=it.second;\\n            while(x.find(a)!=x.end() && a!=0)\\n            {\\n                count++;\\n                a--;\\n            }\\n            if(a==0)\\n                continue;\\n            else\\n                x[a]=it.first;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Simulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        unordered_map<int,char>x;\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            int a=it.second;\\n            while(x.find(a)!=x.end() && a!=0)\\n            {\\n                count++;\\n                a--;\\n            }\\n            if(a==0)\\n                continue;\\n            else\\n                x[a]=it.first;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034948,
                "title": "c-solution-without-using-map",
                "content": "# Intuition\\nWe should first store the count of all the characters in a data structure. And then traverse it after sorting it.\\n\\n# Approach\\nWe will initialize a vector of pair of size 27 (26 alphabets and 1 extra space to handle heap overflow).\\nAfter this, we will store the count of each alphabet in vec.first and corresponding number (ex - 0 for \\'a\\', 3 for \\'d\\') in vec.second.\\nNow, sort the vector of pair in non-increasing order.\\nAfter this, we will traverse the vector of pair and if we find any frequency matching with its next element then we will decrease the current element by 1 and increase the answer by 1 and then again sort the vector of pair.\\nThe base case to break out of loop would be, if frequency of current element is 1, In this case we will manually traverse the remaining elements and count until 0 is reached.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int ans = 0,count = 0;\\n        vector<pair<int,int>> arr(27);\\n        for(int i=0;i<s.size();i++){ // storing count with alphabets in a vector of pair\\n            arr[int(s[i]-\\'a\\')].second = int(s[i]-\\'a\\');\\n            (arr[int(s[i]-\\'a\\')].first)++;\\n        }\\n        sort(arr.begin(),arr.end(),greater<pair<int, int> >()); // sorting in non-increasing order\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i].first == arr[i+1].first){//if current frequency == 1, then traverse remaining elements and count number of 1s and break out of loop \\n                if(arr[i].first == 1){\\n                    while(arr[i].first != 0){\\n                        count++;\\n                        i++;\\n                    }\\n                    ans += count -1;\\n                    break;\\n                }\\n                if(arr[i+1].first == 0 && arr[i+1].second == 0){//if next pair is (0,0) then simply break out of loop\\n                    break;\\n                }\\n                ans++;  \\n                (arr[i].first)--; //decrement current frequency by 1\\n                sort(arr.begin(),arr.end(),greater<pair<int, int> >())// sort again as changes are made in frequencies\\n                i=-1; // To start from i=0 again\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        int ans = 0,count = 0;\\n        vector<pair<int,int>> arr(27);\\n        for(int i=0;i<s.size();i++){ // storing count with alphabets in a vector of pair\\n            arr[int(s[i]-\\'a\\')].second = int(s[i]-\\'a\\');\\n            (arr[int(s[i]-\\'a\\')].first)++;\\n        }\\n        sort(arr.begin(),arr.end(),greater<pair<int, int> >()); // sorting in non-increasing order\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i].first == arr[i+1].first){//if current frequency == 1, then traverse remaining elements and count number of 1s and break out of loop \\n                if(arr[i].first == 1){\\n                    while(arr[i].first != 0){\\n                        count++;\\n                        i++;\\n                    }\\n                    ans += count -1;\\n                    break;\\n                }\\n                if(arr[i+1].first == 0 && arr[i+1].second == 0){//if next pair is (0,0) then simply break out of loop\\n                    break;\\n                }\\n                ans++;  \\n                (arr[i].first)--; //decrement current frequency by 1\\n                sort(arr.begin(),arr.end(),greater<pair<int, int> >())// sort again as changes are made in frequencies\\n                i=-1; // To start from i=0 again\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034117,
                "title": "no-priority-queue-no-heap-no-sorting-10-liner-solution-using-hashmap-and-counters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each letter check if a previous letter has the same count. If Yes? Keep on decreasing until we get a unique count (we might even make it 0 i.e. delete that letter altogether!)\\n![image.png](https://assets.leetcode.com/users/images/5e53908c-43f6-49ed-981a-d1e590c1a949_1694498660.7157955.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a counter to track the counts. E.g. `{a: 2, b:2, c:1}`.\\nWe have a variable `ans=0` to store the number of deletions.\\nNow we keep a hash map that stores the letters and their counts in the final good string.\\nThe computation goes on as :\\nThe Hash Map now has:`{2:a}`. Next we try to add b for index 2 again. But we see that 2 already exists in the keys. This means we previously have some other letter (here a) that has the same count. In order to make it a *good string* we delete 1 from count of b and increase 1 for our ans (ans+=1).\\nCounter Now : `{a:2, b:1, c:1}`. Since hash map does not have 1 as the key we can add b to the Hash Map. \\nHash Map now: `{2:a, 1:b}`.\\nNext, we cannot add c to the hash map as count[\\'c\\'] is 1 (Counter: `{a:2, b:1, c:1}`) and we already have b mapped to the index 1. Hence, we have no other choice but to delete c from the string. Hence count[\\'c\\']-=1 and ans+=1.\\nHence, counter is now `{a:2, b:1, c:0}`.\\nNote, that we do not add any letter for index = 0 in hash Map as the hash map only stores letters that appear in the final string.\\nWe return ans = 2.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        count, hashMap, ans = collections.Counter(s), dict(), 0\\n        for i in count.keys():\\n            while count[i] > 0 and count[i] in hashMap.keys():\\n                ans += 1\\n                count[i] -= 1\\n            if count[i] != 0:\\n                hashMap[count[i]] = i\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        count, hashMap, ans = collections.Counter(s), dict(), 0\\n        for i in count.keys():\\n            while count[i] > 0 and count[i] in hashMap.keys():\\n                ans += 1\\n                count[i] -= 1\\n            if count[i] != 0:\\n                hashMap[count[i]] = i\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033665,
                "title": "java-solution-using-hashing",
                "content": "# class Solution {\\n    public int minDeletions(String s) {\\n        \\n        Map<Character,Integer> map = new HashMap<>();\\n        int max = 0;\\n        for(char ch:s.toCharArray()){\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n            max = Math.max(max,map.get(ch));\\n        }\\n        \\n        int res = 0,size=(int)1e5+1;\\n        int[] hash = new int[size];\\n        for(char ch:map.keySet()){\\n            int val = map.get(ch);\\n            hash[val]++;\\n        }\\n        for(int i=max;i>0;i--){\\n            int count = hash[i];\\n            if(count>1){\\n                res+=(count-1);\\n                hash[i] = 1;\\n                if(i>0) hash[i-1]+=count-1;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minDeletions(String s) {\\n        \\n        Map<Character,Integer> map = new HashMap<>();\\n        int max = 0;\\n        for(char ch:s.toCharArray()){\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n            max = Math.max(max,map.get(ch));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4033610,
                "title": "c-solution-for-minimum-deletions-to-make-character-frequencies-unique-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to count the frequency of each character in the input string s and then ensure that there are no two different characters with the same frequency. To achieve this, we iterate through the frequencies and, if a non-unique frequency is encountered, we decrement it until we find a unique frequency, counting the deletions along the way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.\\tInitialize an array frequency of size 26 to represent the frequency of each lowercase English letter.\\n2.\\tIterate through the characters in the input string s and update their frequencies in the frequency array.\\n3.\\tUse a HashSet uniqueFrequencies to keep track of unique frequencies encountered.\\n4.\\tIterate through the frequency array to process each character\\u2019s frequency.\\n5.\\tIf a non-unique frequency is encountered, decrement it until it becomes unique, counting deletions in the process.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\u2022\\tCounting the character frequencies in the input string takes O(N) time, where N is the length of the input string.\\n\\u2022\\tIterating through the frequency array and processing each frequency also takes O(N) time in the worst case.\\n\\u2022\\tThe total time complexity is O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\u2022\\tThe space complexity is O(26) for the frequency array, which simplifies to O(1) since the array size is constant.\\n\\u2022\\tThe HashSet uniqueFrequencies can contain at most 26 unique frequencies (one for each letter), so its space complexity is also O(1).\\n\\u2022\\tOverall, the space complexity is O(1) since the space used does not depend on the length of the input string.\\n\\n# Code\\n```\\n    public class Solution {\\n        public int MinDeletions(string s) {\\n            int[] frequency = new int[26]; // Array to store character frequencies (assuming lowercase English letters)\\n        foreach (char c in s) {\\n            frequency[c - \\'a\\']++;\\n        }\\n        \\n        HashSet<int> uniqueFrequencies = new HashSet<int>();\\n        int deletions = 0;\\n        \\n        for (int i = 0; i < 26; i++) {\\n            int freq = frequency[i];\\n            while (freq > 0 && !uniqueFrequencies.Add(freq)) {\\n                freq--;\\n                deletions++;\\n            }\\n        }\\n        \\n        return deletions;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    public class Solution {\\n        public int MinDeletions(string s) {\\n            int[] frequency = new int[26]; // Array to store character frequencies (assuming lowercase English letters)\\n        foreach (char c in s) {\\n            frequency[c - \\'a\\']++;\\n        }\\n        \\n        HashSet<int> uniqueFrequencies = new HashSet<int>();\\n        int deletions = 0;\\n        \\n        for (int i = 0; i < 26; i++) {\\n            int freq = frequency[i];\\n            while (freq > 0 && !uniqueFrequencies.Add(freq)) {\\n                freq--;\\n                deletions++;\\n            }\\n        }\\n        \\n        return deletions;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033602,
                "title": "easy-to-understand",
                "content": "# Intuition\\n   \\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        map<char,int>m;\\n        vector<int>v;\\n        map<int,vector<char>>m1;\\n        for(auto s:s)\\n        m[s]++;\\n       \\n        int cnt=0;\\n        for(auto m:m)\\n        {\\n          \\n        m1[m.second].push_back(m.first);\\n        v.push_back(m.second);\\n        }\\n        if(m1.size()==m.size())\\n        return 0;\\n\\n        \\n        \\n        sort(v.begin(),v.end());\\n         for(int i=1;i<v.size();i++)\\n         {\\n          //  cout<<v[i]<<\" \";\\n           if(v[i]==v[i-1])\\n           {\\n             int k=v[i-1];\\n            //  v.erase(v.begin()+i-1);\\n             while(k>0&&find(v.begin(),v.end(),k)!=v.end())\\n             {\\n               cnt++;\\n               k--;\\n             }\\n             if(k==0)\\n             v.push_back(-1);\\n             else\\n             v[i-1]=k;\\n             \\n           }\\n         }\\n      \\n       return cnt;  \\n        }\\n      \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        map<char,int>m;\\n        vector<int>v;\\n        map<int,vector<char>>m1;\\n        for(auto s:s)\\n        m[s]++;\\n       \\n        int cnt=0;\\n        for(auto m:m)\\n        {\\n          \\n        m1[m.second].push_back(m.first);\\n        v.push_back(m.second);\\n        }\\n        if(m1.size()==m.size())\\n        return 0;\\n\\n        \\n        \\n        sort(v.begin(),v.end());\\n         for(int i=1;i<v.size();i++)\\n         {\\n          //  cout<<v[i]<<\" \";\\n           if(v[i]==v[i-1])\\n           {\\n             int k=v[i-1];\\n            //  v.erase(v.begin()+i-1);\\n             while(k>0&&find(v.begin(),v.end(),k)!=v.end())\\n             {\\n               cnt++;\\n               k--;\\n             }\\n             if(k==0)\\n             v.push_back(-1);\\n             else\\n             v[i-1]=k;\\n             \\n           }\\n         }\\n      \\n       return cnt;  \\n        }\\n      \\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4033579,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition and approach dicussed in detail in video solution\\nhttps://youtu.be/cOi_GuQcoU0\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26);\\n        for(auto c : s){\\n            freq[c-\\'a\\']++;\\n        }\\n        sort(freq.begin(), freq.end(), greater<int>());\\n        unordered_set<int> unqFreq;\\n        for(auto f : freq){\\n            cout<<f<<\" \";\\n            if(f != 0)unqFreq.insert(f);\\n        }\\n        cout<<endl;\\n        int dels = 0;\\n        int missFreq = -1;\\n        for(int indx = 0; indx < 26; indx++){\\n            if(!freq[indx])break;\\n            if(indx + 1 < 26 && freq[indx] == freq[indx+1]){\\n               int currFreq = freq[indx];\\n               missFreq = currFreq;\\n               while(missFreq > 0 && unqFreq.count(missFreq))missFreq--;\\n               dels += currFreq - missFreq;\\n               if(missFreq != 0)unqFreq.insert(missFreq);\\n            }\\n        }\\n        return dels;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minDeletions(String str) {\\n        char s[] = str.toCharArray();\\n        int freq[] = new int[26];\\n        for(var c : s){\\n            freq[c-\\'a\\']++;\\n        }\\n        Arrays.sort(freq);\\n        reverse(freq);\\n        HashSet<Integer> unqFreq = new HashSet<>();\\n        for(var f : freq){\\n            if(f != 0)unqFreq.add(f);\\n        }\\n        int dels = 0;\\n        int missFreq = -1;\\n        for(int indx = 0; indx < 26; indx++){\\n            if(freq[indx] == 0)break;\\n            if(indx + 1 < 26 && freq[indx] == freq[indx+1]){\\n               int currFreq = freq[indx];\\n               missFreq = currFreq;\\n               while(missFreq > 0 && unqFreq.contains(missFreq))missFreq--;\\n               dels += currFreq - missFreq;\\n               if(missFreq != 0)unqFreq.add(missFreq);\\n            }\\n        }\\n        return dels;\\n    }\\n    private static void reverse(int[] array)\\n    {\\n \\n      \\n        int n = array.length;\\n        for (int i = 0; i < n / 2; i++) {\\n            int temp = array[i];\\n            array[i] = array[n - i - 1];\\n            array[n - i - 1] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26);\\n        for(auto c : s){\\n            freq[c-\\'a\\']++;\\n        }\\n        sort(freq.begin(), freq.end(), greater<int>());\\n        unordered_set<int> unqFreq;\\n        for(auto f : freq){\\n            cout<<f<<\" \";\\n            if(f != 0)unqFreq.insert(f);\\n        }\\n        cout<<endl;\\n        int dels = 0;\\n        int missFreq = -1;\\n        for(int indx = 0; indx < 26; indx++){\\n            if(!freq[indx])break;\\n            if(indx + 1 < 26 && freq[indx] == freq[indx+1]){\\n               int currFreq = freq[indx];\\n               missFreq = currFreq;\\n               while(missFreq > 0 && unqFreq.count(missFreq))missFreq--;\\n               dels += currFreq - missFreq;\\n               if(missFreq != 0)unqFreq.insert(missFreq);\\n            }\\n        }\\n        return dels;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minDeletions(String str) {\\n        char s[] = str.toCharArray();\\n        int freq[] = new int[26];\\n        for(var c : s){\\n            freq[c-\\'a\\']++;\\n        }\\n        Arrays.sort(freq);\\n        reverse(freq);\\n        HashSet<Integer> unqFreq = new HashSet<>();\\n        for(var f : freq){\\n            if(f != 0)unqFreq.add(f);\\n        }\\n        int dels = 0;\\n        int missFreq = -1;\\n        for(int indx = 0; indx < 26; indx++){\\n            if(freq[indx] == 0)break;\\n            if(indx + 1 < 26 && freq[indx] == freq[indx+1]){\\n               int currFreq = freq[indx];\\n               missFreq = currFreq;\\n               while(missFreq > 0 && unqFreq.contains(missFreq))missFreq--;\\n               dels += currFreq - missFreq;\\n               if(missFreq != 0)unqFreq.add(missFreq);\\n            }\\n        }\\n        return dels;\\n    }\\n    private static void reverse(int[] array)\\n    {\\n \\n      \\n        int n = array.length;\\n        for (int i = 0; i < n / 2; i++) {\\n            int temp = array[i];\\n            array[i] = array[n - i - 1];\\n            array[n - i - 1] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4008784,
                "title": "easy-to-understand-c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int>ump;\\n        for(int i =0; i< s.size(); i++){\\n            ump[s[i]]++;\\n        }\\n        priority_queue<int>pq;\\n        for(auto it : ump){\\n            pq.push(it.second);\\n            \\n        }\\n        int count = 0;\\n        while(pq.size() >1) {\\n            int first = pq.top(); \\n            pq.pop();\\n            int second = pq.top();\\n            pq.pop();\\n            if(first == second && second > 0){\\n                second--;\\n                count++;\\n                pq.push(second);\\n                pq.push(first);\\n            }\\n            else{\\n                pq.push(second);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int>ump;\\n        for(int i =0; i< s.size(); i++){\\n            ump[s[i]]++;\\n        }\\n        priority_queue<int>pq;\\n        for(auto it : ump){\\n            pq.push(it.second);\\n            \\n        }\\n        int count = 0;\\n        while(pq.size() >1) {\\n            int first = pq.top(); \\n            pq.pop();\\n            int second = pq.top();\\n            pq.pop();\\n            if(first == second && second > 0){\\n                second--;\\n                count++;\\n                pq.push(second);\\n                pq.push(first);\\n            }\\n            else{\\n                pq.push(second);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701194,
                "title": "o-n-optimal-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(26)\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = Counter(s)\\n        used = set()\\n        ans = 0\\n        for val in freq.values():\\n            while val in used and val != 0:\\n                val -= 1\\n                ans += 1\\n            if val != 0:\\n                used.add(val)\\n        return ans \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        freq = Counter(s)\\n        used = set()\\n        ans = 0\\n        for val in freq.values():\\n            while val in used and val != 0:\\n                val -= 1\\n                ans += 1\\n            if val != 0:\\n                used.add(val)\\n        return ans \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633925,
                "title": "easily-understandable-c-set-o-n-log-n",
                "content": "# Intuition\\nIntuition is simple greedy based, If any 2 frequency is same then we will reduce this frequency to it\\'s closest frequency which have value 0.\\n\\n\\n# Approach\\nwe will take an array v of size n, where index i is the frequency. we will store count of frequency in v.\\n\\nTo keep track of closest frequency in which other greater frequency can be reduced, we will store all these elements in set.\\n\\nnow we will run a loop and if v[i]>1, then we will find lower_bound of i say it. then decrese it-- and ans will be abs(*it-i).\\n\\nEdge case:- if lower_bound is the first element of set. It means there is no smaller index left so we have to delete all the elements and if v[i]==0. then again put it in set.\\n\\n# Complexity\\n- Time complexity:\\n$$ O(n *(Log(n))) $$\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        map<char,int>mp;\\n        for(auto i:s){\\n            mp[i]+=1;\\n        }\\n        int n=s.size();\\n        vector<int> v(n+1,0);\\n\\n        for(auto i:mp){\\n            v[i.second]++;\\n        }\\n\\n        set<int> st;\\n        for(int i=1;i<=n;i+=1){\\n            if(v[i]==0){\\n                st.insert(i);\\n            }\\n        }\\n\\n        int i=1,ans=0;\\n        while(i<n){\\n            if(v[i]>1){\\n                auto it=st.lower_bound(i);\\n\\n                // if all the minimum index is already filled then we have to delete all the elements\\n                if(it==st.begin()){\\n                    ans+=i;\\n                    v[i]-=1;\\n                    if(v[i]==0)st.insert(i);\\n                    continue;\\n                }\\n\\n                // nearest index of i(ind<i) which is not filled\\n                it--;\\n                int ind= *it;\\n                int val= abs(ind-i);\\n                v[i]-=1;\\n                ans+=val;\\n                st.erase(ind);\\n            }else{\\n                i+=1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nThankYou, Happy coding :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        map<char,int>mp;\\n        for(auto i:s){\\n            mp[i]+=1;\\n        }\\n        int n=s.size();\\n        vector<int> v(n+1,0);\\n\\n        for(auto i:mp){\\n            v[i.second]++;\\n        }\\n\\n        set<int> st;\\n        for(int i=1;i<=n;i+=1){\\n            if(v[i]==0){\\n                st.insert(i);\\n            }\\n        }\\n\\n        int i=1,ans=0;\\n        while(i<n){\\n            if(v[i]>1){\\n                auto it=st.lower_bound(i);\\n\\n                // if all the minimum index is already filled then we have to delete all the elements\\n                if(it==st.begin()){\\n                    ans+=i;\\n                    v[i]-=1;\\n                    if(v[i]==0)st.insert(i);\\n                    continue;\\n                }\\n\\n                // nearest index of i(ind<i) which is not filled\\n                it--;\\n                int ind= *it;\\n                int val= abs(ind-i);\\n                v[i]-=1;\\n                ans+=val;\\n                st.erase(ind);\\n            }else{\\n                i+=1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395820,
                "title": "javascript-solution-using-map-and-set",
                "content": "# Approach\\nThe solution uses a frequency map to count the frequency of each character in the input string s. It then uses a set to keep track of frequencies that have already been seen, and counts the number of deletions needed to make the string good.\\n\\nFirst, the code iterates through the string and counts the frequency of each character using a Map. Then, for each unique character frequency, it adds the frequency to the set of seen frequencies. If the frequency already exists in the set, the code decrements it until a unique frequency is found, and increments the deletions counter accordingly.\\n\\nFinally, the code returns the total number of deletions needed to make the string good.\\n\\n## The step-by-step of the approach is as follows:\\n\\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\\n\\n# Code\\n```\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    const freqMap = new Map();\\n    const freqSet = new Set();\\n    \\n    // Counts the frequency of each character\\n    for (let i = 0; i < s.length; i++) {\\n        freqMap.set(s[i], (freqMap.get(s[i]) || 0) + 1);\\n    }\\n    \\n    let deletions = 0;\\n    for (let [char, freq] of freqMap) {\\n        // If the frequency already exists, decrement until you find a unique frequency.\\n        while (freqSet.has(freq)) {\\n            freq--;\\n            deletions++;\\n        }\\n        if (freq > 0) {\\n            freqSet.add(freq);\\n        }\\n    }\\n    \\n    return deletions;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    const freqMap = new Map();\\n    const freqSet = new Set();\\n    \\n    // Counts the frequency of each character\\n    for (let i = 0; i < s.length; i++) {\\n        freqMap.set(s[i], (freqMap.get(s[i]) || 0) + 1);\\n    }\\n    \\n    let deletions = 0;\\n    for (let [char, freq] of freqMap) {\\n        // If the frequency already exists, decrement until you find a unique frequency.\\n        while (freqSet.has(freq)) {\\n            freq--;\\n            deletions++;\\n        }\\n        if (freq > 0) {\\n            freqSet.add(freq);\\n        }\\n    }\\n    \\n    return deletions;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333465,
                "title": "simplest-solution-in-python-beats-more-than-95-submissions-in-speed-and-memory",
                "content": "# Intuition\\nFind solution with time complexity of O(n) and space complexity of O(1) only. Beats almost 97% of overall submissions in speed and 95% of solutions in memory.\\n\\n# Approach\\n* Create a list of sorted repitions of characters in string.\\n* Create a set to store frequencies that have already occoured.\\n* Loop through each item in counts list created earlier\\n  * If item is not present in occoured elements, add it to occoured elements.\\n  * If it is present in occoured elements,\\n    * Create a variable initialized as present value\\n    * Keep on decreasing value by 1 while checking if new number is present in occourances set.\\n  * If the new frequency is equal to 0, ignore that number.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nfrom collections import Counter as counter\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counts = sorted(counter(s).values())\\n        occoured = set()\\n\\n        operations_needed = 0\\n        for item in counts:\\n            if item not in occoured:\\n                occoured.add(item)\\n            else:\\n                tmp = item\\n                while tmp in occoured:\\n                    tmp -= 1\\n                    operations_needed += 1\\n                if tmp != 0:\\n                    occoured.add(tmp)\\n\\n        return operations_needed\\n```\\n\\n![Screenshot 2023-03-24 at 12.14.10 AM.png](https://assets.leetcode.com/users/images/a3e161b1-c5c7-47bd-adee-4715815d5a79_1679597065.443635.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nfrom collections import Counter as counter\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counts = sorted(counter(s).values())\\n        occoured = set()\\n\\n        operations_needed = 0\\n        for item in counts:\\n            if item not in occoured:\\n                occoured.add(item)\\n            else:\\n                tmp = item\\n                while tmp in occoured:\\n                    tmp -= 1\\n                    operations_needed += 1\\n                if tmp != 0:\\n                    occoured.add(tmp)\\n\\n        return operations_needed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044794,
                "title": "using-set-and-map-in-c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        map<char,int>m;\\n        set<int>st;\\n        int count=0;\\n        for(auto i:s){\\n            m[i]++;\\n        }\\n        for(auto i:m){\\n            while(i.second >0 and st.find(i.second)!=st.end()){\\n                i.second-=1;\\n                count++;\\n            }\\n            st.insert(i.second);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        map<char,int>m;\\n        set<int>st;\\n        int count=0;\\n        for(auto i:s){\\n            m[i]++;\\n        }\\n        for(auto i:m){\\n            while(i.second >0 and st.find(i.second)!=st.end()){\\n                i.second-=1;\\n                count++;\\n            }\\n            st.insert(i.second);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839047,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n//from titan\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq (26, 0);\\n        \\n        for (char c : s){\\n            freq[c - \\'a\\']++;\\n        }\\n        \\n        sort(freq.begin(), freq.end());\\n        \\n        int del = 0; \\n\\n        for (int i = 24; i >= 0; i--) {\\n            \\n            if(freq[i] == 0) break; \\n            \\n            if(freq[i] >= freq[i+1]){\\n                int prev = freq[i]; \\n                freq[i] = max(0, freq[i+1] -1); \\n                del += prev - freq[i]; \\n            }\\n        }\\n        return del;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from titan\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq (26, 0);\\n        \\n        for (char c : s){\\n            freq[c - \\'a\\']++;\\n        }\\n        \\n        sort(freq.begin(), freq.end());\\n        \\n        int del = 0; \\n\\n        for (int i = 24; i >= 0; i--) {\\n            \\n            if(freq[i] == 0) break; \\n            \\n            if(freq[i] >= freq[i+1]){\\n                int prev = freq[i]; \\n                freq[i] = max(0, freq[i+1] -1); \\n                del += prev - freq[i]; \\n            }\\n        }\\n        return del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767306,
                "title": "c-microsoft-online-assessment-question-easy-approach",
                "content": "Here is my code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint minDeletions(string s) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tunordered_map<char, int>m, m1;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tm[s[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto it: m){\\n\\t\\t\\t\\tv.push_back(it.second);\\n\\t\\t\\t}\\n\\t\\t\\tsort(v.begin(), v.end());\\n\\t\\t\\tfor(int i=0; i<v.size(); i++){\\n\\t\\t\\t\\tm1[v[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tif(m1.size()==v.size()){return 0;}\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0; i<v.size()-1; i++){\\n\\t\\t\\t\\tif(v[i]==v[i+1]){\\n\\t\\t\\t\\t\\tint chk=v[i+1];\\n\\t\\t\\t\\t\\twhile(m1.find(chk)!=m.end()){\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t\\tchk--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(chk){m1[chk]++;}\\n\\t\\t\\t\\t\\t//v[i+1]=chk;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint minDeletions(string s) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tunordered_map<char, int>m, m1;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tm[s[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2629618,
                "title": "c-accepted-solution-using-map-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int>mp;\\n        vector<int>v;\\n\\n        for(auto ch : s)\\n        {\\n            mp[ch]++;\\n        }\\n\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n           v.push_back(it->second);\\t\\n        }\\n\\n        sort(v.begin(),v.end(),greater<int>());\\n\\n        int count=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i-1]==0)\\n            {\\n                count=count+(abs(v[i-1]-v[i]));\\n                v[i]=0;\\n            }\\n            else if(v[i-1]<=v[i])\\n            {\\n                count=count+(abs(v[i-1]-v[i])+1);\\n                v[i]=v[i-1]-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int>mp;\\n        vector<int>v;\\n\\n        for(auto ch : s)\\n        {\\n            mp[ch]++;\\n        }\\n\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n           v.push_back(it->second);\\t\\n        }\\n\\n        sort(v.begin(),v.end(),greater<int>());\\n\\n        int count=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i-1]==0)\\n            {\\n                count=count+(abs(v[i-1]-v[i]));\\n                v[i]=0;\\n            }\\n            else if(v[i-1]<=v[i])\\n            {\\n                count=count+(abs(v[i-1]-v[i])+1);\\n                v[i]=v[i-1]-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629614,
                "title": "c-accepted-solution-using-map-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int>mp;\\n        vector<int>v;\\n\\n        for(auto ch : s)\\n        {\\n            mp[ch]++;\\n        }\\n\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n           v.push_back(it->second);\\t\\n        }\\n\\n        sort(v.begin(),v.end(),greater<int>());\\n\\n        int count=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i-1]==0)\\n            {\\n                count=count+(abs(v[i-1]-v[i]));\\n                v[i]=0;\\n            }\\n            else if(v[i-1]<=v[i])\\n            {\\n                count=count+(abs(v[i-1]-v[i])+1);\\n                v[i]=v[i-1]-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int>mp;\\n        vector<int>v;\\n\\n        for(auto ch : s)\\n        {\\n            mp[ch]++;\\n        }\\n\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n           v.push_back(it->second);\\t\\n        }\\n\\n        sort(v.begin(),v.end(),greater<int>());\\n\\n        int count=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i-1]==0)\\n            {\\n                count=count+(abs(v[i-1]-v[i]));\\n                v[i]=0;\\n            }\\n            else if(v[i-1]<=v[i])\\n            {\\n                count=count+(abs(v[i-1]-v[i])+1);\\n                v[i]=v[i-1]-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616723,
                "title": "brute-force-solution-python-pretty-bad-solution-tbh",
                "content": "```python\\nfrom collections import Counter\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counter = 0\\n        dups = []\\n        hashmap_string = Counter(s)\\n        hashmap_values = [*hashmap_string.values()]\\n        hashmap = Counter([*hashmap_string.values()])\\n        for i in hashmap:\\n            if hashmap[i]==2:\\n                dups.append(i)\\n            if hashmap[i]>2:\\n                dups+=[i]*(hashmap[i]-1)\\n        for n,i in enumerate(dups):\\n            while 1:\\n                i-=1\\n                counter+=1\\n                if i==0:\\n                    break\\n                if i in hashmap_values:\\n                    continue\\n                else:\\n                    hashmap_values[n]=i\\n                    break\\n        return counter\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        counter = 0\\n        dups = []\\n        hashmap_string = Counter(s)\\n        hashmap_values = [*hashmap_string.values()]\\n        hashmap = Counter([*hashmap_string.values()])\\n        for i in hashmap:\\n            if hashmap[i]==2:\\n                dups.append(i)\\n            if hashmap[i]>2:\\n                dups+=[i]*(hashmap[i]-1)\\n        for n,i in enumerate(dups):\\n            while 1:\\n                i-=1\\n                counter+=1\\n                if i==0:\\n                    break\\n                if i in hashmap_values:\\n                    continue\\n                else:\\n                    hashmap_values[n]=i\\n                    break\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506293,
                "title": "easy-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        sd={}\\n        for i in s:\\n            if(i in sd):\\n                sd[i]+=1\\n            else:\\n                sd[i]=1\\n        s=[]\\n        for i in sd:\\n            s.append(sd[i])\\n        n=len(s)\\n        tot=0\\n        for i in range(n):\\n            while(s[i] in s[:i]+s[i+1:] and s[i]>0):\\n                s[i]-=1\\n                tot+=1\\n        return(tot)\\n            ****\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        sd={}\\n        for i in s:\\n            if(i in sd):\\n                sd[i]+=1\\n            else:\\n                sd[i]=1\\n        s=[]\\n        for i in sd:\\n            s.append(sd[i])\\n        n=len(s)\\n        tot=0\\n        for i in range(n):\\n            while(s[i] in s[:i]+s[i+1:] and s[i]>0):\\n                s[i]-=1\\n                tot+=1\\n        return(tot)\\n            ****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210594,
                "title": "c-solution-with-explaination",
                "content": "**STEPS THAT I HAVE BEEN TAKEN**\\n1. initially i start with using map to store the frequencies of characters\\n2. next step is to get the maximum frequency of all characters and store in the variable temp.\\n3.  now take a vector of maximum size (temp in my case), and initialize it with value  zero\\n4.  now collect the all the count of frequency in the vector v\\n5.  run a for loop and check if value of frequency occurence is more than one  forward the value into descent one. we have to make every distinct  v[i]=1 or 0 for every i>=1 and i<=temp;\\n6.  now initialize the variable ans =0 and check how many characters will be left in the final string by running a for loop and  summing the product of  **i * v[i]**.\\n7.  now return the answer equals to** size of string s - ans.\\n\\n\\n![image](https://assets.leetcode.com/users/images/953a99ab-96fa-4035-a83c-474f32d6894b_1656435848.025847.jpeg)\\n\\n\\n![image](https://assets.leetcode.com/users/images/4e3ee6d0-368e-499f-8c2a-d507a3d6a49c_1656435846.9378803.jpeg)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f0165ad3-d417-4f79-b2f5-9728a8a6e8c3_1656435853.3340845.jpeg)\\n\\n```\\n int minDeletions(string s) {\\n        // step 1\\n        map<char,int>mp;\\n        for(auto x:s){\\n            mp[x]++;\\n        }\\n        //step 2\\n        int temp=INT_MIN;\\n        for(auto x:mp){\\n            temp=max(temp,x.second);\\n        }\\n        // step 3\\n        vector<int>v(temp+1,0);\\n        \\n        //step 4\\n        for(auto x:mp){\\n            v[x.second]++;\\n        }\\n        // step 5\\n        int cnt=0;\\n        for(int i=temp;i>=1;i--){\\n            v[i]+=cnt;\\n            cnt=0;\\n            if(v[i]>=2){\\n                cnt=v[i]-1;\\n                v[i]=1;\\n            }\\n        }\\n        //step 6\\n        int ans=0;\\n        for(int i=1;i<=temp;i++){\\n            ans+=(i*v[i]);\\n        }\\n        //step 7\\n        return s.size()-ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int minDeletions(string s) {\\n        // step 1\\n        map<char,int>mp;\\n        for(auto x:s){\\n            mp[x]++;\\n        }\\n        //step 2\\n        int temp=INT_MIN;\\n        for(auto x:mp){\\n            temp=max(temp,x.second);\\n        }\\n        // step 3\\n        vector<int>v(temp+1,0);\\n        \\n        //step 4\\n        for(auto x:mp){\\n            v[x.second]++;\\n        }\\n        // step 5\\n        int cnt=0;\\n        for(int i=temp;i>=1;i--){\\n            v[i]+=cnt;\\n            cnt=0;\\n            if(v[i]>=2){\\n                cnt=v[i]-1;\\n                v[i]=1;\\n            }\\n        }\\n        //step 6\\n        int ans=0;\\n        for(int i=1;i<=temp;i++){\\n            ans+=(i*v[i]);\\n        }\\n        //step 7\\n        return s.size()-ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2210505,
                "title": "detailed-solution-with-example-easy-c",
                "content": "**Approch:**\\n***Create a vector of size 26 having all entries as zero\\n*Run a loop and store frequency of each char freq++  \\n*Perform sorting and arrange obtain freq in decending order \\n*Initiate count with zero value and Maxfreq with value freq[0]\\n*Run a loop with condition freq[i] > Maxfreq && freq[i]>0 and replace the value with max(0,freq[i]-1)\\n*In a lop with If condition (freq[i] >Maxfreq satisfied take difference of value of Maxfreq -freq[i]\\n**\\n\\n**Example :** \\n\\ngiven string s =  **aaaabbbbccdef**\\nfreq in sorted order are \\nfreq 4  Maxfreq 4  if condition not satisfy\\nfreq 4  Maxfreq 3 condition satisfy difference is one (4-3) (count=1)\\nfreq 2  Maxfreq 2 if condition not satisfy\\nfreq 1  Maxfreq 1 if condition not satisy \\nfreq 1  Maxfreq 0 condition satisfy difference is one (1-0) (count=2)\\nfreq 1  Maxfreq 0 condition satisfy difference is one (1-0) (count=3)\\n\\nreturn count ,this will give **** Minimum Deletions to Make Character Frequencies Unique**** .\\n\\n**Code:**\\n```\\n\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector <int>  freq(26, 0); \\n    for (char c : s) \\n    {\\n        freq[c - \\'a\\']++;\\n    }\\n      sort(freq.begin(), freq.end(), greater<int>());  \\n    int count = 0;\\n    int maxfreq = freq[0];\\n    for (int i = 0; i < 26 && freq[i] > 0; i++) \\n    {\\n        if (freq[i] > maxfreq)\\n        {\\n            count += freq[i] - maxfreq;\\n            freq[i] = maxfreq;\\n        }\\n        maxfreq = max(0, freq[i] - 1);\\n    }\\n      return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector <int>  freq(26, 0); \\n    for (char c : s) \\n    {\\n        freq[c - \\'a\\']++;\\n    }\\n      sort(freq.begin(), freq.end(), greater<int>());  \\n    int count = 0;\\n    int maxfreq = freq[0];\\n    for (int i = 0; i < 26 && freq[i] > 0; i++) \\n    {\\n        if (freq[i] > maxfreq)\\n        {\\n            count += freq[i] - maxfreq;\\n            freq[i] = maxfreq;\\n        }\\n        maxfreq = max(0, freq[i] - 1);\\n    }\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210466,
                "title": "c-set",
                "content": "```\\nclass Solution {\\n\\npublic:\\nint minDeletions(string s) {\\n\\nunordered_set<int>st;\\nvector<int>vec(26,0);\\nfor(int i=0;i<s.size();i++){\\nvec[s[i]-\\'a\\']++;\\n}\\nint count=0;\\nfor(int i=0;i<26;i++)\\n{\\nwhile(vec[i] && st.find(vec[i])!=st.end())\\n{\\nvec[i]--;\\ncount++;\\n}\\nst.insert(vec[i]);\\n}\\nreturn count;\\n}\\n};\\n```\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\nint minDeletions(string s) {\\n\\nunordered_set<int>st;\\nvector<int>vec(26,0);\\nfor(int i=0;i<s.size();i++){\\nvec[s[i]-\\'a\\']++;\\n}\\nint count=0;\\nfor(int i=0;i<26;i++)\\n{\\nwhile(vec[i] && st.find(vec[i])!=st.end())\\n{\\nvec[i]--;\\ncount++;\\n}\\nst.insert(vec[i]);\\n}\\nreturn count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209096,
                "title": "boom-python-makes-it-easy",
                "content": "Using counter, calculate frequency of each character\\nCreate a list of frequencies and sort it\\nIterate on each value in frequecy list, and decrement the value if it is not 0 and the same value exists in the list\\n\\n```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        deleted_elements = 0\\n        counter = Counter(s)\\n        freq_values = sorted(counter.values())[::-1]\\n        for index in range(len(freq_values)):\\n            while freq_values[index] != 0 and freq_values[index] in freq_values[:index] + freq_values[index+1:]:\\n                freq_values[index] -= 1\\n                deleted_elements += 1\\n        return deleted_elements\\n```\\n\\nPlease upvote if you found this helpful. \\nThank you :) \\n\\nYours-Truly-Rshi",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        deleted_elements = 0\\n        counter = Counter(s)\\n        freq_values = sorted(counter.values())[::-1]\\n        for index in range(len(freq_values)):\\n            while freq_values[index] != 0 and freq_values[index] in freq_values[:index] + freq_values[index+1:]:\\n                freq_values[index] -= 1\\n                deleted_elements += 1\\n        return deleted_elements\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208968,
                "title": "simple-solution-in-c",
                "content": "Runtime: 23 ms, faster than 90.00% of C online submissions for Minimum Deletions to Make Character Frequencies Unique.\\nMemory Usage: 8.6 MB, less than 100.00% of C online submissions for Minimum Deletions to Make Character Frequencies Unique.\\n```\\nint minDeletions(char * s){\\n    \\n    int a[26];\\n    memset(a, 0, sizeof(int)*26);\\n    unsigned int i = 0;\\n    unsigned int j = 0;\\n    int count = 0;\\n    while (s[i] != \\'\\\\0\\')\\n        a[s[i++]-\\'a\\']++;\\n    \\n    i = 0;\\n    for (; i < 26; i++) {\\n        if (a[i] == 0)\\n            continue;\\n        for (j = 0; j < 26; j++) {\\n            if (i == j || a[j] == 0)\\n                continue;\\n            if (a[i] == a[j]) {\\n                count++;\\n                a[i]--;\\n                j = -1;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minDeletions(char * s){\\n    \\n    int a[26];\\n    memset(a, 0, sizeof(int)*26);\\n    unsigned int i = 0;\\n    unsigned int j = 0;\\n    int count = 0;\\n    while (s[i] != \\'\\\\0\\')\\n        a[s[i++]-\\'a\\']++;\\n    \\n    i = 0;\\n    for (; i < 26; i++) {\\n        if (a[i] == 0)\\n            continue;\\n        for (j = 0; j < 26; j++) {\\n            if (i == j || a[j] == 0)\\n                continue;\\n            if (a[i] == a[j]) {\\n                count++;\\n                a[i]--;\\n                j = -1;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2208698,
                "title": "java-solution",
                "content": "class Solution {\\n    public int minDeletions(String s) {\\n          int[] freq = new int[26];\\n          char[] ch = s.toCharArray();\\n \\n        for(int i=0; i < ch.length; i++)\\n        {\\n            freq[ch[i] - \\'a\\']++;\\n        }\\n        Arrays.sort(freq);\\n        int del = 0;\\n\\n        int n = freq[25];\\n       \\n\\n        for (int i = 25; i >= 0; i--) {\\n            if (freq[i] == 0)\\n                break;\\n            if (freq[i] > n) {\\n                del += freq[i] - n;\\n            } else {\\n                n = freq[i];\\n            }\\n            if (n > 0) {\\n                n--;  \\n            }\\n        }\\n        return del;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minDeletions(String s) {\\n          int[] freq = new int[26];\\n          char[] ch = s.toCharArray();\\n \\n        for(int i=0; i < ch.length; i++)\\n        {\\n            freq[ch[i] - \\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2208612,
                "title": "c-o-n-time-complexity-code-o-1-constant-space-complexity",
                "content": "\\nIn this approach we are using a hash table to store the frequencies of each character the maximum size of hash table can be 26 so O(26) (Contant Space Complexity).\\nWe are also using a hast table to store unique frequencies. No. of unique frequencies cannot exceede 26 So it\\'s also taking constant space complexity.\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int> mp;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int ans=0;\\n        for(auto it:mp){\\n            if(m[it.second]>0){\\n                while(m[it.second]!=0){ //This loop will run maximum 26 times as unique frequencies cannot exceede 26\\n                    it.second--;\\n                    ans++;\\n                }\\n            }\\n            if(it.second!=0)    m[it.second]++;\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n**Please Upvote If You Find This Helpful**",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        unordered_map<char,int> mp;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int ans=0;\\n        for(auto it:mp){\\n            if(m[it.second]>0){\\n                while(m[it.second]!=0){ //This loop will run maximum 26 times as unique frequencies cannot exceede 26\\n                    it.second--;\\n                    ans++;\\n                }\\n            }\\n            if(it.second!=0)    m[it.second]++;\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208611,
                "title": "c-min-deletions-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        \\n        int ans = 0;\\n        int n = s.length();\\n        \\n        // freq array for characters\\n        vector<int> freq(26, 0);\\n        for(int i=0; i<n; i++)\\n            freq[s[i] - \\'a\\']++;\\n        \\n        // sorted, all freq are present at last\\n        sort(freq.begin(), freq.end());\\n        \\n        // starting from second last\\n        for(int i=24; i>=0; i--){\\n            \\n            if(freq[i] == 0) break;    // till we encounter 0\\n            \\n            // reduce till becomes smaller than prev, but not smaller than 0\\n            while(freq[i] >= freq[i+1] && freq[i] > 0){   \\n                freq[i]--;\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        \\n        int ans = 0;\\n        int n = s.length();\\n        \\n        // freq array for characters\\n        vector<int> freq(26, 0);\\n        for(int i=0; i<n; i++)\\n            freq[s[i] - \\'a\\']++;\\n        \\n        // sorted, all freq are present at last\\n        sort(freq.begin(), freq.end());\\n        \\n        // starting from second last\\n        for(int i=24; i>=0; i--){\\n            \\n            if(freq[i] == 0) break;    // till we encounter 0\\n            \\n            // reduce till becomes smaller than prev, but not smaller than 0\\n            while(freq[i] >= freq[i+1] && freq[i] > 0){   \\n                freq[i]--;\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208472,
                "title": "c-readable-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {        // \"aaabbbcc\"   understand with this testcase\\n        vector<int> freq(26, 0);\\n        for(char c: s) freq[c-\\'a\\']++;       // save freq    3 3 2\\n        int count = 0;\\n        sort(begin(freq), end(freq), greater<int>());       // 3 3 2 (sort in decreasing order)\\n        for(int i=1; i<26; i++){\\n      // 3 equal 3 so delete 1 now its 2 move to next here 2 equal 2 so delete 1 now all unique\\n            while(freq[i] != 0 and freq[i-1] <= freq[i]) {  // jab tak equal h delete ++\\n                freq[i]--, ++count;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n//  <= to handle \"abcabc\" case whwre all freq are equal a -> 2 so  b decreases to 1 then b -> 1 so \\n//    decrease c to 0 here 2 deletion(means delete less equal to make unique)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {        // \"aaabbbcc\"   understand with this testcase\\n        vector<int> freq(26, 0);\\n        for(char c: s) freq[c-\\'a\\']++;       // save freq    3 3 2\\n        int count = 0;\\n        sort(begin(freq), end(freq), greater<int>());       // 3 3 2 (sort in decreasing order)\\n        for(int i=1; i<26; i++){\\n      // 3 equal 3 so delete 1 now its 2 move to next here 2 equal 2 so delete 1 now all unique\\n            while(freq[i] != 0 and freq[i-1] <= freq[i]) {  // jab tak equal h delete ++\\n                freq[i]--, ++count;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n//  <= to handle \"abcabc\" case whwre all freq are equal a -> 2 so  b decreases to 1 then b -> 1 so \\n//    decrease c to 0 here 2 deletion(means delete less equal to make unique)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208012,
                "title": "c-easy-solution-sorting-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> v(26,0); \\n        for(auto i:s){\\n            v[i-\\'a\\']++; \\n        }\\n        sort(v.begin(),v.end(),greater<int>()); \\n        int count=v[0];\\n       \\n        for(int i=1;i<26;i++){\\n            if(v[i]==0 || v[i-1]==0) \\n                break;\\n            if(v[i]>=v[i-1])\\n            {\\n                v[i]-=((v[i]-v[i-1])+1);\\n            }\\n            count+=v[i];\\n        }\\n        return s.size()-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> v(26,0); \\n        for(auto i:s){\\n            v[i-\\'a\\']++; \\n        }\\n        sort(v.begin(),v.end(),greater<int>()); \\n        int count=v[0];\\n       \\n        for(int i=1;i<26;i++){\\n            if(v[i]==0 || v[i-1]==0) \\n                break;\\n            if(v[i]>=v[i-1])\\n            {\\n                v[i]-=((v[i]-v[i-1])+1);\\n            }\\n            count+=v[i];\\n        }\\n        return s.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207892,
                "title": "2-steps-simply-using-greedy-approach",
                "content": "**Two steps:**\\n- Store the frequency of each letter in a vector\\n- Then, insert frequency of each element in the set.\\n\\t- If the frequency is used, then reduce the frequency and try again\\n\\t- If the frequency reaches 0, then break it\\n\\nAnd you are done!\\n\\nTime complexity:   **O(n)**\\nSpace complexity: O(26) = **O(1)**\\n\\nPlease **Upovte ^** if you like to see more posts like this!\\n\\n**c++ solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26);\\n        unordered_set<int> set;\\n        int ans = 0;\\n        \\n        for(char ch: s)\\n            freq[ch - \\'a\\']++;\\n        \\n        for(char ch = 0; ch < 26; ch++)\\n            while(freq[ch] and !set.insert(freq[ch]).second)\\n                freq[ch]--, ans++;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThank you everyone. Happy coding!\\n\\t",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26);\\n        unordered_set<int> set;\\n        int ans = 0;\\n        \\n        for(char ch: s)\\n            freq[ch - \\'a\\']++;\\n        \\n        for(char ch = 0; ch < 26; ch++)\\n            while(freq[ch] and !set.insert(freq[ch]).second)\\n                freq[ch]--, ans++;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207798,
                "title": "frequency-array-simple-approach-96-faster-c",
                "content": "```\\n    int minDeletions(string s) {\\n        int ch[26]={0};\\n        int freq[100000+1]={0};\\n        for(char c:s)ch[c-\\'a\\']++;\\n        int ans=0;\\n        sort(ch,ch+26);\\n        for(int i:ch){\\n            if(i==0)continue;\\n            else if(freq[i]==0)freq[i]++;\\n            else{\\n                int ct=i;\\n                while(freq[ct]!=0 && ct>0)ct--;\\n                ans+=i-ct;\\n                freq[ct]++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minDeletions(string s) {\\n        int ch[26]={0};\\n        int freq[100000+1]={0};\\n        for(char c:s)ch[c-\\'a\\']++;\\n        int ans=0;\\n        sort(ch,ch+26);\\n        for(int i:ch){\\n            if(i==0)continue;\\n            else if(freq[i]==0)freq[i]++;\\n            else{\\n                int ct=i;\\n                while(freq[ct]!=0 && ct>0)ct--;\\n                ans+=i-ct;\\n                freq[ct]++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207691,
                "title": "javascript-recursive-function",
                "content": "Idea here is to pick up each freq one by one. \\nLet\\'s take a string:  \"aaabbbccddeefgh\"\\n\\nFreq bucket: \\n**Freq**    **Characters**\\n3 => a, b\\n2 => c, d, e\\n1 => f, g, h\\n\\nWhat we want is in each frequency there should be only 1 character. So one of the desired result will be:\\n3 => a\\n2 => c\\n1 => f\\n\\nSo, Perform following steps recursively till there is no multiple characters against each frequency\\n1. For any frequency in any order, keep only one character against this frequency\\n    For e.g. In 3 freq, keep \\'a\\', and move **\\'b\\'** to freq 2\\'s bucket. Increament count by 1.\\n\\t3 => a\\n2 => c, d, e, **b**\\n1 => f, g, h\\n\\n2. Freq 3 is processed, take freq 2. \\n    Move **d, e, b** to #{currentFreq - 1}, which is freq bucket 1. Removed 3 chars. So total deletion count is 4.\\n\\t\\t3 => a\\n2 => c\\n1 => f, g, h, **d, e, b**\\n\\n3. Now, only freq 1 has more than 1 character.\\n  Move **g, h, d, e, b** to the #{currentFreq - 1}, There is no frequency bucket for freq 0. So we will delete those chars.\\n  We are deleting 5 chars here. So total 9 chars are deleted.\\n3 => a\\n2 => c\\n1 => f\\n\\nAbove map fulfills the requirement of having only 1 unique char in each freq bucket\\n3 => a\\n2 => c\\n1 => f\\nSo, **9** is the answer.\\n\\n\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    const map = {};\\n    const revMap = {};\\n    let ch;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        ch = s[i];\\n        map[ch] || (map[ch] = 0);\\n        map[ch]++;                \\n    }\\n    \\n    for(let ch in map) {\\n        let count = map[ch];\\n        revMap[count] || (revMap[count] = {});\\n        revMap[count][ch] = true;\\n    }\\n    \\n    \\n    function chainReaction(deleted = 0) {\\n        \\n        for(let count in revMap) {\\n            const currDict = revMap[count];\\n            const chs = Object.keys(currDict);\\n            const lessCount = count - 1;\\n            \\n            for(let i = 0; i < chs.length - 1; i++) {\\n                ch = chs[i];\\n                delete currDict[ch];                \\n                if (lessCount > 0) {\\n                    revMap[lessCount] || (revMap[lessCount] = {});\\n                    revMap[lessCount][ch] = true;\\n                }               \\n                deleted++;\\n            }                \\n            \\n            if (chs.length > 1) {\\n                deleted = chainReaction(deleted);\\n            }\\n        }\\n        \\n        return deleted;\\n    }\\n        \\n    return chainReaction(0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minDeletions = function(s) {\\n    const map = {};\\n    const revMap = {};\\n    let ch;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        ch = s[i];\\n        map[ch] || (map[ch] = 0);\\n        map[ch]++;                \\n    }\\n    \\n    for(let ch in map) {\\n        let count = map[ch];\\n        revMap[count] || (revMap[count] = {});\\n        revMap[count][ch] = true;\\n    }\\n    \\n    \\n    function chainReaction(deleted = 0) {\\n        \\n        for(let count in revMap) {\\n            const currDict = revMap[count];\\n            const chs = Object.keys(currDict);\\n            const lessCount = count - 1;\\n            \\n            for(let i = 0; i < chs.length - 1; i++) {\\n                ch = chs[i];\\n                delete currDict[ch];                \\n                if (lessCount > 0) {\\n                    revMap[lessCount] || (revMap[lessCount] = {});\\n                    revMap[lessCount][ch] = true;\\n                }               \\n                deleted++;\\n            }                \\n            \\n            if (chs.length > 1) {\\n                deleted = chainReaction(deleted);\\n            }\\n        }\\n        \\n        return deleted;\\n    }\\n        \\n    return chainReaction(0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207674,
                "title": "c-frequency-count-hashset-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26, 0);\\n        for(char& c : s)\\n            freq[c-\\'a\\']++;\\n        \\n        unordered_set<int> seen;\\n        int res = 0;\\n        \\n        for(int i = 0; i < 26; i++) {   // go through each freq\\n            // if this freq is non-zero and already used, then decrease it until a unique freq is found\\n            // increase the delete count by 1 for each decrement in freq\\n            while(freq[i] > 0 and seen.find(freq[i]) != seen.end()) {\\n                freq[i]--;\\n                res++;\\n            }\\n            seen.insert(freq[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> freq(26, 0);\\n        for(char& c : s)\\n            freq[c-\\'a\\']++;\\n        \\n        unordered_set<int> seen;\\n        int res = 0;\\n        \\n        for(int i = 0; i < 26; i++) {   // go through each freq\\n            // if this freq is non-zero and already used, then decrease it until a unique freq is found\\n            // increase the delete count by 1 for each decrement in freq\\n            while(freq[i] > 0 and seen.find(freq[i]) != seen.end()) {\\n                freq[i]--;\\n                res++;\\n            }\\n            seen.insert(freq[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207623,
                "title": "python-simple-python-solution-using-hashmap-dictionary",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 285 ms, faster than 44.94% of Python3 online submissions for Minimum Deletions to Make Character Frequencies Unique.\\n# Memory Usage: 15 MB, less than 17.36% of Python3 online submissions for Minimum Deletions to Make Character Frequencies Unique.\\n\\n\\tclass Solution:\\n\\t\\tdef minDeletions(self, s: str) -> int:\\n\\n\\t\\t\\td = {}\\n\\t\\t\\tresult = 0\\n\\t\\t\\tvisted = []\\n\\n\\t\\t\\tfor char in s:\\n\\t\\t\\t\\n\\t\\t\\t\\tif char not in d:\\n\\t\\t\\t\\t\\td[char] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\td[char] = d[char] + 1\\n\\n\\t\\t\\td = dict(sorted(d.items(), key = lambda x : x[1]))\\n\\n\\t\\t\\tfor i in d:\\n\\t\\t\\t\\n\\t\\t\\t\\tif d[i] not in visted:\\n\\t\\t\\t\\t\\tvisted.append(d[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\twhile d[i] != 0:\\n\\n\\t\\t\\t\\t\\t\\tif d[i] not in visted:\\n\\t\\t\\t\\t\\t\\t\\tvisted.append(d[i])\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\t\\td[i] = d[i] - 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "class Solution:\\n\\t\\tdef minDeletions(self, s: str) -> int:\\n\\n\\t\\t\\td = {}",
                "codeTag": "Java"
            },
            {
                "id": 2207608,
                "title": "c-solution-from-hints",
                "content": "**Runtime: 118 ms\\nMemory Usage: 17.3 MB**\\n```\\nint minDeletions(string s) {\\n\\tvector<int> freq(26,0);                            //Frequency Array\\n\\tfor(int i=0;i<s.size();i++){\\n\\t\\tfreq[s[i]-\\'a\\']++;\\n\\t}\\n\\tint flag=1, ans=0;\\n\\twhile(flag==1){\\n\\t\\tflag=0;\\n\\t\\tsort(freq.rbegin(), freq.rend());                       //Sorting in Non-Increasing order\\n\\t\\tfor(int i=1;i<freq.size();i++){\\n\\t\\t\\tif(freq[i]==0)break;          //Frequency with 0 means those elements are removed\\n\\t\\t\\tif(freq[i]==freq[i-1]){\\n\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\nPlease do Upvote.",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nint minDeletions(string s) {\\n\\tvector<int> freq(26,0);                            //Frequency Array\\n\\tfor(int i=0;i<s.size();i++){\\n\\t\\tfreq[s[i]-\\'a\\']++;\\n\\t}\\n\\tint flag=1, ans=0;\\n\\twhile(flag==1){\\n\\t\\tflag=0;\\n\\t\\tsort(freq.rbegin(), freq.rend());                       //Sorting in Non-Increasing order\\n\\t\\tfor(int i=1;i<freq.size();i++){\\n\\t\\t\\tif(freq[i]==0)break;          //Frequency with 0 means those elements are removed\\n\\t\\t\\tif(freq[i]==freq[i-1]){\\n\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2146974,
                "title": "cpp-easy-code-greedy-solution-0-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // this is a variation of hash table \\n        // here we will calculate the frequecy then we will sort the frequencies in descending order \\n        // the we will run the loop and find the same frequencies and reduce it by 1 for each similarity \\n        // at last we will stop\\n        // edge case can be when string frequecy of the eleement is same for all the charcter and string length is greater than the number of charcters in the string\\n        \\n        int n = s.size();\\n        \\n        // making frequency array \\n        vector<int> hash ( 26 , 0);\\n        \\n        for ( char ch : s ) hash[ch - \\'a\\']++;\\n        \\n        // now sorting the hash function \\n        sort( hash.rbegin() , hash.rend() );\\n        \\n        int thresholdFrq = hash.at(0);\\n        int ans = 0 ;\\n        \\n        for ( auto frequency : hash ){\\n            if ( frequency > thresholdFrq){\\n                if ( thresholdFrq > 0 )\\n                    ans += frequency - thresholdFrq ;\\n                else \\n                    ans += frequency ;\\n            }\\n            \\n            thresholdFrq = min ( thresholdFrq - 1 , frequency - 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        // this is a variation of hash table \\n        // here we will calculate the frequecy then we will sort the frequencies in descending order \\n        // the we will run the loop and find the same frequencies and reduce it by 1 for each similarity \\n        // at last we will stop\\n        // edge case can be when string frequecy of the eleement is same for all the charcter and string length is greater than the number of charcters in the string\\n        \\n        int n = s.size();\\n        \\n        // making frequency array \\n        vector<int> hash ( 26 , 0);\\n        \\n        for ( char ch : s ) hash[ch - \\'a\\']++;\\n        \\n        // now sorting the hash function \\n        sort( hash.rbegin() , hash.rend() );\\n        \\n        int thresholdFrq = hash.at(0);\\n        int ans = 0 ;\\n        \\n        for ( auto frequency : hash ){\\n            if ( frequency > thresholdFrq){\\n                if ( thresholdFrq > 0 )\\n                    ans += frequency - thresholdFrq ;\\n                else \\n                    ans += frequency ;\\n            }\\n            \\n            thresholdFrq = min ( thresholdFrq - 1 , frequency - 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137201,
                "title": "python-greedy-clean-code",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        frequencies = Counter(s)\\n        uniqueFrequencies = set()\\n        result = 0\\n        \\n        for frequency in frequencies.values():\\n            while frequency and frequency in uniqueFrequencies:\\n                frequency -= 1\\n                result += 1\\n            uniqueFrequencies.add(frequency)\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minDeletions(self, s: str) -> int:\\n        frequencies = Counter(s)\\n        uniqueFrequencies = set()\\n        result = 0\\n        \\n        for frequency in frequencies.values():\\n            while frequency and frequency in uniqueFrequencies:\\n                frequency -= 1\\n                result += 1\\n            uniqueFrequencies.add(frequency)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118903,
                "title": "c-sorting-intuitive",
                "content": "Using a dictionary to track frequencies, iterate over the input string and determine how many times each character occurs.\\n\\nNext, we sort by frequency descending. If the current frequency has not been used, then use it without deleting any characters. Otherwise, we need to delete some characters. The number to delete is determined by the last frequency we used, we must use 1 less.\\n\\nThe edge case here is, we can never delete more characters than occur in the input. If the last used frequency is 0, that is lowest freqency we can have.\\n\\n```\\npublic int MinDeletions(string s) {\\n    var counts = new Dictionary<char, int>();\\n    foreach (char c in s) {\\n        counts[c] = counts.GetValueOrDefault(c) + 1;\\n    }\\n    int last = int.MaxValue, deletions = 0;\\n    foreach (var p in counts.OrderByDescending(x => x.Value)) {\\n        last = Math.Min(last - 1, p.Value);\\n        last = Math.Max(last, 0);\\n        deletions += p.Value - last;\\n    }\\n    return deletions;\\n}\\n```\\n\\n - Runtime: O(N + K log K)\\n - Space: O(K)\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\npublic int MinDeletions(string s) {\\n    var counts = new Dictionary<char, int>();\\n    foreach (char c in s) {\\n        counts[c] = counts.GetValueOrDefault(c) + 1;\\n    }\\n    int last = int.MaxValue, deletions = 0;\\n    foreach (var p in counts.OrderByDescending(x => x.Value)) {\\n        last = Math.Min(last - 1, p.Value);\\n        last = Math.Max(last, 0);\\n        deletions += p.Value - last;\\n    }\\n    return deletions;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103296,
                "title": "java-greedy-tc-o-n",
                "content": "// Time Complexity: O(26 * n) = O(n)\\n// Space Complexity: O(1)\\n```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] cnt = new int[26];\\n        Set<Integer> used = new HashSet<>();\\n        // extract the frequency\\n        for(char ch: s.toCharArray()) {\\n            cnt[ch - \\'a\\']++;\\n        }\\n        // iterate over the cnt array and check freq \\n        int minDeletions = 0;\\n        for(int i = 0; i < 26; i++) { \\n            int freq = cnt[i];\\n            while(freq > 0) {        \\n                if(!used.contains(freq)) { // if freq is not present in set(freq not encountered earlier), then add it\\n                    used.add(freq);\\n                    break;\\n                }\\n                // already present then reduce the freq and increase the minDeletions\\n                freq--;\\n                minDeletions++;\\n            }\\n        }\\n        return minDeletions;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] cnt = new int[26];\\n        Set<Integer> used = new HashSet<>();\\n        // extract the frequency\\n        for(char ch: s.toCharArray()) {\\n            cnt[ch - \\'a\\']++;\\n        }\\n        // iterate over the cnt array and check freq \\n        int minDeletions = 0;\\n        for(int i = 0; i < 26; i++) { \\n            int freq = cnt[i];\\n            while(freq > 0) {        \\n                if(!used.contains(freq)) { // if freq is not present in set(freq not encountered earlier), then add it\\n                    used.add(freq);\\n                    break;\\n                }\\n                // already present then reduce the freq and increase the minDeletions\\n                freq--;\\n                minDeletions++;\\n            }\\n        }\\n        return minDeletions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030886,
                "title": "most-easiest-0-n-java",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] alp=new int[26];\\n       \\n\\t   // store the frequecy of each character \\n        for(int i=0;i<s.length();i++){\\n            alp[s.charAt(i)-\\'a\\']++;\\n        }\\n        int ans=0;\\n        \\n\\t\\t//is used to make frequecy is unique\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for(int i=0;i<26;i++){\\n            if(alp[i]!=0){  //if alp[i]==0 then number of character is 0   \\n                if(!arr.contains(alp[i])){   // if it is come first time then just add it \\n                    arr.add(alp[i]);\\n                }else{    //it comes previously ,(we need to make it unique\\n                    int t=alp[i];\\n                   \\n                    while(arr.contains(t) && t>0){    // we decrement t untill it become unique or 0\\n                        t--;\\n                        ans++;\\n                    }\\n                    arr.add(t);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n} \\n\\n```\\n\\n\\t\\n\\t***If You face any problem to understand Solution comment on it***",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] alp=new int[26];\\n       \\n\\t   // store the frequecy of each character \\n        for(int i=0;i<s.length();i++){\\n            alp[s.charAt(i)-\\'a\\']++;\\n        }\\n        int ans=0;\\n        \\n\\t\\t//is used to make frequecy is unique\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for(int i=0;i<26;i++){\\n            if(alp[i]!=0){  //if alp[i]==0 then number of character is 0   \\n                if(!arr.contains(alp[i])){   // if it is come first time then just add it \\n                    arr.add(alp[i]);\\n                }else{    //it comes previously ,(we need to make it unique\\n                    int t=alp[i];\\n                   \\n                    while(arr.contains(t) && t>0){    // we decrement t untill it become unique or 0\\n                        t--;\\n                        ans++;\\n                    }\\n                    arr.add(t);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n} \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889978,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> vec(26,0);\\n        int temp = 0, ans = 0;\\n        for(auto x:s){vec[x-\\'a\\']++;}\\n        priority_queue<int> pq;\\n        for(int i:vec){if(i!=0){pq.push(i);}}\\n        while(!pq.empty() && pq.top()>0){\\n            temp = pq.top();\\n            pq.pop();\\n            if(!pq.empty() && pq.top()==temp){\\n                temp--;\\n                pq.push(temp);\\n                ans++;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletions(string s) {\\n        vector<int> vec(26,0);\\n        int temp = 0, ans = 0;\\n        for(auto x:s){vec[x-\\'a\\']++;}\\n        priority_queue<int> pq;\\n        for(int i:vec){if(i!=0){pq.push(i);}}\\n        while(!pq.empty() && pq.top()>0){\\n            temp = pq.top();\\n            pq.pop();\\n            if(!pq.empty() && pq.top()==temp){\\n                temp--;\\n                pq.push(temp);\\n                ans++;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883982,
                "title": "java-hashmap-and-hashset",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n        for(char ch : s.toCharArray()) {\\n            freqMap.put(ch, freqMap.getOrDefault(ch,0)+1);\\n        }\\n        int deleteCount = 0;\\n        Set<Integer> seenFrequencies = new HashSet<>();\\n        for(char key : freqMap.keySet()) {\\n            int freq = freqMap.get(key);\\n            while(freq > 0 && seenFrequencies.contains(freq)) {\\n                freqMap.put(key, --freq);\\n                deleteCount++;\\n            }\\n            seenFrequencies.add(freq);\\n        }\\n        return deleteCount;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n        for(char ch : s.toCharArray()) {\\n            freqMap.put(ch, freqMap.getOrDefault(ch,0)+1);\\n        }\\n        int deleteCount = 0;\\n        Set<Integer> seenFrequencies = new HashSet<>();\\n        for(char key : freqMap.keySet()) {\\n            int freq = freqMap.get(key);\\n            while(freq > 0 && seenFrequencies.contains(freq)) {\\n                freqMap.put(key, --freq);\\n                deleteCount++;\\n            }\\n            seenFrequencies.add(freq);\\n        }\\n        return deleteCount;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868191,
                "title": "java-hashset-o-n",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) {\\n            count[c-\\'a\\'] ++;\\n        }\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : count) {\\n            if (num != 0) {\\n                while (num != 0 && set.contains(num)) {\\n                    res++;\\n                    num--;\\n                }\\n                set.add(num);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s) {\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) {\\n            count[c-\\'a\\'] ++;\\n        }\\n        int res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : count) {\\n            if (num != 0) {\\n                while (num != 0 && set.contains(num)) {\\n                    res++;\\n                    num--;\\n                }\\n                set.add(num);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863427,
                "title": "c-cleanest-and-shortest-code-using-set-for-easy-understanding",
                "content": "```\\n    int minDeletions(string str)                        {\\n        vector<int> h(26, 0)                            ;\\n        for(auto x : str)h[x-\\'a\\']++                     ;    \\n        set<int> s                                      ;\\n        int ans = 0                                     ;\\n        for(int i=0; i < 26; i++)                       {\\n            while(h[i] and (s.find(h[i])!=s.end()))     {\\n                h[i]--; ans++                           ;}\\n            s.insert(h[i])                              ;}\\n        return ans                                      ;}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n    int minDeletions(string str)                        {\\n        vector<int> h(26, 0)                            ;\\n        for(auto x : str)h[x-\\'a\\']++                     ;    \\n        set<int> s                                      ;\\n        int ans = 0                                     ;\\n        for(int i=0; i < 26; i++)                       {\\n            while(h[i] and (s.find(h[i])!=s.end()))     {\\n                h[i]--; ans++                           ;}\\n            s.insert(h[i])                              ;}\\n        return ans                                      ;}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774432,
                "title": "very-easy-python-solution",
                "content": "```\\n        d={}\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        lis=[]\\n        a=0\\n        for values in d.values():\\n            while values in lis:\\n                values-=1\\n                a+=1\\n            if values!=0:\\n                lis.append(values)\\n        return a\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        d={}\\n        for i in s:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        lis=[]\\n        a=0\\n        for values in d.values():\\n            while values in lis:\\n                values-=1\\n                a+=1\\n            if values!=0:\\n                lis.append(values)\\n        return a\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1662487,
                "title": "easy-c-using-priority-queue",
                "content": "Algorithm:\\n1. Simply count each character using \"for loop\"\\n2. Push each character with it\\'s count in priority_queue (max_heap)\\n\\tmake_pair(count_of_character, character)\\n3. While size of priority_queue is greater than 1:\\n\\t\\tPick two top elements having higest occurance.\\n\\t\\tIf count of both are different, then simply pop first as we don\\'t have to consider reducing it and push the second element back in priority_queue;\\n\\t\\tIf same count, decrease the first and push both back back to priority_queue.(increament the result as we have decreased the value).\\n\\n\\t\\n\\t\\tint minDeletions(string s) {\\n\\t\\t\\t// to store occurance of each character in max heap\\n\\t\\t\\tpriority_queue<pair<int,char>> pq;\\n\\t\\t\\t\\n\\t\\t\\t// to count each character\\n\\t\\t\\tint arr[26]={0};\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tarr[s[i]-\\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t//pushing the occurance to max_heap as it will always have highest count on top\\n\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\tif(arr[i]){\\n\\t\\t\\t\\t\\tpq.push(make_pair(arr[i],(i+\\'a\\')));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint result=0;\\n\\t\\t\\twhile(pq.size()>1){\\n\\t\\t\\t\\tpair<int,char> t1=pq.top();\\n\\t\\t\\t\\t//poping only first element as second element needed for comparision with third and so on\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tpair<int,char> t2=pq.top();\\n\\t\\t\\t\\tif(t1.first==t2.first){\\n\\t\\t\\t\\t\\tt1.first-=1;\\n\\t\\t\\t\\t\\tif(t1.first>0)\\n\\t\\t\\t\\t\\t\\tpq.push(t1);\\n\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "Algorithm:\\n1. Simply count each character using \"for loop\"\\n2. Push each character with it\\'s count in priority_queue (max_heap)\\n\\tmake_pair(count_of_character, character)\\n3. While size of priority_queue is greater than 1:\\n\\t\\tPick two top elements having higest occurance.\\n\\t\\tIf count of both are different, then simply pop first as we don\\'t have to consider reducing it and push the second element back in priority_queue;\\n\\t\\tIf same count, decrease the first and push both back back to priority_queue.(increament the result as we have decreased the value).\\n\\n\\t\\n\\t\\tint minDeletions(string s) {\\n\\t\\t\\t// to store occurance of each character in max heap\\n\\t\\t\\tpriority_queue<pair<int,char>> pq;\\n\\t\\t\\t\\n\\t\\t\\t// to count each character\\n\\t\\t\\tint arr[26]={0};\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tarr[s[i]-\\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t//pushing the occurance to max_heap as it will always have highest count on top\\n\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\tif(arr[i]){\\n\\t\\t\\t\\t\\tpq.push(make_pair(arr[i],(i+\\'a\\')));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint result=0;\\n\\t\\t\\twhile(pq.size()>1){\\n\\t\\t\\t\\tpair<int,char> t1=pq.top();\\n\\t\\t\\t\\t//poping only first element as second element needed for comparision with third and so on\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tpair<int,char> t2=pq.top();\\n\\t\\t\\t\\tif(t1.first==t2.first){\\n\\t\\t\\t\\t\\tt1.first-=1;\\n\\t\\t\\t\\t\\tif(t1.first>0)\\n\\t\\t\\t\\t\\t\\tpq.push(t1);\\n\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1661520,
                "title": "java-faster-than-62-46",
                "content": "```\\nclass Solution {\\n    public int minDeletions(String s)\\n    {\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n        {\\n            freq[ch-\\'a\\']++;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        int min_del=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            while(freq[i]>0)\\n            {\\n                if(!set.contains(freq[i]))\\n                {\\n                    set.add(freq[i]);\\n                    break;\\n                }\\n                freq[i]--;\\n                min_del++;      \\n            }\\n        }\\n        return minDel;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletions(String s)\\n    {\\n        int[] freq = new int[26];\\n        for(char ch : s.toCharArray())\\n        {\\n            freq[ch-\\'a\\']++;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        int min_del=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            while(freq[i]>0)\\n            {\\n                if(!set.contains(freq[i]))\\n                {\\n                    set.add(freq[i]);\\n                    break;\\n                }\\n                freq[i]--;\\n                min_del++;      \\n            }\\n        }\\n        return minDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570231,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2010736,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1857861,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2053986,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2054241,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1661521,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1749777,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2054036,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1567149,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2054598,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1570231,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2010736,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1857861,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2053986,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2054241,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1661521,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1749777,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2054036,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 1567149,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2054598,
                "content": [
                    {
                        "username": "pratiek123",
                        "content": "This exact same question was asked in American Express Online Test Round."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@jems1123](/jems1123) Explain what, Indian are the best, go search tutorials on java and you will find that most videos are made by indians"
                    },
                    {
                        "username": "jems1123",
                        "content": "[@DamianIvanochko](/DamianIvanochko) explain it?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@bhuppidhamii](/bhuppidhamii) Indians are the best at coding"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "[@DamianIvanochko](/DamianIvanochko) wht do you mean?"
                    },
                    {
                        "username": "ankit1478",
                        "content": " same question was asked in Microsoft Online Test Round"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "If Microsoft asks this easy question then I think its not hard to crack :>"
                    },
                    {
                        "username": "matheusflauzino",
                        "content": "# The step-by-step of the approach is as follows:\n\n1. We define a function called \"minDeletions\" that takes a string \"s\" as input.\n2. We create two data structures to assist in processing: a Map called \"freqMap\" and a Set called \"freqSet\". The Map is used to store the frequency of each character in the string, and the Set is used to store the frequencies already found previously.\n3. We use a \"for\" loop to iterate over each character in the string \"s\". For each character, we increment the value of its frequency in the \"freqMap\" Map.\n4. We initialize a variable \"deletions\" with the value zero. This variable will be used to count the number of deletions needed to make the string \"good\".\n5. We use a \"for...of\" loop to iterate over each key-value pair of the \"freqMap\" Map. For each key-value pair, we check if the frequency already exists in the \"freqSet\" Set. If it already exists, we decrement the frequency until finding a unique frequency and increment the \"deletions\" variable to count this removal. This ensures that each frequency is unique. Then, we add the unique frequency to the \"freqSet\" Set.\n6. We return the value of the \"deletions\" variable, which represents the minimum number of characters that need to be deleted to make the string \"s\" \"good\".\n\n[Solution here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/3395820/javascript-solution-using-map-and-set/), don't use directly  ;)"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Drucoder](/Drucoder) Sorting applies to an array of size <= 26 (there would be no more than 26 distinct frequencies). So it\\'s not O(n log n), it\\'s rather a constant compared to n. But you would have to allocate 100\\'000 of 32-bit pairs for maxFrequency-sized array, and, presumably, another one of 100\\'000 x 64-bit. Apart from taking an extra megabyte, this this would result in a lot of traversal. The top 11ms solution wouldn\\'t be beaten, for sure."
                    },
                    {
                        "username": "Drucoder",
                        "content": "We don't need map and set; simple arrays and sorting can work as well. Check out my solution. \n\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4036538/simple-solution-without-complex-data-structures-like-heaps-maps-and-set/"
                    },
                    {
                        "username": "user1313fq",
                        "content": "I used the same thing, basically a map and set. I also agree with [@Sergei](/sergei99) but I personally used a map as well to be a bit more clear in my code."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@azharsheikh760](/azharsheikh760) and we don\\'t need any maps either. A 26-integer array would do."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "you don\\'t need `set` for this, can we used freqMap on another iteration \\nyou can check my solution \\nhttps://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4034402/javascript-no-sorting-and-no-array-using-single-hash-map-clean-solution/?envType=daily-question&envId=2023-09-12\\n\\n\\ni am just wondering what the optimal solution "
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Week of strings questions has started "
                    },
                    {
                        "username": "anivaries",
                        "content": "Some confidence boost"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "Do check for the case \"bbcebab\"."
                    },
                    {
                        "username": "gullyboy007",
                        "content": "What if the frequency of characters is 433222 ? Can I make it 432100 and will it still be considered good ? Do repetitions of 0 don\\'t matter, a little bit of clarification would have been better."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "A repetition of 0 means the characters have zero frequency and thus don\\'t exist. So, how can something repeat if it doesn\\'t exist? At the end you want character frequencies to be non-repeating."
                    },
                    {
                        "username": "Priytosh31",
                        "content": "I think the clarity is already provided, the example 3 reads as follows \\n\\nInput: s = \"ceabaacb\"\\nOutput: 2\\nExplanation: You can delete both \\'c\\'s resulting in the good string \"eabaab\".\\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\\n\\nAlso, its kinda obvious if 0 is not ignored, frequency of all other characters in the range a-z would have been 0 and your frequency list would have been like, \\n00004332220000000000000000. Which is not the case."
                    },
                    {
                        "username": "abhilashExtra2ab",
                        "content": "Just for curiosity, how would we know that it is a problem related to greedy algorithm?"
                    },
                    {
                        "username": "eostling",
                        "content": "One way I go about trying to figure out if greedy is a correct approach is if I can make an operation local state (sub-array, substr etc...) and then compare with the global state that I have, if this type of logic is something I go to, then greedy is a possibility."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "check problem tags <3"
                    },
                    {
                        "username": "singh__12",
                        "content": "Follow these steps-\\n1. Count the character frequencies.\\n2. Sort the frequencies.\\n3. Iterate from the highest frequency to the second highest.\\n4. Determine how much to deduct from the current frequency to make it less than or equal to the next frequency."
                    },
                    {
                        "username": "sergei99",
                        "content": "That seeed to be the right way to me either.\\nI\\'ve tried it this morning: 16 ms with sorting (C++) for best attempt.\\nThen I\\'ve changed sorting to make_heap, pop_heap, etc., and removed all jumps I could. It hit 15 ms.\\nAnd since then I can\\'t push it any lower. The current solution at 13 ms is doing so many unnecessary operations, and I can\\'t keep up with it. This is so screwed up. I\\'ve even unrolled the string reading loop 8 times to read it in quadwords, out of desperation..."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) yeah you don\\'t need to, but if you do it will just make your code a bit faster since now you won\\'t have to use a set.\\n[I\\'ve explained the approach here](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033990/easy-solution-with-explanation-and-visualization-99-87/) with visualization too"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "I don\\'t think we need to sort the frequencies "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Decrement Each Duplicate Until it is Unique\n\n  \n**Approach 2:** Priority Queue\n\n  \n**Approach 3:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is for me too busy. Now I can begin to solve the question. \nWithout sort the frequency table or with sort which way is fast?"
                    },
                    {
                        "username": "sergei99",
                        "content": "With LeetCode it heavily depends on the input data. They are sometimes so eager to hit you with edge cases that they forget non-edge cases. I\\'ve once seen a solution to \"Contains Duplicate II\" which for large lists (length > 300) had been just checking elements at the edge of the specified uniqueness range, entirely ignoring the rest of the range. It had passed all tests and won a top execution time, that\\'s how I saw its code."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) You\\'re right. I correct it."
                    },
                    {
                        "username": "sergei99",
                        "content": "Where n is the number of frequencies, i.e. at most 26? Well, why not then? I\\'m about to adopt the O(n^2) solution because my sorting code just can\\'t get below 15ms (C++). How did those top folks acheve 11ms?"
                    }
                ]
            },
            {
                "id": 2054213,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2054121,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2054437,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2054250,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2054196,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2057346,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2056558,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2055271,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2054627,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2054210,
                "content": [
                    {
                        "username": "Ayush0208",
                        "content": "We can try a straightforward method by using an unordered map to count the frequencies of each character, reverse the map, iterate through the characters using the condition that the current character\\'s frequency is greater than the previous one\\'s frequency and that the frequency is greater than zero, and then decrease the frequency by one while increasing the answer by one.\\n "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I guess multiset is better than sort, but my test result shows no difference in time efficiency."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ProtocolCheese](/ProtocolCheese) well, the deletion computation part might be O(string length), but not O(f log f) like in sorting algorithm (where f = number of frequencies, i.e. 26)."
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "[@sergei99](/sergei99) Multiset is o(n). That's because the total frequency of every character summed up equals n. Worst case you delete all characters, since deleting a character is constant time, the total time complexity is o(n)."
                    },
                    {
                        "username": "sergei99",
                        "content": "That\\'s strange because when you walk down the frequencies list, you can compute the number of deletions for each step in one operation, while the set/mutliset stuff requires walking through each individual frequency until you find a free one."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Tip :  Just you have to make the frequency of letters in strictly decreasing order.\\nAlso take care of these test cases : \"bbcebab\" and \"abcabc\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "don\\'t know, but these questions look easy, LOL"
                    },
                    {
                        "username": "reassurance",
                        "content": "Be sure to test out the below test case.\\n```\\nInput: \"accdcdadddbaadbc\"\\n```"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Hey guys, my solution seems to be correct but it gave wrong output for \\ns =\"bbcebab\"\\nOutput : 3\\nExpected : 2\\n\\nWe can see that \\nb comes 4 times and a,c,e come one times each, if we delete any two elements in this group, we would have frequencies of 4,1,0 and 0 which is unique.So the minimum deletions should be 2 instead of 3.Correct me if I am wrong.\\n## Solution \\nclass Solution {\\npublic:\\n    struct compare {\\n    bool operator()(const pair<char,int> &a, const pair<char,int> &b){\\n        return a.second<b.second;\\n    }\\n    };\\n    \\n    int minDeletions(string s) {\\n        unordered_map<char, int> ump;\\n\\n        for(char c : s)     ump[c]++;\\n        \\n        priority_queue<pair<char,int>, vector<pair<char,int>>,compare> pq;\\n\\n        for (auto& pair : ump) {    pq.push(pair);  }\\n\\n        int del=0,larFreq=pq.top().second;\\n\\n        while (!pq.empty()) {\\n            pair<char, int> top = pq.top();\\n            pq.pop();\\n\\n            top.second<larFreq ? larFreq=top.second : del+=top.second-larFreq;\\n            larFreq--;\\n        }\\n\\n        return del;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "yes"
                    },
                    {
                        "username": "sergei99",
                        "content": "Iteration 1: on entry `larFreq == 4`, `top.second == 4`, on exit `larFreq == 3`, `del == 0`.\nIteration 2: on entry `larFreq == 3`, `top.second == 1`, on exit `larFreq == 0`, `del == 0`.\nIteration 3: on entry `larFreq == 0`, `top.second == 1`, on exit `larFreq == -1`, `del == 1`.\nIteration 4: on entry `larFreq == -1`, `top.second == 1`, on exit `larFreq == -2`, `del == 3` (since you are adding `1 - (-1)` to it).\nThe expected level should saturate at `0`."
                    },
                    {
                        "username": "jems1123",
                        "content": "very simple\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You are probably indian"
                    },
                    {
                        "username": "justtestingn",
                        "content": "Love when a daily comes up... and it\\'s one you solved earlier that day"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "delete(me) "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nFirst make a `char -> freq map/vector` then store all the frequencies in a `set`. \\n\\nThen `iterate` through the map and check if the `freq` is in the set or not.\\n\\nIf it\\'s not, just simply `insert` it in the set and move on to next `iteration`.\\n\\nIf it\\'s in the set, keep decreasing the freq and increasing the ans count till we couldn\\u2019t find the freq in set again."
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "this helps me to think the right path, thank you\\n"
                    }
                ]
            },
            {
                "id": 2055065,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2055028,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2054708,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2054705,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2054542,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2054397,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2054258,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2054227,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2054200,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            },
            {
                "id": 2054155,
                "content": [
                    {
                        "username": "diggu18052002",
                        "content": "chalo lets start with the problem. \\nhow to think.\\nas a beginner \\n\\nwe are going to catch some keywords and then try to solve the problem\\n\\nfirst and the first most keyword which can make the game almost half done for  you is  frequency\\n\\nfrequency okay so we need all those frequencies which are same so we can delete them and return the count of deletion that we have performed.\\n\\nfor that we need a map to count the character.\\n\\nthen since we need to keep track of same frequency character inside the map we need to \\nto maintain and set.\\njis seh ki hum pata laga sake ki kyaa yeh frequency humne pahele kabhi dekhii hai if true then delete all the occurence  of such frequency  and increment your count variable.\\ncharacter \"till it is present inside the map\".\\nother wise keep on adding the values into the set. \\n\\n"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "I passed 56 test cases out of 103 how to overcome memory limit exceeded?\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "I used only hashmap and hashset and everything passed"
                    },
                    {
                        "username": "code__HARD",
                        "content": "The idea can be stated as for a given value in the  what is the max smaller element which is not present in the array."
                    },
                    {
                        "username": "SG-C",
                        "content": "not hard , not medium, not easy it is a good question \\uD83D\\uDE00"
                    },
                    {
                        "username": "layyy",
                        "content": "go from highest frequency to lowest frequency till no elements with same frequency are found"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "why many solutions have sorted the freuencies. I think its not required for the tc"
                    },
                    {
                        "username": "abhishekpseth",
                        "content": "[@Minamikaze392](/Minamikaze392) Okayy, thanks!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "After sorting we can find the answer in linear time with a greedy approach. Time complexity will be $$O(n*log(n))$$ due to sorting, or $$O(n)$$ if bucket sort is used."
                    },
                    {
                        "username": "ashushukla06",
                        "content": "sort the array in decending order \\nstore the frequency of the array in the map;\\ndeclare a set \\nuse set to find the map.second value is in the set or not , if not then insert \\nit present then take a count variable , and ,  decrement the value, till its unique \\nand increment the count variable , \\nif the value is unique and greater then 0 store in the set ;"
                    },
                    {
                        "username": "chrajneesh15",
                        "content": "Those who don\\'t understand plz check the video - https://www.youtube.com/watch?v=OKbhif3yJd0"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "And....Greedy Works!!"
                    },
                    {
                        "username": "pansari",
                        "content": "Hashset + Hashmap solution worked for me. I don\\'t know if this is the best"
                    }
                ]
            }
        ]
    }
]