[
    {
        "title": "Combination Sum",
        "question_content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n&nbsp;\nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\nExample 2:\n\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nExample 3:\n\nInput: candidates = [2], target = 1\nOutput: []\n\n&nbsp;\nConstraints:\n\n\t1 <= candidates.length <= 30\n\t2 <= candidates[i] <= 40\n\tAll elements of candidates are distinct.\n\t1 <= target <= 40",
        "solutions": [
            {
                "id": 1777569,
                "title": "full-explanation-with-state-space-tree-recursion-and-backtracking-well-explained-c",
                "content": "Reading the question we understand that we need every possible unique combination such that sum of the combination is equal to target.\\n\\nFor such questions where we have to find **\"every possible\"** we generally use **backtracking**.\\n\\nLet\\'s understand how can backtracking help us achieve what we want here.\\nBelow is an example with a **state space tree** for better understanding of how backtracking will be used in the solution.\\n\\n#### Example (State Space Tree):\\n\\n![image](https://assets.leetcode.com/users/images/a7b5e2bf-f7c5-4e3a-a040-5cb619027830_1645077072.6875963.jpeg)\\n\\nAs you might have noticed that we are not considering the whole array as possible options at every level, because we want **unique combinations**.\\ne.g. at the node **[2, 2, 3]**, the *possible options* for the next level are only *[3, 5]*. Why?? because if we consider the whole array as possible options, then we we will end up with [2, 2, 3, 2] (with 2 as a possible option), which has already been checked as [2, 2, 2, 3] (see the tree). So to *make the solution unique* we are only considering the *part of the array from current last element to the end element* (like in this example).\\n\\n#### Algorithm:\\n```\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n```\\n\\n#### Code:\\n```cpp\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***Plz upvote the post if you like the explanation.***\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n```\n```cpp\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777334,
                "title": "c-detailed-explanation-w-tree-diagram-recursion-backtracking-each-step-explained",
                "content": "***Brief note about Question-***\\n* In simple words, we have to *return all possible combination of array whose sum is equal to a particular target.*\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array is given to us as arr[]: [2, 3] and target as 6\\n\\nThen, all possible combinations of array whose sum is equal to 6 is-\\n[[2,2,2] , [3,3]]\\n\\n```\\n___________________\\n***General discussion on how we devlop approach-***\\n* This was a problem where we have to explore all possibility, make each combination and if sum of a combination becomes equal to target sum then we have to store that possible combination in our answer array.\\n\\n* One more thing we have to notice here is that, **for a particular element we have unlimited choice** i.e we can choose a element as many times as we want.\\n* But their is some restiction also on choosing a number.\\n* See for every number in making our target sum, we have two possibility i.e \\n1) **Whether to include that element in making our target sum**.\\n2) **Whether not to include that element in making our target sum**.\\n* We will try and explore each possible combination and if at a point we got our sum as zero then we will say yeah!!, we find a possible combination and include that combination in our answer.\\n\\n* Suppose if at any point our target sum becomes less than zero, then we will return from that point and will not explore further possibility by saying that, ok our target sum becomes negative that means from now no any combination is possible because we have given a non - negative array.\\n* See below tree diagram for more clarity.\\n_______________________\\n***How Tree diagram will work-***\\n* We will make a `op array`, that contains all the possible combinations sum of the array.\\n* We will start from the `index 0` and as we already discussed that for each and every element we have two possibility whether to include this element in making our answer or not, so we will explore all possibilities.\\n* op aray represents which elements this array contains now in making combination sum.\\n* Target represents the left combination sum that we have to make. Intially it is same as the original target that we have to make.\\n* The red cursor below the array, points that on which index we are currently standing.\\n* If at any point our target becomes zero, then we will include that combination in our answer array saying that yes, this is an possible combination and return from there.\\n* If at any point our target becomes less than zero, then we return from there saying that we are never able to make our cbination sum by this combination.\\n* If at any point we cross the size of the array then we will return from there saying that no more element is left to choose.\\n\\n* As we dicussed for every element we have two choices whether to include in our answer or not include in our answer.\\n* So, if we do not a include a element in our answer then without decreasing target sum, we will move to next index. **Why we do not decrese sum?** because we will choose not to include in this element in our combination, hence it does not contribute in making our sum.\\n* But, if we choose a particular element to include in our answer, then we will decrease the target sum but we will not move to next index. **Why we will not move to next index?** because for a specific element *we have unlimited number of choice*, so it may be possible that specific element again contribute in making our sum.\\n* If Image is not cleary visible to you, then for that I have uploaded it on my drive.\\n* **You may visit this link to see Image in good quality.**\\n* LINK :- [TREE DIAGRAM](https://drive.google.com/file/d/1dIVMnBcSlI0D1ZJRXsHR89WD4ZKZIxh2/view?usp=sharing)\\n_________________________\\n\\n![image](https://assets.leetcode.com/users/images/eb6d1bed-c1d3-4252-9d80-b44eb02a6654_1645069516.057088.jpeg)\\n_________________________\\n***Solution - I (using backtracking, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\\n______________________\\n***Solution - II (using Recursion, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\\n\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array is given to us as arr[]: [2, 3] and target as 6\\n\\nThen, all possible combinations of array whose sum is equal to 6 is-\\n[[2,2,2] , [3,3]]\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777135,
                "title": "c-easy-to-understand-backtracking",
                "content": "# 39. Combination Sum\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n```\\n1. Sort the vector(non-decreasing).\\n2. First remove all the duplicates from vector.\\n3. Then use recursion and backtracking to solve \\n   the problem.\\n   (A) If at any time sub-problem sum == 0 then \\n       add that vector to the result (vector of \\n       vectors).\\n   (B) Else if sum is negative then ignore that \\n       sub-problem.\\n   (C) Else insert the present index in that \\n       vector to the current vector and call \\n       the function with sum = sum-ar[index] and\\n       index = index, then pop that element from \\n       current index (backtrack) and call the \\n       function with sum = sum and index = index+1\\n```\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n\\n    void Sum(vector<int>& candidates, int target, vector<vector<int> >& res, vector<int>& r, int i)\\n    {\\n        \\n        if(target == 0)\\n        {\\n            // if we get exact answer\\n            res.push_back(r);\\n            return;\\n        }\\n        \\n        while(i <  candidates.size() && target - candidates[i] >= 0)\\n        {\\n            // Till every element in the array starting\\n            // from i which can contribute to the target\\n            r.push_back(candidates[i]);// add them to vector\\n            \\n            // recur for next numbers\\n            Sum(candidates,target - candidates[i],res,r,i);\\n            ++i;\\n            \\n            // Remove number from vector (backtracking)\\n            r.pop_back();\\n        }\\n}\\n    \\n     \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end()); // sort candidates array\\n        \\n        // remove duplicates\\n        candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());\\n        \\n        vector<int> r;\\n        vector<vector<int> > res;\\n        \\n        Sum(candidates,target,res,r,0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n1. Sort the vector(non-decreasing).\\n2. First remove all the duplicates from vector.\\n3. Then use recursion and backtracking to solve \\n   the problem.\\n   (A) If at any time sub-problem sum == 0 then \\n       add that vector to the result (vector of \\n       vectors).\\n   (B) Else if sum is negative then ignore that \\n       sub-problem.\\n   (C) Else insert the present index in that \\n       vector to the current vector and call \\n       the function with sum = sum-ar[index] and\\n       index = index, then pop that element from \\n       current index (backtrack) and call the \\n       function with sum = sum and index = index+1\\n```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n\\n    void Sum(vector<int>& candidates, int target, vector<vector<int> >& res, vector<int>& r, int i)\\n    {\\n        \\n        if(target == 0)\\n        {\\n            // if we get exact answer\\n            res.push_back(r);\\n            return;\\n        }\\n        \\n        while(i <  candidates.size() && target - candidates[i] >= 0)\\n        {\\n            // Till every element in the array starting\\n            // from i which can contribute to the target\\n            r.push_back(candidates[i]);// add them to vector\\n            \\n            // recur for next numbers\\n            Sum(candidates,target - candidates[i],res,r,i);\\n            ++i;\\n            \\n            // Remove number from vector (backtracking)\\n            r.pop_back();\\n        }\\n}\\n    \\n     \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end()); // sort candidates array\\n        \\n        // remove duplicates\\n        candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());\\n        \\n        vector<int> r;\\n        vector<vector<int> > res;\\n        \\n        Sum(candidates,target,res,r,0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16502,
                "title": "a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning",
                "content": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n \\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n \\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "codeTag": "Unknown"
            },
            {
                "id": 16510,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16496,
                "title": "accepted-16ms-c-solution-use-backtracking-easy-understand",
                "content": "Accepted 16ms c++ solution use backtracking for [Combination Sum][1]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum(candidates, target, res, combination, 0);\\n            return res;\\n        }\\n    private:\\n        void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n                combination.push_back(candidates[i]);\\n                combinationSum(candidates, target - candidates[i], res, combination, i);\\n                combination.pop_back();\\n            }\\n        }\\n    };\\n\\nAccepted 12ms c++ solution use backtracking for [Combination Sum II][2]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum2(candidates, target, res, combination, 0);\\n            return res;\\n        }\\n    private:\\n        void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n                if (i == begin || candidates[i] != candidates[i - 1]) {\\n                    combination.push_back(candidates[i]);\\n                    combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                    combination.pop_back();\\n                }\\n        }\\n    };\\n\\nAccepted 0ms c++ solution use backtracking for [Combination Sum III][3]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum3(n, res, combination, 1, k);\\n            return res;\\n        }\\n    private:\\n        void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            else if (!need)\\n                return;\\n            for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n                combination.push_back(i);\\n                combinationSum3(target - i, res, combination, i + 1, need - 1);\\n                combination.pop_back();\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/combination-sum/\\n  [2]: https://leetcode.com/problems/combination-sum-ii/\\n  [3]: https://leetcode.com/problems/combination-sum-iii/",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum(candidates, target, res, combination, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429538,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16509,
                "title": "iterative-java-dp-solution",
                "content": "Hi guys!\\n\\nThe main idea reminds an approach for solving coins/knapsack problem - to store the result for all i < target and create the solution from them. For that for each t from 1 to our target we try every candidate which is less or equal to t in ascending order. For each candidate \"c\" we run through all combinations for target t-c starting with the value greater or equal than c to avoid duplicates and store only ordered combinations. \\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] cands, int t) {\\n            Arrays.sort(cands); // sort candidates to try them in asc order\\n            List<List<List<Integer>>> dp = new ArrayList<>();\\n            for (int i = 1; i <= t; i++) { // run through all targets from 1 to t\\n                List<List<Integer>> newList = new ArrayList(); // combs for curr i\\n                // run through all candidates <= i\\n                for (int j = 0; j < cands.length && cands[j] <= i; j++) {\\n                    // special case when curr target is equal to curr candidate\\n                    if (i == cands[j]) newList.add(Arrays.asList(cands[j]));\\n                    // if current candidate is less than the target use prev results\\n                    else for (List<Integer> l : dp.get(i-cands[j]-1)) {\\n                        if (cands[j] <= l.get(0)) {\\n                            List cl = new ArrayList<>();\\n                            cl.add(cands[j]); cl.addAll(l);\\n                            newList.add(cl);\\n                        }\\n                    }\\n                }\\n                dp.add(newList);\\n            }\\n            return dp.get(t-1);\\n        }\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] cands, int t) {\\n            Arrays.sort(cands); // sort candidates to try them in asc order\\n            List<List<List<Integer>>> dp = new ArrayList<>();\\n            for (int i = 1; i <= t; i++) { // run through all targets from 1 to t\\n                List<List<Integer>> newList = new ArrayList(); // combs for curr i\\n                // run through all candidates <= i\\n                for (int j = 0; j < cands.length && cands[j] <= i; j++) {\\n                    // special case when curr target is equal to curr candidate\\n                    if (i == cands[j]) newList.add(Arrays.asList(cands[j]));\\n                    // if current candidate is less than the target use prev results\\n                    else for (List<Integer> l : dp.get(i-cands[j]-1)) {\\n                        if (cands[j] <= l.get(0)) {\\n                            List cl = new ArrayList<>();\\n                            cl.add(cands[j]); cl.addAll(l);\\n                            newList.add(cl);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 786891,
                "title": "c-two-differnt-aproch-easy-to-understand-with-comment",
                "content": "**Plz upvote my solution if you like it**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n\\t//global values shared between both function\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    int sum;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(sum>target)return ;//base case if sum is greater then target then return \\n        \\n        if(sum==target){\\n            result.push_back(current);//id sum is equal to target then just add current to result\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            sum+=candidates[i];//and current value to sum\\n            current.push_back(candidates[i]);//and current value to current vector\\n            function(candidates,target,i);//again reccure for same index i\\n            sum-=candidates[i];//back track mean remove value that previously added\\n            current.pop_back();//remove the value that previously added to current \\n        }      \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sum=0; // This sum is global you can see it on the top of code just a clarify if you have any doubt\\n        function(candidates,target,0);//i make result current and sum global to reduce the size of function for simplecity\\n        return result;//This result is also global \\n    }\\n};\\n\\'\\'\\'\\nNow second approch is bit tricky you have to be bit carefull or you can solve this approch using pen and paper \\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if(index==candidates.size() || target<0)return;\\n        \\n        current.push_back(candidates[index]);\\n        function(candidates,target-candidates[index],index);\\n        current.pop_back();\\n        function(candidates,target,index+1);      \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        function(candidates,target,0);\\n        return result;\\n    }\\n};\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\t//global values shared between both function\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    int sum;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(sum>target)return ;//base case if sum is greater then target then return \\n        \\n        if(sum==target){\\n            result.push_back(current);//id sum is equal to target then just add current to result\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 937255,
                "title": "python-3-dfs-backtracking-two-dp-methods-explanations",
                "content": "### Approach \\\\#1. DFS (Backtracking)\\n- Straight forward backtracking\\n- `cur`: current combination, `cur_sum` current combination sum, `idx` index current at (to avoid repeats)\\n- Time complexity: `O(N^(M/min_cand + 1))`, `N = len(candidates)`, `M = target`, `min_cand = min(candidates)`\\n- Space complexity: `O(M/min_cand)`\\n<iframe src=\"https://leetcode.com/playground/fwFMybYZ/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#2. DP (Slow)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/Qw6fiSbh/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#3. DP (Fast)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/d2qASVHs/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "### Approach \\\\#1. DFS (Backtracking)\\n- Straight forward backtracking\\n- `cur`: current combination, `cur_sum` current combination sum, `idx` index current at (to avoid repeats)\\n- Time complexity: `O(N^(M/min_cand + 1))`, `N = len(candidates)`, `M = target`, `min_cand = min(candidates)`\\n- Space complexity: `O(M/min_cand)`\\n<iframe src=\"https://leetcode.com/playground/fwFMybYZ/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#2. DP (Slow)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/Qw6fiSbh/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#3. DP (Fast)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/d2qASVHs/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 16521,
                "title": "java-solution-using-recursive",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        \\tArrays.sort(candidates);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            getResult(result, new ArrayList<Integer>(), candidates, target, 0);\\n            \\n            return result;\\n        }\\n        \\n        private void getResult(List<List<Integer>> result, List<Integer> cur, int candidates[], int target, int start){\\n        \\tif(target > 0){\\n        \\t\\tfor(int i = start; i < candidates.length && target >= candidates[i]; i++){\\n        \\t\\t\\tcur.add(candidates[i]);\\n        \\t\\t\\tgetResult(result, cur, candidates, target - candidates[i], i);\\n        \\t\\t\\tcur.remove(cur.size() - 1);\\n        \\t\\t}//for\\n        \\t}//if\\n        \\telse if(target == 0 ){\\n        \\t\\tresult.add(new ArrayList<Integer>(cur));\\n        \\t}//else if\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        \\tArrays.sort(candidates);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            getResult(result, new ArrayList<Integer>(), candidates, target, 0);\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1755084,
                "title": "detailed-time-and-space-complexity-analysis-c-java-backtracking",
                "content": "**Time Complexity** - O(2^k) where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n**Note-** *the time complexity of pushing cur into res is len_of_cur, so we can say TC - O( len_of_cur\\xD72^k)*\\n**Auxillary Space Complexity** - O(length_of_longest_combination).\\n\\n**Detailed explanation for time and auxillary space complexity** \\n\\n**Note-** *the space complexity i mentioned is the auxillary space complexity i.e. recursive stack space*\\n![image](https://assets.leetcode.com/users/images/72c0a206-7a8a-4109-95be-aea3ad7298e5_1644313045.9214947.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/725c0db0-a479-4412-aa89-6ad7965cde0b_1644409701.0079207.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a11a8b81-ae82-478d-a99a-21c035fb1493_1644409707.9676895.jpeg)\\n\\n\\n\\n**C++ and Java Codes -**\\n<iframe src=\"https://leetcode.com/playground/kgQe9ngW/shared\" frameBorder=\"0\" width=\"1090\" height=\"430\"></iframe>",
                "solutionTags": [
                    "Java",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "**Time Complexity** - O(2^k) where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n**Note-** *the time complexity of pushing cur into res is len_of_cur, so we can say TC - O( len_of_cur\\xD72^k)*\\n**Auxillary Space Complexity** - O(length_of_longest_combination).\\n\\n**Detailed explanation for time and auxillary space complexity** \\n\\n**Note-** *the space complexity i mentioned is the auxillary space complexity i.e. recursive stack space*\\n![image](https://assets.leetcode.com/users/images/72c0a206-7a8a-4109-95be-aea3ad7298e5_1644313045.9214947.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/725c0db0-a479-4412-aa89-6ad7965cde0b_1644409701.0079207.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a11a8b81-ae82-478d-a99a-21c035fb1493_1644409707.9676895.jpeg)\\n\\n\\n\\n**C++ and Java Codes -**\\n<iframe src=\"https://leetcode.com/playground/kgQe9ngW/shared\" frameBorder=\"0\" width=\"1090\" height=\"430\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 16554,
                "title": "share-my-python-solution-beating-98-17",
                "content": "    class Solution(object):\\n    def combinationSum(self, candidates, target):\\n        result = []\\n        candidates = sorted(candidates)\\n        def dfs(remain, stack):\\n            if remain == 0:\\n                result.append(stack)\\n                return \\n\\n            for item in candidates:\\n                if item > remain: break\\n                if stack and item < stack[-1]: continue\\n                else:\\n                    dfs(remain - item, stack + [item])\\n        \\n        dfs(target, [])\\n        return result",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "    class Solution(object):\\n    def combinationSum(self, candidates, target):\\n        result = []\\n        candidates = sorted(candidates)\\n        def dfs(remain, stack):\\n            if remain == 0:\\n                result.append(stack)\\n                return \\n\\n            for item in candidates:\\n                if item > remain: break\\n                if stack and item < stack[-1]: continue\\n                else:\\n                    dfs(remain - item, stack + [item])\\n        \\n        dfs(target, [])\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1103237,
                "title": "c-best-and-easy-dp-solution",
                "content": "Similar idea from the problem [coin-change-2](https://leetcode.com/problems/coin-change-2/) .\\nit is simplest and fastest dp solution, we don\\'t need to sort elements \\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n\\t\\t// dp vector to store all possible combinations of the target sum\\n        vector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int &i:nums)\\n        {\\n\\t\\t// Iterating through all the elements from array nums aka candidates\\n            for(int j=i;j<=target;j++)\\n            {\\n\\t\\t\\t// Finding all possible ways to achieve sum j from element i\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n\\t\\t// Finally, returning our ans \\uD83D\\uDE43\\n        return dp[target];\\n    }\\n};\\n```\\nIf you liked this solution please upvote\\uD83D\\uDE4F if you have any query plz comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n\\t\\t// dp vector to store all possible combinations of the target sum\\n        vector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int &i:nums)\\n        {\\n\\t\\t// Iterating through all the elements from array nums aka candidates\\n            for(int j=i;j<=target;j++)\\n            {\\n\\t\\t\\t// Finding all possible ways to achieve sum j from element i\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n\\t\\t// Finally, returning our ans \\uD83D\\uDE43\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875097,
                "title": "python-bactracking-solution-explained",
                "content": "This is classical backtracking problem, so let us use `BackTr(target, curr_sol, k)` function, where:\\n\\n1. `target` is target we need to build, if we get some number, we subtract if from target.\\n2. `curr_sol` is current solution built so far.\\n3. `k` is index in our `candidates`: each new number we take should have number more or equal than `k`.\\n\\nSo, no in algorighm we do:\\n1. If `target == 0`, it means we found solution, which is kept in `curr_sol`, so we add it to `self.sol` list of all found solutions.\\n2. If `target` if negative or `k` is more than number of candidates, we need to go back.\\n3. Finally, for each candidate index in `k,...`, we run our function recursively with updated parameters.\\n\\n**Complexity**: TBD\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        def BackTr(target, curr_sol, k):  \\n            if target == 0:\\n                self.sol.append(curr_sol)\\n\\n            if target < 0 or k >= len(candidates):\\n                return\\n\\n            for i in range(k, len(candidates)):\\n                BackTr(target - candidates[i], curr_sol + [candidates[i]], i)\\n        \\n        self.sol = []\\n        BackTr(target, [], 0)   \\n        return self.sol\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        def BackTr(target, curr_sol, k):  \\n            if target == 0:\\n                self.sol.append(curr_sol)\\n\\n            if target < 0 or k >= len(candidates):\\n                return\\n\\n            for i in range(k, len(candidates)):\\n                BackTr(target - candidates[i], curr_sol + [candidates[i]], i)\\n        \\n        self.sol = []\\n        BackTr(target, [], 0)   \\n        return self.sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752444,
                "title": "python-clear-explanation-and-intuition-using-combination-with-backtracking-solution",
                "content": "Here is a my backtracking-based solution. \\nTo fully understand the intuition behind my solution, I will first explaination how we implement combination using backtracking.\\n\\n### Combination\\n\\nTo get all combinations of length 2 from `[1,2,3]`\\n![image](https://assets.leetcode.com/users/images/941d85bd-dab4-4b09-a6d4-5e0e0aca94fc_1595578055.3871193.png)\\n\\n* We dont append the `1` to `[2]` because `[1, 2]` and `[2, 1]` are the same\\n* Same appies to `[3]`\\n\\n### Implementing combinations of sub array with target length\\n```\\nresults = []\\ntarget_length = 2\\narr = [1,2,3]\\n\\ndef combination(i, path):\\n\\n\\t# we have found our answer, lets return. Any code below this statement wont get executed and the recursion stops.\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n\\n\\t# With each iteration of the for loop, we will reduce the number of candidates - [1, 2, 3] , [2, 3] , [3]\\n\\t# This is important to prevent duplicates. \\n\\tfor x in range(i, len(arr)):\\n\\t\\t# lets keep adding to path. \\t\\n\\t\\tpath.append(arr[x])\\n\\n\\t\\t# lets run combination again, if the path is not our target length, it will go to the for loop again.\\n\\t   combination(x, path)\\n\\n\\t   # backtrack, remove my last element, so i can move on .\\n\\t   path.pop()\\n   \\ncombination(0, [])\\n\\nassert combinations == [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]]\\n```\\n\\nNow instead of just finding combinations of a certain length, we replace the termination statement\\n*combination of k length*\\n\\n```\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n```\\n\\nto \\n*combination of target sum*\\n\\n```\\n\\t\\t# termination 1. The sum is the target. stop recursion\\n\\t\\tif sum(path) == target:\\n\\t\\t\\tresults.append(path[:])\\n\\t\\t\\treturn \\n\\n\\t\\t# termination 2 (The sum is greater than the target). stop recursion\\n\\t\\tif sum(path) > target:\\n\\t\\t\\treturn \\n\\n```\\n\\n### Solution to combination sum.\\n\\nTherefore the solution to the problem is:\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        results = []\\n        def helper(i, path):\\n            # endpoint 1 (we found a matching target)\\n            if sum(path) == target:\\n                results.append(path[:])\\n                return \\n\\t\\t\\t\\n\\t\\t\\t# endpoint 2 (The sum is greater than the target)\\n            if sum(path) > target:\\n                return \\n\\t\\t\\t\\n            for x in range(i, len(candidates)):\\n                path.append(candidates[x])\\n                helper(x, path)\\n                path.pop()\\n\\n        helper(0, [])\\n        return results\\n```\\t\\t\\n\\n### What you can do to understand the implementation better.\\n\\n1 . You can try not doing the backtracking step `path.pop()` and see how that affect the results.\\n2. You can print the `path` value in under the for loop.\\n\\n### Conclusion\\n\\nUsing backtracking to solve combinations problem can be easy once you figure out where and how to terminate.\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Combinatorics"
                ],
                "code": "```\\nresults = []\\ntarget_length = 2\\narr = [1,2,3]\\n\\ndef combination(i, path):\\n\\n\\t# we have found our answer, lets return. Any code below this statement wont get executed and the recursion stops.\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n\\n\\t# With each iteration of the for loop, we will reduce the number of candidates - [1, 2, 3] , [2, 3] , [3]\\n\\t# This is important to prevent duplicates. \\n\\tfor x in range(i, len(arr)):\\n\\t\\t# lets keep adding to path. \\t\\n\\t\\tpath.append(arr[x])\\n\\n\\t\\t# lets run combination again, if the path is not our target length, it will go to the for loop again.\\n\\t   combination(x, path)\\n\\n\\t   # backtrack, remove my last element, so i can move on .\\n\\t   path.pop()\\n   \\ncombination(0, [])\\n\\nassert combinations == [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]]\\n```\n```\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n```\n```\\n\\t\\t# termination 1. The sum is the target. stop recursion\\n\\t\\tif sum(path) == target:\\n\\t\\t\\tresults.append(path[:])\\n\\t\\t\\treturn \\n\\n\\t\\t# termination 2 (The sum is greater than the target). stop recursion\\n\\t\\tif sum(path) > target:\\n\\t\\t\\treturn \\n\\n```\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        results = []\\n        def helper(i, path):\\n            # endpoint 1 (we found a matching target)\\n            if sum(path) == target:\\n                results.append(path[:])\\n                return \\n\\t\\t\\t\\n\\t\\t\\t# endpoint 2 (The sum is greater than the target)\\n            if sum(path) > target:\\n                return \\n\\t\\t\\t\\n            for x in range(i, len(candidates)):\\n                path.append(candidates[x])\\n                helper(x, path)\\n                path.pop()\\n\\n        helper(0, [])\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875365,
                "title": "java-python-backtracking-clean-concise-very-fast-2ms",
                "content": "**Python ~ 32ms**\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()  # sort to terminate early when target < 0\\n        \\n        def backtracking(i, target, path):\\n            if target == 0:\\n                ans.append(path)\\n                return\\n            if i == len(candidates) or target < candidates[i]:\\n                return\\n            backtracking(i, target - candidates[i], path + [candidates[i]]) # Choose ith candidate\\n            backtracking(i + 1, target, path) # Skip ith candidate\\n        \\n        ans = []\\n        backtracking(0, target, [])\\n        return ans\\n```\\n\\n**Java ~ 2ms**\\n```java\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort to terminate early when target < 0\\n        backtracking(0, target, candidates, new LinkedList<>());\\n        return ans;\\n    }\\n    void backtracking(int i, int target, int[] candidates, LinkedList<Integer> path) {\\n        if (target == 0) {\\n            ans.add((List<Integer>) path.clone());\\n            return;\\n        }\\n        if (i == candidates.length || target < candidates[i]) return;\\n        \\n        path.addLast(candidates[i]);\\n        backtracking(i, target - candidates[i], candidates, path); // Choose ith candidate\\n        path.removeLast();\\n        \\n        backtracking(i + 1, target, candidates, path); // Skip ith candidate\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()  # sort to terminate early when target < 0\\n        \\n        def backtracking(i, target, path):\\n            if target == 0:\\n                ans.append(path)\\n                return\\n            if i == len(candidates) or target < candidates[i]:\\n                return\\n            backtracking(i, target - candidates[i], path + [candidates[i]]) # Choose ith candidate\\n            backtracking(i + 1, target, path) # Skip ith candidate\\n        \\n        ans = []\\n        backtracking(0, target, [])\\n        return ans\\n```\n```java\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort to terminate early when target < 0\\n        backtracking(0, target, candidates, new LinkedList<>());\\n        return ans;\\n    }\\n    void backtracking(int i, int target, int[] candidates, LinkedList<Integer> path) {\\n        if (target == 0) {\\n            ans.add((List<Integer>) path.clone());\\n            return;\\n        }\\n        if (i == candidates.length || target < candidates[i]) return;\\n        \\n        path.addLast(candidates[i]);\\n        backtracking(i, target - candidates[i], candidates, path); // Choose ith candidate\\n        path.removeLast();\\n        \\n        backtracking(i + 1, target, candidates, path); // Skip ith candidate\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16530,
                "title": "concise-backtracking-solution",
                "content": "We backtrack from successful searches as well because they are saved at the leafs of recursion tree\\n\\n    class Solution {\\n    public:\\n    \\n        void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n        {\\n            if(target == 0)\\n            {\\n                result.push_back(pSol);\\n                return;\\n            }\\n            \\n            if(next == num.size() || target - num[next] < 0)\\n                return;\\n                \\n            pSol.push_back(num[next]);\\n            search(num, next, pSol, target - num[next], result);\\n            pSol.pop_back();\\n            \\n            search(num, next + 1, pSol, target, result);\\n        }\\n    \\n        \\n        vector<vector<int> > combinationSum(vector<int> &num, int target) \\n        {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            vector<int> pSol;\\n            search(num, 0, pSol, target, result);\\n            return result;    \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n        {\\n            if(target == 0)\\n            {\\n                result.push_back(pSol);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1778054,
                "title": "python-short-and-clean-solution-explained",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16757,
                "title": "javascript-solution-with-backtracking",
                "content": "```js\\nfunction combinationSum(candidates, target) {\\n  var buffer = [];\\n  var result = [];\\n  search(0, target);\\n  return result;\\n\\n  function search(startIdx, target) {\\n    if (target === 0) return result.push(buffer.slice());\\n    if (target < 0) return;\\n    if (startIdx === candidates.length) return;\\n    buffer.push(candidates[startIdx]);\\n    search(startIdx, target - candidates[startIdx]);\\n    buffer.pop();\\n    search(startIdx + 1, target);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```js\\nfunction combinationSum(candidates, target) {\\n  var buffer = [];\\n  var result = [];\\n  search(0, target);\\n  return result;\\n\\n  function search(startIdx, target) {\\n    if (target === 0) return result.push(buffer.slice());\\n    if (target < 0) return;\\n    if (startIdx === candidates.length) return;\\n    buffer.push(candidates[startIdx]);\\n    search(startIdx, target - candidates[startIdx]);\\n    buffer.pop();\\n    search(startIdx + 1, target);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351862,
                "title": "solution-swift-combination-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var comb: [Int] = [], uniqs: [[Int]] = []\\n        dfs(&uniqs, &comb, candidates.sorted(), target, 0)\\n        return uniqs\\n    }\\n    \\n    private func dfs(_ uniq: inout [[Int]], _ comb: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int) {\\n        guard t > 0 else { uniq.append(comb); return }\\n        for i in idx..<cands.count where cands[i] <= t {\\n            comb.append(cands[i])\\n            dfs(&uniq, &comb, cands, t - cands[i], i)\\n            comb.removeLast()\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 5 tests, with 0 failures (0 unexpected) in 0.039 (0.041) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\n    /// 7 is a candidate, and 7 = 7.\\n    /// These are the only two combinations.\\n    func test0() {\\n        let value = solution.combinationSum([2,3,6,7], 7)\\n        XCTAssertEqual(value, [[2,2,3],[7]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum([2,3,5], 8)\\n        XCTAssertEqual(value, [[2,2,2,2],[2,3,3],[3,5]])\\n    }\\n    func test2() {\\n        let value = solution.combinationSum([2], 1)\\n        XCTAssertEqual(value, [])\\n    }\\n    func test3() {\\n        let value = solution.combinationSum([1], 1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n    func test4() {\\n        let value = solution.combinationSum([1], 2)\\n        XCTAssertEqual(value, [[1,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var comb: [Int] = [], uniqs: [[Int]] = []\\n        dfs(&uniqs, &comb, candidates.sorted(), target, 0)\\n        return uniqs\\n    }\\n    \\n    private func dfs(_ uniq: inout [[Int]], _ comb: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int) {\\n        guard t > 0 else { uniq.append(comb); return }\\n        for i in idx..<cands.count where cands[i] <= t {\\n            comb.append(cands[i])\\n            dfs(&uniq, &comb, cands, t - cands[i], i)\\n            comb.removeLast()\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\n    /// 7 is a candidate, and 7 = 7.\\n    /// These are the only two combinations.\\n    func test0() {\\n        let value = solution.combinationSum([2,3,6,7], 7)\\n        XCTAssertEqual(value, [[2,2,3],[7]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum([2,3,5], 8)\\n        XCTAssertEqual(value, [[2,2,2,2],[2,3,3],[3,5]])\\n    }\\n    func test2() {\\n        let value = solution.combinationSum([2], 1)\\n        XCTAssertEqual(value, [])\\n    }\\n    func test3() {\\n        let value = solution.combinationSum([1], 1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n    func test4() {\\n        let value = solution.combinationSum([1], 2)\\n        XCTAssertEqual(value, [[1,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16713,
                "title": "a-solution-avoid-using-set",
                "content": "Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one.\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ret = new LinkedList<List<Integer>>();\\n        Arrays.sort(candidates); // sort the candidates\\n        // collect possible candidates from small to large to eliminate duplicates,\\n        recurse(new ArrayList<Integer>(), target, candidates, 0, ret);\\n        return ret;\\n    }\\n    \\n    // the index here means we are allowed to choose candidates from that index\\n    private void recurse(List<Integer> list, int target, int[] candidates, int index, List<List<Integer>> ret) {\\n        if (target == 0) {\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i = index; i < candidates.length; i++) {\\n            int newTarget = target - candidates[i];\\n            if (newTarget >= 0) {\\n                List<Integer> copy = new ArrayList<Integer>(list);\\n                copy.add(candidates[i]);\\n                recurse(copy, newTarget, candidates, i, ret);\\n            } else {\\n                break;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one.\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ret = new LinkedList<List<Integer>>();\\n        Arrays.sort(candidates); // sort the candidates\\n        // collect possible candidates from small to large to eliminate duplicates,\\n        recurse(new ArrayList<Integer>(), target, candidates, 0, ret);\\n        return ret;\\n    }\\n    \\n    // the index here means we are allowed to choose candidates from that index\\n    private void recurse(List<Integer> list, int target, int[] candidates, int index, List<List<Integer>> ret) {\\n        if (target == 0) {\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i = index; i < candidates.length; i++) {\\n            int newTarget = target - candidates[i];\\n            if (newTarget >= 0) {\\n                List<Integer> copy = new ArrayList<Integer>(list);\\n                copy.add(candidates[i]);\\n                recurse(copy, newTarget, candidates, i, ret);\\n            } else {\\n                break;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 662307,
                "title": "javascript-clean-backtracking-solution",
                "content": "```javascript\\nvar combinationSum = function(candidates, target) {\\n    const result = [];\\n    \\n    function permute(arr=[], sum=0, idx=0) {\\n        if(sum > target) return;\\n        if(sum === target) result.push(arr);\\n        \\n        for(let i = idx; i < candidates.length; i++) {\\n            permute([...arr, candidates[i]], sum+candidates[i], i);\\n        }\\n    }\\n    permute()\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar combinationSum = function(candidates, target) {\\n    const result = [];\\n    \\n    function permute(arr=[], sum=0, idx=0) {\\n        if(sum > target) return;\\n        if(sum === target) result.push(arr);\\n        \\n        for(let i = idx; i < candidates.length; i++) {\\n            permute([...arr, candidates[i]], sum+candidates[i], i);\\n        }\\n    }\\n    permute()\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378325,
                "title": "javascript-solution-with-detailed-explanation",
                "content": "This is a question of backtracking and recursion and we got to this conclusion by following points\\n1.The question states we can use same number multiple times so we can think that \\n    it will take use of recursion \\n2.We need to find all possible unique combination of numbers that will result to our target to this should\\tmake us think it will use backtracking too\\n\\nSolution approach\\n1.We will take use of a backtracking recursive function which will take input as index, target and a temperory data structure(in this question stack will be suitable).\\n2.We already initialised the index because we wanna/may use it many times so intialising index outside the loop will be helpful\\n3.Target is our target that we want to achieve\\n4.Temperory data structure will store our combinations i.e numbers that may result to our target\\n5.The loop will start with index and end on our last index as obvious\\n6.We will add the current number to our temp DS and substract it from target\\n7.If our target is still not equal to zero i.e we still have some target to achieve\\n8.So we will keep on calling backtracking function and substraction the number from target to see if its zero or not\\n9.If it becomes zero then we achieved our target and we will push the temp DS values in the result as temp DS was storing the values which together resulted to our target\\n10.If we reached somewhere lower than zero that means our sum became greater than our target so we cannot take that number that made our sum greater than target\\n11.So we will return from their and because we are in a for loop after returning we will add next number of \"candidates array\" to our temperory datastructure and start backtracking recursion again\\n12.Make sure to remove the element from our temp DS because of which our sum became greater than our target\\n\\nIn general we can say this question is alll about selecting and not-selecting an element . We select an element if we haven\\'t reached our target\\nWe remove element from temp DS or don\\'t select an element if we go beyond our target\\n\\n    var combinationSum = function(candidates, target) {\\n        let index = 0\\n        let tempDataStruct = []\\n        let result = []\\n    \\n        function backtracking(index, target, tempDataStruct) {\\n            if(target === 0) {\\n                result.push([...tempDataStruct])\\n                return\\n            }\\n        \\n            if(target < 0) return;\\n        \\n            for(let i=index; i<candidates.length; i++) {\\n                tempDataStruct.push(candidates[i])\\n                backtracking(i, target-candidates[i], tempDataStruct)\\n                tempDataStruct.pop()\\n            }\\n        }\\n        backtracking(index, target, tempDataStruct)\\n        return result;\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "This is a question of backtracking and recursion and we got to this conclusion by following points\\n1.The question states we can use same number multiple times so we can think that \\n    it will take use of recursion \\n2.We need to find all possible unique combination of numbers that will result to our target to this should\\tmake us think it will use backtracking too\\n\\nSolution approach\\n1.We will take use of a backtracking recursive function which will take input as index, target and a temperory data structure(in this question stack will be suitable).\\n2.We already initialised the index because we wanna/may use it many times so intialising index outside the loop will be helpful\\n3.Target is our target that we want to achieve\\n4.Temperory data structure will store our combinations i.e numbers that may result to our target\\n5.The loop will start with index and end on our last index as obvious\\n6.We will add the current number to our temp DS and substract it from target\\n7.If our target is still not equal to zero i.e we still have some target to achieve\\n8.So we will keep on calling backtracking function and substraction the number from target to see if its zero or not\\n9.If it becomes zero then we achieved our target and we will push the temp DS values in the result as temp DS was storing the values which together resulted to our target\\n10.If we reached somewhere lower than zero that means our sum became greater than our target so we cannot take that number that made our sum greater than target\\n11.So we will return from their and because we are in a for loop after returning we will add next number of \"candidates array\" to our temperory datastructure and start backtracking recursion again\\n12.Make sure to remove the element from our temp DS because of which our sum became greater than our target\\n\\nIn general we can say this question is alll about selecting and not-selecting an element . We select an element if we haven\\'t reached our target\\nWe remove element from temp DS or don\\'t select an element if we go beyond our target\\n\\n    var combinationSum = function(candidates, target) {\\n        let index = 0\\n        let tempDataStruct = []\\n        let result = []\\n    \\n        function backtracking(index, target, tempDataStruct) {\\n            if(target === 0) {\\n                result.push([...tempDataStruct])\\n                return\\n            }\\n        \\n            if(target < 0) return;\\n        \\n            for(let i=index; i<candidates.length; i++) {\\n                tempDataStruct.push(candidates[i])\\n                backtracking(i, target-candidates[i], tempDataStruct)\\n                tempDataStruct.pop()\\n            }\\n        }\\n        backtracking(index, target, tempDataStruct)\\n        return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 742449,
                "title": "explanation-of-time-complexity",
                "content": "Ill try and explain the time complexity I know and understand the solution to be. In order to get the time complexity easily of these types of solutions, always consider the recursive tree.\\n\\nLets say we have 4 elements in our list (call it N) and a target = 7 (call it M):\\n\\nnums = [2,3,6,7]\\nAt every single level in our recursion tree we have N choices to decrease target by and then to recurse on.\\n\\nAt the first level target = 7 and we can chose 2,3,6,7.\\n\\n                                7\\n                         5    4    1   0\\n\\nAt the second level of our recursive tree where target=5 we also have 4 choices. Even though some of those choices would lead us\\nto a negative target which isnt valid we can approximate that we still have about 4 choices. So we can state that the number of recursive calls on each level of our recursive tree is 4 (N)\\n\\nSo now we have the number of elements on each level. However how many levels (heigh) will there be worst case?\\n\\nIf you consider a list with only 1s in it we can see the maximum height of our recursive tree is equal to target (M)\\n\\ntarget = 7\\nnums = [1, 1, 1, 1]\\n\\n                         7\\n                        /\\n                       6\\n                      /\\n                     5\\n                    /\\n                   4\\n                  ..\\n                 /\\n                1\\n\\nSo we know the number of elements on each level of our recursive tree (N) and we know the height of our recursive tree (M)\\n\\nTherefore we can say worst case scenario the time complexity is O(len(nums)^target) or O(N^M)\\n\\nO(n^m) time complexity\\n\\nHope this helps.",
                "solutionTags": [],
                "code": "Ill try and explain the time complexity I know and understand the solution to be. In order to get the time complexity easily of these types of solutions, always consider the recursive tree.\\n\\nLets say we have 4 elements in our list (call it N) and a target = 7 (call it M):\\n\\nnums = [2,3,6,7]\\nAt every single level in our recursion tree we have N choices to decrease target by and then to recurse on.\\n\\nAt the first level target = 7 and we can chose 2,3,6,7.\\n\\n                                7\\n                         5    4    1   0\\n\\nAt the second level of our recursive tree where target=5 we also have 4 choices. Even though some of those choices would lead us\\nto a negative target which isnt valid we can approximate that we still have about 4 choices. So we can state that the number of recursive calls on each level of our recursive tree is 4 (N)\\n\\nSo now we have the number of elements on each level. However how many levels (heigh) will there be worst case?\\n\\nIf you consider a list with only 1s in it we can see the maximum height of our recursive tree is equal to target (M)\\n\\ntarget = 7\\nnums = [1, 1, 1, 1]\\n\\n                         7\\n                        /\\n                       6\\n                      /\\n                     5\\n                    /\\n                   4\\n                  ..\\n                 /\\n                1\\n\\nSo we know the number of elements on each level of our recursive tree (N) and we know the height of our recursive tree (M)\\n\\nTherefore we can say worst case scenario the time complexity is O(len(nums)^target) or O(N^M)\\n\\nO(n^m) time complexity\\n\\nHope this helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 16506,
                "title": "8-line-python-solution-dynamic-programming-beats-86-77",
                "content": "    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        dp = [[[]]] + [[] for i in xrange(target)]\\n        for i in xrange(1, target + 1):\\n            for number in candidates:\\n                if number > i: break\\n                for L in dp[i - number]:\\n                    if not L or number >= L[-1]: dp[i] += L + [number],\\n        return dp[target]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        dp = [[[]]] + [[] for i in xrange(target)]\\n        for i in xrange(1, target + 1):\\n            for number in candidates:\\n                if number > i: break\\n                for L in dp[i - number]:\\n                    if not L or number >= L[-1]: dp[i] += L + [number],\\n        return dp[target]",
                "codeTag": "Python3"
            },
            {
                "id": 3685211,
                "title": "beat-100-proper-step-by-step-explanation-simplest-approach",
                "content": "# Intuition\\nThe code follows a backtracking approach to find all combinations that sum up to the given target.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The code follows a backtracking approach to find all combinations that sum up to the given target.\\n2. The `combinationSum` method is the entry point for the backtracking process. It initializes the `ans` list to store the result and the `ls` list to track the current combination.\\n3. The `cum` method performs the backtracking. It takes the current array `c`, the remaining target value, and the starting index as parameters.\\n4. The base case is when the target value becomes zero. In this case, it means that the current combination in `ls` sums up to the target. Therefore, a copy of `ls` is added to the `ans` list as a valid combination.\\n5. The for loop iterates through the elements in the `c` array, starting from the given index `start`.\\n6. Within the loop, if the current element `c[i]` is less than or equal to the remaining target, it is a valid candidate to include in the combination.\\n7. The element `c[i]` is added to the `ls` list, and the `cum` method is recursively called with the updated target (subtracting `c[i]`) and the same starting index `i` to allow reusing the same element in subsequent combinations.\\n8. After the recursive call, the last element is removed from `ls` using `ls.remove(ls.size() - 1)`. This step is crucial for backtracking, as it ensures that the correct elements are considered for the next iteration of the loop.\\n9. The process continues with the next element in the loop until all combinations have been explored.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    ArrayList<Integer> ls = new ArrayList<>();\\n\\n    public List<List<Integer>> combinationSum(int[] c, int target) {\\n        cum(c, target, 0);\\n        return ans;\\n    }\\n\\n    public void cum(int[] c, int target, int start) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ls)); \\n            return;\\n        }\\n\\n        for (int i = start; i < c.length; i++) {\\n            if (c[i] <= target) {\\n                ls.add(c[i]);\\n                cum(c, target - c[i], i); \\n                ls.remove(ls.size() - 1); \\n            }\\n        }\\n    }\\n}\\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/c0566519-3a55-47c3-a7c3-c6ccf4f753f2_1687785256.2860038.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    ArrayList<Integer> ls = new ArrayList<>();\\n\\n    public List<List<Integer>> combinationSum(int[] c, int target) {\\n        cum(c, target, 0);\\n        return ans;\\n    }\\n\\n    public void cum(int[] c, int target, int start) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ls)); \\n            return;\\n        }\\n\\n        for (int i = start; i < c.length; i++) {\\n            if (c[i] <= target) {\\n                ls.add(c[i]);\\n                cum(c, target - c[i], i); \\n                ls.remove(ls.size() - 1); \\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778405,
                "title": "java-simple-approach-with-explanation-runtime-1-ms-100-faster",
                "content": "### Please upvote if you like the solution\\n\\n```\\nclass Solution {\\n    \\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] arr, int target) {\\n            \\n        getTargetCombination(arr, 0, target, new ArrayList<Integer>());\\n        return resultList;\\n    }\\n    \\n    \\n    public void getTargetCombination(int[] arr, int position, int currentTarget, List<Integer> result) {\\n\\n        /**\\n         * Base case\\n         * 1. If currentTarget is reaching to Zero\\n         * 2. Current Position is equal to the length of the Array\\n         */\\n        if (currentTarget == 0) {\\n            resultList.add(new ArrayList<>(result));\\n            return;\\n        }\\n        if (position == arr.length) {\\n            return;\\n        }\\n\\n        /**\\n         * There are two cases\\n         * 1. Pick the current value if the current value (i.e arr[position]) is less than or equal to the currentTarget\\n         *    value then use the same attribute by passing the same position\\n         *\\n         *  2. Not picking up the current element by not reducing the currentTarget value and increasing the position\\n         */\\n        if (arr[position] <= currentTarget) {\\n            result.add(arr[position]);\\n            getTargetCombination(arr, position, currentTarget - arr[position], result);\\n            // removing the last element because post adding of the value the call came back\\n            result.remove(result.size() - 1);\\n        }\\n        // not picked\\n        getTargetCombination(arr, position + 1, currentTarget, result);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] arr, int target) {\\n            \\n        getTargetCombination(arr, 0, target, new ArrayList<Integer>());\\n        return resultList;\\n    }\\n    \\n    \\n    public void getTargetCombination(int[] arr, int position, int currentTarget, List<Integer> result) {\\n\\n        /**\\n         * Base case\\n         * 1. If currentTarget is reaching to Zero\\n         * 2. Current Position is equal to the length of the Array\\n         */\\n        if (currentTarget == 0) {\\n            resultList.add(new ArrayList<>(result));\\n            return;\\n        }\\n        if (position == arr.length) {\\n            return;\\n        }\\n\\n        /**\\n         * There are two cases\\n         * 1. Pick the current value if the current value (i.e arr[position]) is less than or equal to the currentTarget\\n         *    value then use the same attribute by passing the same position\\n         *\\n         *  2. Not picking up the current element by not reducing the currentTarget value and increasing the position\\n         */\\n        if (arr[position] <= currentTarget) {\\n            result.add(arr[position]);\\n            getTargetCombination(arr, position, currentTarget - arr[position], result);\\n            // removing the last element because post adding of the value the call came back\\n            result.remove(result.size() - 1);\\n        }\\n        // not picked\\n        getTargetCombination(arr, position + 1, currentTarget, result);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16656,
                "title": "dynamic-programming-solution",
                "content": "It adapts the DP solution of coin change problem\\n\\n    class Solution {\\n    public:\\n    \\tvector<vector<int> > combinationSum(vector<int> &candidates, int target) {\\n    \\t\\tvector< vector< vector<int> > > combinations(target + 1, vector<vector<int>>());\\n    \\t\\tcombinations[0].push_back(vector<int>());\\n    \\t\\tfor (auto& score : candidates)\\n    \\t\\t\\tfor (int j = score; j <= target; j++)\\n    \\t\\t\\t\\tif (combinations[j - score].size() > 0)\\t{\\n    \\t\\t\\t\\t\\tauto tmp = combinations[j - score];\\n    \\t\\t\\t\\t\\tfor (auto& s : tmp)\\n    \\t\\t\\t\\t\\t\\ts.push_back(score);\\n    \\t\\t\\t\\t\\tcombinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end());\\n    \\t\\t\\t\\t}\\n    \\t\\tauto ret = combinations[target];\\n    \\t\\tfor (int i = 0; i < ret.size(); i++)\\n    \\t\\t\\tsort(ret[i].begin(), ret[i].end());\\n    \\t\\treturn ret;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int> > combinationSum(vector<int> &candidates, int target) {\\n    \\t\\tvector< vector< vector<int> > > combinations(target + 1, vector<vector<int>>());\\n    \\t\\tcombinations[0].push_back(vector<int>());\\n    \\t\\tfor (auto& score : candidates)\\n    \\t\\t\\tfor (int j = score; j <= target; j++)\\n    \\t\\t\\t\\tif (combinations[j - score].size() > 0)\\t{\\n    \\t\\t\\t\\t\\tauto tmp = combinations[j - score];\\n    \\t\\t\\t\\t\\tfor (auto& s : tmp)\\n    \\t\\t\\t\\t\\t\\ts.push_back(score);\\n    \\t\\t\\t\\t\\tcombinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end());\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 307982,
                "title": "heavily-commented-javascript-backtracking-solution",
                "content": "Here\\'s my heavily commented version, as I didn\\'t see many of those around yet.\\nI left the console.log in there, to help with getting the order of the execution.\\nRemove it for better performance.\\n\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n        console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else if (t < 0) {\\n            console.log(\\'Dead path. Will our code actually ever get here?\\');\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                find(t - candidates[i], [...p, candidates[i]], i)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 // further, because of the 2nd check of the while loop condition.\\n                i++;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n        console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else if (t < 0) {\\n            console.log(\\'Dead path. Will our code actually ever get here?\\');\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                find(t - candidates[i], [...p, candidates[i]], i)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 // further, because of the 2nd check of the while loop condition.\\n                i++;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815714,
                "title": "dfs-recursion-solution-with-illustration-to-understand-the-process",
                "content": "I\\'m using candidates[2,3,5] and target 8 as example. \\nIt\\'s pretty clear with the chart below how the function dfs is called recursively and how duplications like [3,5], [5,3] is avoided.\\nSome solutions sorted the candidates first, and some also have a if statement on if target <0. Both are not necessary.\\nAlso, I acutally found that sort the candidates may increase the number of operations. You can draw a similar chart with [5,3,2]. It has fewer operations. See codes following the chart below.\\n![image](https://assets.leetcode.com/users/images/600da56f-c155-40b7-bb44-186257125966_1598579025.1168523.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        self.dfs(candidates, target,[],res)\\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            self.dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "I\\'m using candidates[2,3,5] and target 8 as example. \\nIt\\'s pretty clear with the chart below how the function dfs is called recursively and how duplications like [3,5], [5,3] is avoided.\\nSome solutions sorted the candidates first, and some also have a if statement on if target <0. Both are not necessary.\\nAlso, I acutally found that sort the candidates may increase the number of operations. You can draw a similar chart with [5,3,2]. It has fewer operations. See codes following the chart below.\\n![image](https://assets.leetcode.com/users/images/600da56f-c155-40b7-bb44-186257125966_1598579025.1168523.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        self.dfs(candidates, target,[],res)\\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            self.dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 16669,
                "title": "c-backtracking-implementation",
                "content": "C# backtracking implementation\\n\\n        public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n        {\\n            List<IList<int>> result = new List<IList<int>>();\\n            List<int> combination = new List<int>();\\n            Array.Sort(candidates);\\n            CombinationSum(result, candidates, combination, target, 0);\\n            return result;\\n        }\\n\\n        private void CombinationSum(IList<IList<int>> result, int[] candidates, IList<int> combination, int target, int start)\\n        {\\n            if (target == 0)\\n            {\\n                result.Add(new List<int>(combination));\\n                return;\\n            }\\n\\n            for (int i = start; i != candidates.Length && target >= candidates[i]; ++i)\\n            {\\n                combination.Add(candidates[i]);\\n                CombinationSum(result, candidates, combination, target - candidates[i], i);\\n                combination.Remove(combination.Last());\\n            }\\n        }",
                "solutionTags": [],
                "code": "C# backtracking implementation\\n\\n        public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n        {\\n            List<IList<int>> result = new List<IList<int>>();\\n            List<int> combination = new List<int>();\\n            Array.Sort(candidates);\\n            CombinationSum(result, candidates, combination, target, 0);\\n            return result;\\n        }\\n\\n        private void CombinationSum(IList<IList<int>> result, int[] candidates, IList<int> combination, int target, int start)\\n        {\\n            if (target == 0)\\n            {\\n                result.Add(new List<int>(combination));\\n                return;\\n            }\\n\\n            for (int i = start; i != candidates.Length && target >= candidates[i]; ++i)\\n            {\\n                combination.Add(candidates[i]);\\n                CombinationSum(result, candidates, combination, target - candidates[i], i);\\n                combination.Remove(combination.Last());\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3237600,
                "title": "c-beats-100-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    void solve(int target,vector<int> &candidates,vector<vector<int>> &ans,int index)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            if(target-candidates[i]>=0)\\n               solve(target-candidates[i],candidates,ans,i);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        solve(target,candidates,ans,0);\\n        return ans;\\n    }\\n};\\n\\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/a9a3382a-a1b3-4c13-a59c-e5e41a1ca8fe_1677523515.9827046.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    void solve(int target,vector<int> &candidates,vector<vector<int>> &ans,int index)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            if(target-candidates[i]>=0)\\n               solve(target-candidates[i],candidates,ans,i);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        solve(target,candidates,ans,0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920513,
                "title": "python",
                "content": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```\\n```",
                "solutionTags": [],
                "code": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1546400,
                "title": "java-backtracking-w-early-exit-detailed-time-complexity-explanation-added",
                "content": "**Backtracking - No Early Exit optimization**\\n```\\n/**\\n * Since this question allows same number to be used unlimited times, candidates\\n * array cannot have zero and negative numbers. As it will lead to infinite\\n * number of combinations. For example: candidates = [-1, 0, 1] and target = 1.\\n * This case will result in infinite solutions if same number can be used\\n * multiple times.\\n *\\n * Time Complexity:\\n * This problem can be converted to Combination Sum II. For example, candidates = [2,3,5,6] and target = 12.\\n * Then we can create an array = [2,2,2,2,2,2, 3,3,3,3, 5,5, 6,6].\\n * Now from this array we can use each number only once in the combination.\\n * Therefore total number of elements in this array N\\' equal to floor(T/n1) + floor(T/n2) + ... + floor(T/nN)\\n *\\n * 1. The length of the potential combinations can vary from 1 to k where k = T/M.\\n * 2. Total number of combinations of size k is C(N\\',k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N\\',1) + 2*C(N\\',2) + ... + k*C(N\\',k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N\\', i)).\\n * If k = N\\', then above time complexity becomes O(N\\' * 2^(N\\'-1))\\n *\\n * Space Complexity: O(T/M) -> This is used by recursion stack and temp list.\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                continue;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Backtracking - With Early Exit optimization**\\n```java\\n/**\\n * In this solution we are sorting the input array, which allows us to early\\n * exit from the recursion if the current number is greater than the remaining\\n * target.\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * the time and space required for the sorting.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n        // Only benefit of sorting is that we can break early in the recursion if the\\n        // current number is greater than the remaining target.\\n        Arrays.sort(candidates);\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/1546439/Java-or-Backtracking-optimized-for-duplicate-candidates-(Detailed-TC-explanation-added))\\n- [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/1546449/Java-or-Optimized-Backtracking-w-Detailed-Time-Complexity-explanation)\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * Since this question allows same number to be used unlimited times, candidates\\n * array cannot have zero and negative numbers. As it will lead to infinite\\n * number of combinations. For example: candidates = [-1, 0, 1] and target = 1.\\n * This case will result in infinite solutions if same number can be used\\n * multiple times.\\n *\\n * Time Complexity:\\n * This problem can be converted to Combination Sum II. For example, candidates = [2,3,5,6] and target = 12.\\n * Then we can create an array = [2,2,2,2,2,2, 3,3,3,3, 5,5, 6,6].\\n * Now from this array we can use each number only once in the combination.\\n * Therefore total number of elements in this array N\\' equal to floor(T/n1) + floor(T/n2) + ... + floor(T/nN)\\n *\\n * 1. The length of the potential combinations can vary from 1 to k where k = T/M.\\n * 2. Total number of combinations of size k is C(N\\',k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N\\',1) + 2*C(N\\',2) + ... + k*C(N\\',k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N\\', i)).\\n * If k = N\\', then above time complexity becomes O(N\\' * 2^(N\\'-1))\\n *\\n * Space Complexity: O(T/M) -> This is used by recursion stack and temp list.\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                continue;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * In this solution we are sorting the input array, which allows us to early\\n * exit from the recursion if the current number is greater than the remaining\\n * target.\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * the time and space required for the sorting.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n        // Only benefit of sorting is that we can break early in the recursion if the\\n        // current number is greater than the remaining target.\\n        Arrays.sort(candidates);\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254479,
                "title": "20ms-cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target, int fm = 0) {\\n        if (target == 0){\\n            return {{}};\\n        }\\n        vector<vector<int>> res;\\n        for (int i = fm; i < candidates.size(); i++){\\n            if (target < candidates[i])\\n                continue;\\n\\n            for (vector<int> &b : combinationSum(candidates, target - candidates[i], i)){\\n                b.push_back(candidates[i]);\\n                res.push_back(b);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target, int fm = 0) {\\n        if (target == 0){\\n            return {{}};\\n        }\\n        vector<vector<int>> res;\\n        for (int i = fm; i < candidates.size(); i++){\\n            if (target < candidates[i])\\n                continue;\\n\\n            for (vector<int> &b : combinationSum(candidates, target - candidates[i], i)){\\n                b.push_back(candidates[i]);\\n                res.push_back(b);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16724,
                "title": "java-solution-backtracking",
                "content": "    public class Solution {\\n     \\n    \\tprivate List<List<Integer>> solution;\\n    \\n    \\tprivate List<Integer> curSolution;\\n    \\n    \\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\t\\tsolution = new ArrayList<List<Integer>>();\\n    \\t\\tcurSolution = new ArrayList<Integer>();\\n    \\t\\tArrays.sort(candidates);\\n    \\t\\tbackTrack(candidates, target, 0); \\n    \\t\\treturn solution;\\n    \\t}\\n    \\n    \\tprivate void backTrack(int[] candidates, int target, int lastIdx) {\\n    \\t\\tif (target == 0) {\\n    \\t\\t\\tsolution.add(new ArrayList<>(curSolution));\\n    \\t\\t}\\n    \\t\\telse if (target < 0) {\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tint i = lastIdx;\\n    \\t\\t\\twhile (i < candidates.length) {\\n    \\t\\t\\t\\tint candidate = candidates[i];\\n    \\t\\t\\t\\tcurSolution.add(candidate);\\n    \\t\\t\\t\\tbackTrack(candidates, target - candidate, i);\\n    \\t\\t\\t\\tcurSolution.remove(curSolution.size() - 1);\\n    \\t\\t\\t\\twhile (i < candidates.length && candidates[i] == candidate) {\\n    \\t\\t\\t\\t\\ti++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n     \\n    \\tprivate List<List<Integer>> solution;\\n    \\n    \\tprivate List<Integer> curSolution;\\n    \\n    \\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\t\\tsolution = new ArrayList<List<Integer>>();\\n    \\t\\tcurSolution = new ArrayList<Integer>();\\n    \\t\\tArrays.sort(candidates);\\n    \\t\\tbackTrack(candidates, target, 0); \\n    \\t\\treturn solution;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 16559,
                "title": "non-recursive-java-solution",
                "content": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        int i=0, size = candidates.length, sum=0;\\n        Stack<Integer> combi = new Stack<>(), indices = new Stack<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        while (i < size) {\\n        \\tif (sum + candidates[i]>= target) {\\n        \\t\\tif (sum + candidates[i] == target) {\\n        \\t\\t\\tcombi.push(candidates[i]);\\n        \\t\\t\\tresult.add(new ArrayList<>(combi));\\n        \\t\\t\\tcombi.pop();\\n        \\t\\t}\\n        \\t\\t// indices stack and combination stack should have the same size all the time\\n        \\t\\tif (!indices.empty()){\\n        \\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\ti = indices.pop();\\n        \\t\\t\\twhile (i == size-1 && !indices.empty()) {\\n        \\t\\t\\t\\ti = indices.pop();\\n        \\t\\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\t\\t\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t} else {\\n        \\t\\tcombi.push(candidates[i]);\\n        \\t\\tsum +=candidates[i];\\n        \\t\\tindices.push(i);\\n        \\t}\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Stack"
                ],
                "code": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        int i=0, size = candidates.length, sum=0;\\n        Stack<Integer> combi = new Stack<>(), indices = new Stack<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        while (i < size) {\\n        \\tif (sum + candidates[i]>= target) {\\n        \\t\\tif (sum + candidates[i] == target) {\\n        \\t\\t\\tcombi.push(candidates[i]);\\n        \\t\\t\\tresult.add(new ArrayList<>(combi));\\n        \\t\\t\\tcombi.pop();\\n        \\t\\t}\\n        \\t\\t// indices stack and combination stack should have the same size all the time\\n        \\t\\tif (!indices.empty()){\\n        \\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\ti = indices.pop();\\n        \\t\\t\\twhile (i == size-1 && !indices.empty()) {\\n        \\t\\t\\t\\ti = indices.pop();\\n        \\t\\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\t\\t\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t} else {\\n        \\t\\tcombi.push(candidates[i]);\\n        \\t\\tsum +=candidates[i];\\n        \\t\\tindices.push(i);\\n        \\t}\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1960396,
                "title": "java-98-fast-backtracking-and-recursion-full-explanation-with-comments",
                "content": "```\\n// Intuition behind this solution is thinking that \"CAN WE TAKE THE ELEMENT\" or \"NOT TAKING IT\" .\\n// By the above logic we can draw recursion tree\\n\\n/* \\n\\nNOTE : we can take any element any number of times in Combination sum 1\\nEX : [2,3,6,7] target = 7\\nans : [ [2,2,3] , [7] ]\\nSuppose calling function : funct(index,target,List<Integer> ds)\\nLeft tree : we are taking the element \\nRight tree : we are not\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2           3        6        7\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \\t  /   \\\\\\n                                       [0,5,{2}]  [i+1,7,{}]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /     \\\\\\n\\t\\t\\t\\t\\t    [0,3,{2,2}]    [i+1,5,{2}]\\n\\t\\t\\t\\t\\t\\t/     \\\\ \\n\\t\\t\\t [0,1,{2,2,2}]      [i+1,3,{2,2}]\\n\\t             /  \\\\                /   \\\\ \\n         Here  t = 0\\t    [1,0,{2,2,3}] = This is one of our answers\\n\\t\\t\\nLike that recursion tree will run and stops when i becomes arr.length and you can also stop at t becomes zero because then it will not be possible to take that element\\t\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] a, int t) {\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        List<Integer> ls = new ArrayList<>();  // our inside list to store different combinations\\n        int index = 0; // starting from index 0\\n        combSum(index,ans,a,t,ls); // recursive function\\n        return ans;\\n    }\\n    static void combSum(int i,List<List<Integer>>ans,int a[],int t,List<Integer> ds) {\\n        // Base condition\\n\\t\\tif(i == a.length) {\\n            if(t == 0) {\\n                ans.add(new ArrayList<>(ds)); // ArrayList constructor constructs a list of specified collection . in our case it is List<Integer> ds\\n            }\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// Check if the element at index is smaller than the target or not\\n        if(a[i] <= t) {\\n            ds.add(a[i]);\\n            combSum(i,ans,a,t-a[i],ds); // calls for same index and decreasing target by a[i]\\n            ds.remove(ds.size()-1); // during backtracking we will remove the added element in ds\\n        }\\n        combSum(i+1,ans,a,t,ds); // call for next index\\n    }\\n}\\n\\n/* Its time complexity will be : 2^target * k  ( k = putting ds in ans in base case )\\n\\nNOTE:  We are taking 2^target not 2^n because if we were allowed to take element only once(i.e in combination sum2) we can have n times pick/non-pick choices thats why its time complexity will be ( 2^n *k ) but here we are having a  choice to take one element multiple times . \\n\\nfor example : number = 2 , target = 10 we can pick/non-pick element 2 till t times \\nand if we distribute 2^t for n elements we can say on an average its time complexity will be 2^t\\n\\nSpace Complexity will be : ( k * x ) ( k = average length and x combinations ) ( Its totally dependent upon given conditions) */\\n\\n// Upvote if you like the explanation \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Intuition behind this solution is thinking that \"CAN WE TAKE THE ELEMENT\" or \"NOT TAKING IT\" .\\n// By the above logic we can draw recursion tree\\n\\n/* \\n\\nNOTE : we can take any element any number of times in Combination sum 1\\nEX : [2,3,6,7] target = 7\\nans : [ [2,2,3] , [7] ]\\nSuppose calling function : funct(index,target,List<Integer> ds)\\nLeft tree : we are taking the element \\nRight tree : we are not\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2           3        6        7\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \\t  /   \\\\\\n                                       [0,5,{2}]  [i+1,7,{}]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /     \\\\\\n\\t\\t\\t\\t\\t    [0,3,{2,2}]    [i+1,5,{2}]\\n\\t\\t\\t\\t\\t\\t/     \\\\ \\n\\t\\t\\t [0,1,{2,2,2}]      [i+1,3,{2,2}]\\n\\t             /  \\\\                /   \\\\ \\n         Here  t = 0\\t    [1,0,{2,2,3}] = This is one of our answers\\n\\t\\t\\nLike that recursion tree will run and stops when i becomes arr.length and you can also stop at t becomes zero because then it will not be possible to take that element\\t\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] a, int t) {\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        List<Integer> ls = new ArrayList<>();  // our inside list to store different combinations\\n        int index = 0; // starting from index 0\\n        combSum(index,ans,a,t,ls); // recursive function\\n        return ans;\\n    }\\n    static void combSum(int i,List<List<Integer>>ans,int a[],int t,List<Integer> ds) {\\n        // Base condition\\n\\t\\tif(i == a.length) {\\n            if(t == 0) {\\n                ans.add(new ArrayList<>(ds)); // ArrayList constructor constructs a list of specified collection . in our case it is List<Integer> ds\\n            }\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// Check if the element at index is smaller than the target or not\\n        if(a[i] <= t) {\\n            ds.add(a[i]);\\n            combSum(i,ans,a,t-a[i],ds); // calls for same index and decreasing target by a[i]\\n            ds.remove(ds.size()-1); // during backtracking we will remove the added element in ds\\n        }\\n        combSum(i+1,ans,a,t,ds); // call for next index\\n    }\\n}\\n\\n/* Its time complexity will be : 2^target * k  ( k = putting ds in ans in base case )\\n\\nNOTE:  We are taking 2^target not 2^n because if we were allowed to take element only once(i.e in combination sum2) we can have n times pick/non-pick choices thats why its time complexity will be ( 2^n *k ) but here we are having a  choice to take one element multiple times . \\n\\nfor example : number = 2 , target = 10 we can pick/non-pick element 2 till t times \\nand if we distribute 2^t for n elements we can say on an average its time complexity will be 2^t\\n\\nSpace Complexity will be : ( k * x ) ( k = average length and x combinations ) ( Its totally dependent upon given conditions) */\\n\\n// Upvote if you like the explanation \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177891,
                "title": "java-100-fastest-solution",
                "content": "```\\nclass Solution {\\n    \\n     void findAllways(int[] candidates,List<List<Integer>> finalList,ArrayList<Integer> list,int i,int target){\\n        if(target == 0)\\n            finalList.add(new ArrayList<Integer>(list));\\n        else{\\n            for(int j=i;j<candidates.length;j++)\\n            {\\n                if(candidates[j]<=target){\\n                list.add(candidates[j]);\\n                findAllways(candidates,finalList,list,j,target-candidates[j]);\\n                list.remove(list.size()-1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\n        List<List<Integer>> finalList = new ArrayList<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        findAllways(candidates,finalList,list,0,target);\\n        \\n        return finalList;\\n    }\\n    \\n}\\n``\\nPlease upvotes if find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n     void findAllways(int[] candidates,List<List<Integer>> finalList,ArrayList<Integer> list,int i,int target){\\n        if(target == 0)\\n            finalList.add(new ArrayList<Integer>(list));\\n        else{\\n            for(int j=i;j<candidates.length;j++)\\n            {\\n                if(candidates[j]<=target){\\n                list.add(candidates[j]);\\n                findAllways(candidates,finalList,list,j,target-candidates[j]);\\n                list.remove(list.size()-1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 371715,
                "title": "python-dynamic-programming-beats-99",
                "content": "I\\'m sharing both my recursive and dynamic programming solutions. The DP approach is about three times faster.\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # return self.combinationSumRecurisve(candidates, target, [])\\n        return self.combinationSumDP(candidates, target)\\n    \\n    def combinationSumDP(self, candidates, target):\\n        dp = {}\\n        dp[0] = [[]]\\n        candidates.sort()\\n        for c in candidates:\\n            for t in range(c, target + 1):\\n                if (t-c) in dp:\\n                    if t not in dp:\\n                        dp[t] = []\\n                    for comb_t_m_c in dp[t-c]:\\n                        dp[t].append(comb_t_m_c + [c])\\n        return dp[target] if target in dp else []\\n        \\n    \\n    def combinationSumRecurisve(self, candidates, target, curr_nums):\\n        if target == 0:\\n            return [curr_nums]\\n        \\n        if len(candidates) == 0 or target <= 0:\\n            return []\\n        \\n        c = candidates[0]\\n        sol = self.combinationSumRecurisve(candidates[1:], target, curr_nums)\\n        sol.extend(self.combinationSumRecurisve(candidates, target - c, curr_nums + [c]))\\n        return sol\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # return self.combinationSumRecurisve(candidates, target, [])\\n        return self.combinationSumDP(candidates, target)\\n    \\n    def combinationSumDP(self, candidates, target):\\n        dp = {}\\n        dp[0] = [[]]\\n        candidates.sort()\\n        for c in candidates:\\n            for t in range(c, target + 1):\\n                if (t-c) in dp:\\n                    if t not in dp:\\n                        dp[t] = []\\n                    for comb_t_m_c in dp[t-c]:\\n                        dp[t].append(comb_t_m_c + [c])\\n        return dp[target] if target in dp else []\\n        \\n    \\n    def combinationSumRecurisve(self, candidates, target, curr_nums):\\n        if target == 0:\\n            return [curr_nums]\\n        \\n        if len(candidates) == 0 or target <= 0:\\n            return []\\n        \\n        c = candidates[0]\\n        sol = self.combinationSumRecurisve(candidates[1:], target, curr_nums)\\n        sol.extend(self.combinationSumRecurisve(candidates, target - c, curr_nums + [c]))\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16735,
                "title": "share-my-15-line-dfs-java-code",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            Arrays.sort(candidates);\\n            dfs(ans, new ArrayList<Integer>(), candidates, target, 0);\\n            return ans;\\n        }\\n        \\n        private void dfs(List<List<Integer>> ans, List<Integer> list, int[] cand, int remain, int from) {\\n            if (remain < 0) { return; }\\n            if (remain == 0) { ans.add(new ArrayList<Integer>(list)); return; }\\n            for (int i=from; i<cand.length; ++i) {  //cand[] sorted; from is the starting point of picking elements at this level\\n                list.add(cand[i]);\\n                dfs(ans, list, cand, remain-cand[i], i);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            Arrays.sort(candidates);\\n            dfs(ans, new ArrayList<Integer>(), candidates, target, 0);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 16814,
                "title": "simple-and-fast-dfs-solution-python-ac-98ms",
                "content": "    class Solution:\\n    # @param candidates, a list of integers\\n    # @param target, integer\\n    # @return a list of lists of integers\\n    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        stack = [(0, 0, [])]\\n        result = []\\n        while stack:\\n            total, start, res = stack.pop()\\n            if total == target:\\n                result.append(res)\\n            for n in range(start, len(candidates)):\\n                t = total + candidates[n]\\n                if t > target:\\n                    break\\n                stack.append((t, n, res + [candidates[n]]))\\n        return result\\n\\nJAVA\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        Stack<ArrayList<Integer>> stack = new Stack<ArrayList<Integer>>();\\n        Stack<Integer> sum = new Stack<Integer>();\\n        Stack<Integer> start = new Stack<Integer>();\\n        stack.push(new ArrayList<Integer>());\\n        sum.push(0);\\n        start.push(0);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        while (!stack.isEmpty()) {\\n            List<Integer> res = stack.pop();\\n            int total = sum.pop();\\n            int begin = start.pop();\\n            if (total == target)\\n                result.add(res);\\n            else {\\n                for (int i = begin; i < candidates.length; i++) {\\n                    int t = total + candidates[i];\\n                    if (t > target)\\n                        break;\\n                    ArrayList<Integer> r = new ArrayList<Integer>(res);\\n                    r.add(candidates[i]);\\n                    stack.push(r);\\n                    sum.push(t);\\n                    start.push(i);\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param candidates, a list of integers\\n    # @param target, integer\\n    # @return a list of lists of integers\\n    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        stack = [(0, 0, [])]\\n        result = []\\n        while stack:\\n            total, start, res = stack.pop()\\n            if total == target:\\n                result.append(res)\\n            for n in range(start, len(candidates)):\\n                t = total + candidates[n]\\n                if t > target:\\n                    break\\n                stack.append((t, n, res + [candidates[n]]))\\n        return result\\n\\nJAVA\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        Stack<ArrayList<Integer>> stack = new Stack<ArrayList<Integer>>();\\n        Stack<Integer> sum = new Stack<Integer>();\\n        Stack<Integer> start = new Stack<Integer>();\\n        stack.push(new ArrayList<Integer>());\\n        sum.push(0);\\n        start.push(0);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        while (!stack.isEmpty()) {\\n            List<Integer> res = stack.pop();\\n            int total = sum.pop();\\n            int begin = start.pop();\\n            if (total == target)\\n                result.add(res);\\n            else {\\n                for (int i = begin; i < candidates.length; i++) {\\n                    int t = total + candidates[i];\\n                    if (t > target)\\n                        break;\\n                    ArrayList<Integer> r = new ArrayList<Integer>(res);\\n                    r.add(candidates[i]);\\n                    stack.push(r);\\n                    sum.push(t);\\n                    start.push(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3696459,
                "title": "backtraking-4-connected-problems",
                "content": "# 1.combination sum\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def dfs(candidates,target,path,res):\\n            if target==0:\\n                res.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n        dfs(candidates,target,[],res)\\n        return res\\n```\\n# 2.combination sum II\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\\n# 3. permutation\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\\n# 4. Restore IP Address\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:\\n                ans.append(temp[:-1])\\n                return\\n            if k==4 or len(s)==0:\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s):\\n                    break\\n                if int(s[:i+1])>255:\\n                    continue\\n                if i!=0 and s[0]==\"0\":\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  \\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```\\n# please upvote me it would encourage me alot\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def dfs(candidates,target,path,res):\\n            if target==0:\\n                res.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n        dfs(candidates,target,[],res)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:\\n                ans.append(temp[:-1])\\n                return\\n            if k==4 or len(s)==0:\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s):\\n                    break\\n                if int(s[:i+1])>255:\\n                    continue\\n                if i!=0 and s[0]==\"0\":\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  \\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090390,
                "title": "very-easy-c-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply do recursion and generate all the possible combinations to check if that combination result in target if not backtrack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe ca use backtracking like the same way we generate all the sub sets of array here the thing is we have to check if the sum of that subset result in target or not . And also we should check repeatedly for the same element also so not call for i+1 instead i.\\n# Complexity\\n- Time complexity:$$O(n*2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,int rem,vector<int>&temp){\\n        if(rem<0)return;\\n        if(rem==0)ans.push_back(temp);\\n\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i,rem-arr[i],temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int>temp;\\n        backtrack(candidates,0,target,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,int rem,vector<int>&temp){\\n        if(rem<0)return;\\n        if(rem==0)ans.push_back(temp);\\n\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i,rem-arr[i],temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int>temp;\\n        backtrack(candidates,0,target,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060713,
                "title": "c-faster-than-100-00-super-clear-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<int>cur_path;\\n\\t\\t\\tlen = candidates.size();\\n\\t\\t\\tdfs ( candidates, target, cur_path, 0 );\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n\\tprivate:\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tint len;\\n\\t\\t\\n\\t\\tvoid dfs ( vector<int> &candidates, int target, vector<int> &cur_path, int start )\\n\\t\\t{\\n\\t\\t\\tif ( target < 0 ) return;\\n\\t\\t\\tif ( target == 0 )\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(cur_path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor ( ; start < len; ++start )\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur_path.push_back( candidates[start] );\\n\\t\\t\\t\\tdfs ( candidates, target - candidates[start], cur_path, start );\\n\\t\\t\\t\\tcur_path.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<int>cur_path;\\n\\t\\t\\tlen = candidates.size();\\n\\t\\t\\tdfs ( candidates, target, cur_path, 0 );\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 632799,
                "title": "three-python-solutions-dp-bfs-backtrack-with-explanation-time-beats-88",
                "content": "### DP\\nConstruct a 1d table for recording combinations in a bottom-up manner. Time O(mn) where m denotes the number of candidates and n is the target.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tcache = [[] for _ in range(target + 1)]\\n\\tcache[0] = [[]]\\n\\tfor c in candidates:\\n\\t\\tfor i in range(target + 1):\\n\\t\\t\\tif i >= c:\\n\\t\\t\\t\\tfor temp_ans in cache[i - c]:\\n\\t\\t\\t\\t\\tcache[i].append(temp_ans + [c])\\n\\treturn cache[-1]\\n```\\n###  BFS\\nBasic idea is similar to [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)\\nFor each element pop from the queue, and for each possible candidates, minus it from the current target. If the result equals zeros then we get a solution; if the result is greater than zero then we keep push it into the queue; if the result is smaller than zero than we just stop proceeding there.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# BFS\\n\\tfrom collections import deque\\n\\tqueue = deque() # [cur_target, cur_ans]\\n\\tqueue.append((target, [], 0))\\n\\tans = []\\n\\twhile queue:\\n\\t\\tcur_target, cur_ans, cand_idx = queue.popleft()\\n\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\tnew_target = cur_target - candidates[i]\\n\\t\\t\\tif new_target == 0:\\n\\t\\t\\t\\tans.append(cur_ans + [candidates[i]])\\n\\t\\t\\telif new_target > 0:\\n\\t\\t\\t\\tqueue.append((cur_target - candidates[i], cur_ans + [candidates[i]], i))\\n\\treturn ans\\n```\\n### Backtrack\\nThe idea is very similar to [77. Combinations](https://leetcode.com/problems/combinations/) but we need to record and pass `cur_sum`, and the base case is to check if `cur_sum` is equal to or larger than `target`. Time beats ~62%.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tdef combination_sum(cur_ans, cur_sum, cand_idx):\\n\\t\\t\\tif cur_sum >= target:\\n\\t\\t\\t\\tif cur_sum == target:\\n\\t\\t\\t\\t\\tans.append(cur_ans)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\t\\tcombination_sum(cur_ans + [candidates[i]], cur_sum + candidates[i], i)\\n\\tans = []\\n\\tcombination_sum([], 0, 0)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tcache = [[] for _ in range(target + 1)]\\n\\tcache[0] = [[]]\\n\\tfor c in candidates:\\n\\t\\tfor i in range(target + 1):\\n\\t\\t\\tif i >= c:\\n\\t\\t\\t\\tfor temp_ans in cache[i - c]:\\n\\t\\t\\t\\t\\tcache[i].append(temp_ans + [c])\\n\\treturn cache[-1]\\n```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# BFS\\n\\tfrom collections import deque\\n\\tqueue = deque() # [cur_target, cur_ans]\\n\\tqueue.append((target, [], 0))\\n\\tans = []\\n\\twhile queue:\\n\\t\\tcur_target, cur_ans, cand_idx = queue.popleft()\\n\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\tnew_target = cur_target - candidates[i]\\n\\t\\t\\tif new_target == 0:\\n\\t\\t\\t\\tans.append(cur_ans + [candidates[i]])\\n\\t\\t\\telif new_target > 0:\\n\\t\\t\\t\\tqueue.append((cur_target - candidates[i], cur_ans + [candidates[i]], i))\\n\\treturn ans\\n```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tdef combination_sum(cur_ans, cur_sum, cand_idx):\\n\\t\\t\\tif cur_sum >= target:\\n\\t\\t\\t\\tif cur_sum == target:\\n\\t\\t\\t\\t\\tans.append(cur_ans)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\t\\tcombination_sum(cur_ans + [candidates[i]], cur_sum + candidates[i], i)\\n\\tans = []\\n\\tcombination_sum([], 0, 0)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 162348,
                "title": "backtracking-with-explanations",
                "content": ">Base case: target == 0\\n\\n>Recursive case: target > 0\\nwe try nums[i] as a candidate of current combination and decrease target by nums[i] (only if target >= candidates[i])\\n\\n>`curRes` printed for the example` candidates = [2,3,6,7], target = 7`\\n```\\n[2]\\n[2, 2]\\n[2, 2, 2]\\n[2, 2, 3]\\n[2, 3]\\n[3]\\n[3, 3]\\n[6]\\n[7]\\n```\\n****\\n```\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        if (candidates == null || candidates.length == 0)\\n            return new ArrayList<>();\\n        \\n        List<List<Integer>> allRes = new ArrayList<>();\\n        combinationSumAfter(candidates, target, new ArrayList<>(), allRes, 0);\\n        return allRes;\\n    }\\n    \\n    private void combinationSumAfter(int[] candidates, int target, List<Integer> curRes, List<List<Integer>> allRes, int start) {\\n        if (target == 0) {\\n            // Base case.\\n            allRes.add(new ArrayList<>(curRes));\\n            return;\\n        }\\n        // Recursive case.\\n        for (int i = start; i < candidates.length; i++) {\\n            if (target - candidates[i] < 0) continue;\\n            curRes.add(candidates[i]);\\n            // System.out.println(curRes);\\n            combinationSumAfter(candidates, target - candidates[i], curRes, allRes, i);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n[2]\\n[2, 2]\\n[2, 2, 2]\\n[2, 2, 3]\\n[2, 3]\\n[3]\\n[3, 3]\\n[6]\\n[7]\\n```\n```\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        if (candidates == null || candidates.length == 0)\\n            return new ArrayList<>();\\n        \\n        List<List<Integer>> allRes = new ArrayList<>();\\n        combinationSumAfter(candidates, target, new ArrayList<>(), allRes, 0);\\n        return allRes;\\n    }\\n    \\n    private void combinationSumAfter(int[] candidates, int target, List<Integer> curRes, List<List<Integer>> allRes, int start) {\\n        if (target == 0) {\\n            // Base case.\\n            allRes.add(new ArrayList<>(curRes));\\n            return;\\n        }\\n        // Recursive case.\\n        for (int i = start; i < candidates.length; i++) {\\n            if (target - candidates[i] < 0) continue;\\n            curRes.add(candidates[i]);\\n            // System.out.println(curRes);\\n            combinationSumAfter(candidates, target - candidates[i], curRes, allRes, i);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3363912,
                "title": "backtracking-with-python3-well-explantation-easy-clear",
                "content": "# Intuition:\\nThe problem requires finding all possible combinations of elements from a given list of integers such that their sum is equal to a target value. The approach is to use backtracking to generate all possible combinations and keep track of the valid ones.\\n\\n# Approach:\\nThe given code defines a class Solution and a function combinationSum that takes a list of integers and a target value as input and returns a list of lists containing all valid combinations of integers that add up to the target value.\\n\\nThe approach used is recursive backtracking. The backtracking function takes two arguments, curr which represents the current combination and i which represents the index of the next element to be added to the combination.\\n\\nInitially, the current combination is empty and the index i is set to zero. Then, for each index j starting from i, the backtracking function is called recursively with the updated combination curr+[can[j]] and the index j. This ensures that all possible combinations are explored.\\n\\nThe function also checks if the current combination sum equals the target value and adds it to the result list if it is valid.\\n\\n# Complexity:\\n# Time complexity: \\nThe time complexity of the backtracking function is O(2^n), where n is the length of the input list can. This is because there are 2^n possible combinations of elements from the input list. Therefore, the time complexity of the entire function is O(2^n) as well.\\n\\n# Space complexity: \\nThe space complexity of the backtracking function is O(n) as the maximum number of elements that can be stored in the current combination at any point is n. The space complexity of the entire function is also O(2^n) as there can be at most 2^n valid combinations.\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum(self, can: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def backtracking(curr: List[int],i:int):\\n            s=sum(curr)\\n            if s==target:\\n                res.append(curr)\\n            elif s<target:\\n                for j in range(i,len(can)):\\n                    backtracking(curr+[can[j]],j)\\n        backtracking([],0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, can: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def backtracking(curr: List[int],i:int):\\n            s=sum(curr)\\n            if s==target:\\n                res.append(curr)\\n            elif s<target:\\n                for j in range(i,len(can)):\\n                    backtracking(curr+[can[j]],j)\\n        backtracking([],0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905794,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n^m), where n is the length of candidates and m is the target value.\\n    //   - space: O(m), where m is the target value.\\n    \\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n        \\n        backtrack(remain: target, comb: &comb, start: 0, candidates: candidates, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(remain: Int, comb: inout [Int], start: Int, candidates: [Int], ans: inout [[Int]]) {\\n        guard remain >= 0 else { return }\\n        guard remain != 0 else { ans.append(comb); return }\\n\\n        for i in start..<candidates.count {\\n            comb.append(candidates[i])\\n            backtrack(remain: remain - candidates[i], comb: &comb, start: i, candidates: candidates, ans: &ans)\\n            comb.removeLast()\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n^m), where n is the length of candidates and m is the target value.\\n    //   - space: O(m), where m is the target value.\\n    \\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n        \\n        backtrack(remain: target, comb: &comb, start: 0, candidates: candidates, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(remain: Int, comb: inout [Int], start: Int, candidates: [Int], ans: inout [[Int]]) {\\n        guard remain >= 0 else { return }\\n        guard remain != 0 else { ans.append(comb); return }\\n\\n        for i in start..<candidates.count {\\n            comb.append(candidates[i])\\n            backtrack(remain: remain - candidates[i], comb: &comb, start: i, candidates: candidates, ans: &ans)\\n            comb.removeLast()\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595577,
                "title": "my-solution",
                "content": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1560722,
                "title": "java-easy-solution-100-faster-recursion-and-backtracking",
                "content": "## Combination Sum\\n\\n![image](https://assets.leetcode.com/users/images/a0d936b8-ff90-48d7-9233-1235eaadf933_1636105505.476083.png)\\n\\n\\nThere are similar questions like 2sum, 3sum, 4sum in which we were required to find a given number of elements from array whose sum is equal to target element, but in this problem we are required to find all the possible subarray or sublists.\\nThe approach for this problem is similar to other problems on finding [subsets](https://leetcode.com/problems/subsets-ii/) and [permutation](https://leetcode.com/problems/permutations/).\\n\\n**Code**\\n\\n```java\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tcombinationUtil(list, new ArrayList<>(), candidates, 0, target);\\n\\treturn list;\\n}\\n\\npublic void combinationUtil(List<List<Integer>> list, List<Integer> temp, int[] candidates, int start, int target) {\\n\\t// base case\\n\\tif(target == 0) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t// recursion step\\n\\tfor(int i = start; i < candidates.length; i++) {\\n\\t\\tif(target < candidates[i]) continue;\\n\\n\\t\\ttemp.add(candidates[i]);\\n\\t\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```\\n\\n**Explanation**\\nSo we were required to find all the sub lists in which sum of elements equal to target given and each element can be taken any number of times. \\nLet\\'s understand recursive step first\\n\\n```java\\nfor(int i = start; i < candidates.length; i++) {\\n\\tif(target < candidates[i]) continue;\\n\\n\\ttemp.add(candidates[i]);\\n\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\ttemp.remove(temp.size() - 1);\\n}\\n```\\n\\nHere I am starting from `0th index` and if the element is greater than or equal to the target then only I add that to my `temp` list otherwise `continue`, after adding to `temp` list make further call on to subarray starting from same `i` because it is given that same element can be taken as many times, so we have to consider the same element and check weather it makes a pair not.\\nThen after solving for `i` remove last element of temp and increment `i` to check for pair starting from next element. Do not forget to initialise `i` to `start` because we don\\'t want to start again from the `0th index` as that will give us duplicates.\\n\\n\\n![image](https://assets.leetcode.com/users/images/92604850-3aa5-402c-a76d-ada2b9581bfa_1636106847.534792.png)\\n\\nHope it helps\\nDo upvote\\nThanks\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tcombinationUtil(list, new ArrayList<>(), candidates, 0, target);\\n\\treturn list;\\n}\\n\\npublic void combinationUtil(List<List<Integer>> list, List<Integer> temp, int[] candidates, int start, int target) {\\n\\t// base case\\n\\tif(target == 0) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t// recursion step\\n\\tfor(int i = start; i < candidates.length; i++) {\\n\\t\\tif(target < candidates[i]) continue;\\n\\n\\t\\ttemp.add(candidates[i]);\\n\\t\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```\n```java\\nfor(int i = start; i < candidates.length; i++) {\\n\\tif(target < candidates[i]) continue;\\n\\n\\ttemp.add(candidates[i]);\\n\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\ttemp.remove(temp.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382280,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\n   vector<vector<int>> ans;\\n    void solve(vector<int>& candidates, int target,int i,int sum,vector<int> temp)\\n    {\\n        \\n        if(target==sum )\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(sum>target || i>=candidates.size())\\n            return;\\n        temp.push_back(candidates[i]);\\n        solve(candidates,target,i,sum+candidates[i],temp);\\n        temp.pop_back();\\n        solve(candidates,target,i+1,sum,temp);\\n      \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        vector<int> temp;\\n        solve(candidates,target,0,0,temp);\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n   vector<vector<int>> ans;\\n    void solve(vector<int>& candidates, int target,int i,int sum,vector<int> temp)\\n    {\\n        \\n        if(target==sum )\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(sum>target || i>=candidates.size())\\n            return;\\n        temp.push_back(candidates[i]);\\n        solve(candidates,target,i,sum+candidates[i],temp);\\n        temp.pop_back();\\n        solve(candidates,target,i+1,sum,temp);\\n      \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        vector<int> temp;\\n        solve(candidates,target,0,0,temp);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616872,
                "title": "intuitive-javascript-solution-with-backtracking",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n  const output = [];\\n   //The goal is to use backtracking to find all combinations.\\n  const findCombination = (remain, path, start) => {\\n    if (remain < 0) {\\n      return;\\n    }\\n    if (remain === 0) {\\n      output.push([...path]);\\n      return;\\n    }\\n    for (let i = start; i < candidates.length; i++) {\\n      // create a new path array to run the subroutine. It\\'s\\n      // cleaner than pushing and then reseting the array in \\n      // javascript.\\n      findCombination(remain - candidates[i], [...path, candidates[i]], i);    \\n    }\\n  }\\n  findCombination(target, [], 0);\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n  const output = [];\\n   //The goal is to use backtracking to find all combinations.\\n  const findCombination = (remain, path, start) => {\\n    if (remain < 0) {\\n      return;\\n    }\\n    if (remain === 0) {\\n      output.push([...path]);\\n      return;\\n    }\\n    for (let i = start; i < candidates.length; i++) {\\n      // create a new path array to run the subroutine. It\\'s\\n      // cleaner than pushing and then reseting the array in \\n      // javascript.\\n      findCombination(remain - candidates[i], [...path, candidates[i]], i);    \\n    }\\n  }\\n  findCombination(target, [], 0);\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389405,
                "title": "combination-1-method-for-6-problems-39-40-77-78-90-216",
                "content": "# Main Idea\\nAfter finishing all these problem, I found that the answers of the leetcode GOD, @caikehe, all use similar approach. So I challenge myself to try out DFS. I think DFS is more easy to understand.\\n\\nThe DFS function\\'s structure can mostly break down into\\n1. Check if it is the path we are looking for, if true, append it to the output.\\n2. Explore (loop through) all the possible next node and call its DFS and we may need to add some kind of constraints in the DFS to fullfill the requirement. For example, limit the possible next node in the next DFS, so we can only select in ascending order.\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```python\\nclass Solution(object):\\n    def combinationSum(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    num = candidates[i]\\n                    dfs(i, target-num, path+[num])\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\nThe key is to pick up number by ascending order, so we will not have duplicates.\\nIn order to do that, we use `min_i`, `min_i` means that we can only select index that is larger than `min_i`\\n\"\"\"\\n```\\n\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\\n```python\\nclass Solution(object):\\n    def combinationSum2(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    if i>min_i and candidates[i]==candidates[i-1]: continue #[2]\\n                    num = candidates[i]\\n                    dfs(i+1, target-num, path+[num]) #[1]\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\n1.\\nIn this problem, we can only select each number once.\\nThat is why we pass `i+1` to the `dfs()`.\\n\\n2.\\nAnother thing is preventing duplicates.\\nFor example, `[1,2,2,2,3]`\\nWe may end up using the first 2, the second 2, the third 2 to make 3 `[2, 3]`.\\nSo when we are looping all the possible candidates\\nWe need to `continue` if it is the not the first one in all the same element.\\nBecuase the first element is going to cover all the possibilities in its own `dfs()`.\\n\"\"\"\\n```\\n\\n[77. Combinations](https://leetcode.com/problems/combinations/)\\n```python\\nclass Solution(object):\\n    def combine(self, N, K):\\n        def dfs(min_num, path):\\n            if len(path)==K:\\n                opt.append(path)\\n                return\\n            else:\\n                for num in xrange(min_num, N+1):\\n                    dfs(num+1, path+[num])\\n        opt = []\\n        dfs(1, [])\\n        return opt\\n```\\n\\n# [90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```python\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        nums.sort()\\n\\n        def dfs(nums, path):\\n            opt.append(path)\\n            if len(nums)==0: return\\n            for i, num in enumerate(nums):\\n                if i>0 and nums[i]==nums[i-1]: continue #[0]\\n                dfs(path+[num], nums[i+1:])\\n        opt = []\\n        dfs([], nums)\\n        return opt\\n\"\"\"\\nSince there is duplicate in the `nums`, if the `num` is the same as the previous, we need to skip it.\\nBecause in the previous DFS, the out come has include the existance of current node.\\n\"\"\"\\n```\\n\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)\\n```python\\nclass Solution(object):\\n    def combinationSum3(self, K, N):\\n        def dfs(min_num, path):\\n            if len(path)==K and sum(path)==N:\\n                opt.append(path)\\n            for num in xrange(min_num, 10):\\n                dfs(path+[num], num+1)\\n        opt = []\\n        dfs([], 1)\\n        return opt\\n```\\n\\n# Big O\\nThe big O of these question are complicated and hard to analize. But according to some resource, all the combination problems are derived to be `O(2^N)`, N is the number of element. (`let s = target / min(nums[i])  T = C(s,1) + C(s, 2) + ... + C(s, s) = 2^s`) You can think of this answer as for each element it got two choices, to be chosen or not to be chosen.\\n\\nThe Space complexity is also `O(2^N)`, because we use recusive DFS. If we convert above to be iterative DFS, it may reduce to `O(N)`.\\n\\n# More Resources\\nCheck out my GitHub, https://github.com/wuduhren/leetcode-python for other topics.  \\nI really take time tried to make the best solution or explaination. Because I wanted to help others like me.  \\nIf you like my answer, a **star** on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def combinationSum(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    num = candidates[i]\\n                    dfs(i, target-num, path+[num])\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\nThe key is to pick up number by ascending order, so we will not have duplicates.\\nIn order to do that, we use `min_i`, `min_i` means that we can only select index that is larger than `min_i`\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combinationSum2(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    if i>min_i and candidates[i]==candidates[i-1]: continue #[2]\\n                    num = candidates[i]\\n                    dfs(i+1, target-num, path+[num]) #[1]\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\n1.\\nIn this problem, we can only select each number once.\\nThat is why we pass `i+1` to the `dfs()`.\\n\\n2.\\nAnother thing is preventing duplicates.\\nFor example, `[1,2,2,2,3]`\\nWe may end up using the first 2, the second 2, the third 2 to make 3 `[2, 3]`.\\nSo when we are looping all the possible candidates\\nWe need to `continue` if it is the not the first one in all the same element.\\nBecuase the first element is going to cover all the possibilities in its own `dfs()`.\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combine(self, N, K):\\n        def dfs(min_num, path):\\n            if len(path)==K:\\n                opt.append(path)\\n                return\\n            else:\\n                for num in xrange(min_num, N+1):\\n                    dfs(num+1, path+[num])\\n        opt = []\\n        dfs(1, [])\\n        return opt\\n```\n```python\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        nums.sort()\\n\\n        def dfs(nums, path):\\n            opt.append(path)\\n            if len(nums)==0: return\\n            for i, num in enumerate(nums):\\n                if i>0 and nums[i]==nums[i-1]: continue #[0]\\n                dfs(path+[num], nums[i+1:])\\n        opt = []\\n        dfs([], nums)\\n        return opt\\n\"\"\"\\nSince there is duplicate in the `nums`, if the `num` is the same as the previous, we need to skip it.\\nBecause in the previous DFS, the out come has include the existance of current node.\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combinationSum3(self, K, N):\\n        def dfs(min_num, path):\\n            if len(path)==K and sum(path)==N:\\n                opt.append(path)\\n            for num in xrange(min_num, 10):\\n                dfs(path+[num], num+1)\\n        opt = []\\n        dfs([], 1)\\n        return opt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16754,
                "title": "simple-java-solution",
                "content": "\\n    List<List<Integer>> res = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        helper(candidates, 0, target, new ArrayList<Integer>());\\n        return res;\\n    }\\n    \\n    private void helper(int[] can, int start, int target,List<Integer> each) {\\n        for (int i = start; i < can.length; i++) {\\n            List<Integer> temp = new ArrayList<>(each);\\n            if (can[i] == target) {\\n                temp.add(can[i]);\\n                res.add(temp);\\n                break;\\n            } else if (can[i] < target) {\\n                temp.add(can[i]);\\n                helper(can, i, target - can[i], new ArrayList<>(temp));\\n            } else {break;}\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    List<List<Integer>> res = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        helper(candidates, 0, target, new ArrayList<Integer>());\\n        return res;\\n    }\\n    \\n    private void helper(int[] can, int start, int target,List<Integer> each) {\\n        for (int i = start; i < can.length; i++) {\\n            List<Integer> temp = new ArrayList<>(each);\\n            if (can[i] == target) {\\n                temp.add(can[i]);\\n                res.add(temp);\\n                break;\\n            } else if (can[i] < target) {\\n                temp.add(can[i]);\\n                helper(can, i, target - can[i], new ArrayList<>(temp));\\n            } else {break;}\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2378220,
                "title": "simple-java-solution-with-full-explanation-easy-to-understand-recursion-tree-drawn",
                "content": "```\\nPlease  \\uD83D\\uDD3C this.solution if(you understood == true)\\n```\\n\\nFirstly if we need to make anytype of choices we can use recursion like to pick the element or to not pick it :\\n\\n##### Recursive Function Call will take arguements :\\n\\n1. `index = 0`\\n2. array(candidates in this case)\\n3. target\\n4. ans `List<<List>>`\\n5. empty `List<>` \\n\\nhere like in case : [2,3,6,7] when target = 7 \\n\\n**Function Call will look Like this** : `combinationsFinder(index,arr,target,list<list<>>,list<>)`\\n\\n***Steps I took to solve:***\\n\\n1. Start from 0 index element i.e 2\\n\\n2. Now we have 2 choices either pick it or leave it (all about recursion)\\n\\n3. Like if we pick it then target will become 5 as 2 is already taken hence (target = target - candidates[i]) and then we will not increase the index as an element can be taken multiple times. We will add this to an ArrayList or Vector as per language pref. after function got called we will remove that element from the list.\\n\\n4. Second choice: if we not pick it target will remain as it is and index will increment by 1 (index = index+1). We will pass the list as it is (empty as no element added). Note: we are not picking element only if it greater than target. \\n\\n5. and lastly for the base condition (no more recursion call) if the target becomes 0 when our index reaches length of array we will add empty arrayList else return\\n\\n\\n**Recursion Tree HandDrawn (ps dont mind my drawing) :**\\n\\n![image](https://assets.leetcode.com/users/images/b152d9f9-f6ef-428b-afd5-28707474c205_1659611996.5682747.png)\\n\\n**Hope You Understood and If you all liked the explanation please upvote this Post** \\uD83D\\uDE0A\\n\\n***My Java Code is \\uD83D\\uDC47\\uD83C\\uDF55***\\n```\\n// Best Approach : Combinations - Recursion - PickNotPick\\n// Time Complexity : O(2^n*k)  -> k : length of arraylist\\n// Space Complexity : O(k)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        combinationsFinder(candidates,0,target,new ArrayList<>(),ans);\\n        \\n        return ans;\\n    }\\n    \\n    static void combinationsFinder(int[] arr,int idx,int target,List<Integer> list,List<List<Integer>> ans){\\n        \\n        if(idx == arr.length){\\n            if(target==0) ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        if(arr[idx]<=target){\\n            list.add(arr[idx]);\\n            combinationsFinder(arr,idx,target - arr[idx],list,ans);\\n            list.remove(list.size() - 1);\\n        }\\n        combinationsFinder(arr,idx+1,target,list,ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nPlease  \\uD83D\\uDD3C this.solution if(you understood == true)\\n```\n```\\n// Best Approach : Combinations - Recursion - PickNotPick\\n// Time Complexity : O(2^n*k)  -> k : length of arraylist\\n// Space Complexity : O(k)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        combinationsFinder(candidates,0,target,new ArrayList<>(),ans);\\n        \\n        return ans;\\n    }\\n    \\n    static void combinationsFinder(int[] arr,int idx,int target,List<Integer> list,List<List<Integer>> ans){\\n        \\n        if(idx == arr.length){\\n            if(target==0) ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        if(arr[idx]<=target){\\n            list.add(arr[idx]);\\n            combinationsFinder(arr,idx,target - arr[idx],list,ans);\\n            list.remove(list.size() - 1);\\n        }\\n        combinationsFinder(arr,idx+1,target,list,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918913,
                "title": "easy-c-solution-using-recursion-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We can take an element multiple times and add them to get the target value.\\n- We\\u2019re using the help function where the base case is if the index reaches the last of our candidates array & the target became 0 then we\\u2019ll push temp to ans vector.\\n- Now there could be 2 possible cases:\\n    1. We\\u2019ll include the current element to our temp variable:\\n        - Check the current index value if it\\u2019s less than target then we can push it to temp and consider this as a part of our ans vector. Reduce the value from target.\\n        - after that we\\u2019ll pop the element from temp, as when it return from this call means that value didn\\u2019t give us expected ans.\\n    2. We won\\u2019t include the current element and move to the next element.\\n- **Time complexity:** O(2^k), where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        help(0, candidates, target, ans, temp);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& candidates, int target, vector<vector<int>> &ans, vector<int> &temp){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n            \\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            help(index, candidates, target-candidates[index], ans, temp);\\n            temp.pop_back();\\n        }\\n        help(index+1, candidates, target, ans, temp);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        help(0, candidates, target, ans, temp);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& candidates, int target, vector<vector<int>> &ans, vector<int> &temp){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n            \\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            help(index, candidates, target-candidates[index], ans, temp);\\n            temp.pop_back();\\n        }\\n        help(index+1, candidates, target, ans, temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875295,
                "title": "javascript-typescript-dfs-solution-w-detailed-comments",
                "content": "**javascript:**\\n```\\nfunction combinationSum(candidates, target) {\\n    // result of all combinations that sum to target\\n    var res = [];\\n\\t\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path, sum, last) {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (var i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\t\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort(function (a, b) {\\n        return a - b;\\n    });\\n\\t\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\t\\n    return res;\\n}\\n```\\n\\n**typescript:**\\n```\\nfunction combinationSum(candidates: number[], target: number): number[][] {\\n    // result of all combinations that sum to target\\n    const res: number[][] = [];\\n\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path: number[], sum: number, last: number): void {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (let i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort((a, b) => a - b);\\n\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction combinationSum(candidates, target) {\\n    // result of all combinations that sum to target\\n    var res = [];\\n\\t\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path, sum, last) {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (var i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\t\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort(function (a, b) {\\n        return a - b;\\n    });\\n\\t\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\t\\n    return res;\\n}\\n```\n```\\nfunction combinationSum(candidates: number[], target: number): number[][] {\\n    // result of all combinations that sum to target\\n    const res: number[][] = [];\\n\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path: number[], sum: number, last: number): void {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (let i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort((a, b) => a - b);\\n\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16550,
                "title": "swift-solution-backtracking",
                "content": "```\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var result = [[Int]]()\\n        var candidate = [Int]()\\n        \\n        backtracking(&result, &candidate, candidates.sorted(), target, 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[Int]], _ candidate: inout [Int], _ candidates: [Int], _ remain: Int, _ start: Int) {\\n        if remain < 0 {\\n            return\\n        } else if remain == 0 {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<candidates.count {\\n                candidate.append(candidates[i])\\n                backtracking(&result, &candidate, candidates, remain - candidates[i], i)\\n                candidate.removeLast()\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var result = [[Int]]()\\n        var candidate = [Int]()\\n        \\n        backtracking(&result, &candidate, candidates.sorted(), target, 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[Int]], _ candidate: inout [Int], _ candidates: [Int], _ remain: Int, _ start: Int) {\\n        if remain < 0 {\\n            return\\n        } else if remain == 0 {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<candidates.count {\\n                candidate.append(candidates[i])\\n                backtracking(&result, &candidate, candidates, remain - candidates[i], i)\\n                candidate.removeLast()\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16719,
                "title": "16-lines-concise-and-easy-understand-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, tmp, candidates, target, 0);\\n            return res;\\n        }\\n        void backtracking(vector<vector<int>>& res, vector<int>& tmp, vector<int>& candidates, int target, int index){\\n            if(target < 0) return;\\n            if(target == 0) {\\n                res.push_back(tmp);\\n                return;\\n            }\\n            for(int i = index; i < candidates.size(); i++){\\n                tmp.push_back(candidates[i]);\\n                backtracking(res, tmp, candidates, target - candidates[i], i);\\n                tmp.pop_back();\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, tmp, candidates, target, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 16761,
                "title": "c-backtracking-solution",
                "content": "        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> nums;\\n        sort(candidates.begin(), candidates.end());\\n        dfs(candidates, target, 0, nums, res);\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& candidates, int target, int index, vector<int>& nums, vector<vector<int>>& res) {\\n        if (target < 0)\\n            return;\\n        if (target == 0) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        for (int i=index; i<candidates.size(); i++) {\\n            nums.push_back(candidates[i]);\\n            dfs(candidates, target-candidates[i], i, nums, res);\\n            nums.pop_back();\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> nums;\\n        sort(candidates.begin(), candidates.end());\\n        dfs(candidates, target, 0, nums, res);\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& candidates, int target, int index, vector<int>& nums, vector<vector<int>>& res) {\\n        if (target < 0)\\n            return;\\n        if (target == 0) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        for (int i=index; i<candidates.size(); i++) {\\n            nums.push_back(candidates[i]);\\n            dfs(candidates, target-candidates[i], i, nums, res);\\n            nums.pop_back();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3534868,
                "title": "c-easy-to-understand",
                "content": "### Intuition:\\nThe problem requires us to find all unique combinations of numbers from the given candidates list that add up to the target value. We can start by considering each candidate as a possible choice at each step and recursively explore all possible paths until the target is reached or exceeded.\\n\\n\\n### Approach:\\n1. Create a vector to store all the unique combinations that add up to the target value. \\n2. Create a vector to store the current combination being explored.\\n3. Define a recursive helper function that takes in the candidates list, target value, start index, current combination, and the answer vector as parameters.\\n4. If the target value is reached, add the current combination to the answer vector and return.\\n5. If the target value is exceeded, return.\\n6. For each candidate starting from the start index, add it to the current combination and recursively call the helper function with the updated target value and start index.\\n7. After returning from the recursive call, remove the last added candidate from the current combination to explore other possibilities.\\n8. Return the answer vector.\\n \\n### Complexity:\\n- Time Complexity: The time complexity of the algorithm is O(N^target), where N is the length of the candidates list and target is the target value. This is because, in the worst-case scenario, we may have to explore all possible combinations of length target. \\n- Space Complexity: The space complexity of the algorithm is O(target) because of the recursive call stack. The space required to store the answer vector and the current combination is negligible compared to the stack space.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(candidates, target, 0, curr, ans);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target, int start, vector<int>& curr, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(target < 0){\\n            return;\\n        }\\n        for(int i=start; i<candidates.size(); i++){\\n            curr.push_back(candidates[i]);\\n            helper(candidates, target-candidates[i], i, curr, ans);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n\\n```\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(candidates, target, 0, curr, ans);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target, int start, vector<int>& curr, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(target < 0){\\n            return;\\n        }\\n        for(int i=start; i<candidates.size(); i++){\\n            curr.push_back(candidates[i]);\\n            helper(candidates, target-candidates[i], i, curr, ans);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211354,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all the given integers, and T is the target value. Thus the time complexity is exponential and this is expected because the algorithm is recursive backtracking.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(T/M), where T is the target value and M is the minimal element among all other candidates.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum(candidates, target-candidates[index], output, temp, index);\\n            temp.pop_back();\\n        }\\n        combinationSum(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                temp.push_back(candidates[i]);\\n                combinationSum(candidates, target-candidates[i], output, temp, i);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum(candidates, target-candidates[index], output, temp, index);\\n            temp.pop_back();\\n        }\\n        combinationSum(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                temp.push_back(candidates[i]);\\n                combinationSum(candidates, target-candidates[i], output, temp, i);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083701,
                "title": "94-javascript-fast-very-easy-to-understand-solution",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/kO95ZxxDpwI\\n\\n# Code\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let res = []\\n    let temp = []\\n    let iterate = (index,sum)=>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push([...temp])\\n            return;\\n        }\\n        for(let i =index; i<candidates.length;i++){\\n            if(candidates[i]>target)continue\\n            temp.push(candidates[i])\\n            iterate(i, sum+candidates[i])\\n            temp.pop()\\n        }\\n    }\\n    iterate(0,0)\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let res = []\\n    let temp = []\\n    let iterate = (index,sum)=>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push([...temp])\\n            return;\\n        }\\n        for(let i =index; i<candidates.length;i++){\\n            if(candidates[i]>target)continue\\n            temp.push(candidates[i])\\n            iterate(i, sum+candidates[i])\\n            temp.pop()\\n        }\\n    }\\n    iterate(0,0)\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777024,
                "title": "java-dp",
                "content": "I solved this problem too many times with backtracking, lets solve it using DP (knapsack)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>>[] dp = new List[target + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(new ArrayList<>());\\n          \\n        for (int c : candidates) {\\n            for (int i = c; i <= target; i++) {\\n                if (dp[i - c] != null) {\\n                    if (dp[i] == null)\\n                        dp[i] = new ArrayList<>();\\n                                    \\n                    for (List<Integer> list : dp[i - c]) {\\n                        List<Integer> copy = new ArrayList<>(list);\\n                        copy.add(c);\\n                        \\n                        dp[i].add(copy);\\n                    }\\n                }\\n            }            \\n        } \\n        \\n        return dp[target] == null ? new ArrayList<>() : dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>>[] dp = new List[target + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(new ArrayList<>());\\n          \\n        for (int c : candidates) {\\n            for (int i = c; i <= target; i++) {\\n                if (dp[i - c] != null) {\\n                    if (dp[i] == null)\\n                        dp[i] = new ArrayList<>();\\n                                    \\n                    for (List<Integer> list : dp[i - c]) {\\n                        List<Integer> copy = new ArrayList<>(list);\\n                        copy.add(c);\\n                        \\n                        dp[i].add(copy);\\n                    }\\n                }\\n            }            \\n        } \\n        \\n        return dp[target] == null ? new ArrayList<>() : dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777011,
                "title": "java-recursion-4ms-daily-challenge-2-17-22",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        helper(candidates, target, 0, new ArrayList<Integer>());\\n        return res;\\n    }\\n    List<List<Integer>> res = new ArrayList<>();\\n    private void helper(int[] cands, int target, int stIdx, List<Integer> curList) {\\n        if (target == 0) res.add(curList);\\n        \\n        for (int i = stIdx; i < cands.length; i++) {\\n            if (cands[i] <= target) {\\n                List<Integer> list = new ArrayList<>(curList);\\n                list.add(cands[i]);\\n                helper(cands, target - cands[i], i, list);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        helper(candidates, target, 0, new ArrayList<Integer>());\\n        return res;\\n    }\\n    List<List<Integer>> res = new ArrayList<>();\\n    private void helper(int[] cands, int target, int stIdx, List<Integer> curList) {\\n        if (target == 0) res.add(curList);\\n        \\n        for (int i = stIdx; i < cands.length; i++) {\\n            if (cands[i] <= target) {\\n                List<Integer> list = new ArrayList<>(curList);\\n                list.add(cands[i]);\\n                helper(cands, target - cands[i], i, list);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874929,
                "title": "c-straightforward-backtracking-unbounded-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> combinations;\\n        vector<int> current;\\n        backtrack(candidates, target, 0, current, combinations);\\n        return combinations;\\n    }\\n    \\nprivate:\\n    void backtrack(vector<int>& candidates, int target, int index, vector<int>& current, vector<vector<int>>& combinations) {\\n        if (target == 0) {\\n            combinations.push_back(current);\\n            return;\\n        }\\n        if (target < 0 || index >= candidates.size()) return;\\n        current.push_back(candidates[index]);\\n        backtrack(candidates, target - current.back(), index, current, combinations);\\n        current.pop_back();\\n        backtrack(candidates, target, index + 1, current, combinations);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> combinations;\\n        vector<int> current;\\n        backtrack(candidates, target, 0, current, combinations);\\n        return combinations;\\n    }\\n    \\nprivate:\\n    void backtrack(vector<int>& candidates, int target, int index, vector<int>& current, vector<vector<int>>& combinations) {\\n        if (target == 0) {\\n            combinations.push_back(current);\\n            return;\\n        }\\n        if (target < 0 || index >= candidates.size()) return;\\n        current.push_back(candidates[index]);\\n        backtrack(candidates, target - current.back(), index, current, combinations);\\n        current.pop_back();\\n        backtrack(candidates, target, index + 1, current, combinations);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491067,
                "title": "python-simple-and-concise-clean-code",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        \\n        ret = []\\n        \\n        def fn(nums, tmp):\\n            if sum(tmp) > target:\\n                return False\\n            elif sum(tmp) == target:\\n                ret.append(tmp)\\n                return True\\n            else:   # sum(tmp) < target\\n                for i in range(len(nums)):\\n                    fn(nums[i:],tmp+[nums[i]])\\n        \\n        fn(candidates,[])\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        \\n        ret = []\\n        \\n        def fn(nums, tmp):\\n            if sum(tmp) > target:\\n                return False\\n            elif sum(tmp) == target:\\n                ret.append(tmp)\\n                return True\\n            else:   # sum(tmp) < target\\n                for i in range(len(nums)):\\n                    fn(nums[i:],tmp+[nums[i]])\\n        \\n        fn(candidates,[])\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237525,
                "title": "python-simple-bactracking-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        ans = []\\n        def helper(candidates, target, t):\\n            if not target:\\n                ans.append(t)\\n                return\\n            for i, num in enumerate(candidates):\\n                if target >= num:\\n                    helper(candidates[i:], target - num, t + [num])\\n                else: break\\n        helper(candidates, target, [])\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        ans = []\\n        def helper(candidates, target, t):\\n            if not target:\\n                ans.append(t)\\n                return\\n            for i, num in enumerate(candidates):\\n                if target >= num:\\n                    helper(candidates[i:], target - num, t + [num])\\n                else: break\\n        helper(candidates, target, [])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16657,
                "title": "my-easy-understanding-dp-solution-c",
                "content": "Hi, here is my dp solution.  The idea is pretty similar with the dp solution of subset. :)\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        int size = candidates.size();\\n        if (size == 0) return result;\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>());\\n        dp[0].push_back(vector<int>());\\n        \\n        for (int i = 1; i <= target; ++i) {\\n            for (int j = 0; j < size && candidates[j] <= i; ++j) {\\n                for (int k = 0; k < dp[i - candidates[j]].size(); ++k) {\\n                    vector<int> temp = dp[i - candidates[j]][k];\\n                    if (temp.size() && (temp[temp.size() - 1] > candidates[j])) continue;\\n                    temp.push_back(candidates[j]);\\n                    dp[i].push_back(temp);\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Hi, here is my dp solution.  The idea is pretty similar with the dp solution of subset. :)\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        int size = candidates.size();\\n        if (size == 0) return result;\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>());\\n        dp[0].push_back(vector<int>());\\n        \\n        for (int i = 1; i <= target; ++i) {\\n            for (int j = 0; j < size && candidates[j] <= i; ++j) {\\n                for (int k = 0; k < dp[i - candidates[j]].size(); ++k) {\\n                    vector<int> temp = dp[i - candidates[j]][k];\\n                    if (temp.size() && (temp[temp.size() - 1] > candidates[j])) continue;\\n                    temp.push_back(candidates[j]);\\n                    dp[i].push_back(temp);\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16758,
                "title": "javascript-solution",
                "content": "    function combinationSum(candidates, target) {\\n      candidates.sort((a, b) => a - b);\\n    \\n      var length = candidates.length;\\n      var res = [];\\n      search(0, [], target);\\n      return res;\\n    \\n      function search(idx, prefix, target) {\\n        if (target === 0) res.push(prefix.slice());\\n        if (idx === length) return;\\n        if (target <= 0) return;\\n    \\n        prefix.push(candidates[idx]);\\n        search(idx, prefix, target - candidates[idx]);\\n        prefix.pop();\\n        search(idx + 1, prefix, target);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function combinationSum(candidates, target) {\\n      candidates.sort((a, b) => a - b);\\n    \\n      var length = candidates.length;\\n      var res = [];\\n      search(0, [], target);\\n      return res;\\n    \\n      function search(idx, prefix, target) {\\n        if (target === 0) res.push(prefix.slice());\\n        if (idx === length) return;\\n        if (target <= 0) return;\\n    \\n        prefix.push(candidates[idx]);\\n        search(idx, prefix, target - candidates[idx]);\\n        prefix.pop();\\n        search(idx + 1, prefix, target);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 16829,
                "title": "a-recursive-yet-efficient-java-solution-with-explanation",
                "content": "The problem is a bit like N-queen problem, which is to say that we just need to enumerate all the possible solution recursively to get the final result. \\n\\nFirst of all, we need to sort the array, to ensure the combination to be unique and also the numbers in the combination to be listed in a non-descending order. \\n\\nThen, we define a recursive function with the signature as:  \\n\\n    combinationSum(int [] candidates, LinkedList vector, int start, int target)\\n\\nwhere `\\u201ccandidates\\u201d` is the list that we could take numbers from, `\\u201cvector\\u201d` is the list of combination that we have accumulated so far, `\\u201cstart\\u201d` is the starting point at which we could take numbers from forwards (no backwards), and `\\u201ctarget\\u201d` is the rest sum that we need to achieve.  \\n\\nAs a recursive function, the bottom cases for the combinationSum() are: \\n\\n1). The value of the `\\u201cstart\\u201d element` is equal to the `\\u201ctarget\\u201d`, we then find a combination, so just add the `\\u201cstart\\u201d element` to the `\\u201cvector\\u201d` and output the result. \\n\\n2). The value of the `\\u201cstart\\u201d element` is greater than the `\\u201ctarget\\u201d`, then it is impossible to find the combination onwards, because the `\\u201ccandidates\\u201d` list is sorted and all the following elements would be greater than the `\\u201ctarget\\u201d` as well. \\n\\n*Given the above recursive function, we could solve the problem by calling the function for each candidate starting from the start point. \\nFor each candidates, we first try to add the candidate into the `\\u201cvector\\u201d`, and then again starting from this candidate, we call the `combinationSum()` function to obtain the result for the new `\\u201ctarget\\u201d` afterwards.* \\n \\nHere is the code. \\n\\n\\n\\tprivate List<List<Integer>> res = new LinkedList<List<Integer>>();\\n\\t\\n\\tprivate void combinationSum(int [] candidates, LinkedList<Integer> vec,\\n\\t\\t\\t\\t\\t\\t\\t\\tint start, int target){\\n\\t\\t\\n\\t\\tfor(int i=start; i<candidates.length; ++i){\\n\\t\\t\\tif(candidates[i] < target){\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\n\\t\\t\\t\\t// Try a new combination, one could repeat itself again, so start from \"i\", instead of \"i+1\" \\n\\t\\t\\t\\tcombinationSum(candidates, newVec, i, target-candidates[i]);\\t\\t\\t\\t\\n\\t\\t\\t}else if(candidates[i] == target){\\n\\n\\t\\t\\t\\t// Found a combination\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\t\\t\\t\\tres.add(newVec);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// candidates[i] > target, no need to continue\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\tArrays.sort(candidates);\\n    \\tLinkedList<Integer> vec = new LinkedList<Integer>();\\n    \\tthis.combinationSum(candidates, vec, 0, target);\\n    \\treturn res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "The problem is a bit like N-queen problem, which is to say that we just need to enumerate all the possible solution recursively to get the final result. \\n\\nFirst of all, we need to sort the array, to ensure the combination to be unique and also the numbers in the combination to be listed in a non-descending order. \\n\\nThen, we define a recursive function with the signature as:  \\n\\n    combinationSum(int [] candidates, LinkedList vector, int start, int target)\\n\\nwhere `\\u201ccandidates\\u201d` is the list that we could take numbers from, `\\u201cvector\\u201d` is the list of combination that we have accumulated so far, `\\u201cstart\\u201d` is the starting point at which we could take numbers from forwards (no backwards), and `\\u201ctarget\\u201d` is the rest sum that we need to achieve.  \\n\\nAs a recursive function, the bottom cases for the combinationSum() are: \\n\\n1). The value of the `\\u201cstart\\u201d element` is equal to the `\\u201ctarget\\u201d`, we then find a combination, so just add the `\\u201cstart\\u201d element` to the `\\u201cvector\\u201d` and output the result. \\n\\n2). The value of the `\\u201cstart\\u201d element` is greater than the `\\u201ctarget\\u201d`, then it is impossible to find the combination onwards, because the `\\u201ccandidates\\u201d` list is sorted and all the following elements would be greater than the `\\u201ctarget\\u201d` as well. \\n\\n*Given the above recursive function, we could solve the problem by calling the function for each candidate starting from the start point. \\nFor each candidates, we first try to add the candidate into the `\\u201cvector\\u201d`, and then again starting from this candidate, we call the `combinationSum()` function to obtain the result for the new `\\u201ctarget\\u201d` afterwards.* \\n \\nHere is the code. \\n\\n\\n\\tprivate List<List<Integer>> res = new LinkedList<List<Integer>>();\\n\\t\\n\\tprivate void combinationSum(int [] candidates, LinkedList<Integer> vec,\\n\\t\\t\\t\\t\\t\\t\\t\\tint start, int target){\\n\\t\\t\\n\\t\\tfor(int i=start; i<candidates.length; ++i){\\n\\t\\t\\tif(candidates[i] < target){\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\n\\t\\t\\t\\t// Try a new combination, one could repeat itself again, so start from \"i\", instead of \"i+1\" \\n\\t\\t\\t\\tcombinationSum(candidates, newVec, i, target-candidates[i]);\\t\\t\\t\\t\\n\\t\\t\\t}else if(candidates[i] == target){\\n\\n\\t\\t\\t\\t// Found a combination\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\t\\t\\t\\tres.add(newVec);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// candidates[i] > target, no need to continue\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\tArrays.sort(candidates);\\n    \\tLinkedList<Integer> vec = new LinkedList<Integer>();\\n    \\tthis.combinationSum(candidates, vec, 0, target);\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16825,
                "title": "recursive-java-solution",
                "content": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort the array, so the result could be increasing order\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        for(int i = 0; i < candidates.length; i++){\\n            // target smaller than current number, jump the current and rest of numbers\\n            if(target < candidates[i]) continue;\\n\\n            // if target is equal to the current number,add it to a new list and add that list to result          \\n            else if(target == candidates[i]){\\n                List<Integer> set = new ArrayList<Integer>();\\n                set.add(candidates[i]);\\n                result.add(set);\\n            }\\n\\n            // if the target is smaller the current number,call this function again\\n            else{\\n                // use modified array which not includes those numbers that before i to eliminate the duplicates\\n                int[] array = Arrays.copyOfRange(candidates,i,candidates.length);\\n\\n                // call this function. pass the new target and modified array.\\n                List<List<Integer>> temp = combinationSum(array, target - candidates[i]);\\n\\n                // for each list in the return list, add current number in the front of list, then add it to result\\n                // attention that if return list is null, this enhanced for loop will not perform. \\n                for(List<Integer> list:temp){\\n                    list.add(0,candidates[i]);\\n                    result.add(list);\\n                } \\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\nThey key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.",
                "solutionTags": [],
                "code": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort the array, so the result could be increasing order\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        for(int i = 0; i < candidates.length; i++){\\n            // target smaller than current number, jump the current and rest of numbers\\n            if(target < candidates[i]) continue;\\n\\n            // if target is equal to the current number,add it to a new list and add that list to result          \\n            else if(target == candidates[i]){\\n                List<Integer> set = new ArrayList<Integer>();\\n                set.add(candidates[i]);\\n                result.add(set);\\n            }\\n\\n            // if the target is smaller the current number,call this function again\\n            else{\\n                // use modified array which not includes those numbers that before i to eliminate the duplicates\\n                int[] array = Arrays.copyOfRange(candidates,i,candidates.length);\\n\\n                // call this function. pass the new target and modified array.\\n                List<List<Integer>> temp = combinationSum(array, target - candidates[i]);\\n\\n                // for each list in the return list, add current number in the front of list, then add it to result\\n                // attention that if return list is null, this enhanced for loop will not perform. \\n                for(List<Integer> list:temp){\\n                    list.add(0,candidates[i]);\\n                    result.add(list);\\n                } \\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\nThey key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.",
                "codeTag": "Unknown"
            },
            {
                "id": 2774330,
                "title": "combinations-sum-1-java-solution-easy-recursive-approach",
                "content": "//Using Subset Pattern To Generate Combinations i.e. Include or Not Include\\n//but this time the change is made when we include the element ,we are not going to increase our index\\n//instead of increasing index we have given that we can use one element as many time as we want that\\'s why we are \\n//not going to increment index\\n\\n\\n![image](https://assets.leetcode.com/users/images/fd71fb68-bc08-4678-806c-66163da7721e_1667491488.5400312.jpeg)\\n\\n//Three Base cases\\n1. if(sum==target)  --> add subset ans into final ans arraylist\\n2. if(sum>target) --> return\\n3. if(index > arr.length) --> return\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(0,candidates,target,0,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\nT.C :- O(2^target  *  k)  // k is the average length/size of subset \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(0,candidates,target,0,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\nT.C :- O(2^target  *  k)  // k is the average length/size of subset \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717214,
                "title": "easy-backtracking-solution-with-explanation-and-complexity-analysis",
                "content": "## General Algorithm \\nThe comination sum problems are those typical problems which can be solve with basic understanding of `backtracking` and `recursion`.\\nThese problems generally require 2 recursive calls which are as follows -\\n- you take `i th indexed` number form array and perform some operation (in this case, adding it to current-sum and inserting it in the list)\\n- you don\\'t take that number and performing operations that counter the operations in 1st recursive call (in this case, subtracting the number from current-sum and removing it from the list)\\n\\nIn this problem\\'s case, you take ith indexed number and add it to `current-sum` followed by inserting it in the `probable-ans lis`t. Now, if taking that number doesn\\'t work then anyways you subtract that number from `current sum` to bring it to it normal state and remove that number from `probable-ans-list`.\\n\\n**Base-case scenarios :**\\n- if `i` is greater that size of array; i.e. , all the elements of the array are visited.\\n- if `current-sum` is greater that target sum; because anyways, there is no point in finding sum with other numbers if current sum exceeds the target\\n\\n## Solution\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> wrapper = new ArrayList<>();\\n        helper(wrapper, candidates, candidates.length, target, 0, 0, new ArrayList<>());\\n        return wrapper;\\n    }\\n    \\n    private void helper(List<List<Integer>> wrapper, int[] arr, int n, int target, int currSum, int i, List<Integer> probableAnsList) {\\n        if (i >= n) { \\n\\t\\t// Base-case 1\\n            if (currSum == target)\\n                wrapper.add(new ArrayList<>(probableAnsList)); \\n\\t\\t\\t\\t/* cloning arraylist (adding new Arraylist) because java references same object here which we are in future going to mutate and if the cloned list is not added then mutated changes will be seen here as well. */\\n            return;\\n        }\\n        if (currSum > target) // base-case 2\\n            return;\\n        \\n\\t\\t// Including the i-th indexed number\\n        currSum += arr[i];\\n        probableAnsList.add(arr[i]);\\n        helper(wrapper, arr, n, target, currSum, i, probableAnsList);\\n\\t\\t\\n\\t\\t// excluding the i-th indexed number\\n        currSum -= arr[i];\\n        probableAnsList.remove(probableAnsList.size() - 1);\\n        helper(wrapper, arr, n, target, currSum, i + 1, probableAnsList);\\n        \\n        return;\\n    }\\n    \\n}\\n```\\n\\n## Complexity analysis\\n\\n- Time Complexity = **O(2 ^ target) * k**\\n\\t- Reason: \\n\\t\\t- `2 ^ target` because at each step we are making 2 recursive calls. \\n\\t\\tFor ex. if arr[] = {1,2,3} and target is 3; then one of the ansers will be [1,1,1] and for \"every 1\" we are either taking it or ignorig it.\\n\\t\\t- `* k` because once we get target == currSum, we are inserting the elements of `probableAnsList` in `wrapper` which is `O(size of probableAnsList)`\\n\\n- Space Complexity = O(number of elements in wrapper)\\n\\n\\uD83C\\uDF1F`Upvote` if you liked this solution \\uD83C\\uDF1F",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> wrapper = new ArrayList<>();\\n        helper(wrapper, candidates, candidates.length, target, 0, 0, new ArrayList<>());\\n        return wrapper;\\n    }\\n    \\n    private void helper(List<List<Integer>> wrapper, int[] arr, int n, int target, int currSum, int i, List<Integer> probableAnsList) {\\n        if (i >= n) { \\n\\t\\t// Base-case 1\\n            if (currSum == target)\\n                wrapper.add(new ArrayList<>(probableAnsList)); \\n\\t\\t\\t\\t/* cloning arraylist (adding new Arraylist) because java references same object here which we are in future going to mutate and if the cloned list is not added then mutated changes will be seen here as well. */\\n            return;\\n        }\\n        if (currSum > target) // base-case 2\\n            return;\\n        \\n\\t\\t// Including the i-th indexed number\\n        currSum += arr[i];\\n        probableAnsList.add(arr[i]);\\n        helper(wrapper, arr, n, target, currSum, i, probableAnsList);\\n\\t\\t\\n\\t\\t// excluding the i-th indexed number\\n        currSum -= arr[i];\\n        probableAnsList.remove(probableAnsList.size() - 1);\\n        helper(wrapper, arr, n, target, currSum, i + 1, probableAnsList);\\n        \\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370502,
                "title": "python-recursion-detailed-explanation",
                "content": "1. Take two empty array to hold the result.\\n2.  `ds` stack for picking and removing element while moving along recursion. \\n3.  `res` to store final result and return. \\n4.  Call a recursive function starting with index 0. \\n5.  For each call, we have two option, either to pick the element (if it is less than the **current target** value) or to not pick (greater than current target value). \\n6.  By Current target, I mean if we have picked up the previous element, our target becomes  `target - element at current index i` else our `target` remains the same. \\n7.  If we pick the element, the current index `i` will be incremented by 1 else it will remain same.\\n8.  Similarly if we have processed the recursive call where we see that the element we picked is wrong, for example, if we picked 3 two\\'s `[2, 2, 2]` in stack then while returning back to its parent call, we should remove the element which is not required. \\n9.  The base case for the recursion will be when we have reached to the last index of the array and if we found the current target is `0`, it means we have found one possible combination. \\n10.  Recursively call above steps and wohooo, we have reached the solution. \\n\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def combination(i, target, ds, res):\\n            if i == len(candidates):\\n                if target == 0 and ds not in res:\\n                    res.append(ds.copy())\\n                return\\n            if candidates[i] <= target:\\n                ds.append(candidates[i])\\n                combination(i, target - candidates[i], ds, res)\\n                ds.pop()\\n            combination(i + 1, target, ds, res)\\n            return res\\n        return combination(0, target, ds = [], res = [])\\n```\\n\\n**Note** - I have used `ds.copy()` to avoid overwriting of array due to reference. You can refer to Python Deep Copy and Shallow Copy concept for more info\\n\\nIf you like the explanation and solution, don\\'t hesitate to upvote. Cheers !!",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def combination(i, target, ds, res):\\n            if i == len(candidates):\\n                if target == 0 and ds not in res:\\n                    res.append(ds.copy())\\n                return\\n            if candidates[i] <= target:\\n                ds.append(candidates[i])\\n                combination(i, target - candidates[i], ds, res)\\n                ds.pop()\\n            combination(i + 1, target, ds, res)\\n            return res\\n        return combination(0, target, ds = [], res = [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276784,
                "title": "python-backtracking-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:  # Time: O(2^len(Tree)) and Space: O(n)\\n        res = []\\n\\n        def dfs(i, cur, total):\\n            if total == target:  # when the conditions are met we will copy a copy of current list into the result list\\n                res.append(cur.copy())\\n                return\\n            \\n            if i >= len(candidates) or total > target: \\n                return\\n            \\n            cur.append(candidates[i])  # x=1 we choose to include the current index\\n            dfs(i, cur, total + candidates[i])\\n            cur.pop()  # x=0 we choose to ignore the current index\\n            dfs(i + 1, cur, total)\\n\\n        dfs(0, [], 0)\\n\\t\\t\\n        return res\\n```\\nFor example,\\nLet **candidates = [2, 3, 5]** & **target = 8**\\n1. res = [ ]\\n* def dfs(0, [], 0):\\nif 0 == 8 = False\\nif 0 >= 3 or 0 > 8 = False or False = False\\ncur = [2] --> \\n* dfs(0, [2], 0 + 2):\\nif 2 == 8 = False -> if 0 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 2] --> \\n* dfs(0, [2, 2], 2 + 2):\\nif 4 == 8 = False -> if 0 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 2] --> \\n* dfs(0, [2, 2, 2], 4 + 2):\\nif 6 == 8 = False -> if 0 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 2] --> \\n* dfs(0, [2, 2, 2, 2], 6 + 2):\\nif 8 == 8 = True: res = [ [2, 2, 2, 2] ] --> return\\n--> dfs(1, [2, 2, 2, 2], 6) -> cur = [2, 2, 2] --> \\n* dfs(1, [2, 2, 2], 6):\\nif 6 == 8 = False -> if 1 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 3] --> \\n* dfs(1, [2, 2, 2, 3], 9):\\nif 9 == 8 = False -> if 1 >= 3 or 9 > 8 = False or True = True: return\\n--> dfs(1, [2, 2, 2, 3], 9) -> cur = [2, 2, 2] --> \\n* dfs(2, [2, 2, 2], 6):\\nif 6 == 8 = False -> if 2 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 5] --> \\n* dfs(2, [2, 2, 2, 5], 11):\\nif 11 == 8 = False -> if 2 >= 3 or 11 > 8 = False or True = True: return\\n--> dfs(2, [2, 2, 2, 3], 9) -> cur = [2, 2, 2] --> \\n* dfs(3, [2, 2, 2], 6) ->\\nif 6 == 8 = False -> if 3 >= 3 or 6 > 8 = True or False = True: return\\n--> dfs(3, [2, 2, 2], 6) -> dfs(2, [2, 2, 2], 6) -> dfs(1, [2, 2, 2], 6) -> dfs(0, [2, 2, 2], 6) -> cur = [2, 2]\\n* dfs(1, [2, 2], 4) ->\\nif 4 == 8 = False -> if 1 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 3] --> \\n* dfs(1, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 1 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 2, 3, 3] --> \\n* dfs(1, [2, 2, 3, 3], 10):\\nif 10 == 8 = False -> if 1 >= 3 or 10 > 8 = False or True = True: return \\n--> dfs(1, [2, 2, 3, 3], 10) --> cur = [2, 3, 3] -->\\n* dfs(2, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 2 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 2, 3, 5] --> \\n* dfs(2, [2, 2, 3, 5], 12):\\nif 12 == 8 = False -> if 2 >= 3 or 12 > 8 = False or True = True: return \\n--> dfs(1, [2, 2, 3, 5], 12) --> cur = [2, 3, 3] -->\\n* dfs(3, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 3 >= 3 or 7 > 8 = True or False = True: return \\n--> dfs(3, [2, 2, 3], 7) -> dfs(2, [2, 2, 3], 7) -> cur = [2, 2]\\n* dfs(2, [2, 2], 4):\\nif 4 == 8 = False -> if 2 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 5] --> \\n* dfs(2, [2, 2, 5], 9):\\nif 9 == 8 = False -> if 2 >= 3 or 9 > 8 = True or False = True: return\\n--> dfs(2, [2, 2, 5], 9) -> cur = [2, 2]\\n* dfs(3, [2, 2], 4):\\nif 4 == 8 = False -> if 3 >= 3 or 4 > 8 = True or False = True: return\\n--> dfs(2, [2, 2], 4) -> dfs(1, [2, 2], 4) -> dfs(0, [2, 2], 4) -> cur = [2] -->\\n* dfs(1, [2], 2):\\nif 2 == 8 = False -> if 1 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 3] --> \\n* dfs(1, [2, 3], 5):\\nif 5 == 8 = False -> if 1 >= 3 or 5 > 8 = False or False = False\\ncur = [2, 3, 3] --> \\n* dfs(1, [2, 3, 3], 8):\\nif 8 == 8 = True: res = [ [2, 3, 3] ] --> return\\n--> dfs(1, [2, 3, 3], 6) -> cur = [2, 3] --> \\n* dfs(2, [2, 3], 5):\\nif 5 == 8 = False -> if 2 >= 3 or 5 > 8 = False or False = False\\ncur = [2, 3, 5] --> \\n* dfs(2, [2, 3, 5], 10):\\nif 10 == 8 = False -> if 2 >= 3 or 10 > 8 = False or True = True: return \\n--> dfs(2, [2, 3, 5], 10) -> cur = [2, 3] --> \\n* dfs(3, [2, 3], 5):\\nif 5 == 8 = False -> if 3 >= 3 or 5 > 8 = True or False = True: return \\n--> dfs(2, [2, 3], 5) -> dfs(1, [2, 3], 5) -> cur = [2] --> \\n* dfs(2, [2], 2):\\nif 2 == 8 = False -> if 2 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 5] --> \\n* dfs(2, [2, 5], 7):\\nif 7 == 8 = False -> if 2 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 5, 5] --> \\n* dfs(2, [2, 5, 5], 12):\\nif 12 == 8 = False -> if 2 >= 3 or 12 > 8 = False or True = True: return \\n--> dfs(2, [2, 5, 5], 12) -> cur = [2, [2, 5], 7)\\n* dfs(3, [2, 5], 7):\\nif 7 == 8 = False -> if 3 >= 3 or 7 > 8 = True or False = True: return \\n--> dfs(2, [2, 5], 7) -> cur = [2]\\n* dfs(3, [2], 2):\\nif 2 == 8 = False -> if 3 >= 3 or 2 > 8 = True or False = True: return \\n--> dfs(2, [2], 5) -> dfs(1, [2], 5) -> dfs(0, [2], 5) -> cur [ ]\\n3. Similarly, continue with the 3 branch and 5 branch.\\n4. Return the result list.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:  # Time: O(2^len(Tree)) and Space: O(n)\\n        res = []\\n\\n        def dfs(i, cur, total):\\n            if total == target:  # when the conditions are met we will copy a copy of current list into the result list\\n                res.append(cur.copy())\\n                return\\n            \\n            if i >= len(candidates) or total > target: \\n                return\\n            \\n            cur.append(candidates[i])  # x=1 we choose to include the current index\\n            dfs(i, cur, total + candidates[i])\\n            cur.pop()  # x=0 we choose to ignore the current index\\n            dfs(i + 1, cur, total)\\n\\n        dfs(0, [], 0)\\n\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875252,
                "title": "combination-sum-c-backtracking-with-short-explanation",
                "content": "Apply backtracking. Add an element to the vector if it keeps the sum less than or equal to target. \\n\\nIf it any point our sum is equal to target, push this vector to our answer vector, else backtrack.\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>& ans, vector<int>& v, vector<int>& candidates, int target, int curr)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0) return;\\n        for(int i=curr;i<candidates.size();i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                v.push_back(candidates[i]);\\n                solve(ans,v,candidates,target-candidates[i],i);\\n                v.pop_back();\\n            }\\n            else break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(candidates.begin(),candidates.end());\\n        solve(ans,v,candidates,target,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>& ans, vector<int>& v, vector<int>& candidates, int target, int curr)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0) return;\\n        for(int i=curr;i<candidates.size();i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                v.push_back(candidates[i]);\\n                solve(ans,v,candidates,target-candidates[i],i);\\n                v.pop_back();\\n            }\\n            else break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(candidates.begin(),candidates.end());\\n        solve(ans,v,candidates,target,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843289,
                "title": "c-simple-and-easy-solution-with-backtracking-concept",
                "content": "Simple backtracking concept , if any problems please let me know in comment section.\\n\\nPoint to observe -> Recursion is used inside the loop(iteration).\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& candidates, int target,int index,vector<int> &v,vector<vector<int> > &ans){\\n        if(target<0)\\n            return;\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            v.push_back(candidates[i]);\\n            solve(candidates,target-candidates[i],i,v,ans);\\n            v.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> >ans;\\n        vector<int> v;\\n        int index=0;\\n        solve(candidates,target,index,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& candidates, int target,int index,vector<int> &v,vector<vector<int> > &ans){\\n        if(target<0)\\n            return;\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            v.push_back(candidates[i]);\\n            solve(candidates,target-candidates[i],i,v,ans);\\n            v.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> >ans;\\n        vector<int> v;\\n        int index=0;\\n        solve(candidates,target,index,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763691,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> v;\\n        vector<int> u;\\n         helper(candidates, target,0,v,u);\\n        return v;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target,int i,vector<vector<int>>& result, vector<int>& current)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return ;\\n        }\\n        if(i==candidates.size() || target<0)\\n            return;\\n        \\n        current.push_back(candidates[i]);\\n        helper(candidates,target-candidates[i],i,result,current);\\n        current.pop_back();\\n        helper(candidates,target,i+1,result,current);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> v;\\n        vector<int> u;\\n         helper(candidates, target,0,v,u);\\n        return v;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target,int i,vector<vector<int>>& result, vector<int>& current)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return ;\\n        }\\n        if(i==candidates.size() || target<0)\\n            return;\\n        \\n        current.push_back(candidates[i]);\\n        helper(candidates,target-candidates[i],i,result,current);\\n        current.pop_back();\\n        helper(candidates,target,i+1,result,current);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344320,
                "title": "python-easy-to-understand-solution-96-faster",
                "content": "\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        \\n        def backtrack ( currSum, currList, mainList ):\\n            \\n\\n            for i in range( len(mainList) ):\\n                \\n                # If we have found the target value then we don\\'t have to iterate in the loop any further\\n                # Optimization #2: Any sum we get after this will always be greater than or equal to the current sum. ( Since we initially sorted the list in Optimization #1  )\\n                if currSum + mainList[i] == target:\\n                    # Add the answer to the list\\n                    solution.append( currList + [mainList[i]] )\\n                    return\\n                \\n                # Since the current sum is already greater than target, no point iterating further. ( Optimization #2 )\\n                if currSum + mainList[i] > target:\\n                    return\\n                \\n                # current sum is still less than target, backtrack\\n                else:\\n                    # currSum = current sum from function parameter + current element\\n                    # currList = current list from function parameter + list(current element)\\n                    # mainList = mainList [ i ... len(candidates) ] ( slicing to avoid duplicates ) \\n                    backtrack( currSum + mainList[i], currList + [ mainList[i] ], mainList[i:] )\\n            \\n        \\n\\t\\t\\n        solution = []\\n        \\n\\t\\t# Call the backtrack function\\n\\t\\t\\t# Optimization #1: sorting the list \\n\\t\\tbacktrack( 0, [], sorted( candidates ) )\\n        \\n        return solution\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        \\n        def backtrack ( currSum, currList, mainList ):\\n            \\n\\n            for i in range( len(mainList) ):\\n                \\n                # If we have found the target value then we don\\'t have to iterate in the loop any further\\n                # Optimization #2: Any sum we get after this will always be greater than or equal to the current sum. ( Since we initially sorted the list in Optimization #1  )\\n                if currSum + mainList[i] == target:\\n                    # Add the answer to the list\\n                    solution.append( currList + [mainList[i]] )\\n                    return\\n                \\n                # Since the current sum is already greater than target, no point iterating further. ( Optimization #2 )\\n                if currSum + mainList[i] > target:\\n                    return\\n                \\n                # current sum is still less than target, backtrack\\n                else:\\n                    # currSum = current sum from function parameter + current element\\n                    # currList = current list from function parameter + list(current element)\\n                    # mainList = mainList [ i ... len(candidates) ] ( slicing to avoid duplicates ) \\n                    backtrack( currSum + mainList[i], currList + [ mainList[i] ], mainList[i:] )\\n            \\n        \\n\\t\\t\\n        solution = []\\n        \\n\\t\\t# Call the backtrack function\\n\\t\\t\\t# Optimization #1: sorting the list \\n\\t\\tbacktrack( 0, [], sorted( candidates ) )\\n        \\n        return solution\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310038,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 203331,
                "title": "ruby-backtracking-with-diagram",
                "content": "```ruby\\n# @param {Integer[]} candidates\\n# @param {Integer} target\\n# @return {Integer[][]}\\ndef combination_sum(candidates, target)\\n    return [] if !candidates || candidates.empty?\\n    bt(candidates, target)\\nend\\n\\ndef bt(candidates, target, idx = 0, path = [], result = [], total = 0)\\n    if total == target\\n        result.push(path)\\n        return\\n    end\\n\\n    idx.upto(candidates.size - 1) do |i|\\n        next if total + candidates[i] > target\\n        bt(candidates, target, i, path + [candidates[i]], result, total + candidates[i])\\n    end\\n\\n    result\\nend\\n\\n# 39. Combination Sum\\n# https://leetcode.com/problems/combination-sum/description/\\n\\n# Similar problem listed in articles\\n# https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\n# https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c++-solution-use-backtracking-easy-understand.\\n\\n# Points to remember\\n# 1. No duplicates combinations in result               (So we should consider each unique combination only once)\\n# 2. Combination can contain a number any no. of times  (This means combination with repitition)\\n# 3. All numbers are +ve                                (Allows for pruning totals > target)\\n\\n# Approach 1: Backtracking\\n\\n# Example: candidates = [2,3,6,7], target = 7\\n# dfs call with idx: 0 path: [] result: [] total: 0\\n# check with next candidate and prune i: 0 | candidate: 2\\n#     dfs call with idx: 0 path: [2] result: [] total: 2\\n#     check with next candidate and prune i: 0 | candidate: 2\\n#         dfs call with idx: 0 path: [2, 2] result: [] total: 4\\n#         check with next candidate and prune i: 0 | candidate: 2\\n#             dfs call with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#             check with next candidate and prune i: 0 | candidate: 2\\n#             check with next candidate and prune i: 1 | candidate: 3\\n#             check with next candidate and prune i: 2 | candidate: 6\\n#             check with next candidate and prune i: 3 | candidate: 7\\n#             dfs retrn with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#             dfs call with idx: 1 path: [2, 2, 3] result: [] total: 7\\n#             dfs retrn with idx: 1 path: [2, 2, 3] result: [[2, 2, 3]] total: 7\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 0 path: [2, 2] result: [[2, 2, 3]] total: 4\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 0 path: [2] result: [[2, 2, 3]] total: 2\\n# check with next candidate and prune i: 1 | candidate: 3\\n#     dfs call with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n# check with next candidate and prune i: 2 | candidate: 6\\n#     dfs call with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n# check with next candidate and prune i: 3 | candidate: 7\\n#     dfs call with idx: 3 path: [7] result: [[2, 2, 3]] total: 7\\n#     dfs retrn with idx: 3 path: [7] result: [[2, 2, 3], [7]] total: 7\\n# dfs retrn with idx: 0 path: [] result: [[2, 2, 3], [7]] total: 0\\n# Refer to the diagram for recursion tree\\n```\\n![image](https://assets.leetcode.com/users/vkommi2/image_1544343701.png)\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer[]} candidates\\n# @param {Integer} target\\n# @return {Integer[][]}\\ndef combination_sum(candidates, target)\\n    return [] if !candidates || candidates.empty?\\n    bt(candidates, target)\\nend\\n\\ndef bt(candidates, target, idx = 0, path = [], result = [], total = 0)\\n    if total == target\\n        result.push(path)\\n        return\\n    end\\n\\n    idx.upto(candidates.size - 1) do |i|\\n        next if total + candidates[i] > target\\n        bt(candidates, target, i, path + [candidates[i]], result, total + candidates[i])\\n    end\\n\\n    result\\nend\\n\\n# 39. Combination Sum\\n# https://leetcode.com/problems/combination-sum/description/\\n\\n# Similar problem listed in articles\\n# https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\n# https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c++-solution-use-backtracking-easy-understand.\\n\\n# Points to remember\\n# 1. No duplicates combinations in result               (So we should consider each unique combination only once)\\n# 2. Combination can contain a number any no. of times  (This means combination with repitition)\\n# 3. All numbers are +ve                                (Allows for pruning totals > target)\\n\\n# Approach 1: Backtracking\\n\\n# Example: candidates = [2,3,6,7], target = 7\\n# dfs call with idx: 0 path: [] result: [] total: 0\\n# check with next candidate and prune i: 0 | candidate: 2\\n#     dfs call with idx: 0 path: [2] result: [] total: 2\\n#     check with next candidate and prune i: 0 | candidate: 2\\n#         dfs call with idx: 0 path: [2, 2] result: [] total: 4\\n#         check with next candidate and prune i: 0 | candidate: 2\\n#             dfs call with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#             check with next candidate and prune i: 0 | candidate: 2\\n#             check with next candidate and prune i: 1 | candidate: 3\\n#             check with next candidate and prune i: 2 | candidate: 6\\n#             check with next candidate and prune i: 3 | candidate: 7\\n#             dfs retrn with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#             dfs call with idx: 1 path: [2, 2, 3] result: [] total: 7\\n#             dfs retrn with idx: 1 path: [2, 2, 3] result: [[2, 2, 3]] total: 7\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 0 path: [2, 2] result: [[2, 2, 3]] total: 4\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 0 path: [2] result: [[2, 2, 3]] total: 2\\n# check with next candidate and prune i: 1 | candidate: 3\\n#     dfs call with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n# check with next candidate and prune i: 2 | candidate: 6\\n#     dfs call with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n# check with next candidate and prune i: 3 | candidate: 7\\n#     dfs call with idx: 3 path: [7] result: [[2, 2, 3]] total: 7\\n#     dfs retrn with idx: 3 path: [7] result: [[2, 2, 3], [7]] total: 7\\n# dfs retrn with idx: 0 path: [] result: [[2, 2, 3], [7]] total: 0\\n# Refer to the diagram for recursion tree\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 16504,
                "title": "easy-to-understand-96-performance-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            return combinationSum(candidates, target, 0);\\n        }\\n        \\n        public List<List<Integer>> combinationSum(int[] candidates, int target, int start) {\\n            \\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            Arrays.sort(candidates);\\n            for (int i = start; i < candidates.length; i++) {\\n                if (candidates[i] <target) {\\n                    for (List<Integer> ar : combinationSum(candidates, target - candidates[i], i)) {\\n                        ar.add(0, candidates[i]);\\n                        res.add(ar);\\n                    }\\n                } else if (candidates[i] == target) {\\n                    List<Integer> lst = new ArrayList<>();\\n                    lst.add(candidates[i]);\\n                    res.add(lst);\\n                } else\\n                    break;\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            return combinationSum(candidates, target, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3521721,
                "title": "detailed-explanation-with-recursion-tree-backtracking-c-tc-o-k-2-t-sc-o-k-x",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every element we come across in the given array, we are faced with the choice of either picking it to subtract from the target, or not picking it. \\n\\nUsing this fact, we can traverse the given array and make recursive calls to the function for each element in the array, reducing the target by the value picked till either the index is equal to size of the array or the value of target reaches less than or equal to zero.\\n\\nIf target value reaches zero, it means that the combination of elements picked will add up to the target and is a valid solution.\\n\\n**NOTE:** Since this problem allows us to pick multiple instances of the same element, we will pass the current index of the array (instead of the next one) when recursively calling the function as we can choose to pick it again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPass 0, `target`, `candidates`, `temp` and `sol` to the function `genUniqueCombos` that will generate unique combinations of the numbers adding up to the target. The parameters passed represent the current index, target to be attained, given array, array holding possible combination and array holding all possible combinations respectively.\\n\\nIf the index we are currently at is less than or equal to the target, we can think about adding it to (one of possible) solution. Push it into `temp` and recursively call the function, only this time with target reduced by the element added.\\n\\nOnce function call is returned, remove the element added to `temp`.\\n\\nIf index we are currently at is greater than the target, we cannot add it to the solution. Simply recursively call the function with the next index.\\n\\nWe can set the base case as the current index becoming equal to the size of the array, or the target becoming less than or equal to zero. If the target is equal to zero, we can surely say that it is one of the possible solutions and can push it into `sol`.\\n\\n**PS:** Recursion tree for `candidates` = [1, 2, 3] and `target` = 3.\\n\\n![WhatsApp Image 2023-05-14 at 8.23.53 AM.jpeg](https://assets.leetcode.com/users/images/2c69be16-4196-4f42-9865-c93fbb4c1fb7_1684032984.0102649.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(k*2^t)$$, where k is the number of possible solutions and t is the target to be attained.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k*x)$$, where k is number of possible solutions and x is the size of the longest solution.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void genUniqueCombos(int idx, int target, vector<int>& candidates, vector<int>& temp, vector<vector<int>>& sol){\\n        if(idx==candidates.size()||target<=0){\\n            if(!target) sol.push_back(temp);\\n            return;\\n        }\\n\\n        if(candidates[idx]<=target){\\n            temp.push_back(candidates[idx]);\\n            genUniqueCombos(idx, target-candidates[idx], candidates, temp, sol);\\n            temp.pop_back();\\n        }\\n        genUniqueCombos(idx+1, target, candidates, temp, sol);\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        genUniqueCombos(0, target, candidates, temp, sol);\\n        return sol;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void genUniqueCombos(int idx, int target, vector<int>& candidates, vector<int>& temp, vector<vector<int>>& sol){\\n        if(idx==candidates.size()||target<=0){\\n            if(!target) sol.push_back(temp);\\n            return;\\n        }\\n\\n        if(candidates[idx]<=target){\\n            temp.push_back(candidates[idx]);\\n            genUniqueCombos(idx, target-candidates[idx], candidates, temp, sol);\\n            temp.pop_back();\\n        }\\n        genUniqueCombos(idx+1, target, candidates, temp, sol);\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        genUniqueCombos(0, target, candidates, temp, sol);\\n        return sol;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629817,
                "title": "java-solution-easy-approach",
                "content": "```\\n\\n```****JAVA Solution Easy Approach****\\npublic List<List<Integer>> combinationSum(int[] candidates, int target)\\n{\\n        List<List<Integer>> al = new ArrayList<>();\\n\\t\\t//taking an List of List which will traverse via Call by reference through recursion\\n        Combo(candidates, target, \"\", target, al);           // passing list of List in recursion logic\\n        return al;                                                             // returning the list after Recursion ends\\n    }\\nstatic void Combo(int a[], int N, String ans, int max, List<List<Integer>> al)\\n    {\\n        if(N==0) //base Condition when our targets equals to 0\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n            StringTokenizer st = new StringTokenizer(ans.trim()); // Breaking the string ans into integers and adding them into list,( a new List will be created for each case when base condition get hit)\\n            int n = st.countTokens();\\n            for(int j=0 ; j<=n-1; j++)\\n            {\\n                cl.add(Integer.parseInt(st.nextToken()));\\n            }\\n            al.add(cl); //adding our list to--> list of list\\n        }\\n        else\\n        {\\n            for(int i=0; i<a.length; i++)\\n            {\\n                if(N-a[i]>=0&& a[i]<=max) //taking max variable for stoping the duplication of answer \\n                {\\n                Combo(a, N-a[i], ans+a[i]+\" \", a[i], al); // passing max as last a[i] which we included in our ans\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777309,
                "title": "python-3-dfs-recursion-solution-and-explanation",
                "content": "\\n# \\uD83C\\uDF1F[Python 3] DFS Recursion Solution and Explanation\\n\\n## 1\\uFE0F\\u20E3 Main Idea:\\n* Step 1. Sort candidates\\n* Step 2. Recurssive call our helper function\\n\\n### Helper Function\\n* We take currentList as one of our function\\'s input because every time we try to add in a new number from candidates\\n* Once we append in new number, we recurssive call helper function and this time make our target = target - num which we picked\\n* Also we use startIdx to prevent counting duplicated outputs\\n\\n## Complexity Analysis\\n* Time: O(N^T/M) : Let N be length of candidates, T be target value, M be minimum value along candidates \\n* Space: O(N^T/M : Let N be length of candidates, T be target value, M be minimum value along candidates\\n\\n> Because every time we may at worst expand N-way tree from certain point. But how do we know the tree\\'s **height**?\\n> For example: We have a smallest value 1, and target value 100. So at worst we will have a maximum height which is [1,1,1,...,1] total **100** length. So we can consider **T/M**\\n\\n## Code\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res = []\\n        self.calHelper([], 0, candidates, target, res)\\n        return res\\n        \\n    def calHelper(self, currentList, startIdx, candidates, target, res):\\n        # Once target == 0 means we found a vaild list\\n        if target == 0:\\n            res.append(currentList)\\n            return\\n        \\n        # Start from startIdx means we can use duplicate nums\\n        for i in range(startIdx, len(candidates)):\\n            num = candidates[i]\\n            if num <= target:\\n                self.calHelper(currentList + [num], i, candidates, target - num, res)\\n            # Since candidates are sorted, if we cant find a vaild num <= target we break\\n            else:\\n                break\\n```\\n\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res = []\\n        self.calHelper([], 0, candidates, target, res)\\n        return res\\n        \\n    def calHelper(self, currentList, startIdx, candidates, target, res):\\n        # Once target == 0 means we found a vaild list\\n        if target == 0:\\n            res.append(currentList)\\n            return\\n        \\n        # Start from startIdx means we can use duplicate nums\\n        for i in range(startIdx, len(candidates)):\\n            num = candidates[i]\\n            if num <= target:\\n                self.calHelper(currentList + [num], i, candidates, target - num, res)\\n            # Since candidates are sorted, if we cant find a vaild num <= target we break\\n            else:\\n                break\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777073,
                "title": "c-clean-easy-backtracking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid findcombination(int ind,int target,vector<int> &arr,vector<vector<int>>&ans,vector<int>&ds){\\n\\t\\t\\tif(ind==arr.size()){\\n\\t\\t\\t\\tif(target==0){\\n\\t\\t\\t\\t\\tans.push_back(ds);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(arr[ind]<=target){\\n\\t\\t\\t\\tds.push_back(arr[ind]);\\n\\t\\t\\t\\tfindcombination(ind,target-arr[ind],arr,ans,ds);\\n\\t\\t\\t\\tds.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tfindcombination(ind+1,target,arr,ans,ds);\\n\\t\\t}\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tvector<int>ds;\\n\\t\\t\\tfindcombination(0,target,candidates,ans,ds);\\n\\t\\t\\treturn ans; \\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid findcombination(int ind,int target,vector<int> &arr,vector<vector<int>>&ans,vector<int>&ds){\\n\\t\\t\\tif(ind==arr.size()){\\n\\t\\t\\t\\tif(target==0){\\n\\t\\t\\t\\t\\tans.push_back(ds);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1777025,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\nfunc combinationSum(candidates []int, target int) [][]int {\\n\\tvar ans [][]int\\n\\n\\tif len(candidates) == 0 {\\n\\t\\treturn ans\\n\\t}\\n\\n\\tbt(&ans, make([]int, 0), candidates, 0, target)\\n\\n\\treturn ans\\n}\\n\\nfunc bt(ans *[][]int, tmp, nums []int, idx, tgt int) {\\n\\tif tgt < 0 || idx > len(nums) {\\n\\t\\treturn\\n\\t}\\n\\n\\tif tgt == 0 {\\n\\t\\tcpyTmp := make([]int, len(tmp))\\n\\t\\tcopy(cpyTmp, tmp)\\n\\t\\t*ans = append(*ans, cpyTmp)\\n\\t}\\n\\n\\tfor i := idx; i < len(nums); i++ {\\n\\t\\ttmp = append(tmp, nums[i])\\n\\t\\tbt(ans, tmp, nums, i, tgt-nums[i])\\n\\t\\ttmp = tmp[:len(tmp)-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc combinationSum(candidates []int, target int) [][]int {\\n\\tvar ans [][]int\\n\\n\\tif len(candidates) == 0 {\\n\\t\\treturn ans\\n\\t}\\n\\n\\tbt(&ans, make([]int, 0), candidates, 0, target)\\n\\n\\treturn ans\\n}\\n\\nfunc bt(ans *[][]int, tmp, nums []int, idx, tgt int) {\\n\\tif tgt < 0 || idx > len(nums) {\\n\\t\\treturn\\n\\t}\\n\\n\\tif tgt == 0 {\\n\\t\\tcpyTmp := make([]int, len(tmp))\\n\\t\\tcopy(cpyTmp, tmp)\\n\\t\\t*ans = append(*ans, cpyTmp)\\n\\t}\\n\\n\\tfor i := idx; i < len(nums); i++ {\\n\\t\\ttmp = append(tmp, nums[i])\\n\\t\\tbt(ans, tmp, nums, i, tgt-nums[i])\\n\\t\\ttmp = tmp[:len(tmp)-1]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594104,
                "title": "easy-java-solution-backtracking-for-beginners",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target){\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        combinationSumhelper(0,candidates,target,ans, new ArrayList<Integer>());\\n\\n        return ans ;\\n    }\\n\\n    // similar concept of taking and not taking\\n    public void  combinationSumhelper( int index ,int[] candidates, int target, List<List<Integer>> ans , List<Integer> insideList){\\n        if (index == candidates.length){\\n            if (target == 0){\\n                List<Integer> newInside = new ArrayList<>(insideList);\\n                ans.add(newInside);\\n            }\\n\\n            return;\\n        }\\n\\n        if (candidates[index] <= target){\\n            insideList.add(candidates[index]);\\n            // Taking the element\\n            combinationSumhelper(index,candidates,target-candidates[index],ans,insideList);\\n            // Backtracking\\n            insideList.remove(insideList.size() - 1);\\n        }\\n        // not taking the element\\n        combinationSumhelper(index+1,candidates,target,ans,insideList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target){\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        combinationSumhelper(0,candidates,target,ans, new ArrayList<Integer>());\\n\\n        return ans ;\\n    }\\n\\n    // similar concept of taking and not taking\\n    public void  combinationSumhelper( int index ,int[] candidates, int target, List<List<Integer>> ans , List<Integer> insideList){\\n        if (index == candidates.length){\\n            if (target == 0){\\n                List<Integer> newInside = new ArrayList<>(insideList);\\n                ans.add(newInside);\\n            }\\n\\n            return;\\n        }\\n\\n        if (candidates[index] <= target){\\n            insideList.add(candidates[index]);\\n            // Taking the element\\n            combinationSumhelper(index,candidates,target-candidates[index],ans,insideList);\\n            // Backtracking\\n            insideList.remove(insideList.size() - 1);\\n        }\\n        // not taking the element\\n        combinationSumhelper(index+1,candidates,target,ans,insideList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189310,
                "title": "java-bactracking-beats-99-in-both-time-and-memory-2ms-t-c-o-n-t-s-c-o-t",
                "content": "\\n\\t// O(N^T) O(T)\\n\\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tArrays.sort(candidates);\\n\\t\\tcombinationSumRecHelper(candidates, 0, target, 0, ans, temp, candidates.length);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(N^T) O(T)\\n\\tpublic void combinationSumRecHelper(int[] candidates, int idx, int target, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int len) {\\n\\n\\t\\tif (curr == target) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (curr > target || idx == len)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (curr + candidates[idx] > target)\\n\\t\\t\\treturn;\\n\\n\\t\\ttemp.add(candidates[idx]);\\n\\t\\tcombinationSumRecHelper(candidates, idx, target, curr + candidates[idx], ans, temp, len);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\n\\t\\tcombinationSumRecHelper(candidates, idx + 1, target, curr, ans, temp, len);\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// O(N^T) O(T)\\n\\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tArrays.sort(candidates);\\n\\t\\tcombinationSumRecHelper(candidates, 0, target, 0, ans, temp, candidates.length);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(N^T) O(T)\\n\\tpublic void combinationSumRecHelper(int[] candidates, int idx, int target, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int len) {\\n\\n\\t\\tif (curr == target) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (curr > target || idx == len)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (curr + candidates[idx] > target)\\n\\t\\t\\treturn;\\n\\n\\t\\ttemp.add(candidates[idx]);\\n\\t\\tcombinationSumRecHelper(candidates, idx, target, curr + candidates[idx], ans, temp, len);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\n\\t\\tcombinationSumRecHelper(candidates, idx + 1, target, curr, ans, temp, len);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 875304,
                "title": "java-combination-sum-recursion-100-fast-well-explained",
                "content": "This solution asks you to create a combination of the integers given IN ANY WAY to get sum as target. Also, the provided integers are unique. \\nWe undertake recusion since there are multiple possibilities for any integer. Any integer can be part of the list of numbers which add to target, or not be part of it, or be present multiple times.\\n\\n```\\nclass Solution {\\n    private List<List<Integer>> result;\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        result = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        recursiveHelper(candidates, target, new ArrayList<Integer>(), 0); \\n        return result;\\n    }\\n    \\n    private void recursiveHelper(int[] candidates, int target, List<Integer> list, int currIdx){\\n        if(target<0)\\n            return;\\n        \\n        for(int i=currIdx;i<candidates.length;i++){\\n            if(candidates[i]==target){\\n                 List<Integer> l = new ArrayList<>(list);\\n                 l.add(candidates[i]);\\n                 result.add(l);\\n                return;\\n            }\\n            if(candidates[i]>target)\\n                return;\\n            list.add(candidates[i]);\\n            recursiveHelper(candidates, target-candidates[i], list, i);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}\\n```\\n\\n\\n1. We need to find a combination of integers which sums to target. oR condition such that SUM- Target == 0. If such a list of numbers is present, that we add in the result set.\\n2. Now how and which number to add?\\n**Pruning 1**\\nWe\\'ll start by adding small numbers to the list (which sums up to target) and then large numbers. Hence we sort the list first. So if the target is not achievable by adding even the smallest number to the list, then it is useless to recurse and add large numebers, hence if **any candidate[i] > target, we stop the current recursion.**\\n\\n**Pruning 2**\\nAlso, while adding numbers we ensure when we add a large number, we do not add small number i.e. we avoid combination like [2,2,3] , [2,3,2], and [3,2,2] by only adding large number after small number. **So IN LOOP we start by index of the number added last time.**\\n\\n**Pruning 3**\\nWe always subtract number added to list from target. So if target is zero, we have a solution list to be added to result set.\\nIf target == any number, we add the number to list and stop our recursion here. No need to add another function call stack, saves memory and time.\\n\\n**BackTrack**\\nAfter adding an element to the list and calling recursion. We need to backtrack our step by removing the recently added element. Since here in JAVA list is passed by reference, we need to do that here. You could always pass a new list but that would be memory consuming since not always the newly created list will create a solution. Thus we only duplicate the list when we have the solution.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private List<List<Integer>> result;\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        result = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        recursiveHelper(candidates, target, new ArrayList<Integer>(), 0); \\n        return result;\\n    }\\n    \\n    private void recursiveHelper(int[] candidates, int target, List<Integer> list, int currIdx){\\n        if(target<0)\\n            return;\\n        \\n        for(int i=currIdx;i<candidates.length;i++){\\n            if(candidates[i]==target){\\n                 List<Integer> l = new ArrayList<>(list);\\n                 l.add(candidates[i]);\\n                 result.add(l);\\n                return;\\n            }\\n            if(candidates[i]>target)\\n                return;\\n            list.add(candidates[i]);\\n            recursiveHelper(candidates, target-candidates[i], list, i);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831159,
                "title": "java-easy-solution",
                "content": "**Please upvote if helpfull!**\\n```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\n        helper(candidates, target, 0, 0, new ArrayList<>());\\n\\n        return resultList;\\n\\n    }\\n\\n    private void helper(int[] candidates, int target, int index, int sum, List<Integer> list) {\\n\\n        if (sum > target) return;\\n\\n        if (sum == target) {\\n\\n            resultList.add(new ArrayList(list));\\n        }\\n\\n        for (int i = index; i < candidates.length; i++) {\\n            \\n            list.add(candidates[i]);\\n            helper(candidates, target, i , sum + candidates[i], list);\\n            list.remove(list.size() - 1);\\n\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\n        helper(candidates, target, 0, 0, new ArrayList<>());\\n\\n        return resultList;\\n\\n    }\\n\\n    private void helper(int[] candidates, int target, int index, int sum, List<Integer> list) {\\n\\n        if (sum > target) return;\\n\\n        if (sum == target) {\\n\\n            resultList.add(new ArrayList(list));\\n        }\\n\\n        for (int i = index; i < candidates.length; i++) {\\n            \\n            list.add(candidates[i]);\\n            helper(candidates, target, i , sum + candidates[i], list);\\n            list.remove(list.size() - 1);\\n\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708264,
                "title": "c-combinations-i-ii-and-iii",
                "content": "**Combinations I :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations II :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations III :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539779,
                "title": "java-2ms-solution-using-recursion-99-56",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Stack<Integer> comb = new Stack<>();\\n        find(candidates, target, comb, 0, result);\\n        return result;\\n    }\\n    private void find(int[] candidates, int target, Stack<Integer> comb, int k, List<List<Integer>> result) {\\n        for (int i = k; i < candidates.length; i++) {\\n            if (candidates[i] == target) {\\n                comb.push(candidates[i]);\\n                result.add(new ArrayList<>(comb));\\n                comb.pop();\\n            } else if (candidates[i] < target) {\\n                comb.push(candidates[i]);\\n                find(candidates, target - candidates[i], comb, i, result);\\n                comb.pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Stack<Integer> comb = new Stack<>();\\n        find(candidates, target, comb, 0, result);\\n        return result;\\n    }\\n    private void find(int[] candidates, int target, Stack<Integer> comb, int k, List<List<Integer>> result) {\\n        for (int i = k; i < candidates.length; i++) {\\n            if (candidates[i] == target) {\\n                comb.push(candidates[i]);\\n                result.add(new ArrayList<>(comb));\\n                comb.pop();\\n            } else if (candidates[i] < target) {\\n                comb.push(candidates[i]);\\n                find(candidates, target - candidates[i], comb, i, result);\\n                comb.pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485551,
                "title": "simple-java-recursion-solution",
                "content": "class Solution \\n{\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        Arrays.sort(candidates);\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        List<Integer> list=new ArrayList<>();\\n        \\n        helper(candidates,0,target,0,result,list);\\n        \\n        return result;\\n        \\n    }\\n    \\n    void helper(int candidates[],int start,int target,int sum,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(sum>target)\\n            return;\\n        \\n        if(sum==target)\\n        {\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i=start;i<candidates.length;i++)\\n        {\\n            list.add(candidates[i]);\\n            helper(candidates,i,target,sum+candidates[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        Arrays.sort(candidates);\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        List<Integer> list=new ArrayList<>();\\n        \\n        helper(candidates,0,target,0,result,list);\\n        \\n        return result;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 459477,
                "title": "python-5-lines-dp-solution",
                "content": "We can simply use the approach for solving Coin Change II [#518](https://leetcode.com/problems/coin-change-2).\\nIt only takes 5 lines without sorting at first.\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[[]]] + [[] for _ in range(target)]\\n        for candidate in candidates:\\n            for i in range(candidate, target + 1):\\n                dp[i] += [sublist + [candidate] for sublist in dp[i - candidate]]\\n        return dp[target]\\n```\\nTime complexity O(length of candidates * target)\\nSpace complexity O(target^3)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[[]]] + [[] for _ in range(target)]\\n        for candidate in candidates:\\n            for i in range(candidate, target + 1):\\n                dp[i] += [sublist + [candidate] for sublist in dp[i - candidate]]\\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255454,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        mem=collections.defaultdict(list)\\n        for i in range(target+1):\\n            for candidate in candidates:\\n                if candidate>i:\\n                    continue\\n                elif candidate==i:\\n                    mem[i].append([candidate])\\n                elif candidate<i:\\n                    tmp=mem[i-candidate]\\n                    for tmplist in tmp:\\n                        pair=[candidate]+tmplist\\n                        if sorted(pair) not in mem[i]:\\n                            mem[i].append(sorted(pair))\\n        return mem[target]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        mem=collections.defaultdict(list)\\n        for i in range(target+1):\\n            for candidate in candidates:\\n                if candidate>i:\\n                    continue\\n                elif candidate==i:\\n                    mem[i].append([candidate])\\n                elif candidate<i:\\n                    tmp=mem[i-candidate]\\n                    for tmplist in tmp:\\n                        pair=[candidate]+tmplist\\n                        if sorted(pair) not in mem[i]:\\n                            mem[i].append(sorted(pair))\\n        return mem[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219346,
                "title": "python-easy-and-clean-iterative-backtracking",
                "content": "```python\\n def combinationSum(self, candidates, target):\\n\\tanswer = []\\n\\tstack = [([], 0, 0)]\\n\\twhile stack:\\n\\t\\tchosen, currSum, currIndex = stack.pop()\\n\\t\\tif currSum == target:\\n\\t\\t\\tanswer.append(chosen)\\n\\t\\t\\tcontinue\\n\\t\\tfor i in range(currIndex, len(candidates)):\\n\\t\\t\\tcandidate = candidates[i]\\n\\t\\t\\tif currSum + candidate > target:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.append((chosen + [candidate], currSum + candidate, i))\\n\\treturn answer\\n```\\nNothing special here, just a simple and easy to read iterative approach to backtracking with a stack. The key here is that we only consider candidates from `currIndex` and onwards as we want to break the symmetry between the pair, leaving us with unique combinations.",
                "solutionTags": [],
                "code": "```python\\n def combinationSum(self, candidates, target):\\n\\tanswer = []\\n\\tstack = [([], 0, 0)]\\n\\twhile stack:\\n\\t\\tchosen, currSum, currIndex = stack.pop()\\n\\t\\tif currSum == target:\\n\\t\\t\\tanswer.append(chosen)\\n\\t\\t\\tcontinue\\n\\t\\tfor i in range(currIndex, len(candidates)):\\n\\t\\t\\tcandidate = candidates[i]\\n\\t\\t\\tif currSum + candidate > target:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.append((chosen + [candidate], currSum + candidate, i))\\n\\treturn answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 16616,
                "title": "very-elegant-python-code-using-recursive-yield-iterator",
                "content": "    def combSum(A, x):\\n        if A == [] or x < A[0]:\\n            return\\n        elif x == A[0]:\\n            yield [x]\\n        else:\\n            for comb in combSum(A, x - A[0]):\\n                yield [A[0]] + comb\\n            for comb in combSum(A[1:], x):\\n                yield comb\\n    \\n    class Solution:\\n        def combinationSum(self, A, x):\\n            return list(combSum(sorted(set(A)), x))",
                "solutionTags": [],
                "code": "    def combSum(A, x):\\n        if A == [] or x < A[0]:\\n            return\\n        elif x == A[0]:\\n            yield [x]\\n        else:\\n            for comb in combSum(A, x - A[0]):\\n                yield [A[0]] + comb\\n            for comb in combSum(A[1:], x):\\n                yield comb\\n    \\n    class Solution:\\n        def combinationSum(self, A, x):\\n            return list(combSum(sorted(set(A)), x))",
                "codeTag": "Java"
            },
            {
                "id": 3597098,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$Exponential$$\\n\\n- Space complexity:\\n$$Exponential$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            if (sum == target)\\n                ans.push_back(temp);\\n            return;\\n        }\\n        if ((sum + candidates[idx]) <= target) {\\n            sum += candidates[idx];\\n            temp.push_back(candidates[idx]);\\n            helper(idx, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[idx];\\n            temp.pop_back();\\n        }\\n        helper(idx+1, candidates, n, sum, target, temp, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            if (sum == target)\\n                ans.push_back(temp);\\n            return;\\n        }\\n        if ((sum + candidates[idx]) <= target) {\\n            sum += candidates[idx];\\n            temp.push_back(candidates[idx]);\\n            helper(idx, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[idx];\\n            temp.pop_back();\\n        }\\n        helper(idx+1, candidates, n, sum, target, temp, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473884,
                "title": "c-recursive-backtracking-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n      if(ind==arr.size()){\\n        if(target==0){\\n          ans.push_back(ds);\\n        }\\n        return;\\n      }\\n      if(arr[ind]<=target){\\n        ds.push_back(arr[ind]);\\n        findCombination(ind,target-arr[ind],arr,ans,ds);\\n        ds.pop_back();\\n      }\\n      findCombination(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n      if(ind==arr.size()){\\n        if(target==0){\\n          ans.push_back(ds);\\n        }\\n        return;\\n      }\\n      if(arr[ind]<=target){\\n        ds.push_back(arr[ind]);\\n        findCombination(ind,target-arr[ind],arr,ans,ds);\\n        ds.pop_back();\\n      }\\n      findCombination(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774204,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760114,
                "title": "java-easy-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> ans=new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] arr, int sum) {\\n        Arrays.sort(arr);\\n        helper(arr,sum,0,new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(int [] arr,int sum,int ind,List<Integer> temp){\\n        if(ind==arr.length){\\n            return;\\n        }\\n        \\n        if(arr[ind]==sum){\\n            ArrayList<Integer> temp2=new ArrayList<>();\\n            temp2.addAll(temp);\\n            temp2.add(arr[ind]);\\n            ans.add(temp2);\\n            return;\\n        }\\n        if(arr[ind]>sum){\\n            return;\\n        }\\n        \\n        helper(arr,sum,ind+1,temp);\\n        \\n        ArrayList<Integer> temp2=new ArrayList<>();\\n        temp2.addAll(temp);\\n        temp2.add(arr[ind]);\\n        helper(arr,sum-arr[ind],ind,temp2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans=new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] arr, int sum) {\\n        Arrays.sort(arr);\\n        helper(arr,sum,0,new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(int [] arr,int sum,int ind,List<Integer> temp){\\n        if(ind==arr.length){\\n            return;\\n        }\\n        \\n        if(arr[ind]==sum){\\n            ArrayList<Integer> temp2=new ArrayList<>();\\n            temp2.addAll(temp);\\n            temp2.add(arr[ind]);\\n            ans.add(temp2);\\n            return;\\n        }\\n        if(arr[ind]>sum){\\n            return;\\n        }\\n        \\n        helper(arr,sum,ind+1,temp);\\n        \\n        ArrayList<Integer> temp2=new ArrayList<>();\\n        temp2.addAll(temp);\\n        temp2.add(arr[ind]);\\n        helper(arr,sum-arr[ind],ind,temp2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969565,
                "title": "very-fast-98-c-dfs-solution",
                "content": "```\\n    public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> current = new();\\n\\n        void Dfs(int index, int total)\\n        {\\n            if (total == target)\\n            {\\n                results.Add(current.ToArray());\\n                return;\\n            }\\n\\n            if (index >= candidates.Length || total > target)\\n            {\\n                return;\\n            }\\n\\n            current.Push(candidates[index]);\\n            Dfs(index, total + candidates[index]);\\n            current.Pop();\\n            Dfs(index + 1, total);\\n        }\\n\\n        Dfs(0, 0);\\n        return results;\\n    }\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n    public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> current = new();\\n\\n        void Dfs(int index, int total)\\n        {\\n            if (total == target)\\n            {\\n                results.Add(current.ToArray());\\n                return;\\n            }\\n\\n            if (index >= candidates.Length || total > target)\\n            {\\n                return;\\n            }\\n\\n            current.Push(candidates[index]);\\n            Dfs(index, total + candidates[index]);\\n            current.Pop();\\n            Dfs(index + 1, total);\\n        }\\n\\n        Dfs(0, 0);\\n        return results;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1777361,
                "title": "recursive-solution-with-diagram",
                "content": "**DO upvote if you understand**\\n![image](https://assets.leetcode.com/users/images/270da9e8-b2c0-4f9f-9a63-24ba4c32722c_1645073544.489124.png)\\n\\n```\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>>answer;\\n\\n        vector<int>currentAns;\\n\\n        solve(candidates , target , 0 , currentAns , answer);\\n    \\treturn answer;\\n    }\\n\\n    void solve(vector<int>& candidates, int target , int idx ,\\n    \\tvector<int>&currentAns , vector<vector<int>>&answer) {\\n\\n\\n    \\t//Base case \\n    \\tif( target == 0 ) {\\n    \\t\\t//if target is zero we have found the combination\\n    \\t\\tanswer.push_back(currentAns);\\n    \\t\\treturn;\\n    \\t}\\n    \\tif(idx >= candidates.size()) return;\\n    \\tint currentVal = candidates[idx];\\n    \\t\\n    \\t//pick the element\\n        //if current element is less or equal to target then do the combination\\n    \\tif(target >= currentVal) {\\n    \\t\\tcurrentAns.push_back(currentVal);\\n    \\t\\tsolve(candidates , target-currentVal , idx , currentAns ,answer);\\n    \\t\\t //make sure u remove the element while recursion is over\\n    \\t\\tcurrentAns.pop_back();\\n    \\t}\\n    \\t\\n    \\t//not pick up element\\n    \\tsolve(candidates , target , idx+1 , currentAns , answer);\\n\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>>answer;\\n\\n        vector<int>currentAns;\\n\\n        solve(candidates , target , 0 , currentAns , answer);\\n    \\treturn answer;\\n    }\\n\\n    void solve(vector<int>& candidates, int target , int idx ,\\n    \\tvector<int>&currentAns , vector<vector<int>>&answer) {\\n\\n\\n    \\t//Base case \\n    \\tif( target == 0 ) {\\n    \\t\\t//if target is zero we have found the combination\\n    \\t\\tanswer.push_back(currentAns);\\n    \\t\\treturn;\\n    \\t}\\n    \\tif(idx >= candidates.size()) return;\\n    \\tint currentVal = candidates[idx];\\n    \\t\\n    \\t//pick the element\\n        //if current element is less or equal to target then do the combination\\n    \\tif(target >= currentVal) {\\n    \\t\\tcurrentAns.push_back(currentVal);\\n    \\t\\tsolve(candidates , target-currentVal , idx , currentAns ,answer);\\n    \\t\\t //make sure u remove the element while recursion is over\\n    \\t\\tcurrentAns.pop_back();\\n    \\t}\\n    \\t\\n    \\t//not pick up element\\n    \\tsolve(candidates , target , idx+1 , currentAns , answer);\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777034,
                "title": "c-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&C,vector<int>&A,vector<vector<int>>&res,int target,int sum,int start)\\n    {\\n        if(sum == target)\\n        {\\n            res.push_back(A);\\n            return;\\n        }\\n        \\n        for(int i = start; i < C.size(); i++)\\n        {\\n            if(sum + C[i] <= target)\\n            {\\n                A.push_back(C[i]);\\n                sum += C[i];\\n                solve(C,A,res,target,sum,i);\\n                A.pop_back();\\n                sum -= C[i];\\n            }\\n        }\\n            \\n    }\\n    vector<vector<int>> combinationSum(vector<int>&C, int target) {\\n        vector<vector<int>>res;\\n        vector<int>A;\\n        solve(C,A,res,target,0,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&C,vector<int>&A,vector<vector<int>>&res,int target,int sum,int start)\\n    {\\n        if(sum == target)\\n        {\\n            res.push_back(A);\\n            return;\\n        }\\n        \\n        for(int i = start; i < C.size(); i++)\\n        {\\n            if(sum + C[i] <= target)\\n            {\\n                A.push_back(C[i]);\\n                sum += C[i];\\n                solve(C,A,res,target,sum,i);\\n                A.pop_back();\\n                sum -= C[i];\\n            }\\n        }\\n            \\n    }\\n    vector<vector<int>> combinationSum(vector<int>&C, int target) {\\n        vector<vector<int>>res;\\n        vector<int>A;\\n        solve(C,A,res,target,0,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634720,
                "title": "0ms-c-solution-backtracking-solution",
                "content": "*Please find the image below:*\\n![image](https://assets.leetcode.com/users/images/ade65dba-4375-492d-82b1-e31a6b377c14_1639865523.526272.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void combinationSumHelper(int indx, vector<int>& arr, int target,vector<vector<int>>& result,  vector<int>& comb )\\n    {\\n        if(indx >=arr.size())\\n        {\\n            return;\\n        }\\n        \\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        \\n        if(arr[indx]<=target)\\n        {\\n        comb.push_back(arr[indx]);\\n        combinationSumHelper(indx,arr,target-arr[indx],result,comb);\\n        comb.pop_back();\\n        \\n        }\\n   \\n       combinationSumHelper(indx+1,arr,target,result,comb);\\n        \\n        \\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        combinationSumHelper(0,candidates,target,result,comb);\\n        return result;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSumHelper(int indx, vector<int>& arr, int target,vector<vector<int>>& result,  vector<int>& comb )\\n    {\\n        if(indx >=arr.size())\\n        {\\n            return;\\n        }\\n        \\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        \\n        if(arr[indx]<=target)\\n        {\\n        comb.push_back(arr[indx]);\\n        combinationSumHelper(indx,arr,target-arr[indx],result,comb);\\n        comb.pop_back();\\n        \\n        }\\n   \\n       combinationSumHelper(indx+1,arr,target,result,comb);\\n        \\n        \\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        combinationSumHelper(0,candidates,target,result,comb);\\n        return result;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626467,
                "title": "c-0ms-100-faster-3-approachs-comparison-explained",
                "content": "**Please upvote if you like the solution and any improvements or suggestion are welcomed in the comments.**\\n## Approach 1: Dynamic Programming\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\tvector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int i:candidates)\\n        {\\n            for(int j=i;j<=target;j++)\\n            {\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        return dp[target];\\n\\t}\\n};\\n```\\n\\n## Approach 2: Sorting, Backtracking and DFS\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t//sorting not needed but used for pruning\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n\\t\\t//removing not possible elements\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    //Function used to calculate the next possible combination until end of the possible candidates\\n    void findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return;\\n        if(sum==0)res.push_back(comb);\\n        for(int i=start;i<n;i++){\\n            comb.push_back(candidates[i]);\\n            findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n    }\\n};\\n```\\n**Example-**\\nInput: **candidates = [2,3,6,7,8,9], target = 7**\\nOutput: **[[2,2,3],[7]]**\\n***Explanation:***\\nPruning- **possible candidates** =**[2,3,6,7]**\\nThe checking goes like-\\n[2]      => (7-2>0) => add 2\\n[2,2]     => (7-4>0)  => add 2\\n[2,2,2]  => (7-6>0)  => add 2 \\n[2,2,2,2]  => (7-8<0)  => remove 2, add 3\\n[2,2,2,3]  => (7-9<0)  => remove 3, add 6\\n[2,2,2,6]  => (7-12<0)  => remove 6, add 7\\n[2,2,2,7]  => (7-13<0)  => remove 7, remove2, add 3\\n**[2,2,3]  => (7-7==0)  => add to result** , remove 3 ,add 6\\n[2,2,6]  => (7-10<0)  => remove 6 ,add 7\\n[2,2,7]  => (7-11<0)  => remove 7 ,remove 2, add 3\\n[2,3]=> (7-5>0)=>add 3\\n[2,3,3] => (7-8<0)  => remove 3 ,add 6\\n[2,3,6] => (7-11<0)  => remove 6 ,add 7\\n[2,3,7] =>(7-12<0) =>remove 7, remove 3, add 6\\n[2,6] => (7-8<0) =>remove 6 , add 7\\n[2,7] =>(7-9<0) =>remove 7, remove 2, add 3\\n[3]=> (7-3>0) => add 3\\n[3,3] => (7-6>0) => add 3\\n[3,3,3] => (7-9<0)  => remove 3 ,add 6\\n[3,3,6] => (7-12<0)  => remove 6 ,add 7\\n[3,3,7] =>(7-13<0) =>remove 7, remove 3, add 6\\n[3,6]  => (7-9<0)  => remove 6 ,add 7\\n[3,7] =>  (7-10<0)  => remove 7 ,remove 3, add 6 \\n[6] =>(7-6>0) =>add 7\\n[6,7] =>(7-13<0) => remove 7 ,remove 6, add 7\\n**[7] => (7==7) =>add to result**\\nIn this way, we get the result as **[[2,2,3],[7]]**\\n\\n## Approach 3:: Optimizing DFS calls\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    \\n    bool findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return false;\\n        if(sum==0){res.push_back(comb);return true;}\\n        bool tryNext=true;\\n        for(int i=start;tryNext&&i<n;i++){\\n            comb.push_back(candidates[i]);\\n            tryNext=findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Example-**\\nInput: **candidates = [2,3,6,7,8,9], target = 7**\\nOutput: **[[2,2,3],[7]]**\\n***Explanation:***\\nPruning- **possible candidates** =**[2,3,6,7]**\\nThe checking goes like-\\n**tryNext=true**\\n[2]      => (7-2>0) => add 2\\n**tryNext=true**\\n[2,2]     => (7-4>0)  => add 2\\n**tryNext=true**\\n[2,2,2]  => (7-6>0)  => add 2 \\n**tryNext=true**\\n[2,2,2,2]  => **(7-8<0)  =>  tryNext=false**, remove 2,\\nremove2, add 3\\n**tryNext=true**\\n**[2,2,3]  => (7-7==0)  => add to result** , remove 3 ,add 6\\n**tryNext=true**\\n[2,2,6]  => **(7-10<0)  =>  tryNext=false** , remove 6\\nremove 2, add 3\\n**tryNext=true**\\n[2,3]=> (7-5>0)=>add 3\\n**tryNext=true**\\n[2,3,3] => **(7-8<0)  =>  tryNext=false** , remove 3,\\nremove 3, add 6\\n[2,6] => **(7-8<0) => tryNext=false** , remove 6 ,\\nremove 2, add 3\\n[3]=> (7-3>0) => add 3\\n**tryNext=true**\\n[3,3] => (7-6>0) => add 3\\n**tryNext=true**\\n[3,3,3] => **(7-9<0)  =>  tryNext=false** , remove 3 \\nremove 3, add 6\\n**tryNext=true**\\n[3,6]  => **(7-9<0)  =>  tryNext=false** , remove 6 \\nremove 3, add 6 \\n**tryNext=true**\\n[6] =>(7-6>0) =>add 7\\n**tryNext=true**\\n[6,7] =>**(7-13<0) =>  tryNext=false** , remove 7 ,remove 6, add 7\\n**tryNext=true**\\n**[7] => (7==7) =>add to result**\\nIn this way, we get the result as **[[2,2,3],[7]]**\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Combination Sum.\\nMemory Usage: 10.7 MB, less than 97.01% of C++ online submissions for Combination Sum.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\tvector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int i:candidates)\\n        {\\n            for(int j=i;j<=target;j++)\\n            {\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        return dp[target];\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t//sorting not needed but used for pruning\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n\\t\\t//removing not possible elements\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    //Function used to calculate the next possible combination until end of the possible candidates\\n    void findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return;\\n        if(sum==0)res.push_back(comb);\\n        for(int i=start;i<n;i++){\\n            comb.push_back(candidates[i]);\\n            findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    \\n    bool findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return false;\\n        if(sum==0){res.push_back(comb);return true;}\\n        bool tryNext=true;\\n        for(int i=start;tryNext&&i<n;i++){\\n            comb.push_back(candidates[i]);\\n            tryNext=findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561049,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        helper(candidates, list, new ArrayList<>(), target, 0);\\n        return list;\\n    }\\n    private void helper(int[] candidates, List<List<Integer>> list , List<Integer> tmp, int target, int i){\\n        if(target < 0)  return;\\n        else if(target == 0)    list.add(new ArrayList<>(tmp));\\n        else{\\n            while(i<candidates.length){\\n                tmp.add(candidates[i]);\\n                helper(candidates, list, tmp, target - candidates[i], i++);\\n                tmp.remove(tmp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        helper(candidates, list, new ArrayList<>(), target, 0);\\n        return list;\\n    }\\n    private void helper(int[] candidates, List<List<Integer>> list , List<Integer> tmp, int target, int i){\\n        if(target < 0)  return;\\n        else if(target == 0)    list.add(new ArrayList<>(tmp));\\n        else{\\n            while(i<candidates.length){\\n                tmp.add(candidates[i]);\\n                helper(candidates, list, tmp, target - candidates[i], i++);\\n                tmp.remove(tmp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427935,
                "title": "c-with-explanation-simple-and-easy-to-understand-for-na-ve-like-me",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void help(vector<int>& cand,vector<vector<int>> &vec,vector<int> &v,int target,int n){\\n\\t//base case\\n        if(target==0){\\n            vec.push_back(v);\\n                return;\\n        }\\n        if(n==0){\\n            return;\\n        }\\n\\t//choice diagram \\n        if(cand[n-1]<=target){\\n            v.push_back(cand[n-1]);\\n            help(cand,vec,v,target-cand[n-1],n);\\n            v.pop_back();\\n        }\\n        help(cand,vec,v,target,n-1);\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& cand, int target) {\\n        vector<vector<int>> vec;\\n        vector<int> v;\\n        help(cand,vec,v,target,cand.size());\\n        return vec;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<int>& cand,vector<vector<int>> &vec,vector<int> &v,int target,int n){\\n\\t//base case\\n        if(target==0){\\n            vec.push_back(v);\\n                return;\\n        }\\n        if(n==0){\\n            return;\\n        }\\n\\t//choice diagram \\n        if(cand[n-1]<=target){\\n            v.push_back(cand[n-1]);\\n            help(cand,vec,v,target-cand[n-1],n);\\n            v.pop_back();\\n        }\\n        help(cand,vec,v,target,n-1);\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& cand, int target) {\\n        vector<vector<int>> vec;\\n        vector<int> v;\\n        help(cand,vec,v,target,cand.size());\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278005,
                "title": "python-dfs-sort",
                "content": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        candidates.sort()\\n        def DFS(arr,sm,target,j):\\n            if sm==target:\\n                if arr not in ans:\\n                    ans.append(arr)\\n                return\\n            for i in range(j,len(candidates)):\\n                if sm+candidates[i]>target:\\n                    return\\n                DFS(arr+[candidates[i]],sm+candidates[i],target,i)\\n        DFS([],0,target,0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        candidates.sort()\\n        def DFS(arr,sm,target,j):\\n            if sm==target:\\n                if arr not in ans:\\n                    ans.append(arr)\\n                return\\n            for i in range(j,len(candidates)):\\n                if sm+candidates[i]>target:\\n                    return\\n                DFS(arr+[candidates[i]],sm+candidates[i],target,i)\\n        DFS([],0,target,0)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1234096,
                "title": "c-backtracking-with-explanation-easy-to-understand",
                "content": "The idea of my solution is simple. I will backtrack with vector result, vector current, int target, int current_sum (sum of this backtrack turn), int prev (to save index of candidates that we have already use in last backtrack). \\n1) I check if current_sum is larger than target or not. If yes I will immediatedly stop backtrack because if we continue to backtrack we only add a postive number to make current_sum larger.\\n2) If current_sum==target, I will push vector current to result then return\\n3) If we are step 3, it means that or current_sum still smaller than target and need to increase. Now we loop from previous index to last index of candidate (I do not loop from 1 because I will make the same vector. For example, if I already have 1, 2 and in backtrack with 2 if we loop from 1 we wiil have 2, 1 and it not valid), then we add the element we loop through to vector current and backtrack with vector current and current_sum + the element we just added.\\n\\nIf my solution is helpful, give me an upvote. Thank you for reading.\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>> &result, vector<int> current, int target, int current_sum, vector<int> candidates, int previous){\\n        if(current_sum>target){\\n            return;\\n        }\\n        if(current_sum==target){\\n            result.push_back(current);\\n        }\\n        \\n        for(int i=previous; i<candidates.size(); i++){\\n            current.push_back(candidates[i]);\\n            backtrack(result, current, target, current_sum+candidates[i], candidates, i);\\n            current.pop_back();\\n        }\\n    }\\n        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        vector<int> current;\\n        backtrack(result, current, target, 0, candidates, 0);\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    void backtrack(vector<vector<int>> &result, vector<int> current, int target, int current_sum, vector<int> candidates, int previous){\\n        if(current_sum>target){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1188545,
                "title": "top-down-using-memoization-solution-better-time-complexity-than-backtracking",
                "content": "The idea is that you memoize the generated combinations for each target, and bubble that up to the caller. The caller will then add the candidate that generated those lists to each of them. \\n\\nOf course we will have to dedupe at the end, because resuing solutions will generate duplicates. \\n\\nI am not so sure of the time complexity, but I beleive it would be this:\\n\\nO(N^2 * M) with N being the target and M being the length of array. We then have the sorting for deduping. So that would be O(MlogM)\\nThe result is O(M(logM * N^2)). Seems to be a better time complexity than backtracking.  \\n\\n```\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        # For memoization\\n        self.memo = {}\\n        \\n        def get_combo(candidates, target):\\n            \\n            if target < 0:\\n                return\\n\\n            if target == 0:\\n                # Return a list of list so we can add candidates to it\\n                return [[]]\\n            \\n            # Use memoization\\n            if target in self.memo:\\n                return self.memo[target]\\n            \\n            final_list = []\\n            for candidate in candidates:\\n                result = get_combo(candidates, target - candidate)\\n                if result:\\n                    for alist in result:\\n                        # deep copy\\n                        alist = list(alist)\\n                        # add candidate to each list returned\\n                        alist.append(candidate)\\n                        # add new list to final list\\n                        final_list.append(alist)\\n\\n            self.memo[target] = final_list             \\n            return final_list\\n        \\n        results = []\\n        \\n        # Dedupe\\n        aset = set()\\n        for alist in get_combo(candidates, target):\\n            alist = sorted(alist)\\n            if tuple(alist) not in aset:\\n                aset.add(tuple(alist))\\n                results.append(alist)\\n                \\n        return results\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        # For memoization\\n        self.memo = {}\\n        \\n        def get_combo(candidates, target):\\n            \\n            if target < 0:\\n                return\\n\\n            if target == 0:\\n                # Return a list of list so we can add candidates to it\\n                return [[]]\\n            \\n            # Use memoization\\n            if target in self.memo:\\n                return self.memo[target]\\n            \\n            final_list = []\\n            for candidate in candidates:\\n                result = get_combo(candidates, target - candidate)\\n                if result:\\n                    for alist in result:\\n                        # deep copy\\n                        alist = list(alist)\\n                        # add candidate to each list returned\\n                        alist.append(candidate)\\n                        # add new list to final list\\n                        final_list.append(alist)\\n\\n            self.memo[target] = final_list             \\n            return final_list\\n        \\n        results = []\\n        \\n        # Dedupe\\n        aset = set()\\n        for alist in get_combo(candidates, target):\\n            alist = sorted(alist)\\n            if tuple(alist) not in aset:\\n                aset.add(tuple(alist))\\n                results.append(alist)\\n                \\n        return results\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1151613,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(target, path, start):\\n            if target == 0: res.append(path)\\n            else:\\n                for i in range(start, len(candidates)):\\n                    if target - candidates[i] >= 0:\\n                        backtrack(target - candidates[i], path + [candidates[i]], i)\\n        \\n        res = []\\n        backtrack(target, [], 0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(target, path, start):\\n            if target == 0: res.append(path)\\n            else:\\n                for i in range(start, len(candidates)):\\n                    if target - candidates[i] >= 0:\\n                        backtrack(target - candidates[i], path + [candidates[i]], i)\\n        \\n        res = []\\n        backtrack(target, [], 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935010,
                "title": "well-commented-javascript-backtracking-solution-beats-99-81-o-n-t-m-time-space",
                "content": "**Explanation for the time/space complexity (taken directly from Solutions tab) below the code**\\n\\n```\\nvar combinationSum = function(candidates, target) {\\n  const combos = [];\\n  // Pass in the given args, plus combos, a currCombo array, and an index\\n  combinationSumHelper(candidates, target, combos, [], 0);\\n  return combos;\\n};\\n\\nvar combinationSumHelper = function(candidates, target, combos, currCombo, index) {\\n  // Since we subtract from target on each recursive call, we know that\\n  // the base case is when target === 0 (a valid combo)\\n  if (target === 0) combos.push([...currCombo]);\\n\\n  for (let i = index; i < candidates.length; i++) {\\n\\t// Just check to make sure the current number fits into target\\n    if (candidates[i] <= target) {\\n\\t  // Try to use the number by pushing to currCombo\\n      currCombo.push(candidates[i]);\\n\\t  // Recurse and subtract this number from target (now the next recursion will use the remainder)\\n\\t  // and pass in i as the index because we can use this number multiple times\\n      combinationSumHelper(candidates, target - candidates[i], combos, currCombo, i);\\n\\t  // Un-use the number so in the next iteration, you will use the next number\\n      currCombo.pop();\\n    }\\n  }\\n}\\n```\\n\\n**Copied directly from Solutions tab; explanation for time/space complexity (Space has the same reason as Time since Recursion stack reflects it):**\\n\\nLet N be the number of candidates, T be the target value, and M be the minimal value among the candidates.\\n\\n... the execution of the backtracking is unfolded as a DFS traversal in a n-ary tree. The total number of steps during the backtracking would be the number of nodes in the tree.\\n\\nAt each node, it takes a constant time to process, except the leaf nodes which could take a linear time to make a copy of combination. So we can say that the time complexity is linear to the number of nodes of the execution tree.\\n\\nHere we provide a loose upper bound on the number of nodes.\\n\\n* First of all, the fan-out of each node would be bounded to N, i.e. the total number of candidates.\\n\\n* The maximal depth of the tree, would be T/M, where we keep on adding the smallest element to the combination.\\n\\n* As we know, the maximal number of nodes in N-ary tree of T/M height would be N ^ ((T/M) +1)\\n\\nNote that, the actual number of nodes in the execution tree would be much smaller than the upper bound, since the fan-out of the nodes are decreasing level by level.",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar combinationSum = function(candidates, target) {\\n  const combos = [];\\n  // Pass in the given args, plus combos, a currCombo array, and an index\\n  combinationSumHelper(candidates, target, combos, [], 0);\\n  return combos;\\n};\\n\\nvar combinationSumHelper = function(candidates, target, combos, currCombo, index) {\\n  // Since we subtract from target on each recursive call, we know that\\n  // the base case is when target === 0 (a valid combo)\\n  if (target === 0) combos.push([...currCombo]);\\n\\n  for (let i = index; i < candidates.length; i++) {\\n\\t// Just check to make sure the current number fits into target\\n    if (candidates[i] <= target) {\\n\\t  // Try to use the number by pushing to currCombo\\n      currCombo.push(candidates[i]);\\n\\t  // Recurse and subtract this number from target (now the next recursion will use the remainder)\\n\\t  // and pass in i as the index because we can use this number multiple times\\n      combinationSumHelper(candidates, target - candidates[i], combos, currCombo, i);\\n\\t  // Un-use the number so in the next iteration, you will use the next number\\n      currCombo.pop();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875305,
                "title": "pyhton-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=qs1-iEla-5M)\\nhttps://www.youtube.com/watch?v=qs1-iEla-5M\\n```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        self.res = []\\n        self.candidates = candidates\\n        self.backtrack([], 0, target)\\n        return self.res\\n    \\n    def backtrack(self, path, indx, target):\\n        \\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            self.res.append(path)\\n            return \\n        \\n        for x in range(indx, len(self.candidates)):\\n            self.backtrack(path+[self.candidates[x]], x, target - self.candidates[x])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        self.res = []\\n        self.candidates = candidates\\n        self.backtrack([], 0, target)\\n        return self.res\\n    \\n    def backtrack(self, path, indx, target):\\n        \\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            self.res.append(path)\\n            return \\n        \\n        for x in range(indx, len(self.candidates)):\\n            self.backtrack(path+[self.candidates[x]], x, target - self.candidates[x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874860,
                "title": "java-clean-code-backtracking-technique",
                "content": "```\\nclass Solution {\\n\\t\\n\\tprivate void combinationSumUtil (int[] candidates, int target, int index, List<Integer> temp, List<List<Integer>> res) {\\n\\t\\t\\n\\t\\tif (target == 0) {\\n\\t\\t\\tres.add (new ArrayList <>(temp));\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (; index < candidates.length && target > 0; index++) {\\n\\t\\t\\ttemp.add (candidates[index]);\\n\\t\\t\\tcombinationSumUtil (candidates, target - candidates[index], index, temp, res);\\n\\t\\t\\ttemp.remove (temp.size () - 1);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<List<Integer>> combinationSum (int[] candidates, int target) {\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList <>();\\n\\t\\tcombinationSumUtil (candidates, target, 0, new ArrayList<Integer> (), res);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tprivate void combinationSumUtil (int[] candidates, int target, int index, List<Integer> temp, List<List<Integer>> res) {\\n\\t\\t\\n\\t\\tif (target == 0) {\\n\\t\\t\\tres.add (new ArrayList <>(temp));\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (; index < candidates.length && target > 0; index++) {\\n\\t\\t\\ttemp.add (candidates[index]);\\n\\t\\t\\tcombinationSumUtil (candidates, target - candidates[index], index, temp, res);\\n\\t\\t\\ttemp.remove (temp.size () - 1);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<List<Integer>> combinationSum (int[] candidates, int target) {\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList <>();\\n\\t\\tcombinationSumUtil (candidates, target, 0, new ArrayList<Integer> (), res);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845243,
                "title": "python-recursive-solution-faster-than-92-13-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        res = []\\n        candidates.sort()\\n        def helper(target, index, sub_list):\\n            if target == 0:\\n                res.append(sub_list)\\n            if target < 0 or index >= len(candidates):\\n                return\\n            for i in range(index, len(candidates)):\\n                #optimization\\n                if target < candidates[i]:\\n                    break\\n                helper(target-candidates[i], i, sub_list+[candidates[i]])\\n        helper(target, 0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        res = []\\n        candidates.sort()\\n        def helper(target, index, sub_list):\\n            if target == 0:\\n                res.append(sub_list)\\n            if target < 0 or index >= len(candidates):\\n                return\\n            for i in range(index, len(candidates)):\\n                #optimization\\n                if target < candidates[i]:\\n                    break\\n                helper(target-candidates[i], i, sub_list+[candidates[i]])\\n        helper(target, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762703,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643296,
                "title": "simple-recursion-python",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.answer=set()   # Set - To get rid of duplicates\\n        self.candidates=[]  \\n    def helper(self,target_,ans_=[]):\\n        if target_ < 0 : return\\n        elif target_ == 0 : \\n            self.answer.add(tuple(sorted(ans_))) # Sets can store only tuples not lists \\n            return          # Sorting it to make it distinguishable\\n        else:\\n            for i in self.candidates:\\n                self.helper(target_-i,ans_+[i])\\n    def combinationSum(self, candidates, target) -> List[List[int]]:\\n        self.candidates = candidates # Making it a data member caus\\' it never changes and \\n        self.helper(target)          #     no need to pass it for every recursion call\\n        return list(self.answer)\\n```\\n![image](https://assets.leetcode.com/users/ssvvbb6/image_1590044625.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.answer=set()   # Set - To get rid of duplicates\\n        self.candidates=[]  \\n    def helper(self,target_,ans_=[]):\\n        if target_ < 0 : return\\n        elif target_ == 0 : \\n            self.answer.add(tuple(sorted(ans_))) # Sets can store only tuples not lists \\n            return          # Sorting it to make it distinguishable\\n        else:\\n            for i in self.candidates:\\n                self.helper(target_-i,ans_+[i])\\n    def combinationSum(self, candidates, target) -> List[List[int]]:\\n        self.candidates = candidates # Making it a data member caus\\' it never changes and \\n        self.helper(target)          #     no need to pass it for every recursion call\\n        return list(self.answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521349,
                "title": "commented-python3-7-solution-faster-than-71-49-100-less-memory",
                "content": "unlike what I saw others post, i am not recalculating the sum every step, rather running the same solution for the remaining sum.\\nHope it helps!\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # if the target is reached - return \\n        if target == 0:\\n            return []\\n        \\n        # quit if we went out of bounds\\n        if target < 0:\\n            return None\\n        out = []\\n        \\n        # two cases here:\\n        # if a candidate is the target add to solutions \\n        # since everything after will be beyond the sum\\n        # if < target : get combinations on target-cur_candidate,\\n        # then merge each solution with the cur_candidate\\n\\n        for i in range(len(candidates)):\\n            candidate = candidates[i]\\n            if candidate == target:\\n                out.append([candidate])\\n\\n            if candidate < target:\\n                solutions = self.combinationSum(candidates[i:], target-candidate)\\n                for solution in solutions:\\n                    if solution is not None:\\n                        out.append([candidate, *solution])\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # if the target is reached - return \\n        if target == 0:\\n            return []\\n        \\n        # quit if we went out of bounds\\n        if target < 0:\\n            return None\\n        out = []\\n        \\n        # two cases here:\\n        # if a candidate is the target add to solutions \\n        # since everything after will be beyond the sum\\n        # if < target : get combinations on target-cur_candidate,\\n        # then merge each solution with the cur_candidate\\n\\n        for i in range(len(candidates)):\\n            candidate = candidates[i]\\n            if candidate == target:\\n                out.append([candidate])\\n\\n            if candidate < target:\\n                solutions = self.combinationSum(candidates[i:], target-candidate)\\n                for solution in solutions:\\n                    if solution is not None:\\n                        out.append([candidate, *solution])\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519968,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> finalResult;\\n    vector<int> result;\\npublic:\\n    void combinationSumUtil(const vector<int>& candidates, int target, int size)\\n    {\\n        if(target == 0)\\n        {\\n            finalResult.push_back(result);\\n            return;\\n        }\\n        if(target<0) return;\\n        if(size<=0 && target>=1) return;\\n        result.push_back(candidates[size-1]);\\n        combinationSumUtil(candidates, target-candidates[size-1], size);\\n        result.pop_back();\\n        combinationSumUtil(candidates, target, size-1);\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        combinationSumUtil(candidates,target,candidates.size());\\n        return finalResult;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    vector<vector<int>> finalResult;\\n    vector<int> result;\\npublic:\\n    void combinationSumUtil(const vector<int>& candidates, int target, int size)\\n    {\\n        if(target == 0)\\n        {\\n            finalResult.push_back(result);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 499983,
                "title": "easy-to-understand-c-solution-backtracking",
                "content": "Runtime: 8 ms, faster than 97.96% of C++ online submissions for Combination Sum.\\nMemory Usage: 9.6 MB, less than 63.89% of C++ online submissions for Combination Sum.\\n```\\nclass Solution {\\n    vector<vector<int>> res;\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(candidates, target, 0, temp, 0);\\n        \\n        return res;\\n    }\\n    \\n    void solve(vector<int>& candidates, int target, int currSum, vector<int>& temp, int pos)\\n    {\\n        if(currSum > target)\\n            return;\\n        if(currSum == target)\\n        {\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=pos; i<candidates.size(); i++)\\n        {\\n            currSum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            solve(candidates, target, currSum, temp, i);\\n            currSum -= candidates[i];\\n            temp.pop_back();\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    vector<vector<int>> res;\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(candidates, target, 0, temp, 0);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 403209,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n\\n    def combinationSum(self, candidates: [int], target: int) -> [[int]]:\\n        answer = []\\n\\n        universe = [([], 0)]\\n        for n in candidates:\\n            for (ls, v) in universe:\\n                if v + n == target:\\n                    answer.append(ls + [n])\\n                elif v + n < target:\\n                    universe.append((ls + [n], v + n))\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\n    def combinationSum(self, candidates: [int], target: int) -> [[int]]:\\n        answer = []\\n\\n        universe = [([], 0)]\\n        for n in candidates:\\n            for (ls, v) in universe:\\n                if v + n == target:\\n                    answer.append(ls + [n])\\n                elif v + n < target:\\n                    universe.append((ls + [n], v + n))\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340436,
                "title": "a-6-line-python-dp-solution-with-explanation",
                "content": "Intuition: This is very similar to the classic Knapsack problem (how many ways can you add these numbers to get target), except we also have to keep track of the combinations.\\n\\nConsider the example\\n\\n```[2,3,5]```, with target 8. To reach 8, our last step must be adding 2, 3, or 5. So we take all the combinations that add up to 6, 5, or 3 respectively, and add the remaining number rin the last step. To eliminate duplicates, we iterate over the candidates first. (This guarantees that each new combination we\\'re adding is distinct.)\\n\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0] = [[]]\\n        for candidate in candidates:\\n            for i in range(candidate, len(dp)): \\n                dp[i].extend(comb + [candidate] for comb in dp[i - candidate])\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```[2,3,5]```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0] = [[]]\\n        for candidate in candidates:\\n            for i in range(candidate, len(dp)): \\n                dp[i].extend(comb + [candidate] for comb in dp[i - candidate])\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 324671,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n\\tlet total = []\\n\\tfunction dfs (index, sum, result) {\\n\\t\\tif (sum === target) {\\n\\t\\t\\ttotal.push([...result])\\n\\t\\t}\\n\\t\\tif (sum > target) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfor (let i = index; i < candidates.length; i++) {\\n\\t\\t\\tresult.push(candidates[i])\\n\\t\\t\\tdfs(i, sum + candidates[i], result)\\n\\t\\t\\tresult.pop()\\n\\t\\t}\\n\\t}\\n\\tdfs(0, 0, [])\\n\\treturn total\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n\\tlet total = []\\n\\tfunction dfs (index, sum, result) {\\n\\t\\tif (sum === target) {\\n\\t\\t\\ttotal.push([...result])\\n\\t\\t}\\n\\t\\tif (sum > target) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfor (let i = index; i < candidates.length; i++) {\\n\\t\\t\\tresult.push(candidates[i])\\n\\t\\t\\tdfs(i, sum + candidates[i], result)\\n\\t\\t\\tresult.pop()\\n\\t\\t}\\n\\t}\\n\\tdfs(0, 0, [])\\n\\treturn total\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16608,
                "title": "backtracking-top-down-dp-bottom-up-dp-solutions-in-java",
                "content": "**Solution 1: Backtracking**\\n```\\nList<List<Integer>> combSum_BK(int[] a, int target) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    backtrack(a, target, result, new ArrayList<>(), 0);\\n    return result;\\n}\\n\\nvoid backtrack(int[] a, int target, List<List<Integer>> result, List<Integer> path, int start) {\\n    if (target == 0) {\\n        result.add(new ArrayList<>(path));\\n        return;\\n    }\\n    for (int i = start; i < a.length; i++) {\\n        if (target - a[i] < 0) continue;\\n        path.add(a[i]);\\n        backtrack(a, target - a[i], result, path, i);\\n        path.remove(path.size() - 1);\\n    }\\n}\\n```\\n\\n**Solution 2: Top-Down DP**\\n```\\nList<List<Integer>> combSum_DP_TopDown(int[] a, int target) {\\n    List<List<List<Integer>>> dp = new ArrayList<>(target);\\n    Arrays.sort(a);\\n    for (int i = 0; i <= target; i++) dp.add(null);\\n    return subProblem(a, target, dp);\\n}\\n\\nList<List<Integer>> subProblem(int[] a, int target, List<List<List<Integer>>> dp) {\\n    if (dp.get(target) != null) return dp.get(target);  // Already calculated. Reuse.\\n    List<List<Integer>> current = new ArrayList<>();    // Not yet calculated.\\n    for (int candidate : a) {\\n        if (target - candidate < 0) break;      // Subproblem doesn't exist.\\n        if (target - candidate == 0) {          // Subproblem is candidate itself.\\n            List<Integer> single = new ArrayList<>(Arrays.asList(candidate));\\n            current.add(single);\\n            continue;\\n        }\\n        List<List<Integer>> old = subProblem(a, target - candidate, dp); //check Subproblem\\n        for (List<Integer> path : old) {            // Add candidate to all results.\\n            if (candidate > path.get(0)) continue;\\n            List<Integer> new_path = new ArrayList<>();        \\n            new_path.add(candidate);\\n            new_path.addAll(path);\\n            current.add(new_path);\\n        }\\n    }\\n    dp.set(target, current);    // Current problem results memoized.\\n    return dp.get(target);\\n}\\n```\\n\\n**Solution 3: Bottom-Up DP**\\n```\\nList<List<Integer>> comb_DP_BottomUp(int[] a, int target) {\\n    Arrays.sort(a);\\n    List<List<List<Integer>>> dp = new ArrayList<>();\\n    for (int i = 1; i <= target; i++) {\\n        List<List<Integer>> current = new ArrayList<>();\\n        for (int candidate : a) {\\n            int sub = i - candidate;    \\n            if (sub < 0) break;         // subproblem doesn't exist.\\n            if (sub == 0) {             // subproblem is candidate itself. \\n                current.add(Arrays.asList(candidate));              \\n                continue;\\n            }\\n            for (List<Integer> path : dp.get(sub - 1)) {    // subproblem is reused.\\n                if (candidate > path.get(0)) continue;\\n                List<Integer> new_path = new ArrayList<>();\\n                new_path.add(candidate);\\n                new_path.addAll(path);\\n                current.add(new_path);\\n            }\\n        }\\n        dp.add(current);\\n    }\\n    return dp.get(target - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nList<List<Integer>> combSum_BK(int[] a, int target) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    backtrack(a, target, result, new ArrayList<>(), 0);\\n    return result;\\n}\\n\\nvoid backtrack(int[] a, int target, List<List<Integer>> result, List<Integer> path, int start) {\\n    if (target == 0) {\\n        result.add(new ArrayList<>(path));\\n        return;\\n    }\\n    for (int i = start; i < a.length; i++) {\\n        if (target - a[i] < 0) continue;\\n        path.add(a[i]);\\n        backtrack(a, target - a[i], result, path, i);\\n        path.remove(path.size() - 1);\\n    }\\n}\\n```\n```\\nList<List<Integer>> combSum_DP_TopDown(int[] a, int target) {\\n    List<List<List<Integer>>> dp = new ArrayList<>(target);\\n    Arrays.sort(a);\\n    for (int i = 0; i <= target; i++) dp.add(null);\\n    return subProblem(a, target, dp);\\n}\\n\\nList<List<Integer>> subProblem(int[] a, int target, List<List<List<Integer>>> dp) {\\n    if (dp.get(target) != null) return dp.get(target);  // Already calculated. Reuse.\\n    List<List<Integer>> current = new ArrayList<>();    // Not yet calculated.\\n    for (int candidate : a) {\\n        if (target - candidate < 0) break;      // Subproblem doesn't exist.\\n        if (target - candidate == 0) {          // Subproblem is candidate itself.\\n            List<Integer> single = new ArrayList<>(Arrays.asList(candidate));\\n            current.add(single);\\n            continue;\\n        }\\n        List<List<Integer>> old = subProblem(a, target - candidate, dp); //check Subproblem\\n        for (List<Integer> path : old) {            // Add candidate to all results.\\n            if (candidate > path.get(0)) continue;\\n            List<Integer> new_path = new ArrayList<>();        \\n            new_path.add(candidate);\\n            new_path.addAll(path);\\n            current.add(new_path);\\n        }\\n    }\\n    dp.set(target, current);    // Current problem results memoized.\\n    return dp.get(target);\\n}\\n```\n```\\nList<List<Integer>> comb_DP_BottomUp(int[] a, int target) {\\n    Arrays.sort(a);\\n    List<List<List<Integer>>> dp = new ArrayList<>();\\n    for (int i = 1; i <= target; i++) {\\n        List<List<Integer>> current = new ArrayList<>();\\n        for (int candidate : a) {\\n            int sub = i - candidate;    \\n            if (sub < 0) break;         // subproblem doesn't exist.\\n            if (sub == 0) {             // subproblem is candidate itself. \\n                current.add(Arrays.asList(candidate));              \\n                continue;\\n            }\\n            for (List<Integer> path : dp.get(sub - 1)) {    // subproblem is reused.\\n                if (candidate > path.get(0)) continue;\\n                List<Integer> new_path = new ArrayList<>();\\n                new_path.add(candidate);\\n                new_path.addAll(path);\\n                current.add(new_path);\\n            }\\n        }\\n        dp.add(current);\\n    }\\n    return dp.get(target - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16658,
                "title": "4-problems-1-solution-java-solutions-for-combinations-combination-sum1-combination-sum2-combination-sum3",
                "content": "**Combinations**\\n\\n```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum1**\\n\\n\\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum2**\\n\\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\\n\\n**CombinationSum3**\\n\\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Combinatorics"
                ],
                "code": "```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16666,
                "title": "almost-same-solution-for-two-problems-combination-sum-and-combination-sum-ii-c-code-with-comments-fast",
                "content": "**Combination Sum** \\n\\ncode is explained as comments.\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                   // if current element is bigger than the assigned target, there is \\n                   //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                   //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                   // keep searching for new elements with start as i since here duplicates are allowed\\n                elementSum(candidates,res,elements,target-candidates[i],i);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n**Combination Sum II**\\n\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                 // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                 // we always want to count the first element in this recursive step even if it is the same \\n                 // as one before. To avoid overcounting, we just ignore the duplicates\\n                 // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                  // if current element is bigger than the assigned target, there is \\n                  //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                  //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                  // keep searching for new element with start as i + 1 because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n\\nThank you",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "**Combination Sum** \\n\\ncode is explained as comments.\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                   // if current element is bigger than the assigned target, there is \\n                   //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                   //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                   // keep searching for new elements with start as i since here duplicates are allowed\\n                elementSum(candidates,res,elements,target-candidates[i],i);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n**Combination Sum II**\\n\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                 // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                 // we always want to count the first element in this recursive step even if it is the same \\n                 // as one before. To avoid overcounting, we just ignore the duplicates\\n                 // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                  // if current element is bigger than the assigned target, there is \\n                  //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                  //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                  // keep searching for new element with start as i + 1 because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n\\nThank you",
                "codeTag": "Unknown"
            },
            {
                "id": 3919161,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void solve(int ind, vector<int>&candidates, int &target, int sum, vector<vector<int>>&result , vector<int>&ans) \\n    {\\n        if(ind == candidates.size())\\n        {\\n            // if(sum == target)\\n            // {\\n            //     result.push_back(ans);\\n            // }\\n            return;\\n        }\\n\\n        if(sum >= target)\\n        {\\n            if(sum == target)\\n            {\\n                result.push_back(ans);\\n            }\\n            return;\\n        }\\n            ans.push_back(candidates[ind]);\\n            sum = sum + candidates[ind];\\n            solve(ind, candidates, target, sum, result, ans);\\n\\n            ans.pop_back();\\n            sum -= candidates[ind];\\n            solve(ind+1, candidates, target, sum, result, ans);\\n         \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) \\n    {\\n        vector<vector<int>>result;\\n        vector<int>ans;\\n        solve(0, candidates, target, 0, result, ans);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void solve(int ind, vector<int>&candidates, int &target, int sum, vector<vector<int>>&result , vector<int>&ans) \\n    {\\n        if(ind == candidates.size())\\n        {\\n            // if(sum == target)\\n            // {\\n            //     result.push_back(ans);\\n            // }\\n            return;\\n        }\\n\\n        if(sum >= target)\\n        {\\n            if(sum == target)\\n            {\\n                result.push_back(ans);\\n            }\\n            return;\\n        }\\n            ans.push_back(candidates[ind]);\\n            sum = sum + candidates[ind];\\n            solve(ind, candidates, target, sum, result, ans);\\n\\n            ans.pop_back();\\n            sum -= candidates[ind];\\n            solve(ind+1, candidates, target, sum, result, ans);\\n         \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) \\n    {\\n        vector<vector<int>>result;\\n        vector<int>ans;\\n        solve(0, candidates, target, 0, result, ans);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631074,
                "title": "most-optimized-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j,n,k-v[j],v,tmp,ans);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& v, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = v.size();\\n        solve(0,n,target,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j,n,k-v[j],v,tmp,ans);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& v, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = v.size();\\n        solve(0,n,target,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193246,
                "title": "simple-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184895,
                "title": "all-in-one-iterative-vs-recursive-tree-diagram-detailed-explained-meme",
                "content": "![backtea.jpeg](https://assets.leetcode.com/users/images/8643339f-f6fa-43ec-91c4-47f8007c230d_1676377995.5688634.jpeg)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs you might have noticed that we are not considering the whole array as possible options at every level, because we want unique combinations.\\ne.g. at the node [2, 2, 3], the possible options for the next level are only [3, 5]. Why?? because if we consider the whole array as possible options, then we we will end up with [2, 2, 3, 2] (with 2 as a possible option), which has already been checked as [2, 2, 2, 3] (see the tree). So to make the solution unique we are only considering the part of the array from current last element to the end element (like in this example).\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n\\n![disc.jpeg](https://assets.leetcode.com/users/images/6d68f170-7995-4c8e-9548-933a3412e358_1676378568.4791667.jpeg)\\n\\n\\nHow Tree diagram will work-\\n\\nWe will make a op array, that contains all the possible combinations sum of the array.\\n\\nWe will start from the index 0 and as we already discussed that for each and every element we have two possibility whether to include this element in making our answer or not, so we will explore all possibilities.\\n\\nop aray represents which elements this array contains now in making combination sum.\\n\\nTarget represents the left combination sum that we have to make. Intially it is same as the original target that we have to make.\\n\\nThe red cursor below the array, points that on which index we are currently standing.\\n\\nIf at any point our target becomes zero, then we will include that combination in our answer array saying that yes, this is an possible combination and return from there.\\n\\nIf at any point our target becomes less than zero, then we return from there saying that we are never able to make our cbination sum by this combination.\\n\\nIf at any point we cross the size of the array then we will return from there saying that no more element is left to choose.\\n\\nAs we dicussed for every element we have two choices whether to include in our answer or not include in our answer.\\n\\nSo, if we do not a include a element in our answer then without decreasing target sum, we will move to next index. Why we do not decrese sum? because we will choose not to include in this element in our combination, hence it does not contribute in making our sum.\\n\\nBut, if we choose a particular element to include in our answer, then we will decrease the target sum but we will not move to next index. Why we will not move to next index? because for a specific element we have unlimited number of choice, so it may be possible that specific element again contribute in making our sum.\\n\\nIf Image is not cleary visible to you, then for that I have uploaded it on my drive.\\n\\nYou may visit this link to see Image in good quality.\\n\\n# Code\\n```1_c++_recursive []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n``` \\n```PYTHON_ITERATIVE []\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```\\n```c++_recursive []\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\\n```java_iterative []\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\n  private void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curSum>target) return;\\n        if(curSum==target){\\n            ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        for(int j=curInd;j<A.length;j++){\\n            subList.add(A[j]);\\n            dfs(ans,subList,A,target,j,curSum+A[j]);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n```\\n```c++ []\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n```\\n```java_recur []\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\nprivate void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curInd==A.length){\\n            if(target==curSum) ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        if((curSum+A[curInd])<=target){\\n            subList.add(A[curInd]);\\n            dfs(ans,subList,A,target,curInd,curSum+A[curInd]);\\n            subList.remove(subList.size()-1);\\n        }\\n        dfs(ans,subList,A,target,curInd+1,curSum);\\n    }\\n```\\n# PYTHON\\n\\n```Combinations []\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\\n```Permutations_I []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\\n```Permutations_II []\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n```Subsets_1 []\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n```Subsets_II []\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n```Comb_Sum []\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n```Comb_sum_II []\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```\\n# java \\n\\n```subset []\\nSubsets : https://leetcode.com/problems/subsets/\\n\\npublic List<List<Integer>> subsets(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n}\\n```\\n```subset2 []\\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n} \\n```\\n```perm []\\nPermutations : https://leetcode.com/problems/permutations/\\n\\npublic List<List<Integer>> permute(int[] nums) {\\n   List<List<Integer>> list = new ArrayList<>();\\n   // Arrays.sort(nums); // not necessary\\n   backtrack(list, new ArrayList<>(), nums);\\n   return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n   if(tempList.size() == nums.length){\\n      list.add(new ArrayList<>(tempList));\\n   } else{\\n      for(int i = 0; i < nums.length; i++){ \\n         if(tempList.contains(nums[i])) continue; // element already exists, skip\\n         tempList.add(nums[i]);\\n         backtrack(list, tempList, nums);\\n         tempList.remove(tempList.size() - 1);\\n      }\\n   }\\n} \\n```\\n```permu2 []\\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n    if(tempList.size() == nums.length){\\n        list.add(new ArrayList<>(tempList));\\n    } else{\\n        for(int i = 0; i < nums.length; i++){\\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n            used[i] = true; \\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, used);\\n            used[i] = false; \\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n```combSum []\\nCombination Sum : https://leetcode.com/problems/combination-sum/\\n\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n```com_sum2 []\\nCombination Sum II (can\\'t reuse same element) : https://leetcode.com/problems/combination-sum-ii/\\n\\npublic List<List<Integer>> combinationSum2(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n    \\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n            tempList.remove(tempList.size() - 1); \\n        }\\n    }\\n} \\n```\\n```palin_part []\\nPalindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/\\npublic List<List<String>> partition(String s) {\\n   List<List<String>> list = new ArrayList<>();\\n   backtrack(list, new ArrayList<>(), s, 0);\\n   return list;\\n}\\n\\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n   if(start == s.length())\\n      list.add(new ArrayList<>(tempList));\\n   else{\\n      for(int i = start; i < s.length(); i++){\\n         if(isPalindrome(s, start, i)){\\n            tempList.add(s.substring(start, i + 1));\\n            backtrack(list, tempList, s, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n         }\\n      }\\n   }\\n}\\n\\npublic boolean isPalindrome(String s, int low, int high){\\n   while(low < high)\\n      if(s.charAt(low++) != s.charAt(high--)) return false;\\n   return true;\\n} \\n```\\n\\n# c++ \\n```comsum1 []\\nAccepted 16ms c++ solution use backtracking for Combination Sum:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n            combination.push_back(candidates[i]);\\n            combinationSum(candidates, target - candidates[i], res, combination, i);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n```comsum2 []\\nAccepted 12ms c++ solution use backtracking for Combination Sum II:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum2(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n            if (i == begin || candidates[i] != candidates[i - 1]) {\\n                combination.push_back(candidates[i]);\\n                combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                combination.pop_back();\\n            }\\n    }\\n};\\n```\\n```comSum2 []\\nAccepted 0ms c++ solution use backtracking for Combination Sum III:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum3(n, res, combination, 1, k);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        else if (!need)\\n            return;\\n        for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n            combination.push_back(i);\\n            combinationSum3(target - i, res, combination, i + 1, need - 1);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity:o(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![mem2.png](https://assets.leetcode.com/users/images/8b0c18c6-2e7d-4ef3-a11b-1ff369dc24f2_1676378307.5784204.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```1_c++_recursive []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\n```PYTHON_ITERATIVE []\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```\n```c++_recursive []\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\n```java_iterative []\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\n  private void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curSum>target) return;\\n        if(curSum==target){\\n            ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        for(int j=curInd;j<A.length;j++){\\n            subList.add(A[j]);\\n            dfs(ans,subList,A,target,j,curSum+A[j]);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n```\n```c++ []\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n```\n```java_recur []\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\nprivate void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curInd==A.length){\\n            if(target==curSum) ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        if((curSum+A[curInd])<=target){\\n            subList.add(A[curInd]);\\n            dfs(ans,subList,A,target,curInd,curSum+A[curInd]);\\n            subList.remove(subList.size()-1);\\n        }\\n        dfs(ans,subList,A,target,curInd+1,curSum);\\n    }\\n```\n```Combinations []\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```Permutations_I []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```Permutations_II []\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```Subsets_1 []\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```Subsets_II []\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```Comb_Sum []\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```Comb_sum_II []\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```\n```subset []\\nSubsets : https://leetcode.com/problems/subsets/\\n\\npublic List<List<Integer>> subsets(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n}\\n```\n```subset2 []\\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n} \\n```\n```perm []\\nPermutations : https://leetcode.com/problems/permutations/\\n\\npublic List<List<Integer>> permute(int[] nums) {\\n   List<List<Integer>> list = new ArrayList<>();\\n   // Arrays.sort(nums); // not necessary\\n   backtrack(list, new ArrayList<>(), nums);\\n   return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n   if(tempList.size() == nums.length){\\n      list.add(new ArrayList<>(tempList));\\n   } else{\\n      for(int i = 0; i < nums.length; i++){ \\n         if(tempList.contains(nums[i])) continue; // element already exists, skip\\n         tempList.add(nums[i]);\\n         backtrack(list, tempList, nums);\\n         tempList.remove(tempList.size() - 1);\\n      }\\n   }\\n} \\n```\n```permu2 []\\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n    if(tempList.size() == nums.length){\\n        list.add(new ArrayList<>(tempList));\\n    } else{\\n        for(int i = 0; i < nums.length; i++){\\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n            used[i] = true; \\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, used);\\n            used[i] = false; \\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```combSum []\\nCombination Sum : https://leetcode.com/problems/combination-sum/\\n\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```com_sum2 []\\nCombination Sum II (can\\'t reuse same element) : https://leetcode.com/problems/combination-sum-ii/\\n\\npublic List<List<Integer>> combinationSum2(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n    \\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n            tempList.remove(tempList.size() - 1); \\n        }\\n    }\\n} \\n```\n```palin_part []\\nPalindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/\\npublic List<List<String>> partition(String s) {\\n   List<List<String>> list = new ArrayList<>();\\n   backtrack(list, new ArrayList<>(), s, 0);\\n   return list;\\n}\\n\\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n   if(start == s.length())\\n      list.add(new ArrayList<>(tempList));\\n   else{\\n      for(int i = start; i < s.length(); i++){\\n         if(isPalindrome(s, start, i)){\\n            tempList.add(s.substring(start, i + 1));\\n            backtrack(list, tempList, s, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n         }\\n      }\\n   }\\n}\\n\\npublic boolean isPalindrome(String s, int low, int high){\\n   while(low < high)\\n      if(s.charAt(low++) != s.charAt(high--)) return false;\\n   return true;\\n} \\n```\n```comsum1 []\\nAccepted 16ms c++ solution use backtracking for Combination Sum:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n            combination.push_back(candidates[i]);\\n            combinationSum(candidates, target - candidates[i], res, combination, i);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\n```comsum2 []\\nAccepted 12ms c++ solution use backtracking for Combination Sum II:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum2(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n            if (i == begin || candidates[i] != candidates[i - 1]) {\\n                combination.push_back(candidates[i]);\\n                combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                combination.pop_back();\\n            }\\n    }\\n};\\n```\n```comSum2 []\\nAccepted 0ms c++ solution use backtracking for Combination Sum III:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum3(n, res, combination, 1, k);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        else if (!need)\\n            return;\\n        for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n            combination.push_back(i);\\n            combinationSum3(target - i, res, combination, i + 1, need - 1);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515817,
                "title": "combination-sum-python-faster-than-98-recursive-approach",
                "content": "```\\n# There are two possibities of making a combination, i.e., to take an element or to not take an element.\\n\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        final = []\\n        def get_combinations(ind, target, arr, result):\\n            if ind == len(arr):\\n                if target == 0:\\n                    final.append(result[:])\\n                return\\n            if arr[ind] <= target:\\n                result.append(arr[ind])\\n                get_combinations(ind, target-arr[ind], arr, result)  # to take the element\\n                result.pop()\\n            get_combinations(ind+1, target, arr, result)  # to not take the element\\n        get_combinations(0, target, candidates, [])\\n        return final\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# There are two possibities of making a combination, i.e., to take an element or to not take an element.\\n\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        final = []\\n        def get_combinations(ind, target, arr, result):\\n            if ind == len(arr):\\n                if target == 0:\\n                    final.append(result[:])\\n                return\\n            if arr[ind] <= target:\\n                result.append(arr[ind])\\n                get_combinations(ind, target-arr[ind], arr, result)  # to take the element\\n                result.pop()\\n            get_combinations(ind+1, target, arr, result)  # to not take the element\\n        get_combinations(0, target, candidates, [])\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382056,
                "title": "python-faster-than-92-easy-solution",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        path = []\\n        answer = []\\n        def dp(idx, total):\\n            if total == target:\\n                answer.append(path[:])\\n                return\\n            if total > target:\\n                return\\n            \\n            for i in range(idx, len(candidates)):\\n                path.append(candidates[i])\\n                dp(i, total + candidates[i])\\n                path.pop()\\n        \\n        dp(0, 0)\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        path = []\\n        answer = []\\n        def dp(idx, total):\\n            if total == target:\\n                answer.append(path[:])\\n                return\\n            if total > target:\\n                return\\n            \\n            for i in range(idx, len(candidates)):\\n                path.append(candidates[i])\\n                dp(i, total + candidates[i])\\n                path.pop()\\n        \\n        dp(0, 0)\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378912,
                "title": "easy-c-detailed-explanation",
                "content": "For this a prior knowledge of recursion and backtracking is required thats it \\n\\n1st Click why recursion --- Since we need to know every kind of combination and also cant possible with regular                                               for and while loop \\n\\n2nd click ---- either include || either we not include it in our data structure approach that get in mind\\n\\nIn this method we just reduce the target till it become equal to 0 by taking each and every possible case of including or not including the combination \\n\\nthinking of approach is difficult but understanding it is much more easier \\n\\n\\nclass Solution {\\n    \\npublic:\\n     void FindCombination( int i , int target , vector<int>&arr , vector<int>&ds , vector<vector<int>>&ans)\\n     {\\n         if(i==arr.size())\\n         {\\n              if(target==0)\\n             {\\n                   ans.push_back(ds) ; \\n             }  \\n             return ; \\n         }      \\n         if(target >= arr[i])\\n         {\\n               ds.push_back(arr[i]) ; \\n              FindCombination(i , target-arr[i] , arr , ds , ans) ; \\n\\t\\t\\t  ds.pop_back() ; // here we are not increasing index so that same element \\n         }                     // pop_back() used for all not including conditions\\n\\t\\t     FindCombination(i+1,target,arr,ds,ans) ; \\n     }\\n   \\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans ; \\n        vector<int>ds ;  // here we simply declare everything we required  \\n        FindCombination(0,target,candidates,ds,ans) ;  // pass it to our recursive function \\n        return ans ; \\n    }\\n};\\n\\nenjoy learning || enjoy leet code \\n\\nif everything is clear make sure to give a up vote",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\npublic:\\n     void FindCombination( int i , int target , vector<int>&arr , vector<int>&ds , vector<vector<int>>&ans)\\n     {\\n         if(i==arr.size())\\n         {\\n              if(target==0)\\n             {\\n                   ans.push_back(ds) ; \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1777617,
                "title": "js-using-recurison",
                "content": "```\\n\\nconst combinationSum = function(candidates, target) {\\n    const len = candidates.length;\\n    const result = [];\\n    \\n    const recursiveFxn = (sum, idx, arr) => {\\n        if(idx >= len) {\\n            return;\\n        }\\n        if(sum < 0) {\\n            return;\\n        }\\n        if(sum === 0) {\\n            result.push([...arr]);\\n        }\\n        for(let i = idx; i < len; i++) {\\n            arr.push(candidates[i]);\\n            recursiveFxn(sum-candidates[i], i, arr);\\n            arr.pop(candidates[i]);\\n        }\\n        \\n    };\\n\\n    recursiveFxn(target, 0, []);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst combinationSum = function(candidates, target) {\\n    const len = candidates.length;\\n    const result = [];\\n    \\n    const recursiveFxn = (sum, idx, arr) => {\\n        if(idx >= len) {\\n            return;\\n        }\\n        if(sum < 0) {\\n            return;\\n        }\\n        if(sum === 0) {\\n            result.push([...arr]);\\n        }\\n        for(let i = idx; i < len; i++) {\\n            arr.push(candidates[i]);\\n            recursiveFxn(sum-candidates[i], i, arr);\\n            arr.pop(candidates[i]);\\n        }\\n        \\n    };\\n\\n    recursiveFxn(target, 0, []);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777476,
                "title": "python3-easy-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        def dfs(i,arr,total):\\n            if total==target:\\n                ans.append(arr.copy())\\n                return\\n            if i>=len(candidates) or total>target:\\n                return\\n            \\n            arr.append(candidates[i])\\n            dfs(i, arr, total+candidates[i])\\n            arr.pop()\\n            dfs(i+1, arr, total)\\n        dfs(0,[],0)\\n        return ans\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        def dfs(i,arr,total):\\n            if total==target:\\n                ans.append(arr.copy())\\n                return\\n            if i>=len(candidates) or total>target:\\n                return\\n            \\n            arr.append(candidates[i])\\n            dfs(i, arr, total+candidates[i])\\n            arr.pop()\\n            dfs(i+1, arr, total)\\n        dfs(0,[],0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777439,
                "title": "javascript-intutive-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(arr, target) {\\n    let result = []\\n    \\n    findCombination();\\n    return result\\n    \\n    function findCombination(start = 0, sum =0, ans = []){\\n        if(sum > target) return;\\n        if(sum === target){\\n            result.push(ans.slice());\\n        }\\n        \\n        for(let i=start; i<arr.length; i++){\\n            findCombination(i, sum + arr[i], [...ans, arr[i]]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(arr, target) {\\n    let result = []\\n    \\n    findCombination();\\n    return result\\n    \\n    function findCombination(start = 0, sum =0, ans = []){\\n        if(sum > target) return;\\n        if(sum === target){\\n            result.push(ans.slice());\\n        }\\n        \\n        for(let i=start; i<arr.length; i++){\\n            findCombination(i, sum + arr[i], [...ans, arr[i]]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640643,
                "title": "easy-fast-simple-98-92-76-ms-41-1-mb",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    const resArr = []\\n    \\n    const dfs = (i = 0, sum = 0, currentArr = []) => {\\n        if (sum > target) return\\n        if (sum === target) {\\n            resArr.push([...currentArr])\\n            return\\n        }\\n        for (let j = i; j < candidates.length; j++) {\\n            currentArr.push(candidates[j])\\n            dfs(j, sum + candidates[j], currentArr)\\n            currentArr.pop()\\n        }\\n    }\\n    \\n    dfs()\\n    return resArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    const resArr = []\\n    \\n    const dfs = (i = 0, sum = 0, currentArr = []) => {\\n        if (sum > target) return\\n        if (sum === target) {\\n            resArr.push([...currentArr])\\n            return\\n        }\\n        for (let j = i; j < candidates.length; j++) {\\n            currentArr.push(candidates[j])\\n            dfs(j, sum + candidates[j], currentArr)\\n            currentArr.pop()\\n        }\\n    }\\n    \\n    dfs()\\n    return resArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606874,
                "title": "python-recursion-faster-than-97-9-with-comments-explanation",
                "content": "Pretty simple recusion here.  \\nFirst we verify that the list is sorted smallest to largest (problem didn\\'t specify), then we call into the recursive funciton which starts at the largest number and work backwards.\\n\\nIf the current value matches the target, we add it to the list of combinations on its own.\\n If value > target, or  target - value < smallest candidate, we skip this value.\\n For all other values, pass a slice of the candidate list up to and including the current index back into the recursive function with a new target of target-value.\\n  Then append the current value to all of those sub combinations and pass them back up.\\n\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # Edge Case\\n        if not candidates:\\n            return []\\n        \\n        # Define recursive function\\n        def rc(nums: list[int], target: int) -> list[list[int]]:\\n            nonlocal low_num\\n            combos = []\\n            for i in range(len(nums)-1, -1, -1):\\n                cur_val = nums[i]\\n                if cur_val == target:\\n                    combos.append([target])\\n                elif cur_val + low_num > target:\\n                     # Don\\'t waste time processing sub_combos for a number too large to be in any\\n                    continue\\n                else:\\n                    # Pass the list including current value into function to get all combos for sub-target.\\n                    sub_combos = rc(nums[:i+1], target - cur_val)\\n                    # Now add the current value to all of those combinations.\\n                    for sub in sub_combos:\\n                        sub.append(cur_val)\\n                        combos.append(sub)\\n            return combos\\n\\n        candidates.sort()   # The problem didn\\'t specify that candidates would be ordered.\\n        low_num = candidates[0]    # Used in rc to stop processing values that won\\'t be in any subgroup\\n        return rc(candidates, target)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6a2c3cd2-9879-4bbe-b588-8bbc7a3ce0a5_1638402728.3166742.png)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # Edge Case\\n        if not candidates:\\n            return []\\n        \\n        # Define recursive function\\n        def rc(nums: list[int], target: int) -> list[list[int]]:\\n            nonlocal low_num\\n            combos = []\\n            for i in range(len(nums)-1, -1, -1):\\n                cur_val = nums[i]\\n                if cur_val == target:\\n                    combos.append([target])\\n                elif cur_val + low_num > target:\\n                     # Don\\'t waste time processing sub_combos for a number too large to be in any\\n                    continue\\n                else:\\n                    # Pass the list including current value into function to get all combos for sub-target.\\n                    sub_combos = rc(nums[:i+1], target - cur_val)\\n                    # Now add the current value to all of those combinations.\\n                    for sub in sub_combos:\\n                        sub.append(cur_val)\\n                        combos.append(sub)\\n            return combos\\n\\n        candidates.sort()   # The problem didn\\'t specify that candidates would be ordered.\\n        low_num = candidates[0]    # Used in rc to stop processing values that won\\'t be in any subgroup\\n        return rc(candidates, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573007,
                "title": "python-using-optimized-decision-tree",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        result = []\\n        def dfs(i, cur, total):\\n            if total == target:\\n                result.append(cur.copy())\\n                return\\n            if i >= len(candidates) or total > target: return\\n            cur.append(candidates[i])\\n            dfs(i, cur, total+candidates[i])\\n            cur.pop()\\n            dfs(i+1, cur, total)\\n            \\n        dfs(0, [], 0)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        result = []\\n        def dfs(i, cur, total):\\n            if total == target:\\n                result.append(cur.copy())\\n                return\\n            if i >= len(candidates) or total > target: return\\n            cur.append(candidates[i])\\n            dfs(i, cur, total+candidates[i])\\n            cur.pop()\\n            dfs(i+1, cur, total)\\n            \\n        dfs(0, [], 0)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435980,
                "title": "javascript-dfs-151ms",
                "content": "Did 40 https://leetcode.com/problems/combination-sum-ii/discuss/1435950/javascript-dfs-128ms first, small change\\n```\\nlet can, n;\\nconst combinationSum = (a, target) => {\\n    a.sort((x, y) => x - y);\\n    let res = [];\\n    can = a, n = a.length;\\n    dfs(target, 0, res, []);\\n    return res;\\n};\\n\\nconst dfs = (sum, start, res, path) => {\\n    if (sum == 0) return res.push([...path]);\\n    for (let i = start; i < n; i++) {\\n        if (can[i] > sum) return;\\n        path.push(can[i]);\\n        dfs(sum - can[i], i, res, path); // allow select the same number, change i + 1 to i \\n        path.pop();\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet can, n;\\nconst combinationSum = (a, target) => {\\n    a.sort((x, y) => x - y);\\n    let res = [];\\n    can = a, n = a.length;\\n    dfs(target, 0, res, []);\\n    return res;\\n};\\n\\nconst dfs = (sum, start, res, path) => {\\n    if (sum == 0) return res.push([...path]);\\n    for (let i = start; i < n; i++) {\\n        if (can[i] > sum) return;\\n        path.push(can[i]);\\n        dfs(sum - can[i], i, res, path); // allow select the same number, change i + 1 to i \\n        path.pop();\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374609,
                "title": "java-backtracking-3ms",
                "content": "```\\nclass Solution \\n{\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> curr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack( res , curr , 0 ,target,candidates,0);    \\n        return res;\\n    }\\n    public void backtrack( List<List<Integer>> res , List<Integer> curr , int sum ,int target,int[] candidates,int index)\\n    {\\n        if( sum == target )\\n        {\\n            if( !res.contains(curr) )\\n            {\\n                res.add(new ArrayList(curr));    \\n            }\\n            return;\\n        }\\n        for( int i = index ; i < candidates.length ; i++ )\\n        {\\n            if( sum + candidates[i] > target )\\n            {\\n                return;\\n            }\\n            curr.add( candidates[i] );\\n            sum = sum + candidates[i];\\n            backtrack( res , curr , sum , target , candidates ,i);  \\n            //adding index so it does\\'nt start from index 0 if current index is 1-n cauze that possiblity will have\\n            // already been covered when index was 0\\n\\t\\t\\t/*\\n\\t\\t\\teg [2,2,3] has been covered when index was at 0\\n\\t\\t\\tso we need not traverse to index 0 to get [3,2,2] because it\\'s already stored in res.\\n\\t\\t\\t*/\\n            curr.remove( curr.size() - 1 );\\n            sum = sum - candidates[i];\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> curr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack( res , curr , 0 ,target,candidates,0);    \\n        return res;\\n    }\\n    public void backtrack( List<List<Integer>> res , List<Integer> curr , int sum ,int target,int[] candidates,int index)\\n    {\\n        if( sum == target )\\n        {\\n            if( !res.contains(curr) )\\n            {\\n                res.add(new ArrayList(curr));    \\n            }\\n            return;\\n        }\\n        for( int i = index ; i < candidates.length ; i++ )\\n        {\\n            if( sum + candidates[i] > target )\\n            {\\n                return;\\n            }\\n            curr.add( candidates[i] );\\n            sum = sum + candidates[i];\\n            backtrack( res , curr , sum , target , candidates ,i);  \\n            //adding index so it does\\'nt start from index 0 if current index is 1-n cauze that possiblity will have\\n            // already been covered when index was 0\\n\\t\\t\\t/*\\n\\t\\t\\teg [2,2,3] has been covered when index was at 0\\n\\t\\t\\tso we need not traverse to index 0 to get [3,2,2] because it\\'s already stored in res.\\n\\t\\t\\t*/\\n            curr.remove( curr.size() - 1 );\\n            sum = sum - candidates[i];\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283302,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(candidates,0,target,result,new ArrayList());\\n        return result;\\n    }\\n    public void recur(int[] c,int start,int target,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(target<0)\\n            return;\\n        if(target==0)\\n            result.add(new ArrayList(list));\\n        for(int i=start;i<c.length;i++)\\n        {\\n            list.add(c[i]);\\n            recur(c,i,target-c[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(candidates,0,target,result,new ArrayList());\\n        return result;\\n    }\\n    public void recur(int[] c,int start,int target,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(target<0)\\n            return;\\n        if(target==0)\\n            result.add(new ArrayList(list));\\n        for(int i=start;i<c.length;i++)\\n        {\\n            list.add(c[i]);\\n            recur(c,i,target-c[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204196,
                "title": "lessons-learned",
                "content": "**Related problems**: All try to teach recursion + loop combo\\n* https://leetcode.com/problems/permutations/ : **(Basics)** on every recursion, iteration starts from 0th index \\n* https://leetcode.com/problems/permutations-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern \\n* https://leetcode.com/problems/combinations/ : **(Basics)** on every recursion, iteration starts from next index (ie, adjacent index to parent recursion iteration index) \\n* https://leetcode.com/problems/combination-sum/ : **(Basics)** sorting helps to prune\\n* https://leetcode.com/problems/combination-sum-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern and Sort+skip adjacent duplicate elements pattern\\n* https://leetcode.com/problems/restore-ip-addresses/ : **(Advanced)** includes special char \\'.\\', StringBuilder, number conversion, number validity check, looped deletion\\n* https://leetcode.com/problems/24-game/ : **(Advanced)** \\n* If you have done the above problems, no need to do: https://leetcode.com/problems/combination-sum-iii/, https://leetcode.com/problems/subsets/, https://leetcode.com/problems/subsets-ii/, https://leetcode.com/problems/letter-combinations-of-a-phone-number/ . These are very similar to the above ones and you won\\'t gain much from these.\\n\\n**Code**:\\n```\\n// My first code\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Better: if you sort the candidates first, then you can skip computing next elements (might be a million next elements) by exiting early from the for loop as soon as you see a candidate that is bigger than the remaining target. Similar technique (not sorting always) can be applied in various backtracking problems to prune the recursive tree.\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length && sum + nums[i] <= target; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Best: Nothing much. Just removed the redundant variable for \\'sum\\' and used \\'target\\' alone. Could use this little trick for various sum problems (already found in tree problems)\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length && target - nums[i] >= 0; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// My first code\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Better: if you sort the candidates first, then you can skip computing next elements (might be a million next elements) by exiting early from the for loop as soon as you see a candidate that is bigger than the remaining target. Similar technique (not sorting always) can be applied in various backtracking problems to prune the recursive tree.\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length && sum + nums[i] <= target; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Best: Nothing much. Just removed the redundant variable for \\'sum\\' and used \\'target\\' alone. Could use this little trick for various sum problems (already found in tree problems)\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length && target - nums[i] >= 0; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141751,
                "title": "python3-no-sorting",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        def backtracking(output,start,res):\\n            if res == target:\\n                ans.append(list(output))\\n                return\\n            \\n            for i in range(start,len(candidates)):\\n                if res<=target:\\n                    output.append(candidates[i])\\n                    backtracking(output,i,res+candidates[i])\\n                    output.pop()\\n\\n        \\n        backtracking([],0,0)  \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        def backtracking(output,start,res):\\n            if res == target:\\n                ans.append(list(output))\\n                return\\n            \\n            for i in range(start,len(candidates)):\\n                if res<=target:\\n                    output.append(candidates[i])\\n                    backtracking(output,i,res+candidates[i])\\n                    output.pop()\\n\\n        \\n        backtracking([],0,0)  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121660,
                "title": "share-my-c-recursive-solution-easy-and-clean-code",
                "content": "### **Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> tmp;\\n        helper(candidates, target, 0, res, tmp);\\n        return res;\\n    }\\n    void helper(vector<int>& candidates, int target, int start, vector<vector<int>>& res, vector<int>& tmp){\\n        for (int i = start; i < candidates.size(); ++i){\\n            int diff = target - candidates[i];\\n            if (diff == 0){\\n                tmp.push_back(candidates[i]);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            else if (diff > 0){\\n                tmp.push_back(candidates[i]);\\n                helper(candidates, diff, i, res, tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n### **Performance**\\n- Runtime: 8 ms, faster than 78.42%\\n- Memory Usage: 10.8 MB, less than 91.65%",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> tmp;\\n        helper(candidates, target, 0, res, tmp);\\n        return res;\\n    }\\n    void helper(vector<int>& candidates, int target, int start, vector<vector<int>>& res, vector<int>& tmp){\\n        for (int i = start; i < candidates.size(); ++i){\\n            int diff = target - candidates[i];\\n            if (diff == 0){\\n                tmp.push_back(candidates[i]);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            else if (diff > 0){\\n                tmp.push_back(candidates[i]);\\n                helper(candidates, diff, i, res, tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564870,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568512,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1565727,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1566902,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1569455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567175,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568222,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568863,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567176,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1564870,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568512,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1565727,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1566902,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1569455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567175,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568222,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568863,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567176,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1872909,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1737630,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1572487,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568861,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568862,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1877541,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568860,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1957710,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1845108,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1575383,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1572719,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1572280,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1571096,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1568859,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 2050310,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 2027858,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1910929,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1878594,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1863942,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1856096,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1853675,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1838875,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1816295,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1812483,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1810863,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1792169,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1757991,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1752613,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1742004,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1735237,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1734199,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1731903,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1728166,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1718488,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1709648,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1698847,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1679753,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1674057,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1671311,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1648678,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Break",
        "question_content": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.\nNote that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 169383,
                "title": "solved-the-time-complexity-of-the-brute-force-method-should-be-o-2-n-and-prove-it-below",
                "content": "First I paste my code here which is equivalent to the code in the \"Solution\" tab:\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        // put all words into a hashset\\n        Set<String> set = new HashSet<>(wordDict);\\n        return wb(s, set);\\n    }\\n    private boolean wb(String s, Set<String> set) {\\n        int len = s.length();\\n        if (len == 0) {\\n            return true;\\n        }\\n        for (int i = 1; i <= len; ++i) {\\n            if (set.contains(s.substring(0, i)) && wb(s.substring(i), set)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nThe time complexity depends on how many nodes the recursion tree has. In the worst case, the recursion tree has the most nodes, which means the program should not return in the middle and it should try as many possibilities as possible. So the branches and depth of the tree are as many as possible. For the worst case, for example, we take `s = \"abcd\"` and `wordDict = [\"a\", \"b\", \"c\", \"bc\", \"ab\", \"abc\"]`, the recursion tree is shown below:\\n<img src=\"https://s3-lc-upload.s3.amazonaws.com/users/r0cky2h/image_1536728871.png\" width=\"500\">\\nFrom the code `if (set.contains(s.substring(0, i)) && wb(s.substring(i), set)) { }`, we can see that only if the wordDict contains the prefix, the recursion function can go down to the next level. So on the figure above, string on the edge means the wordDict contains that string. All the gray node with empty string cannot be reached because if the program reaches one such node, the program will return, which lead to some nodes right to it will not be reached. So the conclusion is for a string with length 4, the recursion tree has 8 nodes (all black nodes), and 8 is 2^(4-1). So to generalize this, for a string with length n, the recursion tree wil have 2^(n-1) nodes, i.e., the time complexity is O(2^n). I will prove this generalization below using mathmatical induction:\\n<img src=\"https://s3-lc-upload.s3.amazonaws.com/users/r0cky2h/image_1536729678.png\" width=\"500\">\\nExplanation: the value of a node is the string length. We calculate the number of nodes in the recursion tree for string length=1, 2, ...., n respectively. \\n\\nFor example, when string length=4, the second layer of the recursion tree has three nodes where the string length is 3, 2 and 1 respectively. And the number of subtree rooted at these three nodes have been calculated when we do the mathmatical induction.\\n\\nSo time complexity is O(2^n).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        // put all words into a hashset\\n        Set<String> set = new HashSet<>(wordDict);\\n        return wb(s, set);\\n    }\\n    private boolean wb(String s, Set<String> set) {\\n        int len = s.length();\\n        if (len == 0) {\\n            return true;\\n        }\\n        for (int i = 1; i <= len; ++i) {\\n            if (set.contains(s.substring(0, i)) && wb(s.substring(i), set)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43790,
                "title": "java-implementation-using-dp-in-two-ways",
                "content": "    public class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            \\n            boolean[] f = new boolean[s.length() + 1];\\n            \\n            f[0] = true;\\n            \\n            \\n            /* First DP\\n            for(int i = 1; i <= s.length(); i++){\\n                for(String str: dict){\\n                    if(str.length() <= i){\\n                        if(f[i - str.length()]){\\n                            if(s.substring(i-str.length(), i).equals(str)){\\n                                f[i] = true;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n            }*/\\n            \\n            //Second DP\\n            for(int i=1; i <= s.length(); i++){\\n                for(int j=0; j < i; j++){\\n                    if(f[j] && dict.contains(s.substring(j, i))){\\n                        f[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            return f[s.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            \\n            boolean[] f = new boolean[s.length() + 1];\\n            \\n            f[0] = true;\\n            \\n            \\n            /* First DP\\n            for(int i = 1; i <= s.length(); i++){\\n                for(String str: dict){\\n                    if(str.length() <= i){\\n                        if(f[i - str.length()]){\\n                            if(s.substring(i-str.length(), i).equals(str)){\\n                                f[i] = true;\\n                                break;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 43814,
                "title": "c-dynamic-programming-simple-and-fast-solution-4ms-with-optimization",
                "content": "We use a boolean vector dp[]. dp[***i***] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position ***i*** back and only substring and do dictionary look up in case the preceding position ***j*** with *dp[**j**] == true* is found.\\n\\n    bool wordBreak(string s, unordered_set<string> &dict) {\\n            if(dict.size()==0) return false;\\n            \\n            vector<bool> dp(s.size()+1,false);\\n            dp[0]=true;\\n            \\n            for(int i=1;i<=s.size();i++)\\n            {\\n                for(int j=i-1;j>=0;j--)\\n                {\\n                    if(dp[j])\\n                    {\\n                        string word = s.substr(j,i-j);\\n                        if(dict.find(word)!= dict.end())\\n                        {\\n                            dp[i]=true;\\n                            break; //next i\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return dp[s.size()];\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "We use a boolean vector dp[]. dp[***i***] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position ***i*** back and only substring and do dictionary look up in case the preceding position ***j*** with *dp[**j**] == true* is found.\\n\\n    bool wordBreak(string s, unordered_set<string> &dict) {\\n            if(dict.size()==0) return false;\\n            \\n            vector<bool> dp(s.size()+1,false);\\n            dp[0]=true;\\n            \\n            for(int i=1;i<=s.size();i++)\\n            {\\n                for(int j=i-1;j>=0;j--)\\n                {\\n                    if(dp[j])\\n                    {\\n                        string word = s.substr(j,i-j);\\n                        if(dict.find(word)!= dict.end())\\n                        {\\n                            dp[i]=true;\\n                            break; //next i\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return dp[s.size()];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3171265,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  bool wordBreak(string s, vector<string>& wordDict) {\\n    const int n = s.length();\\n    const int maxLength = getMaxLength(wordDict);\\n    const unordered_set<string> wordSet{begin(wordDict), end(wordDict)};\\n    vector<int> dp(n + 1);\\n    dp[0] = true;\\n\\n    for (int i = 1; i <= n; ++i)\\n      for (int j = i - 1; j >= 0; --j) {\\n        if (i - j > maxLength)\\n          break;\\n        if (dp[j] && wordSet.count(s.substr(j, i - j))) {\\n          dp[i] = true;\\n          break;\\n        }\\n      }\\n\\n    return dp[n];\\n  }\\n\\n private:\\n  int getMaxLength(const vector<string>& wordDict) {\\n    return max_element(begin(wordDict), end(wordDict),\\n                       [](const auto& a, const auto& b) {\\n                         return a.length() < b.length();\\n                       })\\n        ->length();\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        def construct(current,wordDict, memo={}):\\n            if current in memo:\\n                return memo[current]\\n\\n            if not current:\\n                return True\\n\\n            for word in wordDict:\\n                if current.startswith(word):\\n                    new_current = current[len(word):]\\n                    if construct(new_current,wordDict,memo):\\n                        memo[current] = True\\n                        return True\\n\\n            memo[current] = False\\n            return False\\n\\n        return construct(s,wordDict)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recWay1(s, wordDict);\\n    }\\n\\n    boolean recWay2(String s, List<String> wordDict) {\\n        Boolean[] memo = new Boolean[s.length() + 1];\\n        return wordBreak2(s, new HashSet<>(wordDict), 0, memo);\\n    }\\n\\n    boolean wordBreak2(String s, Set<String> wordDict, int k, Boolean[] memo) {\\n        int n = s.length();\\n        if (k == n) return true;\\n\\n        if (memo[k] != null) return memo[k];\\n\\n        for (int i=k + 1; i<=n; i++) {\\n            String word = s.substring(k, i);\\n            if (wordDict.contains(word) && wordBreak2(s, wordDict, i, memo)) {\\n                return memo[k] = true;\\n            }\\n        }\\n\\n        return memo[k] = false;\\n    }\\n\\n    boolean recWay1(String s, List<String> wordDict) {\\n        Boolean[] memo = new Boolean[s.length() + 1];\\n        return wordBreak(s, wordDict, 0, memo);\\n    }\\n    \\n    boolean wordBreak(String s, List<String> wordDict, int k, Boolean[] memo) {\\n        if (k == s.length()) {\\n            return true;\\n        }\\n        \\n        if (memo[k] != null) {\\n            return memo[k];\\n        }\\n        \\n        for (int i=0; i<wordDict.size(); i++) {\\n            String word = wordDict.get(i);\\n            if (s.startsWith(word, k)) {\\n                if(wordBreak(s, wordDict, k + word.length(), memo)) return memo[k] = true;\\n            }\\n        }\\n                   \\n        return memo[k] = false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  bool wordBreak(string s, vector<string>& wordDict) {\\n    const int n = s.length();\\n    const int maxLength = getMaxLength(wordDict);\\n    const unordered_set<string> wordSet{begin(wordDict), end(wordDict)};\\n    vector<int> dp(n + 1);\\n    dp[0] = true;\\n\\n    for (int i = 1; i <= n; ++i)\\n      for (int j = i - 1; j >= 0; --j) {\\n        if (i - j > maxLength)\\n          break;\\n        if (dp[j] && wordSet.count(s.substr(j, i - j))) {\\n          dp[i] = true;\\n          break;\\n        }\\n      }\\n\\n    return dp[n];\\n  }\\n\\n private:\\n  int getMaxLength(const vector<string>& wordDict) {\\n    return max_element(begin(wordDict), end(wordDict),\\n                       [](const auto& a, const auto& b) {\\n                         return a.length() < b.length();\\n                       })\\n        ->length();\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        def construct(current,wordDict, memo={}):\\n            if current in memo:\\n                return memo[current]\\n\\n            if not current:\\n                return True\\n\\n            for word in wordDict:\\n                if current.startswith(word):\\n                    new_current = current[len(word):]\\n                    if construct(new_current,wordDict,memo):\\n                        memo[current] = True\\n                        return True\\n\\n            memo[current] = False\\n            return False\\n\\n        return construct(s,wordDict)\\n```\n```Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recWay1(s, wordDict);\\n    }\\n\\n    boolean recWay2(String s, List<String> wordDict) {\\n        Boolean[] memo = new Boolean[s.length() + 1];\\n        return wordBreak2(s, new HashSet<>(wordDict), 0, memo);\\n    }\\n\\n    boolean wordBreak2(String s, Set<String> wordDict, int k, Boolean[] memo) {\\n        int n = s.length();\\n        if (k == n) return true;\\n\\n        if (memo[k] != null) return memo[k];\\n\\n        for (int i=k + 1; i<=n; i++) {\\n            String word = s.substring(k, i);\\n            if (wordDict.contains(word) && wordBreak2(s, wordDict, i, memo)) {\\n                return memo[k] = true;\\n            }\\n        }\\n\\n        return memo[k] = false;\\n    }\\n\\n    boolean recWay1(String s, List<String> wordDict) {\\n        Boolean[] memo = new Boolean[s.length() + 1];\\n        return wordBreak(s, wordDict, 0, memo);\\n    }\\n    \\n    boolean wordBreak(String s, List<String> wordDict, int k, Boolean[] memo) {\\n        if (k == s.length()) {\\n            return true;\\n        }\\n        \\n        if (memo[k] != null) {\\n            return memo[k];\\n        }\\n        \\n        for (int i=0; i<wordDict.size(); i++) {\\n            String word = wordDict.get(i);\\n            if (s.startsWith(word, k)) {\\n                if(wordBreak(s, wordDict, k + word.length(), memo)) return memo[k] = true;\\n            }\\n        }\\n                   \\n        return memo[k] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43808,
                "title": "simple-dp-solution-in-python-with-description",
                "content": "The idea is the following:\\n\\n- d is an array that contains booleans\\n\\n- d[i] is True if there is a word in the dictionary that *ends* at ith index of s AND d is also True at the beginning of the word\\n\\n\\nExample:\\n\\n- s = \"leetcode\"\\n\\n- words = [\"leet\", \"code\"]\\n\\n- d[3] is True because there is \"leet\" in the dictionary that ends at 3rd index of \"leetcode\"\\n\\n- d[7] is True because there is \"code\" in the dictionary that ends at the 7th index of \"leetcode\" AND d[3] is True\\n\\nThe result is the last index of d.\\n\\n    def word_break(s, words):\\n     \\td = [False] * len(s)    \\n     \\tfor i in range(len(s)):\\n     \\t\\tfor w in words:\\n     \\t\\t\\tif w == s[i-len(w)+1:i+1] and (d[i-len(w)] or i-len(w) == -1):\\n     \\t\\t\\t\\td[i] = True\\n     \\treturn d[-1]",
                "solutionTags": [],
                "code": "The idea is the following:\\n\\n- d is an array that contains booleans\\n\\n- d[i] is True if there is a word in the dictionary that *ends* at ith index of s AND d is also True at the beginning of the word\\n\\n\\nExample:\\n\\n- s = \"leetcode\"\\n\\n- words = [\"leet\", \"code\"]\\n\\n- d[3] is True because there is \"leet\" in the dictionary that ends at 3rd index of \"leetcode\"\\n\\n- d[7] is True because there is \"code\" in the dictionary that ends at the 7th index of \"leetcode\" AND d[3] is True\\n\\nThe result is the last index of d.\\n\\n    def word_break(s, words):\\n     \\td = [False] * len(s)    \\n     \\tfor i in range(len(s)):\\n     \\t\\tfor w in words:\\n     \\t\\t\\tif w == s[i-len(w)+1:i+1] and (d[i-len(w)] or i-len(w) == -1):\\n     \\t\\t\\t\\td[i] = True\\n     \\treturn d[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 43788,
                "title": "4-lines-in-python",
                "content": "`ok[i]` tells whether `s[:i]` can be built.\\n\\n    def wordBreak(self, s, words):\\n        ok = [True]\\n        for i in range(1, len(s)+1):\\n            ok += any(ok[j] and s[j:i] in words for j in range(i)),\\n        return ok[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "`ok[i]` tells whether `s[:i]` can be built.\\n\\n    def wordBreak(self, s, words):\\n        ok = [True]\\n        for i in range(1, len(s)+1):\\n            ok += any(ok[j] and s[j:i] in words for j in range(i)),\\n        return ok[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1455100,
                "title": "python-3-solutions-top-down-dp-bottom-up-dp-then-optimised-with-trie-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DFS with Memoization + HashSet**\\n- Let `dp(i)` return True if `s[i..n-1]` can be segmented into a space-separated sequence of one or more dictionary words.\\n- Then `dp(0)` is our result.\\n```python\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        wordSet = set(wordDict)\\n\\n        @lru_cache(None)\\n        def dp(start):\\n            if start == n:  # Found a valid way to break words\\n                return True\\n\\n            for end in range(start + 1, n + 1):  # O(N^2)\\n                word = s[start:end]  # O(N)\\n                if word in wordSet and dp(end):\\n                    return True\\n            return False\\n\\n        return dp(0)\\n```\\n**Complexity**\\n- Time: `O(N^3 + M)`, where `N <= 300` is length of string `s`, where `M <= 1000` is length of `wordDict`.\\n  There are total `N` dp states, they are `dp[0], dp[1],.., dp[n]`, each dp state needs a loop `O(N^2)` to calculate the result.\\n  Plus the time to build `wordSet` from `wordDict`, which is `O(M)`\\n  So total complexity is: `O(N * N^2 + M)` = `O(N^3 + M)`.\\n- Space: `O(N + M)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP (Updated: Add this solution)**\\n- Just convert from Top down DP to Bottom up DP.\\n```python\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        \\n        dp = [False] * (n+1)\\n        dp[n] = True\\n        for i in range(n-1, -1, -1):\\n            for j in range(i+1, n+1):\\n                if dp[j] and s[i:j] in wordSet:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[0]\\n```\\n**Complexity**\\n- Time: `O(N^3 + M)`, where `N <= 300` is length of string `s`, where `M <= 1000` is length of `wordDict`.\\n- Space: `O(N + M)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: DFS with Memoization + Optimized with Trie**\\n- We can optimize to this part `s[i:j] in wordSet` to `O(1)` by building the Trie structure to store all words in our trie.\\n- Then when we iterate characters at index `j`, we update the `cur` trie node which represents the string `s[i:j]` in our trie words.\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.child = defaultdict(TrieNode)\\n    \\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            cur = cur.child[c]\\n        cur.isWord = True\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        root = TrieNode()\\n        for word in wordDict:\\n            root.addWord(word)\\n            \\n        n = len(s)\\n        dp = [False] * (n+1)\\n        dp[n] = True\\n        \\n        for i in range(n-1, -1, -1):\\n            cur = root\\n            for j in range(i+1, n+1):\\n                c = s[j-1]\\n                if c not in cur.child: break  # s[i:j] not exist in our trie\\n                cur = cur.child[c]\\n                if cur.isWord and dp[j]:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[0]\\n```\\n**Complexity**\\n- Time: `O(N^2 + T)`, where `N <= 300` is length of string `s`, `T <= 20000` is total characters in `wordDict` for building Trie Structure.\\n   Building DP costs `O(N^2)`.\\n   Plus the time to build the Trie, which is `O(T)`.\\n   So total complexity is: `O(N * N + T)` = `O(N^2 + T)`.\\n- Space: `O(N + T)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        wordSet = set(wordDict)\\n\\n        @lru_cache(None)\\n        def dp(start):\\n            if start == n:  # Found a valid way to break words\\n                return True\\n\\n            for end in range(start + 1, n + 1):  # O(N^2)\\n                word = s[start:end]  # O(N)\\n                if word in wordSet and dp(end):\\n                    return True\\n            return False\\n\\n        return dp(0)\\n```\n```python\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        \\n        dp = [False] * (n+1)\\n        dp[n] = True\\n        for i in range(n-1, -1, -1):\\n            for j in range(i+1, n+1):\\n                if dp[j] and s[i:j] in wordSet:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[0]\\n```\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.child = defaultdict(TrieNode)\\n    \\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            cur = cur.child[c]\\n        cur.isWord = True\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        root = TrieNode()\\n        for word in wordDict:\\n            root.addWord(word)\\n            \\n        n = len(s)\\n        dp = [False] * (n+1)\\n        dp[n] = True\\n        \\n        for i in range(n-1, -1, -1):\\n            cur = root\\n            for j in range(i+1, n+1):\\n                c = s[j-1]\\n                if c not in cur.child: break  # s[i:j] not exist in our trie\\n                cur = cur.child[c]\\n                if cur.isWord and dp[j]:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43797,
                "title": "a-solution-using-bfs",
                "content": "People have posted elegant solutions using DP. The solution I post below using BFS is no better than those. Just to share some new thoughts.\\n\\nWe can use a graph to represent the possible solutions. The vertices of the graph are simply the positions of the first characters of the words and each edge actually represents a word. For example, the input string is \"nightmare\", there are two ways to break it, \"night mare\" and \"nightmare\". The graph would be\\n\\n0-->5-->9\\n\\n|__ __ _^\\n\\nThe question is simply to check if there is a path from 0 to 9. The most efficient way is traversing the graph using BFS with the help of a queue and a hash set. The hash set is used to keep track of the visited nodes to avoid repeating the same work. \\n\\nFor this problem, the time complexity is O(n^2) and space complexity is O(n), the same with DP. This idea can be used to solve the problem word break II. We can simple construct the graph using BFS, save it into a map and then find all the paths using DFS. \\n\\n    bool wordBreak(string s, unordered_set<string> &dict) {\\n        // BFS\\n        queue<int> BFS;\\n        unordered_set<int> visited;\\n        \\n        BFS.push(0);\\n        while(BFS.size() > 0)\\n        {\\n            int start = BFS.front();\\n            BFS.pop();\\n            if(visited.find(start) == visited.end())\\n            {\\n                visited.insert(start);\\n                for(int j=start; j<s.size(); j++)\\n                {\\n                    string word(s, start, j-start+1);\\n                    if(dict.find(word) != dict.end())\\n                    {\\n                        BFS.push(j+1);\\n                        if(j+1 == s.size())\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "People have posted elegant solutions using DP. The solution I post below using BFS is no better than those. Just to share some new thoughts.\\n\\nWe can use a graph to represent the possible solutions. The vertices of the graph are simply the positions of the first characters of the words and each edge actually represents a word. For example, the input string is \"nightmare\", there are two ways to break it, \"night mare\" and \"nightmare\". The graph would be\\n\\n0-->5-->9\\n\\n|__ __ _^\\n\\nThe question is simply to check if there is a path from 0 to 9. The most efficient way is traversing the graph using BFS with the help of a queue and a hash set. The hash set is used to keep track of the visited nodes to avoid repeating the same work. \\n\\nFor this problem, the time complexity is O(n^2) and space complexity is O(n), the same with DP. This idea can be used to solve the problem word break II. We can simple construct the graph using BFS, save it into a map and then find all the paths using DFS. \\n\\n    bool wordBreak(string s, unordered_set<string> &dict) {\\n        // BFS\\n        queue<int> BFS;\\n        unordered_set<int> visited;\\n        \\n        BFS.push(0);\\n        while(BFS.size() > 0)\\n        {\\n            int start = BFS.front();\\n            BFS.pop();\\n            if(visited.find(start) == visited.end())\\n            {\\n                visited.insert(start);\\n                for(int j=start; j<s.size(); j++)\\n                {\\n                    string word(s, start, j-start+1);\\n                    if(dict.find(word) != dict.end())\\n                    {\\n                        BFS.push(j+1);\\n                        if(j+1 == s.size())\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43886,
                "title": "evolve-from-brute-force-to-optimal-a-review-of-all-solutions",
                "content": "1. Recursion, Average O(2^n)\\nT(n) = T(n-1)+T(n-2)+...+T(1) \\n=> T(n+1) = T(n)+T(n-1)+T(n-2)+...+T(1)\\n=>T(n+1) = 2T(n)\\n* c++\\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        return canBrk(0,s,wordDict);    \\n    }\\n    bool canBrk(int start, string& s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if(start == n) return 1;\\n        string sub;\\n        for(int i = start; i<n; i++) if(wordDict.count(sub+=s[i]) && canBrk(i+1,s,wordDict)) return 1;\\n        return 0;\\n    }\\n```\\n* java is more expensive due to use of substring\\n```\\n\\tpublic boolean wordBreak(String s, List<String> wordDict) {    \\n        return wordBreak(0,s,new HashSet(wordDict));   \\n    }\\n    private boolean wordBreak(int p, String s, Set<String> dict){\\n        int n=s.length();\\n        if(p==n) {\\n            return true;\\n        }\\n        for(int i=p+1;i<=n;i++) {\\n            if(dict.contains(s.substring(p,i)) && wordBreak(i,s,dict)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n2.  DFS with Memoization. There is redundancy in #1. A substr may be checked multiple times. We can cache the result by memoization. This is the optimal solution.\\n* c++  Average O(n^2) Time, O(n+d) space. wordDict.count(string) could be O(1) or O(n) depending on the hash function implementation, see [reference]().\\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<char> mem(s.size(),-1);\\n        return canBrk(0,s,wordDict,mem);    \\n    }\\n    bool canBrk(int start, string& s, unordered_set<string>& wordDict,vector<char>& mem) {\\n        int n = s.size();\\n        if(start == n) return 1;\\n        if(mem[start]!= -1) return mem[start];\\n        string sub;\\n        for(int i = start; i<n; i++) if(wordDict.count(sub+=s[i]) && canBrk(i+1,s,wordDict,mem)) return mem[start] = 1; \\n        return mem[start] = 0;\\n    }\\n```\\n* java O(n^3)\\n```\\n\\tBoolean[] mem;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        mem=new Boolean[s.length()];\\n        return wordBreak(0,s,new HashSet<String>(wordDict));   \\n    }\\n    private boolean wordBreak(int p, String s, Set<String> dict){\\n        int n=s.length();\\n        if(p==n) {\\n            return true;\\n        }\\n        if(mem[p]!=null) {\\n            return mem[p];\\n        }\\n        for(int i=p+1;i<=n;i++) {\\n            if(dict.contains(s.substring(p,i))&&wordBreak(i,s,dict)) { \\n                return mem[p]=true;\\n            }\\n        }\\n        return mem[p]=false;\\n    }\\n```\\n3. dp. For dp problems, many times we go into iterative dp directly without even thinking about dfs. This is a great example showing that dfs is better than dp. DFS returns as soon as it finds one way to break the word while dp computes if each substring starting/ending at i is breakable. The test cases of this problem do not show it but it is shown in a similar problem [Concatenated Words](https://discuss.leetcode.com/topic/78569/a-review-of-top-solutions).\\n* c++ Average O(n^2) \\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        vector<bool> dp(n+1);\\n        dp[n]=1;\\n        for(int i=n-1;i>=0;i--) {\\n            string sub;\\n            for(int j=i;j<n;j++) if (dp[i] = wordDict.count(sub+=s[j]) && dp[j+1]) break;\\n        }\\n        return dp[0];    \\n    }\\n```\\n* java O(n^3)\\n```\\n\\tpublic boolean wordBreak(String s, List<String> wordDict) {\\n        int n=s.length();\\n        boolean[] dp=new boolean[n+1];\\n        dp[n]=true;\\n        Set<String> dict=new HashSet(wordDict);\\n        for(int i=n-1;i>=0;i--) {\\n            for(int j=i+1;!dp[i] && j<=n;j++) { \\n                dp[i] = dp[j] & dict.contains(s.substring(i,j));\\n            }\\n        }\\n        return dp[0];   \\n    }\\n```\\n4. BFS, Average O(n^2) BFS may be better than dp. In dp, for each index i, it checks if the substr starting at i can break. However, if the substr ending before i cannot break, then we do not have to check i. But this is the nature of dp, we visit all the states and derive the next state according to previous states and I don\\'t find a way to improve the dp solution. BFS always starts from a valid index and may visit fewer states. This is similar to [Perfect Squares](https://discuss.leetcode.com/topic/57631/evolve-from-brute-force). But BFS is not guaranteed to be better than dp. If every index is a valid state, then BFS visits the same number of states as dp. The inner for loop of BFS looks more expensive than the inner for loop of dp. So I think which is better is case by case. In general, both BFS and dp visit all the states and are less efficient than dfs.\\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        queue<int> q({0});\\n        unordered_set<int> vstd;\\n        int n = s.size();\\n        while(!q.empty()) {\\n            int start = q.front();\\n            q.pop();\\n            if(vstd.count(start)) continue;\\n            vstd.insert(start);\\n            string sub;\\n            for(int i=start;i<n;i++) \\n                if(wordDict.count(sub+=s[i])) {\\n                    q.push(i+1);\\n                    if(i+1 == n) return 1;    \\n                }\\n        }\\n        return 0;    \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        return canBrk(0,s,wordDict);    \\n    }\\n    bool canBrk(int start, string& s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if(start == n) return 1;\\n        string sub;\\n        for(int i = start; i<n; i++) if(wordDict.count(sub+=s[i]) && canBrk(i+1,s,wordDict)) return 1;\\n        return 0;\\n    }\\n```\n```\\n\\tpublic boolean wordBreak(String s, List<String> wordDict) {    \\n        return wordBreak(0,s,new HashSet(wordDict));   \\n    }\\n    private boolean wordBreak(int p, String s, Set<String> dict){\\n        int n=s.length();\\n        if(p==n) {\\n            return true;\\n        }\\n        for(int i=p+1;i<=n;i++) {\\n            if(dict.contains(s.substring(p,i)) && wordBreak(i,s,dict)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<char> mem(s.size(),-1);\\n        return canBrk(0,s,wordDict,mem);    \\n    }\\n    bool canBrk(int start, string& s, unordered_set<string>& wordDict,vector<char>& mem) {\\n        int n = s.size();\\n        if(start == n) return 1;\\n        if(mem[start]!= -1) return mem[start];\\n        string sub;\\n        for(int i = start; i<n; i++) if(wordDict.count(sub+=s[i]) && canBrk(i+1,s,wordDict,mem)) return mem[start] = 1; \\n        return mem[start] = 0;\\n    }\\n```\n```\\n\\tBoolean[] mem;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        mem=new Boolean[s.length()];\\n        return wordBreak(0,s,new HashSet<String>(wordDict));   \\n    }\\n    private boolean wordBreak(int p, String s, Set<String> dict){\\n        int n=s.length();\\n        if(p==n) {\\n            return true;\\n        }\\n        if(mem[p]!=null) {\\n            return mem[p];\\n        }\\n        for(int i=p+1;i<=n;i++) {\\n            if(dict.contains(s.substring(p,i))&&wordBreak(i,s,dict)) { \\n                return mem[p]=true;\\n            }\\n        }\\n        return mem[p]=false;\\n    }\\n```\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        vector<bool> dp(n+1);\\n        dp[n]=1;\\n        for(int i=n-1;i>=0;i--) {\\n            string sub;\\n            for(int j=i;j<n;j++) if (dp[i] = wordDict.count(sub+=s[j]) && dp[j+1]) break;\\n        }\\n        return dp[0];    \\n    }\\n```\n```\\n\\tpublic boolean wordBreak(String s, List<String> wordDict) {\\n        int n=s.length();\\n        boolean[] dp=new boolean[n+1];\\n        dp[n]=true;\\n        Set<String> dict=new HashSet(wordDict);\\n        for(int i=n-1;i>=0;i--) {\\n            for(int j=i+1;!dp[i] && j<=n;j++) { \\n                dp[i] = dp[j] & dict.contains(s.substring(i,j));\\n            }\\n        }\\n        return dp[0];   \\n    }\\n```\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        queue<int> q({0});\\n        unordered_set<int> vstd;\\n        int n = s.size();\\n        while(!q.empty()) {\\n            int start = q.front();\\n            q.pop();\\n            if(vstd.count(start)) continue;\\n            vstd.insert(start);\\n            string sub;\\n            for(int i=start;i<n;i++) \\n                if(wordDict.count(sub+=s[i])) {\\n                    q.push(i+1);\\n                    if(i+1 == n) return 1;    \\n                }\\n        }\\n        return 0;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43995,
                "title": "a-simple-python-dp-solution",
                "content": "    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: bool\\n            \"\"\"\\n            dp = [False] * (len(s) + 1) # dp[i] means s[:i+1] can be segmented into words in the wordDicts \\n            dp[0] = True\\n            for i in range(len(s)):\\n                for j in range(i, len(s)):\\n                    if dp[i] and s[i: j+1] in wordDict:\\n                        dp[j+1] = True\\n                        \\n            return dp[-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: bool\\n            \"\"\"\\n            dp = [False] * (len(s) + 1) # dp[i] means s[:i+1] can be segmented into words in the wordDicts \\n            dp[0] = True\\n            for i in range(len(s)):\\n                for j in range(i, len(s)):\\n                    if dp[i] and s[i: j+1] in wordDict:\\n                        dp[j+1] = True\\n                        \\n            return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 44054,
                "title": "java-dp-solution",
                "content": "    public boolean wordBreak(String s, Set<String> dict) {\\n      if (s == null || s.length() == 0) return false;\\n      \\n      int n = s.length();\\n      \\n      // dp[i] represents whether s[0...i] can be formed by dict\\n      boolean[] dp = new boolean[n];\\n      \\n      for (int i = 0; i < n; i++) {\\n        for (int j = 0; j <= i; j++) {\\n          String sub = s.substring(j, i + 1);\\n          \\n          if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\\n            dp[i] = true;\\n            break;\\n          }\\n        }\\n      }\\n      \\n      return dp[n - 1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean wordBreak(String s, Set<String> dict) {\\n      if (s == null || s.length() == 0) return false;\\n      \\n      int n = s.length();\\n      \\n      // dp[i] represents whether s[0...i] can be formed by dict\\n      boolean[] dp = new boolean[n];\\n      \\n      for (int i = 0; i < n; i++) {\\n        for (int j = 0; j <= i; j++) {\\n          String sub = s.substring(j, i + 1);\\n          \\n          if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\\n            dp[i] = true;\\n            break;\\n          }\\n        }\\n      }\\n      \\n      return dp[n - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3226285,
                "title": "best-c-3-solution-dp-memoization-tabulation-backtracking-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using String + Backtracking + Hash Table.\\n2. Solved using String + DP(Memoisation) + Hash Table.\\n3. Solved using String + DP(Tabulation) + Hash Table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\\n    results in O(2^N).\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + Backtracking + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set){\\n        if(s.size() == 0){\\n            return true;\\n        }\\n        for(int i=0; i<s.size(); i++){\\n            if(set.count(s.substr(0, i+1)) && wordBreak(s.substr(i+1), set)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\\n    results in O(2^N).\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + Backtracking + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set, int start){\\n        if(start == s.size()){\\n            return true;\\n        }\\n        for(int i=start; i<s.size(); i++){\\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, i+1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set, 0);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Size of recursion tree can go up to N^2.\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + DP(Memoisation) + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set, vector<int> &memo, int start){\\n        if(start == s.size()){\\n            return true;\\n        }\\n        if(memo[start] != -1){\\n            return memo[start];\\n        }\\n        for(int i=start; i<s.size(); i++){\\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, memo, i+1)){\\n                memo[start] = true;\\n                return true;\\n            }\\n        }\\n        return memo[start] = false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<int> memo(s.size(), -1);\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set, memo, 0);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), There are two nested loops, and substring computation at each iteration. Overall\\n    that results in O(N^3) time complexity.\\n\\n    Space Complexity : O(N), Length of dp array is N+1.\\n    \\n    Solved using String + DP(Tabulation) + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, 0);\\n        dp[0] = true;\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        for(int i=1; i<=s.size(); i++){\\n            for(int j=0; j<i; j++){\\n                if(dp[j] && set.count(s.substr(j, i-j))){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\\n    results in O(2^N).\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + Backtracking + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set){\\n        if(s.size() == 0){\\n            return true;\\n        }\\n        for(int i=0; i<s.size(); i++){\\n            if(set.count(s.substr(0, i+1)) && wordBreak(s.substr(i+1), set)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\\n    results in O(2^N).\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + Backtracking + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set, int start){\\n        if(start == s.size()){\\n            return true;\\n        }\\n        for(int i=start; i<s.size(); i++){\\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, i+1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set, 0);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Size of recursion tree can go up to N^2.\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + DP(Memoisation) + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set, vector<int> &memo, int start){\\n        if(start == s.size()){\\n            return true;\\n        }\\n        if(memo[start] != -1){\\n            return memo[start];\\n        }\\n        for(int i=start; i<s.size(); i++){\\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, memo, i+1)){\\n                memo[start] = true;\\n                return true;\\n            }\\n        }\\n        return memo[start] = false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<int> memo(s.size(), -1);\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set, memo, 0);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), There are two nested loops, and substring computation at each iteration. Overall\\n    that results in O(N^3) time complexity.\\n\\n    Space Complexity : O(N), Length of dp array is N+1.\\n    \\n    Solved using String + DP(Tabulation) + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, 0);\\n        dp[0] = true;\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        for(int i=1; i<=s.size(); i++){\\n            for(int j=0; j<i; j++){\\n                if(dp[j] && set.count(s.substr(j, i-j))){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43908,
                "title": "4-different-ways-to-solve-this-with-detailed-explanation",
                "content": "```\\n\\n\\n\\n/*\\n SOLUTION 1: bfs\\n    Idea is to try to chop off prefix of s that is in the dict\\n    enqueue the left-over of each chop off\\n    if there is a time the left over happens to be in the dict as well\\n        we know word is breakable, b/c all the previous chops are all in the dict\\n    otherwise the original world is not breakable.\\n    \\n    we can use a set to store all the leftovers that we have tried, to avoid enqueue the \\n    same leftover multiple times.\\n\\n*/\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        int index = 0;\\n        Queue<String> queue = new LinkedList<String>();\\n        queue.offer(s);\\n        Set<String> visited = new HashSet<String>();\\n        while(!queue.isEmpty()){\\n            String candidate = queue.poll();\\n            if(wordDict.contains(candidate)) return true;\\n            for(int i = 0; i < candidate.length(); i++){\\n                String chop = candidate.substring(0,i);\\n                String next = candidate.substring(i, candidate.length());\\n                if(!visited.contains(next) && wordDict.contains(chop)){\\n                    next = candidate.substring(i, candidate.length());\\n                    queue.offer(next);\\n                    visited.add(next);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/* SOLUTION 2: dfs\\n    use a set to record the substring (i, s.length) that is not breakable\\n    start from the front, try to see if the substring (0,i) is in the dict,\\n    if so, recursively check if there is a way to break (i, s.length)\\n    \\n    \\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if(s.length() == 0) return false;\\n        Set<Integer> set = new HashSet<Integer>();\\n        return helper(s, 0, set, wordDict);\\n    }\\n    \\n    private boolean helper(String s, int index, Set<Integer> set, Set<String> dict){\\n        if(index == s.length()) return true;\\n        for(int i = index + 1; i <= s.length(); i++){\\n            if(set.contains(i)) continue;\\n            if(dict.contains(s.substring(index, i))){\\n                 if (helper(s, i, set, dict)) return true;\\n                 set.add(i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n/* SOLUTION 3: dp\\n    dp[i] represents if substring (0,i) is breakable.\\n    for each longer substring, we just need to check \\n\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if(s.length() == 0) return false;\\n        boolean[] breakable = new boolean[s.length() + 1];\\n        breakable[0] = true;\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = 0; j < i; j++){\\n                if(breakable[j] && wordDict.contains(s.substring(j, i))){\\n                    breakable[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        //for(boolean b : breakable) System.out.print(b + \", \");\\n        return breakable[s.length()];\\n    }\\n}\\n*/\\n\\n/* SOLUTION 4: TRIE + MAP  \\n\\n\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        Trie trie = new Trie();\\n        for(String d : wordDict){\\n            trie.insert(d);\\n        }\\n        List<String> prefix = findPrefix(trie, s);\\n        Map<String, Boolean> map = new HashMap<String, Boolean>();\\n        for(String split : prefix){\\n            if(canBeSplitted(trie, s.replaceFirst(split, \"\"), map)){\\n                map.put(split, true);\\n                return true;\\n            }\\n        }\\n        return false;   \\n    }\\n    \\n    private boolean canBeSplitted(Trie root, String input, Map<String, Boolean> map){\\n        if(map.containsKey(input)) return map.get(input);\\n        if(root.search(input) || input.length() == 0) return true;\\n        List<String> prefix = findPrefix(root, input);\\n        for(String s : prefix){\\n            String copy = new String(input);\\n            if(canBeSplitted(root, copy.replaceFirst(s, \"\"), map)){\\n                map.put(input, true);\\n                return true;\\n            } \\n        }\\n        map.put(input, false);\\n        return false;\\n    }\\n    \\n    private List<String> findPrefix(Trie root, String input){\\n        char[] split = input.toCharArray();\\n        List<String> result = new ArrayList<String>();\\n        TrieNode pointer = root.root;\\n        for(int i = 0; i < split.length; i++){\\n            pointer = pointer.next[split[i] - 'a'];\\n            if(pointer == null) break;\\n            if(pointer.word != null) result.add(pointer.word);\\n        }\\n        return result;\\n    }    \\n\\n    class TrieNode {\\n    \\n        public String word;\\n        public TrieNode[] next;\\n        public TrieNode() {\\n            word = null;\\n            next = new TrieNode[26];\\n        }\\n    }\\n\\n    public class Trie {\\n        private TrieNode root;\\n    \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n    \\n        public void insert(String word) {\\n            TrieNode pointer = root;\\n            for(int i = 0; i < word.length(); i++){\\n                if(pointer.next[word.charAt(i) - 'a'] == null){\\n                    pointer.next[word.charAt(i) - 'a'] = new TrieNode();\\n                }\\n                pointer = pointer.next[word.charAt(i) - 'a'];\\n            }\\n            pointer.word = word;\\n        }\\n    \\n        public boolean search(String word) {\\n            TrieNode pointer = root;\\n            if(root.word != null && root.word.equals(word)) return true;\\n            for(int i = 0; i < word.length(); i++){\\n                if(pointer.next[word.charAt(i) - 'a'] == null) return false;\\n                pointer = pointer.next[word.charAt(i) - 'a'];\\n            }\\n            if(pointer.word == null) return false;\\n            return pointer.word.equals(word);\\n        }\\n    \\n    }    \\n    \\n}*/\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\n/*\\n SOLUTION 1: bfs\\n    Idea is to try to chop off prefix of s that is in the dict\\n    enqueue the left-over of each chop off\\n    if there is a time the left over happens to be in the dict as well\\n        we know word is breakable, b/c all the previous chops are all in the dict\\n    otherwise the original world is not breakable.\\n    \\n    we can use a set to store all the leftovers that we have tried, to avoid enqueue the \\n    same leftover multiple times.\\n\\n*/\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        int index = 0;\\n        Queue<String> queue = new LinkedList<String>();\\n        queue.offer(s);\\n        Set<String> visited = new HashSet<String>();\\n        while(!queue.isEmpty()){\\n            String candidate = queue.poll();\\n            if(wordDict.contains(candidate)) return true;\\n            for(int i = 0; i < candidate.length(); i++){\\n                String chop = candidate.substring(0,i);\\n                String next = candidate.substring(i, candidate.length());\\n                if(!visited.contains(next) && wordDict.contains(chop)){\\n                    next = candidate.substring(i, candidate.length());\\n                    queue.offer(next);\\n                    visited.add(next);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/* SOLUTION 2: dfs\\n    use a set to record the substring (i, s.length) that is not breakable\\n    start from the front, try to see if the substring (0,i) is in the dict,\\n    if so, recursively check if there is a way to break (i, s.length)\\n    \\n    \\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if(s.length() == 0) return false;\\n        Set<Integer> set = new HashSet<Integer>();\\n        return helper(s, 0, set, wordDict);\\n    }\\n    \\n    private boolean helper(String s, int index, Set<Integer> set, Set<String> dict){\\n        if(index == s.length()) return true;\\n        for(int i = index + 1; i <= s.length(); i++){\\n            if(set.contains(i)) continue;\\n            if(dict.contains(s.substring(index, i))){\\n                 if (helper(s, i, set, dict)) return true;\\n                 set.add(i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n/* SOLUTION 3: dp\\n    dp[i] represents if substring (0,i) is breakable.\\n    for each longer substring, we just need to check \\n\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if(s.length() == 0) return false;\\n        boolean[] breakable = new boolean[s.length() + 1];\\n        breakable[0] = true;\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = 0; j < i; j++){\\n                if(breakable[j] && wordDict.contains(s.substring(j, i))){\\n                    breakable[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        //for(boolean b : breakable) System.out.print(b + \", \");\\n        return breakable[s.length()];\\n    }\\n}\\n*/\\n\\n/* SOLUTION 4: TRIE + MAP  \\n\\n\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        Trie trie = new Trie();\\n        for(String d : wordDict){\\n            trie.insert(d);\\n        }\\n        List<String> prefix = findPrefix(trie, s);\\n        Map<String, Boolean> map = new HashMap<String, Boolean>();\\n        for(String split : prefix){\\n            if(canBeSplitted(trie, s.replaceFirst(split, \"\"), map)){\\n                map.put(split, true);\\n                return true;\\n            }\\n        }\\n        return false;   \\n    }\\n    \\n    private boolean canBeSplitted(Trie root, String input, Map<String, Boolean> map){\\n        if(map.containsKey(input)) return map.get(input);\\n        if(root.search(input) || input.length() == 0) return true;\\n        List<String> prefix = findPrefix(root, input);\\n        for(String s : prefix){\\n            String copy = new String(input);\\n            if(canBeSplitted(root, copy.replaceFirst(s, \"\"), map)){\\n                map.put(input, true);\\n                return true;\\n            } \\n        }\\n        map.put(input, false);\\n        return false;\\n    }\\n    \\n    private List<String> findPrefix(Trie root, String input){\\n        char[] split = input.toCharArray();\\n        List<String> result = new ArrayList<String>();\\n        TrieNode pointer = root.root;\\n        for(int i = 0; i < split.length; i++){\\n            pointer = pointer.next[split[i] - 'a'];\\n            if(pointer == null) break;\\n            if(pointer.word != null) result.add(pointer.word);\\n        }\\n        return result;\\n    }    \\n\\n    class TrieNode {\\n    \\n        public String word;\\n        public TrieNode[] next;\\n        public TrieNode() {\\n            word = null;\\n            next = new TrieNode[26];\\n        }\\n    }\\n\\n    public class Trie {\\n        private TrieNode root;\\n    \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n    \\n        public void insert(String word) {\\n            TrieNode pointer = root;\\n            for(int i = 0; i < word.length(); i++){\\n                if(pointer.next[word.charAt(i) - 'a'] == null){\\n                    pointer.next[word.charAt(i) - 'a'] = new TrieNode();\\n                }\\n                pointer = pointer.next[word.charAt(i) - 'a'];\\n            }\\n            pointer.word = word;\\n        }\\n    \\n        public boolean search(String word) {\\n            TrieNode pointer = root;\\n            if(root.word != null && root.word.equals(word)) return true;\\n            for(int i = 0; i < word.length(); i++){\\n                if(pointer.next[word.charAt(i) - 'a'] == null) return false;\\n                pointer = pointer.next[word.charAt(i) - 'a'];\\n            }\\n            if(pointer.word == null) return false;\\n            return pointer.word.equals(word);\\n        }\\n    \\n    }    \\n    \\n}*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870144,
                "title": "c-simple-and-short-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        \\n        // we mark as true every index that we managed to segment so far\\n        for (int i = 1; i <= s.size(); i++)\\n            for (int j = 0; j < i; j++)\\n                if ((dp[j]) && (find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end())) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n        return dp.back();\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        \\n        // we mark as true every index that we managed to segment so far\\n        for (int i = 1; i <= s.size(); i++)\\n            for (int j = 0; j < i; j++)\\n                if ((dp[j]) && (find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end())) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860456,
                "title": "100-dp-dfs-video-segmenting-a-string",
                "content": "# Intuition\\nWhen given a string and a dictionary of words, the problem requires us to determine if the string can be segmented into a sequence of dictionary words. A common way to approach this problem is to use either Dynamic Programming or Depth-First Search with memoization, considering the constraints and properties of the problem. The comparison includes implementations in multiple languages: Python, C++, Java, JavaScript, Rust, Go, and C#.\\n\\nhttps://youtu.be/9ZIQwa1wCNA\\n\\n# Approaches - Short Description\\n\\n## Dynamic Programming\\nBy utilizing a boolean array dp, we can iteratively build a solution that checks if the string can be segmented into dictionary words. This approach leverages the subproblem overlap and builds a bottom-up solution.\\n\\n## Depth-First Search with Memoization\\nThis approach searches for a valid segmentation by recursively exploring different paths and using a set data structure to efficiently match prefixes. Memoization is used to store results and avoid redundant computations.\\n\\n## Differences\\nWhile Dynamic Programming builds the solution iteratively, Depth-First Search explores recursively. The DP approach has a more straightforward implementation, while DFS with memoization may be more efficient in some cases due to early termination.\\n\\n# Approach - Dynamic Programming\\nThe Dynamic Programming approach provides an efficient way to solve the word break problem by building up a solution iteratively. Here\\'s a step-by-step description:\\n\\n1. **Initialization**: We initialize a boolean array `dp` of length \\\\(n+1\\\\), where \\\\(n\\\\) is the length of the string `s`. The entry `dp[i]` will be `True` if there exists a word in the dictionary that ends at index \\\\(i-1\\\\) in the string `s`. We set `dp[0]` to `True` since an empty string can always be segmented.\\n\\n2. **Determine Maximum Word Length**: We find the maximum length of a word in the dictionary using `max_len = max(map(len, wordDict))`. This helps us in reducing unnecessary iterations.\\n\\n3. **Iterate Through the String**: We iterate through the string from index 1 to \\\\(n\\\\) (inclusive) and for each index `i`, we iterate from index \\\\(i-1\\\\) down to \\\\(i - \\\\text{max_len} - 1\\\\) (or -1, whichever is larger).\\n\\n4. **Check for Segmentation**: For each `j` in the range, we check if `dp[j]` is `True` and if the substring `s[j:i]` is in `wordDict`. If both conditions are met, we set `dp[i]` to `True` and break out of the inner loop. This means that there exists a valid segmentation ending at index \\\\(i-1\\\\).\\n\\n5. **Result**: Finally, we return `dp[n]`, which will be `True` if the entire string can be segmented into words from the dictionary.\\n\\n## Example:\\nConsider the example with `s = \"leetcode\"` and `wordDict = [\"leet\",\"code\"]`. Here\\'s how the algorithm proceeds:\\n\\n- **Initialization**: `dp = [True, False, False, False, False, False, False, False, False]`.\\n- **Determine Maximum Word Length**: `max_len = 4`.\\n- **Iterate Through the String**:\\n  - When `i = 4`, the loop finds that `dp[0]` is `True` and `\"leet\"` is in the dictionary, so `dp[4]` is set to `True`.\\n  - When `i = 8`, the loop finds that `dp[4]` is `True` and `\"code\"` is in the dictionary, so `dp[8]` is set to `True`.\\n- **Result**: `dp[8]` is `True`, so the function returns `True`.\\n\\nThe use of dynamic programming ensures that we are not recomputing solutions to subproblems, and the consideration of the maximum word length helps in avoiding unnecessary iterations, making this approach both elegant and efficient.\\n\\n# Complexity\\n- Time complexity: \\\\( O(n * m) \\\\), where \\\\( n \\\\) is the length of the string and \\\\( m \\\\) is the maximum length of a word in the dictionary.\\n- Space complexity: \\\\( O(n) \\\\)\\n\\n# Performance - DP\\n\\n| Language   | Runtime | Beats   | Memory   | Beats   |\\n|------------|---------|---------|----------|---------|\\n| Go         | 1 ms    | 69.76%  | 2.1 MB   | 99.78%  |\\n| Rust       | 1 ms    | 85.43%  | 2.1 MB   | 75.38%  |\\n| Java       | 1 ms    | 99.85%  | 41.1 MB  | 86.3%   |\\n| C++        | 4 ms    | 84.76%  | 7.6 MB   | 92.64%  |\\n| Python3    | 29 ms   | 99.91%  | 16.3 MB  | 97.29%  |\\n| JavaScript | 52 ms   | 95.93%  | 42.3 MB  | 95.86%  |\\n| C#         | 104 ms  | 73.58%  | 40.8 MB  | 94.98%  |\\n\\n![dp_comparison.png](https://assets.leetcode.com/users/images/cfab53e7-9add-4d41-a397-03773ec82f64_1691117831.0879085.png)\\n\\n\\n# Code - Dynamic Programming\\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        max_len = max(map(len, wordDict))  # The maximum length of a word in the dictionary\\n\\n        for i in range(1, n + 1):\\n            for j in range(i - 1, max(i - max_len - 1, -1), -1): # Only consider words that could fit\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(std::string s, std::vector<std::string>& wordDict) {\\n        int n = s.size();\\n        std::vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        int max_len = 0;\\n        for (const auto& word : wordDict) {\\n            max_len = std::max(max_len, static_cast<int>(word.size()));\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= std::max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && std::find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        int max_len = 0;\\n        for (String word : wordDict) {\\n            max_len = Math.max(max_len, word.length());\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let n = s.length;\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n    let max_len = Math.max(...wordDict.map(word => word.length));\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (let j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n            if (dp[j] && wordDict.includes(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        int n = s.Length;\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n        int max_len = 0;\\n        foreach (string word in wordDict) {\\n            max_len = Math.Max(max_len, word.Length);\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= Math.Max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && wordDict.Contains(s.Substring(j, i - j))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    n := len(s)\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n    max_len := 0\\n    for _, word := range wordDict {\\n        if len(word) > max_len {\\n            max_len = len(word)\\n        }\\n    }\\n\\n    for i := 1; i <= n; i++ {\\n        for j := i - 1; j >= max(i - max_len - 1, 0); j-- {\\n            if dp[j] && contains(wordDict, s[j:i]) {\\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n\\n    return dp[n]\\n}\\n\\nfunc contains(words []string, target string) bool {\\n    for _, word := range words {\\n        if word == target {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let n = s.len();\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n        let max_len = word_dict.iter().map(|word| word.len()).max().unwrap_or(0);\\n\\n        let word_dict: std::collections::HashSet<String> = word_dict.into_iter().collect();\\n\\n        for i in 1..=n {\\n            for j in (std::cmp::max(i as isize - max_len as isize - 1, 0) as usize..i).rev() {\\n                if dp[j] && word_dict.contains(&s[j..i].to_string()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        dp[n]\\n    }\\n}\\n```\\n\\n# Approach - Depth-First Search with Memoization\\nThe Depth-First Search (DFS) approach with memoization offers a recursive way to solve the word break problem. It leverages the Trie data structure to efficiently match prefixes and employs memoization to store intermediate results. Here\\'s a step-by-step description:\\n\\n1. **Building the Trie**: We initialize an empty Trie and iterate through each word in the dictionary (`wordDict`). For each word, we add it to the Trie, using a nested loop to traverse each character (`ch`) in the word. We use the `\\'#\\'` symbol to mark the end of a word in the Trie. We also determine the maximum length (`max_len`) of a word in the dictionary.\\n\\n2. **Initialization of Memoization**: We initialize an empty dictionary (`memo`) to store the results of subproblems. This helps in avoiding redundant computations.\\n\\n3. **DFS Function Call**: We call the recursive DFS function with initial parameters, starting from index 0.\\n\\n4. **Recursive DFS Function**:\\n    - **Memoization Check**: If the starting index (`start`) is found in `memo`, we return the stored result.\\n    - **Base Case**: If `start` equals the length of the string, we return `True`, as we have reached the end.\\n    - **Iterate Through Prefixes**: We initialize `node` to the root of the Trie and iterate through the string from the `start` index to the minimum of `start + max_len` and the length of the string.\\n    - **Trie Traversal**: For each character (`ch`), we traverse the Trie. If `ch` is not found, we break out of the loop.\\n    - **Check for Word End and Recursion**: If we find the end of a word marker (`\\'#\\'`) in the Trie, we make a recursive call to `dfs` with the next index (`i + 1`).\\n    - **Update Memoization**: If the recursive call returns `True`, we update `memo[start]` to `True` and return `True`.\\n\\n5. **Result**: Finally, we update `memo[start]` to `False` if no valid segmentation is found and return `False`.\\n\\nThis approach leverages the Trie structure to efficiently match prefixes and uses memoization to enhance efficiency. It offers a recursive and elegant solution to the word break problem.\\n\\n# Complexity\\n- Time complexity: \\\\( O(n * m + k) \\\\), where \\\\( n \\\\) is the length of the string, \\\\( m \\\\) is the maximum length of a word in the dictionary, and \\\\( k \\\\) is the total number of characters in all words in the dictionary (for building the Trie).\\n- Space complexity: \\\\( O(n + k) \\\\), where \\\\( n \\\\) is the length of the string and \\\\( k \\\\) is the total number of characters in all words in the dictionary.\\n\\n# Performance - DFS\\n\\n| Language   | Runtime | Beats  | Memory | Beats  |\\n|------------|---------|--------|--------|--------|\\n| Rust       | 0 ms    | 100%   | 2.1 MB  | 75.38% |\\n| Go         | 2 ms    | 66.9%  | 2.4 MB  | 29.16% |\\n| Java       | 8 ms    | 49.31% | 44 MB   | 14.85% |\\n| C++        | 21 ms   | 37.63% | 14.7 MB | 21.91% |\\n| Python3    | 42 ms   | 94.1%  | 17.5 MB | 5.8%   |\\n| JavaScript | 58 ms   | 86.4%  | 44.6 MB | 16.27% |\\n| C#         | 93 ms   | 94.32% | 48.1 MB | 17.47% |\\n\\n![dfs_comparison.png](https://assets.leetcode.com/users/images/49fa36d2-1560-4e64-98f6-d3cf85b253f6_1691117857.6867971.png)\\n\\n# Code - Depth-First Search with Memoization\\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        wordSet = set(wordDict)\\n        return self.dfs(s, wordSet, memo)\\n    \\n    def dfs(self, s, wordSet, memo):\\n        if s in memo:\\n            return memo[s]\\n        if s in wordSet:\\n            return True\\n        for i in range(1, len(s)):\\n            prefix = s[:i]\\n            if prefix in wordSet and self.dfs(s[i:], wordSet, memo):\\n                memo[s] = True\\n                return True\\n        memo[s] = False\\n        return False\\n```\\n``` JavaScript []\\nvar wordBreak = function(s, wordDict) {\\n    let memo = {};\\n    let wordSet = new Set(wordDict);\\n    return dfs(s, wordSet, memo);\\n};\\n\\nfunction dfs(s, wordSet, memo) {\\n    if (s in memo) return memo[s];\\n    if (wordSet.has(s)) return true;\\n    for (let i = 1; i < s.length; i++) {\\n        let prefix = s.substring(0, i);\\n        if (wordSet.has(prefix) && dfs(s.substring(i), wordSet, memo)) {\\n            memo[s] = true;\\n            return true;\\n        }\\n    }\\n    memo[s] = false;\\n    return false;\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(std::string s, std::vector<std::string>& wordDict) {\\n        std::unordered_map<std::string, bool> memo;\\n        std::unordered_set<std::string> wordSet(wordDict.begin(), wordDict.end());\\n        return dfs(s, wordSet, memo);\\n    }\\n    \\nprivate:\\n    bool dfs(const std::string& s, const std::unordered_set<std::string>& wordSet, std::unordered_map<std::string, bool>& memo) {\\n        if (memo.find(s) != memo.end()) return memo[s];\\n        if (wordSet.find(s) != wordSet.end()) return true;\\n        for (int i = 1; i < s.size(); i++) {\\n            std::string prefix = s.substr(0, i);\\n            if (wordSet.find(prefix) != wordSet.end() && dfs(s.substr(i), wordSet, memo)) {\\n                memo[s] = true;\\n                return true;\\n            }\\n        }\\n        memo[s] = false;\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Map<String, Boolean> memo = new HashMap<>();\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        return dfs(s, wordSet, memo);\\n    }\\n    \\n    private boolean dfs(String s, Set<String> wordSet, Map<String, Boolean> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        if (wordSet.contains(s)) return true;\\n        for (int i = 1; i < s.length(); i++) {\\n            String prefix = s.substring(0, i);\\n            if (wordSet.contains(prefix) && dfs(s.substring(i), wordSet, memo)) {\\n                memo.put(s, true);\\n                return true;\\n            }\\n        }\\n        memo.put(s, false);\\n        return false;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        Dictionary<string, bool> memo = new Dictionary<string, bool>();\\n        HashSet<string> wordSet = new HashSet<string>(wordDict);\\n        return Dfs(s, wordSet, memo);\\n    }\\n    \\n    private bool Dfs(string s, HashSet<string> wordSet, Dictionary<string, bool> memo) {\\n        if (memo.ContainsKey(s)) return memo[s];\\n        if (wordSet.Contains(s)) return true;\\n        for (int i = 1; i < s.Length; i++) {\\n            string prefix = s.Substring(0, i);\\n            if (wordSet.Contains(prefix) && Dfs(s.Substring(i), wordSet, memo)) {\\n                memo[s] = true;\\n                return true;\\n            }\\n        }\\n        memo[s] = false;\\n        return false;\\n    }\\n}\\n```\\n``` Rust []\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let mut memo = std::collections::HashMap::new();\\n        let word_set: HashSet<String> = word_dict.into_iter().collect();\\n        Self::dfs(s, &word_set, &mut memo)\\n    }\\n\\n    fn dfs(s: String, word_set: &HashSet<String>, memo: &mut std::collections::HashMap<String, bool>) -> bool {\\n        if let Some(&value) = memo.get(&s) {\\n            return value;\\n        }\\n        if word_set.contains(&s) {\\n            return true;\\n        }\\n        for i in 1..s.len() {\\n            let prefix = &s[0..i];\\n            if word_set.contains(prefix) && Self::dfs(s[i..].to_string(), word_set, memo) {\\n                memo.insert(s, true);\\n                return true;\\n            }\\n        }\\n        memo.insert(s, false);\\n        return false;\\n    }\\n}\\n```\\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n\\tmemo := make(map[string]bool)\\n\\twordSet := make(map[string]bool)\\n\\tfor _, word := range wordDict {\\n\\t\\twordSet[word] = true\\n\\t}\\n\\treturn dfs(s, wordSet, memo)\\n}\\n\\nfunc dfs(s string, wordSet map[string]bool, memo map[string]bool) bool {\\n\\tif value, exists := memo[s]; exists {\\n\\t\\treturn value\\n\\t}\\n\\tif _, exists := wordSet[s]; exists {\\n\\t\\treturn true\\n\\t}\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tprefix := s[:i]\\n\\t\\tif _, exists := wordSet[prefix]; exists && dfs(s[i:], wordSet, memo) {\\n\\t\\t\\tmemo[s] = true\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\tmemo[s] = false\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        max_len = max(map(len, wordDict))  # The maximum length of a word in the dictionary\\n\\n        for i in range(1, n + 1):\\n            for j in range(i - 1, max(i - max_len - 1, -1), -1): # Only consider words that could fit\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(std::string s, std::vector<std::string>& wordDict) {\\n        int n = s.size();\\n        std::vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        int max_len = 0;\\n        for (const auto& word : wordDict) {\\n            max_len = std::max(max_len, static_cast<int>(word.size()));\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= std::max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && std::find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        int max_len = 0;\\n        for (String word : wordDict) {\\n            max_len = Math.max(max_len, word.length());\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let n = s.length;\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n    let max_len = Math.max(...wordDict.map(word => word.length));\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (let j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n            if (dp[j] && wordDict.includes(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        int n = s.Length;\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n        int max_len = 0;\\n        foreach (string word in wordDict) {\\n            max_len = Math.Max(max_len, word.Length);\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= Math.Max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && wordDict.Contains(s.Substring(j, i - j))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    n := len(s)\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n    max_len := 0\\n    for _, word := range wordDict {\\n        if len(word) > max_len {\\n            max_len = len(word)\\n        }\\n    }\\n\\n    for i := 1; i <= n; i++ {\\n        for j := i - 1; j >= max(i - max_len - 1, 0); j-- {\\n            if dp[j] && contains(wordDict, s[j:i]) {\\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n\\n    return dp[n]\\n}\\n\\nfunc contains(words []string, target string) bool {\\n    for _, word := range words {\\n        if word == target {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let n = s.len();\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n        let max_len = word_dict.iter().map(|word| word.len()).max().unwrap_or(0);\\n\\n        let word_dict: std::collections::HashSet<String> = word_dict.into_iter().collect();\\n\\n        for i in 1..=n {\\n            for j in (std::cmp::max(i as isize - max_len as isize - 1, 0) as usize..i).rev() {\\n                if dp[j] && word_dict.contains(&s[j..i].to_string()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        dp[n]\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        wordSet = set(wordDict)\\n        return self.dfs(s, wordSet, memo)\\n    \\n    def dfs(self, s, wordSet, memo):\\n        if s in memo:\\n            return memo[s]\\n        if s in wordSet:\\n            return True\\n        for i in range(1, len(s)):\\n            prefix = s[:i]\\n            if prefix in wordSet and self.dfs(s[i:], wordSet, memo):\\n                memo[s] = True\\n                return True\\n        memo[s] = False\\n        return False\\n```\n``` JavaScript []\\nvar wordBreak = function(s, wordDict) {\\n    let memo = {};\\n    let wordSet = new Set(wordDict);\\n    return dfs(s, wordSet, memo);\\n};\\n\\nfunction dfs(s, wordSet, memo) {\\n    if (s in memo) return memo[s];\\n    if (wordSet.has(s)) return true;\\n    for (let i = 1; i < s.length; i++) {\\n        let prefix = s.substring(0, i);\\n        if (wordSet.has(prefix) && dfs(s.substring(i), wordSet, memo)) {\\n            memo[s] = true;\\n            return true;\\n        }\\n    }\\n    memo[s] = false;\\n    return false;\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(std::string s, std::vector<std::string>& wordDict) {\\n        std::unordered_map<std::string, bool> memo;\\n        std::unordered_set<std::string> wordSet(wordDict.begin(), wordDict.end());\\n        return dfs(s, wordSet, memo);\\n    }\\n    \\nprivate:\\n    bool dfs(const std::string& s, const std::unordered_set<std::string>& wordSet, std::unordered_map<std::string, bool>& memo) {\\n        if (memo.find(s) != memo.end()) return memo[s];\\n        if (wordSet.find(s) != wordSet.end()) return true;\\n        for (int i = 1; i < s.size(); i++) {\\n            std::string prefix = s.substr(0, i);\\n            if (wordSet.find(prefix) != wordSet.end() && dfs(s.substr(i), wordSet, memo)) {\\n                memo[s] = true;\\n                return true;\\n            }\\n        }\\n        memo[s] = false;\\n        return false;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Map<String, Boolean> memo = new HashMap<>();\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        return dfs(s, wordSet, memo);\\n    }\\n    \\n    private boolean dfs(String s, Set<String> wordSet, Map<String, Boolean> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        if (wordSet.contains(s)) return true;\\n        for (int i = 1; i < s.length(); i++) {\\n            String prefix = s.substring(0, i);\\n            if (wordSet.contains(prefix) && dfs(s.substring(i), wordSet, memo)) {\\n                memo.put(s, true);\\n                return true;\\n            }\\n        }\\n        memo.put(s, false);\\n        return false;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        Dictionary<string, bool> memo = new Dictionary<string, bool>();\\n        HashSet<string> wordSet = new HashSet<string>(wordDict);\\n        return Dfs(s, wordSet, memo);\\n    }\\n    \\n    private bool Dfs(string s, HashSet<string> wordSet, Dictionary<string, bool> memo) {\\n        if (memo.ContainsKey(s)) return memo[s];\\n        if (wordSet.Contains(s)) return true;\\n        for (int i = 1; i < s.Length; i++) {\\n            string prefix = s.Substring(0, i);\\n            if (wordSet.Contains(prefix) && Dfs(s.Substring(i), wordSet, memo)) {\\n                memo[s] = true;\\n                return true;\\n            }\\n        }\\n        memo[s] = false;\\n        return false;\\n    }\\n}\\n```\n``` Rust []\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let mut memo = std::collections::HashMap::new();\\n        let word_set: HashSet<String> = word_dict.into_iter().collect();\\n        Self::dfs(s, &word_set, &mut memo)\\n    }\\n\\n    fn dfs(s: String, word_set: &HashSet<String>, memo: &mut std::collections::HashMap<String, bool>) -> bool {\\n        if let Some(&value) = memo.get(&s) {\\n            return value;\\n        }\\n        if word_set.contains(&s) {\\n            return true;\\n        }\\n        for i in 1..s.len() {\\n            let prefix = &s[0..i];\\n            if word_set.contains(prefix) && Self::dfs(s[i..].to_string(), word_set, memo) {\\n                memo.insert(s, true);\\n                return true;\\n            }\\n        }\\n        memo.insert(s, false);\\n        return false;\\n    }\\n}\\n```\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n\\tmemo := make(map[string]bool)\\n\\twordSet := make(map[string]bool)\\n\\tfor _, word := range wordDict {\\n\\t\\twordSet[word] = true\\n\\t}\\n\\treturn dfs(s, wordSet, memo)\\n}\\n\\nfunc dfs(s string, wordSet map[string]bool, memo map[string]bool) bool {\\n\\tif value, exists := memo[s]; exists {\\n\\t\\treturn value\\n\\t}\\n\\tif _, exists := wordSet[s]; exists {\\n\\t\\treturn true\\n\\t}\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tprefix := s[:i]\\n\\t\\tif _, exists := wordSet[prefix]; exists && dfs(s[i:], wordSet, memo) {\\n\\t\\t\\tmemo[s] = true\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\tmemo[s] = false\\n\\treturn false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428606,
                "title": "python-simple-iterative-bfs-or-dfs-24ms",
                "content": "Simple iterative BFS or DFS. 24 to 32 ms (Python 3, Nov 2019).\\n\\nStarts with string `s`. For each string visited, chop off front of string if it starts with a word in the dictionary and adds the shortened string to the queue or stack. If string becomes empty, that means word break succeeded. Keep a set of seen string states  to avoid duplicate work.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        from collections import deque\\n   \\t\\tq = deque([s])\\n\\t\\tseen = set() \\n\\t\\twhile q:\\n            s = q.popleft()    # popleft() = BFS ; pop() = DFS\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    new_s = s[len(word):]\\n\\t\\t\\t\\t\\tif new_s == \"\": \\n                        return True\\n                    if new_s not in seen:\\n                        q.append(new_s)\\n                        seen.add(new_s)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        from collections import deque\\n   \\t\\tq = deque([s])\\n\\t\\tseen = set() \\n\\t\\twhile q:\\n            s = q.popleft()    # popleft() = BFS ; pop() = DFS\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    new_s = s[len(word):]\\n\\t\\t\\t\\t\\tif new_s == \"\": \\n                        return True\\n                    if new_s not in seen:\\n                        q.append(new_s)\\n                        seen.add(new_s)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397927,
                "title": "clean-javascript-solution-bfs-dynamic-programming",
                "content": "**Method 1 BFS**\\n\\n```\\nconst wordBreak = (s, wordDict) => {\\n  if (wordDict == null || wordDict.length === 0) return false;\\n  const set = new Set(wordDict);\\n\\n  // When s = \\'catsandog\\', wordDict = [\\'cats\\', \\'ca\\', \\'ts\\']\\n  // After \\'cats\\' and \\'ca\\', it will become \\'andog\\', \\'tsandog\\'\\n  // For \\'tsandog\\', after \\'ts\\', it will become \\'andog\\' again, visited set here is for memoization\\n  const visited = new Set();\\n  const q = [0];\\n\\n  while (q.length) {\\n    const start = q.shift();\\n\\n    if (!visited.has(start)) {\\n      for (let end = start + 1; end <= s.length; end++) {\\n        if (set.has(s.slice(start, end))) {\\n          if (end === s.length) return true;\\n          q.push(end);\\n        }\\n      }\\n      visited.add(start);\\n    }\\n  }\\n  return false;\\n};\\n```\\n\\n**Method 2 Dynamic Programming**\\n\\n```\\nconst wordBreak = (s, wordDict) => {\\n  if (wordDict == null || wordDict.length === 0) return false;\\n\\n  const set = new Set(wordDict);\\n  const dp = Array(s.length + 1).fill(false);\\n  dp[0] = true;\\n\\n  for (let end = 1; end <= s.length; end++) {\\n    for (let start = 0; start < end; start++) {\\n      const w = s.slice(start, end);\\n      if (dp[start] === true && set.has(w)) {\\n        dp[end] = true;\\n        break;\\n      }\\n    }\\n  }\\n  return dp[s.length];\\n};\\n```\\n\\n```\\n// e.g.\\n// \\'leetcode\\'\\n// [\\'leet\\', \\'code\\']\\n//\\n// i = 1 j = 0 l\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 2 j = 0 le\\n// i = 2 j = 1  e\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 3 j = 0 lee\\n// i = 3 j = 1  ee\\n// i = 3 j = 2   e\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 4 j = 0 leet\\n// match\\n// dp = [true, false, false, false, true, false, false, false, false]\\n//\\n// i = 5 j = 0 leetc\\n// i = 5 j = 1  eetc\\n// i = 5 j = 2   etc\\n// i = 5 j = 3    tc\\n// i = 5 j = 4     c\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 6 j = 0 leetco\\n// i = 6 j = 1  eetco\\n// i = 6 j = 2   etco\\n// i = 6 j = 3    tco\\n// i = 6 j = 4     co\\n// i = 6 j = 5      o\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 7 j = 0 leetcod\\n// i = 7 j = 1  eetcod\\n// i = 7 j = 2   etcod\\n// i = 7 j = 3    tcod\\n// i = 7 j = 4     cod\\n// i = 7 j = 5      od\\n// i = 7 j = 6       d\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 8 j = 0 leetcode\\n// i = 8 j = 1  eetcode\\n// i = 8 j = 2   etcode\\n// i = 8 j = 3    tcode\\n// i = 8 j = 4     code\\n// match\\n// dp = [true, false, false, false, true, false, false, false, true]\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst wordBreak = (s, wordDict) => {\\n  if (wordDict == null || wordDict.length === 0) return false;\\n  const set = new Set(wordDict);\\n\\n  // When s = \\'catsandog\\', wordDict = [\\'cats\\', \\'ca\\', \\'ts\\']\\n  // After \\'cats\\' and \\'ca\\', it will become \\'andog\\', \\'tsandog\\'\\n  // For \\'tsandog\\', after \\'ts\\', it will become \\'andog\\' again, visited set here is for memoization\\n  const visited = new Set();\\n  const q = [0];\\n\\n  while (q.length) {\\n    const start = q.shift();\\n\\n    if (!visited.has(start)) {\\n      for (let end = start + 1; end <= s.length; end++) {\\n        if (set.has(s.slice(start, end))) {\\n          if (end === s.length) return true;\\n          q.push(end);\\n        }\\n      }\\n      visited.add(start);\\n    }\\n  }\\n  return false;\\n};\\n```\n```\\nconst wordBreak = (s, wordDict) => {\\n  if (wordDict == null || wordDict.length === 0) return false;\\n\\n  const set = new Set(wordDict);\\n  const dp = Array(s.length + 1).fill(false);\\n  dp[0] = true;\\n\\n  for (let end = 1; end <= s.length; end++) {\\n    for (let start = 0; start < end; start++) {\\n      const w = s.slice(start, end);\\n      if (dp[start] === true && set.has(w)) {\\n        dp[end] = true;\\n        break;\\n      }\\n    }\\n  }\\n  return dp[s.length];\\n};\\n```\n```\\n// e.g.\\n// \\'leetcode\\'\\n// [\\'leet\\', \\'code\\']\\n//\\n// i = 1 j = 0 l\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 2 j = 0 le\\n// i = 2 j = 1  e\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 3 j = 0 lee\\n// i = 3 j = 1  ee\\n// i = 3 j = 2   e\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 4 j = 0 leet\\n// match\\n// dp = [true, false, false, false, true, false, false, false, false]\\n//\\n// i = 5 j = 0 leetc\\n// i = 5 j = 1  eetc\\n// i = 5 j = 2   etc\\n// i = 5 j = 3    tc\\n// i = 5 j = 4     c\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 6 j = 0 leetco\\n// i = 6 j = 1  eetco\\n// i = 6 j = 2   etco\\n// i = 6 j = 3    tco\\n// i = 6 j = 4     co\\n// i = 6 j = 5      o\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 7 j = 0 leetcod\\n// i = 7 j = 1  eetcod\\n// i = 7 j = 2   etcod\\n// i = 7 j = 3    tcod\\n// i = 7 j = 4     cod\\n// i = 7 j = 5      od\\n// i = 7 j = 6       d\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 8 j = 0 leetcode\\n// i = 8 j = 1  eetcode\\n// i = 8 j = 2   etcode\\n// i = 8 j = 3    tcode\\n// i = 8 j = 4     code\\n// match\\n// dp = [true, false, false, false, true, false, false, false, true]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748479,
                "title": "python3-solution-with-a-detailed-explanation-word-break",
                "content": "The idea is that we go over the combinations of substrings of `s` and see whether they are available in the dictionary. Read [this](https://leetcode.com/problems/word-break/discuss/169383/The-Time-Complexity-of-The-Brute-Force-Method-Should-Be-O(2n)-and-Prove-It-Below) to get a better intuition. \\n\\nWe initialize `dp` to take care of cases that sub-string exists in the `wordDict`. `dp[i]` shows whether subarray `s[0:i]` is available in the `wordDict`. Based on this, `dp[0]` is basically an empty string, that\\'s why we set it to `True` before the `for` loops begin. Then we first loop over `s` and check each substring by starting a new `for` loop that checks the availability of each substring between `j` and `i` (`s[j:i]`). For example if `s = \"leetcode\", wordDict = [\"leet\", \"code\"]`, and `i = 2`, in the inner loop `j` takes values of `0, 1`. Then if `d[j]` is true, meaning that up to that particular `j` is found already, and `s[j:i]` is in the `wordDict`, it would turn `dp[i]` to true showing that we\\'ve found `s[:i]` already in the `wordDict` somewhere. In the below example, `dp = [ True, False, False, False, True ..]` since we found `leet` in the `wordDict`. Note that between index `0` and `4`, there are `False`s.  This is because we don\\'t have `l` or `le` or `lee` in `wordDict`. All the available combinations would be `True` in the `dp` (given the possibility of multiple segmentation) and while the second loop is checking substrings, the `if` statement would take care of all of them. This means that there might be multiple possible segmentations in the `wordDict` and once we found the first one, we\\'re done. \\n\\nQuestion: Imagine `wordDic = [\"leet\",\"code\", \"lee\",\"tcode\"]` and `s= \"leetcode\"`, alright? Can you tell which combinations the code will find first? `lee` and `tcode` because when doing the second loop and checking `s[j:i]` when `i = 8`, `tcode` comes before `code` (note the `break` that gets us out of second loop). Note that it finds both `lee` and `leet` as correct substrings and will turn the `dp` to `True` for them (`dp[3] = True` and `dp[4] = True`). \\n\\nYou might ask why `dp[j]` is there in the `if` statement? Consider this `wordDict = [\"leet\",\"ode\"]`. If that wasn\\'t for `dp[j]` in the `if` statement, `dp[i]` could be turned to `True` while we were missing a letter in the `s`. Basically, `dp[j]` marks a safe station for the loop to move forward with the searching having in mind that up to this point is taken care of. \\n```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n\\t\\tdp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(1, len(s)+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n\\t\\t\\t\\t\\tdp[i] = True\\n                    break\\n                    \\n        return dp[-1]\\n    \\n```\\n\\nThat\\'s it.\\n\\n======================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n\\t\\tdp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(1, len(s)+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n\\t\\t\\t\\t\\tdp[i] = True\\n                    break\\n                    \\n        return dp[-1]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 43819,
                "title": "dfs-with-path-memorizing-java-solution",
                "content": "I write this method by what I learned from @[mahdy][1] in his post [Decode Ways][2]\\n\\nUse a set to record all position that cannot find a match in dict. That cuts down the run time of DFS to O(n^2)\\n\\n    public class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            // DFS\\n            Set<Integer> set = new HashSet<Integer>();\\n            return dfs(s, 0, dict, set);\\n        }\\n        \\n        private boolean dfs(String s, int index, Set<String> dict, Set<Integer> set){\\n            // base case\\n            if(index == s.length()) return true;\\n            // check memory\\n            if(set.contains(index)) return false;\\n            // recursion\\n            for(int i = index+1;i <= s.length();i++){\\n                String t = s.substring(index, i);\\n                if(dict.contains(t))\\n                    if(dfs(s, i, dict, set))\\n                        return true;\\n                    else\\n                        set.add(i);\\n            }\\n            set.add(index);\\n            return false;\\n        }\\n    }\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/user/mahdy\\n  [2]: https://oj.leetcode.com/discuss/23872/sharing-my-java-memoized-solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            // DFS\\n            Set<Integer> set = new HashSet<Integer>();\\n            return dfs(s, 0, dict, set);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 809993,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool>dp(s.size(),false);\\n        dp[0]=true;\\n        \\n        for(int i = 0; i <= s.size(); i++)\\n        {\\n            for(auto str: wordDict)\\n            {\\n                if(dp[i])\\n                {\\n                    if(s.substr(i,str.size()).compare(str)==0)\\n                    {\\n                        dp[i+str.size()]=true;\\n                    }\\n                }\\n            }\\n        }return dp[s.size()];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool>dp(s.size(),false);\\n        dp[0]=true;\\n        \\n        for(int i = 0; i <= s.size(); i++)\\n        {\\n            for(auto str: wordDict)\\n            {\\n                if(dp[i])\\n                {\\n                    if(s.substr(i,str.size()).compare(str)==0)\\n                    {\\n                        dp[i+str.size()]=true;\\n                    }\\n                }\\n            }\\n        }return dp[s.size()];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311028,
                "title": "3-solutions-cpp",
                "content": "**RECURSION, Time Limit Exceeded o(2^N)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(),wordDict.end(),s)!=wordDict.end())\\n            return true;\\n    \\n        for(int i=1;i<s.size();i++){\\n            string left = s.substr(0,i);\\n            if(find(wordDict.begin(),wordDict.end(),left)!=wordDict.end() && wordBreak(s.substr(i),wordDict)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```\\n\\n**MEMOIZATION, 22.76% of C++ online submissions**\\n```\\nclass Solution {\\n map <string,bool> m;\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(),wordDict.end(),s)!=wordDict.end())\\n            return true;\\n        if(m.find(s)!=m.end())\\n            return m[s];\\n        for(int i=1;i<s.size();i++){\\n            string left = s.substr(0,i);\\n                 cout<<left<<\"#\";\\n            if(find(wordDict.begin(),wordDict.end(),left)!=wordDict.end() && wordBreak(s.substr(i),wordDict)){\\n                  m[s]=true;\\n                return true;\\n            }\\n        }\\n   \\n        m[s]=false;\\n        return false;\\n    }\\n    \\n};\\n```\\n\\n**DP, 16 ms, faster than 54.11% of C++ online submissions**\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int len = s.length();\\n        vector<bool> dp(len+1,false);\\n        dp[0] = true;\\n        \\n        for(int i=1;i<=len;i++){\\n            for(int j=0;j<i;j++){\\n               if(dp[j] and find(wordDict.begin(),wordDict.end(),s.substr(j,i-j))!=wordDict.end()){\\n                dp[i]=true;   \\n               }              \\n            }\\n        }\\n         return dp[len];\\n    }\\n};\\n```\\n\\nANY SUGGESTION WILL BE APPRITIATED AND PLEASE UPVOTE IF FOUND HELPFUL \\uD83D\\uDE00",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(),wordDict.end(),s)!=wordDict.end())\\n            return true;\\n    \\n        for(int i=1;i<s.size();i++){\\n            string left = s.substr(0,i);\\n            if(find(wordDict.begin(),wordDict.end(),left)!=wordDict.end() && wordBreak(s.substr(i),wordDict)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\n map <string,bool> m;\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(),wordDict.end(),s)!=wordDict.end())\\n            return true;\\n        if(m.find(s)!=m.end())\\n            return m[s];\\n        for(int i=1;i<s.size();i++){\\n            string left = s.substr(0,i);\\n                 cout<<left<<\"#\";\\n            if(find(wordDict.begin(),wordDict.end(),left)!=wordDict.end() && wordBreak(s.substr(i),wordDict)){\\n                  m[s]=true;\\n                return true;\\n            }\\n        }\\n   \\n        m[s]=false;\\n        return false;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int len = s.length();\\n        vector<bool> dp(len+1,false);\\n        dp[0] = true;\\n        \\n        for(int i=1;i<=len;i++){\\n            for(int j=0;j<i;j++){\\n               if(dp[j] and find(wordDict.begin(),wordDict.end(),s.substr(j,i-j))!=wordDict.end()){\\n                dp[i]=true;   \\n               }              \\n            }\\n        }\\n         return dp[len];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 161162,
                "title": "from-brute-force-to-dp",
                "content": "### Brute Force\\n> Could we break the word? We can start from putting the first space.\\n> Where should we put the first space? We can enumerate all possible positions to put the first space.\\n\\n> Take `s = leetcodegood, wordDict = {leet, code, good}` for example,\\n ```\\n   leetcodegood______________________________________________________________________________________\\n\\t /                \\\\                     \\\\                \\\\  leet in dict                        \\\\ \\nl(eetcodegood) le(etcodegood) lee(tcodegood)     leet(codegood)________________                      leetc(odegood) ...\\n                                                  /           |        \\\\         \\\\ code in dict\\n                                              c(odegood) co(degood) cod(egood) code(good)\\n                                                                                /\\n                                                                              g(ood), ...\\n ```\\n> We check all possible break positions \\'l\\', \\'le\\', \\'lee\\'... until we meet `leet`, which is in dict.\\n> Then the problem becomes to if we could break `codegood`, etc.\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recur(s, 0, wordDict);\\n    }\\n    \\n    private boolean recur(String s, int curIndex, List<String> wordDict) {\\n        if (curIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        for (int end = curIndex + 1; end <= s.length(); end++) {\\n            String split = s.substring(curIndex, end);\\n            if (wordDict.contains(split)) {\\n                if(recur(s, end, wordDict)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n\\n### Top-down DP\\nWe can use memoization to overcome overlapping subproblems.\\n```\\nclass Solution {\\n    private Boolean[] dp;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        dp = new Boolean[s.length()];\\n        return recur(s, 0, wordDict);\\n    }\\n    \\n    \\n    private boolean recur(String s, int curIndex, List<String> wordDict) {\\n        if (curIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        if (dp[curIndex] != null) {\\n            return dp[curIndex];\\n        }\\n        for (int end = curIndex + 1; end <= s.length(); end++) {\\n            String split = s.substring(curIndex, end);\\n            if (wordDict.contains(split)) {\\n                if(recur(s, end, wordDict)) {\\n                    return dp[curIndex] = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[curIndex] = false;\\n    }\\n}\\n```\\n### Bottom-up DP\\nDefine dp[i] as whether we can break s[0, i).\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>();\\n        wordSet.addAll(wordDict);\\n        \\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i < dp.length ; i++) {\\n            for (int k = 1; k <= i; k++) {\\n                dp[i] = dp[i] || (dp[i - k] && wordSet.contains(s.substring(i - k, i)));\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n   leetcodegood______________________________________________________________________________________\\n\\t /                \\\\                     \\\\                \\\\  leet in dict                        \\\\ \\nl(eetcodegood) le(etcodegood) lee(tcodegood)     leet(codegood)________________                      leetc(odegood) ...\\n                                                  /           |        \\\\         \\\\ code in dict\\n                                              c(odegood) co(degood) cod(egood) code(good)\\n                                                                                /\\n                                                                              g(ood), ...\\n ```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recur(s, 0, wordDict);\\n    }\\n    \\n    private boolean recur(String s, int curIndex, List<String> wordDict) {\\n        if (curIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        for (int end = curIndex + 1; end <= s.length(); end++) {\\n            String split = s.substring(curIndex, end);\\n            if (wordDict.contains(split)) {\\n                if(recur(s, end, wordDict)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Boolean[] dp;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        dp = new Boolean[s.length()];\\n        return recur(s, 0, wordDict);\\n    }\\n    \\n    \\n    private boolean recur(String s, int curIndex, List<String> wordDict) {\\n        if (curIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        if (dp[curIndex] != null) {\\n            return dp[curIndex];\\n        }\\n        for (int end = curIndex + 1; end <= s.length(); end++) {\\n            String split = s.substring(curIndex, end);\\n            if (wordDict.contains(split)) {\\n                if(recur(s, end, wordDict)) {\\n                    return dp[curIndex] = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[curIndex] = false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>();\\n        wordSet.addAll(wordDict);\\n        \\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i < dp.length ; i++) {\\n            for (int k = 1; k <= i; k++) {\\n                dp[i] = dp[i] || (dp[i - k] && wordSet.contains(s.substring(i - k, i)));\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172343,
                "title": "java-solution-99-faster-90-less-space-memoization",
                "content": "Instead of checking which substrings exist in the dictionary,\\nI used the fact that the given word can be constructed from the words in the dictionary\\n\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t// for memoization\\n        HashMap<String,Boolean> map= new HashMap<>();\\n        return canConstruct(s, wordDict, map);\\n    }\\n    \\n    public boolean canConstruct(String target,List<String> words, HashMap<String,Boolean> map)\\n    {\\n\\t\\n\\t// if answer already cached, return it\\n        if(map.containsKey(target))\\n            return map.get(target);\\n\\t\\t\\t\\n\\t\\t// if target string is empty\\n\\t\\t// it can always be constructed by taking no elements from dictionary\\n        if(target.isEmpty())\\n            return true;\\n\\t\\t\\t\\n\\t\\t// for all words in the dictionary\\n        for(String word: words)\\n        {\\n\\t\\t// if the target starts with the given word\\n            if(target.startsWith(word))\\n            {\\n\\t\\t\\t// and it is possible to construct the rest of the string\\n\\t\\t\\t// from the words in the dictionary\\n                if(canConstruct(target.substring(word.length()),words, map))\\n                {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// save and return true\\n                    map.put(target, true);\\n                    return true;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if it was not possible to construct the target from words from the dictionary\\n\\t\\t// save and return false to the previous call\\n        map.put(target,false);\\n        return false;\\n    }\\n}\\n```\\n\\nUpvote if you liked:)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t// for memoization\\n        HashMap<String,Boolean> map= new HashMap<>();\\n        return canConstruct(s, wordDict, map);\\n    }\\n    \\n    public boolean canConstruct(String target,List<String> words, HashMap<String,Boolean> map)\\n    {\\n\\t\\n\\t// if answer already cached, return it\\n        if(map.containsKey(target))\\n            return map.get(target);\\n\\t\\t\\t\\n\\t\\t// if target string is empty\\n\\t\\t// it can always be constructed by taking no elements from dictionary\\n        if(target.isEmpty())\\n            return true;\\n\\t\\t\\t\\n\\t\\t// for all words in the dictionary\\n        for(String word: words)\\n        {\\n\\t\\t// if the target starts with the given word\\n            if(target.startsWith(word))\\n            {\\n\\t\\t\\t// and it is possible to construct the rest of the string\\n\\t\\t\\t// from the words in the dictionary\\n                if(canConstruct(target.substring(word.length()),words, map))\\n                {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// save and return true\\n                    map.put(target, true);\\n                    return true;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if it was not possible to construct the target from words from the dictionary\\n\\t\\t// save and return false to the previous call\\n        map.put(target,false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43879,
                "title": "beat-90-java-c-trie-dp-solution-36-lines-7ms-3ms-java-set-dp-solution-31-lines-7ms",
                "content": "So as many have seen this:\\n\\n> **UPDATE (2017/1/4):**\\n> The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\\n\\nIn a (sort of) similar problem <https://leetcode.com/problems/word-search-ii> there's a use of Trie instead of Set of Strings to speed up the lookup - but why not the word break?\\n\\nSo my understanding for this change in word break is that it does not limit interviewee to process it as Set but also as Trie.\\n\\nif you have already written a Trie for the <https://leetcode.com/problems/implement-trie-prefix-tree> problem or the word-search-ii problem, you should probably copy-paste it to here (and adjust it).\\n\\nThe current C++ DP w/ Set solution runs in 4ms but the below C++ DP w/ Trie solution runs in 3ms.\\n\\nMy Java re-write of solution <https://discuss.leetcode.com/topic/74943/c-dp-solution-with-trie-tree>:\\n\\n```\\npublic class Solution {\\n    private TrieNode root = new TrieNode();\\n    public boolean wordBreak(String str, List<String> wordDict) {\\n        for (String word : wordDict)\\n            addToTrie(word);\\n        boolean[] dp = new boolean[str.length() + 1];\\n        char[] s = str.toCharArray();\\n        dp[0] = true;\\n        for (int i = 0; i < s.length; i++) {\\n            if (!dp[i])\\n                continue;\\n            int j = i; // start trie traversal\\n            TrieNode cur = root;\\n            while (j < s.length && cur.children[s[j] - 'a'] != null) {\\n                cur = cur.children[s[j++] - 'a'];\\n                if (cur.isWord)\\n                    dp[j] = true;\\n            }\\n        }\\n        return dp[str.length()];\\n    }\\n\\n    private void addToTrie(String word) {\\n        TrieNode cur = root;\\n        for (char ch : word.toCharArray()) {\\n            if (cur.children[ch - 'a'] == null)\\n                cur.children[ch - 'a'] = new TrieNode();\\n            cur = cur.children[ch - 'a'];\\n        }\\n        cur.isWord = true;\\n    }\\n    class TrieNode {\\n        public boolean isWord;\\n        public TrieNode[] children = new TrieNode[26];\\n    }\\n}\\n```\\n\\nThe original C++ solution:\\n\\n\\n```\\nclass DictNode {\\npublic:\\n    bool isWord = false;\\n    DictNode *next[26] = {0};\\n};\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        buildDict(wordDict);\\n        int len = s.length();\\n        bool *dp = new bool[len + 1]{0};\\n        dp[0] = 1;\\n        for(int i = 0; i < len; ++i) {\\n            if(!dp[i]) continue;\\n            DictNode* p = dict;\\n            int j = i;\\n            while(j < len && p -> next[s[j] - 'a']) {\\n                p = p -> next[s[j++] - 'a'];\\n                if(p -> isWord) dp[j] = 1;\\n            }\\n            if(dp[len]) return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    DictNode *dict;\\n    \\n    void buildDict(vector<string>& wordDict) {\\n        dict = new DictNode();\\n        DictNode* p;\\n        for(auto &w : wordDict) {\\n            p = dict;\\n            for(auto &c : w) {\\n                auto &next = p -> next[c - 'a'];\\n                if(!next) next = new DictNode();\\n                p = next;\\n            }\\n            p -> isWord = true;\\n        }\\n    }\\n};\\n\\n```\\n\\n* discussion inspired by: <https://discuss.leetcode.com/topic/74192/why-worddict-changed-into-list/3>\\n\\nAlso attached my 7ms-beats-90% (as of Feb 2, 2017) Simple DP solution - just use dictionary\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        int[] maxmin = getMaxMin(wordDict);\\n        int maxLen = maxmin[0];\\n        int minLen = maxmin[1];\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int l = Math.max(0, i - maxLen); l + minLen <= i; l++) {\\n                if (dp[l] && wordSet.contains(s.substring(l, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int l = 0; l < s.length(); l++)\\n            for (int len = minLen; len <= maxLen && l + len <= s.length(); len++)\\n                if (!dp[l + len] && dp[l] && wordSet.contains(s.substring(l, l + len)))\\n                    dp[l + len] = true;\\n        return dp[s.length()];\\n    }\\n    private int[] getMaxMin(List<String> list) {\\n        int max = 0, min = 0;\\n        for (String s : list) {\\n            max = Math.max(max, s.length());\\n            min = Math.min(min, s.length());\\n        }\\n        return new int[]{max, min};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\npublic class Solution {\\n    private TrieNode root = new TrieNode();\\n    public boolean wordBreak(String str, List<String> wordDict) {\\n        for (String word : wordDict)\\n            addToTrie(word);\\n        boolean[] dp = new boolean[str.length() + 1];\\n        char[] s = str.toCharArray();\\n        dp[0] = true;\\n        for (int i = 0; i < s.length; i++) {\\n            if (!dp[i])\\n                continue;\\n            int j = i; // start trie traversal\\n            TrieNode cur = root;\\n            while (j < s.length && cur.children[s[j] - 'a'] != null) {\\n                cur = cur.children[s[j++] - 'a'];\\n                if (cur.isWord)\\n                    dp[j] = true;\\n            }\\n        }\\n        return dp[str.length()];\\n    }\\n\\n    private void addToTrie(String word) {\\n        TrieNode cur = root;\\n        for (char ch : word.toCharArray()) {\\n            if (cur.children[ch - 'a'] == null)\\n                cur.children[ch - 'a'] = new TrieNode();\\n            cur = cur.children[ch - 'a'];\\n        }\\n        cur.isWord = true;\\n    }\\n    class TrieNode {\\n        public boolean isWord;\\n        public TrieNode[] children = new TrieNode[26];\\n    }\\n}\\n```\n```\\nclass DictNode {\\npublic:\\n    bool isWord = false;\\n    DictNode *next[26] = {0};\\n};\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        buildDict(wordDict);\\n        int len = s.length();\\n        bool *dp = new bool[len + 1]{0};\\n        dp[0] = 1;\\n        for(int i = 0; i < len; ++i) {\\n            if(!dp[i]) continue;\\n            DictNode* p = dict;\\n            int j = i;\\n            while(j < len && p -> next[s[j] - 'a']) {\\n                p = p -> next[s[j++] - 'a'];\\n                if(p -> isWord) dp[j] = 1;\\n            }\\n            if(dp[len]) return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    DictNode *dict;\\n    \\n    void buildDict(vector<string>& wordDict) {\\n        dict = new DictNode();\\n        DictNode* p;\\n        for(auto &w : wordDict) {\\n            p = dict;\\n            for(auto &c : w) {\\n                auto &next = p -> next[c - 'a'];\\n                if(!next) next = new DictNode();\\n                p = next;\\n            }\\n            p -> isWord = true;\\n        }\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        int[] maxmin = getMaxMin(wordDict);\\n        int maxLen = maxmin[0];\\n        int minLen = maxmin[1];\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int l = Math.max(0, i - maxLen); l + minLen <= i; l++) {\\n                if (dp[l] && wordSet.contains(s.substring(l, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int l = 0; l < s.length(); l++)\\n            for (int len = minLen; len <= maxLen && l + len <= s.length(); len++)\\n                if (!dp[l + len] && dp[l] && wordSet.contains(s.substring(l, l + len)))\\n                    dp[l + len] = true;\\n        return dp[s.length()];\\n    }\\n    private int[] getMaxMin(List<String> list) {\\n        int max = 0, min = 0;\\n        for (String s : list) {\\n            max = Math.max(max, s.length());\\n            min = Math.min(min, s.length());\\n        }\\n        return new int[]{max, min};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860709,
                "title": "very-easy-and-short-code-memoization-dp-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBreak the problem into subproblems sb and check if sb can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtu.be/-bSiawDmYkQ\\n or link in my profile.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a recursive approach with memoization to determine if the input string `s` can be broken down into valid words from the given `wordDict`. It iterates through all possible prefixes of the input string, and for each prefix, it checks if it exists in the `wordDict`. If found, it makes a recursive call with the remaining suffix of the input string. Memoization is used to avoid redundant computations and improve efficiency. If a valid segmentation is found, the function returns `true`, otherwise `false`.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$ where n is string length.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n     unordered_map<string,bool>dp;\\n    bool solve(string s,unordered_set<string>&m){\\n        if(s.length()==0){\\n            return true;\\n        }\\n        if(dp.find(s)!=dp.end())\\n        return dp[s];\\n        for(int i=0;i<s.length();i++){\\n            string r=s.substr(0,i+1);\\n            if(m.count(r)){\\n                if(solve(s.substr(i+1),m))\\n                return dp[s]=true;\\n            }\\n        }\\n        return dp[s]=false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n         unordered_set<string>m;\\n        for(auto x:wordDict){\\n            m.insert(x);\\n        }\\n         return solve(s,m);\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    private Map<String, Boolean> dp;\\n\\n    public boolean solve(String s, Set<String> m) {\\n        if (s.length() == 0) {\\n            return true;\\n        }\\n        if (dp.containsKey(s))\\n            return dp.get(s);\\n        for (int i = 0; i < s.length(); i++) {\\n            String r = s.substring(0, i + 1);\\n            if (m.contains(r)) {\\n                if (solve(s.substring(i + 1), m)){\\n                    dp.put(s,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        dp.put(s, false);\\n        return false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> m = new HashSet<>(wordDict);\\n        dp = new HashMap<>();\\n        return solve(s, m);\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = {}\\n\\n    def solve(self, s, m):\\n        if not s:\\n            return True\\n        if s in self.dp:\\n            return self.dp[s]\\n        for i in range(len(s)):\\n            r = s[:i + 1]\\n            if r in m:\\n                if self.solve(s[i + 1:], m):\\n                    self.dp[s] = True\\n                    return True\\n        self.dp[s] = False\\n        return False\\n\\n    def wordBreak(self, s, wordDict):\\n        m = set(wordDict)\\n        return self.solve(s, m)\\n\\n```\\n# upvote the article if u understood the solution!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n     unordered_map<string,bool>dp;\\n    bool solve(string s,unordered_set<string>&m){\\n        if(s.length()==0){\\n            return true;\\n        }\\n        if(dp.find(s)!=dp.end())\\n        return dp[s];\\n        for(int i=0;i<s.length();i++){\\n            string r=s.substr(0,i+1);\\n            if(m.count(r)){\\n                if(solve(s.substr(i+1),m))\\n                return dp[s]=true;\\n            }\\n        }\\n        return dp[s]=false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n         unordered_set<string>m;\\n        for(auto x:wordDict){\\n            m.insert(x);\\n        }\\n         return solve(s,m);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    private Map<String, Boolean> dp;\\n\\n    public boolean solve(String s, Set<String> m) {\\n        if (s.length() == 0) {\\n            return true;\\n        }\\n        if (dp.containsKey(s))\\n            return dp.get(s);\\n        for (int i = 0; i < s.length(); i++) {\\n            String r = s.substring(0, i + 1);\\n            if (m.contains(r)) {\\n                if (solve(s.substring(i + 1), m)){\\n                    dp.put(s,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        dp.put(s, false);\\n        return false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> m = new HashSet<>(wordDict);\\n        dp = new HashMap<>();\\n        return solve(s, m);\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = {}\\n\\n    def solve(self, s, m):\\n        if not s:\\n            return True\\n        if s in self.dp:\\n            return self.dp[s]\\n        for i in range(len(s)):\\n            r = s[:i + 1]\\n            if r in m:\\n                if self.solve(s[i + 1:], m):\\n                    self.dp[s] = True\\n                    return True\\n        self.dp[s] = False\\n        return False\\n\\n    def wordBreak(self, s, wordDict):\\n        m = set(wordDict)\\n        return self.solve(s, m)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870102,
                "title": "pyhon-dfs-using-lru-cache-explained",
                "content": "Let `dfs(k)` be a possibility to split string `s[k:]` into words from `wordSet`. Then to check if word `s[k:]` can be splitted, we need to check if for some `i` word `s[k:i]` in our `wordSet` and if `s[i:]` can be splitted, which is `dfs(i)`.\\n\\n**Complexity**: let `T` be the maximum length of word in our `wordSet`. Then we need `O(T)` time to check if word in our set, so we have overall `O(n^2T)` complexity. Space complexity is `O(n +Tn)` : to keep our cache and to keep our set of `wordSet`\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n   \\n        @lru_cache(None)\\n        def dfs(k):\\n            if k == n: return True\\n            for i in range(k + 1, n + 1):\\n                if s[k:i] in wordSet and dfs(i):\\n                    return True        \\n            return False\\n        \\n        return dfs(0)\\n```\\n\\n**Further discussion**: Another approach is to use KMP for each of the `m` words and create `n x n` table `Mem`, where `Mem[i][j]` is equal to `1` if `s[i:j]` is in our dictionary. The complexity to generate `Mem` table is `O(mn)` and `O(n^2)` to update `dp`. Finally, we have `O(n^2 + nm)` time and `O(n^2)` memory.\\n\\nOne more approach is to use Tries to preprocess our dictionary with `O(mk)` time, where `k` is the average length of words. Then we can fill `dp` table in `O(n^2)` time (CHECK, I am not 100 percent sure). Finally, we have `O(mk + n^2)` time and `O(mk)` memory.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n   \\n        @lru_cache(None)\\n        def dfs(k):\\n            if k == n: return True\\n            for i in range(k + 1, n + 1):\\n                if s[k:i] in wordSet and dfs(i):\\n                    return True        \\n            return False\\n        \\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528858,
                "title": "fastest-javascript-bfs-44ms",
                "content": "```javascript\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    const words = new Set(wordDict);\\n    const wordLens = new Set(wordDict.map((word) => word.length))\\n    const starts = new Set([0])\\n    for (let start of starts) {\\n        for (let len of wordLens) {\\n            if (words.has(s.slice(start, start + len))) {\\n                starts.add(start + len)\\n            }\\n        }\\n    }\\n    return starts.has(s.length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    const words = new Set(wordDict);\\n    const wordLens = new Set(wordDict.map((word) => word.length))\\n    const starts = new Set([0])\\n    for (let start of starts) {\\n        for (let len of wordLens) {\\n            if (words.has(s.slice(start, start + len))) {\\n                starts.add(start + len)\\n            }\\n        }\\n    }\\n    return starts.has(s.length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43796,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            boolean [] breakable = new boolean[s.length()+1];\\n            breakable[0] = true;\\n    \\n            for(int i=1;i<=s.length();i++){\\n                for(int j=0;j<i;j++){\\n                    if(breakable[j]&&dict.contains(s.substring(j,i))){\\n                        breakable[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            return breakable[s.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            boolean [] breakable = new boolean[s.length()+1];\\n            breakable[0] = true;\\n    \\n            for(int i=1;i<=s.length();i++){\\n                for(int j=0;j<i;j++){\\n                    if(breakable[j]&&dict.contains(s.substring(j,i))){\\n                        breakable[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 43916,
                "title": "a-concise-java-solution-11-line-in-wordbreak-function",
                "content": "    public class Solution {\\n        \\n        public boolean wordBreak(String s, Set<String> wordDict) {\\n            int len = s.length();\\n            boolean[] f = new boolean[len+1];\\n            f[0] = true;\\n            for (int i=1; i<len+1; i++)\\n                for (int j=0; j<i; j++)\\n                    if (f[j] && wordDict.contains(s.substring(j,i)))\\n                    {\\n                        f[i] = true;\\n                        break;\\n                    }\\n            return f[len];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        public boolean wordBreak(String s, Set<String> wordDict) {\\n            int len = s.length();\\n            boolean[] f = new boolean[len+1];\\n            f[0] = true;\\n            for (int i=1; i<len+1; i++)\\n                for (int j=0; j<i; j++)\\n                    if (f[j] && wordDict.contains(s.substring(j,i)))\\n                    {\\n                        f[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 511991,
                "title": "python-trie",
                "content": "I have implemented a Trie directly from my code for the problem https://leetcode.com/problems/implement-trie-prefix-tree/\\nThe main function creates an array like the dp solutions shown in other posts. But it uses a Trie to search for a string. It is always a good choice to optimize search for substrings using a Trie Data Structure. The runtime for the test cases here is similar to the DP solutions but for interview preparation this probably is a good way to demonstrate your knowledge of Trie. \\n\\n```\\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.root = {\\'*\\':\\'*\\'}\\n        \\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n\\n    def insert(self, word):        \\n        \"\"\"\\n        Inserts a word into the trie.\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        current = self.root\\n        \\n        for c in word:\\n            \\n            if c not in current:\\n                \\n                current[c] = {}\\n                \\n            current = current[c]\\n            \\n        current[\\'*\\'] = \\'*\\'\\n        \\n    def search_word(self,word):\\n        \\n        current = self.root\\n        \\n        for c in word:\\n            \\n            if c not in current:\\n                return False\\n                \\n            current = current[c]\\n        if \\'*\\' in current:\\n            return True\\n        \\n        else:\\n            return False\\n\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        trie = Trie()\\n        \\n        for w in wordDict:\\n            \\n            trie.insert(w)\\n        \\n        dp=[False for i in range(len(s)+1)]\\n        dp[0]=True\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(i):\\n                \\n                if dp[j] and trie.search_word(s[j:i]):\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.root = {\\'*\\':\\'*\\'}\\n        \\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n\\n    def insert(self, word):        \\n        \"\"\"\\n        Inserts a word into the trie.\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        current = self.root\\n        \\n        for c in word:\\n            \\n            if c not in current:\\n                \\n                current[c] = {}\\n                \\n            current = current[c]\\n            \\n        current[\\'*\\'] = \\'*\\'\\n        \\n    def search_word(self,word):\\n        \\n        current = self.root\\n        \\n        for c in word:\\n            \\n            if c not in current:\\n                return False\\n                \\n            current = current[c]\\n        if \\'*\\' in current:\\n            return True\\n        \\n        else:\\n            return False\\n\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        trie = Trie()\\n        \\n        for w in wordDict:\\n            \\n            trie.insert(w)\\n        \\n        dp=[False for i in range(len(s)+1)]\\n        dp[0]=True\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(i):\\n                \\n                if dp[j] and trie.search_word(s[j:i]):\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959656,
                "title": "c-recursion-memo-commented",
                "content": "Thank you @Nk_mishra for a clear solution.\\n\\nThe idea is to find all **possible prefixes** and recurse the remaining part of the string. \\nMemoize the function to avoid redundant calls.\\n\\n```Catsandog - [cat, cats, sand, and, dog]```\\nC\\nCa\\nCat\\nLeft = Cat, Recurse(sandog)\\ns\\nsa\\nsan\\nsand\\nLeft = sand, Recurse(og)\\no\\nog\\nreturn false\\nFunction falls on Left = Cats, Recurse(andog) ...\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, bool> memo;\\n    \\n    bool wordBreakHelp(string word, unordered_map<string, bool>& dict)\\n    {\\n        //if present in dict\\n        if(dict.find(word) != dict.end())\\n            return true;\\n        \\n        //if present in memo, no need to call \\n        if(memo.find(word) != memo.end())\\n            return memo[word];\\n        \\n        \\n        for(int i=0; i<word.length(); i++)\\n        {\\n            string left = word.substr(0, i+1); //always starts from beginning\\n            string right = word.substr(i+1); //remaining string till the last letter;\\n            \\n            if(dict.find(left) != dict.end())\\n            {\\n                bool ros = wordBreakHelp(right, dict); //rest of the string is recursed\\n                \\n                if(ros == true)\\n                {\\n                    memo[word] = true; //entire word exists\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        //if no prefix is found to be matching, word does not exist\\n        memo[word] = false;\\n        return false;\\n          \\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) \\n    {\\n        unordered_map<string, bool> dict;\\n        \\n        for(string s : wordDict)\\n            dict[s] = true;\\n        \\n        return wordBreakHelp(s, dict);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```Catsandog - [cat, cats, sand, and, dog]```\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, bool> memo;\\n    \\n    bool wordBreakHelp(string word, unordered_map<string, bool>& dict)\\n    {\\n        //if present in dict\\n        if(dict.find(word) != dict.end())\\n            return true;\\n        \\n        //if present in memo, no need to call \\n        if(memo.find(word) != memo.end())\\n            return memo[word];\\n        \\n        \\n        for(int i=0; i<word.length(); i++)\\n        {\\n            string left = word.substr(0, i+1); //always starts from beginning\\n            string right = word.substr(i+1); //remaining string till the last letter;\\n            \\n            if(dict.find(left) != dict.end())\\n            {\\n                bool ros = wordBreakHelp(right, dict); //rest of the string is recursed\\n                \\n                if(ros == true)\\n                {\\n                    memo[word] = true; //entire word exists\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        //if no prefix is found to be matching, word does not exist\\n        memo[word] = false;\\n        return false;\\n          \\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) \\n    {\\n        unordered_map<string, bool> dict;\\n        \\n        for(string s : wordDict)\\n            dict[s] = true;\\n        \\n        return wordBreakHelp(s, dict);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609045,
                "title": "c-solution-with-dynamic-programming-with-explanation",
                "content": "In this sample explanation, let\\'s take the input string as `\"leetcode\"` and dictionary as follows: `{\"leet\", \"code\"}`. \\nFirst we create the dynamic programming array (dp), initially it looks as follows:\\n![image](https://assets.leetcode.com/users/guney/image_1588442946.png)\\nThen, we keep iterating `e` and `b` pointers. At some point, pointers are creating a substring that is in the dictionary, as follows:\\n![image](https://assets.leetcode.com/users/guney/image_1588443094.png)\\nHere, `b` pointer shows index 0 of dp array and `e` pointer shows index 4 of dp array, which creates the substring `leet`. We update the index 4 of dp array as `true` if the substring is in the dictionary and if dp array at index `b` is `true`. In this case, condition is satisfied and dp array is updated as follows:\\n![image](https://assets.leetcode.com/users/guney/image_1588443414.png)\\nWe keep iterating pointers until we traverse whole input string and keep updating dp array when the condition is satisfied. In the current example, we update it one more time when pointers are shown as below:\\n![image](https://assets.leetcode.com/users/guney/image_1588443527.png)\\n\\nIf the last element is `true`, we have a successful word break. Having more elements in the dictionary with different substrings in the input string would break the algorithm, it would only add more `true` values to the dp array.\\n\\nCode is below for this explanation.\\n\\n```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\t// remove duplicates from dictionary\\n\\tunordered_set<string> word_set(wordDict.begin(), wordDict.end());\\n\\tauto slen = s.size();\\n\\tvector<bool> dp(slen + 1, false);\\n\\tdp[0] = true;\\n\\tfor (int e = 0; e <= slen; ++e) {\\n\\t\\tfor (int b = e; b >= 0; --b) {\\n\\t\\t\\tif (dp[b] && word_set.count(s.substr(b, e - b)) > 0) {\\n\\t\\t\\t\\t// substring begins at location \\'b\\' and end at location \\'e\\'\\n\\t\\t\\t\\t// set location \\'e\\' to true, if substring is in the dictionary & the last word before the substring is also true\\n\\t\\t\\t\\tdp[e] = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[slen];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\t// remove duplicates from dictionary\\n\\tunordered_set<string> word_set(wordDict.begin(), wordDict.end());\\n\\tauto slen = s.size();\\n\\tvector<bool> dp(slen + 1, false);\\n\\tdp[0] = true;\\n\\tfor (int e = 0; e <= slen; ++e) {\\n\\t\\tfor (int b = e; b >= 0; --b) {\\n\\t\\t\\tif (dp[b] && word_set.count(s.substr(b, e - b)) > 0) {\\n\\t\\t\\t\\t// substring begins at location \\'b\\' and end at location \\'e\\'\\n\\t\\t\\t\\t// set location \\'e\\' to true, if substring is in the dictionary & the last word before the substring is also true\\n\\t\\t\\t\\tdp[e] = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[slen];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44011,
                "title": "java-solution-using-dp",
                "content": "    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if (s == null && wordDict == null)\\n            return true;\\n        if (s == null || wordDict == null)\\n            return false;\\n        //dp[i] represents if s.substring(0, i) is wordbreakable.\\n        boolean[] dp = new boolean[s.length()+1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if (s == null && wordDict == null)\\n            return true;\\n        if (s == null || wordDict == null)\\n            return false;\\n        //dp[i] represents if s.substring(0, i) is wordbreakable.\\n        boolean[] dp = new boolean[s.length()+1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 490911,
                "title": "python-simple-trie-solution-with-detailed-explanation-and-sketches",
                "content": "**For BFS, DFS recursive with memo, and DP solutions, please visit the link below:**\\nhttps://leetcode.com/problems/word-break/discuss/1326943/Python-Two-BFS-solutions-or-Explained-%2B-visualized\\n\\n**Trie Solution Idea:**\\n\\n- Build your dictionary of words using a trie DS.\\n- In the trie dictionary, every word is represented by a path from the root to a leaf (the root is a null node since its shared by all words in the dictionary)\\n- Along every path, a word is stored as a series of nodes (aka linked list) where each node represents a character in the word (path)\\n- The main building block of a trie is a node\\n- The nodes have 3 basic attributes: value, children, a flag to indicate whether the \\n\\n**Time and space complexity:**\\n\\n-  ``` add() ```  O(K) where K = len(words)\\n-  ``` find() ```  O(S) where s = sentence\\n- ``` wordBreak() ```   O(W *  K) OR O(S * S[i+1:]) Whichever is worst, where W=len(words)\\n\\n\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\t\\t# instantiate an empty trie \\n        trie = Trie()\\n        # Iterate over words in dictionary and build trie one word at a time\\n        for word in wordDict:   #------ O(W) where W = len(words)\\n            trie.add(word)  #--------------- O(K) where K = len(word)\\n        print(trie.root.children)\\n        # Words have been added. Find if s is made up of words in the trie\\n        return trie.find(s)  # ---- Overall time : O(W*K) OR O(S*S[i+1:]) Whichever is worst\\n\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.is_done = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n        self.memo = {}\\n\\n    def add(self, word):\\n        root = self.root\\n        for char in word:\\n            if char not in root.children:\\n                root.children[char] = Node(char)\\n            root = root.children[char]   # -- on to the child - going one level down the tire branch/path\\n\\t    root.is_done = True    # -------------- To mark the end of a word.\\n\\t\\t                                                # This is necessary to make the \"word break\" functionality possible) -- SEE SKETCH-1-\\n                                                        # s = \"Ilovecats\", wordDict = [\"I\", \"love\", \"cats\"]\\n                                                        # Marking last chars of each word is the only way for the trie to distinguish between the words and to seperate the words\\n                                                        # while building the trie and also searching the trie later on.\\n\\n    def find(self, s):\\n        root = self.root\\n        for i, char in enumerate(s):\\n            if char not in root.children:   # [1] -- if char does not exist\\n                return False\\n            \\n            if root.children[char].is_done: # [2] --  if char does exit, but it\\'s marked as the last char/leaf node --- \\n\\t\\t\\t                                            # SEE NOTE #[2] FOR A DETAILED EXPLANATION\\n\\n                if s[i+1:] not in self.memo:                  # -- (a) if the remaining part hasn\\'t been seen before, then we need to check it -> call the function recursively\\n                    self.memo[s[i+1:]] = self.find(s[i+1:]) \\n\\n                if self.memo[s[i+1:]]:                        # -- (b) if remaining has been seen - return True (no need to check)\\n                    return True                                      # -- Having seen the \"remaining part\" before is possible if a word repeats in the sentence.\\n                                                                            # for example:\\n                                                                            # A man gotta do what a man gotta do\\n                                                                            # ex: s = \"Amangottadowhatamangottado\"\\n                                                                            # The words \"man\", \"do\", \"gotta\", and \"a\" repeats twice each\\n                                                                            # in such scenario, it\\'s wise to use a memoization dict to speed things up - see sketch 3\\n\\n            root = root.children[char]         # ----- move on to the child node - go one level down the branch\\n        \\n        return root.is_done                   # ----- Only return True if the last char in s is marked as leaf in the trie\\n                                                       # This is another way of saying - we have found every word in our given sentence \"s\" \\n                \\n            \\n    \\n\\t # NOTE 2\\n     # ------   \\n     # We need to capture leaf nodes because in a trie, words that have the same prefix\\n     # will appear as one word as long as they share the prefix and\\n     # will only start to diverge from one another at the first non-mutual letter/character\\n     # *please see sketch -2-*\\n\\n     # Thus, if char exists and it\\'s marked as a leaf node in the trie.\\n     # there\\'s no way to make sure whether this leaf node is \\n     # the GLOBAL leaf node of that path/branch or just a LOCAL leaf node\\n\\n     # GLOBAL leaf node belongs represents the char that belongs\\n     # to the longest word of all the words that share the same prefix.\\n     # While LOCAL leaf node marks the end of a shorter word that shares the\\n     # same prefix with longer words, and thus -in reality- is not really a \\n     # <proper> leaf node as far as the trie is concenred. As a result,\\n     # whenever we encounter a leaf, we need to make sure that there\\'s\\n     # no remaining characters by checking s[i+1:]\\n     # if s[i+1: ] is not None -> this means the word we\\'are trying to find\\n     # extends beyond that initial leaf node that we encountered \\n     # <there are more characters to the word>, hence we need to call the function again\\n     # on that remaining part s[i+1: ] to make sure that it exists in the trie.\\n     # This makes sense becasue, so far we were able to find only the first part\\n     # s[:i] and we\\'re sure it exists but we still have to verify the existence of\\n     # the remaing part. We do that by simply calling the function again -recursively-\\n     # on that remaining part.\\n    \\n```\\n\\n\\n# **Sketch -1-**\\n![image](https://assets.leetcode.com/users/abadawi/image_1580063469.png)\\n.\\n.\\n.\\n.\\n\\n \\n# **Sketch -2-**\\n![image](https://assets.leetcode.com/users/abadawi/image_1580063478.png)\\n\\n.\\n.\\n.\\n.\\n\\n# **Sketch -3-**\\n![image](https://assets.leetcode.com/users/abadawi/image_1580063486.png)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "``` add() ```\n``` find() ```\n``` wordBreak() ```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\t\\t# instantiate an empty trie \\n        trie = Trie()\\n        # Iterate over words in dictionary and build trie one word at a time\\n        for word in wordDict:   #------ O(W) where W = len(words)\\n            trie.add(word)  #--------------- O(K) where K = len(word)\\n        print(trie.root.children)\\n        # Words have been added. Find if s is made up of words in the trie\\n        return trie.find(s)  # ---- Overall time : O(W*K) OR O(S*S[i+1:]) Whichever is worst\\n\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.is_done = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n        self.memo = {}\\n\\n    def add(self, word):\\n        root = self.root\\n        for char in word:\\n            if char not in root.children:\\n                root.children[char] = Node(char)\\n            root = root.children[char]   # -- on to the child - going one level down the tire branch/path\\n\\t    root.is_done = True    # -------------- To mark the end of a word.\\n\\t\\t                                                # This is necessary to make the \"word break\" functionality possible) -- SEE SKETCH-1-\\n                                                        # s = \"Ilovecats\", wordDict = [\"I\", \"love\", \"cats\"]\\n                                                        # Marking last chars of each word is the only way for the trie to distinguish between the words and to seperate the words\\n                                                        # while building the trie and also searching the trie later on.\\n\\n    def find(self, s):\\n        root = self.root\\n        for i, char in enumerate(s):\\n            if char not in root.children:   # [1] -- if char does not exist\\n                return False\\n            \\n            if root.children[char].is_done: # [2] --  if char does exit, but it\\'s marked as the last char/leaf node --- \\n\\t\\t\\t                                            # SEE NOTE #[2] FOR A DETAILED EXPLANATION\\n\\n                if s[i+1:] not in self.memo:                  # -- (a) if the remaining part hasn\\'t been seen before, then we need to check it -> call the function recursively\\n                    self.memo[s[i+1:]] = self.find(s[i+1:]) \\n\\n                if self.memo[s[i+1:]]:                        # -- (b) if remaining has been seen - return True (no need to check)\\n                    return True                                      # -- Having seen the \"remaining part\" before is possible if a word repeats in the sentence.\\n                                                                            # for example:\\n                                                                            # A man gotta do what a man gotta do\\n                                                                            # ex: s = \"Amangottadowhatamangottado\"\\n                                                                            # The words \"man\", \"do\", \"gotta\", and \"a\" repeats twice each\\n                                                                            # in such scenario, it\\'s wise to use a memoization dict to speed things up - see sketch 3\\n\\n            root = root.children[char]         # ----- move on to the child node - go one level down the branch\\n        \\n        return root.is_done                   # ----- Only return True if the last char in s is marked as leaf in the trie\\n                                                       # This is another way of saying - we have found every word in our given sentence \"s\" \\n                \\n            \\n    \\n\\t # NOTE 2\\n     # ------   \\n     # We need to capture leaf nodes because in a trie, words that have the same prefix\\n     # will appear as one word as long as they share the prefix and\\n     # will only start to diverge from one another at the first non-mutual letter/character\\n     # *please see sketch -2-*\\n\\n     # Thus, if char exists and it\\'s marked as a leaf node in the trie.\\n     # there\\'s no way to make sure whether this leaf node is \\n     # the GLOBAL leaf node of that path/branch or just a LOCAL leaf node\\n\\n     # GLOBAL leaf node belongs represents the char that belongs\\n     # to the longest word of all the words that share the same prefix.\\n     # While LOCAL leaf node marks the end of a shorter word that shares the\\n     # same prefix with longer words, and thus -in reality- is not really a \\n     # <proper> leaf node as far as the trie is concenred. As a result,\\n     # whenever we encounter a leaf, we need to make sure that there\\'s\\n     # no remaining characters by checking s[i+1:]\\n     # if s[i+1: ] is not None -> this means the word we\\'are trying to find\\n     # extends beyond that initial leaf node that we encountered \\n     # <there are more characters to the word>, hence we need to call the function again\\n     # on that remaining part s[i+1: ] to make sure that it exists in the trie.\\n     # This makes sense becasue, so far we were able to find only the first part\\n     # s[:i] and we\\'re sure it exists but we still have to verify the existence of\\n     # the remaing part. We do that by simply calling the function again -recursively-\\n     # on that remaining part.\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 44033,
                "title": "7-line-python-dp",
                "content": "Original title was \"Naive python solution.. looks like Greedy?\"\\n\\nKeeping track of possible start indices.\\n\\n    def wordBreak(self, s, wordDict):\\n        starts = [0]\\n        for i in range(len(s)):\\n            for j in starts:\\n                if s[j:i+1] in wordDict:\\n                    starts.append(i+1)\\n                    break\\n        return starts[-1] == len(s)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Original title was \"Naive python solution.. looks like Greedy?\"\\n\\nKeeping track of possible start indices.\\n\\n    def wordBreak(self, s, wordDict):\\n        starts = [0]\\n        for i in range(len(s)):\\n            for j in starts:\\n                if s[j:i+1] in wordDict:\\n                    starts.append(i+1)\\n                    break\\n        return starts[-1] == len(s)",
                "codeTag": "Python3"
            },
            {
                "id": 806451,
                "title": "python-dp-bottom-up-solution-with-comments",
                "content": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        dp = [False for i in range(len(s) + 1)] #(1)\\n        dp[0] = True\\n        \\n        for i in range(len(s) + 1): #(2)\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict: #(3)\\n                    dp[i] = True\\n                    break #(4)\\n        \\n        return dp[len(s)] #(5)\\n        \\n    #(1) dp[i] = s[0:i] is breakable\\n    #(2) Considering all possible substrings of s.\\n    #(3) If s[0:j] is breakable and s[j:i] is breakable, then s[0:i] is breakable. Equivalently, if dp[j] is True and s[j:i] is in the wordDict, then dp[i] is True.\\n    #(4) Our goal is to determine if dp[i] is breakable, and once we do, we don\\'t need to consider anything else. This is because we want to construct dp.\\n    #(5) dp[len(s)] tells us if s[0:len(s)] (or equivalently, s) is breakable.\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        dp = [False for i in range(len(s) + 1)] #(1)\\n        dp[0] = True\\n        \\n        for i in range(len(s) + 1): #(2)\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict: #(3)\\n                    dp[i] = True\\n                    break #(4)\\n        \\n        return dp[len(s)] #(5)\\n        \\n    #(1) dp[i] = s[0:i] is breakable\\n    #(2) Considering all possible substrings of s.\\n    #(3) If s[0:j] is breakable and s[j:i] is breakable, then s[0:i] is breakable. Equivalently, if dp[j] is True and s[j:i] is in the wordDict, then dp[i] is True.\\n    #(4) Our goal is to determine if dp[i] is breakable, and once we do, we don\\'t need to consider anything else. This is because we want to construct dp.\\n    #(5) dp[len(s)] tells us if s[0:len(s)] (or equivalently, s) is breakable.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861895,
                "title": "c-dp-recursion-memoization-day-4",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    map<string,int>m;\\n    bool help(int i,string &s,vector<int>&dp){\\n        if(i==s.size())return true;\\n        if(dp[i]!=-1)return dp[i];\\n        bool ans = false;\\n        string a = \"\";\\n        for(int k=i;k<s.size();k++){\\n            a += s[k];\\n            if(m[a]){\\n                ans |= help(k+1,s,dp);\\n            }\\n        }\\n        return  dp[i] = ans;\\n    }\\n    bool wordBreak(string s, vector<string>& w) {\\n        for(auto i:w){\\n            m[i]++;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return help(0,s,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/7802eeca-3df2-4498-9bd7-0413695bcf8f_1691138462.1918123.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,int>m;\\n    bool help(int i,string &s,vector<int>&dp){\\n        if(i==s.size())return true;\\n        if(dp[i]!=-1)return dp[i];\\n        bool ans = false;\\n        string a = \"\";\\n        for(int k=i;k<s.size();k++){\\n            a += s[k];\\n            if(m[a]){\\n                ans |= help(k+1,s,dp);\\n            }\\n        }\\n        return  dp[i] = ans;\\n    }\\n    bool wordBreak(string s, vector<string>& w) {\\n        for(auto i:w){\\n            m[i]++;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return help(0,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617356,
                "title": "recursion-memoization-tabulation-simple-and-precise-c-solution",
                "content": "# Recursion\\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        return f(0, s, dict);\\n    }\\n\\t\\n\\tbool f(int ind, string &s, set<string> &dict) {\\n        if(ind == s.length()) return true;\\n        \\n        for(int i = ind; i < s.length(); i++) {\\n            string cur = s.substr(ind, i-ind+1);\\n            if(dict.find(cur) != dict.end() && f(i+1, s, dict)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n# Memoization\\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<int> dp(s.length(), -1);\\n        return f(0, s, dict, dp);\\n    }\\n\\t\\n\\tbool f(int ind, string &s, set<string> &dict, vector<int>& dp) {\\n        if(ind == s.length()) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        for(int i = ind; i < s.length(); i++) {\\n            string cur = s.substr(ind, i-ind+1);\\n            if(dict.find(cur) != dict.end() && f(i+1, s, dict, dp)) {\\n                return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n```\\n\\n# Tabulation\\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        int n = s.length();\\n        vector<bool> dp(n+1, false);\\n        dp[n] = true;\\n        for(int ind = n-1; ind >= 0; ind--) {\\n            for(int i = ind; i < s.length(); i++) {\\n                string cur = s.substr(ind, i-ind+1);\\n                if(dict.find(cur) != dict.end() && dp[i+1]) {\\n                    dp[ind] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n\\t}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        return f(0, s, dict);\\n    }\\n\\t\\n\\tbool f(int ind, string &s, set<string> &dict) {\\n        if(ind == s.length()) return true;\\n        \\n        for(int i = ind; i < s.length(); i++) {\\n            string cur = s.substr(ind, i-ind+1);\\n            if(dict.find(cur) != dict.end() && f(i+1, s, dict)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<int> dp(s.length(), -1);\\n        return f(0, s, dict, dp);\\n    }\\n\\t\\n\\tbool f(int ind, string &s, set<string> &dict, vector<int>& dp) {\\n        if(ind == s.length()) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        for(int i = ind; i < s.length(); i++) {\\n            string cur = s.substr(ind, i-ind+1);\\n            if(dict.find(cur) != dict.end() && f(i+1, s, dict, dp)) {\\n                return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n```\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        int n = s.length();\\n        vector<bool> dp(n+1, false);\\n        dp[n] = true;\\n        for(int ind = n-1; ind >= 0; ind--) {\\n            for(int i = ind; i < s.length(); i++) {\\n                string cur = s.substr(ind, i-ind+1);\\n                if(dict.find(cur) != dict.end() && dp[i+1]) {\\n                    dp[ind] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1326943,
                "title": "python-5-approaches-bfs-recursive-memo-dp-trie-explained-visualized",
                "content": "\\n---------------------------------------------------------------------\\nBFS Idea:\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n![image](https://assets.leetcode.com/users/images/a37c252b-59c6-4203-8432-5b816c785bdd_1625840817.161574.jpeg)\\n\\n\\n---------------------------------------------------------------------\\n[1] Top-down  : Iterative BFS - generate all substrings intially but only traverse the dict-approved ones\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n```\\ndef wordBreak(s, wordDict):\\n        from collections import deque\\n        q = deque()\\n        q.append(0) # startIndx\\n        visited = set()\\n        dictSet = set(wordDict)\\n        while q:\\n            for i in range(len(q)):\\n                startIndx = q.popleft()\\n                if startIndx == len(s): # - NOTE [1]\\n                    return True\\n                \\n                if startIndx not in visited:\\n                    visited.add(startIndx)\\n                    \\n                    for endIndx in range(startIndx+1, len(s)+1): # NOTE [2]\\n                        sub = s[startIndx: endIndx]\\n                        if sub in dictSet:\\n                            q.append(endIndx) # endIndx is the new startIndx\\n                            \\n        return False   \\n    \\n    \\n        # NOTE [1]\\n        # --------\\n        # How do I know when to return true?\\n        # When the start index = len(s) (aka successfully reached the end of s)\\n        # A path won\\'t be able to reach the end of s if any of the genreated substrings \\n        # is not a dictionary word.\\n        # In other words, if a branch resuts in a non-dict word, it gets pruned/terminated\\n        # One successful path is enough to return True (aka to declare s can be broken into dict-apporved words)\\n        # Which is why we use BFS, so that we can find the shortest successful path faster (if more than one successful path exist)\\n        \\n        # NOTE [2]\\n        # --------\\n        # Generate all possible substrings by generating all possible end-indicies\\n        # However we only expand/traverse those substrings that are dict-approved\\n```\\n\\n\\n---------------------------------------------------------------------  \\n[2] Top-down : Faster Iterative BFS - generate only possible substrings using the length of words in dict\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n```\\ndef wordBreak(s, wordDict):\\n        # find lenghths\\n        lengthList = set()\\n        for w in wordDict:\\n            lengthList.add(len(w))\\n        \\n        dictSet = set(wordDict)\\n        visited = set()\\n        \\n        from collections import deque\\n        q = deque()\\n        q.append(0) # start index\\n        while q:\\n            start = q.popleft()\\n            \\n            if start == len(s): # NOTE [1]\\n                return True\\n            \\n            if start not in visited:\\n                visited.add(start)\\n                \\n                for l in lengthList: # -- NOTE [3]\\n                    sub = s[start: start+l]\\n                    if sub in dictSet:\\n                        q.append(start+l)\\n        return False\\n    \\n        # NOTE [3]\\n        # --------\\n        # Instead of generate all possible substrings by generating all possible end-indicies\\n        # We only generate end-indicies that match the are equal to (startIndx + l) where l is the lenght of each dictonary-approved word\\n```\\n\\n\\n\\n---------------------------------------------------------------------\\n[3] Top-down : Recursive with memoization\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n```\\ndef wordBreak(s, wordDict):\\n        # helper\\n        def recurse(start):\\n            \\n            if start == len(s):\\n                return True\\n            \\n            if start in memo:\\n                return memo[start]\\n            \\n            # find end indx\\n            for l in endIndexes:\\n                node = s[start: start+l]\\n\\n                if node in dictSet and recurse(start+l):\\n                    memo[start+l] = True\\n                    return True\\n                \\n            memo[start] = False\\n            return False\\n            \\n        \\n        # main\\n        memo = {}\\n        start = 0\\n        \\n        endIndexes = []\\n        for w in wordDict:\\n            endIndexes.append(len(w))\\n        \\n        dictSet = set(wordDict)\\n        \\n        state = recurse(start)\\n        return state\\n```\\n\\n---------------------------------------------------------------------\\n[4] Bottom - up with tabulation: Dynamic programming\\ncredit to @zhuyinghua1203\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n```\\ndef wordBreak(s, wordDict):\\n        dictSet = set(wordDict)\\n        starts = [0] # dp[0] is the equivalent of a base-case from the recursive solution and dp[-1] is the overall solution to the complete problem\\n        for i in range(len(s)):\\n            for j in starts:\\n                if s[j:i+1] in dictSet:\\n                    starts.append(i+1) # start of next word\\n                    break # - note [1]\\n        \\n        return starts[-1] == len(s)\\n    \\n\\t# Note [1]\\n\\t# -------\\n\\t# we break because we only care about whether we can build the string s with the \\n\\t# ex: s = catdog, wordDict = [cat, at]\\n\\t# if i -> t\\n\\t#    j -> c\\n\\t# we capture that first and we break even though \"at\" is also a valid dict word\\n\\t# breaking will not affect the answer since our index i is fixed\\n\\t# because we just wanna see if we can get to the end of the string\\n```\\n\\n---------------------------------------------------------------------\\n[5] Trie \\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n- For a trie-based solution => [[Python] Simple Trie solution with detailed explanation and sketches](https://leetcode.com/problems/word-break/discuss/490911/Python-Simple-Trie-solution-with-detailed-explanation-and-sketches://)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\ndef wordBreak(s, wordDict):\\n        from collections import deque\\n        q = deque()\\n        q.append(0) # startIndx\\n        visited = set()\\n        dictSet = set(wordDict)\\n        while q:\\n            for i in range(len(q)):\\n                startIndx = q.popleft()\\n                if startIndx == len(s): # - NOTE [1]\\n                    return True\\n                \\n                if startIndx not in visited:\\n                    visited.add(startIndx)\\n                    \\n                    for endIndx in range(startIndx+1, len(s)+1): # NOTE [2]\\n                        sub = s[startIndx: endIndx]\\n                        if sub in dictSet:\\n                            q.append(endIndx) # endIndx is the new startIndx\\n                            \\n        return False   \\n    \\n    \\n        # NOTE [1]\\n        # --------\\n        # How do I know when to return true?\\n        # When the start index = len(s) (aka successfully reached the end of s)\\n        # A path won\\'t be able to reach the end of s if any of the genreated substrings \\n        # is not a dictionary word.\\n        # In other words, if a branch resuts in a non-dict word, it gets pruned/terminated\\n        # One successful path is enough to return True (aka to declare s can be broken into dict-apporved words)\\n        # Which is why we use BFS, so that we can find the shortest successful path faster (if more than one successful path exist)\\n        \\n        # NOTE [2]\\n        # --------\\n        # Generate all possible substrings by generating all possible end-indicies\\n        # However we only expand/traverse those substrings that are dict-approved\\n```\n```\\ndef wordBreak(s, wordDict):\\n        # find lenghths\\n        lengthList = set()\\n        for w in wordDict:\\n            lengthList.add(len(w))\\n        \\n        dictSet = set(wordDict)\\n        visited = set()\\n        \\n        from collections import deque\\n        q = deque()\\n        q.append(0) # start index\\n        while q:\\n            start = q.popleft()\\n            \\n            if start == len(s): # NOTE [1]\\n                return True\\n            \\n            if start not in visited:\\n                visited.add(start)\\n                \\n                for l in lengthList: # -- NOTE [3]\\n                    sub = s[start: start+l]\\n                    if sub in dictSet:\\n                        q.append(start+l)\\n        return False\\n    \\n        # NOTE [3]\\n        # --------\\n        # Instead of generate all possible substrings by generating all possible end-indicies\\n        # We only generate end-indicies that match the are equal to (startIndx + l) where l is the lenght of each dictonary-approved word\\n```\n```\\ndef wordBreak(s, wordDict):\\n        # helper\\n        def recurse(start):\\n            \\n            if start == len(s):\\n                return True\\n            \\n            if start in memo:\\n                return memo[start]\\n            \\n            # find end indx\\n            for l in endIndexes:\\n                node = s[start: start+l]\\n\\n                if node in dictSet and recurse(start+l):\\n                    memo[start+l] = True\\n                    return True\\n                \\n            memo[start] = False\\n            return False\\n            \\n        \\n        # main\\n        memo = {}\\n        start = 0\\n        \\n        endIndexes = []\\n        for w in wordDict:\\n            endIndexes.append(len(w))\\n        \\n        dictSet = set(wordDict)\\n        \\n        state = recurse(start)\\n        return state\\n```\n```\\ndef wordBreak(s, wordDict):\\n        dictSet = set(wordDict)\\n        starts = [0] # dp[0] is the equivalent of a base-case from the recursive solution and dp[-1] is the overall solution to the complete problem\\n        for i in range(len(s)):\\n            for j in starts:\\n                if s[j:i+1] in dictSet:\\n                    starts.append(i+1) # start of next word\\n                    break # - note [1]\\n        \\n        return starts[-1] == len(s)\\n    \\n\\t# Note [1]\\n\\t# -------\\n\\t# we break because we only care about whether we can build the string s with the \\n\\t# ex: s = catdog, wordDict = [cat, at]\\n\\t# if i -> t\\n\\t#    j -> c\\n\\t# we capture that first and we break even though \"at\" is also a valid dict word\\n\\t# breaking will not affect the answer since our index i is fixed\\n\\t# because we just wanna see if we can get to the end of the string\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 164472,
                "title": "python-solution",
                "content": "Dynamic Programming bottom up:\\n\\nWe first convert `wordDict` to a hashset `wordSet` to facilitate `O(1)` look-up. Next, we initialize an array of length `len(s)+1`, where `dp[i]` denotes if `s[:i]` can be segmented into words in `wordSet`. We let `dp[0] = 1`, because the empty string can be segmented into words in `wordSet` (trivially). We iterate `i` over `range(1, len(s)+1)`, and try to find the value for `dp[i]`. Now `dp[i] = 1` if there is some `0 <= j < i`, such that `dp[j] == 1` and `s[j:i]` is in `wordSet`. Therefore, we iterate `j` in `range(i)`, and check if such a `j` exists. If it does, we let `dp[i] = 1`, Otherwise, we let `dp[i] = 0`. Finally, we return `dp[-1] == 1`.\\n\\nTime complexity: `O(n**3)`, where `n = len(s)`, because there are two nested for loops, and the slicing `s[j:i]` costs an extra `O(n)`. Space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        wordSet = set(wordDict)\\n        dp = [0]*(len(s)+1)\\n        dp[0] = 1\\n        for i in range(1, len(s)+1):\\n            for j in range(i):\\n                if dp[j] == 1 and s[j:i] in wordSet:\\n                    dp[i] = 1\\n                    break\\n            else:\\n                dp[i] = 0\\n        return dp[-1] == 1\\n```\\n\\nThe above algorithm can also be implemented in a top-down fashion, as below. The time complexity and space complexity is the same as above.\\n\\nDynamic Programming top down (memoization):\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return True\\n            if rec[i] != -1:\\n                return True if rec[i] == 1 else False\\n            for j in range(i, len(s)):\\n                if s[i:j+1] in wordSet:\\n                    rec[j+1] = 1 if dfs(j+1) else 0\\n                    if rec[j+1] == 1:\\n                        return True\\n            return False\\n        \\n        rec = [-1]*(len(s)+1)\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        wordSet = set(wordDict)\\n        dp = [0]*(len(s)+1)\\n        dp[0] = 1\\n        for i in range(1, len(s)+1):\\n            for j in range(i):\\n                if dp[j] == 1 and s[j:i] in wordSet:\\n                    dp[i] = 1\\n                    break\\n            else:\\n                dp[i] = 0\\n        return dp[-1] == 1\\n```\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return True\\n            if rec[i] != -1:\\n                return True if rec[i] == 1 else False\\n            for j in range(i, len(s)):\\n                if s[i:j+1] in wordSet:\\n                    rec[j+1] = 1 if dfs(j+1) else 0\\n                    if rec[j+1] == 1:\\n                        return True\\n            return False\\n        \\n        rec = [-1]*(len(s)+1)\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43970,
                "title": "concise-dfs-backtracking-solution",
                "content": "Straightforward DFS solution, the only trick is to memorize already checked strings.\\n\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        return dfs(s, wordDict, new HashSet<>());\\n    }\\n    \\n    private boolean dfs(String s, Set<String> wordDict, Set<String> checked) {\\n        if (s.isEmpty()) return true;\\n        if (checked.contains(s)) return false;\\n        checked.add(s);\\n        \\n        for (String w : wordDict) {\\n            if (s.startsWith(w) && dfs(s.substring(w.length()), wordDict, checked)) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "Straightforward DFS solution, the only trick is to memorize already checked strings.\\n\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        return dfs(s, wordDict, new HashSet<>());\\n    }\\n    \\n    private boolean dfs(String s, Set<String> wordDict, Set<String> checked) {\\n        if (s.isEmpty()) return true;\\n        if (checked.contains(s)) return false;\\n        checked.add(s);\\n        \\n        for (String w : wordDict) {\\n            if (s.startsWith(w) && dfs(s.substring(w.length()), wordDict, checked)) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 821032,
                "title": "java-dp-solution-in-detail-for-beginner",
                "content": "Again the solution I posted is not for opitimization, it\\'s for beginner. :)\\n\\nSo this is a good example of exercising DP in terms of String, let\\'s take a look.\\n\\nThe problem is asking if the given string can be formed of words in the dictionary. Then let\\'s define dp[i] represents at character position i, so far the string.substring[0,i] can/cannot be segmented from dictionary. If it can, d[i] = true, else dp[i] = false. With this definition kept in mind, let\\'s continue by initializing dp array first.\\n\\n```\\nboolean[] dp = new dp[s.length() + 1]\\ndp[0] = true;\\n// we want an extra space because when the string = \"\", empty, it\\'s true. I will explain later why.\\n```\\n\\nNow let\\'s try to find the induction rule.\\n```\\n   l  e  e  t  c  o  d  e\\nT  F  F  F  T  F  F  F  T   <- dp array\\n0  1  2  3  4  5  6  7  8   <- i\\n```\\n\\nSo starting from i = 1, we can see that dp[0] = true. Substring \"l\"  is not in the dictionary, so we set dp[1] = false\\nNext, i = 2, dp[0] = true, Substring \"le\"  is not in the dictionary, so we set dp[2] = false\\nNext, i = 3, dp[0] = true, Substring \"lee\"  is not in the dictionary, so we set dp[3] = false\\nNext, i = 4, dp[0] = true, Substring \"leet\"  is IN the dictionary, so we set dp[4] = true\\n\\nLet\\'s continue.\\nSince we already knew that the substring at the left side of i=4(inclusive) can be found in the dictionary, we can just look at the right side of i=4, the remaining substring.\\nSo when i = 5, dp[4] = true, Substring \"c\" is not in the dictionary, so we set dp[5] = false\\nwhen i = 6, dp[4] = true, Substring \"co\" is not in the dictionary, so we set dp[6] = false\\nwhen i = 7, dp[4] = true, Substring \"cod\" is not in the dictionary, so we set dp[7] = false\\nwhen i = 8, dp[4] = true, Substring \"code\" is now IN the dictionary, so we set dp[8] = true\\n\\nSo based on the these answers, what\\'s the induction rule?\\nIf between [0, i], there is a 0 <= j <= i where dp[j] = true, we just need to check if substring[j+1, i] is in the dictionary. If the substring [j+1,i] is in the dictionary, then dp[i] = true. Now if we look back at dp[0] = true, it means when there is an empty string, it\\'s set for true. This step is important for filling dp array.\\n\\nHere is the code:\\n```\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor(String e : wordDict) {set.add(e);}\\n\\tboolean[] dp = new boolean[s.length() + 1];\\n\\tdp[0] = true;\\n\\t// i is actually a right bound, 0 is the left bound, j is the middle pointer\\n\\t// j is to find where dp[j] = true, so that we can check substring[j+1,i]\\n\\tfor(int i = 1; i < dp.length; i++){\\n\\t\\tfor(int j = 0; j <= i; j++){\\n\\t\\t    // if dp[j] is found true in the dictionary\\n\\t\\t\\tif(dp[j] == true) {\\n\\t\\t\\t    // we just need to take a look at the right side substring [j+1, i]\\n\\t\\t\\t\\tif(set.contains(s.substring(j,i))) {\\n\\t\\t\\t\\t\\tdp[i] = true;\\n\\t\\t\\t\\t\\tbreak;         // we break because there is no need to continue looping\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[dp.length - 1];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nboolean[] dp = new dp[s.length() + 1]\\ndp[0] = true;\\n// we want an extra space because when the string = \"\", empty, it\\'s true. I will explain later why.\\n```\n```\\n   l  e  e  t  c  o  d  e\\nT  F  F  F  T  F  F  F  T   <- dp array\\n0  1  2  3  4  5  6  7  8   <- i\\n```\n```\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor(String e : wordDict) {set.add(e);}\\n\\tboolean[] dp = new boolean[s.length() + 1];\\n\\tdp[0] = true;\\n\\t// i is actually a right bound, 0 is the left bound, j is the middle pointer\\n\\t// j is to find where dp[j] = true, so that we can check substring[j+1,i]\\n\\tfor(int i = 1; i < dp.length; i++){\\n\\t\\tfor(int j = 0; j <= i; j++){\\n\\t\\t    // if dp[j] is found true in the dictionary\\n\\t\\t\\tif(dp[j] == true) {\\n\\t\\t\\t    // we just need to take a look at the right side substring [j+1, i]\\n\\t\\t\\t\\tif(set.contains(s.substring(j,i))) {\\n\\t\\t\\t\\t\\tdp[i] = true;\\n\\t\\t\\t\\t\\tbreak;         // we break because there is no need to continue looping\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[dp.length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44035,
                "title": "python-concise-dp-solution",
                "content": "        \\n    def wordBreak(self, s, wordDict):\\n        dp = [False] * (len(s)+1)\\n        dp[0] = True\\n        for i in xrange(1, len(s)+1):\\n            for j in xrange(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    def wordBreak(self, s, wordDict):\\n        dp = [False] * (len(s)+1)\\n        dp[0] = True\\n        for i in xrange(1, len(s)+1):\\n            for j in xrange(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 877547,
                "title": "c-o-n-2-using-dp-trie",
                "content": "Since `substr` is actually an O(N) operation, we could use Trie to further decrease the time complexity to O(max(S, N^2)). Here N is the length of the string, and S is the sum of length of all words in the dictionary.\\n\\n```\\nclass TrieNode {\\npublic:\\n    bool isWord;\\n    vector<TrieNode*> next;\\n    TrieNode(): isWord(false), next(vector<TrieNode*>(26, nullptr)) {}\\n};\\nclass Solution {\\npublic:\\n    TrieNode* buildTrie(vector<string> &wordDict) {\\n        TrieNode *root = new TrieNode();\\n        for (auto &word : wordDict) {\\n            TrieNode *p = root;\\n            for (auto &ch : word) {\\n                if (p->next[ch-\\'a\\'] == nullptr)\\n                    p->next[ch-\\'a\\'] = new TrieNode();\\n                p = p->next[ch-\\'a\\'];\\n            }\\n            p->isWord = true;\\n        }\\n        return root;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int len = s.length();\\n        TrieNode *root = buildTrie(wordDict);\\n\\n        vector<bool> dp(len + 1, false);\\n        dp[0] = true;\\n        for (int i = 0; i <= len; i++) {\\n            if (dp[i]) {\\n                TrieNode *p = root;\\n                for (int j = i; j < len; j++) {\\n                    if (p->next[s[j]-\\'a\\'] == nullptr)\\n                        break;\\n                    p = p->next[s[j] - \\'a\\'];\\n                    if (p->isWord)\\n                        dp[j+1] = true;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    bool isWord;\\n    vector<TrieNode*> next;\\n    TrieNode(): isWord(false), next(vector<TrieNode*>(26, nullptr)) {}\\n};\\nclass Solution {\\npublic:\\n    TrieNode* buildTrie(vector<string> &wordDict) {\\n        TrieNode *root = new TrieNode();\\n        for (auto &word : wordDict) {\\n            TrieNode *p = root;\\n            for (auto &ch : word) {\\n                if (p->next[ch-\\'a\\'] == nullptr)\\n                    p->next[ch-\\'a\\'] = new TrieNode();\\n                p = p->next[ch-\\'a\\'];\\n            }\\n            p->isWord = true;\\n        }\\n        return root;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int len = s.length();\\n        TrieNode *root = buildTrie(wordDict);\\n\\n        vector<bool> dp(len + 1, false);\\n        dp[0] = true;\\n        for (int i = 0; i <= len; i++) {\\n            if (dp[i]) {\\n                TrieNode *p = root;\\n                for (int j = i; j < len; j++) {\\n                    if (p->next[s[j]-\\'a\\'] == nullptr)\\n                        break;\\n                    p = p->next[s[j] - \\'a\\'];\\n                    if (p->isWord)\\n                        dp[j+1] = true;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870388,
                "title": "python-simple-solution-explained-video-code-fastest",
                "content": "[](https://www.youtube.com/watch?v=tSbBuiO1rXI)\\nhttps://www.youtube.com/watch?v=tSbBuiO1rXI\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        dp = [True] + [False] * len(s)\\n        \\n        for indx in range(1, len(s) + 1):\\n            \\n            for word in wordDict:\\n                if dp[indx - len(word)] and s[:indx].endswith(word):\\n                    dp[indx] = True\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        dp = [True] + [False] * len(s)\\n        \\n        for indx in range(1, len(s) + 1):\\n            \\n            for word in wordDict:\\n                if dp[indx - len(word)] and s[:indx].endswith(word):\\n                    dp[indx] = True\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537226,
                "title": "javascript-dp",
                "content": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    let table = new Array(s.length + 1).fill(false);\\n    \\n    table[0] = true;\\n    \\n    for(let i = 0; i <= s.length; i++){\\n        if(table[i] === true){\\n\\t\\t\\tfor(let word of wordDict){\\n\\t\\t\\t\\tif(s.slice(i, i + word.length) === word){\\n\\t\\t\\t\\t\\ttable[i + word.length] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    return table[s.length];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    let table = new Array(s.length + 1).fill(false);\\n    \\n    table[0] = true;\\n    \\n    for(let i = 0; i <= s.length; i++){\\n        if(table[i] === true){\\n\\t\\t\\tfor(let word of wordDict){\\n\\t\\t\\t\\tif(s.slice(i, i + word.length) === word){\\n\\t\\t\\t\\t\\ttable[i + word.length] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    return table[s.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475984,
                "title": "c-2-solutions-trie-dp-and-map-dp",
                "content": "**Solution 1: Trie+DP(memoization)**\\n**Time Complexity: O(n*l + N^2)** \\nwhere, \\n*n=length of word dict*,\\n*l=length of longest word in the dict.*\\n*N=length of string (s)*\\n\\t\\t\\t\\n**Prerequisite:**   You should know basic concept of **Trie**.\\nif you dont know, then first try **Leetcode: 208** *[https://leetcode.com/problems/implement-trie-prefix-tree/](http://)*\\n```\\nclass Solution {\\npublic:\\n    class Trie{\\n      public:\\n        Trie *child[26];\\n        bool isEnd = false;\\n    };\\n    \\n    void insert(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(!cur->child[ch-\\'a\\']) cur->child[ch-\\'a\\'] = new Trie();\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(!cur->child[ch-\\'a\\']) return false;\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    int dp[305][305];\\n    bool solve(string &s, Trie *root, int n, int start){\\n        if(start==n) return true;\\n        if(dp[start][n]!=-1) return dp[start][n];\\n        for(int i=start; i<n; ++i){\\n            string str = s.substr(start,i-start+1);\\n            if(search(str,root)){\\n                if(solve(s,root,n,i+1)) return dp[start][n] = true;\\n            }\\n        }\\n        return dp[start][n] = false;\\n    }\\n    \\n    bool wordBreak(string &s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict) insert(word,root);\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,root,n,0);\\n    }\\n};\\n```\\n\\n**Solution 2: Map+DP(memoization)**\\n**Time Complexity: O(Nlog(N) + N^2)**\\nwhere,\\n*N=length of string (s)*\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> map;\\n    int dp[305][305];\\n    bool solve(string &s, int n, int start){\\n        if(start==n) return true;\\n        if(dp[start][n]!=-1) return dp[start][n];\\n        for(int i=start; i<n; ++i){\\n            string str = s.substr(start,i-start+1);\\n            if(map.find(str)!=map.end()){\\n                if(solve(s,n,i+1)) return dp[start][n] = true;\\n            }\\n        }\\n        return dp[start][n] = false;\\n    }\\n    bool wordBreak(string &s, vector<string>& wordDict) {\\n        memset(dp,-1,sizeof(dp));\\n        for(auto &word : wordDict) map[word]++;\\n        int n=s.size();\\n        return solve(s,n,0);\\n    }\\n};\\n```\\n**I will highly recommend to try *Trie+DP solution,*** **It is faster then map+DP method and it will clear lot of concept of trie.  Hope this will help :)**\\n\\nPlease **Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Trie",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Trie{\\n      public:\\n        Trie *child[26];\\n        bool isEnd = false;\\n    };\\n    \\n    void insert(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(!cur->child[ch-\\'a\\']) cur->child[ch-\\'a\\'] = new Trie();\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(!cur->child[ch-\\'a\\']) return false;\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    int dp[305][305];\\n    bool solve(string &s, Trie *root, int n, int start){\\n        if(start==n) return true;\\n        if(dp[start][n]!=-1) return dp[start][n];\\n        for(int i=start; i<n; ++i){\\n            string str = s.substr(start,i-start+1);\\n            if(search(str,root)){\\n                if(solve(s,root,n,i+1)) return dp[start][n] = true;\\n            }\\n        }\\n        return dp[start][n] = false;\\n    }\\n    \\n    bool wordBreak(string &s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict) insert(word,root);\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,root,n,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> map;\\n    int dp[305][305];\\n    bool solve(string &s, int n, int start){\\n        if(start==n) return true;\\n        if(dp[start][n]!=-1) return dp[start][n];\\n        for(int i=start; i<n; ++i){\\n            string str = s.substr(start,i-start+1);\\n            if(map.find(str)!=map.end()){\\n                if(solve(s,n,i+1)) return dp[start][n] = true;\\n            }\\n        }\\n        return dp[start][n] = false;\\n    }\\n    bool wordBreak(string &s, vector<string>& wordDict) {\\n        memset(dp,-1,sizeof(dp));\\n        for(auto &word : wordDict) map[word]++;\\n        int n=s.size();\\n        return solve(s,n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860687,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing dynamic programming to keep a certain substring is true or not.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/LgoAfakGz5E\\n\\n# Subscribe to my channel from here. I have 239 videos as of August 4th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize a list `dp` of size `len(s) + 1`, where `dp[i]` will indicate whether the substring up to index `i` (inclusive) can be segmented into words from `wordDict`. Initialize `dp[0]` as `True`, since an empty string can always be segmented.\\n\\n2. Iterate over each index `i` from 1 to `len(s) + 1` (outer loop):\\n   - For each index `i`, iterate over each word `w` in `wordDict` (inner loop):\\n     - Check if the current word `w` can be appended to the substring ending at index `i - len(w)`.\\n     - This is done by verifying three conditions:\\n       1. `i - len(w) >= 0`: This ensures that the current word can be fit within the current index `i`.\\n       2. `dp[i - len(w)]`: This checks if the substring before the current word can be segmented into words from `wordDict`.\\n       3. `s[:i].endswith(w)`: This checks if the current substring ending at index `i` ends with the word `w`.\\n\\n3. If all three conditions are satisfied, it means that the substring up to index `i` can be segmented using words from `wordDict`. In this case, set `dp[i]` to `True`.\\n\\n4. After iterating through all words in `wordDict` and updating `dp[i]` for the current index `i`, move on to the next index in the outer loop.\\n\\n5. Continue this process until you\\'ve iterated over all possible indices `i` from 1 to `len(s)`.\\n\\n6. Finally, return `dp[-1]`, which indicates whether the entire string `s` can be segmented using words from `wordDict`.\\n\\nIn essence, the algorithm uses dynamic programming to build up the `dp` array, where each entry represents whether a certain substring can be segmented using the words from the dictionary. The algorithm leverages the fact that if a substring up to index `i` can be segmented, and a word from `wordDict` can be appended to it to reach index `i`, then the substring up to index `i + len(word)` can also be segmented.\\n\\n# Complexity\\n- Time complexity: O(n * m * k)\\nn is length of input string and m is length of wordDict. nested loop is n * m and in the nested loop. We check substring operations which costs O(k).\\n\\n- Space complexity: O(n)\\nFor dp list. n is the length of the string s\\n\\n```python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\n        dp = [True] + [False] * len(s)\\n\\n        for i in range(1, len(s) + 1):\\n            for w in wordDict:\\n                if i - len(w) >= 0 and dp[i - len(w)] and s[:i].endswith(w):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    const n = s.length;\\n    const dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (const word of wordDict) {\\n            if (i - word.length >= 0 && dp[i - word.length] && s.substring(i - word.length, i) === word) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (String word : wordDict) {\\n                if (i - word.length() >= 0 && dp[i - word.length()] && s.substring(i - word.length(), i).equals(word)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        \\n        for (int i = 1; i <= s.size(); i++)\\n            for (int j = 0; j < i; j++)\\n                if ((dp[j]) && (find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end())) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n\\n        return dp.back();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\n        dp = [True] + [False] * len(s)\\n\\n        for i in range(1, len(s) + 1):\\n            for w in wordDict:\\n                if i - len(w) >= 0 and dp[i - len(w)] and s[:i].endswith(w):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    const n = s.length;\\n    const dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (const word of wordDict) {\\n            if (i - word.length >= 0 && dp[i - word.length] && s.substring(i - word.length, i) === word) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (String word : wordDict) {\\n                if (i - word.length() >= 0 && dp[i - word.length()] && s.substring(i - word.length(), i).equals(word)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        \\n        for (int i = 1; i <= s.size(); i++)\\n            for (int j = 0; j < i; j++)\\n                if ((dp[j]) && (find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end())) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860872,
                "title": "c-java-pyhton3-space-and-time-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo determine if the string s can be segmented into a space-separated sequence of dictionary words, we can use dynamic programming. The idea is to break down the problem into smaller subproblems and build a solution from the subproblems\\' results. We\\'ll keep track of whether a substring can be segmented into dictionary words or not, and use this information to solve the overall problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, we create a set from the given wordDict to efficiently check if a word is present in the dictionary.\\n- We\\'ll use a dynamic programming approach to fill up a boolean array dp, where dp[i] will be true if the substring s[0:i] (i.e., the first i characters of s) can be segmented into dictionary words. Initially, all elements in dp are set to false.\\n- We\\'ll iterate through each index i in the string s, and for each index, we\\'ll check all possible prefixes s[0:j] (where 0 <= j < i) and see if the prefix is in the dictionary and if the remaining substring s[j:i] is also in the dictionary or if it\\'s an empty string.\\n- If both the prefix and the remaining substring are in the dictionary (or if the remaining substring is empty), then we can set dp[i] to true, indicating that the substring s[0:i] can be segmented.\\n- Finally, we return the value of dp[s.length()], which indicates whether the entire string s can be segmented or not.\\n\\n# Complexity\\n- Time complexity: **O(n^2)**, where n is the length of the input string s\\n\\n- Space complexity: **O(n)**, where n is the length of the input string s\\n\\n# Code\\n## C++\\n```\\nclass Solution {\\npublic:\\n    bool solve(string &s, map<string,bool>& mp, int ind, string temp,map<pair<int,string>,bool>&dp){\\n        if(ind == s.length() && temp == \"\") return true;\\n        if(ind == s.length()) return false;\\n        if(dp.find({ind,temp})!=dp.end()) return dp[{ind,temp}];\\n        bool ans = false;\\n        temp+=s[ind];\\n        if(mp.find(temp)!=mp.end()){\\n            ans = solve(s,mp,ind+1,\"\",dp);\\n        }\\n        ans = ans || solve(s,mp,ind+1,temp,dp);\\n        \\n        return dp[{ind,temp}] = ans;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,bool>mp;\\n        map<pair<int,string>,bool> dp;\\n        for(auto word: wordDict) mp[word] = true;\\n        return solve(s,mp,0,\"\",dp);\\n    }\\n};\\n```\\n## Java\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (dp[j] && dict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n```\\n## Python3\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\\n![upvote img.jpg](https://assets.leetcode.com/users/images/e3445fcf-d1b4-43a5-8575-4dffbd7f48fe_1691121465.7283533.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string &s, map<string,bool>& mp, int ind, string temp,map<pair<int,string>,bool>&dp){\\n        if(ind == s.length() && temp == \"\") return true;\\n        if(ind == s.length()) return false;\\n        if(dp.find({ind,temp})!=dp.end()) return dp[{ind,temp}];\\n        bool ans = false;\\n        temp+=s[ind];\\n        if(mp.find(temp)!=mp.end()){\\n            ans = solve(s,mp,ind+1,\"\",dp);\\n        }\\n        ans = ans || solve(s,mp,ind+1,temp,dp);\\n        \\n        return dp[{ind,temp}] = ans;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,bool>mp;\\n        map<pair<int,string>,bool> dp;\\n        for(auto word: wordDict) mp[word] = true;\\n        return solve(s,mp,0,\"\",dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (dp[j] && dict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106264,
                "title": "simple-c-dp-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is that the given problem  can be divided into sub-problems .And  If these subproblems individually satisfy the required conditions, then  complete problem will also satisfy the same. And hence we can say whether it is true to find the word in the dictionary or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Naive Approach**: Use recursion and backtracking. For finding the solution, we check every prefix of the string in the word_dict of words, if it is found , then the recursive function is called for the remaining portion of that string. But this will be$$ 2^n$$ so will give tle . SO we can optimize using memoization or dp.\\n- **DP**: So as we can see that in recurion we call for evrery prefix substring and check if its presnt and like this the whole is presnt or not .So similarly we can store the same ,like upto certain index whether the substring upto that index is present or not. In this way our dp array will be filled with 0\\'s and 1\\'s representing whether the substring is present or not . And at last if last index is true i.e dp[n] is true this means whole string is presnt .\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938500,
                "title": "100-fastest-swift-solution-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n ^ 2), where n is the length of s.\\n    //   - space: O(n), where n is the length of s.\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\\n        var dp = [Bool](repeating: false, count: s.count+1)\\n        dp[0] = true\\n\\n        let chars = Array(s)\\n        let wordSet = Set(wordDict)\\n\\n        for i in 1...s.count {\\n            for j in 0..<i {\\n                guard dp[j], wordSet.contains(String(chars[j..<i])) else { continue }\\n                dp[i] = true\\n                break\\n            }\\n        }\\n\\n        return dp[s.count]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n ^ 2), where n is the length of s.\\n    //   - space: O(n), where n is the length of s.\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\\n        var dp = [Bool](repeating: false, count: s.count+1)\\n        dp[0] = true\\n\\n        let chars = Array(s)\\n        let wordSet = Set(wordDict)\\n\\n        for i in 1...s.count {\\n            for j in 0..<i {\\n                guard dp[j], wordSet.contains(String(chars[j..<i])) else { continue }\\n                dp[i] = true\\n                break\\n            }\\n        }\\n\\n        return dp[s.count]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354276,
                "title": "python3-breadth-first-search",
                "content": "\\n```\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \"\"\"\\n\\t\\ts = \"catsandog\"\\n\\t\\twordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\\n        0 1 2 3 4 5 6 7 8 9\\n        c a t s a n d d o g\\n\\t\\tqueue = [0]\\n\\t\\tyou find \\'cat\\' and \\'cats\\'\\n\\t\\tqueue = [3,4]\\n\\t\\tyou find \\'and\\u2018  and \\'sand\\'\\n\\t\\tqueue = [7]\\n\\t\\tyou find \\'dog\\', which you reached the end.\\n         0\\n        / \\\\\\n      cat  cats\\n      /      \\\\\\n    sand     and\\n    /         \\\\\\n    dog       dog\\n        \"\"\"\\n        visited = set()\\n        queue = deque([0])\\n        while queue:\\n            start = queue.popleft()\\n            if start not in visited:\\n                for end in range(start + 1, len(s)+1):\\n                    if s[start:end] in wordDict:\\n                        queue.append(end)\\n                        if end == len(s):\\n                            return True\\n                visited.add(start)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \"\"\"\\n\\t\\ts = \"catsandog\"\\n\\t\\twordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\\n        0 1 2 3 4 5 6 7 8 9\\n        c a t s a n d d o g\\n\\t\\tqueue = [0]\\n\\t\\tyou find \\'cat\\' and \\'cats\\'\\n\\t\\tqueue = [3,4]\\n\\t\\tyou find \\'and\\u2018  and \\'sand\\'\\n\\t\\tqueue = [7]\\n\\t\\tyou find \\'dog\\', which you reached the end.\\n         0\\n        / \\\\\\n      cat  cats\\n      /      \\\\\\n    sand     and\\n    /         \\\\\\n    dog       dog\\n        \"\"\"\\n        visited = set()\\n        queue = deque([0])\\n        while queue:\\n            start = queue.popleft()\\n            if start not in visited:\\n                for end in range(start + 1, len(s)+1):\\n                    if s[start:end] in wordDict:\\n                        queue.append(end)\\n                        if end == len(s):\\n                            return True\\n                visited.add(start)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44003,
                "title": "very-clean-python-code-with-trie",
                "content": "    class TrieNode(object):\\n        def __init__(self, char=None, isWord=False):\\n            self.char = char\\n            self.isWord = isWord\\n            self.children = {}\\n    \\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n            self.cache = {}\\n    \\n        def insert(self, word):\\n            root = self.root\\n            for char in word:\\n                if char not in root.children:\\n                    root.children[char] = TrieNode(char)\\n                root = root.children[char]\\n            root.isWord = True\\n    \\n        def cache(f):\\n            def method(obj, s):\\n                if s not in obj.cache:\\n                    obj.cache[s] = f(obj, s)\\n                return obj.cache[s]\\n            return method\\n    \\n        @cache\\n        def search(self, s):\\n            root = self.root\\n            for i, char in enumerate(s):\\n                if char not in root.children:\\n                    return False\\n    \\n                if root.children[char].isWord:\\n                    if self.search(s[i + 1:]):\\n                        return True\\n                root = root.children[char]\\n            return root.isWord\\n    \\n    \\n    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            trie = Trie()\\n            [trie.insert(word) for word in wordDict]\\n    \\n            return trie.search(s)",
                "solutionTags": [],
                "code": "    class TrieNode(object):\\n        def __init__(self, char=None, isWord=False):\\n            self.char = char\\n            self.isWord = isWord\\n            self.children = {}\\n    \\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n            self.cache = {}\\n    \\n        def insert(self, word):\\n            root = self.root\\n            for char in word:\\n                if char not in root.children:\\n                    root.children[char] = TrieNode(char)\\n                root = root.children[char]\\n            root.isWord = True\\n    \\n        def cache(f):\\n            def method(obj, s):\\n                if s not in obj.cache:\\n                    obj.cache[s] = f(obj, s)\\n                return obj.cache[s]\\n            return method\\n    \\n        @cache\\n        def search(self, s):\\n            root = self.root\\n            for i, char in enumerate(s):\\n                if char not in root.children:\\n                    return False\\n    \\n                if root.children[char].isWord:\\n                    if self.search(s[i + 1:]):\\n                        return True\\n                root = root.children[char]\\n            return root.isWord\\n    \\n    \\n    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            trie = Trie()\\n            [trie.insert(word) for word in wordDict]\\n    \\n            return trie.search(s)",
                "codeTag": "Java"
            },
            {
                "id": 44086,
                "title": "easy-understand-python-dp-solution",
                "content": "    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a boolean\\n        def wordBreak(self, s, dict):\\n            n = len(s)\\n            f = [False for i in range(n+1)]\\n            f[0] = True\\n            for i in range(n):\\n                if f[i]:\\n                    for j in dict:\\n                        l = len(j)\\n                        if i+l<=n and s[i:i+l] == j:\\n                            f[i+l] = True\\n            return f[n]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a boolean\\n        def wordBreak(self, s, dict):\\n            n = len(s)\\n            f = [False for i in range(n+1)]\\n            f[0] = True\\n            for i in range(n):\\n                if f[i]:\\n                    for j in dict:\\n                        l = len(j)\\n                        if i+l<=n and s[i:i+l] == j:\\n                            f[i+l] = True\\n            return f[n]",
                "codeTag": "Java"
            },
            {
                "id": 3238057,
                "title": "java-3-solutions-with-clear-explanation-and-real-life-application-brute-force-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nDetermine whether a given string can be segmented into words from a given dictionary. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are a couple of approaches to solve this problem:\\n1. Brute force: generate all possible substrings and check whether if the current substring can be segmented into words in the dictionary wordDict. If all the substrings can be segmented into words, then reture true; otherwise, return false.\\n\\n2. Dynamic Programming: we build a boolean array dp of size `n+1` to keep track of whether the first k characters of the input string can be segmented into words from the dictionary.\\n\\n# Code\\n#### **1) Brute force solution (Recursive - Top Down) [TLE] \\u274C**\\n\\n1. The `helper` function iterates over all possible substrings of the input string starting from the first index.\\n\\n2. Check if the substring exists in the dictionary. If it does, then recursively check whether the remaining part of the string can be segmented into words. \\n\\n3. If `index == s.length()`, which means all the substrings can be segmented into words, then return true; otherwise return false.\\n\\n```\\nclass Solution {\\n   public boolean wordBreak(String s, List<String> wordDict) {  \\n        //step 1\\n        return helper(0, s, wordDict);\\n   }\\n\\n   public boolean helper(int index, String s, List<String> wordDict)\\n   {\\n       //step 3\\n       int n = s.length();\\n       if(index == n) return true;\\n\\n       for(int k = index + 1; k <= n; k++)\\n       {\\n           //step 2\\n           if(wordDict.contains(s.substring(index, k)) && helper(k, s, wordDict))\\n           return true;\\n       }\\n       return false;\\n   }\\n}\\n```\\n\\n- Time complexity: $$O(2^n)$$ where n is the length of the input string. We try all possible combinations of substrings in the input string.\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array.\\n\\n#### **2) Dynamic programming solutions**\\n##### 1. Recursive - Memoization - Top Down \\u2705\\n\\nThis solution is built on top of the brute force solution, where we use memoization to avoid recomputing the same subproblems.\\n\\nWe also initializes a Boolean array dp with null values, which is used for memoization.\\n\\n```\\nclass Solution {\\n   public boolean wordBreak(String s, List<String> wordDict) {  \\n        Boolean [] dp = new Boolean[s.length()];\\n        return helper(0, s, wordDict, dp);\\n   }\\n\\n   public boolean helper(int index, String s, List<String> wordDict, Boolean [] dp)\\n   {\\n       //step 3\\n       int n = s.length();\\n       if(index == n) return true;\\n       if(dp[index] != null) return dp[index];\\n       for(int k = index + 1; k <= n; k++)\\n       {\\n           //step 2\\n           if(wordDict.contains(s.substring(index, k)) && helper(k, s, wordDict, dp))\\n           return dp[index] = true;\\n       }\\n       return dp[index] = false;\\n   }\\n}\\n```\\n\\n- Time complexity: $$O(n ^ 2)$$ where n is the length of the input string, due to the nested loops used in the helper function.\\n\\n- Space complexity: $$O(n)$$ where n is the length of the input string. This is because we use an array `dp` of size `s.length()` to store results of previous computed subproblems.\\n\\n##### 2. Iterative - Tabulation - Bottom Up \\u2705\\n\\n1. We create a boolean array `dp` of length `s.length()`, where `dp[k]` indicates if the substring from 0 to i can be segmented into words from the dictionary. \\n\\n2. Then we iterate over the input string and checks if anysubstring from `j to k` (where `j <= k`) can be segmented into words from the dictionary. If it does, `dp[k]` is set to true. \\n\\n3. Finally we returns dp[len-1] which indicates if the entire string can be segmented into words from the dictionary.\\n\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int len = s.length();\\n        boolean [] dp = new boolean[len];\\n        for(int k = 0; k < len; k++)\\n        {\\n            for(int j = 0; j <= k; j++)\\n            {\\n                if((j == 0 || dp[j-1] == true) && wordDict.contains(s.substring(j, k + 1)))\\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len-1];\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(n^2)$$ where n is the length of the input string.\\n\\n- Space complexity: $$O(n)$$ due to the `dp` array.\\n\\n\\n\\n# Application\\n\\n###### The Word Break problem have several real-life applications, including the following: \\n\\n1. Spell-checking software: Identify and suggest corrections for misspelled words by breaking down the words into smaller units and comparing them against a dictionary.\\n\\n2. Natural Language Processing (NLP): segment text into meaningful units such as sentences, phrases, and words. This is essential for applications such as text classification, machine translation, and sentiment analysis.\\n\\n3. Search engines: identify relevant keywords and phrases from a user\\'s search query and match them against indexed web pages.\\n\\n4. Auto-complete: suggest completions for partially typed words, by matching them against a dictionary of valid words.\\n\\n5. Speech recognition: segment speech signals into discrete words, which can then be processed and analyzed.\\n\\n6. Optical character recognition (OCR): segment text from images into individual words, which can then be recognized and converted into editable text.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n   public boolean wordBreak(String s, List<String> wordDict) {  \\n        //step 1\\n        return helper(0, s, wordDict);\\n   }\\n\\n   public boolean helper(int index, String s, List<String> wordDict)\\n   {\\n       //step 3\\n       int n = s.length();\\n       if(index == n) return true;\\n\\n       for(int k = index + 1; k <= n; k++)\\n       {\\n           //step 2\\n           if(wordDict.contains(s.substring(index, k)) && helper(k, s, wordDict))\\n           return true;\\n       }\\n       return false;\\n   }\\n}\\n```\n```\\nclass Solution {\\n   public boolean wordBreak(String s, List<String> wordDict) {  \\n        Boolean [] dp = new Boolean[s.length()];\\n        return helper(0, s, wordDict, dp);\\n   }\\n\\n   public boolean helper(int index, String s, List<String> wordDict, Boolean [] dp)\\n   {\\n       //step 3\\n       int n = s.length();\\n       if(index == n) return true;\\n       if(dp[index] != null) return dp[index];\\n       for(int k = index + 1; k <= n; k++)\\n       {\\n           //step 2\\n           if(wordDict.contains(s.substring(index, k)) && helper(k, s, wordDict, dp))\\n           return dp[index] = true;\\n       }\\n       return dp[index] = false;\\n   }\\n}\\n```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int len = s.length();\\n        boolean [] dp = new boolean[len];\\n        for(int k = 0; k < len; k++)\\n        {\\n            for(int j = 0; j <= k; j++)\\n            {\\n                if((j == 0 || dp[j-1] == true) && wordDict.contains(s.substring(j, k + 1)))\\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496203,
                "title": "c-two-solutions-recursive-with-memoization-and-dp-with-comments",
                "content": "#### Recurvice + Memo:\\n\\n```c++\\n    bool helper(const string& s, int start, const unordered_set<string>& d, vector<int>& memo) {\\n        if (start == s.size()) {\\n            return true;\\n        }\\n        \\n        if (memo[start] != -1) return memo[start];\\n        \\n        for (int i = start + 1; i <= s.size(); ++i) {\\n            const string sub = s.substr(start, i - start); \\n            if (d.count(sub) == 1) {\\n                if (helper(s, i, d, memo)) {\\n                    memo[start] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        memo[start] = 0;\\n        return false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> d(wordDict.begin(), wordDict.end());\\n\\t\\t// Use a vector since we can index from 0 to N. \\n\\t\\t// Possible values in vector are: -1, 0, 1.\\n        vector<int> memo(s.length(), -1); \\n        return helper(s, 0, d, memo);\\n    }\\n```\\nFor the worst runtime, take this example: `s = \"abcd\"` and `wordDict = [\"a\", \"b\", \"c\", \"bc\", \"ab\", \"abc\"]`.\\nWIthout memoization the runtime complexity would be O(2^N) but with it we avoid solving the same sub-problems all the time:\\n\\n* Runtime complexity: O(N^2)\\n* Space complexity: O(N)\\n\\n#### DP:\\n\\n```c++\\n    bool wordBreak(string s, vector<string>& words) {\\n        if (words.size() == 0) return false;\\n        \\n        unordered_set<string> d(words.begin(), words.end());\\n           \\n\\t\\t // dp[i] is true only if a valid word or sequence of words ends at i\\n        vector<bool> dp(s.size() + 1, false);\\n        dp[0] = true;\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                // check only if a valid sequence of words (or a word) ends at j\\n                if (dp[j]) {\\n                    const string sub = s.substr(j, i - j);\\n                    if (d.count(sub)) {\\n                        // Ending at i is a valid word\\n                        dp[i] = true; \\n\\t\\t\\t\\t\\t\\t// Others j values might be false\\n\\t\\t\\t\\t\\t\\t// We stop here since there is one valid sequence ending here\\n                        break; \\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n\\t\\n```\\n\\n* Runtime complexity: O(N^2)\\n* Space complexity: O(N)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```c++\\n    bool helper(const string& s, int start, const unordered_set<string>& d, vector<int>& memo) {\\n        if (start == s.size()) {\\n            return true;\\n        }\\n        \\n        if (memo[start] != -1) return memo[start];\\n        \\n        for (int i = start + 1; i <= s.size(); ++i) {\\n            const string sub = s.substr(start, i - start); \\n            if (d.count(sub) == 1) {\\n                if (helper(s, i, d, memo)) {\\n                    memo[start] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        memo[start] = 0;\\n        return false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> d(wordDict.begin(), wordDict.end());\\n\\t\\t// Use a vector since we can index from 0 to N. \\n\\t\\t// Possible values in vector are: -1, 0, 1.\\n        vector<int> memo(s.length(), -1); \\n        return helper(s, 0, d, memo);\\n    }\\n```\n```c++\\n    bool wordBreak(string s, vector<string>& words) {\\n        if (words.size() == 0) return false;\\n        \\n        unordered_set<string> d(words.begin(), words.end());\\n           \\n\\t\\t // dp[i] is true only if a valid word or sequence of words ends at i\\n        vector<bool> dp(s.size() + 1, false);\\n        dp[0] = true;\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                // check only if a valid sequence of words (or a word) ends at j\\n                if (dp[j]) {\\n                    const string sub = s.substr(j, i - j);\\n                    if (d.count(sub)) {\\n                        // Ending at i is a valid word\\n                        dp[i] = true; \\n\\t\\t\\t\\t\\t\\t// Others j values might be false\\n\\t\\t\\t\\t\\t\\t// We stop here since there is one valid sequence ending here\\n                        break; \\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43852,
                "title": "my-java-dp-solution-beats-93-83",
                "content": "    public boolean wordBreak(String s, Set<String> wordDict) {\\n        int maxWord = getMax(wordDict);\\n        int len = s.length();\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= len; i ++) {\\n            int start = Math.max(1, i - maxWord);\\n            for (int j = start; j <= i; j++) {\\n                if (dp[j - 1] && wordDict.contains(s.substring(j - 1, i))) {\\n                    dp[i] = true; \\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n    \\n    private int getMax(Set<String> wordDict) {\\n        int max = 0;\\n        for (String str : wordDict) {\\n            max = Math.max(max, str.length());\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean wordBreak(String s, Set<String> wordDict) {\\n        int maxWord = getMax(wordDict);\\n        int len = s.length();\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= len; i ++) {\\n            int start = Math.max(1, i - maxWord);\\n            for (int j = start; j <= i; j++) {\\n                if (dp[j - 1] && wordDict.contains(s.substring(j - 1, i))) {\\n                    dp[i] = true; \\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n    \\n    private int getMax(Set<String> wordDict) {\\n        int max = 0;\\n        for (String str : wordDict) {\\n            max = Math.max(max, str.length());\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 675314,
                "title": "java-with-picture",
                "content": "\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_139_using_dp.png)  \\n\\n\\n\\n``` java\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int len = s.length();\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= len; i++){\\n            for (int j = 0; j < i; j++){\\n                if (dp[j] && wordDict.contains(s.substring(j, i))){\\n                    dp[i] = true;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int len = s.length();\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= len; i++){\\n            for (int j = 0; j < i; j++){\\n                if (dp[j] && wordDict.contains(s.substring(j, i))){\\n                    dp[i] = true;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460974,
                "title": "cpp-0ms-simple-solution-recursion-memoization",
                "content": "Just go with the flow, check if the substring of s from 0 to i is a part of wordDIct[i]. if Yes, make a recursive call to check further. Done!!!!!!  \\nOnce you have written the solution recursively, then just memoize it. \\n\\n```\\nclass Solution {\\npublic:\\n    int dp[300];\\n    \\n    bool helper(string s, vector<string>& w)\\n    {\\n        if(s.size() == 0) return dp[s.size()] = true;\\n        if(dp[s.size()] != -1) return dp[s.size()];\\n            \\n        bool check = false;\\n        \\n        for(int idx = 0; idx < w.size(); idx++)\\n        {\\n            if(s.substr(0, w[idx].size()) == w[idx])\\n            {\\n                if(helper(s.substr(w[idx].size()), w)) \\n                {\\n                    check = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()] = check;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& W)\\n    {\\n        if(W.size() == 0) return false;\\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        return helper(s, W);\\n    }\\n};\\n```\\n\\nIf you have any doubts, feel free to message. Do upvote.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[300];\\n    \\n    bool helper(string s, vector<string>& w)\\n    {\\n        if(s.size() == 0) return dp[s.size()] = true;\\n        if(dp[s.size()] != -1) return dp[s.size()];\\n            \\n        bool check = false;\\n        \\n        for(int idx = 0; idx < w.size(); idx++)\\n        {\\n            if(s.substr(0, w[idx].size()) == w[idx])\\n            {\\n                if(helper(s.substr(w[idx].size()), w)) \\n                {\\n                    check = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()] = check;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& W)\\n    {\\n        if(W.size() == 0) return false;\\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        return helper(s, W);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43951,
                "title": "python-bfs-beats-95",
                "content": "I use BFS to avoid useless states calculation like someone did in Coin Change. I do not check every substring but I check the substring whose length is possible (I store all distinct length of words in a list). Thus, no need to check backward from the current position one by one. \\n\\nIt runs for 44ms in average while my original DP is 58ms.\\n\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        queue = [0]\\n        slen = len(s)\\n        lenList = [l for l in set(map(len,wordDict))]\\n        visited = [0 for _ in range(0, slen + 1)]\\n        while queue:\\n            tmpqueue = []\\n            for start in queue:\\n                for l in lenList:\\n                    if s[start:start+l] in wordDict:\\n                        if start + l == slen:\\n                            return True\\n                        if visited[start + l] == 0:\\n                            tmpqueue.append(start+l)\\n                            visited[start + l] = 1\\n            queue, tmpqueue = tmpqueue, []\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        queue = [0]\\n        slen = len(s)\\n        lenList = [l for l in set(map(len,wordDict))]\\n        visited = [0 for _ in range(0, slen + 1)]\\n        while queue:\\n            tmpqueue = []\\n            for start in queue:\\n                for l in lenList:\\n                    if s[start:start+l] in wordDict:\\n                        if start + l == slen:\\n                            return True\\n                        if visited[start + l] == 0:\\n                            tmpqueue.append(start+l)\\n                            visited[start + l] = 1\\n            queue, tmpqueue = tmpqueue, []\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107044,
                "title": "c-template-for-word-break-i-ii-concatenated-words",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for all the problems:\\nAll the three given problems  can be divided into sub-problems .And  If these subproblems individually satisfy the required conditions, then  complete problem will also satisfy the same. And hence we can say whether it is true to find the word in the dictionary or not.\\n\\n# Approach\\n- **Naive Approach**: Use recursion and backtracking. For finding the solution, we check every prefix of the string in the word_dict of words, if it is found , then the recursive function is called for the remaining portion of that string. But this will be$$ 2^n$$ so will give tle . SO we can optimize using memoization or dp.\\n- **DP**: So as we can see that in recurion we call for evrery prefix substring and check if its presnt and like this the we check the whole is present or not .So similarly we can store the same ,like upto certain index whether the substring upto that index is present or not . In this way our dp array will be filled with 0\\'s and 1\\'s representing whether the substring upto that index is present or not . And at last if last index is true i.e dp[n] is true this means whole string is presnt .\\n- So applying this logic we can do all the three problems with a little modification based on requirements.\\n<!-- Describe your approach to solving the problem. -->\\n# **For Word Break I**\\n\\n# Code\\n\\n```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **For Word Break II**\\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **For concatenated Words**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(N*W^3)$$\\n    - where `N=word.length and W = words[i].length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*W)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615636,
                "title": "c-dp-solution",
                "content": "**Intuition**\\n\\t![image](https://assets.leetcode.com/users/newbiecoder1/image_1588724366.png)\\n\\n**Complexity**\\n- Time: O(n^3)\\n- Space: O(n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        \\n        //dp[i] indicates whehter substring of length i can be segmented.\\n        bool[] dp = new bool[s.Length + 1];\\n        //assume empty string is always in the wordDict\\n        dp[0] = true;\\n        \\n        // HashSet<T>.Contains(T) is O(1) operation. It\\'s better than List<T>.Contains<T) which is O(n) operation\\n        HashSet<string> set = new HashSet<string>(wordDict);\\n        \\n        // check substring from length 1 to s.Length \\n\\t\\t// i and j represent the length of substrings\\n        for(int i = 1; i < dp.Length; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(dp[j] && set.Contains(s.Substring(j, i - j)))\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n                   \\n        return dp[s.Length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        \\n        //dp[i] indicates whehter substring of length i can be segmented.\\n        bool[] dp = new bool[s.Length + 1];\\n        //assume empty string is always in the wordDict\\n        dp[0] = true;\\n        \\n        // HashSet<T>.Contains(T) is O(1) operation. It\\'s better than List<T>.Contains<T) which is O(n) operation\\n        HashSet<string> set = new HashSet<string>(wordDict);\\n        \\n        // check substring from length 1 to s.Length \\n\\t\\t// i and j represent the length of substrings\\n        for(int i = 1; i < dp.Length; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(dp[j] && set.Contains(s.Substring(j, i - j)))\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n                   \\n        return dp[s.Length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205773,
                "title": "139-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We can use Dynamic programming to solve the problem. Create an array dp of length s+1.\\n- dp[i] represents whether we can segment the substring s[0:i] into words from the dictionary.\\n- Initially, we set dp[0] to True because the empty string can be segmented into an empty sequence of words.\\n- For each substring s[0:i] (i=1 to s+1), we need to check whether the prefix s[0:j] and suffix s[j:i] can be segmented. If so, set dp[i] to True.\\n- To check whether s[0:j] can be segmented, we can use dp[j]. If it is True, then we just need to check whether s[j:i] is in the wordDict.\\n- We can use a set to store the wordDict for constant time lookup.\\n- The final answer is stored in dp[s+1].\\n\\n# Complexity\\n- Time complexity:\\nO(n^2), where n is the length of the string.\\n\\n- Space complexity:\\nO(n), where n is the length of the string.\\n\\n# Code\\n```\\nclass Solution:\\n  def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n    word_set = set(wordDict)  # convert wordDict to a set for constant time lookup\\n    n = len(s)\\n    dp = [False] * (n+1)  # create an array dp of length n+1\\n    dp[0] = True  # empty string can be segmented into an empty sequence of words\\n    \\n    for i in range(1, n+1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in word_set:\\n                dp[i] = True\\n                break\\n    \\n    return dp[n]  # return the final answer\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n    word_set = set(wordDict)  # convert wordDict to a set for constant time lookup\\n    n = len(s)\\n    dp = [False] * (n+1)  # create an array dp of length n+1\\n    dp[0] = True  # empty string can be segmented into an empty sequence of words\\n    \\n    for i in range(1, n+1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in word_set:\\n                dp[i] = True\\n                break\\n    \\n    return dp[n]  # return the final answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552323,
                "title": "javascript-dp-with-heavy-comments",
                "content": "***\\nFirst, lets look at the recursive solution WITHOUT memoization/DP. **(THIS SOLUTION WILL TIME OUT)**\\n***\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict) => {\\n\\t// We break down the word each recursive call\\n\\t// Base case is the broken down word becomes an empty string, which means we found a path\\n    if(!s) return true;\\n    \\n\\t// We need to loop everyword in the wordDict\\n    for(let word of wordDict) {\\n\\t\\t// indexOf will give us the prefix START of the word we pass in\\n        // So if s.indexOf(word) is 0, we know the word is the prefix\\n        if(s.indexOf(word) === 0) {\\n\\t\\t\\t// If they match, we continue our recursion\\n\\t\\t\\t// We pass in the NEW s with the word sliced from the prefix, we also need to pass wordDict\\n\\t\\t\\t// If we ever hit our base case, this will evaluate to true and return true overall\\n            if(wordBreak(s.slice(word.length), wordDict)) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n\\t// If we never make it to a base case, we have no answers\\n    return false;\\n};\\n```\\n***\\nNow, lets look at the solution WITH DP/Memoization, THIS IS THE CORRECT SOLUTION. **(Added lines will have #### after them)**\\n***\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict, memo = {}) => { // Default arg which is our memo object #####\\n\\t// We break down the word each recursive call\\n\\t// Base case is the broken down word becomes an empty string, which means we found a path\\n    if(!s) return true;\\n    if(s in memo) return memo[s]; // Base case to avoid extra computation #####\\n    // ^^ Will be hit if we already computated this word\\n    \\n\\t// We need to loop everyword in the wordDict\\n    for(let word of wordDict) {\\n\\t\\t// indexOf will give us the prefix START of the word we pass in\\n        // So if s.indexOf(word) is 0, we know the word is the prefix\\n        if(s.indexOf(word) === 0) {\\n\\t\\t\\t// If they match, we continue our recursion\\n\\t\\t\\t// We pass in the NEW s with the word sliced from the prefix, we also need to pass wordDict\\n\\t\\t\\t// If we ever hit our base case, this will evaluate to true and return true overall\\n            if(wordBreak(s.slice(word.length), wordDict, memo)) { // Remeber to pass down memo #####\\n                memo[s] = true; // Save our computation #####\\n                return true;\\n            }\\n        }\\n    }\\n    \\n\\t// If we never make it to a base case, we have no answers\\n    memo[s] = false; // Save our computation #####\\n    return false;\\n};\\n```\\n***\\nBONUS Tabulation\\n***\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    // Tablulation\\n    // Init our table, this will be boolean values since return is boolean\\n    const table = Array(s.length + 1).fill(false);\\n    // Seed our simple case, this would be base case in recursive solution\\n    // Basically, we can make an empty string, so 0 would be true\\n    // In our table, each index refers to the letter before\\n    // So table[0] is \"\", table[1] is \"l\", table[2] is \"e\", if testcase is \"leetcode\"\\n    table[0] = true;\\n    \\n    // Loop table\\n    for(let i = 0; i < table.length; i++) {\\n        // We only want to process if current table position is true\\n        if(!table[i]) continue;\\n        \\n        // Loop all letters in wordDict\\n        for(let w of wordDict) {\\n            // We want to test if word matches where we are in s, and the word\\n            // We can slice from i to i + w.length and compare with the word\\n            if(s.slice(i, i + w.length) === w) {\\n                // If we pass the condition above, and the table index we are trying to update is in bounds, update to true\\n                if(i + w.length <= table.length) table[i + w.length] = true;\\n            }\\n        }\\n    }\\n    \\n    // The last item in our table can be returned, as it will be updated to true if we found a solution\\n    return table[s.length];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict) => {\\n\\t// We break down the word each recursive call\\n\\t// Base case is the broken down word becomes an empty string, which means we found a path\\n    if(!s) return true;\\n    \\n\\t// We need to loop everyword in the wordDict\\n    for(let word of wordDict) {\\n\\t\\t// indexOf will give us the prefix START of the word we pass in\\n        // So if s.indexOf(word) is 0, we know the word is the prefix\\n        if(s.indexOf(word) === 0) {\\n\\t\\t\\t// If they match, we continue our recursion\\n\\t\\t\\t// We pass in the NEW s with the word sliced from the prefix, we also need to pass wordDict\\n\\t\\t\\t// If we ever hit our base case, this will evaluate to true and return true overall\\n            if(wordBreak(s.slice(word.length), wordDict)) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n\\t// If we never make it to a base case, we have no answers\\n    return false;\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict, memo = {}) => { // Default arg which is our memo object #####\\n\\t// We break down the word each recursive call\\n\\t// Base case is the broken down word becomes an empty string, which means we found a path\\n    if(!s) return true;\\n    if(s in memo) return memo[s]; // Base case to avoid extra computation #####\\n    // ^^ Will be hit if we already computated this word\\n    \\n\\t// We need to loop everyword in the wordDict\\n    for(let word of wordDict) {\\n\\t\\t// indexOf will give us the prefix START of the word we pass in\\n        // So if s.indexOf(word) is 0, we know the word is the prefix\\n        if(s.indexOf(word) === 0) {\\n\\t\\t\\t// If they match, we continue our recursion\\n\\t\\t\\t// We pass in the NEW s with the word sliced from the prefix, we also need to pass wordDict\\n\\t\\t\\t// If we ever hit our base case, this will evaluate to true and return true overall\\n            if(wordBreak(s.slice(word.length), wordDict, memo)) { // Remeber to pass down memo #####\\n                memo[s] = true; // Save our computation #####\\n                return true;\\n            }\\n        }\\n    }\\n    \\n\\t// If we never make it to a base case, we have no answers\\n    memo[s] = false; // Save our computation #####\\n    return false;\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    // Tablulation\\n    // Init our table, this will be boolean values since return is boolean\\n    const table = Array(s.length + 1).fill(false);\\n    // Seed our simple case, this would be base case in recursive solution\\n    // Basically, we can make an empty string, so 0 would be true\\n    // In our table, each index refers to the letter before\\n    // So table[0] is \"\", table[1] is \"l\", table[2] is \"e\", if testcase is \"leetcode\"\\n    table[0] = true;\\n    \\n    // Loop table\\n    for(let i = 0; i < table.length; i++) {\\n        // We only want to process if current table position is true\\n        if(!table[i]) continue;\\n        \\n        // Loop all letters in wordDict\\n        for(let w of wordDict) {\\n            // We want to test if word matches where we are in s, and the word\\n            // We can slice from i to i + w.length and compare with the word\\n            if(s.slice(i, i + w.length) === w) {\\n                // If we pass the condition above, and the table index we are trying to update is in bounds, update to true\\n                if(i + w.length <= table.length) table[i + w.length] = true;\\n            }\\n        }\\n    }\\n    \\n    // The last item in our table can be returned, as it will be updated to true if we found a solution\\n    return table[s.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309633,
                "title": "3-solutions-memoized-mcm-variation-brut-force",
                "content": "**Sol1:** BRUTFORCE\\nTC: exponential\\n\\n```\\nint helper(string s, vector<string> dict, int i, unordered_set<string> us)\\n    {\\n        if(i==s.size())\\n            return 1;\\n\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(us.find(s.substr(i, j-i+1))!= us.end() && helper(s, dict, j+1, us))\\n                return 1;\\n        }\\n\\n        return 0;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n                \\n        unordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return helper(s, wordDict, 0, us);\\n    }\\n```\\n\\n\\n**Sol2:** MEMOIZED  \\n\\nTC: O(N^2)\\n\\n```\\n    int dp[302];\\n\\t\\n\\tint helper(string s, vector<string> dict, int i, unordered_set<string> us)\\n    {\\n        if(i==s.size())\\n            return 1;\\n        \\n        if(dp[i]!= -1)\\n            return dp[i];\\n\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(us.find(s.substr(i, j-i+1))!= us.end() && helper(s, dict, j+1, us))\\n                return dp[i] = 1;\\n        }\\n\\n        return dp[i] = 0;\\n    }\\n\\t\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        unordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return helper(s, wordDict, 0, us);\\n    }\\n```\\n\\n**Sol3:** MATRIX CHAIN MULTIPLICATION VARIATION\\nTC: O(N^3)\\n\\n```\\nint dp[302][302];\\n    \\n    int wordBreakHelper(string A, vector<string> B, int i, int j, unordered_set<string> us)\\n    {\\n        if(i>j)\\n            return 0;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        bool ans = 0, tempAns;\\n\\n        if(us.find(A.substr(i, j-i+1)) != us.end())\\n            return 1;\\n\\n        for(int k=i;k<j;k++)\\n        {\\n            int leftChoice;\\n            if(dp[i][k]!= -1)\\n                leftChoice = dp[i][k];\\n            else\\n                dp[i][k] = leftChoice = wordBreakHelper(A, B, i, k, us);\\n\\n            int rightChoice;\\n            if(dp[k+1][j]!= -1)\\n                rightChoice = dp[k+1][j];\\n            else\\n                dp[k+1][j] = rightChoice = wordBreakHelper(A, B, k+1, j, us);\\n\\n            tempAns = leftChoice && rightChoice;\\n            ans = ans || tempAns;\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\tunordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return wordBreakHelper(s, wordDict, 0, s.size()-1, us);\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint helper(string s, vector<string> dict, int i, unordered_set<string> us)\\n    {\\n        if(i==s.size())\\n            return 1;\\n\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(us.find(s.substr(i, j-i+1))!= us.end() && helper(s, dict, j+1, us))\\n                return 1;\\n        }\\n\\n        return 0;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n                \\n        unordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return helper(s, wordDict, 0, us);\\n    }\\n```\n```\\n    int dp[302];\\n\\t\\n\\tint helper(string s, vector<string> dict, int i, unordered_set<string> us)\\n    {\\n        if(i==s.size())\\n            return 1;\\n        \\n        if(dp[i]!= -1)\\n            return dp[i];\\n\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(us.find(s.substr(i, j-i+1))!= us.end() && helper(s, dict, j+1, us))\\n                return dp[i] = 1;\\n        }\\n\\n        return dp[i] = 0;\\n    }\\n\\t\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        unordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return helper(s, wordDict, 0, us);\\n    }\\n```\n```\\nint dp[302][302];\\n    \\n    int wordBreakHelper(string A, vector<string> B, int i, int j, unordered_set<string> us)\\n    {\\n        if(i>j)\\n            return 0;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        bool ans = 0, tempAns;\\n\\n        if(us.find(A.substr(i, j-i+1)) != us.end())\\n            return 1;\\n\\n        for(int k=i;k<j;k++)\\n        {\\n            int leftChoice;\\n            if(dp[i][k]!= -1)\\n                leftChoice = dp[i][k];\\n            else\\n                dp[i][k] = leftChoice = wordBreakHelper(A, B, i, k, us);\\n\\n            int rightChoice;\\n            if(dp[k+1][j]!= -1)\\n                rightChoice = dp[k+1][j];\\n            else\\n                dp[k+1][j] = rightChoice = wordBreakHelper(A, B, k+1, j, us);\\n\\n            tempAns = leftChoice && rightChoice;\\n            ans = ans || tempAns;\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\tunordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return wordBreakHelper(s, wordDict, 0, s.size()-1, us);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350836,
                "title": "simple-java-dp-bfs-and-dfs-solution",
                "content": "All solutions take O(n* n) time and O(n) space.\\n\\nDP\\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        boolean [] dp = new boolean[s.length()+1];\\n        dp[0] = true;\\n        for(int i = 0; i < s.length(); i++){\\n            for(int j = i + 1; j <= s.length(); j++){\\n                if(set.contains(s.substring(i,j)) && dp[i]){\\n                    dp[j] = true;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\\n\\nDFS\\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        HashMap<String, Boolean> map = new HashMap<>();\\n        return helper(s, map, set);\\n    }\\n    \\n    boolean helper(String s, HashMap<String, Boolean> map, HashSet<String> set){\\n        if(s.length() == 0) return true;\\n        if(map.containsKey(s)) return map.get(s);\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(set.contains(s.substring(0, i +1)) && helper(s.substring(i + 1), map, set)){\\n                map.put(s, true);\\n                return map.get(s);\\n            }\\n        }\\n\\n        map.put(s, false);\\n        return map.get(s);\\n    }\\n```\\n\\nBFS\\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(s);\\n        HashSet<String> v = new HashSet<>();\\n        while(!q.isEmpty()){\\n            String t = q.poll();\\n            for(int i = 1; i <= t.length(); i++){\\n                if(set.contains(t.substring(0,i))){\\n                    if(i == t.length()) return true;\\n                    if(!v.contains(t.substring(i))){\\n                        q.offer(t.substring(i));\\n                        v.add(t.substring(i));\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n```\\n\\nDo up vote if you find it useful! :)",
                "solutionTags": [],
                "code": "```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        boolean [] dp = new boolean[s.length()+1];\\n        dp[0] = true;\\n        for(int i = 0; i < s.length(); i++){\\n            for(int j = i + 1; j <= s.length(); j++){\\n                if(set.contains(s.substring(i,j)) && dp[i]){\\n                    dp[j] = true;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        HashMap<String, Boolean> map = new HashMap<>();\\n        return helper(s, map, set);\\n    }\\n    \\n    boolean helper(String s, HashMap<String, Boolean> map, HashSet<String> set){\\n        if(s.length() == 0) return true;\\n        if(map.containsKey(s)) return map.get(s);\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(set.contains(s.substring(0, i +1)) && helper(s.substring(i + 1), map, set)){\\n                map.put(s, true);\\n                return map.get(s);\\n            }\\n        }\\n\\n        map.put(s, false);\\n        return map.get(s);\\n    }\\n```\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(s);\\n        HashSet<String> v = new HashSet<>();\\n        while(!q.isEmpty()){\\n            String t = q.poll();\\n            for(int i = 1; i <= t.length(); i++){\\n                if(set.contains(t.substring(0,i))){\\n                    if(i == t.length()) return true;\\n                    if(!v.contains(t.substring(i))){\\n                        q.offer(t.substring(i));\\n                        v.add(t.substring(i));\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030368,
                "title": "java-dynamic-programming-hashset",
                "content": "# Intuition\\nThe problem requires determining whether a given string `s` can be segmented into space-separated words from a dictionary. The intuition is to use dynamic programming to keep track of valid word breaks.\\n\\n# Approach\\n- Create a `wordSet` HashSet containing all the words from the `wordDict` list to allow for efficient word lookup.\\n- Initialize a boolean array `dp` of size `n+1` (where `n` is the length of the input string `s`). Each element `dp[i]` will represent whether the substring `s[0:i]` can be segmented into words from the dictionary.\\n- Set `dp[0]` to `true` because an empty string can be segmented into words (base case).\\n- Use two nested loops to iterate through the string `s`. The outer loop iterates through the positions in the string from `1` to `n`, and the inner loop iterates from `0` to the current position `i`.\\n- For each `i`, check if `dp[j]` is `true` (where `j` is in the range `[0, i)`) and whether the substring `s[j:i]` (inclusive at `i`) is in the `wordSet`. If both conditions are met, set `dp[i]` to `true`, indicating that the substring `s[0:i]` can be segmented into words.\\n- Continue this process until the outer loop has traversed the entire string.\\n- Finally, return `dp[n]`, which represents whether the entire string `s` can be segmented into words from the dictionary.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n  The algorithm uses two nested loops to fill the `dp` array, resulting in a time complexity of O(n^2), where n is the length of the input string `s`.\\n\\n- Space complexity: O(n)\\n  The algorithm uses additional space for the `wordSet` HashSet and the `dp` array, both of which have a maximum size of `n+1`, resulting in a space complexity of O(n).\\n\\n# Code\\n```java\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672860,
                "title": "easy-c-trie-for-lookup-solution",
                "content": "```\\nclass Trie {\\npublic:\\n    unordered_map<char, Trie*> children;\\n    bool isEnd=false;\\n    \\n    void insert(string word) {\\n        Trie* node=this;\\n        for(char c : word){\\n            if(node->children.find(c)==node->children.end())\\n                node->children[c]=new Trie();\\n            node=node->children[c];\\n        }\\n        node->isEnd=true;\\n    }\\n        \\n    bool search(string word) {\\n        Trie* node=this;\\n        for(char c : word){\\n            if(node->children.find(c)==node->children.end())\\n                return false;\\n            node=node->children[c];\\n        }\\n        return node->isEnd;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for(string word : wordDict)\\n            trie.insert(word);\\n        \\n        vector<bool> dp(s.size()+1, false);\\n        dp[0]=true;\\n        \\n        for(int len=1; len<=s.size(); len++){\\n            for(int i=0; i<len; i++){\\n                if(dp[i] && trie.search(s.substr(i, len-i)))\\n                    dp[len]=true;\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for(string word : wordDict)\\n            trie.insert(word);\\n        \\n        vector<bool> dp(s.size()+1, false);\\n        dp[0]=true;\\n        \\n        for(int len=1; len<=s.size(); len++){\\n            for(int i=0; i<len; i++){\\n                if(dp[i] && trie.search(s.substr(i, len-i)))\\n                    dp[len]=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 642382,
                "title": "python-with-dp-dfs-bfs",
                "content": "## DP\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False]*(n+1)\\n        dp[0] = True\\n        for i in range(n+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n        return dp[n]\\n```\\n## DFS\\n>### 1. DFS\\n```\\n#DFS Time Limit Exceeded\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False]*(n+1)\\n        \\n        def dfs(s):\\n            if s in wordDict:\\n                return True\\n            for i in range(len(s)):\\n                if dfs(s[:i]) and dfs(s[i:]):\\n                    return True\\n            return False\\n        \\n        return dfs(s)```\\n```\\n>###  2. DFS+memoization\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        table = {}\\n        def dfs(s,loc):\\n            if loc in table:\\n                return table[loc]\\n            if s in wordDict:\\n                return True\\n            start,end = loc\\n            for i in range(len(s)):\\n                if dfs(s[:i],(start,start+i)) and dfs(s[i:],(start+i,end)):\\n                    table[loc] = True\\n                    return True\\n            table[loc] = False\\n            return False\\n        \\n        return dfs(s,(0,n))\\n```\\n## BFS\\n>### 1. BFS\\n\\n```\\n#BFS Time Limit Exceeded\\n    stack = []\\n        stack.append(s)\\n        \\n        while(stack):\\n            token = stack.pop()\\n            if token in wordDict:\\n                return True\\n            for i in range(len(token)):\\n                if token[:i] in wordDict:\\n                    stack.append(token[i:])\\n        \\n        return False\\n```\\n>### 2. BFS+memoization\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        stack = []\\n        stack.append(0)\\n        visited = [False]*(n+1)\\n        while(stack):\\n            idx = stack.pop()\\n            if not visited[idx]:\\n                for i in range(idx,n):\\n                    if s[idx:i+1] in wordDict:\\n                        if s[i+1:] == \\'\\' or s[i+1:] in wordDict:\\n                            return True\\n                        stack.append(i+1)\\n            visited[idx] = True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False]*(n+1)\\n        dp[0] = True\\n        for i in range(n+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n        return dp[n]\\n```\n```\\n#DFS Time Limit Exceeded\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False]*(n+1)\\n        \\n        def dfs(s):\\n            if s in wordDict:\\n                return True\\n            for i in range(len(s)):\\n                if dfs(s[:i]) and dfs(s[i:]):\\n                    return True\\n            return False\\n        \\n        return dfs(s)```\n```\\n>###  2. DFS+memoization\\n```\n```\\n## BFS\\n>### 1. BFS\\n\\n```\n```\\n>### 2. BFS+memoization\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306561,
                "title": "a-simple-solution-using-tries",
                "content": "As many of you know, for optimized searching of a string in a list of strings we use Tries.\\nTries take some time to build but then all the searches are much faster.\\nHere is the time for sol with and w/o tries -\\n* Without trie ( str in list )-\\n\\tO(n*k) where n is length of list and k is length of the string\\n\\t\\n* With trie ( Trie.checkWord(str) )-\\n\\tO(n*k) for building trie\\n\\tO(k) for querying\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        t = Trie()\\n        for w in wordDict:\\n            t.addWord(w)\\n        \\n        #dp[i] = True if s[:i] is word breakable\\n        #dp[i] = dp[j(<i)] and t.checkWord(s[j,i])\\n        \\n        dp=[False for i in range(len(s)+1)]\\n        dp[0]=True\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(i):\\n                \\n                if dp[j] and t.checkWord(s[j:i]):\\n                    # print(s[j:i])\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[-1]\\n \\n            \\n\\nclass TrieNode:\\n    def __init__(self, letter):\\n        self.nodes = {}\\n        self.val = letter\\n        self.term = False\\n\\n    def markTerm(self, stat):\\n        self.term = stat\\n\\n    def isTerm(self):\\n        return self.term\\n\\n    def addKid(self, kid):\\n        if kid not in self.nodes:\\n            self.nodes[kid] = TrieNode(kid)\\n        return self.nodes[kid]\\n\\n    def getKid(self, kid):\\n        return self.nodes.get(kid)\\n\\n    def hasKid(self, kid):\\n        return True if kid in self.nodes else False\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\\'Root\\')\\n\\n    def addWord(self, word):\\n        p = self.root\\n        for w in word:\\n            p = p.addKid(w)\\n        p.markTerm(True)\\n\\n    def checkWord(self, word):\\n        p = self.root\\n        for w in word:\\n            p = p.getKid(w)\\n            if p is None:\\n                return False\\n        return True if p.isTerm() else False\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        t = Trie()\\n        for w in wordDict:\\n            t.addWord(w)\\n        \\n        #dp[i] = True if s[:i] is word breakable\\n        #dp[i] = dp[j(<i)] and t.checkWord(s[j,i])\\n        \\n        dp=[False for i in range(len(s)+1)]\\n        dp[0]=True\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(i):\\n                \\n                if dp[j] and t.checkWord(s[j:i]):\\n                    # print(s[j:i])\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[-1]\\n \\n            \\n\\nclass TrieNode:\\n    def __init__(self, letter):\\n        self.nodes = {}\\n        self.val = letter\\n        self.term = False\\n\\n    def markTerm(self, stat):\\n        self.term = stat\\n\\n    def isTerm(self):\\n        return self.term\\n\\n    def addKid(self, kid):\\n        if kid not in self.nodes:\\n            self.nodes[kid] = TrieNode(kid)\\n        return self.nodes[kid]\\n\\n    def getKid(self, kid):\\n        return self.nodes.get(kid)\\n\\n    def hasKid(self, kid):\\n        return True if kid in self.nodes else False\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\\'Root\\')\\n\\n    def addWord(self, word):\\n        p = self.root\\n        for w in word:\\n            p = p.addKid(w)\\n        p.markTerm(True)\\n\\n    def checkWord(self, word):\\n        p = self.root\\n        for w in word:\\n            p = p.getKid(w)\\n            if p is None:\\n                return False\\n        return True if p.isTerm() else False\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 434582,
                "title": "java-solutions-backtracking-memoization-dp-with-detailed-exp",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/word-break/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem\\n\\n> Given a **non-empty** string `s` and a dictionary `wordDict` containing a list of **non-empty** words, determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\n**Note:** \\n\\n- The same word in the dictionary **may be reused multiple times** in the segmentation.\\n- You may assume the dictionary does not contain duplicate words.\\n\\n**Example:** \\n\\n```java\\nInput: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\\nOutput: true\\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\\n\\nInput: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\\nOutput: true\\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\\n             Note that you are allowed to reuse a dictionary word.\\n\\nInput: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\\nOutput: false\\n```\\n\\n\\n## Analysis\\n\\n\\n### Backtracking\\n\\nFirst, we put `wordSet` into a hash set for quick `contains` examination.\\n\\nFor each character `S[depth]`, we consider substrings `S[depth, i]` including `S[depth]`, `S[depth, depth + 1]`, ..., `S[depth, n - 1]`. If one of them is in `wordDict`, we then redo the task on character `S[i + 1]`; otherwise, return `false`.\\n\\nOne of the most difficult part is to write the `reject & accept` code. Think about it carefully, we notice that if the recursive call goes into a situation where `n == s.length()`, it means the string `s` can be successfully segmented; otherwise, it won\\'t go into that situation. **We don\\'t write reject case in this backtracking function.**\\n\\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  return backtracking(0, s, new HashSet<>(wordDict));\\n}\\n\\nprivate boolean backtracking(int depth, String s, Set<String> wordSet) {\\n  int n = s.length();\\n  // accept\\n  if (depth == n) {\\n    return true;\\n  }\\n  \\n  for (int i = depth; i < n; ++i) {\\n    String str = s.substring(depth, i + 1); // substring[depth, i]\\n    if (wordSet.contains(str)) {\\n      if (backtracking(i + 1, s, wordSet)) return true;\\n    }\\n  }\\n  \\n  return false;\\n}\\n```\\n\\n**Time:** `O(N^N)` since each time it has at most `N` choices and the depth (problem size) is `N`. (this is an `upper bound`)\\n**Space:** `O(N)` (string length and call stack depth)\\n\\n<span class=\"purple\">Marked</span> For the time complexity, if we count `substring` operation (`O(N)`), it would be `O(N \\\\times N^N) = O(N^(N + 1))`.\\n\\n\\n\\n### Backtracking (Memoization)\\n\\nLet\\'s use an example to see if we can optimize the above method.\\n\\n```java\\n// String: \"abcde\" | wordDict: [\"a\", ...]\\n\\ndepth = 0 (\\'a\\')\\nwe have substrings: \"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"\\n```\\n\\nFor the first substring `\"a\"`, it is in `wordDict`, so `depth` becomes 1 and we would examine if `\"bcde\"` is breakable.\\n\\nIn the process of checking if `\"bcde\"` is breakable, we may check if `\"cde\", \"de\", \"e\"` are breakable. Once we know the answers, we can cache them for future usage no matter they are true or false.\\n\\nIn future when we\\'ve done processing the first substring `\"a\"`, we will examine `\"b\"`, and you will see there could be a lot of repeated computation for `\"cde\", \"de\", \"e\"`.\\n\\n**Difficulty:** Using memoization in a backtracking-style recursive function is quite uncommon than other DP memoization. This is the new form I learned. There are three places that we need to set and get `memo[]`.\\n\\n**Note:** We use `Boolean` since initially we want values to be `null`.\\n\\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  int n = s.length();\\n  Boolean[] memo = new Boolean[n]; // memo[i] --> S[i...] is breakable or not\\n  return backtracking(0, s, new HashSet<>(wordDict), memo);\\n}\\n\\nprivate boolean backtracking(int depth, String s, Set<String> wordSet, Boolean[] memo) {\\n  int n = s.length();\\n  // accept\\n  if (depth == n) {\\n    return true;\\n  }\\n  // memoization\\n  if (memo[depth] != null) { // memo\\n    return memo[depth];\\n  }\\n  \\n  for (int i = depth; i < n; ++i) {\\n    String str = s.substring(depth, i + 1); // substring[depth, i]\\n    if (wordSet.contains(str)) {\\n      if (backtracking(i + 1, s, wordSet, memo)) {\\n        memo[depth] = true; // memo\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  memo[depth] = false; // memo\\n  return false;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(N)`\\n\\n\\n\\n\\n### DP\\n\\nThe idea is that given a problem(s) we can divide it into two subproblems `s1` and `s2`. If both of them are **breakable**, `s` is breakable (by saying breakable I mean it satisfies the required conditions).\\n\\n**Note:** Substring `s(i, j)` (character `i` to `j`) in Java is denoted by `s.substring(i, j + 1)`.\\n\\nFirst, we define our `dp[]` array, where `dp[i]` is `true` if the substring `s(0, i - 1)` or `s.substring(0, i)` is breakable; otherwise, it should be `false`.\\n\\nThen, we process string length from `1` to `n` in `dp[i]`. For each substring `s(0, i - 1)`, we examine each combination of substrings `s(0, j - 1)` (`s.substring(0, j)`) and `s(j, i - 1)` (`s.substring(j, i)`). The first subproblem can be calculated directly by `dp[j]` while the second one can be checked by `wordDict` set. **Question:** Why don\\'t we break the second substring and examine it further? (e.g. `abc` is not in `wordDict`, but `ab` and `c` could be in `wordDict`)\\n\\n```java\\n// String: a b c d e f\\nIn the final round, we are looking into the whole string. We would examine the follow pair of two substrings:\\na     bcdef\\nab    cdef\\nabc   def\\nabcd  ef\\nabcde f\\n```\\n**The question is:** what happen if `\"cdef\"` is not in wordDict while `\"cd\"` and `\"ef\"` are both in `wordDict`?\\n\\nIt is handled previously! If `\"cd\"` is in `wordDict`, in the previously fourth round for substring `\"abcd\"`, we would examine `\"ab\"` and `\"cd\"`. If `dp(\"ab\")` is true and `\"cd\"` is in `wordDict`, we would mark `dp(\"abcd\")` as true!\\n\\nThen in the final round, `dp(\"abcd\")` is true and `\"ef\"` is in `wordDict`, so we have the whole string breakable.\\n\\n**Note:** In addition, please think about the `initialization step` and the `break statement` in the code.\\n\\n\\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  int n = s.length();\\n  Set<String> set = new HashSet<>(wordDict);\\n  \\n  boolean[] dp = new boolean[n + 1];\\n  dp[0] = true; // consider the begining! (\"\" + \"a\")\\n  \\n  for (int i = 1; i <= n; ++i) { // for each length\\n    for (int j = 0; j < i; ++j) {\\n      // s1 = substring(0, j) = dp[j]\\n      // s2 = substring(j, i) = s[j, i - 1]\\n      if (dp[j] && set.contains(s.substring(j, i))) {\\n        dp[i] = true;\\n        break;\\n      }\\n    }\\n  }\\n  \\n  return dp[n];\\n}\\n```\\n\\n**Time:** `O(N^3)` since `substring` takes `O(N)`.\\n**Space:** `O(N)`\\n\\n\\n\\n### BFS\\n\\nGo To: [LeetCode Solution](https://leetcode.com/problems/word-break/solution/)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java\\nInput: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\\nOutput: true\\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\\n\\nInput: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\\nOutput: true\\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\\n             Note that you are allowed to reuse a dictionary word.\\n\\nInput: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\\nOutput: false\\n```\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  return backtracking(0, s, new HashSet<>(wordDict));\\n}\\n\\nprivate boolean backtracking(int depth, String s, Set<String> wordSet) {\\n  int n = s.length();\\n  // accept\\n  if (depth == n) {\\n    return true;\\n  }\\n  \\n  for (int i = depth; i < n; ++i) {\\n    String str = s.substring(depth, i + 1); // substring[depth, i]\\n    if (wordSet.contains(str)) {\\n      if (backtracking(i + 1, s, wordSet)) return true;\\n    }\\n  }\\n  \\n  return false;\\n}\\n```\n```java\\n// String: \"abcde\" | wordDict: [\"a\", ...]\\n\\ndepth = 0 (\\'a\\')\\nwe have substrings: \"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"\\n```\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  int n = s.length();\\n  Boolean[] memo = new Boolean[n]; // memo[i] --> S[i...] is breakable or not\\n  return backtracking(0, s, new HashSet<>(wordDict), memo);\\n}\\n\\nprivate boolean backtracking(int depth, String s, Set<String> wordSet, Boolean[] memo) {\\n  int n = s.length();\\n  // accept\\n  if (depth == n) {\\n    return true;\\n  }\\n  // memoization\\n  if (memo[depth] != null) { // memo\\n    return memo[depth];\\n  }\\n  \\n  for (int i = depth; i < n; ++i) {\\n    String str = s.substring(depth, i + 1); // substring[depth, i]\\n    if (wordSet.contains(str)) {\\n      if (backtracking(i + 1, s, wordSet, memo)) {\\n        memo[depth] = true; // memo\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  memo[depth] = false; // memo\\n  return false;\\n}\\n```\n```java\\n// String: a b c d e f\\nIn the final round, we are looking into the whole string. We would examine the follow pair of two substrings:\\na     bcdef\\nab    cdef\\nabc   def\\nabcd  ef\\nabcde f\\n```\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  int n = s.length();\\n  Set<String> set = new HashSet<>(wordDict);\\n  \\n  boolean[] dp = new boolean[n + 1];\\n  dp[0] = true; // consider the begining! (\"\" + \"a\")\\n  \\n  for (int i = 1; i <= n; ++i) { // for each length\\n    for (int j = 0; j < i; ++j) {\\n      // s1 = substring(0, j) = dp[j]\\n      // s2 = substring(j, i) = s[j, i - 1]\\n      if (dp[j] && set.contains(s.substring(j, i))) {\\n        dp[i] = true;\\n        break;\\n      }\\n    }\\n  }\\n  \\n  return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44059,
                "title": "easy-to-understand-c-solution",
                "content": "Using a vector to record if it is possible to have a combination of dictionary of words at point i.\\n\\n    class Solution {\\n    public:\\n        bool wordBreak(string s, unordered_set<string>& wordDict) {\\n            s = \"!\" + s;\\n            vector<bool> dpArray(s.size());\\n            dpArray[0] = true;\\n            for(int i=0; i<s.size(); i++){\\n                for(int j=i+1; j<s.size(); j++) {\\n                    if(dpArray[j]) continue;\\n                    if(wordDict.find(s.substr(i+1, j-i))!=wordDict.end() && dpArray[i])\\n                        dpArray[j] = true;\\n                }\\n            }\\n            return dpArray[dpArray.size()-1];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool wordBreak(string s, unordered_set<string>& wordDict) {\\n            s = \"!\" + s;\\n            vector<bool> dpArray(s.size());\\n            dpArray[0] = true;\\n            for(int i=0; i<s.size(); i++){\\n                for(int j=i+1; j<s.size(); j++) {\\n                    if(dpArray[j]) continue;\\n                    if(wordDict.find(s.substr(i+1, j-i))!=wordDict.end() && dpArray[i])\\n                        dpArray[j] = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44103,
                "title": "a-java-solution-with-similar-dp-idea",
                "content": "The idea is pretty similar to other DP solution. \\n1)keep all positions which could form substring contained in the set in a linkedlist\\n2) Iterate the target string, check  substring between current position and stored positions. If new sub string hits the dictionary,add it the front of linkedlist\\n3)After iteration, check if the front element of linkedlist equals to the length of string.\\n\\nIt consumes 296ms\\n\\nThis solution is still a time O(n^2) and space O(n) one. It is better if dictionary contains long words. \\n\\n  \\n\\n    public class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            if (s==null||s.length()==0) return false;\\n            else if (dict.contains(s)) return true;\\n            \\n            List<Integer> starts = new LinkedList<Integer>();\\n            starts.add(0);\\n           \\n            for (int end=1;end<=s.length();end++){\\n            \\tboolean found=false;\\n                for (Integer start:starts)\\n                    if (dict.contains(s.substring(start,end))){\\n                    \\tfound=true;\\n                    \\tbreak;\\n                    }\\n                if(found)  starts.add(0,end);\\n            }\\n    \\n            return (starts.get(0)==s.length());\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            if (s==null||s.length()==0) return false;\\n            else if (dict.contains(s)) return true;\\n            \\n            List<Integer> starts = new LinkedList<Integer>();\\n            starts.add(0);\\n           \\n            for (int end=1;end<=s.length();end++){\\n            \\tboolean found=false;\\n                for (Integer start:starts)\\n                    if (dict.contains(s.substring(start,end))){\\n                    \\tfound=true;\\n                    \\tbreak;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3860527,
                "title": "100-dynamic-programming",
                "content": "# Intuition\\nThe Word Break problem requires us to determine if a given string can be segmented into a sequence of dictionary words. This can be visualized as finding a path through a sequence of characters where each step corresponds to a valid word in the dictionary. Special thanks to vanAmsen for their invaluable insights and contributions to this problem [139 - Word Break](https://youtu.be/9ZIQwa1wCNA) The problem can be solved efficiently using Dynamic Programming.\\n\\n# Approach - Dynamic Programming\\nThe Dynamic Programming approach involves breaking down the problem into smaller subproblems and solving them iteratively. We initialize a boolean array `dp`, where `dp[i]` represents whether the substring up to the `i`-th character can be segmented into dictionary words. By considering the maximum word length, we reduce unnecessary iterations, making the solution more efficient.\\n\\n1. **Initialization**: Set `dp[0]` to `true` and the rest to `false`.\\n2. **Iteration**: Iterate through the string from left to right, and for each position `i`, check the substrings ending at `i` to see if they are in the dictionary.\\n3. **Memoization**: If a valid segmentation is found, update `dp[i]` to `true`.\\n4. **Result**: The final result is stored in `dp[n]`, where `n` is the length of the string.\\n\\n# Complexity\\n- **Time complexity**: \\\\(O(n * m)\\\\), where \\\\(n\\\\) is the length of the string and \\\\(m\\\\) is the maximum length of a word in the dictionary. We iterate through the string and for each position, we may consider up to \\\\(m\\\\) characters.\\n- **Space complexity**: \\\\(O(n + k)\\\\), where \\\\(n\\\\) is the length of the string and \\\\(k\\\\) is the size of the dictionary. The space is used for the `dp` array and storing the dictionary as a HashSet.\\n\\n# Code\\n``` Rust []\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let n = s.len();\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n        let max_len = word_dict.iter().map(|word| word.len()).max().unwrap_or(0);\\n\\n        let word_dict: std::collections::HashSet<String> = word_dict.into_iter().collect();\\n\\n        for i in 1..=n {\\n            for j in (std::cmp::max(i as isize - max_len as isize - 1, 0) as usize..i).rev() {\\n                if dp[j] && word_dict.contains(&s[j..i].to_string()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        dp[n]\\n    }\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        max_len = max(map(len, wordDict)) \\n        for i in range(1, n + 1):\\n            for j in range(i - 1, max(i - max_len - 1, -1), -1): \\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    n := len(s)\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n    max_len := 0\\n    for _, word := range wordDict {\\n        if len(word) > max_len {\\n            max_len = len(word)\\n        }\\n    }\\n    for i := 1; i <= n; i++ {\\n        for j := i - 1; j >= max(i - max_len - 1, 0); j-- {\\n            if dp[j] && contains(wordDict, s[j:i]) {\\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n\\n    return dp[n]\\n}\\nfunc contains(words []string, target string) bool {\\n    for _, word := range words {\\n        if word == target {\\n            return true\\n        }\\n    }\\n    return false\\n}\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n\\nThis code offers a concise and efficient solution to the Word Break problem by leveraging the power of Dynamic Programming, carefully considering the constraints, and using Rust\\'s standard library to handle the dictionary.",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "``` Rust []\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let n = s.len();\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n        let max_len = word_dict.iter().map(|word| word.len()).max().unwrap_or(0);\\n\\n        let word_dict: std::collections::HashSet<String> = word_dict.into_iter().collect();\\n\\n        for i in 1..=n {\\n            for j in (std::cmp::max(i as isize - max_len as isize - 1, 0) as usize..i).rev() {\\n                if dp[j] && word_dict.contains(&s[j..i].to_string()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        dp[n]\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        max_len = max(map(len, wordDict)) \\n        for i in range(1, n + 1):\\n            for j in range(i - 1, max(i - max_len - 1, -1), -1): \\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    n := len(s)\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n    max_len := 0\\n    for _, word := range wordDict {\\n        if len(word) > max_len {\\n            max_len = len(word)\\n        }\\n    }\\n    for i := 1; i <= n; i++ {\\n        for j := i - 1; j >= max(i - max_len - 1, 0); j-- {\\n            if dp[j] && contains(wordDict, s[j:i]) {\\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n\\n    return dp[n]\\n}\\nfunc contains(words []string, target string) bool {\\n    for _, word := range words {\\n        if word == target {\\n            return true\\n        }\\n    }\\n    return false\\n}\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714428,
                "title": "c-dp-faster-easy-to-understand",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n\\n    int dp[305];\\n\\n    unordered_set<string> s;\\n\\n    bool helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return true;\\n        }\\n        \\n        // if already calculated\\n\\n        if(dp[i] != -1)\\n        {\\n            return dp[i];\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for remaining part \\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                if(helper(str, j + 1, n))\\n                {\\n                    return dp[i] = true;\\n                }\\n            }\\n        }\\n        \\n        // store the res and return\\n\\n        return dp[i] = false;\\n    }\\n    \\n    bool wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n        \\n        // declare dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(str, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n\\n    int dp[305];\\n\\n    unordered_set<string> s;\\n\\n    bool helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return true;\\n        }\\n        \\n        // if already calculated\\n\\n        if(dp[i] != -1)\\n        {\\n            return dp[i];\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for remaining part \\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                if(helper(str, j + 1, n))\\n                {\\n                    return dp[i] = true;\\n                }\\n            }\\n        }\\n        \\n        // store the res and return\\n\\n        return dp[i] = false;\\n    }\\n    \\n    bool wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n        \\n        // declare dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(str, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089632,
                "title": "c-dp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& w) {\\n      int n=s.length();\\n      unordered_set<string>m(w.begin(),w.end());\\n      int dp[n+1];\\n      memset(dp,0,sizeof dp);\\n      dp[n]=1;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n        string t=\"\";\\n        for(int j=i;j<n;j++)\\n        {\\n          t+=s[j];\\n          if(m.find(t)!=m.end())\\n            if(dp[j+1]==1)\\n              dp[i]=1;\\n        }\\n      }\\n        return dp[0];\\n    }\\n};\\n```\\n**Upvote Pls**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& w) {\\n      int n=s.length();\\n      unordered_set<string>m(w.begin(),w.end());\\n      int dp[n+1];\\n      memset(dp,0,sizeof dp);\\n      dp[n]=1;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n        string t=\"\";\\n        for(int j=i;j<n;j++)\\n        {\\n          t+=s[j];\\n          if(m.find(t)!=m.end())\\n            if(dp[j+1]==1)\\n              dp[i]=1;\\n        }\\n      }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413187,
                "title": "java-two-solutions-dfs-memoization-dp-detailed-explanation",
                "content": "```\\nclass Solution {\\n    // get the max length of string in dict\\n    int maxLen = 0;\\n    // Recursion with memoization, time O(n^2), space O(n)\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for (String str : wordDict) {\\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        Set<String> set = new HashSet(wordDict);\\n        return helper(s, set, 0, new Boolean[s.length()]);\\n    }\\n    \\n    public boolean helper(String s, Set<String> wordDict, int start, Boolean[] memo) {\\n        if (start == s.length()) {\\n            return true;\\n        }\\n        if (memo[start] != null) {\\n            return memo[start];\\n        }\\n        /* \\u6CE8\\u610F\\u5230recursion\\u7684\\u8BB0\\u5FC6\\u5316\\u641C\\u7D22\\u662F\\u6709\\u540E\\u6548\\u6027\\u7684\\uFF0Cmemo[]\\u7684\\u6539\\u53D8\\u662F\\u4ECE\\u540E\\u5F80\\u524D\\u8FDB\\u884C\\u7684\\n        \\u6BCF\\u6B21\\u5C1D\\u8BD5\\u4ECE\\u6700\\u77ED\\u7684\\u5728\\u5B57\\u5178\\u91CC\\u7684\\u5B57\\u7B26\\u4E32\\u5F00\\u59CB\\uFF0C\\u7136\\u540E\\u7EE7\\u7EED\\u641C\\u7D22\\u5269\\u4E0B\\u7684\\u5B50\\u4E32\\uFF0C\\u5982\\u679C\\u67D0\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u5F80\\u540E\\n        \\u662F\\u4E0D\\u53EF\\u80FD\\u7684\\uFF08for\\u5FAA\\u73AF\\u5B8C\\u5168\\u7ED3\\u675F\\uFF09\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u7684memo[i]\\u5C31\\u53D8\\u6210false.\\u4E0B\\u6B21\\u518D\\u641C\\u7D22\\u5230\\n        \\u8FD9\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u5C31\\u76F4\\u63A5\\u8FD4\\u56DEfalse\\u4E86\\u3002\\n        \\n        e.g. s = \"catsandogxxx\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\",\"xxx\"]\\n        \\u4E00\\u5F00\\u59CB\\u4F9D\\u6B21\\u641C\\u7D22\\u5230cat, sand\\uFF0C\\u7136\\u540E\\u53D1\\u73B0og\\u662F\\u4E0D\\u53EF\\u80FD\\u7684\\uFF0C\\u90A3\\u4E48o\\u4F4D\\u7F6E\\u7684memo\\u5C31\\u8BBE\\u4E3Afalse\\uFF0C\\u63A5\\u4E0B\\u6765sand\\n        \\u4E00\\u76F4\\u641C\\u5230sandogxxx\\uFF0C\\u90FD\\u6CA1\\u6709\\u5339\\u914D\\uFF0C\\u90A3\\u4E48s\\u4F4D\\u7F6E\\u7684memo\\u5C31\\u8BBE\\u4E3Afalse\\u3002\\u4E4B\\u540E\\u641C\\u7D22\\u5230cats, and\\uFF0C\\u6CE8\\u610F\\u5230\\n        \\u8FD9\\u91CC\\u63A5\\u4E0B\\u6765start\\u53D8\\u4E3Ao\\u7684\\u4F4D\\u7F6E\\uFF0C\\u8FD9\\u65F6\\u5019\\u4E0D\\u4F1A\\u518D\\u6B21\\u641C\\u7D22\\uFF0C\\u800C\\u662F\\u76F4\\u63A5\\u8FD4\\u56DE\\u8BB0\\u5FC6\\u4E2D\\u7684false!\\u56E0\\u4E3A\\u5B83\\u77E5\\u9053\\u4E86o\\u4E4B\\u540E\\n        \\u662F\\u6CA1\\u6709\\u6210\\u529F\\u7684\\u8DEF\\u7684\\u3002\\n        \\n        \\u6211\\u4EEC\\u8FD8\\u53EF\\u4EE5\\u518D\\u63D0\\u5347\\u641C\\u7D22\\u7684\\u6548\\u7387\\uFF0C\\u901A\\u8FC7\\u9650\\u5236\\u6BCF\\u6B21\\u641C\\u7D22\\u7684\\u957F\\u5EA6\\uFF0C\\u6BD4\\u5982\\u6211\\u4EEC\\u4E0D\\u9700\\u8981\\u4ECEsand\\u4E00\\u76F4\\u641C\\u5230sandogxxx\\uFF0C\\n        \\u6211\\u4EEC\\u901A\\u8FC7\\u5148\\u7B97\\u51FA\\u5B57\\u5178\\u91CC\\u6700\\u957F\\u5B57\\u7B26\\u4E32\\u7684\\u957F\\u5EA6\\uFF0C\\u7136\\u540E\\u6BCF\\u6B21\\u641C\\u7D22\\u90FD\\u9650\\u5236\\u5728\\u8FD9\\u4E2A\\u957F\\u5EA6\\u4EE5\\u5185\\u3002\\u5BF9\\u4E8E\\u5F88\\u957F\\u7684s\\uFF0C\\u8FD9\\u6837\\n        \\u80FD\\u63D0\\u9AD8\\u5F88\\u5927\\u7684\\u6548\\u7387\\u3002*/\\n        for (int end = start + 1; end <= s.length() && end - start <= maxLen; end++) {\\n            // \\u5B57\\u5178\\u5305\\u542B\\u5F53\\u524D\\u5B50\\u4E32(start, end)\\uFF0C\\u5982\\u679Cend\\u4E4B\\u540E\\u7684\\u5B50\\u4E32\\u8FD4\\u56DEtrue\\uFF0C\\u8BF4\\u660E\\n            if (wordDict.contains(s.substring(start, end)) && \\n                helper(s, wordDict, end, memo)) {\\n                return memo[start] = true;\\n            }\\n        }\\n        return memo[start] = false;\\n    }\\n    \\n    // DP solution, time O(n^2), space O(n)\\n    public boolean wordBreak1(String s, List<String> wordDict) {\\n        // get the max length of string in dict\\n        int maxLen = 0;\\n        for (String str : wordDict) {\\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        \\n        /* \\n        for current substring from 0 -> i, use j to iterate over 0 -> maxLen, \\n        and check whether:\\n        1. substring(i - j, i + 1) is in dict\\n        2. isBreak[i - j] == true\\n        */\\n        \\n        boolean[] isBreak = new boolean[s.length() + 1];\\n        isBreak[0] = true;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < maxLen && j <= i; j++) {\\n                String sub = s.substring(i - j, i + 1);\\n                if (wordDict.contains(sub) && isBreak[i - j]) {\\n                    isBreak[i + 1] = true;\\n                }\\n            }\\n        }\\n        return isBreak[s.length()];\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // get the max length of string in dict\\n    int maxLen = 0;\\n    // Recursion with memoization, time O(n^2), space O(n)\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for (String str : wordDict) {\\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        Set<String> set = new HashSet(wordDict);\\n        return helper(s, set, 0, new Boolean[s.length()]);\\n    }\\n    \\n    public boolean helper(String s, Set<String> wordDict, int start, Boolean[] memo) {\\n        if (start == s.length()) {\\n            return true;\\n        }\\n        if (memo[start] != null) {\\n            return memo[start];\\n        }\\n        /* \\u6CE8\\u610F\\u5230recursion\\u7684\\u8BB0\\u5FC6\\u5316\\u641C\\u7D22\\u662F\\u6709\\u540E\\u6548\\u6027\\u7684\\uFF0Cmemo[]\\u7684\\u6539\\u53D8\\u662F\\u4ECE\\u540E\\u5F80\\u524D\\u8FDB\\u884C\\u7684\\n        \\u6BCF\\u6B21\\u5C1D\\u8BD5\\u4ECE\\u6700\\u77ED\\u7684\\u5728\\u5B57\\u5178\\u91CC\\u7684\\u5B57\\u7B26\\u4E32\\u5F00\\u59CB\\uFF0C\\u7136\\u540E\\u7EE7\\u7EED\\u641C\\u7D22\\u5269\\u4E0B\\u7684\\u5B50\\u4E32\\uFF0C\\u5982\\u679C\\u67D0\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u5F80\\u540E\\n        \\u662F\\u4E0D\\u53EF\\u80FD\\u7684\\uFF08for\\u5FAA\\u73AF\\u5B8C\\u5168\\u7ED3\\u675F\\uFF09\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u7684memo[i]\\u5C31\\u53D8\\u6210false.\\u4E0B\\u6B21\\u518D\\u641C\\u7D22\\u5230\\n        \\u8FD9\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u5C31\\u76F4\\u63A5\\u8FD4\\u56DEfalse\\u4E86\\u3002\\n        \\n        e.g. s = \"catsandogxxx\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\",\"xxx\"]\\n        \\u4E00\\u5F00\\u59CB\\u4F9D\\u6B21\\u641C\\u7D22\\u5230cat, sand\\uFF0C\\u7136\\u540E\\u53D1\\u73B0og\\u662F\\u4E0D\\u53EF\\u80FD\\u7684\\uFF0C\\u90A3\\u4E48o\\u4F4D\\u7F6E\\u7684memo\\u5C31\\u8BBE\\u4E3Afalse\\uFF0C\\u63A5\\u4E0B\\u6765sand\\n        \\u4E00\\u76F4\\u641C\\u5230sandogxxx\\uFF0C\\u90FD\\u6CA1\\u6709\\u5339\\u914D\\uFF0C\\u90A3\\u4E48s\\u4F4D\\u7F6E\\u7684memo\\u5C31\\u8BBE\\u4E3Afalse\\u3002\\u4E4B\\u540E\\u641C\\u7D22\\u5230cats, and\\uFF0C\\u6CE8\\u610F\\u5230\\n        \\u8FD9\\u91CC\\u63A5\\u4E0B\\u6765start\\u53D8\\u4E3Ao\\u7684\\u4F4D\\u7F6E\\uFF0C\\u8FD9\\u65F6\\u5019\\u4E0D\\u4F1A\\u518D\\u6B21\\u641C\\u7D22\\uFF0C\\u800C\\u662F\\u76F4\\u63A5\\u8FD4\\u56DE\\u8BB0\\u5FC6\\u4E2D\\u7684false!\\u56E0\\u4E3A\\u5B83\\u77E5\\u9053\\u4E86o\\u4E4B\\u540E\\n        \\u662F\\u6CA1\\u6709\\u6210\\u529F\\u7684\\u8DEF\\u7684\\u3002\\n        \\n        \\u6211\\u4EEC\\u8FD8\\u53EF\\u4EE5\\u518D\\u63D0\\u5347\\u641C\\u7D22\\u7684\\u6548\\u7387\\uFF0C\\u901A\\u8FC7\\u9650\\u5236\\u6BCF\\u6B21\\u641C\\u7D22\\u7684\\u957F\\u5EA6\\uFF0C\\u6BD4\\u5982\\u6211\\u4EEC\\u4E0D\\u9700\\u8981\\u4ECEsand\\u4E00\\u76F4\\u641C\\u5230sandogxxx\\uFF0C\\n        \\u6211\\u4EEC\\u901A\\u8FC7\\u5148\\u7B97\\u51FA\\u5B57\\u5178\\u91CC\\u6700\\u957F\\u5B57\\u7B26\\u4E32\\u7684\\u957F\\u5EA6\\uFF0C\\u7136\\u540E\\u6BCF\\u6B21\\u641C\\u7D22\\u90FD\\u9650\\u5236\\u5728\\u8FD9\\u4E2A\\u957F\\u5EA6\\u4EE5\\u5185\\u3002\\u5BF9\\u4E8E\\u5F88\\u957F\\u7684s\\uFF0C\\u8FD9\\u6837\\n        \\u80FD\\u63D0\\u9AD8\\u5F88\\u5927\\u7684\\u6548\\u7387\\u3002*/\\n        for (int end = start + 1; end <= s.length() && end - start <= maxLen; end++) {\\n            // \\u5B57\\u5178\\u5305\\u542B\\u5F53\\u524D\\u5B50\\u4E32(start, end)\\uFF0C\\u5982\\u679Cend\\u4E4B\\u540E\\u7684\\u5B50\\u4E32\\u8FD4\\u56DEtrue\\uFF0C\\u8BF4\\u660E\\n            if (wordDict.contains(s.substring(start, end)) && \\n                helper(s, wordDict, end, memo)) {\\n                return memo[start] = true;\\n            }\\n        }\\n        return memo[start] = false;\\n    }\\n    \\n    // DP solution, time O(n^2), space O(n)\\n    public boolean wordBreak1(String s, List<String> wordDict) {\\n        // get the max length of string in dict\\n        int maxLen = 0;\\n        for (String str : wordDict) {\\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        \\n        /* \\n        for current substring from 0 -> i, use j to iterate over 0 -> maxLen, \\n        and check whether:\\n        1. substring(i - j, i + 1) is in dict\\n        2. isBreak[i - j] == true\\n        */\\n        \\n        boolean[] isBreak = new boolean[s.length() + 1];\\n        isBreak[0] = true;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < maxLen && j <= i; j++) {\\n                String sub = s.substring(i - j, i + 1);\\n                if (wordDict.contains(sub) && isBreak[i - j]) {\\n                    isBreak[i + 1] = true;\\n                }\\n            }\\n        }\\n        return isBreak[s.length()];\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534354,
                "title": "c-easy-top-down-approach",
                "content": "```\\nclass Solution {\\n    int dp[301];\\n    //top-down approach\\n    int helper(int i, string s, set<string>&st)\\n    {\\n        if(i==s.size())\\n            return 1;\\n        string temp;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        for(int j=i;j<s.size();j++)\\n        {\\n            temp+=s[j];\\n            if(st.find(temp)!=st.end())\\n            {\\n                if(helper(j+1,s,st))\\n                    return dp[i]=1;\\n            }\\n        }\\n        return dp[i]=0;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        memset(dp,-1,sizeof(dp));\\n        for(auto a:wordDict)\\n        {\\n            st.insert(a);\\n        }\\n        return helper(0,s,st);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[301];\\n    //top-down approach\\n    int helper(int i, string s, set<string>&st)\\n    {\\n        if(i==s.size())\\n            return 1;\\n        string temp;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        for(int j=i;j<s.size();j++)\\n        {\\n            temp+=s[j];\\n            if(st.find(temp)!=st.end())\\n            {\\n                if(helper(j+1,s,st))\\n                    return dp[i]=1;\\n            }\\n        }\\n        return dp[i]=0;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        memset(dp,-1,sizeof(dp));\\n        for(auto a:wordDict)\\n        {\\n            st.insert(a);\\n        }\\n        return helper(0,s,st);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500768,
                "title": "python-dp-memoization",
                "content": "```\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str],):\\n        \\n        \\n        memo = {}\\n        \\n        def memoize(target, wordDict):\\n            if target == \"\":\\n                return True\\n            if target in memo:\\n                return memo[target]\\n            \\n            for word in wordDict:\\n                if target[:len(word)] == word and memoize(target[len(word):], wordDict):\\n                    memo[target] = True\\n                    return memo[target]\\n            memo[target] = False\\n            return memo[target]\\n        \\n        return memoize(s, wordDict)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str],):\\n        \\n        \\n        memo = {}\\n        \\n        def memoize(target, wordDict):\\n            if target == \"\":\\n                return True\\n            if target in memo:\\n                return memo[target]\\n            \\n            for word in wordDict:\\n                if target[:len(word)] == word and memoize(target[len(word):], wordDict):\\n                    memo[target] = True\\n                    return memo[target]\\n            memo[target] = False\\n            return memo[target]\\n        \\n        return memoize(s, wordDict)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1215873,
                "title": "word-break-cpp-solution-recursive-memoization",
                "content": "\\nThe idea is to check every possible prefix of that string in the dictionary of words, if it is found in the dictionary, then the recursive function is called for the remaining portion of that string. And, if in some function call, it is found that the complete string is in dictionary, then it will return true.\\n\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(2^N), Space: O(N)\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(), wordDict.end(), s) != wordDict.end())\\n            return true;\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            string prefix = s.substr(0, i);\\n            \\n            //finding the prefix in the wordDict\\n            auto it = find(wordDict.begin(), wordDict.end(), prefix) != wordDict.end();\\n            \\n            //check for the remaining portion of string\\n            if(it && wordBreak(s.substr(i), wordDict))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Memoization**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(N^3), Space: O(N)\\n    unordered_map<string, bool> memo;\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(), wordDict.end(), s) != wordDict.end())\\n            return true;\\n        \\n        //check before doing any further calculation\\n        if(memo.find(s) != memo.end()) return memo[s];\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            string prefix = s.substr(0, i);\\n            \\n            //finding the prefix in the wordDict\\n            auto it = find(wordDict.begin(), wordDict.end(), prefix) != wordDict.end();\\n            \\n            //check for the remaining portion of string\\n            if(it && wordBreak(s.substr(i), wordDict)){\\n                return memo[s] = true;   \\n            }\\n        }\\n        return memo[s] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(2^N), Space: O(N)\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(), wordDict.end(), s) != wordDict.end())\\n            return true;\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            string prefix = s.substr(0, i);\\n            \\n            //finding the prefix in the wordDict\\n            auto it = find(wordDict.begin(), wordDict.end(), prefix) != wordDict.end();\\n            \\n            //check for the remaining portion of string\\n            if(it && wordBreak(s.substr(i), wordDict))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(N^3), Space: O(N)\\n    unordered_map<string, bool> memo;\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(), wordDict.end(), s) != wordDict.end())\\n            return true;\\n        \\n        //check before doing any further calculation\\n        if(memo.find(s) != memo.end()) return memo[s];\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            string prefix = s.substr(0, i);\\n            \\n            //finding the prefix in the wordDict\\n            auto it = find(wordDict.begin(), wordDict.end(), prefix) != wordDict.end();\\n            \\n            //check for the remaining portion of string\\n            if(it && wordBreak(s.substr(i), wordDict)){\\n                return memo[s] = true;   \\n            }\\n        }\\n        return memo[s] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113876,
                "title": "efficient-trie-solution-with-explanation-o-len-s-length-of-longest-word",
                "content": "This implementation is based on @abhijith97 \\'s comment in the solution page discussion.  With this idea, we essentially go through the dp idea from solution #4 (in reverse), but match words to strings in s more efficiently.  In the official dp solution, we loop through each end point in s for substrings, then loop through each start point to the left or equal to the end point.  Then, we slice the substring of s from the start point to the end point: if the substring matches a word in wordDict, and the end of the previous word in s was also a match in the dp array, then we set the current word is a successful match in the dp array.  That process is O(n^3), because we loop through each pair of start/end points in O(n^2), and for each start/end point pair we substring s in O(n).\\n\\nWith the implementation here, we do the following: we begin by constructing a normal trie from the words in wordDict.  Then, we loop through the start points from the end to the beginning of the array (this is done so indices in s match indices in dp out of convenience, versus having the base case for the dp at the start of the dp array and shifting all the dp indices by 1, like in solution #4).  Starting at each start point in s, we then loop through characters in s while they allow us to step further into the trie.  At each character match, if that character marks the end of a word in the trie, AND the start of the following word is a successful dp match (similar idea to solution #4), then we mark the start of the current word as a successful match, and move to the next starting point.\\n\\nSo, for each starting point, we do a simple loop up to the maximum length of a word in the trie (rather than also looping through each corresponding endpoint and getting the substring).  Letting n be the length of string s, and k be the maximum length of a word in wordDict, the time complexity is O(nk).  The space complexity is the size of the wordDict, as we populate a trie using each word in wordDict.\\n\\nMy implementation differs from @abhijith97 \\'s comment in that I\\'ve adjusted the idea to go from the end to the beginning of s; this lets us construct the trie as normal (because we then loop through starting points of words, rather than ending points), and also lets the dp indicies match indicies in s which removes another headache.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        # construct a regular trie from all the words\\n        trie = {}\\n        \\n        for w in wordDict:\\n            root = trie\\n            \\n            for c in w:\\n                root = root.setdefault(c, {})\\n                \\n            root[None] = None # use None *key* as end of word marker\\n        \\n        # set up base case with dp, from end to beginning of word;\\n        # for a word to match a part of s, we require that the start\\n        # of the next word was a successful True match in dp.\\n        # so, we start with an additional True value at end of dp,\\n        # so when we begin by matching a word to the end of s,\\n        # the \"next word after\" is True as a base case\\n        dp = [False]*len(s) + [True]\\n        \\n        # do dp in reverse\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] in trie:\\n                # we can start matching our trie with char at position i\\n                root = trie\\n                j = i # j is a separate iterator for the word match\\n                \\n                # loop through characters in s while they\\n                # are also present in the trie\\n                while j < len(s) and s[j] in root:\\n                    root = root[s[j]]\\n                    \\n                    # if at any point we jump to a matching character,\\n                    # and that character marks the end of the word (None in root),\\n                    # and the following character in dp marks the start of\\n                    # a successful word (dp[j+1] == True), then we can mark the\\n                    # start of the current word at position i as True and be done;\\n                    # we just need to set this word at i once, so we don\\'t\\n                    # need to continue looping\\n                    if None in root and dp[j+1]:\\n                        dp[i] = 1\\n                        break\\n                    \\n                    j += 1\\n        \\n        # returns if we can match words from end to beginning of s\\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        # construct a regular trie from all the words\\n        trie = {}\\n        \\n        for w in wordDict:\\n            root = trie\\n            \\n            for c in w:\\n                root = root.setdefault(c, {})\\n                \\n            root[None] = None # use None *key* as end of word marker\\n        \\n        # set up base case with dp, from end to beginning of word;\\n        # for a word to match a part of s, we require that the start\\n        # of the next word was a successful True match in dp.\\n        # so, we start with an additional True value at end of dp,\\n        # so when we begin by matching a word to the end of s,\\n        # the \"next word after\" is True as a base case\\n        dp = [False]*len(s) + [True]\\n        \\n        # do dp in reverse\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] in trie:\\n                # we can start matching our trie with char at position i\\n                root = trie\\n                j = i # j is a separate iterator for the word match\\n                \\n                # loop through characters in s while they\\n                # are also present in the trie\\n                while j < len(s) and s[j] in root:\\n                    root = root[s[j]]\\n                    \\n                    # if at any point we jump to a matching character,\\n                    # and that character marks the end of the word (None in root),\\n                    # and the following character in dp marks the start of\\n                    # a successful word (dp[j+1] == True), then we can mark the\\n                    # start of the current word at position i as True and be done;\\n                    # we just need to set this word at i once, so we don\\'t\\n                    # need to continue looping\\n                    if None in root and dp[j+1]:\\n                        dp[i] = 1\\n                        break\\n                    \\n                    j += 1\\n        \\n        # returns if we can match words from end to beginning of s\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023786,
                "title": "trie-dfs-solution",
                "content": "I kind of jumped at the opportunity to use a trie here. It seems that the solutions here based off of using substrings are much simpler to read, yet may be slower if the dictionary has a large amount of strings with common prefixes. I am unsure of the time complexity here.\\n\\n```\\nclass Solution {\\n    class TrieNode{\\n        Character c;\\n        boolean isWord;\\n        HashMap<Character, TrieNode> children = new HashMap();\\n        \\n        TrieNode(){\\n            \\n        }\\n        \\n        TrieNode(Character c, boolean isWord){\\n            this.c = c;\\n            this.isWord = isWord;\\n        }\\n   }\\n    \\n    TrieNode trie = new TrieNode();\\n    boolean[] visited;\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        buildTrie(wordDict);\\n        visited = new boolean[s.length()];\\n        return traverseTree(s, 0);\\n    }\\n    \\n    public boolean traverseTree(String s, int idx){\\n        TrieNode curr = trie;\\n        //end state\\n        if(idx == s.length())\\n            return true;\\n        \\n        if(visited[idx] == true)\\n            return false;\\n        visited[idx] = true;\\n\\n        //traverse\\n        while(idx < s.length() && curr.children.containsKey(s.charAt(idx))){\\n            curr = curr.children.get(s.charAt(idx));\\n            if(curr.isWord){\\n                boolean answer = traverseTree(s, idx + 1);\\n                if(answer)\\n                    return true;\\n            }\\n            idx++;\\n        }\\n        \\n        //not found, back track or possibly exit\\n        return false;\\n    }\\n    \\n    private void buildTrie(List<String> wordDict){\\n        for(String s: wordDict){\\n            TrieNode curr = trie;\\n            for(int i = 0; i < s.length(); i++){\\n                if(!curr.children.containsKey(s.charAt(i)))\\n                    curr.children.put(s.charAt(i), new TrieNode(s.charAt(i), false));\\n                curr = curr.children.get(s.charAt(i));\\n                if(i == s.length() - 1)\\n                   curr.isWord = true;\\n            }\\n        }\\n    }\\n}```\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode{\\n        Character c;\\n        boolean isWord;\\n        HashMap<Character, TrieNode> children = new HashMap();\\n        \\n        TrieNode(){\\n            \\n        }\\n        \\n        TrieNode(Character c, boolean isWord){\\n            this.c = c;\\n            this.isWord = isWord;\\n        }\\n   }\\n    \\n    TrieNode trie = new TrieNode();\\n    boolean[] visited;\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        buildTrie(wordDict);\\n        visited = new boolean[s.length()];\\n        return traverseTree(s, 0);\\n    }\\n    \\n    public boolean traverseTree(String s, int idx){\\n        TrieNode curr = trie;\\n        //end state\\n        if(idx == s.length())\\n            return true;\\n        \\n        if(visited[idx] == true)\\n            return false;\\n        visited[idx] = true;\\n\\n        //traverse\\n        while(idx < s.length() && curr.children.containsKey(s.charAt(idx))){\\n            curr = curr.children.get(s.charAt(idx));\\n            if(curr.isWord){\\n                boolean answer = traverseTree(s, idx + 1);\\n                if(answer)\\n                    return true;\\n            }\\n            idx++;\\n        }\\n        \\n        //not found, back track or possibly exit\\n        return false;\\n    }\\n    \\n    private void buildTrie(List<String> wordDict){\\n        for(String s: wordDict){\\n            TrieNode curr = trie;\\n            for(int i = 0; i < s.length(); i++){\\n                if(!curr.children.containsKey(s.charAt(i)))\\n                    curr.children.put(s.charAt(i), new TrieNode(s.charAt(i), false));\\n                curr = curr.children.get(s.charAt(i));\\n                if(i == s.length() - 1)\\n                   curr.isWord = true;\\n            }\\n        }\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 870741,
                "title": "c-dp-different-approach-fast-beats-100-of-submissions-and-simple",
                "content": "\\n* This takes a slightly different approach to solving this problem in a more intuitive manner\\n* Maintain a dp where dp[i] indicates whether the string ending at s[i - 1] can be formed using words from wordDict\\n* Set dp[0] as true - since any empty string can be formed without using any words from the Word Dictionary\\n* Now from each i where dp[i] has been set as true, check each word of the dictionary to see if that string can be formed from i. If it\\'s possible, then set dp[i + word.size()] = true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int i, n = s.size();\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        for(i=0; i<n; i++) {\\n            if(!dp[i]) continue;\\n            for(auto word : wordDict) {\\n                int len = word.size();\\n                if(i + len > n) continue;\\n                if(word == s.substr(i, len)) \\n                    dp[i + len] = true;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int i, n = s.size();\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        for(i=0; i<n; i++) {\\n            if(!dp[i]) continue;\\n            for(auto word : wordDict) {\\n                int len = word.size();\\n                if(i + len > n) continue;\\n                if(word == s.substr(i, len)) \\n                    dp[i + len] = true;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674046,
                "title": "javascript-bfs-with-comments",
                "content": "Basically, from every character index we build substrings up and until the end of the string. \\nE.g. given string s = \\'abcd\\', we start with index 0 to search from and build\\n0 : a\\n1: ab\\n2: abc\\n3: abcd\\n\\nuntil we find the word that is in the given dictionary. If we find a word and our search index is at the last character of s, then we are done. \\n```\\n// rephrased question: Can you build this string with the given dictionary?\\n// BFS approach\\nfunction wordBreak(s, wordDict) {\\n    // switch dict to a set for faster lookup\\n    const dictionary = new Set(wordDict);\\n\\n    let visited = new Set();\\n    let queue = [0]; // index of the letter where we will start searching from. Start with 0\\n\\n\\t// while we have character indexes left to search\\n    while (queue.length > 0) {\\n\\t    // take the latest added index, we will explore all words that begin with the character at this index\\n        const currentIndex = queue.shift();\\n        // if we haven\\'t explored the current index already\\n        if (!visited.has(currentIndex)) {\\n            // from the currentIndex we need all substrings up to the end of the string s\\n            for (let i = currentIndex; i < s.length; i++) {\\n                // get the current substring from current index exploring, to latest character i\\n                const substring = s.slice(currentIndex, i + 1); // (remember slice is not inclusive, so we need + 1 to get the full substr)\\n\\n                // if our dictionary contains the current substring, then we have all the letters we need for this word\\n                if (dictionary.has(substring)) {\\n                    // check if we are done searching (our search has searched until last character in s)\\n                    if (i === s.length - 1) { // if we are at the end of the string, and we have a word in the dictionary, it must be last word\\n                        return true; // done\\n                    }\\n                    // otherwise, we have all the letters we need for the word we just found, but we need to look for more words (not at end of s) \\n                    // so add the next unfound letter to our queue\\n                    queue.push(i + 1);\\n                }\\n            }\\n\\n            // we visited all we can for the current index, lets add it and move on\\n            visited.add(currentIndex);\\n        }\\n    }\\n\\n    // we didn\\'t find all the words, and ran out of elements to search in our queue\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n// rephrased question: Can you build this string with the given dictionary?\\n// BFS approach\\nfunction wordBreak(s, wordDict) {\\n    // switch dict to a set for faster lookup\\n    const dictionary = new Set(wordDict);\\n\\n    let visited = new Set();\\n    let queue = [0]; // index of the letter where we will start searching from. Start with 0\\n\\n\\t// while we have character indexes left to search\\n    while (queue.length > 0) {\\n\\t    // take the latest added index, we will explore all words that begin with the character at this index\\n        const currentIndex = queue.shift();\\n        // if we haven\\'t explored the current index already\\n        if (!visited.has(currentIndex)) {\\n            // from the currentIndex we need all substrings up to the end of the string s\\n            for (let i = currentIndex; i < s.length; i++) {\\n                // get the current substring from current index exploring, to latest character i\\n                const substring = s.slice(currentIndex, i + 1); // (remember slice is not inclusive, so we need + 1 to get the full substr)\\n\\n                // if our dictionary contains the current substring, then we have all the letters we need for this word\\n                if (dictionary.has(substring)) {\\n                    // check if we are done searching (our search has searched until last character in s)\\n                    if (i === s.length - 1) { // if we are at the end of the string, and we have a word in the dictionary, it must be last word\\n                        return true; // done\\n                    }\\n                    // otherwise, we have all the letters we need for the word we just found, but we need to look for more words (not at end of s) \\n                    // so add the next unfound letter to our queue\\n                    queue.push(i + 1);\\n                }\\n            }\\n\\n            // we visited all we can for the current index, lets add it and move on\\n            visited.add(currentIndex);\\n        }\\n    }\\n\\n    // we didn\\'t find all the words, and ran out of elements to search in our queue\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 523264,
                "title": "python3-one-minor-change-from-18-77-to-96-07",
                "content": "Just make the wordDict from a list to a set : )\\n\\n```\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        n = len(s)\\n\\t\\t# List->Set\\n        dic = set(wordDict)\\n\\n        dp = [False for _ in range(n + 1)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            for j in range(i+1, n+1):\\n                if dp[i] == True and s[i:j] in dic:\\n                    dp[j] = True\\n        \\n        return dp[-1]\\n```\\n![image](https://assets.leetcode.com/users/lenah/image_1583130194.png)\\n\\n\\n(1) Initialization\\uFF1A\\ndp = [False, ... , False], and length of dp is n+1.\\ndp[i] means if s[:i] is contained in wordDict.\\n\\n(2) Base case:\\nNull character is always contained, so dp[0] = True.\\n\\n(3) Tranversal:\\ndp[i] = True means that s[0,..., i) can be segmented into words in the dictionary. When s[i, ... , j) also appears in wordDict, dp[j] is True.\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        n = len(s)\\n\\t\\t# List->Set\\n        dic = set(wordDict)\\n\\n        dp = [False for _ in range(n + 1)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            for j in range(i+1, n+1):\\n                if dp[i] == True and s[i:j] in dic:\\n                    dp[j] = True\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 43813,
                "title": "c-solution-using-trie",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Node {\\n        bool isValid;\\n        Node* child[256];\\n    };\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        Node* root = new Node();\\n        for (auto& word : wordDict) {\\n            Node* tmp = root;\\n            for (auto& c : word)\\n                tmp = (tmp->child[c] ? tmp->child[c] : tmp->child[c] = new Node());\\n            tmp->isValid = true;\\n        }\\n        vector<bool> f(s.size(), false);\\n        f[0] = true;\\n        for (int i = 0; i < s.size(); ++ i)\\n            if (f[i]) {\\n                Node* tmp = root;\\n                for (int j = i; j < s.size(); ++ j) {\\n                    if (!tmp->child[s[j]]) break;\\n                    tmp = tmp->child[s[j]];\\n                    f[j + 1] = f[j + 1] || tmp->isValid;\\n                }\\n            }\\n        return f[(int)s.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Node {\\n        bool isValid;\\n        Node* child[256];\\n    };\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        Node* root = new Node();\\n        for (auto& word : wordDict) {\\n            Node* tmp = root;\\n            for (auto& c : word)\\n                tmp = (tmp->child[c] ? tmp->child[c] : tmp->child[c] = new Node());\\n            tmp->isValid = true;\\n        }\\n        vector<bool> f(s.size(), false);\\n        f[0] = true;\\n        for (int i = 0; i < s.size(); ++ i)\\n            if (f[i]) {\\n                Node* tmp = root;\\n                for (int j = i; j < s.size(); ++ j) {\\n                    if (!tmp->child[s[j]]) break;\\n                    tmp = tmp->child[s[j]];\\n                    f[j + 1] = f[j + 1] || tmp->isValid;\\n                }\\n            }\\n        return f[(int)s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43987,
                "title": "easy-to-understand-2ms-java-solution-using-dp",
                "content": "    public boolean wordBreak(String s, Set<String> wordDict) \\n    {\\n        int n = s.length();\\n        boolean[] canBreak = new boolean[1 + n];\\n        canBreak[n] = true;\\n        \\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            for(int j = i + 1; j <= n; ++j)\\n            {\\n                if(canBreak[j] && wordDict.contains(s.substring(i, j)))\\n                {\\n                    canBreak[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return canBreak[0];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean wordBreak(String s, Set<String> wordDict) \\n    {\\n        int n = s.length();\\n        boolean[] canBreak = new boolean[1 + n];\\n        canBreak[n] = true;\\n        \\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            for(int j = i + 1; j <= n; ++j)\\n            {\\n                if(canBreak[j] && wordDict.contains(s.substring(i, j)))\\n                {\\n                    canBreak[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return canBreak[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43993,
                "title": "dp-using-c-4ms",
                "content": "    class Solution {\\n    public:\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        int m = s.length();\\n        \\n        bool *dp = new bool[m+1];\\n        for(int i = 0; i <= m; i ++) dp[i] = false;\\n        \\n        dp[0] = true;\\n        for(int i = 1; i <= m; i ++){\\n            for(int j = 1; j <= i; j ++){\\n                string tmp = s.substr(i - j, j);\\n                if(wordDict.find(tmp) != wordDict.end()){\\n                    dp[i] = dp[i-j];\\n                    if(dp[i]) break;\\n                }\\n            }\\n        }\\n        bool res = dp[m];\\n        delete [] dp;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        int m = s.length();\\n        \\n        bool *dp = new bool[m+1];\\n        for(int i = 0; i <= m; i ++) dp[i] = false;\\n        \\n        dp[0] = true;\\n        for(int i = 1; i <= m; i ++){\\n            for(int j = 1; j <= i; j ++){\\n                string tmp = s.substr(i - j, j);\\n                if(wordDict.find(tmp) != wordDict.end()){\\n                    dp[i] = dp[i-j];\\n                    if(dp[i]) break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44057,
                "title": "a-short-dp-c-solution",
                "content": "    public class Solution {\\n        public bool WordBreak(string s, ISet<string> wordDict) {\\n            int len = s.Length;\\n            bool[] f = new bool[len + 1];\\n            f[0] = true;\\n            for (int i = 1; i < len + 1; i++)\\n                for (int j = 0; j < i; j++)\\n                    if (f[j] && wordDict.Contains(s.Substring(j, i - j))){\\n                        f[i] = true;\\n                        break;\\n                    }\\n            return f[len];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public bool WordBreak(string s, ISet<string> wordDict) {\\n            int len = s.Length;\\n            bool[] f = new bool[len + 1];\\n            f[0] = true;\\n            for (int i = 1; i < len + 1; i++)\\n                for (int j = 0; j < i; j++)\\n                    if (f[j] && wordDict.Contains(s.Substring(j, i - j))){\\n                        f[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3862716,
                "title": "simple-solution-explained-with-example-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI will explain two things \\n\\n**1) How do we start thinking when we such questions**\\n\\n**2) How do i write code for such a thing...**\\n\\nAnswer 1) \\n\\nYou are given a string , let us say **s=\"Leetcode\"** and your **array = [\"leet , \"code\",\"shit\"]**\\n\\nNow, how do i start, \\n\\nRemember this rule, When you can\\'t understand where to start, **just break the string in the lowest size possible...**\\n\\nSO, here Let us break..Leetcode into smallest size possible ..**that is \"L\", \"e\" , \"e\" ,\"t\" \"c\", \"o\", \"d\" ,\"e\"**...Are any of the chactarcters present in your array ... **your ans is  no**\\n\\nNow, let us move to the second smallest size possible .. that is..**\"le\",\"ee\" ,\"et\" , \"tc\" ,\"co\" ,\"od\" , \"de\"**..Are any of the strings presnt in your array..**The ans is no..**\\n\\nNow, Let us move to the **fourth smallest size possible**..that is **\"leet\", \"eetc\"...and so on..**.\\n\\nNow , you found **that atleast leet is present in your array**, Now once you find that** atleast somnething is presnt** ..we will start **forming strings again from the next index onwards..**\\n\\nLet me explain , After leet, we will again form **strings of size 1..****then 2 ..then 3 and so on.**..Let us say you again **find a string of size 4 which is present so**..you will again start the same process from the next index....\\n\\n**Now, how do we write the code for such a thing ...**\\n\\n```\\n        string x;\\n        bool ans  = false;\\n\\n        for(int k=i; k<s.size(); k++)\\n        {\\n            x+=s[k];\\n\\n            if(jd.find(x)!=jd.end())\\n            {\\n                ans = check(k+1,s,jd,dp);\\n                if(ans==true)\\n                {\\n                    dp[i] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n```\\n\\nNow, what will be the base case...\\n\\nLet us say after **incrementing the index \"i\"**, you reach the end of the string..**It means you were able to find all the combinations**..**so return a true...**\\n\\n```\\n  if(i==s.size())\\n    {\\n        return true;\\n    }\\n```\\n\\nNow, how do i memoize it...The ans is simple...\\n\\nWe know that , **only a single index \"i\" is changing**...so we will make a **1-d dp array** and **store 1 or 0**, if it is true we will **store 1 and if false , we will store a 0 in the dp array...**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are making a 1-d dp array and we are just iterating the string given to us so...**O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe made a 1-d dp array and a hash map , where the hashmap stores all the strings so it will be **O(N +M)**, where M will be the no of strings presnt in the array...\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int i,string &s,unordered_map<string,int>&jd, vector<int>&dp)\\n    {\\n\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n\\n        \\n        if(dp[i]!=-1)\\n        {\\n            if(dp[i]==1)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        string x;\\n        bool ans  = false;\\n\\n        for(int k=i; k<s.size(); k++)\\n        {\\n            x+=s[k];\\n\\n            if(jd.find(x)!=jd.end())\\n            {\\n                ans = check(k+1,s,jd,dp);\\n                if(ans==true)\\n                {\\n                    dp[i] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n\\n        if(ans==false)\\n        {\\n            dp[i]=0;\\n            \\n        }\\n        else\\n        {\\n            dp[i]=1;\\n        }\\n\\n      \\n\\n        return ans;\\n    }\\n\\n\\n    bool wordBreak(string s, vector<string>& worddict) {\\n        \\n        vector<int>dp(s.size(),-1);\\n        unordered_map<string,int>jd;\\n\\n        for(int i=0; i<worddict.size(); i++)\\n        {\\n            jd[worddict[i]]=0;\\n        }\\n\\n        bool z = check(0,s,jd,dp);\\n\\n        return z;\\n\\n    }\\n};\\n```\\n**TIME FOR A MEME NOW**\\n\\n![WhatsApp Image 2023-08-04 at 17.51.43.jpeg](https://assets.leetcode.com/users/images/e1154413-0781-46fc-87a0-bfa66c4fc659_1691151736.4184039.jpeg)\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTEE.....**\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n        string x;\\n        bool ans  = false;\\n\\n        for(int k=i; k<s.size(); k++)\\n        {\\n            x+=s[k];\\n\\n            if(jd.find(x)!=jd.end())\\n            {\\n                ans = check(k+1,s,jd,dp);\\n                if(ans==true)\\n                {\\n                    dp[i] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n```\n```\\n  if(i==s.size())\\n    {\\n        return true;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int i,string &s,unordered_map<string,int>&jd, vector<int>&dp)\\n    {\\n\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n\\n        \\n        if(dp[i]!=-1)\\n        {\\n            if(dp[i]==1)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        string x;\\n        bool ans  = false;\\n\\n        for(int k=i; k<s.size(); k++)\\n        {\\n            x+=s[k];\\n\\n            if(jd.find(x)!=jd.end())\\n            {\\n                ans = check(k+1,s,jd,dp);\\n                if(ans==true)\\n                {\\n                    dp[i] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n\\n        if(ans==false)\\n        {\\n            dp[i]=0;\\n            \\n        }\\n        else\\n        {\\n            dp[i]=1;\\n        }\\n\\n      \\n\\n        return ans;\\n    }\\n\\n\\n    bool wordBreak(string s, vector<string>& worddict) {\\n        \\n        vector<int>dp(s.size(),-1);\\n        unordered_map<string,int>jd;\\n\\n        for(int i=0; i<worddict.size(); i++)\\n        {\\n            jd[worddict[i]]=0;\\n        }\\n\\n        bool z = check(0,s,jd,dp);\\n\\n        return z;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616181,
                "title": "amortized-linear-o-k-m-solution-using-aho-corasick-automaton",
                "content": "# Approach\\nI used an advanced data structure that can detect matches in one-pass. This data structure is called Aho-Corasick automaton. The present solutions in leetcode are at $$O(n^2)$$ solution. This solution runs at $$O(k + m)$$ at test time with an overhead of $$O(n)$$. I hope this helps you impress your future interviewer. (\\u25CD\\u2022\\u1D17\\u2022\\u25CD)\\n# Complexity\\n- Time complexity: $$O(n + k + m)$$\\nBuild Automaton: $$O(n)$$ where $$n$$ is the total number of characters in the dictionary.\\nTest segmentation: $$O(k + m)$$ where $$k$$ is the length of string to segment and $$m$$ represents the number of matches present between the dictionary and the string to segment.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$\\nAutomaton: $$O(n + m)$$\\nDP Array: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.fail = None\\n        self.output = set()\\n\\n\\nclass AhoCorasick:\\n    def __init__(self, words):\\n        self.root = TrieNode()\\n        self.build_trie(words)\\n        self.build_fail()\\n\\n    def build_trie(self, words):\\n        for word in words:\\n            curr = self.root\\n            for c in word:\\n                curr = curr.children[c]\\n            curr.output.add(word)\\n    \\n    def build_fail(self):\\n        q = deque([self.root])\\n        while q:\\n            curr = q.popleft()\\n            for n, child in list(curr.children.items()):\\n                if curr is self.root:\\n                    child.fail = curr\\n                else:\\n                    p = curr.fail\\n                    while p is not self.root and n not in p.children:\\n                        p = p.fail\\n                    if n in p.children:\\n                        p = p.children[n]\\n                    child.fail = p\\n                    child.output.update(p.output)\\n                q.append(child)\\n\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        ac = AhoCorasick(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        curr = ac.root\\n        for i in range(n):\\n            c = s[i]\\n            while curr is not ac.root and c not in curr.children:\\n                curr = curr.fail\\n            if c in curr.children:\\n                curr = curr.children[c]\\n            else:\\n                return False\\n            \\n            for word in curr.output:\\n                start = i - len(word) + 1\\n                dp[i + 1] = dp[start] or dp[i + 1]\\n                if dp[i + 1]: break\\n        \\n        return dp[-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.fail = None\\n        self.output = set()\\n\\n\\nclass AhoCorasick:\\n    def __init__(self, words):\\n        self.root = TrieNode()\\n        self.build_trie(words)\\n        self.build_fail()\\n\\n    def build_trie(self, words):\\n        for word in words:\\n            curr = self.root\\n            for c in word:\\n                curr = curr.children[c]\\n            curr.output.add(word)\\n    \\n    def build_fail(self):\\n        q = deque([self.root])\\n        while q:\\n            curr = q.popleft()\\n            for n, child in list(curr.children.items()):\\n                if curr is self.root:\\n                    child.fail = curr\\n                else:\\n                    p = curr.fail\\n                    while p is not self.root and n not in p.children:\\n                        p = p.fail\\n                    if n in p.children:\\n                        p = p.children[n]\\n                    child.fail = p\\n                    child.output.update(p.output)\\n                q.append(child)\\n\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        ac = AhoCorasick(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        curr = ac.root\\n        for i in range(n):\\n            c = s[i]\\n            while curr is not ac.root and c not in curr.children:\\n                curr = curr.fail\\n            if c in curr.children:\\n                curr = curr.children[c]\\n            else:\\n                return False\\n            \\n            for word in curr.output:\\n                start = i - len(word) + 1\\n                dp[i + 1] = dp[start] or dp[i + 1]\\n                if dp[i + 1]: break\\n        \\n        return dp[-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621627,
                "title": "my-dp-c-solution-using-sliding-window",
                "content": "**Upvote If helpful please**\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> st(wordDict.begin(),wordDict.end());\\n        vector<bool> dp(s.size(),0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp=\"\";\\n            for(int j=i;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                if(st.find(temp)!=st.end())\\n                {\\n                    //cout<<temp<<\" \";\\n                    if(i==0)\\n                    {\\n                        dp[j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[j]=dp[i-1] or dp[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()-1];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> st(wordDict.begin(),wordDict.end());\\n        vector<bool> dp(s.size(),0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp=\"\";\\n            for(int j=i;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                if(st.find(temp)!=st.end())\\n                {\\n                    //cout<<temp<<\" \";\\n                    if(i==0)\\n                    {\\n                        dp[j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[j]=dp[i-1] or dp[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1355839,
                "title": "c-simple-and-intuitive-solutions-top-down-and-bottom-up-dp",
                "content": "**1. Top Down DP Approach**\\n\\n```\\nclass Solution {\\n    unordered_map<string, int> dict;\\n    vector<vector<int> > dp;\\npublic:\\n    bool findSequence(int i, int j, string s, string curr){\\n        if(j >= s.size()){\\n            if(curr == \"\" or dict.find(curr) != dict.end()){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        if(dict.find(curr + s[j]) != dict.end()){\\n            return dp[i][j] = findSequence(i, j+1, s, curr+s[j]) || findSequence(j+1, j+1, s, \"\");\\n        }\\n        else{\\n            return dp[i][j] = findSequence(i, j+1, s, curr+s[j]);\\n        }\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n = s.size();\\n        for(int i=0;i<wordDict.size();i++){\\n            dict[wordDict[i]] = 1;\\n        }\\n        \\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return findSequence(0, 0, s, \"\");\\n    }\\n};\\n```\\n\\n**2. Bottom Up DP Approach**\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(wordDict.size() == 0)\\n            return false;\\n        \\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        int longestWord = 0;\\n        for(string str: wordDict){\\n            longestWord = max(longestWord, (int)str.size());\\n        }\\n        \\n        int n = s.size();\\n        vector<bool> dp(n+1, false);\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = i-1; j >= max(i-longestWord, 0); j--){\\n                if(dp[j] == true){\\n                    if(dict.find(s.substr(j, i-j)) != dict.end()){\\n                        dp[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string, int> dict;\\n    vector<vector<int> > dp;\\npublic:\\n    bool findSequence(int i, int j, string s, string curr){\\n        if(j >= s.size()){\\n            if(curr == \"\" or dict.find(curr) != dict.end()){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        if(dict.find(curr + s[j]) != dict.end()){\\n            return dp[i][j] = findSequence(i, j+1, s, curr+s[j]) || findSequence(j+1, j+1, s, \"\");\\n        }\\n        else{\\n            return dp[i][j] = findSequence(i, j+1, s, curr+s[j]);\\n        }\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n = s.size();\\n        for(int i=0;i<wordDict.size();i++){\\n            dict[wordDict[i]] = 1;\\n        }\\n        \\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return findSequence(0, 0, s, \"\");\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(wordDict.size() == 0)\\n            return false;\\n        \\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        int longestWord = 0;\\n        for(string str: wordDict){\\n            longestWord = max(longestWord, (int)str.size());\\n        }\\n        \\n        int n = s.size();\\n        vector<bool> dp(n+1, false);\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = i-1; j >= max(i-longestWord, 0); j--){\\n                if(dp[j] == true){\\n                    if(dict.find(s.substr(j, i-j)) != dict.end()){\\n                        dp[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178842,
                "title": "memoization-easy-matrix-chain-multiplication-aditya-verma-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    bool fun(string &s, int i, int j, vector<string> &dict)\\n    {\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        if(find(dict.begin(),dict.end(),s.substr(i,j-i+1))!=dict.end())\\n            return dp[i][j] = true;\\n        \\n        for(int k = i+1;k<=j;k++)\\n        {\\n            if(fun(s,i,k-1,dict) and fun(s,k,j,dict))\\n                return dp[i][j] = true;\\n        }\\n        \\n        return dp[i][j] = false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& dict) \\n    {   \\n        int n = s.size();\\n        \\n        int i = 0;\\n        int j = s.size()-1;\\n        \\n        dp.clear();\\n        dp.resize(n+1,vector<int> (n+1,-1));\\n        \\n        return fun(s,i,j,dict);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    bool fun(string &s, int i, int j, vector<string> &dict)\\n    {\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        if(find(dict.begin(),dict.end(),s.substr(i,j-i+1))!=dict.end())\\n            return dp[i][j] = true;\\n        \\n        for(int k = i+1;k<=j;k++)\\n        {\\n            if(fun(s,i,k-1,dict) and fun(s,k,j,dict))\\n                return dp[i][j] = true;\\n        }\\n        \\n        return dp[i][j] = false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& dict) \\n    {   \\n        int n = s.size();\\n        \\n        int i = 0;\\n        int j = s.size()-1;\\n        \\n        dp.clear();\\n        dp.resize(n+1,vector<int> (n+1,-1));\\n        \\n        return fun(s,i,j,dict);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880049,
                "title": "python-easiest-soln-top-down-dp-bottom-up-dp-dp-with-trie-soln-faster-than-90",
                "content": "**Top-down DP**\\n\\n```\\nclass Solution:\\n    def dp(self, s, dic, dp):   #Top-Down\\n        if s == \"\":\\n            return True\\n\\n        if s in dic:\\n            return True\\n\\n        if s in dp:\\n            return dp[s]\\n\\n        for i in range(1,len(s)+1):\\n            if s[:i] in dic and self.dp(s[i:],dic,dp):\\n                dp[s] = True\\n                return dp[s]\\n\\n        dp[s] = False\\n        return dp[s]\\n\\n    def wordBreak(self, s, dic):\\n        n = len(s)\\n        dp = {}\\n        return self.dp(s, dic,dp)\\n```\\n\\n**Bottom-Up**\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s, dic):   #Bottom-Up\\n        n = len(s)\\n        dp = [False for _ in range(n + 1)]\\n        dp[0] = True\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in dic:\\n                    dp[i] = True\\n\\n        return dp[-1]\\n```\\n\\n**DP with Trie**\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = {}\\n        self.terminal = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, w):\\n        n = len(w)\\n        head = self.root\\n        \\n        for i in range(n):\\n            if w[i] in head.child:\\n                head = head.child[w[i]]\\n            else:\\n                head.child[w[i]] = TrieNode()\\n                head = head.child[w[i]]\\n        \\n        head.terminal = True\\n    \\n    def search(self, w):\\n        n = len(w)\\n        head = self.root\\n        \\n        for i in range(n):\\n            if w[i] not in head.child:\\n                return False\\n            \\n            head = head.child[w[i]]\\n        \\n        return True if head.terminal else False\\n    \\nclass Solution:\\n    def wordBreak(self, s: str, dic: List[str]) -> bool:\\n        n = len(s)\\n        trie = Trie()\\n        for i in dic:\\n            trie.insert(i)\\n\\n        dp = [False for _ in range(n+1)]\\n        dp[0] = True\\n\\n        for i in range(1, n+1):\\n            for j in range(i):\\n                if dp[j] and trie.search(s[j:i]):\\n                    dp[i] = True\\n                    break\\n\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, s, dic, dp):   #Top-Down\\n        if s == \"\":\\n            return True\\n\\n        if s in dic:\\n            return True\\n\\n        if s in dp:\\n            return dp[s]\\n\\n        for i in range(1,len(s)+1):\\n            if s[:i] in dic and self.dp(s[i:],dic,dp):\\n                dp[s] = True\\n                return dp[s]\\n\\n        dp[s] = False\\n        return dp[s]\\n\\n    def wordBreak(self, s, dic):\\n        n = len(s)\\n        dp = {}\\n        return self.dp(s, dic,dp)\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s, dic):   #Bottom-Up\\n        n = len(s)\\n        dp = [False for _ in range(n + 1)]\\n        dp[0] = True\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in dic:\\n                    dp[i] = True\\n\\n        return dp[-1]\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = {}\\n        self.terminal = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, w):\\n        n = len(w)\\n        head = self.root\\n        \\n        for i in range(n):\\n            if w[i] in head.child:\\n                head = head.child[w[i]]\\n            else:\\n                head.child[w[i]] = TrieNode()\\n                head = head.child[w[i]]\\n        \\n        head.terminal = True\\n    \\n    def search(self, w):\\n        n = len(w)\\n        head = self.root\\n        \\n        for i in range(n):\\n            if w[i] not in head.child:\\n                return False\\n            \\n            head = head.child[w[i]]\\n        \\n        return True if head.terminal else False\\n    \\nclass Solution:\\n    def wordBreak(self, s: str, dic: List[str]) -> bool:\\n        n = len(s)\\n        trie = Trie()\\n        for i in dic:\\n            trie.insert(i)\\n\\n        dp = [False for _ in range(n+1)]\\n        dp[0] = True\\n\\n        for i in range(1, n+1):\\n            for j in range(i):\\n                if dp[j] and trie.search(s[j:i]):\\n                    dp[i] = True\\n                    break\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818969,
                "title": "c-trie-dp-o-n-l-space-o-n-l-time-complexity",
                "content": "\\tstruct TrieNode{\\n\\t\\tTrieNode *children[26];\\n\\t\\tbool isEnd;\\n    \\n\\t\\tTrieNode()\\n\\t\\t{\\n\\t\\t\\tfor(int i=0; i<26; i++)\\n\\t\\t\\t\\tchildren[i] = NULL;\\n\\t\\t\\tisEnd = false;\\n\\t\\t}\\n\\t};\\n\\n\\tTrieNode *root;\\n\\tvector<bool> dp;\\n\\n\\tvoid insert(string word)\\n\\t{\\n\\t\\tint n = word.size();\\n\\t\\tTrieNode *temp = root;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tint x = (int)(word[i] - \\'a\\');\\n\\t\\t\\tif(!temp->children[x])\\n\\t\\t\\t\\ttemp->children[x] = new TrieNode();\\n\\t\\t\\ttemp = temp->children[x];\\n\\t\\t}\\n\\t\\ttemp->isEnd = true;\\n\\t}\\n\\n\\tvoid search(string word, int start)\\n\\t{\\n\\t\\tint n = word.size();\\n\\t\\tTrieNode *temp = root;\\n\\t\\tfor(int i=start; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tint x = word[i] - \\'a\\';\\n\\t\\t\\tif(!temp->children[x])\\n\\t\\t\\t\\treturn;\\n\\t\\t\\ttemp = temp->children[x];\\n\\t\\t\\tif(temp->isEnd)\\n\\t\\t\\t\\tdp[i+1] = 1;\\n\\t\\t}\\n\\n\\t\\tif(temp->isEnd)\\n\\t\\t\\tdp[n] = 1;\\n\\t}\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool wordBreak(string s, vector<string>& A) {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t\\tint n = A.size(), l = s.size();\\n\\t\\t\\tdp.assign(l+1, 0);\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t\\tinsert(A[i]);\\n\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i=0; i<l; i++)\\n\\t\\t\\t\\tif(dp[i])\\n\\t\\t\\t\\t\\tsearch(s, i);\\n\\n\\t\\t\\treturn dp[l];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool wordBreak(string s, vector<string>& A) {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t\\tint n = A.size(), l = s.size();\\n\\t\\t\\tdp.assign(l+1, 0);\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t\\tinsert(A[i]);\\n\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i=0; i<l; i++)\\n\\t\\t\\t\\tif(dp[i])\\n\\t\\t\\t\\t\\tsearch(s, i);\\n\\n\\t\\t\\treturn dp[l];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 673369,
                "title": "java-simple-recursion-with-memoization-solution",
                "content": "\\nclass Solution {\\n    \\n    Map<String, Boolean> map = new HashMap<String,Boolean>();\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        \\n        if(s.length() == 0) return true;\\n        \\n        if(map.containsKey(s) && !map.get(s)) return false;\\n        for(String str:wordDict){\\n            \\n            int len = str.length();\\n            \\n            if(s.indexOf(str) == 0){\\n                \\n               if(wordBreak(s.substring(len),wordDict)){\\n                   return true;\\n               }\\n            }\\n            \\n            \\n        }\\n        map.put(s,false);\\n        return false;\\n    }\\n    \\n    \\n}\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    Map<String, Boolean> map = new HashMap<String,Boolean>();\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        \\n        if(s.length() == 0) return true;\\n        \\n        if(map.containsKey(s) && !map.get(s)) return false;\\n        for(String str:wordDict){\\n            \\n            int len = str.length();\\n            \\n            if(s.indexOf(str) == 0){\\n                \\n               if(wordBreak(s.substring(len),wordDict)){\\n                   return true;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 597051,
                "title": "java-dp-bfs-solutions-clean-code",
                "content": "```\\n// Bottom Up Dynamic Programming\\n// Time Complexity: O(n^2) quadratic\\n// Space Complexity:  O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        Set<String> dict = new HashSet<>(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1]; // Don\\'t forget +1 or you\\'ll get an index out of bounds error for dp[s.length()]\\n        dp[0] = true;\\n        \\n        for (int end = 0; end <= s.length(); end++) {\\n            for (int start = 0; start < end; start++) {\\n                if (dp[start] && dict.contains(s.substring(start, end))) {\\n                    dp[end] = true;\\n                    break; // Optional: Prevents unneccesary cycles after solution is found\\n                }\\n            }\\n        }\\n        \\n        return dp[s.length()];\\n    }\\n}\\n```\\n```\\n// Top Down Dynamic Programming - Recusion + Memoization\\n// Time Complexity: O(n^2) quadratic time\\n// Space Complexity: O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        return bckTrck(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);\\n    }\\n    \\n    public boolean bckTrck(String s, Set<String> dict, int idx, Boolean[] memo) {\\n        if (idx == s.length()) return true;\\n        \\n        if (memo[idx] != null) return memo[idx];\\n        \\n        for (int end = idx + 1; end <= s.length(); end++) {\\n            if (dict.contains(s.substring(idx, end)) && bckTrck(s, dict, end, memo)){\\n                memo[idx] = true;\\n                return true;\\n            } \\n        }\\n        \\n        memo[idx] = false;\\n        return false;\\n    }\\n}\\n```\\n```\\n// BFS\\n// Time Complexity: O(n^2) quadratic time\\n// Space Complexity: O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        Set<String> dict = new HashSet<>(wordDict);\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[s.length()];\\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            int start = q.poll();\\n            \\n            if (!visited[start]) {\\n                for (int end = start + 1; end <= s.length(); end++) {\\n                    if (dict.contains(s.substring(start, end))) {  \\n                        if (end == s.length()) return true;\\n                        \\n                        q.offer(end);\\n                    }\\n                }\\n                \\n                visited[start] = true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Bottom Up Dynamic Programming\\n// Time Complexity: O(n^2) quadratic\\n// Space Complexity:  O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        Set<String> dict = new HashSet<>(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1]; // Don\\'t forget +1 or you\\'ll get an index out of bounds error for dp[s.length()]\\n        dp[0] = true;\\n        \\n        for (int end = 0; end <= s.length(); end++) {\\n            for (int start = 0; start < end; start++) {\\n                if (dp[start] && dict.contains(s.substring(start, end))) {\\n                    dp[end] = true;\\n                    break; // Optional: Prevents unneccesary cycles after solution is found\\n                }\\n            }\\n        }\\n        \\n        return dp[s.length()];\\n    }\\n}\\n```\n```\\n// Top Down Dynamic Programming - Recusion + Memoization\\n// Time Complexity: O(n^2) quadratic time\\n// Space Complexity: O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        return bckTrck(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);\\n    }\\n    \\n    public boolean bckTrck(String s, Set<String> dict, int idx, Boolean[] memo) {\\n        if (idx == s.length()) return true;\\n        \\n        if (memo[idx] != null) return memo[idx];\\n        \\n        for (int end = idx + 1; end <= s.length(); end++) {\\n            if (dict.contains(s.substring(idx, end)) && bckTrck(s, dict, end, memo)){\\n                memo[idx] = true;\\n                return true;\\n            } \\n        }\\n        \\n        memo[idx] = false;\\n        return false;\\n    }\\n}\\n```\n```\\n// BFS\\n// Time Complexity: O(n^2) quadratic time\\n// Space Complexity: O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        Set<String> dict = new HashSet<>(wordDict);\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[s.length()];\\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            int start = q.poll();\\n            \\n            if (!visited[start]) {\\n                for (int end = start + 1; end <= s.length(); end++) {\\n                    if (dict.contains(s.substring(start, end))) {  \\n                        if (end == s.length()) return true;\\n                        \\n                        q.offer(end);\\n                    }\\n                }\\n                \\n                visited[start] = true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560793,
                "title": "c-dynamic-programming-with-explanation",
                "content": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n        if(wordDict.size()==0 || s.empty()) return false;\\n        int n = s.length();\\n        \\n        vector<bool> dp(n+1,false);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) { //fix the s.legth\\n            for(auto k : wordDict){ // find in dictionary\\n                int startIdx = i - k.size(); //start index of substring\\n                if(startIdx < 0 || dp[startIdx] == false) continue;\\n                if ( k == s.substr(startIdx, k.size())){ //compare substring with the element of wordDict\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n        if(wordDict.size()==0 || s.empty()) return false;\\n        int n = s.length();\\n        \\n        vector<bool> dp(n+1,false);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) { //fix the s.legth\\n            for(auto k : wordDict){ // find in dictionary\\n                int startIdx = i - k.size(); //start index of substring\\n                if(startIdx < 0 || dp[startIdx] == false) continue;\\n                if ( k == s.substr(startIdx, k.size())){ //compare substring with the element of wordDict\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 495603,
                "title": "python-simple-dp-idea-using-set-instead-of-list",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        wordDict = set(wordDict)\\n        \\n        # dp[i] means if s[:i] meets\\n        dp = [False for _ in range(n+1)]\\n        dp[0] = True\\n        \\n        for i in range(1, n+1):\\n            for j in range(i):\\n                sub_string = s[j:i]\\n                if dp[j] and sub_string in wordDict:\\n                    dp[i] = True\\n\\t\\t\\t\\t\\tbreak\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        wordDict = set(wordDict)\\n        \\n        # dp[i] means if s[:i] meets\\n        dp = [False for _ in range(n+1)]\\n        dp[0] = True\\n        \\n        for i in range(1, n+1):\\n            for j in range(i):\\n                sub_string = s[j:i]\\n                if dp[j] and sub_string in wordDict:\\n                    dp[i] = True\\n\\t\\t\\t\\t\\tbreak\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148450,
                "title": "clean-java-code-11-lines-5ms",
                "content": "```\\nclass Solution {\\n    Set<String> map = new HashSet();\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(wordDict.contains(s)) return true;\\n        if(map.contains(s)) return false;\\n        for(String word : wordDict){\\n            if(s.startsWith(word)){\\n                if(wordBreak(s.substring(word.length()), wordDict)) return true;\\n            }\\n        }\\n        map.add(s);\\n        return false;\\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<String> map = new HashSet();\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(wordDict.contains(s)) return true;\\n        if(map.contains(s)) return false;\\n        for(String word : wordDict){\\n            if(s.startsWith(word)){\\n                if(wordBreak(s.substring(word.length()), wordDict)) return true;\\n            }\\n        }\\n        map.add(s);\\n        return false;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138398,
                "title": "javascript-solution-using-bfs-and-memoization",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    if (wordDict.length === 0) return false;\\n    if (wordDict.length === 1) return s === wordDict[0];\\n    \\n    let queue = [\\'\\'];\\n    let memo = new Map();\\n    \\n    while (queue.length > 0) {\\n        const val = queue.shift();\\n        \\n        for (let word of wordDict) {\\n            const searchWord = `${val}${word}`;\\n            const startsWith = s.indexOf(searchWord) === 0;\\n            \\n            if (searchWord === s) return true;\\n            else if (!memo.has(searchWord) && startsWith) {\\n                memo.set(searchWord, true);\\n                queue.push(searchWord);\\n            }\\n        }\\n    }\\n    \\n    return false;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    if (wordDict.length === 0) return false;\\n    if (wordDict.length === 1) return s === wordDict[0];\\n    \\n    let queue = [\\'\\'];\\n    let memo = new Map();\\n    \\n    while (queue.length > 0) {\\n        const val = queue.shift();\\n        \\n        for (let word of wordDict) {\\n            const searchWord = `${val}${word}`;\\n            const startsWith = s.indexOf(searchWord) === 0;\\n            \\n            if (searchWord === s) return true;\\n            else if (!memo.has(searchWord) && startsWith) {\\n                memo.set(searchWord, true);\\n                queue.push(searchWord);\\n            }\\n        }\\n    }\\n    \\n    return false;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130922,
                "title": "python-dfs-98",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        start = 0\\n        stack = [start]\\n        visited = set()\\n        while stack:\\n            start = stack.pop()\\n            if start in visited:\\n                continue\\n            visited.add(start)\\n            for word in wordDict:\\n                if s[start:].startswith(word):\\n                    x = len(word)\\n                    if x == len(s[start:]):\\n                        return True\\n                    stack.append(start + x)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        start = 0\\n        stack = [start]\\n        visited = set()\\n        while stack:\\n            start = stack.pop()\\n            if start in visited:\\n                continue\\n            visited.add(start)\\n            for word in wordDict:\\n                if s[start:].startswith(word):\\n                    x = len(word)\\n                    if x == len(s[start:]):\\n                        return True\\n                    stack.append(start + x)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862763,
                "title": "python-easy-explanation",
                "content": "# Intuition\\nTo solve this problem, we can use dynamic programming.\\n\\n# Approach\\nWe\\'ll define a boolean array dp of length n+1, where n is the length of the input string s. dp[i] will be true if the substring s[0:i] can be segmented into space-separated sequences of words from the wordDict.\\n\\nThe idea is to iterate through the string s and check if any substring ending at index i can be formed using words from the wordDict. To do this, we\\'ll check if there is any index j such that dp[j] is true (meaning s[0:j] can be segmented) and the substring s[j:i] (s[j:i] is the substring from index j to i-1) is present in the wordDict.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        n= len(s)\\n        dp= [False] * (n+1)\\n        dp[0]= True\\n\\n        for i in range(1,n+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i]=True\\n                    break\\n        return dp[n]\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        n= len(s)\\n        dp= [False] * (n+1)\\n        dp[0]= True\\n\\n        for i in range(1,n+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i]=True\\n                    break\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860723,
                "title": "easy-intutive-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are trying to partition the string in the best possible way.\\nFor a particular index we\\'re trying to find the maximum length of the string that can be formed from the current index that is present in the dictionary.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the recursive solution would have a exponential complexity, we\\'ll be using memoization and bring it down to O(n) (n=given string length).\\nWe\\'ve further optimized our searching time by using hashmap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n m=wordDict size hashmap, n=given string length\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n+m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(int ind,string&s,unordered_map<string,int>&mp,vector<int>&dp) \\n    {\\n        if(ind==s.length()) \\n         return 0;\\n        if(dp[ind]!=-1) \\n         return dp[ind];\\n        string tmp=\"\";\\n        int len=0; \\n        for(int j=ind;j<s.length();j++) \\n        {\\n            tmp+=s[j]; \\n            if(mp[tmp]) \\n            {   \\n                len=max(len,(j-ind+1)+fun(j+1,s,mp,dp));\\n            }   \\n        } \\n        return dp[ind]=len;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,int>mp;\\n        for(auto it:wordDict) \\n            mp[it]++;\\n        int n=s.length();\\n            vector<int>dp(n,-1);\\n        return fun(0,s,mp,dp)==s.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int ind,string&s,unordered_map<string,int>&mp,vector<int>&dp) \\n    {\\n        if(ind==s.length()) \\n         return 0;\\n        if(dp[ind]!=-1) \\n         return dp[ind];\\n        string tmp=\"\";\\n        int len=0; \\n        for(int j=ind;j<s.length();j++) \\n        {\\n            tmp+=s[j]; \\n            if(mp[tmp]) \\n            {   \\n                len=max(len,(j-ind+1)+fun(j+1,s,mp,dp));\\n            }   \\n        } \\n        return dp[ind]=len;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,int>mp;\\n        for(auto it:wordDict) \\n            mp[it]++;\\n        int n=s.length();\\n            vector<int>dp(n,-1);\\n        return fun(0,s,mp,dp)==s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860474,
                "title": "easy-recursive-dfs-c-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    bool solve(int i, string s, vector<string>& wordDict){\\n        if (i < 0) return 1;\\n        if (dp[i] != -1) return dp[i] == 1;\\n        for (string& w : wordDict) {\\n            int sz = w.size();\\n            if (i - sz + 1 < 0) continue;\\n            if (s.rfind(w, i-sz+1)== i-sz+1 && solve(i - sz, s, wordDict)) {\\n                dp[i] = 1;\\n                return 1;\\n            }\\n        }\\n        dp[i] = 0;\\n        return 0;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int&& n = s.size();\\n        dp.assign(n, -1);\\n        return solve(n - 1, s, wordDict );\\n    }\\n};\\n\\n\\n\\n```\\n# Python code\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [-1] * n\\n\\n        def solve(i, s):\\n            if i < 0:\\n                return True\\n            if dp[i] != -1:\\n                return dp[i] == 1\\n            for w in wordDict:\\n                sz = len(w)\\n                if i-sz+1 >= 0 and s[i-sz+1:i+1] == w:\\n                    if solve(i - sz, s):\\n                        dp[i] = 1\\n                        return True\\n            dp[i] = 0\\n            return False\\n\\n        return solve(n-1, s)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    bool solve(int i, string s, vector<string>& wordDict){\\n        if (i < 0) return 1;\\n        if (dp[i] != -1) return dp[i] == 1;\\n        for (string& w : wordDict) {\\n            int sz = w.size();\\n            if (i - sz + 1 < 0) continue;\\n            if (s.rfind(w, i-sz+1)== i-sz+1 && solve(i - sz, s, wordDict)) {\\n                dp[i] = 1;\\n                return 1;\\n            }\\n        }\\n        dp[i] = 0;\\n        return 0;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int&& n = s.size();\\n        dp.assign(n, -1);\\n        return solve(n - 1, s, wordDict );\\n    }\\n};\\n\\n\\n\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [-1] * n\\n\\n        def solve(i, s):\\n            if i < 0:\\n                return True\\n            if dp[i] != -1:\\n                return dp[i] == 1\\n            for w in wordDict:\\n                sz = len(w)\\n                if i-sz+1 >= 0 and s[i-sz+1:i+1] == w:\\n                    if solve(i - sz, s):\\n                        dp[i] = 1\\n                        return True\\n            dp[i] = 0\\n            return False\\n\\n        return solve(n-1, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328049,
                "title": "c-faster-96-recursive-iterative",
                "content": "**Intuition**\\nBoth approaches attempt to create a substring starting from a particular position, and when a word from the dictionary is identified, they branch out to explore alternate paths from the next index.\\n\\nFirst, I tried the `recursive approach` which was easier to reason about.\\n\\n**Recursive Approach**\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> bag(dict.begin(), dict.end());\\n        unordered_map<int, bool> cache;\\n\\t\\t\\n        // Define a recursive function to solve the problem\\n        function<bool(int)> go = [&](auto start) {\\n            // Base case: if we have reached the end of the string, return true\\n            if (start == s.size()) return true;\\n            // Check if we have already solved this subproblem\\n            if (cache.count(start)) return cache[start];\\n            \\n            // Otherwise, try all possible ways to split the string from the current position\\n            bool is_possible = false;\\n            string builder = \"\";\\n            for (int i = start; i < s.size(); i++) {\\n                builder += s[i];\\n                if (bag.count(builder)) is_possible |= go(i + 1);\\n            }\\n            // Memoize the result of this subproblem and return it\\n            return cache[start] = is_possible;\\n        };\\n\\t\\t\\n        // Solve the problem starting from the beginning of the string\\n        return go(0);\\n    }\\n};\\n```\\n\\nHowever, as the recursive approach was slower, I converted it to iterative resulting in 96% faster solution.\\n\\n**Iterative Approach**\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> bag(dict.begin(), dict.end());\\n        \\n        // Create a vector of boolean values, initialized to false, \\n        // to store whether a substring of s can be broken into words\\n        vector<bool> dp(s.size() + 1, false);\\n        \\n        // Set the value of dp[0] to true, as an empty string can always be broken into words\\n        dp[0] = true;\\n        \\n        // Create a queue to store the starting index of the substring to be processed\\n        queue<int> q; q.push(0);\\n        \\n        // Loop through the queue until it is empty\\n        while (q.size()) {\\n            // Get the starting index of the next substring to be processed\\n            auto start = q.front(); q.pop();\\n            \\n            // If we\\'ve processed the entire string, skip\\n            if (start == s.size()) continue;\\n            \\n            // Create a string to store the current substring being built\\n            string builder = \"\";\\n            \\n            // Loop through the remaining characters of s, starting from the current index\\n            for (int i = start; i < s.size(); i++) {\\n                // Add the current character to the builder string\\n                builder += s[i];\\n                \\n                // If the builder string is in the dictionary, and the previous substring (dp[start]) \\n                // can be broken into words, and the current substring has not been processed yet (not dp[i + 1]), \\n                // mark the current substring as being able to be broken into words, and add the \\n                // starting index of the next substring to the queue to be processed later\\n                if (bag.count(builder) && dp[start] && !dp[i + 1]) {\\n                    q.push(i + 1);\\n                    dp[i + 1] = true;\\n                }\\n            }\\n        }\\n        \\n        // Return the value of the last element of the dp array, which represents whether \\n        // the entire string can be broken into words\\n        return dp[s.size()];\\n    }\\n};\\n```\\n\\n**Similar Problem** \\n- [Word Break II](https://leetcode.com/problems/word-break-ii/discuss/3328288/C%2B%2B-oror-Recursive-solution)\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [github repo](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> bag(dict.begin(), dict.end());\\n        unordered_map<int, bool> cache;\\n\\t\\t\\n        // Define a recursive function to solve the problem\\n        function<bool(int)> go = [&](auto start) {\\n            // Base case: if we have reached the end of the string, return true\\n            if (start == s.size()) return true;\\n            // Check if we have already solved this subproblem\\n            if (cache.count(start)) return cache[start];\\n            \\n            // Otherwise, try all possible ways to split the string from the current position\\n            bool is_possible = false;\\n            string builder = \"\";\\n            for (int i = start; i < s.size(); i++) {\\n                builder += s[i];\\n                if (bag.count(builder)) is_possible |= go(i + 1);\\n            }\\n            // Memoize the result of this subproblem and return it\\n            return cache[start] = is_possible;\\n        };\\n\\t\\t\\n        // Solve the problem starting from the beginning of the string\\n        return go(0);\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> bag(dict.begin(), dict.end());\\n        \\n        // Create a vector of boolean values, initialized to false, \\n        // to store whether a substring of s can be broken into words\\n        vector<bool> dp(s.size() + 1, false);\\n        \\n        // Set the value of dp[0] to true, as an empty string can always be broken into words\\n        dp[0] = true;\\n        \\n        // Create a queue to store the starting index of the substring to be processed\\n        queue<int> q; q.push(0);\\n        \\n        // Loop through the queue until it is empty\\n        while (q.size()) {\\n            // Get the starting index of the next substring to be processed\\n            auto start = q.front(); q.pop();\\n            \\n            // If we\\'ve processed the entire string, skip\\n            if (start == s.size()) continue;\\n            \\n            // Create a string to store the current substring being built\\n            string builder = \"\";\\n            \\n            // Loop through the remaining characters of s, starting from the current index\\n            for (int i = start; i < s.size(); i++) {\\n                // Add the current character to the builder string\\n                builder += s[i];\\n                \\n                // If the builder string is in the dictionary, and the previous substring (dp[start]) \\n                // can be broken into words, and the current substring has not been processed yet (not dp[i + 1]), \\n                // mark the current substring as being able to be broken into words, and add the \\n                // starting index of the next substring to the queue to be processed later\\n                if (bag.count(builder) && dp[start] && !dp[i + 1]) {\\n                    q.push(i + 1);\\n                    dp[i + 1] = true;\\n                }\\n            }\\n        }\\n        \\n        // Return the value of the last element of the dp array, which represents whether \\n        // the entire string can be broken into words\\n        return dp[s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943110,
                "title": "c-dp-easy-and-fast-100",
                "content": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    vector<int> dp;\\n\\n    bool dfs(int i, string s, vector<string>& wordDict){\\n        if(i == n)\\n            return true;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n        for(auto word : wordDict){\\n            int sz = word.size();\\n            if(sz > n-i)\\n                continue;\\n            string newWord = s.substr(i, sz);\\n\\n            if(word == newWord)\\n                ans |= dfs(i+sz, s, wordDict);\\n\\n            dp[i] = ans;\\n            if(ans == true)\\n                return ans;\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        n = s.size();\\n\\n        dp = vector<int>(n, -1);\\n        return dfs(0, s, wordDict);\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/8b410b2a-8874-4747-83be-08a23177505b_1671818287.144914.png){:style=\\'width:300px\\'}",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    int n;\\n    vector<int> dp;\\n\\n    bool dfs(int i, string s, vector<string>& wordDict){\\n        if(i == n)\\n            return true;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n        for(auto word : wordDict){\\n            int sz = word.size();\\n            if(sz > n-i)\\n                continue;\\n            string newWord = s.substr(i, sz);\\n\\n            if(word == newWord)\\n                ans |= dfs(i+sz, s, wordDict);\\n\\n            dp[i] = ans;\\n            if(ans == true)\\n                return ans;\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        n = s.size();\\n\\n        dp = vector<int>(n, -1);\\n        return dfs(0, s, wordDict);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442365,
                "title": "java-dp-1ms-99-91-dp",
                "content": "Key Optimization over standard DP:\\n1. sort all unique length in wordDict by ascending order \\n2. iterate over len only, when length is more than sub-problem length, no need to check further\\n\\n```java\\nclass Solution {\\n    Set<String> set = new HashSet<>();\\n    int[] lens;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        // create unique and ascending word length array\\n        int n = s.length(), j;\\n        prep(set, wordDict, n);\\n        boolean[] dp = new boolean[n+1];\\n\\n        // start dp\\n        dp[0] = true;\\n        for (int i = 1; i <= n; i++) for (int x : lens) { // inner loop: iterate over len\\n            if ((j = i - x) < 0) break; // key: early termination on len\\n            if (dp[j] && set.contains(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private void prep(Set<String> set, List<String> wordDict, int n) {\\n        Set<Integer> lenSet = new HashSet<>();\\n        for (String w : wordDict) {\\n            set.add(w);\\n            lenSet.add(w.length());\\n        }\\n\\n        // convert lenSet to int[] and sort it for speed and early termination\\n        lens = new int[lenSet.size()]; int k = 0;\\n        for (int x : lenSet) lens[k++] = x;\\n        Arrays.sort(lens);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    Set<String> set = new HashSet<>();\\n    int[] lens;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        // create unique and ascending word length array\\n        int n = s.length(), j;\\n        prep(set, wordDict, n);\\n        boolean[] dp = new boolean[n+1];\\n\\n        // start dp\\n        dp[0] = true;\\n        for (int i = 1; i <= n; i++) for (int x : lens) { // inner loop: iterate over len\\n            if ((j = i - x) < 0) break; // key: early termination on len\\n            if (dp[j] && set.contains(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private void prep(Set<String> set, List<String> wordDict, int n) {\\n        Set<Integer> lenSet = new HashSet<>();\\n        for (String w : wordDict) {\\n            set.add(w);\\n            lenSet.add(w.length());\\n        }\\n\\n        // convert lenSet to int[] and sort it for speed and early termination\\n        lens = new int[lenSet.size()]; int k = 0;\\n        for (int x : lenSet) lens[k++] = x;\\n        Arrays.sort(lens);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316020,
                "title": "c-dp-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool>dp(s.size(),false);\\n        dp[0]=true;\\n        \\n        for(int i = 0; i <= s.size(); i++)\\n        {\\n            for(auto str: wordDict)\\n            {\\n                if(dp[i])\\n                {\\n                    if(s.substr(i,str.size()).compare(str)==0)\\n                    {\\n                        dp[i+str.size()]=true;\\n                    }\\n                }\\n            }\\n        }return dp[s.size()];    \\n    }\\n};\\n```\\n**Please Upvote!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool>dp(s.size(),false);\\n        dp[0]=true;\\n        \\n        for(int i = 0; i <= s.size(); i++)\\n        {\\n            for(auto str: wordDict)\\n            {\\n                if(dp[i])\\n                {\\n                    if(s.substr(i,str.size()).compare(str)==0)\\n                    {\\n                        dp[i+str.size()]=true;\\n                    }\\n                }\\n            }\\n        }return dp[s.size()];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101379,
                "title": "0ms-100-fast-top-down-dp-solution",
                "content": "Here to optimize the time and space compleixity I\\'ve passed the string by reference and used \"short\" data type instead of \"int\" to store the dp values!\\nI\\'ve used an unordered map to store the frequency of all the strings, and then used recursion + memorization.\\n\\nFeel free to share any opinions (o\\uFF9F\\u25BD\\uFF9F)o\\n```\\nclass Solution {\\npublic:\\n    bool partition(int curr,int last_break,string &s,unordered_map<string,int>& m,short dp[],int mx)\\n    {\\n        if(dp[last_break]!=-1) \\n            return dp[last_break]; // returning the ans stored in dp[last_break] as we\\'ve encountered this case in past\\n        if(last_break-curr>mx)\\n            return dp[last_break]=0;  // returning 0 in case the length difference becomes greater than the max length of strings\\n        if(curr==0)\\n        {\\n            string t=s.substr(curr,last_break-curr);\\n            if(m[t]>0)\\n            return 1;\\n            return 0;\\n        }\\n        string t=s.substr(curr,last_break-curr);\\n        if(m[t]>0)  // checking if there exists a substring from curr_index to last_break-1 in the dictionary\\n        {\\n            if(partition(curr-1,curr,s,m,dp,mx))\\n            return dp[curr]=1;  // if yes then returning 1 as the answer\\n            dp[curr]=0;\\n        }\\n        if(partition(curr-1,last_break,s,m,dp,mx))\\n        return dp[last_break]=1;\\n        return dp[last_break]=0;\\n    }\\n    int wordBreak(string A, vector<string> &B) {\\n        //code here\\n        unordered_map<string,int> m;\\n        int n=A.size();\\n        short dp[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=-1;\\n        int mx=0;\\n        for(auto it: B)\\n        {\\n            m[it]++;\\n            if(it.size()>mx)\\n                mx=it.size();\\n        }\\n        if(partition(n-1,n,A,m,dp,mx))\\n        return 1;\\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool partition(int curr,int last_break,string &s,unordered_map<string,int>& m,short dp[],int mx)\\n    {\\n        if(dp[last_break]!=-1) \\n            return dp[last_break]; // returning the ans stored in dp[last_break] as we\\'ve encountered this case in past\\n        if(last_break-curr>mx)\\n            return dp[last_break]=0;  // returning 0 in case the length difference becomes greater than the max length of strings\\n        if(curr==0)\\n        {\\n            string t=s.substr(curr,last_break-curr);\\n            if(m[t]>0)\\n            return 1;\\n            return 0;\\n        }\\n        string t=s.substr(curr,last_break-curr);\\n        if(m[t]>0)  // checking if there exists a substring from curr_index to last_break-1 in the dictionary\\n        {\\n            if(partition(curr-1,curr,s,m,dp,mx))\\n            return dp[curr]=1;  // if yes then returning 1 as the answer\\n            dp[curr]=0;\\n        }\\n        if(partition(curr-1,last_break,s,m,dp,mx))\\n        return dp[last_break]=1;\\n        return dp[last_break]=0;\\n    }\\n    int wordBreak(string A, vector<string> &B) {\\n        //code here\\n        unordered_map<string,int> m;\\n        int n=A.size();\\n        short dp[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=-1;\\n        int mx=0;\\n        for(auto it: B)\\n        {\\n            m[it]++;\\n            if(it.size()>mx)\\n                mx=it.size();\\n        }\\n        if(partition(n-1,n,A,m,dp,mx))\\n        return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665660,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func wordBreak(_ s: String, _ wd: [String]) -> Bool {\\n        guard !s.isEmpty else { return false }\\n        let len = s.count, wdset = Set(wd)\\n        let arrS = Array(s), maxw = wdset.reduce(0, { max($0, $1.count) })\\n        \\n        var dp = [Bool](repeating: false, count: len + 1)\\n        dp[0] = true\\n        \\n        for a in 0..<len where dp[a] {\\n            for b in a + 1...(min(len, a + 1 + maxw)) where wdset.contains(String(arrS[a..<b])) {\\n                dp[b] = true\\n            }\\n        }\\n        return dp[len]\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.016 (0.018) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Return true because \"leetcode\" can be segmented as \"leet code\".\\n    func test0() {\\n        let value = solution.wordBreak(\"leetcode\", [\"leet\",\"code\"])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    // Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"applepenapple\", [\"apple\",\"pen\"])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func wordBreak(_ s: String, _ wd: [String]) -> Bool {\\n        guard !s.isEmpty else { return false }\\n        let len = s.count, wdset = Set(wd)\\n        let arrS = Array(s), maxw = wdset.reduce(0, { max($0, $1.count) })\\n        \\n        var dp = [Bool](repeating: false, count: len + 1)\\n        dp[0] = true\\n        \\n        for a in 0..<len where dp[a] {\\n            for b in a + 1...(min(len, a + 1 + maxw)) where wdset.contains(String(arrS[a..<b])) {\\n                dp[b] = true\\n            }\\n        }\\n        return dp[len]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Return true because \"leetcode\" can be segmented as \"leet code\".\\n    func test0() {\\n        let value = solution.wordBreak(\"leetcode\", [\"leet\",\"code\"])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    // Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"applepenapple\", [\"apple\",\"pen\"])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064004,
                "title": "python-code-using-dp-with-visualization-and-explanation",
                "content": "I found out many of posts even though said `detailed explanation` and `easy to understand` but they didnt put or barly put explanation there... \\nSo here you are:\\n\\nLet\\'s use the string \"catsandog\" as an example. By using dp, the foundamental logic is we divide the string to two parts: prefix and right side string. Let\\'s say prefix is \"c\" then rightside is \"atsandog\" etc. Then we initialize a array with the length len(s) + 1 and for index 0 with True and all other with False. So it will be:\\n`prefixChecks = [T, F,F,F,F,F,F,F,F, F]` which represent the string `_catsandog`. Before `c` there should be a empty string and we can think of empty string is always existed in both string and word_dic so that\\'s why we initialized with True here.\\n\\nThen we have a nested loop, `isPrefixDecmposed` will get if the prefix before the current index whether is decomposable which measn it existed in word_dict. If it is and our rightside of current idx, which also included, is also in word_dict, then we update `prefixChecks[i] = True` and break inner loop.\\n\\n\\n```\\ndef wordBreak(strings, wordDict):\\n    prefixChecks = [False for i in range(len(strings) + 1)]\\n    prefixChecks[0] = True\\n\\n    for i in range(len(strings) + 1):\\n        for j in range(i):\\n            isPrefixDecmposed = prefixChecks[j]\\n            rightSideString = strings[j:i]\\n            if isPrefixDecmposed and rightSideString in wordDict:\\n                prefixChecks[i] = True\\n                break\\n    return prefixChecks[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef wordBreak(strings, wordDict):\\n    prefixChecks = [False for i in range(len(strings) + 1)]\\n    prefixChecks[0] = True\\n\\n    for i in range(len(strings) + 1):\\n        for j in range(i):\\n            isPrefixDecmposed = prefixChecks[j]\\n            rightSideString = strings[j:i]\\n            if isPrefixDecmposed and rightSideString in wordDict:\\n                prefixChecks[i] = True\\n                break\\n    return prefixChecks[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1017085,
                "title": "simple-python-solution-w-memoization",
                "content": "The main idea is to check if s begins with any dict words. If we find one, strip it off of s and make recursive call with that new s. If we end up with the empty string return true.\\n\\nThis results in 0(2^n) but if we store every substring in a map that maps to True if we\\'ve already solved for that substring, it becomes 0(n^2)\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, wordDict, memo)\\n        \\n    \\n    def helper(self, s, wordDict, memo):\\n        # base case: if word is empty its in dict or we\\'ve stripped off every word and result is empty\\n        if len(s) == 0:\\n            return True\\n        elif s in memo:\\n            return memo[s]\\n        \\n        for word in wordDict:\\n            # check if any words in dictionary are in the beginning of s\\n            prefix = s[0:len(word)]\\n            \\n            # if we found a match, recursive call with that part stripped off\\n            if prefix == word and self.helper(s[len(word):], wordDict, memo):\\n                memo[prefix] = True\\n                return True\\n                \\n        memo[s] = False\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, wordDict, memo)\\n        \\n    \\n    def helper(self, s, wordDict, memo):\\n        # base case: if word is empty its in dict or we\\'ve stripped off every word and result is empty\\n        if len(s) == 0:\\n            return True\\n        elif s in memo:\\n            return memo[s]\\n        \\n        for word in wordDict:\\n            # check if any words in dictionary are in the beginning of s\\n            prefix = s[0:len(word)]\\n            \\n            # if we found a match, recursive call with that part stripped off\\n            if prefix == word and self.helper(s[len(word):], wordDict, memo):\\n                memo[prefix] = True\\n                return True\\n                \\n        memo[s] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890163,
                "title": "java-memorized-recursion-and-dynamic-programming-solutions",
                "content": "This is a popular question. To solve this, a more intuitive solution is recursion. But a trivial recurstion will return TLE, which is not accepted. We can apply a memorized recursion here to reduce the time complexity, to which is acceptable.\\n\\nIt is worth to note that, memorized recursion can be deemed as a top down dynamic programming solution. Then we can also propose a bottom up dynamic programming solution, which is the solution 2 below.\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t// Solution 1: Memorized Recursion\\n         Set<String> set = new HashSet<>();\\n         Map<String, Boolean> map = new HashMap<>();\\n         for (String a : wordDict) {\\n             set.add(a);\\n         }\\n         return canBreak(s, set, map);\\n     }\\n    \\n     public boolean canBreak(String s, Set<String> set, Map<String, Boolean> map) {\\n         if (map.containsKey(s)) return map.get(s);\\n         if (set.contains(s)) {\\n             map.put(s, true);\\n             return true;\\n         }\\n         for (int i=0; i<s.length(); i++) {\\n             if (set.contains(s.substring(0, i+1)) && canBreak(s.substring(i+1, s.length()), set, map)) {\\n                 map.put(s.substring(i+1, s.length()), true);\\n                 return true;\\n             }                \\n         }\\n         map.put(s, false);\\n         return false;\\n\\t}\\n}\\n        \\n\\t// Solution 2: Dynamic Programming       \\n//        Set<String> set = new HashSet<>();\\n//        for (String a : wordDict) {\\n//            set.add(a);\\n//        }\\n//        if (set.contains(s)) return true;\\n//        int[] dp = new int[s.length() + 1];\\n//        dp[0] = 1; // end with 0, which is \"\", is true\\n//        for (int i=1; i<s.length()+1; i++) {\\n//            for (int j=0; j<i; j++) {\\n//                if (dp[j] == 1 && set.contains(s.substring(j, i))) {\\n//                    dp[i] = 1;\\n//                    break;\\n//                }\\n//            }\\n//        }\\n//        return dp[s.length()] == 1 ? true : false;\\n//    }\\n//}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t// Solution 1: Memorized Recursion\\n         Set<String> set = new HashSet<>();\\n         Map<String, Boolean> map = new HashMap<>();\\n         for (String a : wordDict) {\\n             set.add(a);\\n         }\\n         return canBreak(s, set, map);\\n     }\\n    \\n     public boolean canBreak(String s, Set<String> set, Map<String, Boolean> map) {\\n         if (map.containsKey(s)) return map.get(s);\\n         if (set.contains(s)) {\\n             map.put(s, true);\\n             return true;\\n         }\\n         for (int i=0; i<s.length(); i++) {\\n             if (set.contains(s.substring(0, i+1)) && canBreak(s.substring(i+1, s.length()), set, map)) {\\n                 map.put(s.substring(i+1, s.length()), true);\\n                 return true;\\n             }                \\n         }\\n         map.put(s, false);\\n         return false;\\n\\t}\\n}\\n        \\n\\t// Solution 2: Dynamic Programming       \\n//        Set<String> set = new HashSet<>();\\n//        for (String a : wordDict) {\\n//            set.add(a);\\n//        }\\n//        if (set.contains(s)) return true;\\n//        int[] dp = new int[s.length() + 1];\\n//        dp[0] = 1; // end with 0, which is \"\", is true\\n//        for (int i=1; i<s.length()+1; i++) {\\n//            for (int j=0; j<i; j++) {\\n//                if (dp[j] == 1 && set.contains(s.substring(j, i))) {\\n//                    dp[i] = 1;\\n//                    break;\\n//                }\\n//            }\\n//        }\\n//        return dp[s.length()] == 1 ? true : false;\\n//    }\\n//}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870697,
                "title": "trie-dp-gg",
                "content": "If we use a trie, we don\\'t need to test substrings against every word in `wordDict`.\\n\\nFirst, construct a trie from `wordDict`. Now, for each character in `s` we can traverse from one node to the next in the trie, or if we reach the end of a word, we can insert a space and go back to the root of the trie. It\\'s possible that we could break up a substring into words in multiple ways, but once we determine that it\\'s possible to do it one way, there is no need to find the solution again. This is why `@lru_cache` is used to automatically enable dynamic programming. Without this, the algorithm times out.\\n\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n        for word in wordDict:\\n            node = trie\\n            for c in word:\\n                node = node[c]\\n            node[\\'$\\'] = None\\n            \\n        @lru_cache(None)\\n        def space(i: int) -> bool:\\n            return traverse(trie, i)\\n            \\n        def traverse(node, i):\\n            if i == len(s):\\n                return \\'$\\' in node\\n            c = s[i]\\n            if c in node:\\n                if traverse(node[c], i + 1):\\n                    return True\\n            if \\'$\\' in node:\\n                if space(i):\\n                    return True\\n            \\n            return False\\n            \\n        return space(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n        for word in wordDict:\\n            node = trie\\n            for c in word:\\n                node = node[c]\\n            node[\\'$\\'] = None\\n            \\n        @lru_cache(None)\\n        def space(i: int) -> bool:\\n            return traverse(trie, i)\\n            \\n        def traverse(node, i):\\n            if i == len(s):\\n                return \\'$\\' in node\\n            c = s[i]\\n            if c in node:\\n                if traverse(node[c], i + 1):\\n                    return True\\n            if \\'$\\' in node:\\n                if space(i):\\n                    return True\\n            \\n            return False\\n            \\n        return space(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707358,
                "title": "java-dp-top-down",
                "content": "* Break the string if the first part of it is in the set of dictionary words\\n* Check that the rest of the string can be also broken into dictionary words by doing a recursive call\\n* This is divide and concur.\\n* There are overlapping subproblems so memoize\\n```\\nclass Solution {\\n    Set<String> set;\\n    Map<String, Boolean> map;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        set = new HashSet<>(wordDict);\\n        map = new HashMap<>();\\n        \\n        return check(s);\\n    }\\n    \\n    public boolean check(String s) {\\n        if(s.length() == 0 || set.contains(s)) return true;\\n        if(map.containsKey(s)) return map.get(s);\\n        for(int i = 1; i <= s.length() - 1; i++) {\\n            if(set.contains(s.substring(0, i)) && check(s.substring(i))) {\\n                map.put(s, true);\\n                return true;\\n            }\\n        }\\n        map.put(s, false);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<String> set;\\n    Map<String, Boolean> map;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        set = new HashSet<>(wordDict);\\n        map = new HashMap<>();\\n        \\n        return check(s);\\n    }\\n    \\n    public boolean check(String s) {\\n        if(s.length() == 0 || set.contains(s)) return true;\\n        if(map.containsKey(s)) return map.get(s);\\n        for(int i = 1; i <= s.length() - 1; i++) {\\n            if(set.contains(s.substring(0, i)) && check(s.substring(i))) {\\n                map.put(s, true);\\n                return true;\\n            }\\n        }\\n        map.put(s, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632205,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n---\\n\\n**Top-Down:** Recursively `go()` explore each `i`<sup>th</sup> index of the input string `s` as a subproblem with the goal of reaching `N`, the cardinality of `s`.  The base case occurs when `i == N`, ie. we can reach the empty string without having to do anything, so we can return `true`.  Then we see if each candidate `cand` substring `s[i..j)` (from `i` inclusive to `j` non-inclusive) has been `seen` in the input array `A`.  If so, then we recursively explore the `j`<sup>th</sup> subproblem.  As the recursive stack unwinds, each `i`<sup>th</sup> subproblem is set to `true` if and only if the candidate `cand` substring `s[i..j)` has been `seen` and the `j`<sup>th</sup> subproblem was also previously set to `true`, ie. we are attempting to \"append\" each candidate `cand` substring `s[i..j)` onto previously found `j`<sup>th</sup> subproblem solutions.\\n\\n**Bottom-Up:** Let `dp[i]` denote the `i`<sup>th</sup> index of the input string `s` is reachable.  Explicitly set the base case `dp[N] = true` to denote the empty string is reachable.  Then iteratively explore each candidate `cand` substring `s[i..j)` attempting to build upon each previously found `j`<sup>th</sup> subproblem solution to mimic the recursive stack unwinding from `i = N - 1..0` inclusive.\\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            for (j in i + 1..N) {\\n                var cand = s.substring(i, j)\\n                if (seen.contains(cand) && go(j))\\n                    return true\\n            }\\n            return false\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Boolean>()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            if (!m.contains(i)) {\\n                m[i] = false\\n                for (j in i + 1..N) {\\n                    var cand = s.substring(i, j)\\n                    if (seen.contains(cand) && go(j))\\n                        m[i] = true\\n                }\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        var dp = BooleanArray(N + 1) { false }\\n        dp[N] = true\\n        for (i in N - 1 downTo 0) {\\n            for (j in i + 1..N) {\\n                if (!dp[j])\\n                    continue\\n                var cand = s.substring(i, j)\\n                if (seen.contains(cand))\\n                    dp[i] = true\\n            }\\n        }\\n        return dp[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet wordBreak = (s, A) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = s.substring(i, j);\\n            if (seen.has(cand) && go(j))\\n                return true;\\n        }\\n        return false;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet wordBreak = (s, A, m = new Map()) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        if (!m.has(i)) {\\n            m.set(i, false);\\n            for (let j = i + 1; j <= N; ++j) {\\n                let cand = s.substring(i, j);\\n                if (seen.has(cand) && go(j))\\n                    m.set(i, true);\\n            }\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet wordBreak = (s, A, m = new Map()) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let dp = Array(N + 1).fill(false);\\n    dp[N] = true;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        for (let j = i + 1; j <= N; ++j) {\\n            if (!dp[j])\\n                continue;\\n            let cand = s.substring(i, j);\\n            if (seen.has(cand))\\n                dp[i] = true;\\n        }\\n    }\\n    return dp[0];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            j = i + 1\\n            while j <= N:\\n                cand = s[i:j]\\n                if cand in seen:\\n                    return go(j)\\n                j += 1\\n            return False\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        @cache\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            j = i + 1\\n            while j <= N:\\n                cand = s[i:j]\\n                if cand in seen and go(j):\\n                    return True\\n                j += 1\\n            return False\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        dp = [False] * (N + 1)\\n        dp[N] = True\\n        for i in range(N - 1, -1, -1):\\n            for j in range(i + 1, N + 1):\\n                if not dp[j]:\\n                    continue\\n                cand = s[i:j]\\n                if cand in seen:\\n                    dp[i] = True\\n        return dp[0]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\n// TODO: how to implement a recursive closure which captures the outter-scope?\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\ntype VS = Vec<String>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn word_break(S: String, A: VS) -> bool {\\n        let seen = A.iter().map(|s| &s[..]).collect::<HashSet<&str>>();\\n        let N = S.len();\\n        let mut dp = vec![false; N + 1];       // \\uD83E\\uDD14 memo\\n        dp[N] = true;                          // \\uD83D\\uDED1 base case\\n        for i in (0..N).rev() {\\n            for k in 1..=N - i {\\n                dp[i] |= seen.contains(&&S[i..i + k]) && dp[i + k];  // \\uD83C\\uDFAF recurrence relation target\\n            }\\n        }\\n        dp[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int)>;\\n    bool wordBreak(string s, VS& A) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            for (auto j{ 1 }; i + j <= N; ++j) {\\n                auto cand = s.substr(i, j);\\n                if (seen.find(cand) != seen.end() && go(i + j))\\n                    return true;\\n            }\\n            return false;\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, bool>;\\n    bool wordBreak(string s, VS& A, Map m = {}) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            if (m.find(i) == m.end()) {\\n                for (auto j{ 1 }; i + j <= N; ++j) {\\n                    auto cand = s.substr(i, j);\\n                    if (seen.find(cand) != seen.end() && go(i + j))\\n                        m[i] = true;\\n                }\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VI = vector<int>;\\n    using Set = unordered_set<string>;\\n    bool wordBreak(string s, VS& A) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        VI dp(N + 1);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            for (auto j{ 1 }; i + j <= N; ++j) {\\n                if (!dp[i + j])\\n                    continue;\\n                auto cand = s.substr(i, j);\\n                if (seen.find(cand) != seen.end())\\n                    dp[i] = 1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            for (j in i + 1..N) {\\n                var cand = s.substring(i, j)\\n                if (seen.contains(cand) && go(j))\\n                    return true\\n            }\\n            return false\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Boolean>()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            if (!m.contains(i)) {\\n                m[i] = false\\n                for (j in i + 1..N) {\\n                    var cand = s.substring(i, j)\\n                    if (seen.contains(cand) && go(j))\\n                        m[i] = true\\n                }\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        var dp = BooleanArray(N + 1) { false }\\n        dp[N] = true\\n        for (i in N - 1 downTo 0) {\\n            for (j in i + 1..N) {\\n                if (!dp[j])\\n                    continue\\n                var cand = s.substring(i, j)\\n                if (seen.contains(cand))\\n                    dp[i] = true\\n            }\\n        }\\n        return dp[0]\\n    }\\n}\\n```\n```\\nlet wordBreak = (s, A) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = s.substring(i, j);\\n            if (seen.has(cand) && go(j))\\n                return true;\\n        }\\n        return false;\\n    };\\n    return go();\\n};\\n```\n```\\nlet wordBreak = (s, A, m = new Map()) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        if (!m.has(i)) {\\n            m.set(i, false);\\n            for (let j = i + 1; j <= N; ++j) {\\n                let cand = s.substring(i, j);\\n                if (seen.has(cand) && go(j))\\n                    m.set(i, true);\\n            }\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet wordBreak = (s, A, m = new Map()) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let dp = Array(N + 1).fill(false);\\n    dp[N] = true;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        for (let j = i + 1; j <= N; ++j) {\\n            if (!dp[j])\\n                continue;\\n            let cand = s.substring(i, j);\\n            if (seen.has(cand))\\n                dp[i] = true;\\n        }\\n    }\\n    return dp[0];\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            j = i + 1\\n            while j <= N:\\n                cand = s[i:j]\\n                if cand in seen:\\n                    return go(j)\\n                j += 1\\n            return False\\n        return go()\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        @cache\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            j = i + 1\\n            while j <= N:\\n                cand = s[i:j]\\n                if cand in seen and go(j):\\n                    return True\\n                j += 1\\n            return False\\n        return go()\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        dp = [False] * (N + 1)\\n        dp[N] = True\\n        for i in range(N - 1, -1, -1):\\n            for j in range(i + 1, N + 1):\\n                if not dp[j]:\\n                    continue\\n                cand = s[i:j]\\n                if cand in seen:\\n                    dp[i] = True\\n        return dp[0]\\n```\n```\\n// TODO: how to implement a recursive closure which captures the outter-scope?\\n```\n```\\ntype VS = Vec<String>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn word_break(S: String, A: VS) -> bool {\\n        let seen = A.iter().map(|s| &s[..]).collect::<HashSet<&str>>();\\n        let N = S.len();\\n        let mut dp = vec![false; N + 1];       // \\uD83E\\uDD14 memo\\n        dp[N] = true;                          // \\uD83D\\uDED1 base case\\n        for i in (0..N).rev() {\\n            for k in 1..=N - i {\\n                dp[i] |= seen.contains(&&S[i..i + k]) && dp[i + k];  // \\uD83C\\uDFAF recurrence relation target\\n            }\\n        }\\n        dp[0]\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int)>;\\n    bool wordBreak(string s, VS& A) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            for (auto j{ 1 }; i + j <= N; ++j) {\\n                auto cand = s.substr(i, j);\\n                if (seen.find(cand) != seen.end() && go(i + j))\\n                    return true;\\n            }\\n            return false;\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, bool>;\\n    bool wordBreak(string s, VS& A, Map m = {}) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            if (m.find(i) == m.end()) {\\n                for (auto j{ 1 }; i + j <= N; ++j) {\\n                    auto cand = s.substr(i, j);\\n                    if (seen.find(cand) != seen.end() && go(i + j))\\n                        m[i] = true;\\n                }\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VI = vector<int>;\\n    using Set = unordered_set<string>;\\n    bool wordBreak(string s, VS& A) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        VI dp(N + 1);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            for (auto j{ 1 }; i + j <= N; ++j) {\\n                if (!dp[i + j])\\n                    continue;\\n                auto cand = s.substr(i, j);\\n                if (seen.find(cand) != seen.end())\\n                    dp[i] = 1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492700,
                "title": "javascript-simple-solution-using-dfs",
                "content": "```\\nvar  wordBreak = function(s,wordDict) {\\n        let set = new Set(wordDict);\\n        let cache = new Map();\\n        return recurFind(set, s, cache);\\n    }\\n    \\n    function recurFind(set, s, cache) {\\n        if (cache.has(s)){\\n            return cache.get(s);\\n        } \\n        if (set.has(s)) return true;\\n        for (let i = 1; i < s.length; i++) {\\n            if (set.has(s.substring(0, i)) && recurFind(set, s.substring(i, s.length), cache)) {\\n                cache.set(s,true);\\n                return true;   \\n            }\\n        }\\n        cache.set(s,false);\\n        return false;\\n    }\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar  wordBreak = function(s,wordDict) {\\n        let set = new Set(wordDict);\\n        let cache = new Map();\\n        return recurFind(set, s, cache);\\n    }\\n    \\n    function recurFind(set, s, cache) {\\n        if (cache.has(s)){\\n            return cache.get(s);\\n        } \\n        if (set.has(s)) return true;\\n        for (let i = 1; i < s.length; i++) {\\n            if (set.has(s.substring(0, i)) && recurFind(set, s.substring(i, s.length), cache)) {\\n                cache.set(s,true);\\n                return true;   \\n            }\\n        }\\n        cache.set(s,false);\\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378192,
                "title": "trie-bfs-1ms-with-99-68-time-and-94-memory",
                "content": "I followed these steps. \\n\\n1. Build Trie Tree of words. \\n2. Run BFS to try out all options. \\n\\nclass Solution {\\n    \\n    class TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        \\n        TrieNode t = new TrieNode();\\n        for(String word:wordDict){\\n            insertString(word, t);\\n        }\\n        \\n        return helper(s.toCharArray(), 0, t);\\n        \\n    }\\n    \\n    public boolean helper(char[] charArray, int startIndex, TrieNode root){\\n    \\n                \\n        Queue<TrieNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        boolean[] visited = new boolean[charArray.length];\\n        \\n        while(!queue.isEmpty() && startIndex < charArray.length) {\\n            \\n            int size = queue.size();\\n                        \\n            for(int i=0;i<size;i++){\\n                TrieNode t = queue.poll();    \\n                 if(t.children[charArray[startIndex]-\\'a\\'] != null){\\n                    queue.add(t.children[charArray[startIndex]-\\'a\\']);\\n                    if(t.children[charArray[startIndex]-\\'a\\'].isWord && !visited[startIndex]){\\n                        queue.add(root);\\n                        visited[startIndex] = true;\\n                    }\\n               \\n                }\\n            }\\n            \\n            if(queue.size() != 0)\\n                startIndex++;        \\n           \\n        }\\n                \\n        if(startIndex == charArray.length && visited[startIndex-1]){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public void insertString(String s, TrieNode t){\\n        \\n        char[] charArray = s.toCharArray();\\n        \\n        for(int i=0;i<charArray.length;i++) {\\n            \\n            if(t.children[charArray[i]-\\'a\\'] == null){\\n              t.children[charArray[i]-\\'a\\'] = new TrieNode();\\n            }\\n            \\n             t = t.children[charArray[i]-\\'a\\'];\\n            \\n        }\\n        \\n        t.isWord = true;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n    \\n    class TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 318377,
                "title": "c-concise-dp",
                "content": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\tvector<bool> dp(s.size() + 1, false);\\n\\tdp[0] = true;\\n\\tfor(int i = 1; i < dp.size(); i++)\\n\\t\\tfor(string &w : wordDict)\\n\\t\\t\\tif(i >= w.size() && dp[i - w.size()] && s.substr(i - w.size(), w.size()) == w) {\\n\\t\\t\\t\\tdp[i] = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\treturn dp.back();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\tvector<bool> dp(s.size() + 1, false);\\n\\tdp[0] = true;\\n\\tfor(int i = 1; i < dp.size(); i++)\\n\\t\\tfor(string &w : wordDict)\\n\\t\\t\\tif(i >= w.size() && dp[i - w.size()] && s.substr(i - w.size(), w.size()) == w) {\\n\\t\\t\\t\\tdp[i] = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\treturn dp.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215547,
                "title": "c-4ms-using-dp",
                "content": "Time complexity: O(N^2)\\n\\n`dp[i]`: whether the substring starting from index `0` with length `i` could be segmented using the words in the dictionary.\\nThat is to say: `dp[i] = wordBreak(s.substr(0, i))`, where `dp[0]` is set to `true`.\\n\\nThe underlying point is that if `s.substr(0, i)` could be segmented by the dict words, it could **always** be decomposed to `s.substr(0, j) + a-single-word`, where `j < i` and `wordBreak(s.substr(0, j))`  is also `true`. \\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string> &wordDict) {\\n        set<string> word_set(wordDict.begin(), wordDict.end());\\n        auto len_s = s.size();\\n        vector<bool> dp(len_s + 1, false);\\n        dp[0] = true;\\n        for (int i = 0; i <= len_s; ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                if (dp[j] && word_set.find(s.substr(j, i - j)) != word_set.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len_s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string> &wordDict) {\\n        set<string> word_set(wordDict.begin(), wordDict.end());\\n        auto len_s = s.size();\\n        vector<bool> dp(len_s + 1, false);\\n        dp[0] = true;\\n        for (int i = 0; i <= len_s; ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                if (dp[j] && word_set.find(s.substr(j, i - j)) != word_set.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len_s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169669,
                "title": "java-7ms-solution-using-trie",
                "content": "\\n```\\nclass Solution {\\n    class Trie{\\n        boolean isWord;\\n        int height;\\n        Trie[] children;\\n        \\n        public Trie(){\\n            isWord = false;\\n            height = 0;\\n            children = new Trie[26];\\n        }\\n        \\n        public void add(String s){\\n            add(s, 0);\\n        }\\n        \\n        // Helper method for add\\n        public void add(String s, int pos){\\n            if (s.length() == pos){\\n                isWord = true;\\n                return;\\n            }\\n            int index = s.charAt(pos) - \\'a\\';\\n            if (children[index] == null)\\n                children[index] = new Trie();\\n            children[index].add(s, pos+1);\\n            // Update the height of the tree\\n            height = Math.max(height, children[index].height+1);\\n        }\\n        \\n        // Check if the substring is present in the trie\\n        public boolean search(String s, int start, int end){\\n            // Return false if the string is longer than the height of the tree\\n            if (end - start > height)\\n                return false;\\n            if (start == end)\\n                return isWord;\\n            Trie child = children[s.charAt(start) - \\'a\\'];\\n            if (child == null)\\n                return false;\\n            else \\n                return child.search(s, start+1, end);\\n        }\\n        \\n    }\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Trie trie = new Trie();\\n        for (String word: wordDict)\\n            trie.add(word);\\n        \\n        // Idea: s[0:i] can be separated if and only if s[0:j] can be separated\\n        //       and s[j:i] is present in the trie, for some j (0 <= j < i)\\n        boolean[] memo = new boolean[s.length()+1];\\n        memo[0] = true;\\n        for (int i = 1; i < s.length()+1; i++){\\n            for (int j = 0; j < i; j++){\\n                if (memo[j]){\\n                    if (trie.search(s, j, i))\\n                        memo[i] = true;\\n                }\\n            }\\n        }\\n        \\n        return memo[s.length()];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Trie{\\n        boolean isWord;\\n        int height;\\n        Trie[] children;\\n        \\n        public Trie(){\\n            isWord = false;\\n            height = 0;\\n            children = new Trie[26];\\n        }\\n        \\n        public void add(String s){\\n            add(s, 0);\\n        }\\n        \\n        // Helper method for add\\n        public void add(String s, int pos){\\n            if (s.length() == pos){\\n                isWord = true;\\n                return;\\n            }\\n            int index = s.charAt(pos) - \\'a\\';\\n            if (children[index] == null)\\n                children[index] = new Trie();\\n            children[index].add(s, pos+1);\\n            // Update the height of the tree\\n            height = Math.max(height, children[index].height+1);\\n        }\\n        \\n        // Check if the substring is present in the trie\\n        public boolean search(String s, int start, int end){\\n            // Return false if the string is longer than the height of the tree\\n            if (end - start > height)\\n                return false;\\n            if (start == end)\\n                return isWord;\\n            Trie child = children[s.charAt(start) - \\'a\\'];\\n            if (child == null)\\n                return false;\\n            else \\n                return child.search(s, start+1, end);\\n        }\\n        \\n    }\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Trie trie = new Trie();\\n        for (String word: wordDict)\\n            trie.add(word);\\n        \\n        // Idea: s[0:i] can be separated if and only if s[0:j] can be separated\\n        //       and s[j:i] is present in the trie, for some j (0 <= j < i)\\n        boolean[] memo = new boolean[s.length()+1];\\n        memo[0] = true;\\n        for (int i = 1; i < s.length()+1; i++){\\n            for (int j = 0; j < i; j++){\\n                if (memo[j]){\\n                    if (trie.search(s, j, i))\\n                        memo[i] = true;\\n                }\\n            }\\n        }\\n        \\n        return memo[s.length()];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43817,
                "title": "scala-implementation",
                "content": "```\\ndef wordBreak(s: String, wordDict: List[String]): Boolean = {\\n\\tval res = (1 to s.length).foldLeft(List(0)){\\n\\t\\t(acc, i) =>\\n\\t\\t\\tif(acc.exists(x => wordDict.contains(s.substring(x, i)))) //substring is [...)\\n\\t\\t\\t\\ti :: acc\\n\\t\\t\\telse\\n\\t\\t\\t\\tacc\\n\\t}  \\n\\n\\tres.head == s.length\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef wordBreak(s: String, wordDict: List[String]): Boolean = {\\n\\tval res = (1 to s.length).foldLeft(List(0)){\\n\\t\\t(acc, i) =>\\n\\t\\t\\tif(acc.exists(x => wordDict.contains(s.substring(x, i)))) //substring is [...)\\n\\t\\t\\t\\ti :: acc\\n\\t\\t\\telse\\n\\t\\t\\t\\tacc\\n\\t}  \\n\\n\\tres.head == s.length\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 43890,
                "title": "javascript-dp-beats-91-golang-dp-3ms",
                "content": "Javascript:\\n```\\nvar wordBreak = function(s, wordDict) {\\n    if (!wordDict || wordDict.length == 0) return false\\n    var dp = new Array(s.length + 1);\\n    dp.fill(false)\\n    dp[0] = true\\n    \\n    for(var i = 1; i <= s.length; i++) {\\n        for(var j = 0; j < i; j++) {\\n            if(dp[j] && wordDict.indexOf(s.substring(j, i)) >= 0) {\\n                \\n                dp[i] = true\\n                break;\\n            }\\n        }\\n    }\\n    return dp[s.length]\\n};\\n```\\n\\nGolang:\\n\\n```\\nfunc wordBreak(s string, wordDict []string) bool {\\n    if wordDict == nil || len(wordDict) == 0 { return false }\\n    dp := make([]bool, len(s) + 1)\\n    for k, _:= range dp {\\n        dp[k] = false\\n    }\\n\\n    dp[0] = true\\n    sort.Strings(wordDict)\\n\\n    for i := 1; i <= len(s); i++ {\\n        for j := 0; j < i; j++ {\\n            if dp[j] && stringInSlice(s[j:i], wordDict) {\\n                \\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n    return dp[len(s)]\\n}\\n\\n func stringInSlice(str string, list []string) bool {\\n \\tfor _, v := range list {\\n \\t\\tif v == str {\\n \\t\\t\\treturn true\\n \\t\\t}\\n \\t}\\n \\treturn false\\n }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    if (!wordDict || wordDict.length == 0) return false\\n    var dp = new Array(s.length + 1);\\n    dp.fill(false)\\n    dp[0] = true\\n    \\n    for(var i = 1; i <= s.length; i++) {\\n        for(var j = 0; j < i; j++) {\\n            if(dp[j] && wordDict.indexOf(s.substring(j, i)) >= 0) {\\n                \\n                dp[i] = true\\n                break;\\n            }\\n        }\\n    }\\n    return dp[s.length]\\n};\\n```\n```\\nfunc wordBreak(s string, wordDict []string) bool {\\n    if wordDict == nil || len(wordDict) == 0 { return false }\\n    dp := make([]bool, len(s) + 1)\\n    for k, _:= range dp {\\n        dp[k] = false\\n    }\\n\\n    dp[0] = true\\n    sort.Strings(wordDict)\\n\\n    for i := 1; i <= len(s); i++ {\\n        for j := 0; j < i; j++ {\\n            if dp[j] && stringInSlice(s[j:i], wordDict) {\\n                \\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n    return dp[len(s)]\\n}\\n\\n func stringInSlice(str string, list []string) bool {\\n \\tfor _, v := range list {\\n \\t\\tif v == str {\\n \\t\\t\\treturn true\\n \\t\\t}\\n \\t}\\n \\treturn false\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43903,
                "title": "python-solutions-with-detailed-explanations",
                "content": "**Solution**\\n\\n**Word Break** https://leetcode.com/problems/word-break/\\n\\n**Memoization: Time: O(N^2)**\\n* We parameterize the sub-problem as helper(k, s, ..) which answers the question whether we can break the string s[k:] into smaller strings.\\n* In the test cases for this problem, if s is a part of the dictionary, then it can be broken. There is no limitation that we should have atleast two parts.\\n* There are N sub-problems and in each sub problem we do O(N) work. So complexity is N^2.\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        return self.helper(0, s, wordDict, {})\\n\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return True\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            for i in range(k, len(s)):\\n                if s[k:i+1] in wordDict:\\n                    if self.helper(i+1, s, wordDict, cache):\\n                        cache[k] = True\\n                        return True\\n        cache[k] = False\\n        return cache[k]\\n```\\n\\n**Dynamic Programming**\\n* Initialize a table of len(s). table[j] means whether we can break the string s[0:j+1].\\n* For every ending index j, we move towards left and extract every right word. If the word is valid, then we just lookup the table if the left half is breakable or not.\\n* The boundary condition is string of length 0 is breakable. This is implemented when we calculate left_is_breakable.\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        table = [False]*(len(s))\\n        for j in range(len(s)):\\n            for i in range(j, -1, -1):\\n                word_so_far = s[i:j+1]\\n                left_is_breakable = table[i-1] if i > 0 else True \\n                if word_so_far in wordDict and left_is_breakable:\\n                    table[j] = True\\n                    break\\n        return table[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        return self.helper(0, s, wordDict, {})\\n\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return True\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            for i in range(k, len(s)):\\n                if s[k:i+1] in wordDict:\\n                    if self.helper(i+1, s, wordDict, cache):\\n                        cache[k] = True\\n                        return True\\n        cache[k] = False\\n        return cache[k]\\n```\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        table = [False]*(len(s))\\n        for j in range(len(s)):\\n            for i in range(j, -1, -1):\\n                word_so_far = s[i:j+1]\\n                left_is_breakable = table[i-1] if i > 0 else True \\n                if word_so_far in wordDict and left_is_breakable:\\n                    table[j] = True\\n                    break\\n        return table[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43980,
                "title": "two-intuitive-solutions-both-beating-100-submissions-in-c-using-deque-or-stack-instead-of-dp",
                "content": "Actually this problem can be quite simple but intuitively if you treat it that way and using DFS recursive method to solve it, you're bound to get TLE in this test case: \\n>\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nsince there are so many tries till the final failure.\\n\\nSo let's take another look around it:\\n\\n- first we do not really need to check all the length of the substring -> we retrieve the minimal and maximal length of the words in dictionary first -> this operation will save us much time;\\n- using a queue to record the next all possible start index -> suppose we start from index 0 and try length [min, max], there might be several possible ways around, several substrings start in the same index in different lengths fit the dictionary -> at this very moment we record the next start index for later traversal;\\n- at last, let's search the substring (from the start index and try each length [minLen, maxLen] inclusive) in dictionary; now we are to use an array to record whether the start index is visited which will prevent us from another useless try -> this's the major improvement which will ensure us almost linearity of the time complexity;\\n\\n\\nEssence part Done! End of Story!\\n\\n- space complexity can be O(n) or O(kn) k is a special argument which will be explained.\\n- time complexity can be O(n) since we only check the unvisited index.\\n\\nSeveral tricks are used to further improve the performance:\\n\\n- check only limited length of the substring from [min, max] instead of always checking till the end of the string;\\n- storing the length for each word in dictionary, since we are using C, so when we compare the substring with the word in dictionary, we will need to ensure the length for both -> strncmp(word, substring, length);\\n- using a huge deque to imitate the queue instead of two parallel stacks - exchanging space for time and that's why the space complexity can O(kn);\\n\\n----------\\n    //BFS - 0ms;\\n    bool wordBreak(char* s, char** dict, int size)\\n    {\\n        int min=INT_MAX, max=0; //compare only in a limited range of length of the substring actually;\\n        int* lens = (int*)malloc(sizeof(int)*size); //used to compare substring with words;\\n        int lSize = 0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int len = strlen(dict[i]);\\n            lens[lSize++] = len;\\n            if(len < min) min = len;\\n            if(len > max) max = len;\\n        }\\n        int len = strlen(s);\\n        bool* visited = (bool*)malloc(sizeof(bool)*len); //used to record whether the index visited or not;\\n        memset(visited, 0, len*sizeof(bool));\\n        int* queue = (int*)malloc(sizeof(int)*len*100); //avoid parallel stacks' interdenpendency;\\n        int begin=0, end=-1;\\n        queue[++end] = 0;\\n        while(end-begin > -1)\\n        {\\n            int start = queue[begin++]; \\n            if(!visited[start]) //unvisited so far;\\n            {\\n                visited[start] = true; //label it as visited;\\n                for(int j = min; j <= MIN(max, len-start); j++) //check different length of substringfrom the start index;\\n                {\\n                    int i = 0;\\n                    for(; i < size; i++)\\n                        if(lens[i]==j && strncmp(dict[i], s+start, j)==0)\\n                            break;\\n                    if(i != size)\\n                    {\\n                        int next = start+j;\\n                        queue[++end] = next;\\n                        if(next == len)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\nAs you may say, actually we can just use stack to run DFS instead of deque running BFS to achieve the same goal using the same algorithm and tricks ^^.\\n\\nSo amazing! Right! And again it's accepted with 0ms and beating all the other submissions! \\n\\n> I think it should be voted up! Thanks in advance!\\n\\n\\n----------\\n\\n    //DFS - 0ms;\\n    bool wordBreak(char* s, char** dict, int size)\\n    {\\n        int min=INT_MAX, max=0; //compare only in a limited range of length of the substring actually;\\n        int* lens = (int*)malloc(sizeof(int)*size); //used to compare substring with words;\\n        int lSize = 0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int len = strlen(dict[i]);\\n            lens[lSize++] = len;\\n            if(len < min) min = len;\\n            if(len > max) max = len;\\n        }\\n        int len = strlen(s);\\n        bool* visited = (bool*)malloc(sizeof(bool)*len); //used to record whether the index visited or not;\\n        memset(visited, 0, len*sizeof(bool));\\n        int* stack = (int*)malloc(sizeof(int)*len*100); //avoid parallel stacks' interdenpendency;\\n        int top = -1;\\n        stack[++top] = 0;\\n        while(top > -1)\\n        {\\n            int start = stack[top--]; \\n            if(!visited[start]) //unvisited so far;\\n            {\\n                visited[start] = true; //label it as visited;\\n                for(int j = min; j <= MIN(max, len-start); j++) //check different length of substringfrom the start index;\\n                {\\n                    int i = 0;\\n                    for(; i < size; i++)\\n                        if(lens[i]==j && strncmp(dict[i], s+start, j)==0)\\n                            break;\\n                    if(i != size)\\n                    {\\n                        int next = start+j;\\n                        stack[++top] = next;\\n                        if(next == len)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Actually this problem can be quite simple but intuitively if you treat it that way and using DFS recursive method to solve it, you're bound to get TLE in this test case: \\n>\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nsince there are so many tries till the final failure.\\n\\nSo let's take another look around it:\\n\\n- first we do not really need to check all the length of the substring -> we retrieve the minimal and maximal length of the words in dictionary first -> this operation will save us much time;\\n- using a queue to record the next all possible start index -> suppose we start from index 0 and try length [min, max], there might be several possible ways around, several substrings start in the same index in different lengths fit the dictionary -> at this very moment we record the next start index for later traversal;\\n- at last, let's search the substring (from the start index and try each length [minLen, maxLen] inclusive) in dictionary; now we are to use an array to record whether the start index is visited which will prevent us from another useless try -> this's the major improvement which will ensure us almost linearity of the time complexity;\\n\\n\\nEssence part Done! End of Story!\\n\\n- space complexity can be O(n) or O(kn) k is a special argument which will be explained.\\n- time complexity can be O(n) since we only check the unvisited index.\\n\\nSeveral tricks are used to further improve the performance:\\n\\n- check only limited length of the substring from [min, max] instead of always checking till the end of the string;\\n- storing the length for each word in dictionary, since we are using C, so when we compare the substring with the word in dictionary, we will need to ensure the length for both -> strncmp(word, substring, length);\\n- using a huge deque to imitate the queue instead of two parallel stacks - exchanging space for time and that's why the space complexity can O(kn);\\n\\n----------\\n    //BFS - 0ms;\\n    bool wordBreak(char* s, char** dict, int size)\\n    {\\n        int min=INT_MAX, max=0; //compare only in a limited range of length of the substring actually;\\n        int* lens = (int*)malloc(sizeof(int)*size); //used to compare substring with words;\\n        int lSize = 0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int len = strlen(dict[i]);\\n            lens[lSize++] = len;\\n            if(len < min) min = len;\\n            if(len > max) max = len;\\n        }\\n        int len = strlen(s);\\n        bool* visited = (bool*)malloc(sizeof(bool)*len); //used to record whether the index visited or not;\\n        memset(visited, 0, len*sizeof(bool));\\n        int* queue = (int*)malloc(sizeof(int)*len*100); //avoid parallel stacks' interdenpendency;\\n        int begin=0, end=-1;\\n        queue[++end] = 0;\\n        while(end-begin > -1)\\n        {\\n            int start = queue[begin++]; \\n            if(!visited[start]) //unvisited so far;\\n            {\\n                visited[start] = true; //label it as visited;\\n                for(int j = min; j <= MIN(max, len-start); j++) //check different length of substringfrom the start index;\\n                {\\n                    int i = 0;\\n                    for(; i < size; i++)\\n                        if(lens[i]==j && strncmp(dict[i], s+start, j)==0)\\n                            break;\\n                    if(i != size)\\n                    {\\n                        int next = start+j;\\n                        queue[++end] = next;\\n                        if(next == len)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\nAs you may say, actually we can just use stack to run DFS instead of deque running BFS to achieve the same goal using the same algorithm and tricks ^^.\\n\\nSo amazing! Right! And again it's accepted with 0ms and beating all the other submissions! \\n\\n> I think it should be voted up! Thanks in advance!\\n\\n\\n----------\\n\\n    //DFS - 0ms;\\n    bool wordBreak(char* s, char** dict, int size)\\n    {\\n        int min=INT_MAX, max=0; //compare only in a limited range of length of the substring actually;\\n        int* lens = (int*)malloc(sizeof(int)*size); //used to compare substring with words;\\n        int lSize = 0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int len = strlen(dict[i]);\\n            lens[lSize++] = len;\\n            if(len < min) min = len;\\n            if(len > max) max = len;\\n        }\\n        int len = strlen(s);\\n        bool* visited = (bool*)malloc(sizeof(bool)*len); //used to record whether the index visited or not;\\n        memset(visited, 0, len*sizeof(bool));\\n        int* stack = (int*)malloc(sizeof(int)*len*100); //avoid parallel stacks' interdenpendency;\\n        int top = -1;\\n        stack[++top] = 0;\\n        while(top > -1)\\n        {\\n            int start = stack[top--]; \\n            if(!visited[start]) //unvisited so far;\\n            {\\n                visited[start] = true; //label it as visited;\\n                for(int j = min; j <= MIN(max, len-start); j++) //check different length of substringfrom the start index;\\n                {\\n                    int i = 0;\\n                    for(; i < size; i++)\\n                        if(lens[i]==j && strncmp(dict[i], s+start, j)==0)\\n                            break;\\n                    if(i != size)\\n                    {\\n                        int next = start+j;\\n                        stack[++top] = next;\\n                        if(next == len)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43978,
                "title": "4-ms-15-lines-c-dp-solution-easy-to-read",
                "content": "```\\n bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<int> helper(s.size()+1, 0);\\n        helper[0]=1;\\n        for (int i = 0; i < helper.size(); i++) {\\n            for (int j = 0; j < i && !helper[i]; j++) {\\n                if (helper[j] && wordDict.count(s.substr(j,i-j))) {\\n                    helper[i]=1;\\n                }\\n            }\\n        }\\n        return helper[s.size()];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<int> helper(s.size()+1, 0);\\n        helper[0]=1;\\n        for (int i = 0; i < helper.size(); i++) {\\n            for (int j = 0; j < i && !helper[i]; j++) {\\n                if (helper[j] && wordDict.count(s.substr(j,i-j))) {\\n                    helper[i]=1;\\n                }\\n            }\\n        }\\n        return helper[s.size()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44046,
                "title": "share-c-c-4ms-68ms-explained-dynamic-programming-solution",
                "content": "C++ version\\n\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n      // Check Bad Input Values\\n      if(wordDict.size() == 0)\\n        return false;\\n    \\n      if (s.length() == 0)\\n      {\\n        return wordDict.find(s) != wordDict.end();\\n      }\\n    \\n      // Check the whole word first\\n      if (wordDict.find(s) != wordDict.end())\\n        return true;\\n    \\n      int n = s.size();\\n      // Suppose i is the start of a word and j it's end with 0 < i <= j< n\\n      // Lets create a table C (n*n) that check if s(i,j) is breakable\\n      // We have this formula for C[i,j]\\n      // C[i,j] = C[i,j-1] and s[j,j] is in the dictionary\\n      // C[i,j] = s(i,j) is in dictionary\\n      // C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n      bool** C = new bool*[n];\\n      for(int i = 0; i < n; ++i)\\n      {\\n        C[i] = new bool[n];\\n        for(int j = 0; j<n; ++j)\\n        {\\n          // initialiazed to false;\\n          C[i][j] = false;\\n        }\\n      }\\n    \\n      // Fill the diagonal by checking if a word i,i is in the dictionary\\n      for (int i = 0; i < n; ++i)\\n      {\\n        C[i][i] = wordDict.find(s.substr(i,1)) != wordDict.end();\\n      }\\n    \\n      // Compute C[0,j] here\\n      for (int j = 1; j < n; ++j)\\n      {\\n        C[0][j] = C[0][j] ||\\n          (C[0][j - 1] && C[j][ j]) || // C[i,j-1] and s[j,j] is in the dictionary\\n          wordDict.find(s.substr(0, j + 1)) != wordDict.end();//s(i,j) is in dictionary\\n        if (!C[0][ j])\\n        {\\n          // Search for k: C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n          int k = 0;\\n          while (k < j - 1 && !C[0][j])\\n          {\\n            C[k + 1][ j] = (wordDict.find(s.substr(k + 1, j - k)) != wordDict.end());\\n            C[0][ j] = C[0][ k] && C[k + 1][ j];\\n            ++k;\\n          }\\n        }\\n      }\\n    \\n      // Return true if s(0,n-1) is breakable\\n      bool result = C[0][n-1];\\n    \\n      // delete memory\\n      for(int i = 0; i < n; ++i)\\n      {\\n        delete [] C[i];\\n      }\\n    \\n      delete []C;\\n      C=NULL;\\n    \\n      return result;\\n    }\\n\\nC# version\\n\\n    public static bool WordBreak(string s, ISet<string> wordDict)\\n    {\\n      // Check Bad Input Values\\n      if(wordDict == null || wordDict.Count == 0)\\n        return false;\\n      if (string.IsNullOrEmpty(s))\\n        return wordDict.Contains(s);\\n\\n      // Check the whole word first\\n      if (wordDict.Contains(s))\\n        return true;\\n\\n      int n = s.Length;\\n      // Suppose i is the start of a word and j it's end with 0 < i <= j< n\\n      // Lets create a table C (n*n) that check if s(i,j) is breakable\\n      // We have this formula for C[i,j]\\n      // C[i,j] = C[i,j-1] and s[j,j] is in the dictionary\\n      // C[i,j] = s(i,j) is in dictionary\\n      // C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n      bool[,] C = new bool[n,n]; // initialiazed to false;\\n\\n      // Fill the diagonal by checking if a word i,i is in the dictionary\\n      for (int i = 0; i < n; ++i)\\n      {\\n        C[i, i] = wordDict.Contains(s.Substring(i, 1));\\n      }\\n\\n      // Compute C[0,j] here\\n      for (int j = 1; j < n; ++j)\\n      {\\n        C[0, j] = C[0, j] ||\\n          (C[0, j - 1] && C[j, j]) || // C[i,j-1] and s[j,j] is in the dictionary\\n          wordDict.Contains(s.Substring(0, j + 1));//s(i,j) is in dictionary\\n        if (!C[0, j])\\n        {\\n          // Search for k: C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n          int k = 0;\\n          while (k < j - 1 && !C[0, j])\\n          {\\n            C[k + 1, j] = wordDict.Contains(s.Substring(k + 1, j - k));\\n            C[0, j] = C[0, k] && C[k + 1, j];\\n            ++k;\\n          }\\n        }\\n      }\\n\\n      // Return true if s(0,n-1) is breakable\\n      return C[0,n-1];\\n    }",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "C++ version\\n\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n      // Check Bad Input Values\\n      if(wordDict.size() == 0)\\n        return false;\\n    \\n      if (s.length() == 0)\\n      {\\n        return wordDict.find(s) != wordDict.end();\\n      }\\n    \\n      // Check the whole word first\\n      if (wordDict.find(s) != wordDict.end())\\n        return true;\\n    \\n      int n = s.size();\\n      // Suppose i is the start of a word and j it's end with 0 < i <= j< n\\n      // Lets create a table C (n*n) that check if s(i,j) is breakable\\n      // We have this formula for C[i,j]\\n      // C[i,j] = C[i,j-1] and s[j,j] is in the dictionary\\n      // C[i,j] = s(i,j) is in dictionary\\n      // C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n      bool** C = new bool*[n];\\n      for(int i = 0; i < n; ++i)\\n      {\\n        C[i] = new bool[n];\\n        for(int j = 0; j<n; ++j)\\n        {\\n          // initialiazed to false;\\n          C[i][j] = false;\\n        }\\n      }\\n    \\n      // Fill the diagonal by checking if a word i,i is in the dictionary\\n      for (int i = 0; i < n; ++i)\\n      {\\n        C[i][i] = wordDict.find(s.substr(i,1)) != wordDict.end();\\n      }\\n    \\n      // Compute C[0,j] here\\n      for (int j = 1; j < n; ++j)\\n      {\\n        C[0][j] = C[0][j] ||\\n          (C[0][j - 1] && C[j][ j]) || // C[i,j-1] and s[j,j] is in the dictionary\\n          wordDict.find(s.substr(0, j + 1)) != wordDict.end();//s(i,j) is in dictionary\\n        if (!C[0][ j])\\n        {\\n          // Search for k: C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n          int k = 0;\\n          while (k < j - 1 && !C[0][j])\\n          {\\n            C[k + 1][ j] = (wordDict.find(s.substr(k + 1, j - k)) != wordDict.end());\\n            C[0][ j] = C[0][ k] && C[k + 1][ j];\\n            ++k;\\n          }\\n        }\\n      }\\n    \\n      // Return true if s(0,n-1) is breakable\\n      bool result = C[0][n-1];\\n    \\n      // delete memory\\n      for(int i = 0; i < n; ++i)\\n      {\\n        delete [] C[i];\\n      }\\n    \\n      delete []C;\\n      C=NULL;\\n    \\n      return result;\\n    }\\n\\nC# version\\n\\n    public static bool WordBreak(string s, ISet<string> wordDict)\\n    {\\n      // Check Bad Input Values\\n      if(wordDict == null || wordDict.Count == 0)\\n        return false;\\n      if (string.IsNullOrEmpty(s))\\n        return wordDict.Contains(s);\\n\\n      // Check the whole word first\\n      if (wordDict.Contains(s))\\n        return true;\\n\\n      int n = s.Length;\\n      // Suppose i is the start of a word and j it's end with 0 < i <= j< n\\n      // Lets create a table C (n*n) that check if s(i,j) is breakable\\n      // We have this formula for C[i,j]\\n      // C[i,j] = C[i,j-1] and s[j,j] is in the dictionary\\n      // C[i,j] = s(i,j) is in dictionary\\n      // C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n      bool[,] C = new bool[n,n]; // initialiazed to false;\\n\\n      // Fill the diagonal by checking if a word i,i is in the dictionary\\n      for (int i = 0; i < n; ++i)\\n      {\\n        C[i, i] = wordDict.Contains(s.Substring(i, 1));\\n      }\\n\\n      // Compute C[0,j] here\\n      for (int j = 1; j < n; ++j)\\n      {\\n        C[0, j] = C[0, j] ||\\n          (C[0, j - 1] && C[j, j]) || // C[i,j-1] and s[j,j] is in the dictionary\\n          wordDict.Contains(s.Substring(0, j + 1));//s(i,j) is in dictionary\\n        if (!C[0, j])\\n        {\\n          // Search for k: C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n          int k = 0;\\n          while (k < j - 1 && !C[0, j])\\n          {\\n            C[k + 1, j] = wordDict.Contains(s.Substring(k + 1, j - k));\\n            C[0, j] = C[0, k] && C[k + 1, j];\\n            ++k;\\n          }\\n        }\\n      }\\n\\n      // Return true if s(0,n-1) is breakable\\n      return C[0,n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44110,
                "title": "python-code-dp",
                "content": "    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a boolean\\n    \\n                \\n        def wordBreak(self, s, dict):\\n            if s == '':\\n                return True\\n            checklist = [False]*(len(s)+1)\\n            checklist[len(s)] = True\\n            for i in range(len(s)-1,-1,-1):\\n                for j in range(i,len(s)):\\n                    if s[i:j+1] in dict and checklist[j+1]==True:\\n                        checklist[i]=True\\n            return checklist[0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a boolean\\n    \\n                \\n        def wordBreak(self, s, dict):\\n            if s == '':\\n                return True\\n            checklist = [False]*(len(s)+1)\\n            checklist[len(s)] = True\\n            for i in range(len(s)-1,-1,-1):\\n                for j in range(i,len(s)):\\n                    if s[i:j+1] in dict and checklist[j+1]==True:\\n                        checklist[i]=True\\n            return checklist[0]",
                "codeTag": "Java"
            },
            {
                "id": 3863868,
                "title": "bfs-memoization-99-63-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought that comes to mind is prefix, this can be done plainly with BFS, but would lead to memory limit. \\n\\n```Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        q = deque([s])\\n        while q:\\n            remaining = q.popleft()\\n            for word in wordDict:\\n                if remaining == word:\\n                    return True\\n                elif remaining.startswith(word):\\n                    q.append(remaining[len(word):])\\n        return False\\n```\\n```Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    q := []string{s}\\n    for len(q) != 0 {\\n        remaining := q[0]\\n        q = q[1:] // Dequeue\\n        for _, word := range wordDict {\\n            if word == remaining {\\n                return true\\n            }\\n            if strings.HasPrefix(remaining, word) {\\n                q = append(q, remaining[len(word):]) // Enqueue\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\\nTo optimise we add memoization by storing values of strings we\\'ve already processed.\\n\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        q = deque([s])\\n        memo = set()\\n        while q:\\n            remaining = q.popleft()\\n            if remaining in memo:\\n                continue\\n            for word in wordDict:\\n                if remaining == word:\\n                    return True\\n                elif remaining.startswith(word):\\n                    q.append(remaining[len(word):])\\n                    memo.add(remaining)\\n        return False\\n```\\n```golang []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    q := []string{s}\\n    memo := make(map[string]bool)\\n    for len(q) != 0 {\\n        remaining := q[0]\\n        q = q[1:] // Dequeue\\n        if _, ok := memo[remaining]; ok {\\n            continue\\n        }\\n        for _, word := range wordDict {\\n            if word == remaining {\\n                return true\\n            }\\n            if strings.HasPrefix(remaining, word) {\\n                q = append(q, remaining[len(word):]) // Enqueue\\n                memo[remaining] = true\\n            }\\n        }\\n    }\\n    return false\\n}\\n\\n```\\n# Complexity\\n- Time complexity: $$O(N^2 * M)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot 2023-08-05 at 12.40.38 AM.png](https://assets.leetcode.com/users/images/d363daa0-4356-40a8-996f-42d1a912ce98_1691167251.0166585.png)\\n\\n![Screenshot 2023-08-05 at 1.22.13 AM.png](https://assets.leetcode.com/users/images/d779f2f6-2241-419d-b110-2c9b09431eca_1691169748.0013075.png)\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Go"
                ],
                "code": "```Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        q = deque([s])\\n        while q:\\n            remaining = q.popleft()\\n            for word in wordDict:\\n                if remaining == word:\\n                    return True\\n                elif remaining.startswith(word):\\n                    q.append(remaining[len(word):])\\n        return False\\n```\n```Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    q := []string{s}\\n    for len(q) != 0 {\\n        remaining := q[0]\\n        q = q[1:] // Dequeue\\n        for _, word := range wordDict {\\n            if word == remaining {\\n                return true\\n            }\\n            if strings.HasPrefix(remaining, word) {\\n                q = append(q, remaining[len(word):]) // Enqueue\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\n```python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        q = deque([s])\\n        memo = set()\\n        while q:\\n            remaining = q.popleft()\\n            if remaining in memo:\\n                continue\\n            for word in wordDict:\\n                if remaining == word:\\n                    return True\\n                elif remaining.startswith(word):\\n                    q.append(remaining[len(word):])\\n                    memo.add(remaining)\\n        return False\\n```\n```golang []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    q := []string{s}\\n    memo := make(map[string]bool)\\n    for len(q) != 0 {\\n        remaining := q[0]\\n        q = q[1:] // Dequeue\\n        if _, ok := memo[remaining]; ok {\\n            continue\\n        }\\n        for _, word := range wordDict {\\n            if word == remaining {\\n                return true\\n            }\\n            if strings.HasPrefix(remaining, word) {\\n                q = append(q, remaining[len(word):]) // Enqueue\\n                memo[remaining] = true\\n            }\\n        }\\n    }\\n    return false\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863694,
                "title": "c-complete-approach-and-solution",
                "content": "\\n# Approach\\n\\nThe given code is a C++ solution to the word break problem. The problem is defined as follows: Given a string s and a dictionary of strings wordDict, we need to determine if the string s can be segmented into a space-separated sequence of one or more words from the wordDict.\\n\\nLet\\'s break down the code and explain each part:\\n\\nThe code defines a class Solution that contains a function wordBreak that takes the input string s and the dictionary of words dictionary.\\n\\nInside the wordBreak function, the code initializes a vector dp of size s.length() + 1 with all elements set to -1. This vector will be used for memoization to store the results of subproblems to avoid redundant computations.\\n\\nThe main logic is implemented in the help function, which takes the current substring s of length n, the dictionary of words word, and the memoization vector dp.\\n\\nIn the help function, the code first checks if the result for the current substring s is already memoized in the dp vector. If so, it returns the precomputed result to avoid recomputation.\\n\\nThe code then iterates over all possible substrings of s with lengths from 1 to n. For each substring, it checks if it exists in the dictionary wordDict.\\n\\nIf the substring is found in the dictionary, it means that the current substring can be formed using words from the dictionary. If the current substring is equal to the whole string s (i == n), then the word segmentation is successful, and the function returns 1.\\n\\nIf the substring is found in the dictionary and it is not equal to the whole string s, the code calls the help function recursively with the remaining part of the string (i.e., s.substr(i, n)) to check if the remaining part can also be segmented into words from the dictionary. The result of the recursive call is added to the cnt variable.\\n\\nThe cnt variable keeps track of the total number of ways the string s can be segmented into words from the dictionary.\\n\\nFinally, the result of the help function is stored in the dp vector for the current substring s and returned as the result of the wordBreak function.\\n\\nIn the wordBreak function, the result returned by the help function is directly returned to determine whether the string s can be segmented into words from the dictionary.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\t\\tvector<string> v;\\n\\t\\tint help(string s, int n, vector<string> &word,vector<int> &dp)\\n\\t\\t{\\n\\t\\t\\tif(dp[n]!=-1)\\n\\t\\t\\t\\treturn dp[n];\\n            long long cnt = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring ss = s.substr(0, i);\\n\\t\\t\\t\\tint l = word.size();\\n\\t\\t\\t\\tbool flag = false;\\n\\n\\t\\t\\t\\tfor (int j = 0; j < l; j++)\\n\\t\\t\\t\\t\\tif (word[j] == ss)\\n\\t\\t\\t\\t\\t\\tflag = true;\\n\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (i == n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt+=help(s.substr(i, n), n - i, word,dp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n]=cnt;\\n\\t\\t}\\n\\n\\t\\tbool wordBreak(string s, vector<string> &dictionary)\\n\\t\\t{\\n\\t\\t\\tvector<int> dp(s.length()+1,-1);\\n\\t\\t\\treturn help(s, s.size(), dictionary,dp);\\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<string> v;\\n\\t\\tint help(string s, int n, vector<string> &word,vector<int> &dp)\\n\\t\\t{\\n\\t\\t\\tif(dp[n]!=-1)\\n\\t\\t\\t\\treturn dp[n];\\n            long long cnt = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring ss = s.substr(0, i);\\n\\t\\t\\t\\tint l = word.size();\\n\\t\\t\\t\\tbool flag = false;\\n\\n\\t\\t\\t\\tfor (int j = 0; j < l; j++)\\n\\t\\t\\t\\t\\tif (word[j] == ss)\\n\\t\\t\\t\\t\\t\\tflag = true;\\n\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (i == n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt+=help(s.substr(i, n), n - i, word,dp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n]=cnt;\\n\\t\\t}\\n\\n\\t\\tbool wordBreak(string s, vector<string> &dictionary)\\n\\t\\t{\\n\\t\\t\\tvector<int> dp(s.length()+1,-1);\\n\\t\\t\\treturn help(s, s.size(), dictionary,dp);\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861407,
                "title": "memoization-dp-java-simple",
                "content": "# Approach\\n- Memoization DP\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        Boolean[] dp = new Boolean[n];    // dp array\\n        HashSet<String> set = new HashSet<>(wordDict); // for easy searching\\n        return canBreakWord(0, n, s, set, dp);\\n    }\\n\\n    private boolean canBreakWord(int ind, int n, String s, HashSet<String> set, Boolean[] dp){\\n        if (ind == n)\\n            return true;\\n        if (dp[ind] != null)\\n            return dp[ind];\\n        \\n        for (int i = ind; i < n; i++){\\n            if (set.contains(s.substring(ind, i + 1))){\\n                if (canBreakWord(i + 1, n, s, set, dp))\\n                    return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        Boolean[] dp = new Boolean[n];    // dp array\\n        HashSet<String> set = new HashSet<>(wordDict); // for easy searching\\n        return canBreakWord(0, n, s, set, dp);\\n    }\\n\\n    private boolean canBreakWord(int ind, int n, String s, HashSet<String> set, Boolean[] dp){\\n        if (ind == n)\\n            return true;\\n        if (dp[ind] != null)\\n            return dp[ind];\\n        \\n        for (int i = ind; i < n; i++){\\n            if (set.contains(s.substring(ind, i + 1))){\\n                if (canBreakWord(i + 1, n, s, set, dp))\\n                    return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861366,
                "title": "100-faster-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind this problem was to search for a possible dictionary word at every index. For this purpose, a map was created with a vector of strings for the letter they start with.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt every index, if substring was found matching a dictionary word, the same thing is continued until the end of the string was reached.\\nThe dp stores whether a set of words from dictionary can be fused to complete the string from a particular index till the end of string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<char,vector<string>> m;\\n    vector<int> dp;\\n    bool f(string s, int i){\\n        if(i==s.size()){\\n            return true;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        bool ans=false;\\n        for(auto it:m[s[i]]){\\n            if(s.substr(i,it.size())==it){\\n                ans|=f(s,i+it.size());\\n            }\\n        }\\n        return dp[i]=ans;\\n\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        dp.resize(s.size(),-1);\\n        for(auto it:wordDict){\\n            m[it[0]].push_back(it);\\n        }\\n        return f(s,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,vector<string>> m;\\n    vector<int> dp;\\n    bool f(string s, int i){\\n        if(i==s.size()){\\n            return true;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        bool ans=false;\\n        for(auto it:m[s[i]]){\\n            if(s.substr(i,it.size())==it){\\n                ans|=f(s,i+it.size());\\n            }\\n        }\\n        return dp[i]=ans;\\n\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        dp.resize(s.size(),-1);\\n        for(auto it:wordDict){\\n            m[it[0]].push_back(it);\\n        }\\n        return f(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860547,
                "title": "c-optimal",
                "content": "# Intuition\\nThe Word Break problem can be visualized as attempting to partition a string into a sequence of words present in a dictionary. The challenge is to find a valid segmentation, if one exists. This naturally leads to the idea of breaking down the problem into smaller subproblems and solving them iteratively or recursively.\\n\\n# Approach - Dynamic Programming\\nThe Dynamic Programming (DP) approach is used to solve this problem in an iterative manner. By utilizing a boolean array `dp`, the algorithm builds a solution that checks if the string can be segmented into dictionary words.\\n\\n1. **Initialization**: Create an unordered set containing the dictionary words and initialize a DP array with `dp[0] = true`.\\n2. **Iteration**: Iterate through the string, and for each position `i`, check the substrings ending at `i` to see if they are in the dictionary.\\n3. **Memoization**: If a valid segmentation is found, update `dp[i]` to `true`.\\n4. **Result**: The final result is stored in `dp[s.size()]`.\\n\\n# Complexity\\n- **Time complexity**: \\\\(O(n^2 * m)\\\\), where \\\\(n\\\\) is the length of the string, and \\\\(m\\\\) is the maximum length of a word in the dictionary. This considers the nested iteration through the string and the substring operation.\\n- **Space complexity**: \\\\(O(n + k)\\\\), where \\\\(n\\\\) is the length of the string, and \\\\(k\\\\) is the size of the dictionary.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> st(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1, false);\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= s.size(); i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(dp[j] && st.find(s.substr(j, i - j)) != st.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()];\\n    }\\n};\\n```\\n\\nThe provided code offers a concise and efficient solution to the Word Break problem by leveraging the power of Dynamic Programming. By carefully considering the constraints and using C++\\'s standard library, the algorithm ensures an optimal solution.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> st(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1, false);\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= s.size(); i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(dp[j] && st.find(s.substr(j, i - j)) != st.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860520,
                "title": "c-backtracking",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:** \\n* for all index, we will determine *prefix* & *suffix* strings.\\n* if *preffix* is present in *dictionary*, then its a valid break point and remaining *suffix* becomes our sub-problem.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(string s, set<string> &st, map<string,bool> &mp){\\n        int n=s.length();\\n        \\n        if(n==0) return true;\\n        \\n        if(mp.find(s)!=mp.end()) return mp[s];\\n        \\n        for(int i=0;i<s.length();i++){\\n            string pre=s.substr(0,i+1); // current prefix string\\n            string suf=s.substr(i+1); // left over suffix string\\n            \\n            if(st.find(pre)!=st.end() && (st.find(suf)!=st.end() || check(suf,st,mp)==true)) return mp[s]=true;\\n        }\\n        return mp[s]=false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string> &dict) {\\n        set<string> st;\\n        for(int i=0;i<dict.size();i++) st.insert(dict[i]);\\n        \\n        map<string,bool> mp;\\n        return check(s,st,mp);\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(string s, set<string> &st, map<string,bool> &mp){\\n        int n=s.length();\\n        \\n        if(n==0) return true;\\n        \\n        if(mp.find(s)!=mp.end()) return mp[s];\\n        \\n        for(int i=0;i<s.length();i++){\\n            string pre=s.substr(0,i+1); // current prefix string\\n            string suf=s.substr(i+1); // left over suffix string\\n            \\n            if(st.find(pre)!=st.end() && (st.find(suf)!=st.end() || check(suf,st,mp)==true)) return mp[s]=true;\\n        }\\n        return mp[s]=false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string> &dict) {\\n        set<string> st;\\n        for(int i=0;i<dict.size();i++) st.insert(dict[i]);\\n        \\n        map<string,bool> mp;\\n        return check(s,st,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766655,
                "title": "a-general-template-solution-for-dp-memoization",
                "content": "# Intuition\\nThis is exactly the same as [coin change problem](https://leetcode.com/problems/coin-change/) and [Number of Dice Rolls With Target Sum\\n](https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/description/). So many medium or hard problems have been solved using this template and now I share it. The solution for this type of problems is straightforward and can be summarized into a template as follows: \\n1. Discuss some corner cases\\n2. Define a recursive structure where we can apply memoization\\n3. Call the recursive structure\\n```\\nclass Solution:\\n    def someProblem(self, nums) -> bool:\\n        # 1. some corner case discussion\\n        if not nums:\\n            return []\\n\\n        # 2. the recursive function\\n        @cache\\n        def helper(s):\\n            # 2.1 base cases for recursion\\n            if len(s) == 0:\\n                return True\\n            # 2.2 recursive call with smaller input size\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    if helper(s[len(word):]):\\n                        return True\\n            return False\\n\\n        # 3. wrap the function call\\n        return helper(s)\\n\\n```\\n\\nSome examples on how to use the template:\\n\\n# 139. Word Break\\nRecursively try each word in the word dictionary, and input the ``helper`` function again with smaller input. If the input size is reduced to zero, we find the word break. Otherwise, return False.\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        # no need for base case\\n\\n        # recursive call\\n        @cache\\n        def helper(s):\\n            if len(s) == 0:\\n                return True\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    if helper(s[len(word):]):\\n                        return True\\n            return False\\n        return helper(s)\\n```\\n\\n# 322. Coin Change\\nStart with 1 or 2 or 5, in order to get 11, the remaining balance now becomes 10 or 9 or 6. For each subcase, we can use 1 or 2 or 5 again, and calculate the corresponding remaining balance... which just forms a recursive structure with smaller input size.\\n\\n```\\nclass Solution:\\n    def coinChange(self, coins: List[int], amount: int) -> int:\\n        # corner cases\\n        if amount == 0: return 0\\n        @cache\\n        def helper(balance): # return the optimal strategy with balance\\n            if balance < 0:\\n                return float(\\'inf\\')\\n            elif balance == 0:\\n                return 0\\n            res = []\\n            for coin in coins:\\n                res.append(1 + helper(balance-coin))\\n            return min(res) # get the minimum possible outcomes\\n\\n        return helper(amount) if helper(amount) != float(\\'inf\\') else -1\\n\\n```\\n# 91. Decode Ways\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        @cache\\n        def helper(s):\\n            if s.startswith(\\'0\\'):\\n                return 0\\n\\n            if not s or len(s) == 1:\\n                return 1\\n\\n            return helper(s[1:]) + helper(s[2:]) if int(s[:2]) <= 26 else helper(s[1:])\\n\\n        return helper(s)\\n```\\n\\n# 416. Partition Equal Subset Sum\\nOne of the most famous problem in leetcode.\\n```\\nclass Solution:\\n    def canPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        total_sum = sum(nums)\\n        # discuss corner case\\n        if total_sum % 2 != 0:\\n            return False\\n        @cache\\n        def helper(target, idx):\\n            # recursion base cases\\n            if target == 0:\\n                return True\\n            if target < 0 or idx > n-1:\\n                return False\\n            if target < nums[idx]:\\n                return helper(target, idx + 1)\\n            return helper(target-nums[idx], idx+1) or helper(target, idx+1)\\n        subset_sum = total_sum // 2\\n        return helper(subset_sum, 0)\\n```\\n\\n# 1155. Number of Dice Rolls With Target Sum\\n```\\nclass Solution:\\n    def numRollsToTarget(self, n: int, k: int, target: int) -> int:\\n        @cache\\n        def helper(n, target):\\n            # base case for recursion\\n            if n == 1 and target>0 and target<=k:\\n                return 1\\n            if n == 0 or target < 0:\\n                return 0\\n            res = []\\n            for i in range(1,k+1):\\n                res.append(helper(n-1, target-i)) # recursive call\\n            ans = 0\\n            for j in res:\\n                ans = (ans+j)%(10**9+7)\\n            return ans\\n        return helper(n, target)\\n\\n```\\n\\n# 2767. Partition String Into Minimum Beautiful Substrings\\nA biweekly contest problem which can be written in less than 10 minutes if you are familiar with this template.\\n```\\nclass Solution:\\n    def minimumBeautifulSubstrings(self, s: str) -> int:\\n        ans = [\\'1\\', \\'101\\', \\'11001\\', \\'1111101\\', \\'1001110001\\', \\'110000110101\\', \\'11110100001001\\']\\n        @cache\\n        def helper(s):\\n            if s.startswith(\\'0\\'):\\n                return float(\\'inf\\')\\n            if not s:\\n                return 0\\n            res = []\\n            for i in ans:\\n                if s.startswith(i):\\n                    res.append(1 + helper(s[len(i):]))\\n            return min(res) if res else -1\\n        return helper(s) if helper(s) < float(\\'inf\\') else -1\\n```\\n\\n\\n\\n\\n\\nPlease upvote if you find this helpful! Thanks a lot.\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def someProblem(self, nums) -> bool:\\n        # 1. some corner case discussion\\n        if not nums:\\n            return []\\n\\n        # 2. the recursive function\\n        @cache\\n        def helper(s):\\n            # 2.1 base cases for recursion\\n            if len(s) == 0:\\n                return True\\n            # 2.2 recursive call with smaller input size\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    if helper(s[len(word):]):\\n                        return True\\n            return False\\n\\n        # 3. wrap the function call\\n        return helper(s)\\n\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        # no need for base case\\n\\n        # recursive call\\n        @cache\\n        def helper(s):\\n            if len(s) == 0:\\n                return True\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    if helper(s[len(word):]):\\n                        return True\\n            return False\\n        return helper(s)\\n```\n```\\nclass Solution:\\n    def coinChange(self, coins: List[int], amount: int) -> int:\\n        # corner cases\\n        if amount == 0: return 0\\n        @cache\\n        def helper(balance): # return the optimal strategy with balance\\n            if balance < 0:\\n                return float(\\'inf\\')\\n            elif balance == 0:\\n                return 0\\n            res = []\\n            for coin in coins:\\n                res.append(1 + helper(balance-coin))\\n            return min(res) # get the minimum possible outcomes\\n\\n        return helper(amount) if helper(amount) != float(\\'inf\\') else -1\\n\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        @cache\\n        def helper(s):\\n            if s.startswith(\\'0\\'):\\n                return 0\\n\\n            if not s or len(s) == 1:\\n                return 1\\n\\n            return helper(s[1:]) + helper(s[2:]) if int(s[:2]) <= 26 else helper(s[1:])\\n\\n        return helper(s)\\n```\n```\\nclass Solution:\\n    def canPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        total_sum = sum(nums)\\n        # discuss corner case\\n        if total_sum % 2 != 0:\\n            return False\\n        @cache\\n        def helper(target, idx):\\n            # recursion base cases\\n            if target == 0:\\n                return True\\n            if target < 0 or idx > n-1:\\n                return False\\n            if target < nums[idx]:\\n                return helper(target, idx + 1)\\n            return helper(target-nums[idx], idx+1) or helper(target, idx+1)\\n        subset_sum = total_sum // 2\\n        return helper(subset_sum, 0)\\n```\n```\\nclass Solution:\\n    def numRollsToTarget(self, n: int, k: int, target: int) -> int:\\n        @cache\\n        def helper(n, target):\\n            # base case for recursion\\n            if n == 1 and target>0 and target<=k:\\n                return 1\\n            if n == 0 or target < 0:\\n                return 0\\n            res = []\\n            for i in range(1,k+1):\\n                res.append(helper(n-1, target-i)) # recursive call\\n            ans = 0\\n            for j in res:\\n                ans = (ans+j)%(10**9+7)\\n            return ans\\n        return helper(n, target)\\n\\n```\n```\\nclass Solution:\\n    def minimumBeautifulSubstrings(self, s: str) -> int:\\n        ans = [\\'1\\', \\'101\\', \\'11001\\', \\'1111101\\', \\'1001110001\\', \\'110000110101\\', \\'11110100001001\\']\\n        @cache\\n        def helper(s):\\n            if s.startswith(\\'0\\'):\\n                return float(\\'inf\\')\\n            if not s:\\n                return 0\\n            res = []\\n            for i in ans:\\n                if s.startswith(i):\\n                    res.append(1 + helper(s[len(i):]))\\n            return min(res) if res else -1\\n        return helper(s) if helper(s) < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607067,
                "title": "c-fast-solution-beats-100-o-mn-2-runtime-explanation-provided",
                "content": "# Intuition\\nThink of the problem this way: if we were going to build ```s``` from the words in ```wordDict```, then at any given index ```i``` of ```s``` we have the opportunity to insert some string, ```word```, from the dictionary (i.e. use ```word``` to cover the characters ```s[i,...,i + word.size() - 1]```). So at each index, we can try and check if we can insert a word from the given dictionary. But what exactly does it mean \"to be able to insert a word\"? Of course, the only actual requirement is that if we\\'re inserting some word, ```word```, at index ```i``` in ```s```, then the characters of ```word``` and the substring in ```s``` that it covers have to match. For example, if \\n```s = \"leetcode\"``` and ```wordDict = [\"le\", \"et\", \"co\", \"de\"]```, we can insert ```wordDict[2] = \"co\"``` at index $4$ in ```s``` (since the substring ```\"co\"``` begins at index $4$ in ```s```). So far we know that we could insert ```\"co\"``` at index $4$ and properly form the substring ```\"co\"``` of ```s```. One important observation that we can make here that will be important in our implementation is that we don\\'t need to try inserting every word in dictionary at some index ```i``` in ```s```. We only need to try those that start with the character ```s[i]```. Now we make another important observation: there\\'s a subproblem here (DP!). What if I knew that I could form the substring \\n```s[4 + wordDict[2].size(), ..., s.size() - 1] = \"de\"``` (i.e. the substring that follows our inserted word, which is the substring ```\"de\"```)? Well, then I know that I can form the substring ```\"code\"``` since we\\'ve confirmed that we can form the two independent substrings ```\"co\"``` and ```\"de\"```. This is the basis of our dynamic programming approach.\\n\\n# Approach\\n\\n1. Initialize a boolean ```dp``` array of size ```s.size() + 1``` to ```false```. ```dp[i] = true``` denotes that the substring ```s[i, ..., s.size() - 1]``` can be formed using the words in ```wordDict```. Set ```dp[s.size()] = true``` (explained later).\\n2. Construct an unordered map ```insertions```. This map must map the first character of a given string, ```word```, to a vector of strings from ```wordDict``` that all start with that first character (including ```word```). For example, if ```wordDict = [\"Skill\", \"Issue\", \"IMO\"]```, then ```insertions[\\'I\\'] = [\"Issue\", \"IMO\"]```\\n3. Begin a backwards iteration starting at the last character of ```s``` In other words our iteration starts at ```i = s.size() - 1```. At each step of this iteration we will try inserting words from ```wordDict``` that start with ```s[i]```.\\n4. At each index ```i``` loop through all the words from ```wordDict``` that start with ```s[i]``` (recall that a vector containing all such words exists at ```insertions[s[i]]```). For each possible insertion, ```word```, in ```insertions[s[i]]``` check that the substring following our insertion can be formed (i.e. ```dp[i + word.size()] == true]```) and that ```word``` is a valid insertion (i.e. ```word == s[i, ..., i + word.size() - 1]```). If our word is both a valid insertion AND the substring following our insertion can be formed, then we set ```dp[i] = true```. We can also exit the loop for index ```i``` because we\\'ve already confirmed that we can form the string ```s[i, ..., s.size() - 1]```,\\n5. Return ```dp[0]```, which denotes that ```s[0,...,s.size() - 1]``` (i.e. the entire string) can be formed using the words in ```wordDict```.\\n\\n\\n## Notes\\n- The reason why we have the extra entry in the ```dp``` array is for the inserted strings that terminate ```s```. To elaborate, remember that when updating the ```dp``` array, we consider if the substring following our insertion can be formed. But if our insertion happens at the end of ```s```, then there is no substring following our insertion. For example, if ```s = \"tim\"```, ```wordDict = [\"t\", \"im\"]``` we try inserting the string of length $2$, ```\"im\"```, at ```s[1]```, we want ```dp[1 + 2] = dp[s.size()]``` to be set to ```true```.\\n- While the unordered map technically doesn\\'t have an effect on the time complexity, it\\'s a pretty useful optimization when the dictionary is large with many different words.\\n- Possible Improvements: If duplicate strings were allowed in the dictionary, we could use an unordered set instead of a vector to store the strings within the unordered map. Also, if the length of a word in the dictionary is longer than the input string ```s```, we could just not put it in our map.\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m \\\\cdot n^2)$$ ($m$ is the length of the dictionary, $n$ is the length of the longest string)\\n\\nIn the outermost loop we iterate over ```s``` ($n$). In the inner loop iterate over words from ```wordDict``` ,which are mapped by their first character ($m$). Inside the inner loop, we may make a call to ```compare()```, ($n$), which gives us our runtime $O(m \\\\cdot n^2)$.\\n\\n- Space complexity:\\n$$O(l + m \\\\cdot w)$$ ($l$ is the length of ```s```, $m$ is the length of the dictionary, and $w$ is the length of the longest word in the dictionary)\\n\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n\\n        unordered_map<char, vector<string>> insertions;\\n        vector<bool> dp(s.size() + 1, false);\\n        int nxt;\\n\\n        dp[s.size()] = true;\\n\\n        for (string& word : wordDict)\\n            insertions[word[0]].push_back(word);\\n\\n        for (int i = s.size() - 1; i > -1; --i)\\n        {\\n            // Attempt insertion of all strings in wordDict beginning with character s[i]\\n            for (string& word : insertions[s[i]])\\n            {\\n                nxt = i + word.size();\\n\\n                // Check that the substring following the current string (word) can be \\n                // formed and that the current string (word) is valid \\n                if (nxt <= s.size() && dp[nxt] && s.compare(i, word.size(), word) == 0)\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\nYou could also replace \\n\\n```\\nif (nxt <= s.size() && dp[nxt] && s.compare(i, word.size(), word) == 0)\\n```\\n\\nwith\\n\\n```\\nif (s.compare(i, word.size(), word) == 0 && dp[nxt])\\n```\\n---\\n# Performance\\n![Screen Shot 2023-06-07 at 1.00.44 AM.png](https://assets.leetcode.com/users/images/d4c84d4b-99a6-4374-aa5d-8ec6ac8bceda_1686114102.6830206.png)\\n\\n---\\n# Saving Space\\n\\nThis approach definitely uses a significant amount of memory if `wordDict` is very large since we store a copy each `word` in `wordDict` in our map, but we can fix this problem if we store the index of each `word` in the original `wordDict` array rather than the `word` itself. Because we no longer store a copy of the words in `wordDict`, our space complexity is reduced to $O(l + m)$ ($l$ is the length of ```s``` and $m$ is the length of the dictionary) and the time complexity remains the same.\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n\\n        unordered_map<char, vector<int>> insertions;\\n        vector<bool> dp(s.size() + 1, false);\\n        int nxt;\\n\\n        dp[s.size()] = true;\\n\\n        for (int i = 0; i < wordDict.size(); ++i)\\n            insertions[wordDict[i][0]].push_back(i);\\n\\n        for (int i = s.size() - 1; i > -1; --i)\\n        {\\n            for (int pos : insertions[s[i]])\\n            {\\n                nxt = i + wordDict[pos].size();\\n                if (nxt <= s.size() && dp[nxt] && s.compare(i, wordDict[pos].size(), wordDict[pos]) == 0)\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```s```\n```wordDict```\n```i```\n```s```\n```word```\n```word```\n```s[i,...,i + word.size() - 1]```\n```word```\n```i```\n```s```\n```word```\n```s```\n```s = \"leetcode\"```\n```wordDict = [\"le\", \"et\", \"co\", \"de\"]```\n```wordDict[2] = \"co\"```\n```s```\n```\"co\"```\n```s```\n```\"co\"```\n```\"co\"```\n```s```\n```i```\n```s```\n```s[i]```\n```s[4 + wordDict[2].size(), ..., s.size() - 1] = \"de\"```\n```\"de\"```\n```\"code\"```\n```\"co\"```\n```\"de\"```\n```dp```\n```s.size() + 1```\n```false```\n```dp[i] = true```\n```s[i, ..., s.size() - 1]```\n```wordDict```\n```dp[s.size()] = true```\n```insertions```\n```word```\n```wordDict```\n```word```\n```wordDict = [\"Skill\", \"Issue\", \"IMO\"]```\n```insertions[\\'I\\'] = [\"Issue\", \"IMO\"]```\n```s```\n```i = s.size() - 1```\n```wordDict```\n```s[i]```\n```i```\n```wordDict```\n```s[i]```\n```insertions[s[i]]```\n```word```\n```insertions[s[i]]```\n```dp[i + word.size()] == true]```\n```word```\n```word == s[i, ..., i + word.size() - 1]```\n```dp[i] = true```\n```i```\n```s[i, ..., s.size() - 1]```\n```dp[0]```\n```s[0,...,s.size() - 1]```\n```wordDict```\n```dp```\n```s```\n```dp```\n```s```\n```s = \"tim\"```\n```wordDict = [\"t\", \"im\"]```\n```\"im\"```\n```s[1]```\n```dp[1 + 2] = dp[s.size()]```\n```true```\n```s```\n```s```\n```wordDict```\n```compare()```\n```s```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n\\n        unordered_map<char, vector<string>> insertions;\\n        vector<bool> dp(s.size() + 1, false);\\n        int nxt;\\n\\n        dp[s.size()] = true;\\n\\n        for (string& word : wordDict)\\n            insertions[word[0]].push_back(word);\\n\\n        for (int i = s.size() - 1; i > -1; --i)\\n        {\\n            // Attempt insertion of all strings in wordDict beginning with character s[i]\\n            for (string& word : insertions[s[i]])\\n            {\\n                nxt = i + word.size();\\n\\n                // Check that the substring following the current string (word) can be \\n                // formed and that the current string (word) is valid \\n                if (nxt <= s.size() && dp[nxt] && s.compare(i, word.size(), word) == 0)\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\n```\\nif (nxt <= s.size() && dp[nxt] && s.compare(i, word.size(), word) == 0)\\n```\n```\\nif (s.compare(i, word.size(), word) == 0 && dp[nxt])\\n```\n```s```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n\\n        unordered_map<char, vector<int>> insertions;\\n        vector<bool> dp(s.size() + 1, false);\\n        int nxt;\\n\\n        dp[s.size()] = true;\\n\\n        for (int i = 0; i < wordDict.size(); ++i)\\n            insertions[wordDict[i][0]].push_back(i);\\n\\n        for (int i = s.size() - 1; i > -1; --i)\\n        {\\n            for (int pos : insertions[s[i]])\\n            {\\n                nxt = i + wordDict[pos].size();\\n                if (nxt <= s.size() && dp[nxt] && s.compare(i, wordDict[pos].size(), wordDict[pos]) == 0)\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107848,
                "title": "without-dp-c-easy",
                "content": "# Approach\\nSo I have seen many DP Solutions here.\\nInstead of DP I used normal BFS but with Set,\\nBasically what DP does here is to avoid the same computation at a given index being queried multiple times due to recursion (worst case exponential)....so you use DP so as the queries are only entertained once and convert it into n^2 time (for n=string length).\\n\\nBasically I kept this same concept in mind and Made a set which records partitions already pushed in queue once and so to not to compute them further every time they are added in queue due to various possible ways to reach there for a partition.\\n\\n# Complexity\\n- Time complexity:\\nO(N*maxlenofstr+(maxlenofstr)^2)\\n\\n- Space complexity:\\nO(N*maxlenofstr)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string str,vector<string>wordDict) \\n    {\\n        unordered_map<string,bool>existsinDict;\\n        for(string j:wordDict)\\n        {\\n            existsinDict[j]=true;\\n        }\\n        queue<int>tocheck;\\n        vector<bool>alreadypushedinqueue(str.size(),false);\\n        bool partitionreachedend=false;\\n        tocheck.push(-1);\\n        while(!tocheck.empty())\\n        {\\n            int indexofstr=tocheck.front();\\n            tocheck.pop();\\n            if(indexofstr==(str.size()-1))\\n            {\\n                partitionreachedend=true;\\n                break;\\n            }\\n            string checkinDict;\\n            for(int i=indexofstr+1;i<str.size();i++)\\n            {\\n                checkinDict.push_back(str[i]);\\n                if(existsinDict[checkinDict] && !alreadypushedinqueue[i])\\n                {\\n                    tocheck.push(i);\\n                    alreadypushedinqueue[i]=true;\\n                }\\n            }\\n        }\\n        return partitionreachedend;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string str,vector<string>wordDict) \\n    {\\n        unordered_map<string,bool>existsinDict;\\n        for(string j:wordDict)\\n        {\\n            existsinDict[j]=true;\\n        }\\n        queue<int>tocheck;\\n        vector<bool>alreadypushedinqueue(str.size(),false);\\n        bool partitionreachedend=false;\\n        tocheck.push(-1);\\n        while(!tocheck.empty())\\n        {\\n            int indexofstr=tocheck.front();\\n            tocheck.pop();\\n            if(indexofstr==(str.size()-1))\\n            {\\n                partitionreachedend=true;\\n                break;\\n            }\\n            string checkinDict;\\n            for(int i=indexofstr+1;i<str.size();i++)\\n            {\\n                checkinDict.push_back(str[i]);\\n                if(existsinDict[checkinDict] && !alreadypushedinqueue[i])\\n                {\\n                    tocheck.push(i);\\n                    alreadypushedinqueue[i]=true;\\n                }\\n            }\\n        }\\n        return partitionreachedend;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917101,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        if(dict.size()==0)\\n            return false;\\n        unordered_map<string, int> mp;\\n        for(auto s1:dict)\\n            mp[s1]++;\\n        vector<bool> dp(s.size()+1);\\n        dp[0]=true;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(dp[j])\\n                {\\n                    string word=s.substr(j, i-j+1);\\n                    if(mp.find(word)!=mp.end())\\n                    {\\n                        dp[i+1]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        if(dict.size()==0)\\n            return false;\\n        unordered_map<string, int> mp;\\n        for(auto s1:dict)\\n            mp[s1]++;\\n        vector<bool> dp(s.size()+1);\\n        dp[0]=true;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(dp[j])\\n                {\\n                    string word=s.substr(j, i-j+1);\\n                    if(mp.find(word)!=mp.end())\\n                    {\\n                        dp[i+1]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557501,
                "title": "fastest-solution-detailed-explanation-easy-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it***\\n\\n**Intution 1 (String DP):-**\\n**Approach**\\nThe approach is simple, we\\'ll just call recursively for all substrings of the given string and check if that substring exists inside the dictionary, then make a new call to the next substring to check further. In this recursive call we have used unordered map \\'dp\\', which prevents recall for the same substring again. Finally if the size of the substring becomes zero it means the given string is present inside the dictionary, then return true else false.\\n\\n**Dry run:-**\\n\\n![image](https://assets.leetcode.com/users/images/029f9586-3839-44a8-82cd-3c79aa8dd678_1662807900.2093604.jpeg)\\n\\n**Code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp;\\n    \\n    int solve(string s, vector<string>& wordDict){\\n        int sz=s.length();\\n        if(sz==0) return 1;\\n        if(dp[s]!=0) return dp[s];\\n        \\n        for(int i=1;i<=sz;i++)\\n        {\\n            int f=0;\\n            string ss=s.substr(0,i);\\n            for(int j=0;j<wordDict.size();j++){\\n                if(ss.compare(b[j])==0){\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(f==1 and solve(s.substr(i,sz-i),b)==1) return dp[s]=1;\\n        }\\n        return dp[s]=-1;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int x=solve(s,wordDict);\\n        if(x==1) return true;\\n        else return false;\\n        \\n    }\\n};\\n```\\n\\n**Intution 1 (DP):-**\\n**Approach 1 : Recursion (TLE)**\\nTake a set insert all dictionary words. Create recursive fuction pass \\'0\\' as starting index, given string and set. inside function check current index is equal to number of char in string then return true (base case). Take a blank temp string and run loop from current index till size of string and add char one by one with temp simultaneously check temp present in set if true then call same function pass current index as i+1. at the you will get your answer.\\n\\n**~Time Complexity: O(N^2) \\n~Space Complexity: O(N) ~stack space**\\n\\n**C++ Code (TLE)**\\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind,string str,set<string> st){\\n        if(ind==str.size()) return true;\\n        string temp=\"\";\\n        for(int i=ind;i<str.size();i++){\\n            temp+=str[i];\\n            if(st.find(temp)!=st.end()){\\n                if(solve(i+1,str,st)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        return solve(0,s,st);\\n    }\\n};\\n```\\n\\n**Approach 2 : Memoization (Accepted)**\\n**~Time Complexity: O(N^2) \\n~Space Complexity:  O(N)+O(N) stack space and dp vector**\\n\\n**C++ Code (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind,string str,set<string> st,vector<int>& dp){\\n        if(ind==str.size()) return true;\\n        if(dp[ind]!=-1) return dp[ind];\\n        string temp=\"\";\\n        for(int i=ind;i<str.size();i++){\\n            temp+=str[i];\\n            if(st.find(temp)!=st.end()){\\n                if(solve(i+1,str,st,dp)){\\n                    return dp[ind]=true;\\n                }\\n            }\\n        }\\n        return dp[ind]=false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        vector<int> dp(s.size(),-1);\\n        return solve(0,s,st,dp);\\n    }\\n};\\n```\\n\\n**Approach 3 : Tabulation (Accepted)**\\n\\n**~Time Complexity: O(N^2) \\n~Space Complexity:  O(N) ~dp vector**\\n\\n**C++ Code (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        \\n        vector<bool> dp(n,false);\\n        dp[n]=true;\\n        \\n        for(int ind=n-1;ind>=0;ind--){\\n            string temp=\"\";\\n            for(int i=ind;i<n;i++){\\n                temp+=s[i];\\n                if(st.find(temp)!=st.end()){\\n                    if(dp[i+1]){\\n                        dp[ind]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp;\\n    \\n    int solve(string s, vector<string>& wordDict){\\n        int sz=s.length();\\n        if(sz==0) return 1;\\n        if(dp[s]!=0) return dp[s];\\n        \\n        for(int i=1;i<=sz;i++)\\n        {\\n            int f=0;\\n            string ss=s.substr(0,i);\\n            for(int j=0;j<wordDict.size();j++){\\n                if(ss.compare(b[j])==0){\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(f==1 and solve(s.substr(i,sz-i),b)==1) return dp[s]=1;\\n        }\\n        return dp[s]=-1;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int x=solve(s,wordDict);\\n        if(x==1) return true;\\n        else return false;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind,string str,set<string> st){\\n        if(ind==str.size()) return true;\\n        string temp=\"\";\\n        for(int i=ind;i<str.size();i++){\\n            temp+=str[i];\\n            if(st.find(temp)!=st.end()){\\n                if(solve(i+1,str,st)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        return solve(0,s,st);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind,string str,set<string> st,vector<int>& dp){\\n        if(ind==str.size()) return true;\\n        if(dp[ind]!=-1) return dp[ind];\\n        string temp=\"\";\\n        for(int i=ind;i<str.size();i++){\\n            temp+=str[i];\\n            if(st.find(temp)!=st.end()){\\n                if(solve(i+1,str,st,dp)){\\n                    return dp[ind]=true;\\n                }\\n            }\\n        }\\n        return dp[ind]=false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        vector<int> dp(s.size(),-1);\\n        return solve(0,s,st,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        \\n        vector<bool> dp(n,false);\\n        dp[n]=true;\\n        \\n        for(int ind=n-1;ind>=0;ind--){\\n            string temp=\"\";\\n            for(int i=ind;i<n;i++){\\n                temp+=s[i];\\n                if(st.find(temp)!=st.end()){\\n                    if(dp[i+1]){\\n                        dp[ind]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422836,
                "title": "c-solution-memoization-tabulation-both-dp-comments",
                "content": "Memoization\\n```\\n// created a dp[pos], to store the boolean value of string being formed at that pos\\nint dp [301];\\nint helper(string s, vector<string> wordDict, int pos){\\n\\t// if we reach the end of string, we formed the string from the dict of wordDict\\n\\tif(pos==s.length()) return true;\\n\\t\\n\\t// if already saved in dp, return.\\n\\tif(dp[pos]!=-1) return dp[pos];\\n\\t\\n\\tstring temp = \"\";\\n\\tfor(int i =pos; i<s.length(); i++){\\n\\t\\t// we keep adding in temp, and search if present in wordDict\\n\\t\\ttemp +=s[i];\\n\\t\\tif(find(wordDict.begin(), wordDict.end(),temp)!=wordDict.end()){\\n\\t\\t\\tif(helper(s, wordDict, i+1))    return true;            \\n\\t\\t}\\n\\t}\\n\\treturn dp[pos] =  false;        \\n}\\n\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\tmemset(dp, -1, sizeof(dp));\\n\\treturn helper(s, wordDict, 0);\\n}\\n```\\n\\nTabulation: Here we do the following,\\n-> For each word in wordDict, we check that length\\'s string in the string **s** and if it is present, we save it in res, and move up the string.\\n```\\nbool wordBreak(string s, vector<string>& wordDict) {        \\n\\tvector<bool> res(s.size(),false);\\n\\tres[0]=true;\\n\\tfor(int i=0;i<s.size();i++){\\n\\t\\tif(res[i]){\\n\\t\\t\\tfor(auto str:wordDict){\\n\\t\\t\\t\\tif(s.substr(i,str.size()).compare(str)==0){\\n\\t\\t\\t\\t\\tres[i+str.size()]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res[s.size()];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// created a dp[pos], to store the boolean value of string being formed at that pos\\nint dp [301];\\nint helper(string s, vector<string> wordDict, int pos){\\n\\t// if we reach the end of string, we formed the string from the dict of wordDict\\n\\tif(pos==s.length()) return true;\\n\\t\\n\\t// if already saved in dp, return.\\n\\tif(dp[pos]!=-1) return dp[pos];\\n\\t\\n\\tstring temp = \"\";\\n\\tfor(int i =pos; i<s.length(); i++){\\n\\t\\t// we keep adding in temp, and search if present in wordDict\\n\\t\\ttemp +=s[i];\\n\\t\\tif(find(wordDict.begin(), wordDict.end(),temp)!=wordDict.end()){\\n\\t\\t\\tif(helper(s, wordDict, i+1))    return true;            \\n\\t\\t}\\n\\t}\\n\\treturn dp[pos] =  false;        \\n}\\n\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\tmemset(dp, -1, sizeof(dp));\\n\\treturn helper(s, wordDict, 0);\\n}\\n```\n```\\nbool wordBreak(string s, vector<string>& wordDict) {        \\n\\tvector<bool> res(s.size(),false);\\n\\tres[0]=true;\\n\\tfor(int i=0;i<s.size();i++){\\n\\t\\tif(res[i]){\\n\\t\\t\\tfor(auto str:wordDict){\\n\\t\\t\\t\\tif(s.substr(i,str.size()).compare(str)==0){\\n\\t\\t\\t\\t\\tres[i+str.size()]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res[s.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906412,
                "title": "very-efficient-code-faster-solution-than-5-06-of-problem-solvers-1905-ms-440-mb",
                "content": "Used divide and conquer in this code. Basically breaking the string into several substrings and checking whether they exist in the word dictionary or not . **Am*z0n interviewer was so proud , he realised that i had to be hired or else any other fintech shall hire me instead.**\\n    \\n    bool search(string s,set<string>& dict,int l,int r,vector<vector<int>>& dp)\\n    {\\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        string temp = s.substr(l,r-l+1);\\n        \\n        if(dict.find(temp)!=dict.end())\\n        {\\n            return dp[l][r] = 1;\\n        }\\n        \\n        for(int k=l;k<r;k++)\\n        {\\n            bool lt = search(s,dict,l,k,dp);\\n            bool rt = search(s,dict,k+1,r,dp);\\n            \\n            if(lt && rt)return dp[l][r] = true;\\n        }\\n        \\n        return dp[l][r] = false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict;\\n        \\n        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        \\n        for(auto x:wordDict)dict.insert(x);\\n        \\n        return search(s,dict,0,s.length()-1,dp);\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "Used divide and conquer in this code. Basically breaking the string into several substrings and checking whether they exist in the word dictionary or not . **Am*z0n interviewer was so proud , he realised that i had to be hired or else any other fintech shall hire me instead.**\\n    \\n    bool search(string s,set<string>& dict,int l,int r,vector<vector<int>>& dp)\\n    {\\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        string temp = s.substr(l,r-l+1);\\n        \\n        if(dict.find(temp)!=dict.end())\\n        {\\n            return dp[l][r] = 1;\\n        }\\n        \\n        for(int k=l;k<r;k++)\\n        {\\n            bool lt = search(s,dict,l,k,dp);\\n            bool rt = search(s,dict,k+1,r,dp);\\n            \\n            if(lt && rt)return dp[l][r] = true;\\n        }\\n        \\n        return dp[l][r] = false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict;\\n        \\n        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        \\n        for(auto x:wordDict)dict.insert(x);\\n        \\n        return search(s,dict,0,s.length()-1,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1582771,
                "title": "python-easy-dfs-dp-solution",
                "content": "```\\ndef wordBreak(self, string, wordDict):\\n\\tn = len(string)\\n\\tdp = {}\\n\\tdef dfs(i):\\n\\t\\tif i in dp: return dp[i]\\n\\t\\tif i == n: return True\\n\\t\\tif i > n:\\n\\t\\t\\treturn False\\n\\n\\t\\tfor word in wordDict: # check if there is a match for any word form \\'wordDict\\' starting from index i of \\'string\\'\\n\\t\\t\\tif i+ len(word) > n: continue\\n\\t\\t\\tif word == string[i:i + len(word)]: # if yes then do the same from i + len(word) => next index from end of match\\n\\t\\t\\t\\tdp[i] = dfs(i + len(word))\\n\\t\\t\\t\\tif dp[i]: return True\\n\\n\\t\\tdp[i] = False\\n\\t\\treturn dp[i]\\n\\n\\treturn dfs(0)\\n\\t# like if you find it useful\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef wordBreak(self, string, wordDict):\\n\\tn = len(string)\\n\\tdp = {}\\n\\tdef dfs(i):\\n\\t\\tif i in dp: return dp[i]\\n\\t\\tif i == n: return True\\n\\t\\tif i > n:\\n\\t\\t\\treturn False\\n\\n\\t\\tfor word in wordDict: # check if there is a match for any word form \\'wordDict\\' starting from index i of \\'string\\'\\n\\t\\t\\tif i+ len(word) > n: continue\\n\\t\\t\\tif word == string[i:i + len(word)]: # if yes then do the same from i + len(word) => next index from end of match\\n\\t\\t\\t\\tdp[i] = dfs(i + len(word))\\n\\t\\t\\t\\tif dp[i]: return True\\n\\n\\t\\tdp[i] = False\\n\\t\\treturn dp[i]\\n\\n\\treturn dfs(0)\\n\\t# like if you find it useful\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1483038,
                "title": "python3-recursive-with-memoization-faster-than-99",
                "content": "\\'\\'\\'\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n\\n\\n        def can_construct(target, strings_bank, memo):    \\n            if target in memo:\\n                return memo[target]\\n            if target == \"\":\\n                return True\\n            for element in strings_bank: # for every element in our dict we check if we can start constructing the string \"s\"\\n                if element == target[0:len(element)]: # the remaining of the string \"s\" (which is the suffix) is the new target \\n                    suffix = target[len(element):]\\n                    if can_construct(suffix, strings_bank, memo):\\n                        memo[target] = True\\n                        return True\\n            memo[target] = False\\n            return False\\n\\n\\n        return can_construct(s, wordDict, memo)\\n```\\nIf you like it, please upvote!\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n\\n\\n        def can_construct(target, strings_bank, memo):    \\n            if target in memo:\\n                return memo[target]\\n            if target == \"\":\\n                return True\\n            for element in strings_bank: # for every element in our dict we check if we can start constructing the string \"s\"\\n                if element == target[0:len(element)]: # the remaining of the string \"s\" (which is the suffix) is the new target \\n                    suffix = target[len(element):]\\n                    if can_construct(suffix, strings_bank, memo):\\n                        memo[target] = True\\n                        return True\\n            memo[target] = False\\n            return False\\n\\n\\n        return can_construct(s, wordDict, memo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480275,
                "title": "well-explained-clean-concise-98-faster",
                "content": "## IDEA:\\n*Mark the end point upto which we can reach by using the words from given dictionary.*\\n### Explainantion:\\n\\n\\t* For this we can use dp to mark the index which is reachable or not.\\n\\t* In starting we can reach the 0th index of any string so make it True.\\n\\t* Now, start the loop of length of given string and when you find the index is reachable i.e. **dp[i]==True** start checking for the next word to be fitted in string.\\n\\t* If found make dp[i]=True.\\n\\t* By going all the index if we are unable to reach last index then it will remain as False.\\n\\t* Return the dp[-1] which will signify that we aare able form string or not from wordDictionary given.\\n\\n### CODE:\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        n=len(s)\\n        dp = [False for _ in range(n+1)]\\n        dp[0]=True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for w in wordDict:\\n                    if s[i:i+len(w)]==w:\\n                        dp[i+len(w)]=True\\n        return dp[-1]\\n\\t\\t\\n**Feel free to ask if you have any doubt.\\uD83E\\uDD1E**\\n#### Thanks and *Upvote* if you got any help!!\\uD83E\\uDD17",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "## IDEA:\\n*Mark the end point upto which we can reach by using the words from given dictionary.*\\n### Explainantion:\\n\\n\\t* For this we can use dp to mark the index which is reachable or not.\\n\\t* In starting we can reach the 0th index of any string so make it True.\\n\\t* Now, start the loop of length of given string and when you find the index is reachable i.e. **dp[i]==True** start checking for the next word to be fitted in string.\\n\\t* If found make dp[i]=True.\\n\\t* By going all the index if we are unable to reach last index then it will remain as False.\\n\\t* Return the dp[-1] which will signify that we aare able form string or not from wordDictionary given.\\n\\n### CODE:\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        n=len(s)\\n        dp = [False for _ in range(n+1)]\\n        dp[0]=True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for w in wordDict:\\n                    if s[i:i+len(w)]==w:\\n                        dp[i+len(w)]=True\\n        return dp[-1]\\n\\t\\t\\n**Feel free to ask if you have any doubt.\\uD83E\\uDD1E**\\n#### Thanks and *Upvote* if you got any help!!\\uD83E\\uDD17",
                "codeTag": "Java"
            },
            {
                "id": 1354876,
                "title": "o-n-2-regular-mcm-approach",
                "content": "In this question if we observe carefully, the problem statement can be reduced to this ->\"*it is saying us to make partitions of the given string such that all the partitions should be present in the dictionary*\".\\n\\nSo, for making partitions we can use MCM (**matrix chain multiplication**) approach. \\n\\nHere is my code for MCM approach with memoization.\\n\\n```\\nclass Solution {\\npublic:\\n    bool MCM(string &s, unordered_map<string, bool> &ourmap, int i, int j, vector<vector<int>> &dp){\\n        if(i>j) return false;            //base case\\n        if(dp[i][j]!=-1) return dp[i][j];        //using previously stored sub-problem\\n        string temp = s.substr(i,j-i+1);\\n        if(ourmap.count(temp))  return true;\\n        bool flag=false;\\n\\t\\t//running loop for checking valid partition \\n        for(int k=i;k<j;k++){\\n            if(MCM(s,ourmap,i,k,dp) && MCM(s,ourmap,k+1,j,dp)){\\n                flag=true;\\n            }\\n        }\\n        return dp[i][j]=flag;    //storing final answer and returing it too\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n       unordered_map<string,bool> ourmap;     //map for storing dictionary\\n        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));     //dp array for storing sub-problems answers\\n        for(int i=0;i<wordDict.size();i++){\\n            ourmap[wordDict[i]]=true;\\n        }\\n        \\n        return MCM(s,ourmap,0,s.size()-1,dp);      //calling MCM function\\n    }\\n};\\n```\\n\\nThanks for reading!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool MCM(string &s, unordered_map<string, bool> &ourmap, int i, int j, vector<vector<int>> &dp){\\n        if(i>j) return false;            //base case\\n        if(dp[i][j]!=-1) return dp[i][j];        //using previously stored sub-problem\\n        string temp = s.substr(i,j-i+1);\\n        if(ourmap.count(temp))  return true;\\n        bool flag=false;\\n\\t\\t//running loop for checking valid partition \\n        for(int k=i;k<j;k++){\\n            if(MCM(s,ourmap,i,k,dp) && MCM(s,ourmap,k+1,j,dp)){\\n                flag=true;\\n            }\\n        }\\n        return dp[i][j]=flag;    //storing final answer and returing it too\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n       unordered_map<string,bool> ourmap;     //map for storing dictionary\\n        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));     //dp array for storing sub-problems answers\\n        for(int i=0;i<wordDict.size();i++){\\n            ourmap[wordDict[i]]=true;\\n        }\\n        \\n        return MCM(s,ourmap,0,s.size()-1,dp);      //calling MCM function\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984987,
                "title": "c-solution",
                "content": "```\\n bool solve(string s,unordered_map<string,int> dict)\\n    {\\n            int n = s.size();\\n            vector<int>dp(n+1);\\n            dp[0] = true;\\n            for(int len = 1;len<=s.length();len++)\\n            {\\n                    for(int i = 0;i<len;i++)\\n                    {\\n                            if(dp[i] == true && dict.find(s.substr(i,len- i)) != dict.end()){\\n                                    dp[len] = true;\\n                                    break;\\n                            }\\n                    }\\n            }\\n         return dp[n];\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n            unordered_map<string,int> dict;\\n            for(int i = 0;i<wordDict.size();i++)\\n            {\\n                   dict[wordDict[i]]++; \\n            }\\n           return solve(s,dict);\\n    }",
                "solutionTags": [],
                "code": "```\\n bool solve(string s,unordered_map<string,int> dict)\\n    {\\n            int n = s.size();\\n            vector<int>dp(n+1);\\n            dp[0] = true;\\n            for(int len = 1;len<=s.length();len++)\\n            {\\n                    for(int i = 0;i<len;i++)\\n                    {\\n                            if(dp[i] == true && dict.find(s.substr(i,len- i)) != dict.end()){\\n                                    dp[len] = true;\\n                                    break;\\n                            }\\n                    }\\n            }\\n         return dp[n];\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n            unordered_map<string,int> dict;\\n            for(int i = 0;i<wordDict.size();i++)\\n            {\\n                   dict[wordDict[i]]++; \\n            }\\n           return solve(s,dict);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 870576,
                "title": "python-dynamic-programming",
                "content": "```\\ndef wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\tdp = [False]*(len(s)+1)\\n\\tdp[0] = True\\n\\twordDict = set(wordDict)\\n\\n\\t# check if words until index i are valid(in wordDict)\\n\\tfor i in range(len(s)):\\n\\t\\t# if word until index j is valid, than we only need to check if word[j:i+1] is valid for all substring word[:i+1] to be valid\\n\\t\\tfor j in range(i+1):\\n\\t\\t\\tif not dp[j]:\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t# we know word[:j] is valid if we are here, so if word[j:i+1] is valid we can check substring word[:i+1] as valid too\\n\\t\\t\\tsubword = s[j:i+1]\\n\\t\\t\\tif subword in wordDict:\\n\\t\\t\\t\\tdp[i+1] = True\\n\\t\\t\\t\\tbreak\\n\\n\\treturn dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\tdp = [False]*(len(s)+1)\\n\\tdp[0] = True\\n\\twordDict = set(wordDict)\\n\\n\\t# check if words until index i are valid(in wordDict)\\n\\tfor i in range(len(s)):\\n\\t\\t# if word until index j is valid, than we only need to check if word[j:i+1] is valid for all substring word[:i+1] to be valid\\n\\t\\tfor j in range(i+1):\\n\\t\\t\\tif not dp[j]:\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t# we know word[:j] is valid if we are here, so if word[j:i+1] is valid we can check substring word[:i+1] as valid too\\n\\t\\t\\tsubword = s[j:i+1]\\n\\t\\t\\tif subword in wordDict:\\n\\t\\t\\t\\tdp[i+1] = True\\n\\t\\t\\t\\tbreak\\n\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 870374,
                "title": "java-short-and-crisp-dfs-time-space-beats-99-with-explanation",
                "content": "Instead of breaking string at every index from 0 to string.length() ,search if the word in Dictionary is prefix of the string.\\nIf (word is prefix of string) Break the string upto prefix and again apply recursion\\n\\nExample:\\ns = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\\nSol:\\ndfs(\"applepenapple\", Dictionary wordDict){\\nfor(word in wordDict)\\n\"applepenapple\" starts with \"apple\". so apply dfs on \"penapple\"\\n}\\ndfs(\"penapple\",apple,Dictionary wordDict){\\nfor(word in wordDict){\\n\"penapple\" does not start with apple ,so continue\\n\"penapple\" starts with pen ,so apply dfs on \"apple\"\\n}\\ndfs(\"apple\",Dictionary wordDict){\\nfor(word in wordDict){\\n\"apple\" starts with apple, so apply dfs on \"\"\\n}\\n}\\ndfs(\"\") {\\nif string is empty then we have successfully broken string using words in dictionary\\n}\\n\\nUse a hashmap to store already computed results.This is called memoization ,which hugely reduces time and space complexity.\\n\\n```\\nclass Solution {\\n    private HashMap<String,Boolean> memo;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t//Hashmap for memoization\\n        memo=new HashMap<String,Boolean>();\\n\\t//We know that ,if string is empty ,return true\\n        memo.put(\"\",true);\\n\\t//Start Depth-first-Search\\n        return recur(s,wordDict);\\n    }\\n    private boolean recur(String s,List<String> dictionary){\\n\\t//If given string is already computed,then return stored result\\n        if(memo.containsKey(s)) return memo.get(s);\\n\\t//Variable to store result\\n        boolean res=false;\\n\\t//For every word in Dictionary,check if the word is prefix of input string\\n        for(String word: dictionary){\\n            if(s.startsWith(word)){\\n\\t\\t\\t//If you find string can be broken ,then stop searching \\n                if(recur(s.substring(word.length()),dictionary)){\\n                    res=true;\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\t//Store result to prevent same computations in future\\n        memo.put(s,res);\\n        return res;\\n    }\\n}\\n```\\nLink for follow up problem : **Word Break 2**\\nhttps://leetcode.com/problems/word-break-ii/discuss/871333/Java-short-and-crisp-DFSmemoization-or-With-Explanation\\n\\nHope you find it useful.\\nThank You",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private HashMap<String,Boolean> memo;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t//Hashmap for memoization\\n        memo=new HashMap<String,Boolean>();\\n\\t//We know that ,if string is empty ,return true\\n        memo.put(\"\",true);\\n\\t//Start Depth-first-Search\\n        return recur(s,wordDict);\\n    }\\n    private boolean recur(String s,List<String> dictionary){\\n\\t//If given string is already computed,then return stored result\\n        if(memo.containsKey(s)) return memo.get(s);\\n\\t//Variable to store result\\n        boolean res=false;\\n\\t//For every word in Dictionary,check if the word is prefix of input string\\n        for(String word: dictionary){\\n            if(s.startsWith(word)){\\n\\t\\t\\t//If you find string can be broken ,then stop searching \\n                if(recur(s.substring(word.length()),dictionary)){\\n                    res=true;\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\t//Store result to prevent same computations in future\\n        memo.put(s,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1841940,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567045,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1568170,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1570170,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567885,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999348,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999923,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999123,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567312,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1576436,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1841940,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567045,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1568170,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1570170,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567885,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999348,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999923,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999123,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567312,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1576436,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1575228,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1569445,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1999133,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1570336,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1999192,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1572509,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1747347,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1572067,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1568962,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1568963,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 2040318,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1999193,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1709927,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1575802,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1575291,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1574177,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1572610,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1571303,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1570216,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1574247,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1568964,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 1749678,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2058348,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2044128,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2040401,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2040259,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2040237,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2035878,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2020800,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2017228,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2003432,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2001835,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2001701,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000266,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000217,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000214,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000209,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000199,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000197,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000149,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000128,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 2000061,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999995,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999982,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999821,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999709,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999635,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999570,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999540,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999430,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999401,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999359,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999317,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999308,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999300,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999275,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999253,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999188,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999177,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999140,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1991499,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1990363,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1959897,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1954723,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1928096,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1904346,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1904208,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1901994,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1888946,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1869848,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1786529,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1779789,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1779482,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778293,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1768469,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1766927,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1713335,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1688641,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1684268,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1823077,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            }
        ]
    }
]