[
    {
        "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
        "question_content": "A string is a valid parentheses string&nbsp;(denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and:\r\n\r\n\r\n\tIt is the empty string, or\r\n\tIt can be written as&nbsp;AB&nbsp;(A&nbsp;concatenated with&nbsp;B), where&nbsp;A&nbsp;and&nbsp;B&nbsp;are VPS's, or\r\n\tIt can be written as&nbsp;(A), where&nbsp;A&nbsp;is a VPS.\r\n\r\n\r\nWe can&nbsp;similarly define the nesting depth depth(S) of any VPS S as follows:\r\n\r\n\r\n\tdepth(\"\") = 0\r\n\tdepth(A + B) = max(depth(A), depth(B)), where A and B are VPS's\r\n\tdepth(\"(\" + A + \")\") = 1 + depth(A), where A is a VPS.\r\n\r\n\r\nFor example,&nbsp; \"\",&nbsp;\"()()\", and&nbsp;\"()(()())\"&nbsp;are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's.\r\n\r\n&nbsp;\r\n\r\nGiven a VPS seq, split it into two disjoint subsequences A and B, such that&nbsp;A and B are VPS's (and&nbsp;A.length + B.length = seq.length).\r\n\r\nNow choose any such A and B such that&nbsp;max(depth(A), depth(B)) is the minimum possible value.\r\n\r\nReturn an answer array (of length seq.length) that encodes such a&nbsp;choice of A and B:&nbsp; answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.&nbsp; Note that even though multiple answers may exist, you may return any of them.\r\n&nbsp;\nExample 1:\n\nInput: seq = \"(()())\"\nOutput: [0,1,1,1,1,0]\n\nExample 2:\n\nInput: seq = \"()(())()\"\nOutput: [0,0,0,1,1,0,1,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= seq.size <= 10000",
        "solutions": [
            {
                "id": 358419,
                "title": "confused-by-this-problem-i-was-too-here-is-how-it-became-crystal-clear",
                "content": "# Some observations\\n\\n1. This problem uses very abstract and non-intuitive language; this is not a bad thing, just makes it hard to understand for those of us who are not well versed in that particular language.\\n2. The problem uses seemingly ambiguous language, when overloading the meaning of `A` and `B`: It first talks about `A` and `B` in the context of the definition of a VPS, but then re-defines `A` and `B` later as two disjoint subsequences in the solution of the problem, absolutely unrelated to the first definition.\\n3. After looking at some explanations and code samples, I see that the solution depends on whether or not the depth of a parenthesis is odd or not, but I did not get why, so I kept on pondering...\\n\\n# First things first: What is a VPS?\\nA VPS (or \"valid parentheses string\") is just a string containing balanced parentheses, i.e. any opening parenthesis is followed by exactly one that closes it, and any closing parenthesis is preceded by at least one unbalanced opening parenthesis.\\n\\nValid examples: `((()))`, `(())()`, `()((((((()))))))()()()()` etc.\\n\\nInvalid examples: `)(`, `))`, `(())()))` etc.\\n\\n# Now, what does this problem really want from me?\\n\\nWe are trying to minimize depth of a VPS by splitting all pairs of parentheses into two groups `A` and `B`. `A` and `B` can be any **disjoint** sub-sequence of the input sequence, as long as they are still VPS **without changing the order** of anything (side-note: the `order` constraint is implied by the word `sequence`).\\n\\nSome examples:\\n\\n1. `\"(())\"` can be grouped into `A = \"()\"` and `B = \"()\"` or, `A = \"\"` and `B = \"(())\"`, but, for example, not `A = \"((\"` and `B = \"))\"` as those are not VPS\\n1. `\"(())()\"` can be grouped into `A = \"(())\"` and `B = \"()\"`, and many other ways\\n\\nHowever, the goal is to **minimize** the **max depth** of both groups.\\n\\nIn the last example (`\"(())()\"`), the grouping (`A = \"(())\"` and `B = \"()\"`) is not minimal, because `A` has a max-depth of 2 while there exists a grouping where both only have a depth of 1, namely: `A = ()()` and `B = ()`, or to visualize the designation:\\n\\n```\\nparentheses =   [ (, (, ), ), (, )]\\ndepths =        [ 1, 2, 2, 1, 1, 1 ]\\ngroups =        [ A, B, B, A, A, A]\\nsolution =      [ 0, 1, 1, 0, 0, 0]\\n```\\n\\nNOTE: One of several other solutions would be: `[1, 0, 0, 1, 0, 0]`, as `A` and `B` maintain a max depth of 1. Solutions are not unique.\\n\\n\\n# Going deeper: How to minimize the depth?\\n\\nThis optimization problem does not really care too much about anything but the most deeply nested subset. If we can solve that, we can easily solve the rest. For example, in the previous example that deepest stack would be `(())`. The remaining `()` we can put either in `A` or `B` (because, as it turns out they will have a depth of at most (roughly) `maxDepth/2`, so we don\\'t care whether they are in `A` or in `B`; explained later).\\n\\nSo, given a tall, but simple stack of parentheses, such as `((((((((()))))))))`, how do we split it into two disjoint sub-sequences that happen to be VPS, while also *minimizing* each of their depth?\\n\\nSince we can only split all parentheses into two groups, the minimum depth we can achieve will always be `ceil(maxDepth/2)` and we achieve it by putting one half in each group. Trying to put less than half in one of the two groups, will leave the other group with more than one half.\\n\\nOnce we handled the deepest stack, we can handle all other stacks using the same strategy, making sure that no other parenthesis will increase the max depth.\\n\\nInteresting side note: Any stack in the sequence that is of max depth less or equal to `ceil(globalMaxDepth/2)` (of the entire sequence) we can assign any which way we want (as long as we maintain the VPS property), since they cannot increase the max depth of the resulting split.\\nE.g.: when looking at `\"((()))()()()()\"`, we just gotta take good care of the first `\"((()))\"`, then we can assign each following parenthesis pair `\"()\"` to `A` or `B` any which way we want, since their max depth is less or equal to `ceil(3/2) = 2`.\\n\\n# Solution\\n\\nSo what we need is a strategy to cut any stack in half while making sure that the resulting half-stacks are balanced VPS. There are many ways of doing that, but one of the easiest (and seemingly a very common) approach is the odd/even strategy:\\n\\n1. Get the depth at every index of the string\\n1. Put all odd-depth parentheses in one group, and all even-depth in the other\\n1. Done.\\n\\nNOTE: Using this solution, parentheses at the same depth are always in the same group, so you can ensure that the resulting groups are balanced VPS.\\n\\n\\n# Code\\n\\nYou can find many examples on this discussion board; here is mine:\\n\\n```python\\nclass Solution:\\n  def maxDepthAfterSplit(self, s: str) -> List[int]:\\n    groups = []\\n    d = 0\\n    for c in s:\\n      open = c == \\'(\\'\\n      if open:\\n        d += 1\\n      groups.append(d % 2)  # group determined through parity (odd/even?) of depth\\n      if not open:\\n        d -=1\\n    \\n    return groups\\n```",
                "solutionTags": [],
                "code": "```\\nparentheses =   [ (, (, ), ), (, )]\\ndepths =        [ 1, 2, 2, 1, 1, 1 ]\\ngroups =        [ A, B, B, A, A, A]\\nsolution =      [ 0, 1, 1, 0, 0, 0]\\n```\n```python\\nclass Solution:\\n  def maxDepthAfterSplit(self, s: str) -> List[int]:\\n    groups = []\\n    d = 0\\n    for c in s:\\n      open = c == \\'(\\'\\n      if open:\\n        d += 1\\n      groups.append(d % 2)  # group determined through parity (odd/even?) of depth\\n      if not open:\\n        d -=1\\n    \\n    return groups\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328841,
                "title": "java-c-python-o-1-extra-space-except-output",
                "content": "## Solution 0: Alternatively Distribute Parentheses\\nBasically, `(` is 1 point, `)` is `-1` point.\\nWe try to keep total points of two groups even,\\nby distributing parentheses alternatively.\\n\\nThe good part of this solution is that,\\nwe actually need no extra variable to record anything.\\n\\n\\n**Java:**\\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length(), res[] = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = seq.charAt(i) == \\'(\\' ? i & 1 : (1 - i & 1);\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res(seq.length());\\n        for (int i = 0; i < seq.length(); ++i)\\n            res[i] = i & 1 ^ (seq[i] == \\'(\\');\\n        return res;\\n    }\\n```\\n\\n**1-line Python:**\\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        return [i & 1 ^ (seq[i] == \\'(\\') for i, c in enumerate(seq)]\\n```\\n<br>\\n\\n# Complexity\\nTime `O(N)` for one pass\\nSpace `O(1)` extra space,  `O(N)` for output\\n<br>\\n\\n# More\\nAlso provide some more easy understood ideas for this problem,\\npick the the one you like.\\n(As I keep receiving complaints about the readability,\\nlike no parentheses in solution for problem of parentheses)\\n<br>\\n\\n# Solution 1: Keep Two Group Even\\nCount the number of open parentheses of group `A` and group `B`.\\n**Java:**\\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int A = 0, B = 0, n = seq.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (seq.charAt(i) == \\'(\\') {\\n                if (A < B) {\\n                    ++A;\\n                } else {\\n                    ++B;\\n                    res[i] = 1;\\n                }\\n            } else {\\n                if (A > B) {\\n                    --A;\\n                } else {\\n                    --B;\\n                    res[i] = 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int A = 0, B = 0, n = seq.length();\\n        vector<int> res(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (seq[i] == \\'(\\') {\\n                if (A < B) ++A;\\n                else ++B, res[i] = 1;\\n            } else {\\n                if (A > B) --A;\\n                else --B, res[i] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        A = B = 0\\n        res = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            v = 1 if c == \\'(\\' else -1\\n            if (v > 0) == (A < B):\\n                A += v\\n            else:\\n                B += v\\n                res[i] = 1\\n        return res\\n\\n```\\n<br>\\n\\n# Solution 2: Split by Half\\nCount the number of level of whole string.\\nThen split it by half.\\nGroup 0: the part under the half height\\nGroup 1: the part above the half height\\n\\n**Java:**\\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth = 0, cur = 0, n = seq.length();\\n        for (int i = 0; i < n; ++i) {\\n            cur +=  seq.charAt(i) == \\'(\\' ?  1 : -1;\\n            depth = Math.max(depth, cur);\\n        }\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (seq.charAt(i) == \\'(\\') {\\n                if (++cur > depth / 2)\\n                    res[i] = 1;\\n            } else {\\n                if (cur-- > depth / 2)\\n                    res[i] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int depth = 0, cur = 0, n = seq.length();\\n        for (char c : seq)\\n            depth = max(depth, cur += c == \\'(\\' ? 1 : -1);\\n        vector<int> res(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (seq[i] == \\'(\\' && ++cur > depth / 2) res[i] = 1;\\n            if (seq[i] == \\')\\' && cur-- > depth / 2) res[i] = 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        depth = cur = 0\\n        for c in seq:\\n            if c == \\'(\\':\\n                cur += 1\\n                depth = max(depth, cur)\\n            else:\\n                cur -= 1\\n        half = depth / 2\\n        res = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                cur += 1\\n                if cur > half: res[i] = 1\\n            else:\\n                if cur > half: res[i] = 1\\n                cur -= 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length(), res[] = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = seq.charAt(i) == \\'(\\' ? i & 1 : (1 - i & 1);\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res(seq.length());\\n        for (int i = 0; i < seq.length(); ++i)\\n            res[i] = i & 1 ^ (seq[i] == \\'(\\');\\n        return res;\\n    }\\n```\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        return [i & 1 ^ (seq[i] == \\'(\\') for i, c in enumerate(seq)]\\n```\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int A = 0, B = 0, n = seq.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (seq.charAt(i) == \\'(\\') {\\n                if (A < B) {\\n                    ++A;\\n                } else {\\n                    ++B;\\n                    res[i] = 1;\\n                }\\n            } else {\\n                if (A > B) {\\n                    --A;\\n                } else {\\n                    --B;\\n                    res[i] = 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int A = 0, B = 0, n = seq.length();\\n        vector<int> res(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (seq[i] == \\'(\\') {\\n                if (A < B) ++A;\\n                else ++B, res[i] = 1;\\n            } else {\\n                if (A > B) --A;\\n                else --B, res[i] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        A = B = 0\\n        res = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            v = 1 if c == \\'(\\' else -1\\n            if (v > 0) == (A < B):\\n                A += v\\n            else:\\n                B += v\\n                res[i] = 1\\n        return res\\n\\n```\n```java\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth = 0, cur = 0, n = seq.length();\\n        for (int i = 0; i < n; ++i) {\\n            cur +=  seq.charAt(i) == \\'(\\' ?  1 : -1;\\n            depth = Math.max(depth, cur);\\n        }\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (seq.charAt(i) == \\'(\\') {\\n                if (++cur > depth / 2)\\n                    res[i] = 1;\\n            } else {\\n                if (cur-- > depth / 2)\\n                    res[i] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int depth = 0, cur = 0, n = seq.length();\\n        for (char c : seq)\\n            depth = max(depth, cur += c == \\'(\\' ? 1 : -1);\\n        vector<int> res(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (seq[i] == \\'(\\' && ++cur > depth / 2) res[i] = 1;\\n            if (seq[i] == \\')\\' && cur-- > depth / 2) res[i] = 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def maxDepthAfterSplit(self, seq):\\n        depth = cur = 0\\n        for c in seq:\\n            if c == \\'(\\':\\n                cur += 1\\n                depth = max(depth, cur)\\n            else:\\n                cur -= 1\\n        half = depth / 2\\n        res = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                cur += 1\\n                if cur > half: res[i] = 1\\n            else:\\n                if cur > half: res[i] = 1\\n                cur -= 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 328920,
                "title": "very-easy-and-clean-code-one-pass-o-n-with-explanation",
                "content": "# intuition\\nif we are going deeper, take turns to assign to A and B\\n```\\n1.         ( ( ( ( ( ) ) ) ) )\\n   level   1 2 3 4 5 5 4 3 2 1  \\n   A takes level 1,3,5 and B takes level 2,4 ==> A : ( ( ( ) ) ) , B : ( ( ) )\\n2.         ( ( ) ) ( ( ( ) ) )\\n   level   1 2 2 1 1 2 3 3 2 1\\n   A takes level 1,3 and B takes level 2 ==> A : ( ) ( ( ) ) , B : ( ) ( )\\n   \\nwhen to increase/decrese level ?\\n1. meet a new \\'(\\' level up\\n2. meet a new \\')\\' level down\\n\\nif you can understand the level conception, coding is quite easy.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res(seq.size(),0);\\n        int level = 0, index = 0;\\n        while(index < seq.size()){\\n            if(seq[index] ==\\'(\\')\\n                res[index] = ++level%2;\\n            else\\n                res[index] = level--%2;\\n            index++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1.         ( ( ( ( ( ) ) ) ) )\\n   level   1 2 3 4 5 5 4 3 2 1  \\n   A takes level 1,3,5 and B takes level 2,4 ==> A : ( ( ( ) ) ) , B : ( ( ) )\\n2.         ( ( ) ) ( ( ( ) ) )\\n   level   1 2 2 1 1 2 3 3 2 1\\n   A takes level 1,3 and B takes level 2 ==> A : ( ) ( ( ) ) , B : ( ) ( )\\n   \\nwhen to increase/decrese level ?\\n1. meet a new \\'(\\' level up\\n2. meet a new \\')\\' level down\\n\\nif you can understand the level conception, coding is quite easy.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res(seq.size(),0);\\n        int level = 0, index = 0;\\n        while(index < seq.size()){\\n            if(seq[index] ==\\'(\\')\\n                res[index] = ++level%2;\\n            else\\n                res[index] = level--%2;\\n            index++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328843,
                "title": "mountain-shaving-algorithm",
                "content": "\\n\\nJust shave off all sub-VPSs of `level > max_level / 2` to 1 and appoint the rest to 0.\\nThis may be visualized with a mountain that corresponds to a VPS.\\n\\nThe visualiztion method:\\n```\\n      _\\n( =  /     (Uphill)\\n\\n     _\\n) =   \\\\    (Downhill)\\n```\\n\\n`()(())() will give the following hill`\\n\\n```\\n( ) ( ( ) ) ( )\\n       __\\n __  _/  \\\\_  __  ____________________<] FIRE LASER     \\n/  \\\\/      \\\\/  \\\\                      | & SHAVE THE MOUNTAIN!\\n\\n                     ||\\n                    \\\\||/\\n                \\t \\\\/\\n\\n       __\\n      /  \\\\           Top of mountain  = \"   ()   \"       \\n      \\n __  ______  __\\n/  \\\\/      \\\\/  \\\\     Base of mountain = \"()(  )()\"\\n\\n```\\n\\nPR0GR4M C0D3:\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int lvl = 0, maxlvl = 0;\\n        for (char c : seq) {\\n            if (c == \\'(\\') {\\n                lvl++;\\n                maxlvl = max(lvl, maxlvl);\\n            } else if (c == \\')\\') {\\n                lvl--;\\n            }\\n        }\\n        int cnt1 = 0;\\n        vector<int> ret(seq.size());\\n        vector<int> openings;\\n        int pos = 0;\\n        lvl = 0;\\n        for (char c : seq) {\\n            if (c == \\'(\\') {\\n                lvl ++;\\n                openings.push_back(pos);\\n            } else if (c == \\')\\') {\\n                bool should_make_1 = false;\\n                \\n                if (pos == seq.size()-1 && cnt1 == 0) {\\n                    should_make_1 = true;\\n                }\\n                if (/*lvl > maxlvl/2*/ lvl == maxlvl/2 + 1) {\\n                    should_make_1 = true;\\n                }\\n                \\n                if (should_make_1) {\\n                    for (int i=openings.back(); i<=pos; i++) {\\n                        if (ret[i] == 0) cnt1 ++;\\n                        ret[i] = 1;\\n                    }\\n                }\\n                openings.pop_back();\\n                lvl --;\\n            }\\n            \\n            pos ++;\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n      _\\n( =  /     (Uphill)\\n\\n     _\\n) =   \\\\    (Downhill)\\n```\n```\\n( ) ( ( ) ) ( )\\n       __\\n __  _/  \\\\_  __  ____________________<] FIRE LASER     \\n/  \\\\/      \\\\/  \\\\                      | & SHAVE THE MOUNTAIN!\\n\\n                     ||\\n                    \\\\||/\\n                \\t \\\\/\\n\\n       __\\n      /  \\\\           Top of mountain  = \"   ()   \"       \\n      \\n __  ______  __\\n/  \\\\/      \\\\/  \\\\     Base of mountain = \"()(  )()\"\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int lvl = 0, maxlvl = 0;\\n        for (char c : seq) {\\n            if (c == \\'(\\') {\\n                lvl++;\\n                maxlvl = max(lvl, maxlvl);\\n            } else if (c == \\')\\') {\\n                lvl--;\\n            }\\n        }\\n        int cnt1 = 0;\\n        vector<int> ret(seq.size());\\n        vector<int> openings;\\n        int pos = 0;\\n        lvl = 0;\\n        for (char c : seq) {\\n            if (c == \\'(\\') {\\n                lvl ++;\\n                openings.push_back(pos);\\n            } else if (c == \\')\\') {\\n                bool should_make_1 = false;\\n                \\n                if (pos == seq.size()-1 && cnt1 == 0) {\\n                    should_make_1 = true;\\n                }\\n                if (/*lvl > maxlvl/2*/ lvl == maxlvl/2 + 1) {\\n                    should_make_1 = true;\\n                }\\n                \\n                if (should_make_1) {\\n                    for (int i=openings.back(); i<=pos; i++) {\\n                        if (ret[i] == 0) cnt1 ++;\\n                        ret[i] = 1;\\n                    }\\n                }\\n                openings.pop_back();\\n                lvl --;\\n            }\\n            \\n            pos ++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328847,
                "title": "python-greedy-o-n-with-clarification-and-analysis",
                "content": "### To clarify the question\\n\\nThe split result is two subsequences, not necessarily two substrings. The difference between a subsequence and a substring is that a subsequence doesn\\'t have to be continuous. For example, `\"ABDG\"` is not a substring of `\"ABCDEFG\"`, but it is a subsequence.\\n\\n---\\n\\n### Solution Analysis\\nSince we are spliting the original string into subsequences, we don\\'t care whether they are continuous. As long as the resulting subsequences have their parentheses from the original string **in the original order**, that is good enough. To guarantee they are in the original order, we can simply scan from left to right once, and hopefully we can determine which (A or B) subsequence does the parenthesis belong to **right after we scan to it**. -- so we are looking for a greedy algorithm.\\n\\nSo can we determine it right away? Yes. Apart from keeping the origional order, the **only** other goal is to minimize the depth. That means, **to achieve this goal**, when we see a `\"(\"` we should allocate it to the subsequence with less unmatched `\"(\"`; when we see a `\")\"`, we should allocate it to the subsequence with more unmatched `\"(\"`.\\n\\n---\\n\\n### Code [Python]\\n```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        res = [None] * len(seq)\\n        A = B = 0\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                if A <= B:\\n                    A += 1\\n                    res[i] = 0\\n                else:\\n                    B += 1\\n                    res[i] = 1\\n            else:\\n                if A >= B:\\n                    A -= 1\\n                    res[i] = 0\\n                else:\\n                    B -= 1\\n                    res[i] = 1\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        res = [None] * len(seq)\\n        A = B = 0\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                if A <= B:\\n                    A += 1\\n                    res[i] = 0\\n                else:\\n                    B += 1\\n                    res[i] = 1\\n            else:\\n                if A >= B:\\n                    A -= 1\\n                    res[i] = 0\\n                else:\\n                    B -= 1\\n                    res[i] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328946,
                "title": "submitting-only-1-s-works-edit-fixed",
                "content": "Edit: This was fixed, this doesn\\'t work anymore.\\n\\nIf you submit a vector with all 1\\'s, it works.\\n\\nThe code below for C++ actually works.\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> answer(seq.length());\\n        for(int i=0;i<seq.length();i++) answer[i]=1;\\n        return answer;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> answer(seq.length());\\n        for(int i=0;i<seq.length();i++) answer[i]=1;\\n        return answer;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 328842,
                "title": "c-java-o-n-greedy",
                "content": "# Intuition\\n1. We need to minimize the depth of two disjoint subsequences. \\n3. For ```A``` string, we can reduce the depth by half by splitting ```A``` into two disjoint subsequences.\\n   - for example, the depth of ```(((())))``` is 4, and the best split we can do is ```(())``` and ```(())``` with the depth of 2.  \\n   - we can put parentheses with odd depth into the first subsequence, and with even - to the second. \\n3. For ```AB``` string, we can solve the problem independently for ```A``` and ```B```.\\n   - for example, ```((()))(()())``` is concatenation of ```((()))``` and ```(()())``` with depths 3 and 2 correspondingly.\\n# C++\\n```\\nvector<int> maxDepthAfterSplit(string seq, int depth = 0) {\\n  vector<int> res;\\n  for (auto c : seq) {\\n    if (c == \\'(\\') res.push_back(depth++ % 2);\\n    else res.push_back(--depth % 2);        \\n  }\\n  return res;\\n}\\n```\\n# Java\\n```\\npublic int[] maxDepthAfterSplit(String seq) {\\n  int[] res = new int[seq.length()];\\n  for (int i = 0, depth = 0; i < seq.length(); ++i) {\\n    if (seq.charAt(i) == \\'(\\') res[i] = depth++ % 2;\\n    else res[i] = --depth % 2;\\n  }\\n  return res;\\n}\\n```\\n# Complexity Analysis\\nRuntime: *O(n)*;\\nMemory: *O(1)*, or *O(n)* if we consider the result.",
                "solutionTags": [],
                "code": "```A```\n```A```\n```(((())))```\n```(())```\n```(())```\n```AB```\n```A```\n```B```\n```((()))(()())```\n```((()))```\n```(()())```\n```\\nvector<int> maxDepthAfterSplit(string seq, int depth = 0) {\\n  vector<int> res;\\n  for (auto c : seq) {\\n    if (c == \\'(\\') res.push_back(depth++ % 2);\\n    else res.push_back(--depth % 2);        \\n  }\\n  return res;\\n}\\n```\n```\\npublic int[] maxDepthAfterSplit(String seq) {\\n  int[] res = new int[seq.length()];\\n  for (int i = 0, depth = 0; i < seq.length(); ++i) {\\n    if (seq.charAt(i) == \\'(\\') res[i] = depth++ % 2;\\n    else res[i] = --depth % 2;\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329275,
                "title": "i-don-t-know-why-it-is-wrong",
                "content": "![image](https://assets.leetcode.com/users/arajo/image_1562506850.png)\\n\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        depth = 0\\n        out = [0]\\n        f = seq[0]\\n        \\n        if len(seq)==0: return depth\\n        else:\\n            n = 1\\n            while n < len(seq):\\n                if f==seq[n]:\\n                    out.append(1)\\n                    n += 1\\n                    if n < len(seq) and f != seq[n] :\\n                        out.append(1)\\n                        n += 1\\n                else: \\n                    out.append(0)\\n                    f = seq[n]\\n                    n += 1\\n        return out",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/arajo/image_1562506850.png)\\n\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        depth = 0\\n        out = [0]\\n        f = seq[0]\\n        \\n        if len(seq)==0: return depth\\n        else:\\n            n = 1\\n            while n < len(seq):\\n                if f==seq[n]:\\n                    out.append(1)\\n                    n += 1\\n                    if n < len(seq) and f != seq[n] :\\n                        out.append(1)\\n                        n += 1\\n                else: \\n                    out.append(0)\\n                    f = seq[n]\\n                    n += 1\\n        return out",
                "codeTag": "Java"
            },
            {
                "id": 1206226,
                "title": "100-solution-clear-description-simple-explanation-time-o-n-space-o-1",
                "content": "The problem:\\n\\n```\\nFor example,\\nseq = \"()(())\"\\nA   = \"()(  )\"\\nB   = \"   () \"\\nans = \"000110\"\\n```\\nSpliting the given string seq into two sub-sequences A and B, so that:\\n1. A and B are both VPS\\n2. the number of \"(\" of A plus that of B equals to the number of \"(\" of seq. (sub-sequence, not substring)\\n3. let M=max(depth(A), depth(B)), our job is to find the right A and B to minimize M\\n4. using 0 to denote that the i\\'th character belongs to A\\n\\n\\nThe Algorithm:\\n\\nIt starts as an algorithm to pair \"(\" and \")\" of the given string named \"seq\". We use stack to record the position i of every \"(\" and pop the stack to get a pair.\\n\\nNow, let us focus on the max depth of the stack, which is also the depth of VPS. e.g. \"((()))\". According to the problem, our job is to minimized such depth. \\n\\nOur method is to slow the growth of the depth of VPS, distribute the \"(\" and corresponding \")\" to A and B so that it takes twice effort to increase the depth. Actually, we can track the depth of the stack,\\nas long as it is odd, distribute them to B, and distribute to A for even (we can also swap A and B). \\n\\nActually, the stack is useless, we just need a counter to track the depth of the stack. The codes are given in the following.\\n\\nIn case it helps your, plz upvote to supprt.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cnt=-1;\\n        int N=seq.size();\\n        const char * c=seq.c_str();\\n        vector<int> ans (N);\\n        for(int i=0; i<N; ++i) {\\n            if(c[i]==\\'(\\') {\\n                ++cnt;\\n                ans[i]=cnt&1;\\n            } else {\\n                ans[i]=cnt&1;\\n                --cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nFor example,\\nseq = \"()(())\"\\nA   = \"()(  )\"\\nB   = \"   () \"\\nans = \"000110\"\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cnt=-1;\\n        int N=seq.size();\\n        const char * c=seq.c_str();\\n        vector<int> ans (N);\\n        for(int i=0; i<N; ++i) {\\n            if(c[i]==\\'(\\') {\\n                ++cnt;\\n                ans[i]=cnt&1;\\n            } else {\\n                ans[i]=cnt&1;\\n                --cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329273,
                "title": "strange-error-need-help-28-31-test-cases-passed-and-then-a-strange-error",
                "content": "![image](https://assets.leetcode.com/users/dkcs/image_1562506547.png)\\n\\nany idea why its being shown like this?\\nIt says 28/31 test cases passed and this error\\nmy code is as follows:\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) \\n    {        \\n        char ch[]=seq.toCharArray();\\n        int c=0;\\n        int n[]=new int[ch.length];\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                ++c;\\n                if(c%2!=0)\\n                    n[i]=0;\\n                else\\n                    n[i]=1;\\n            }\\n            else\\n            {\\n                --c;\\n                if(c%2==0)\\n                    n[i]=0;\\n                else\\n                    n[i]=1;\\n            }   \\n        }\\n        return n;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) \\n    {        \\n        char ch[]=seq.toCharArray();\\n        int c=0;\\n        int n[]=new int[ch.length];\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]==\\'(\\')\\n            {\\n                ++c;\\n                if(c%2!=0)\\n                    n[i]=0;\\n                else\\n                    n[i]=1;\\n            }\\n            else\\n            {\\n                --c;\\n                if(c%2==0)\\n                    n[i]=0;\\n                else\\n                    n[i]=1;\\n            }   \\n        }\\n        return n;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340417,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n        A = B = 0 # max opens for 2 groups\\n        res = [0] * len(seq) # we split into sequences, not continuous subarrays\\n        for i, c in enumerate(seq):\\n            v = 1 if c == \\'(\\' else -1\\n            if (v > 0) == (A < B): A += v\\n            else:\\n                B += v\\n                res[i] = 1\\n        return res\\n    \\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        depth = 0\\n        ans = list()\\n        for c in seq:\\n            if c == \"(\":\\n                ans.append(depth % 2)\\n                depth += 1\\n            else:\\n                depth -= 1\\n                ans.append(depth % 2)\\n        return ans\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n        A = B = 0 # max opens for 2 groups\\n        res = [0] * len(seq) # we split into sequences, not continuous subarrays\\n        for i, c in enumerate(seq):\\n            v = 1 if c == \\'(\\' else -1\\n            if (v > 0) == (A < B): A += v\\n            else:\\n                B += v\\n                res[i] = 1\\n        return res\\n    \\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        depth = 0\\n        ans = list()\\n        for c in seq:\\n            if c == \"(\":\\n                ans.append(depth % 2)\\n                depth += 1\\n            else:\\n                depth -= 1\\n                ans.append(depth % 2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329635,
                "title": "c-100-javascript-c-odd-even-levels-easy-to-understand",
                "content": "When depth increases - change set, so we divide depths/levels between sets as even as possible. \\n\\nIf you imagine histogram with parentheses nesting depth represented as height of the bars, and put all even vertical levels to one set and the rest (odd levels) to the other, then you basically get a solution to the problem.\\n\\nSmall catch, to match open to close parenthesis, for open parenthesis first increment then calculate set code (0 or 1), for close case first calculate set then decrement depth, this way parenthesis will match.\\n\\nC++ human friendly version\\n```\\nvector<int> maxDepthAfterSplit1(string seq) {\\n    int size = seq.size();\\n    vector<int> result(size);\\n    int depth = 0;\\n    for(int i = 0; i < size; ++i) {\\n        if (seq[i] == \\'(\\') {\\n            ++depth;\\n            result[i] = depth % 2;\\n        } else  {\\n            result[i] = depth % 2;\\n            --depth;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nC++\\n```\\nvector<int> maxDepthAfterSplit(string seq) {\\n    vector<int> result;\\n    int depth = 0;\\n    for(auto& ch: seq) \\n        result.push_back(ch == \\'(\\' ? ++depth % 2 : depth-- % 2);\\n    return result;\\n}\\n```\\n\\nC# human friendly version\\n```\\npublic int[] MaxDepthAfterSplit(string seq) {\\n    var result = new int[seq.Length];\\n    var depth = 0;\\n    for(var i = 0; i < seq.Length; ++i) {\\n        if (seq[i] == \\'(\\') {\\n            ++depth;\\n            result[i] = depth % 2;\\n        } else  {\\n            result[i] = depth % 2;\\n            --depth;\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nC# short version\\n```\\npublic int[] MaxDepthAfterSplit(string seq) {\\n    var result = new int[seq.Length];\\n    var depth = 0;\\n    for(var i = 0; i < seq.Length; ++i)\\n        result[i] = seq[i] == \\'(\\' ? ++depth % 2 : depth-- % 2;\\n    return result;\\n}\\n```\\n\\nJavascript human friendly version\\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        if (ch == \\'(\\') {\\n            ++depth;\\n            result.push(depth & 1);\\n        } else  {\\n            result.push(depth & 1);\\n            --depth;\\n        }\\n    }\\n    return result;\\n};\\n```\\n\\nJavascript\\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        result.push(ch == \\'(\\' ? ++depth & 1 : depth-- & 1);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nvector<int> maxDepthAfterSplit1(string seq) {\\n    int size = seq.size();\\n    vector<int> result(size);\\n    int depth = 0;\\n    for(int i = 0; i < size; ++i) {\\n        if (seq[i] == \\'(\\') {\\n            ++depth;\\n            result[i] = depth % 2;\\n        } else  {\\n            result[i] = depth % 2;\\n            --depth;\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\nvector<int> maxDepthAfterSplit(string seq) {\\n    vector<int> result;\\n    int depth = 0;\\n    for(auto& ch: seq) \\n        result.push_back(ch == \\'(\\' ? ++depth % 2 : depth-- % 2);\\n    return result;\\n}\\n```\n```\\npublic int[] MaxDepthAfterSplit(string seq) {\\n    var result = new int[seq.Length];\\n    var depth = 0;\\n    for(var i = 0; i < seq.Length; ++i) {\\n        if (seq[i] == \\'(\\') {\\n            ++depth;\\n            result[i] = depth % 2;\\n        } else  {\\n            result[i] = depth % 2;\\n            --depth;\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\npublic int[] MaxDepthAfterSplit(string seq) {\\n    var result = new int[seq.Length];\\n    var depth = 0;\\n    for(var i = 0; i < seq.Length; ++i)\\n        result[i] = seq[i] == \\'(\\' ? ++depth % 2 : depth-- % 2;\\n    return result;\\n}\\n```\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        if (ch == \\'(\\') {\\n            ++depth;\\n            result.push(depth & 1);\\n        } else  {\\n            result.push(depth & 1);\\n            --depth;\\n        }\\n    }\\n    return result;\\n};\\n```\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    const result = [];\\n    let depth = 0;\\n    for(let ch of seq) {\\n        result.push(ch == \\'(\\' ? ++depth & 1 : depth-- & 1);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420665,
                "title": "java-optimize-easy",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] a = new int[seq.length()];\\n        \\n        int count = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n                a[i] = count++ % 2;\\n            }else{\\n                a[i] = --count % 2;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] a = new int[seq.length()];\\n        \\n        int count = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n                a[i] = count++ % 2;\\n            }else{\\n                a[i] = --count % 2;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609304,
                "title": "c-0-ms-faster-than-100-with-intuition-using-two-stacks-easy-to-understand",
                "content": "## Intuition:\\nWe need A and  B subsequences and they need to be valid paranthesis strings.\\n\\nLets traverse the array and assign each character of given string to A or B.\\n if current character is \\'(\\'\\n* we can assign it to A or B, but we have to decrease the max(depth(A),depth(B))\\n* if we have more \\'(\\' already in A than B that didn\\'t get corresponding \\')\\' yet. Then we should add it to B. because B is having less \\'(\\' waiting for \\')\\'.\\n* else if B has more \\'(\\' than \\'A\\' or both have equal \\'(\\' , we assign the cuurent \\'(\\' to A\\n\\n\\nIf current character is \\')\\'\\n* If A has more \\'(\\' waiting for corresponding \\')\\' than B. We assign the current \\')\\' to A\\n* else we assign to B\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq)\\n    {\\n        int n = seq.size() ;\\n        vector<int> ans(n) ;\\n        \\n        stack<int> st1 , st2 ; \\n\\t\\t// st1 holds indices all \\'(\\' in A waiting for corresponding \\')\\'\\n\\t\\t// st2 holds indices all \\'(\\' in A waiting for corresponding \\')\\'\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n\\t\\t\\t    // assign current \\'(\\' to the one with less number of \\'(\\' waiting\\n\\t\\t\\t\\t// so we push into respective stacks and mark ans[i] accordingly\\n                if(st1.size()>st2.size())\\n                {\\n                    st2.push(i) ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    st1.push(i) ; ans[i] = 0 ;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t   \\n\\t\\t\\t    // assign current \\')\\' to the one with more number of \\'(\\' waiting\\n\\t\\t\\t\\t//and pop one \\'(\\' from the group(A or B) to which the current \\')\\' has been assigned to\\n\\t\\t\\t\\t//mark ans[i] accordingly\\n                if(st1.size()<st2.size())\\n                {\\n                    st2.pop() ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    st1.pop() ; ans[i] = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n\\n```\\n\\n**Time** : O(n)\\n**Space** O(n)\\n\\n## Approach - 2 : (Optimised version of 1)\\nIf you can observe, we need not store the indices of \\'(\\'. We just need the count of \\'(\\' waiting in each stack.\\n\\nSo instead of using 2 stacks. We can just keep track of count\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq)\\n    {\\n        int n = seq.size() ;\\n        vector<int> ans(n) ;\\n        \\n        int c1 = 0 , c2 = 0 ;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n                if(c1>c2)\\n                {\\n                    c2++ ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    c1++ ; ans[i] = 0 ;\\n                }\\n            }\\n            else\\n            {\\n                if(c1<c2)\\n                {\\n                    c2-- ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    c1-- ; ans[i] = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```\\n\\n**Time** : O(n)\\n**Space**: O(1) not considering the vector to be returned",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq)\\n    {\\n        int n = seq.size() ;\\n        vector<int> ans(n) ;\\n        \\n        stack<int> st1 , st2 ; \\n\\t\\t// st1 holds indices all \\'(\\' in A waiting for corresponding \\')\\'\\n\\t\\t// st2 holds indices all \\'(\\' in A waiting for corresponding \\')\\'\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n\\t\\t\\t    // assign current \\'(\\' to the one with less number of \\'(\\' waiting\\n\\t\\t\\t\\t// so we push into respective stacks and mark ans[i] accordingly\\n                if(st1.size()>st2.size())\\n                {\\n                    st2.push(i) ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    st1.push(i) ; ans[i] = 0 ;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t   \\n\\t\\t\\t    // assign current \\')\\' to the one with more number of \\'(\\' waiting\\n\\t\\t\\t\\t//and pop one \\'(\\' from the group(A or B) to which the current \\')\\' has been assigned to\\n\\t\\t\\t\\t//mark ans[i] accordingly\\n                if(st1.size()<st2.size())\\n                {\\n                    st2.pop() ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    st1.pop() ; ans[i] = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq)\\n    {\\n        int n = seq.size() ;\\n        vector<int> ans(n) ;\\n        \\n        int c1 = 0 , c2 = 0 ;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n                if(c1>c2)\\n                {\\n                    c2++ ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    c1++ ; ans[i] = 0 ;\\n                }\\n            }\\n            else\\n            {\\n                if(c1<c2)\\n                {\\n                    c2-- ; ans[i] = 1 ;\\n                }\\n                else\\n                {\\n                    c1-- ; ans[i] = 0 ;\\n                }\\n            }\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346040,
                "title": "easy-python3-97-39-lesser-memory",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def toggler(toggle: int) -> int:\\n            if toggle == 1:\\n                return 0\\n            return 1\\n        ans = list()\\n        toggle = 0\\n        ans.append(toggle)\\n        l = len(seq)\\n        for i in range(l-1):\\n            if seq[i] == seq[i+1]:\\n                toggle = toggler(toggle)\\n            ans.append(toggle)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def toggler(toggle: int) -> int:\\n            if toggle == 1:\\n                return 0\\n            return 1\\n        ans = list()\\n        toggle = 0\\n        ans.append(toggle)\\n        l = len(seq)\\n        for i in range(l-1):\\n            if seq[i] == seq[i+1]:\\n                toggle = toggler(toggle)\\n            ans.append(toggle)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201480,
                "title": "cpp-c-easy-to-understand-beginner-friendly-solution-with-comments",
                "content": "```\\ncomments are written inside //  //.\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>p;                                    // first wee created vector tu put store resulting values//\\n        int max=0;                                       // created variable and assign with zero to count brackets//\\n        for(int i=0;i<seq.length();i++)       // traverse overr string //\\n        {\\n            if(seq[i]==\\'(\\')                          // cheacked for opening bracket condition//\\n                max++;                            //increse count//\\n            p.push_back(max%2);        //here is the logic \"max%2\" it gives the required op//\\n            if(seq[i]==\\')\\')                    //condition if brackets are empty//\\n                max--;                        //count decreases//\\n        }\\n        return p;                        //returned the vector as op//\\n    }\\n};\\n```\\n## *please upvote if yoou like the solution and feel free to ask any doubt in comments will surely reply.*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ncomments are written inside //  //.\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>p;                                    // first wee created vector tu put store resulting values//\\n        int max=0;                                       // created variable and assign with zero to count brackets//\\n        for(int i=0;i<seq.length();i++)       // traverse overr string //\\n        {\\n            if(seq[i]==\\'(\\')                          // cheacked for opening bracket condition//\\n                max++;                            //increse count//\\n            p.push_back(max%2);        //here is the logic \"max%2\" it gives the required op//\\n            if(seq[i]==\\')\\')                    //condition if brackets are empty//\\n                max--;                        //count decreases//\\n        }\\n        return p;                        //returned the vector as op//\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106478,
                "title": "python-simplest-solution-ac",
                "content": "if the previous bracket is same take it to the other VPS. Since given string is a valid VPS, this implementation will never raise any incorrect VPSs.\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = [0]*len(seq)\\n        x = 0\\n        for i in range(1,len(seq)):\\n            if seq[i]==seq[i-1]:\\n                x = 1-x\\n            ans[i] = x\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = [0]*len(seq)\\n        x = 0\\n        for i in range(1,len(seq)):\\n            if seq[i]==seq[i-1]:\\n                x = 1-x\\n            ans[i] = x\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902281,
                "title": "allocate-each-opening-bracket-alternately-to-a-and-b-98",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        out = []\\n        prev = \\'B\\'\\n        for l in seq:\\n            if l==\"(\":\\n                if prev==\\'A\\':\\n                    out.append(1)\\n                    prev = \\'B\\'\\n                else:\\n                    out.append(0)\\n                    prev = \\'A\\'\\n            else:\\n                if prev==\\'A\\':\\n                    out.append(0)\\n                    prev=\\'B\\'\\n                else:\\n                    out.append(1)\\n                    prev=\\'A\\'\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        out = []\\n        prev = \\'B\\'\\n        for l in seq:\\n            if l==\"(\":\\n                if prev==\\'A\\':\\n                    out.append(1)\\n                    prev = \\'B\\'\\n                else:\\n                    out.append(0)\\n                    prev = \\'A\\'\\n            else:\\n                if prev==\\'A\\':\\n                    out.append(0)\\n                    prev=\\'B\\'\\n                else:\\n                    out.append(1)\\n                    prev=\\'A\\'\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537260,
                "title": "easy-solution-beats-100-in-both-runtime-space",
                "content": "```\\nclass Solution {\\npublic:    \\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector <int> ans(seq.length());\\n        stack <char> st;\\n        \\n        for(int i=0;i<seq.length();i++) {\\n            if(st.empty() || seq[i] == \\'(\\') {\\n                st.push(seq[i]);\\n                ans[i] = (st.size() - 1)%2;\\n            }    \\n            else {\\n                ans[i] = (st.size() - 1)%2;\\n                st.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector <int> ans(seq.length());\\n        stack <char> st;\\n        \\n        for(int i=0;i<seq.length();i++) {\\n            if(st.empty() || seq[i] == \\'(\\') {\\n                st.push(seq[i]);\\n                ans[i] = (st.size() - 1)%2;\\n            }    \\n            else {\\n                ans[i] = (st.size() - 1)%2;\\n                st.pop();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513623,
                "title": "java-concise-solution",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int level = 0, n = seq.length();\\n        int[] ans = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(seq.charAt(i) == \\'(\\') ans[i] = ++level%2;\\n            else ans[i] = level--%2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int level = 0, n = seq.length();\\n        int[] ans = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(seq.charAt(i) == \\'(\\') ans[i] = ++level%2;\\n            else ans[i] = level--%2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054088,
                "title": "c-stack-solution-very-easy-to-understand",
                "content": "\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> answer(n, 0);\\n\\n        stack<pair<int,int>> st;\\n        for(int i = 0; i < n; i++) {\\n            if(seq[i] == \\'(\\') {\\n                if(!st.empty()) st.push({st.top().first == 0 ? 1 : 0, i});\\n                else st.push({0, i});\\n            }else{\\n                auto [cnt, idx] = st.top(); st.pop();\\n                answer[idx] = cnt;\\n                answer[i] = cnt;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> answer(n, 0);\\n\\n        stack<pair<int,int>> st;\\n        for(int i = 0; i < n; i++) {\\n            if(seq[i] == \\'(\\') {\\n                if(!st.empty()) st.push({st.top().first == 0 ? 1 : 0, i});\\n                else st.push({0, i});\\n            }else{\\n                auto [cnt, idx] = st.top(); st.pop();\\n                answer[idx] = cnt;\\n                answer[i] = cnt;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825324,
                "title": "python-98-06-faster-greedy-approach-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans=[]\\n        prev=1\\n        for i in seq:\\n            if i==\\'(\\':\\n                if prev==0:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n            else:\\n                ans.append(prev)\\n            if prev==0:\\n                prev=1\\n            else:\\n                prev=0\\n        return ans\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans=[]\\n        prev=1\\n        for i in seq:\\n            if i==\\'(\\':\\n                if prev==0:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n            else:\\n                ans.append(prev)\\n            if prev==0:\\n                prev=1\\n            else:\\n                prev=0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580050,
                "title": "stack-based-easy-python-solution-explained-o-n",
                "content": "Idea is that if the dept is greater than 1, we alternatively allocate bracket pairs to A and B.\\nEg: (()) => Outer pair to A and inner pair to B => [0,1,1,0]. Similarly ((())) => [0,1,0,0,1,0] => Outermost pair to A, middle pair to B and innermost pair to A again.\\n\\nWe use a stack to stor info of last unclosed bracket and in which block  (A = 0 or B = 1) it belongs. And pop it to close it whenever closing bracket appears during iteration.\\n\\nUpvote if you understood the logic :)\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack = []\\n        ans = []\\n        \\n        for s in seq:\\n            if s == \\'(\\':\\n                if not stack or stack[-1]:\\n                    ans.append(0)\\n                    stack.append(0)\\n                else:\\n                    ans.append(1)\\n                    stack.append(1)\\n            else:\\n                if stack[-1]:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n                stack.pop()\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack = []\\n        ans = []\\n        \\n        for s in seq:\\n            if s == \\'(\\':\\n                if not stack or stack[-1]:\\n                    ans.append(0)\\n                    stack.append(0)\\n                else:\\n                    ans.append(1)\\n                    stack.append(1)\\n            else:\\n                if stack[-1]:\\n                    ans.append(1)\\n                else:\\n                    ans.append(0)\\n                stack.pop()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522944,
                "title": "c-easy-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        int depth = -1;\\n        for(auto s : seq) {\\n            if(s == \\'(\\') {\\n                depth++;\\n                res.push_back(depth%2);\\n            } else if(s == \\')\\') {\\n                res.push_back(depth%2);\\n                depth--;\\n            }\\n        }\\n        return res;        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1725698,
                "title": "java-o-n-divide-into-2-group-based-odd-and-even-depths",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        \\n        int n = seq.length();\\n        int ans[] = new int[n];\\n        char  chars[] = seq.toCharArray();\\n        int depth = 0;\\n\\n        for(int i =0; i < n ;i++){\\n            if(chars[i] == \\'(\\'){\\n                depth++;\\n                if(depth % 2 == 0){\\n             \\n                    ans[i] = 0;\\n                }else{\\n                    ans[i] = 1;\\n                }\\n            }else{\\n                if(depth %2 == 0){\\n                    ans[i] = 0;\\n                }else{\\n                    ans[i] = 1;\\n                }\\n                depth--;\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        \\n        int n = seq.length();\\n        int ans[] = new int[n];\\n        char  chars[] = seq.toCharArray();\\n        int depth = 0;\\n\\n        for(int i =0; i < n ;i++){\\n            if(chars[i] == \\'(\\'){\\n                depth++;\\n                if(depth % 2 == 0){\\n             \\n                    ans[i] = 0;\\n                }else{\\n                    ans[i] = 1;\\n                }\\n            }else{\\n                if(depth %2 == 0){\\n                    ans[i] = 0;\\n                }else{\\n                    ans[i] = 1;\\n                }\\n                depth--;\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273245,
                "title": "java-iterative-easiest-faster-than-100-with-explaination",
                "content": "What we have to do is ..\\nfrom the given string which is VPS,we have to divide it into two subsequences of minimum length.\\n\\nLet\\'s say subsequence strings are A and B.\\n\\nDuring visiting each chars of given VPS string......\\nwhen we first get \\'(\\' we allocate it for string A.\\n               next time for B.\\n\\t\\t\\t   next time for A.\\n\\t\\t\\t   and likewise.....\\n\\nWhen we first get \\')\\' we allocate it for string B.\\n\\t\\t\\tnext time for A.\\n\\t\\t\\tnext time for B.\\n\\t\\t\\tand likewise......\\n\\t\\t\\t\\nTo do this alternatively we can use boolean variable for open and close parantheses.\\t\\t\\t\\n\\n\\n```\\nclass Solution {\\n    int arr[];\\n    public int[] maxDepthAfterSplit(String seq) {\\n        boolean open=false,close=false;\\n        //if open=false  ==> next \\'(\\' will be allocated for A otherwise for B.\\n\\t\\t//if close=false ==> next \\')\\' will be allocated for A otherwise for B.\\n        \\n        int arr[]=new int[seq.length()];\\n        for(int i=0;i<seq.length();i++){\\n            if(seq.charAt(i)==\\'(\\'){\\n                if(close){\\n                    arr[i]=1;\\n                    close=false;//to allocate next \\'(\\' to A.\\n                }else{\\n                    arr[i]=0;\\n                    close=true;//to allocate next \\'(\\' to B.\\n                }\\n            }else{\\n                if(open){\\n                    arr[i]=1;\\n                    open=false;//to allocate next \\')\\' to A.\\n                }else{\\n                    arr[i]=0;\\n                    open=true;//to allocate next \\')\\' to B.\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int arr[];\\n    public int[] maxDepthAfterSplit(String seq) {\\n        boolean open=false,close=false;\\n        //if open=false  ==> next \\'(\\' will be allocated for A otherwise for B.\\n\\t\\t//if close=false ==> next \\')\\' will be allocated for A otherwise for B.\\n        \\n        int arr[]=new int[seq.length()];\\n        for(int i=0;i<seq.length();i++){\\n            if(seq.charAt(i)==\\'(\\'){\\n                if(close){\\n                    arr[i]=1;\\n                    close=false;//to allocate next \\'(\\' to A.\\n                }else{\\n                    arr[i]=0;\\n                    close=true;//to allocate next \\'(\\' to B.\\n                }\\n            }else{\\n                if(open){\\n                    arr[i]=1;\\n                    open=false;//to allocate next \\')\\' to A.\\n                }else{\\n                    arr[i]=0;\\n                    open=true;//to allocate next \\')\\' to B.\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218640,
                "title": "easy-c-recursive-100-fastest-explanation-inside",
                "content": "//say, ans contains depth of string and we have ans as {0,1,1,1,1,0}, thus we can always make disjoint set of 1st and last element i.e. {0,0} and remaining (1 to 4 index ) elements making their depth {0,0,0,0} Since parent parent parenthesis is no more so depth reduced by one\\n//we can always separate max depth and max depth-1 parenthesis making max(a,b)=0, except ()(), where max(a,b) will always be 1 so doesn\\'t matter how you break\\n//so take one in a and other in b\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int i=0;\\n    void sol(string &s,int dep){\\n        if(i==s.length())return;\\n        if(s[i]==\\'(\\'){\\n            ans[i]=dep;\\n            i++;\\n            sol(s,dep+1);\\n        }\\n        else {\\n            ans[i]=dep-1;\\n            i++;\\n            sol(s,dep-1);\\n            \\n        }\\n    }\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        ans.resize(seq.length(),-1);\\n        sol(seq,0);\\n        for(auto &i:ans)i=i&1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int i=0;\\n    void sol(string &s,int dep){\\n        if(i==s.length())return;\\n        if(s[i]==\\'(\\'){\\n            ans[i]=dep;\\n            i++;\\n            sol(s,dep+1);\\n        }\\n        else {\\n            ans[i]=dep-1;\\n            i++;\\n            sol(s,dep-1);\\n            \\n        }\\n    }\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        ans.resize(seq.length(),-1);\\n        sol(seq,0);\\n        for(auto &i:ans)i=i&1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083691,
                "title": "c-beats-100-simple-solution-easy-to-understand-with-comments",
                "content": "**Do upvote if you liked the code !**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int count = 0;\\n        vector<int>depths(seq.size());\\n        int maxx = 0;\\n        for(int i=0;i<seq.size();i++){                       \\n//             assigning depths\\n//             for opening assign before & for closing assign afterwards\\n//             with this corresponding pair of brackets will have same depth\\n            if(seq[i]==\\'(\\'){\\n                depths[i] = count+1;\\n                count++;\\n            }\\n            else{\\n                count--;\\n                depths[i] = count+1;\\n            }\\n            maxx = max(maxx,count);\\n        }\\n//         Now to have least max(depth(A), depth(B)) is the minimum possible value.\\n//         divide them into 2 groups one having\\n//         height > maxx/2 other smaller\\n//         this way the depths of both groups will get reduced\\n        for(int i=0;i<seq.size();i++){                       \\n            if(depths[i]>maxx/2)\\n                depths[i] = 1;\\n            else\\n                depths[i] = 0;\\n        }\\n        return depths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int count = 0;\\n        vector<int>depths(seq.size());\\n        int maxx = 0;\\n        for(int i=0;i<seq.size();i++){                       \\n//             assigning depths\\n//             for opening assign before & for closing assign afterwards\\n//             with this corresponding pair of brackets will have same depth\\n            if(seq[i]==\\'(\\'){\\n                depths[i] = count+1;\\n                count++;\\n            }\\n            else{\\n                count--;\\n                depths[i] = count+1;\\n            }\\n            maxx = max(maxx,count);\\n        }\\n//         Now to have least max(depth(A), depth(B)) is the minimum possible value.\\n//         divide them into 2 groups one having\\n//         height > maxx/2 other smaller\\n//         this way the depths of both groups will get reduced\\n        for(int i=0;i<seq.size();i++){                       \\n            if(depths[i]>maxx/2)\\n                depths[i] = 1;\\n            else\\n                depths[i] = 0;\\n        }\\n        return depths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885478,
                "title": "easy-c-solution-no-fancy-stuff",
                "content": "The idea is that all paratheses in the seuquence have their closing parentheses, which means that we can create other VPS\\'s of depth 1 : depth(\"()\") = 1.\\nTo not get larger depths by having  things like \"(())\" each time we affect parantheses of the sime type that are side by side to a different sub-sequence : 0 1 1 0.\\n\\n```\\n vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> res(n);\\n        res[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (seq[i] != seq[i - 1]) {\\n                res[i] = res[i - 1];\\n            } else {\\n                res[i] = 1 - res[i - 1];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> res(n);\\n        res[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (seq[i] != seq[i - 1]) {\\n                res[i] = res[i - 1];\\n            } else {\\n                res[i] = 1 - res[i - 1];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826894,
                "title": "thinking-process",
                "content": "In order to minimize maximum depth, we ought to divide the deepest VPS substring into two subsequences evenly.\\n\\nConstructing a VPS is like counting `score`, where `(` is 1 and `)` is -1. If accumulative `score` is never negative and equal to 0 in the end, a VPS is constructed.\\n\\nDividing a VPS evenly also uses the concept of `score`. We want to maintain the **invariant** that `score difference` of two subsequences is no larger than 1.\\n\\n****\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] res = new int[seq.length()];\\n        int A = 0, B = 0;\\n        for (int i = 0; i < seq.length(); i++) {\\n            System.out.println(\"== A: \" + A + \" B: \" + B + \" ==\");\\n            int score = seq.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (score > 0 && A < B || score < 0 && A > B) {\\n                System.out.println(score + \" to A\");\\n                A += score;\\n            } else {\\n                System.out.println(score + \" to B\");\\n                B += score;\\n                res[i] = 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n****\\nThe invariant above holds in the code:\\n- If deepest VPS substring has even pairs of parentheses, e.g.  `\"(())\"`\\n```\\n== A: 0 B: 0 ==\\n1 to B\\n== A: 0 B: 1 ==\\n1 to A\\n== A: 1 B: 1 ==\\n-1 to B\\n== A: 1 B: 0 ==\\n-1 to A\\n\\n```\\n\\n- If deepest VPS substring has odd pairs of parentheses, e.g. = `\"((()))\"`,\\n```\\n== A: 0 B: 0 ==\\n1 to B\\n== A: 0 B: 1 ==\\n1 to A\\n== A: 1 B: 1 ==\\n1 to B\\n== A: 1 B: 2 ==\\n-1 to B\\n== A: 1 B: 1 ==\\n-1 to B\\n== A: 1 B: 0 ==\\n-1 to A\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] res = new int[seq.length()];\\n        int A = 0, B = 0;\\n        for (int i = 0; i < seq.length(); i++) {\\n            System.out.println(\"== A: \" + A + \" B: \" + B + \" ==\");\\n            int score = seq.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (score > 0 && A < B || score < 0 && A > B) {\\n                System.out.println(score + \" to A\");\\n                A += score;\\n            } else {\\n                System.out.println(score + \" to B\");\\n                B += score;\\n                res[i] = 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\n== A: 0 B: 0 ==\\n1 to B\\n== A: 0 B: 1 ==\\n1 to A\\n== A: 1 B: 1 ==\\n-1 to B\\n== A: 1 B: 0 ==\\n-1 to A\\n\\n```\n```\\n== A: 0 B: 0 ==\\n1 to B\\n== A: 0 B: 1 ==\\n1 to A\\n== A: 1 B: 1 ==\\n1 to B\\n== A: 1 B: 2 ==\\n-1 to B\\n== A: 1 B: 1 ==\\n-1 to B\\n== A: 1 B: 0 ==\\n-1 to A\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722564,
                "title": "c-greedy-mountain-visualization-technique-with-pictures",
                "content": "Refer this post for the visualization part https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328843/%22Mountain-Shaving%22-algorithm\\nSee the picture for clarity ->\\n![image](https://assets.leetcode.com/users/images/70882a8d-87ea-45af-b615-a8bee204d809_1594037022.3392315.png)\\n\\nThe code given in that link has some uneccesary stuff going on. Here is a clean code.\\n\\n```\\nclass Solution {\\n   public:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        if (seq.empty())\\n            return {};\\n\\n        int currLevel = 0;\\n        int maxLevel = 0;\\n        int N = (int)seq.length();\\n        vector<int> levels(N);\\n        for (int i = 0; i < N; ++i) {\\n            char c = seq[i];\\n            if (c == \\'(\\') {\\n                levels[i] = currLevel;\\n                currLevel++;\\n            } else {\\n                currLevel--;\\n                levels[i] = currLevel;\\n            }\\n            maxLevel = max(maxLevel, currLevel);\\n        }\\n\\n        int threshold = maxLevel / 2;\\n        //level[i] >= threshold then it belongs to B else A\\n        for (int i = 0; i < levels.size(); ++i) {\\n            if (levels[i] >= threshold)\\n                levels[i] = 1;\\n            else\\n                levels[i] = 0;\\n        }\\n\\n        return levels;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        if (seq.empty())\\n            return {};\\n\\n        int currLevel = 0;\\n        int maxLevel = 0;\\n        int N = (int)seq.length();\\n        vector<int> levels(N);\\n        for (int i = 0; i < N; ++i) {\\n            char c = seq[i];\\n            if (c == \\'(\\') {\\n                levels[i] = currLevel;\\n                currLevel++;\\n            } else {\\n                currLevel--;\\n                levels[i] = currLevel;\\n            }\\n            maxLevel = max(maxLevel, currLevel);\\n        }\\n\\n        int threshold = maxLevel / 2;\\n        //level[i] >= threshold then it belongs to B else A\\n        for (int i = 0; i < levels.size(); ++i) {\\n            if (levels[i] >= threshold)\\n                levels[i] = 1;\\n            else\\n                levels[i] = 0;\\n        }\\n\\n        return levels;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636983,
                "title": "greedy-approach-cpp-easy-solution-with-comments",
                "content": "\\n\\nRuntime: 8 ms, faster than 84.62% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\nMemory Usage: 7.9 MB, less than 100.00% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\n```\\n    class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        //since we want the difference to be as low as possible so we will try to balance both A and B by trying to maintain the number of paranthesis as close as close as possible\\n        vector<int> indexA, indexB, res(seq.length(), 0 );\\n\\t\\t//initailly assuming all parenthesis belong to A so filling res with 0\\n        int i = 0;\\n        int addToA = 0, addToB = 0;\\n        while(i < seq.length()){\\n            if(seq[i] == \\'(\\'){\\n                if(addToA <= addToB){\\n                    //adding depth to A when it\\'s depth is lesser or equal to b\\n                    indexA.push_back(i);\\n                    addToA ++;\\n                }else{\\n                    indexB.push_back(i);\\n                    addToB++;\\n                }\\n            }else{\\n                // removing depth from string whose depth is maximum as we have to keep the difference minimum\\n                if(addToA >= addToB){\\n                    addToA--;\\n                    indexA.push_back(i);\\n                }else{\\n                    indexB.push_back(i);\\n                    addToB--;\\n                }\\n            }\\n           i++;\\n        }\\n         for(i = 0; i < indexB.size(); i++){\\n                res[indexB[i]] = 1;\\n            }\\n         return res;   \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        //since we want the difference to be as low as possible so we will try to balance both A and B by trying to maintain the number of paranthesis as close as close as possible\\n        vector<int> indexA, indexB, res(seq.length(), 0 );\\n\\t\\t//initailly assuming all parenthesis belong to A so filling res with 0\\n        int i = 0;\\n        int addToA = 0, addToB = 0;\\n        while(i < seq.length()){\\n            if(seq[i] == \\'(\\'){\\n                if(addToA <= addToB){\\n                    //adding depth to A when it\\'s depth is lesser or equal to b\\n                    indexA.push_back(i);\\n                    addToA ++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 629097,
                "title": "o-n-simple-idea-easy-to-understand-java-with-comments-99-fast",
                "content": "Basic idea - The max you can reduce the degree is half. ie for continous opening brackets, you can split them into 2 groups. Remaining brackets you can split in any choice. \\n\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        char[] arr = seq.toCharArray();\\n        int l = arr.length;\\n        int[] res = new int[l];\\n        \\n        int deg = 0;\\n        int maxDegree = 0;\\n\\t\\t\\n\\t\\t// calculate the maximum degree of given string\\n        for(int i=0; i<l; i++) {\\n            if (arr[i] == \\'(\\') {\\n                deg++;\\n                maxDegree = Math.max(maxDegree, deg);\\n            }\\n            else {\\n                deg--;\\n            }\\n        }\\n\\t\\t\\n        int currdeg = 0;\\n        int groupBcounter = 0; // maintain a counter for providing closing brackets for group B.\\n\\t\\t\\n        for(int i=0; i<l; i++) {\\n            if (arr[i]==\\'(\\') {\\n\\t\\t\\t// if the current degree is greater than half, put the bracket in group B.\\n                if (currdeg >= maxDegree/2) {\\n                    res[i] = 1;\\n                    groupBcounter++;\\n                }\\n                currdeg++;\\n            }\\n            else {\\n                currdeg--;\\n\\t\\t\\t\\t// if group B requires closing, assign \\')\\' to B.\\n                if (groupBcounter > 0) {\\n                    res[i] = 1;\\n                    groupBcounter--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        char[] arr = seq.toCharArray();\\n        int l = arr.length;\\n        int[] res = new int[l];\\n        \\n        int deg = 0;\\n        int maxDegree = 0;\\n\\t\\t\\n\\t\\t// calculate the maximum degree of given string\\n        for(int i=0; i<l; i++) {\\n            if (arr[i] == \\'(\\') {\\n                deg++;\\n                maxDegree = Math.max(maxDegree, deg);\\n            }\\n            else {\\n                deg--;\\n            }\\n        }\\n\\t\\t\\n        int currdeg = 0;\\n        int groupBcounter = 0; // maintain a counter for providing closing brackets for group B.\\n\\t\\t\\n        for(int i=0; i<l; i++) {\\n            if (arr[i]==\\'(\\') {\\n\\t\\t\\t// if the current degree is greater than half, put the bracket in group B.\\n                if (currdeg >= maxDegree/2) {\\n                    res[i] = 1;\\n                    groupBcounter++;\\n                }\\n                currdeg++;\\n            }\\n            else {\\n                currdeg--;\\n\\t\\t\\t\\t// if group B requires closing, assign \\')\\' to B.\\n                if (groupBcounter > 0) {\\n                    res[i] = 1;\\n                    groupBcounter--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588230,
                "title": "c-short-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        short curr = 0;\\n        vector<int> ret;\\n        for (char& c : seq)\\n        {\\n            if (c == \\'(\\')\\n            {\\n                ret.push_back(curr);\\n                curr ^= 1;\\n            }\\n            else\\n            {\\n                curr ^= 1;\\n                ret.push_back(curr);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        short curr = 0;\\n        vector<int> ret;\\n        for (char& c : seq)\\n        {\\n            if (c == \\'(\\')\\n            {\\n                ret.push_back(curr);\\n                curr ^= 1;\\n            }\\n            else\\n            {\\n                curr ^= 1;\\n                ret.push_back(curr);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422002,
                "title": "without-increment-using-flag-easy-to-understand",
                "content": "Lets say for every character we push either 1 or 0 based on flag F.\\n() -> result should be FF (eg 00, or 11)\\n)( -> result should be FF (eg 00 or 11) as they allow us to keep minimum depth\\nfor other cases it should be F!F (eg 01 or 10)\\n\\n```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        bool isA = true;\\n        char old = \\')\\';\\n        \\n        for(auto ch : seq) {\\n            if ((old == \\'(\\' && ch == \\')\\') || \\n                (old == \\')\\' && ch == \\'(\\')) { \\n                /* don\\'t change while processing () and )( */ \\n            } else { \\n                isA = !isA; // change is above pattern not found\\n            }\\n\\n            // push integer based on isA\\n            if (isA) res.push_back(1);\\n            else res.push_back(0);\\n            \\n            // update old char\\n            old = ch;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        bool isA = true;\\n        char old = \\')\\';\\n        \\n        for(auto ch : seq) {\\n            if ((old == \\'(\\' && ch == \\')\\') || \\n                (old == \\')\\' && ch == \\'(\\')) { \\n                /* don\\'t change while processing () and )( */ \\n            } else { \\n                isA = !isA; // change is above pattern not found\\n            }\\n\\n            // push integer based on isA\\n            if (isA) res.push_back(1);\\n            else res.push_back(0);\\n            \\n            // update old char\\n            old = ch;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401663,
                "title": "easy-to-understand-c-solution-20ms-one-pass",
                "content": "Runtime: 20 ms, faster than 94.77% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\nMemory Usage: 9.6 MB, less than 100.00% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\n\\n```\\nvector<int> maxDepthAfterSplit(string seq) {\\n        \\n        vector<int> res;\\n        int depth = 0;\\n        \\n        for(int i=0; i<seq.size(); i++)\\n        {\\n            if(seq[i] == \\'(\\')\\n                depth++;\\n            res.push_back(depth%2);\\n            if(seq[i] == \\')\\')\\n                depth--;\\n        } \\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 20 ms, faster than 94.77% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\nMemory Usage: 9.6 MB, less than 100.00% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\n\\n```\\nvector<int> maxDepthAfterSplit(string seq) {\\n        \\n        vector<int> res;\\n        int depth = 0;\\n        \\n        for(int i=0; i<seq.size(); i++)\\n        {\\n            if(seq[i] == \\'(\\')\\n                depth++;\\n            res.push_back(depth%2);\\n            if(seq[i] == \\')\\')\\n                depth--;\\n        } \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 330657,
                "title": "python-simple-idea-split-depths-into-even-and-odd-o-n-time-o-1-space",
                "content": "The simple idea here is to get the depth of each brace and basically split those depths into two sections A and B such that A contains all braces with even depths and B contains all braces with odd depths.\\n\\nLet\\'s say you have the input as \"( ( ( ) ( ) ( ) ) ( ) )\". Let\\'s first construct the depths array.\\narr = [0, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0]. Each element in the depths array depicts the depth of that particular brace in the sequence.\\n\\nOnce we have this arr, we want to modify this such that all elements where depths[i]%2 == 1 are labelled as 1 and all elements with deptsh[i]%2 == 0 are labelled as 0. \\n\\nFollowing is the code that shows this.\\n\\n\\tdef maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res = []\\n        lvl = -1\\n        for c in seq:\\n            if c == \\'(\\':\\n                lvl += 1\\n                res.append(lvl%2)\\n            elif c == \\')\\':\\n                res.append(lvl%2)\\n                lvl -=1\\n        return res",
                "solutionTags": [],
                "code": "The simple idea here is to get the depth of each brace and basically split those depths into two sections A and B such that A contains all braces with even depths and B contains all braces with odd depths.\\n\\nLet\\'s say you have the input as \"( ( ( ) ( ) ( ) ) ( ) )\". Let\\'s first construct the depths array.\\narr = [0, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0]. Each element in the depths array depicts the depth of that particular brace in the sequence.\\n\\nOnce we have this arr, we want to modify this such that all elements where depths[i]%2 == 1 are labelled as 1 and all elements with deptsh[i]%2 == 0 are labelled as 0. \\n\\nFollowing is the code that shows this.\\n\\n\\tdef maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res = []\\n        lvl = -1\\n        for c in seq:\\n            if c == \\'(\\':\\n                lvl += 1\\n                res.append(lvl%2)\\n            elif c == \\')\\':\\n                res.append(lvl%2)\\n                lvl -=1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 328852,
                "title": "python-solution-3-7-o-n-with-detailed-explanation",
                "content": "This question annoyed me at first, because it\\'s so verbose. However, if you can get past the verbosity, it\\'s actually not so difficult to solve.\\n\\nThe problem is the following: You have a string, seq, which is a valid parentheses string (VPS) as defined in the question. depth(seq) is equal to the maximum depth that any pair of parentheses in the sequence has; so, if seq is \"()((()))\" for example, then depth(seq) = 3 because that\\'s as \"deep\" as the sequence goes. \\n\\nIf you removed the left and right parentheses at indices 4 and 5, respectively, then you\\'d have \"()(())\" and depth(seq) would only be\\n2.\\n\\nHowever, if you inserted a \"()\" at index 5, then you\\'d have \"()(((())))\" and depth(seq) would be 4.\\n\\nIf you remove the \"()\" at the beginning of seq, then you\\'d have \"((()))\", and depth(seq) would still be 3. You removed a pair of parentheses, but the maximum depth reached by seq is still 3.\\n\\nYou need to separate seq into what the problem calls \"two disjoint subsequences\" A and B, where A and B are also VPS\\'s. This means that every individual parenthesis in seq needs to be in either A or B, but not both, and A and B must also meet the requirements of a VPS. The idea is to minimize the depth of both A and B while choosing what they should be; you have to cover all of seq with both A and B, but max(depth(A), depth(B)) needs to be as low as possible.\\n\\nIf you struggled to understand the question when you read it and gave up, you should try giving it some more thought before moving on.\\n\\nYou should realize that, for every seq, there is at least one solution where (first case) depth(A) = depth(B), or (second case) depth(A) is either depth(B)+1 or depth(B)-1 (they\\'re both the same case since A and B are interchangeable). If depth(seq) is even, then the first case holds; otherwise, the second case holds. This means that max(depth(A), depth(B)) is either equal to depth(seq)//2 or depth(seq)//2 + 1.\\n\\nHow do we know this? Because, no matter what seq is, the fact that it\\'s a VPS allows us to just take any pair of parentheses, whether or not they have other parentheses nested within them, and add them to either sequence. So, we can just choose to add pairs that will allow us to make depth(A) equal to depth(B), or equal to depth(B)-1.\\n\\nI understand that this is a lot of information, so here\\'s my code. Feel free to ask away in the comments, I know this is still a lot to wrap your head around.\\n\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # idea: max(depth(A), depth(B)) can only be as low as 1/2 * depth(seq),\\n        #       because otherwise A and B are either (a) not actually VPS\\'s, or\\n        #       (b) do not actually constitute the smallest possible max(depth(A),\\n        #       depth(B)). So, just choose any A and B where depth(A) = depth(B)\\n        #       or depth(A) = depth(B) + 1. They\\'ll be equal if depth(seq) is\\n        #       an even number, otherwise they\\'ll be off by one.\\n        \\n        depthSeq = 0\\n        curDepth = 0\\n        for el in seq:\\n            if el == \\'(\\':\\n                curDepth += 1\\n            else:\\n                curDepth -= 1\\n            \\n            depthSeq = max(depthSeq, curDepth)\\n\\n        ret = []\\n        curDepth = 0\\n        for el in seq:\\n            if el == \\'(\\':\\n                curDepth += 1\\n            else:\\n                curDepth -= 1\\n            \\n            if curDepth > depthSeq//2 or (curDepth == depthSeq//2 and el != \\'(\\'):\\n                ret.append(1)\\n            else:\\n                ret.append(0)\\n                \\n        return ret\\n           \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # idea: max(depth(A), depth(B)) can only be as low as 1/2 * depth(seq),\\n        #       because otherwise A and B are either (a) not actually VPS\\'s, or\\n        #       (b) do not actually constitute the smallest possible max(depth(A),\\n        #       depth(B)). So, just choose any A and B where depth(A) = depth(B)\\n        #       or depth(A) = depth(B) + 1. They\\'ll be equal if depth(seq) is\\n        #       an even number, otherwise they\\'ll be off by one.\\n        \\n        depthSeq = 0\\n        curDepth = 0\\n        for el in seq:\\n            if el == \\'(\\':\\n                curDepth += 1\\n            else:\\n                curDepth -= 1\\n            \\n            depthSeq = max(depthSeq, curDepth)\\n\\n        ret = []\\n        curDepth = 0\\n        for el in seq:\\n            if el == \\'(\\':\\n                curDepth += 1\\n            else:\\n                curDepth -= 1\\n            \\n            if curDepth > depthSeq//2 or (curDepth == depthSeq//2 and el != \\'(\\'):\\n                ret.append(1)\\n            else:\\n                ret.append(0)\\n                \\n        return ret\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658648,
                "title": "100-faster-only-ternary-operator-used-c-4-lines-of-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    \\n    vector<int> maxDepthAfterSplit(string s) {\\n        int a = 1,b = 0,latest = 0,n = s.size();\\n        vector<int> v(n,0);\\n\\nfor(int i = 1;i<n;i++)(s[i] == \\'(\\')?((latest == 0)? (b++,latest = 1,v[i] = 1):(latest == 1 ? (a++,latest = 0,v[i] =0):0)) : (v[i] = latest,((latest == 0)?(a--,latest = 1):(b--,latest =0)));\\n\\n      return v;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    \\n    vector<int> maxDepthAfterSplit(string s) {\\n        int a = 1,b = 0,latest = 0,n = s.size();\\n        vector<int> v(n,0);\\n\\nfor(int i = 1;i<n;i++)(s[i] == \\'(\\')?((latest == 0)? (b++,latest = 1,v[i] = 1):(latest == 1 ? (a++,latest = 0,v[i] =0):0)) : (v[i] = latest,((latest == 0)?(a--,latest = 1):(b--,latest =0)));\\n\\n      return v;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971954,
                "title": "python-binary-search-solution-o-n-log-n",
                "content": "When we\\'re asked for the \"minimum maximum\", it\\'s a very strong hint that we can use binary search.\\n\\nThe solution range is given by the minimum and maximum possible depth of a VPS. The minimum is zero. The maximum is N // 2. For example:\\n```\\nN=0 --> \"\"\\nN=8 --> \"(((())))\"\\n```\\n\\nIf we use a depth that is too small, we won\\'t be able to split the sequence into two VPS while keeping max(depth(A), depth(B)) <= depth.\\n\\nIf we use a depth that is too large, let\\'s say N // 2, we\\'ll be able to keep max(depth(A), depth(B)) <= depth.\\n\\nWe can binary search the minimum possible depth that is going to be enough to split the sequence into two VPS.\\n\\nTo test if a given depth is enough we can use a simple greedy algorithm. We assign as much as we can to string A. Whenever we go above our target depth, the only possible option is assigning what is left to string B.\\n\\nIf both, depth(A) and depth(B) are less than or equal to our target depth, then we\\'ve found a possible answer. However, we need to keep searching until we find the smallest one (optimal answer).\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # T: O(N log(N)), S: O(N)\\n        N = len(seq)\\n        def test(targetDepth, output):\\n            depth, s = [0, 0], 0\\n            maxDepth = 0\\n            for i, c in enumerate(seq):\\n                if c == \\'(\\':\\n                    if depth[0] == targetDepth: s = 1\\n                    depth[s] += 1\\n                    output[i] = s\\n                else:\\n                    depth[s] -= 1\\n                    output[i] = s\\n                    if depth[1] == 0: s = 0\\n\\n                maxDepth = max(maxDepth, depth[0], depth[1])\\n            return maxDepth <= targetDepth\\n\\n        l, r = 0, N // 2\\n        ans = []            \\n        while l <= r:\\n            m = l + (r - l) // 2\\n\\n            candidate = [0] * N\\n            if test(m, candidate):\\n                ans = candidate\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        \\n        return ans\\n\\n```\\n\\nThis solution is suboptimal compared with the linear time ones, but I believe it\\'s still an interesting solution for practicing binary search.\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nN=0 --> \"\"\\nN=8 --> \"(((())))\"\\n```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        # T: O(N log(N)), S: O(N)\\n        N = len(seq)\\n        def test(targetDepth, output):\\n            depth, s = [0, 0], 0\\n            maxDepth = 0\\n            for i, c in enumerate(seq):\\n                if c == \\'(\\':\\n                    if depth[0] == targetDepth: s = 1\\n                    depth[s] += 1\\n                    output[i] = s\\n                else:\\n                    depth[s] -= 1\\n                    output[i] = s\\n                    if depth[1] == 0: s = 0\\n\\n                maxDepth = max(maxDepth, depth[0], depth[1])\\n            return maxDepth <= targetDepth\\n\\n        l, r = 0, N // 2\\n        ans = []            \\n        while l <= r:\\n            m = l + (r - l) // 2\\n\\n            candidate = [0] * N\\n            if test(m, candidate):\\n                ans = candidate\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825291,
                "title": "python-easy-explained-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        m,c,n=0,0,len(seq)\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                m=max(c,m) # Here m is the maximium depth of the VPS\\n            elif seq[i]==\\')\\': \\n                c-=1\\n        a=[]\\n        m//=2 # Minimum depth possible by breaking string in two parts A and B\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                if c<=m:\\n                    a.append(0) #For A\\n                else:\\n                    a.append(1) #For B\\n            else:\\n                if c<=m:\\n                    a.append(0)\\n                else:\\n                    a.append(1)\\n                c-=1\\n        return a\\n```\\n\\n**Upvote if you like the soluiton or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        m,c,n=0,0,len(seq)\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                m=max(c,m) # Here m is the maximium depth of the VPS\\n            elif seq[i]==\\')\\': \\n                c-=1\\n        a=[]\\n        m//=2 # Minimum depth possible by breaking string in two parts A and B\\n        for i in range(n):\\n            if seq[i]==\\'(\\':\\n                c+=1\\n                if c<=m:\\n                    a.append(0) #For A\\n                else:\\n                    a.append(1) #For B\\n            else:\\n                if c<=m:\\n                    a.append(0)\\n                else:\\n                    a.append(1)\\n                c-=1\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494917,
                "title": "100-faster-solution-1ms-runtime-java-easy-n-simple",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }\\n            else{\\n                a[i]=depth%2;\\n                depth--;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }\\n            else{\\n                a[i]=depth%2;\\n                depth--;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087484,
                "title": "python-simple-stack-solution",
                "content": "\\n    def maxDepthAfterSplit(self, seq):\\n        stack = [0]\\n        \\n        for i in range(1,len(seq)):\\n            if seq[i] == seq[i-1]:\\n                stack.append(1-stack[i-1])\\n            else:\\n                stack.append(stack[i-1])\\n            \\n        return stack",
                "solutionTags": [],
                "code": "\\n    def maxDepthAfterSplit(self, seq):\\n        stack = [0]\\n        \\n        for i in range(1,len(seq)):\\n            if seq[i] == seq[i-1]:\\n                stack.append(1-stack[i-1])\\n            else:\\n                stack.append(stack[i-1])\\n            \\n        return stack",
                "codeTag": "Python3"
            },
            {
                "id": 1785090,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n)**\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] res = new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++){\\n            res[i] = seq.charAt(i) == \\'(\\' ? i & 1 : 1-i & 1; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] res = new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++){\\n            res[i] = seq.charAt(i) == \\'(\\' ? i & 1 : 1-i & 1; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587607,
                "title": "java-easy-solution",
                "content": "\\n\\n\\n     class Solution {\\n    public int[] maxDepthAfterSplit(String s) {\\n        \\n        int[] arr = new int[s.length()];\\n        int a=0;\\n        Stack st1 = new Stack();\\n        Stack st2 = new Stack();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               if(st1.size()<=st2.size())\\n               {\\n                   st1.push(\\'(\\');\\n                   arr[a]=0;\\n                   a++;\\n               }\\n               else\\n               {\\n                  st2.push(\\'(\\');\\n                   arr[a]=1;\\n                   a++;    \\n               }\\n            }\\n\\n            \\n            if(s.charAt(i)==\\')\\')\\n            {\\n                if(st1.size()>=st2.size())\\n                {\\n                   st1.pop();\\n                   arr[a]=0;\\n                   a++;\\n                }\\n                else\\n                {\\n                    st2.pop();\\n                    arr[a]=1;\\n                    a++;             \\n                }\\n                \\n            }\\n        }\\n       \\n        return arr;\\n        \\n     }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int[] maxDepthAfterSplit(String s) {\\n        \\n        int[] arr = new int[s.length()];\\n        int a=0;\\n        Stack st1 = new Stack();\\n        Stack st2 = new Stack();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n               if(st1.size()<=st2.size())\\n               {\\n                   st1.push(\\'(\\');\\n                   arr[a]=0;\\n                   a++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1467578,
                "title": "c-simple-solution",
                "content": "The idea is to find the \"level\" of each char. Starting from 0, \\nwhen we met \\'(\\' we increase the level by 1\\nwhen we met \\')\\' we decrease the level by 1.\\n\\nSo \"(()())\" becomes \"122221\"\\n\"()()(())\" becomes \"11111221\"\\n\\nThen we try to put the odd leveled chars to string A, and even leveled chars to string B. And that\\'s it.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> v(n, 0);\\n        int lvl = 0;\\n        \\n        for(int i=0; i<n; ++i) {\\n            if(seq[i] == \\'(\\') {\\n                lvl++;\\n                v[i] = lvl;\\n            } else {\\n                v[i] = lvl;\\n                lvl--;\\n            }    \\n        }\\n        \\n        for(int i=0; i<n; ++i) {\\n            v[i] = v[i] % 2 == 1 ? 0 : 1;\\n        }\\n        return v;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> v(n, 0);\\n        int lvl = 0;\\n        \\n        for(int i=0; i<n; ++i) {\\n            if(seq[i] == \\'(\\') {\\n                lvl++;\\n                v[i] = lvl;\\n            } else {\\n                v[i] = lvl;\\n                lvl--;\\n            }    \\n        }\\n        \\n        for(int i=0; i<n; ++i) {\\n            v[i] = v[i] % 2 == 1 ? 0 : 1;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295673,
                "title": "easy-greedy-o-n-python",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        \\n        \\n        \\n        ans=[]\\n        la=0\\n        lb=0\\n        \\n        for i in range(len(seq)):\\n            \\n            if seq[i]==\\'(\\':\\n                \\n                if la > lb:\\n                    lb+=1\\n                    ans.append(0)\\n                elif lb>la:\\n                    la+=1\\n                    ans.append(1)\\n                else:\\n                    la+=1\\n                    ans.append(1)\\n            else:\\n                if la >0:\\n                    ans.append(1)\\n                    la-=1\\n                elif lb>0:\\n                    ans.append(0)\\n                    lb-=1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        \\n        \\n        \\n        ans=[]\\n        la=0\\n        lb=0\\n        \\n        for i in range(len(seq)):\\n            \\n            if seq[i]==\\'(\\':\\n                \\n                if la > lb:\\n                    lb+=1\\n                    ans.append(0)\\n                elif lb>la:\\n                    la+=1\\n                    ans.append(1)\\n                else:\\n                    la+=1\\n                    ans.append(1)\\n            else:\\n                if la >0:\\n                    ans.append(1)\\n                    la-=1\\n                elif lb>0:\\n                    ans.append(0)\\n                    lb-=1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290392,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int depth = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq[i] == \\'(\\') depth++;\\n            ans.push_back(depth%2);\\n            if(seq[i] == \\')\\') depth--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int depth = 0;\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq[i] == \\'(\\') depth++;\\n            ans.push_back(depth%2);\\n            if(seq[i] == \\')\\') depth--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252877,
                "title": "golang-solution-with-explanation-for-understanding",
                "content": "I wouldn\\'t say that this problem statment is the easiest to understand, so I am going to try to explain it in my own words. Let us say that we have `(())()()` the maximum depth is `2`, because `(())` has a depth of `2` the problem wants us to find two subsequences `A`, and `B`, so that `A` and `B` are both at their minimum depths, and minimum lengths (When we want minimum lengths `seq` has to be split into two pieces) so in the following input, `A` and `B` will be shown:\\n\\ninput := `( ( ) ) ( ) ( )`\\ndepth = `1 2 2 1 1 1 1 1`\\nA and B `A B B A B B A A`\\n\\n```\\nfunc maxDepthAfterSplit(seq string) []int {\\n\\tres := make([]int, len(seq))\\n\\tevenOrOdd := 0\\n\\tfor i, i2 := range seq {\\n\\t\\tif i2 == \\'(\\' {\\n\\t\\t\\tevenOrOdd++\\n\\t\\t\\tres[i] = evenOrOdd % 2\\n\\t\\t} else {\\n\\t\\t\\tres[i] = evenOrOdd % 2\\n\\t\\t\\tevenOrOdd--\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxDepthAfterSplit(seq string) []int {\\n\\tres := make([]int, len(seq))\\n\\tevenOrOdd := 0\\n\\tfor i, i2 := range seq {\\n\\t\\tif i2 == \\'(\\' {\\n\\t\\t\\tevenOrOdd++\\n\\t\\t\\tres[i] = evenOrOdd % 2\\n\\t\\t} else {\\n\\t\\t\\tres[i] = evenOrOdd % 2\\n\\t\\t\\tevenOrOdd--\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235341,
                "title": "c-0ms-100-easy-to-understand",
                "content": "\\n```\\nvector<int> maxDepthAfterSplit(string &seq) {\\n        vector<int> ans(seq.size());\\n        int a=0,b=0;\\n        for(int i=0; i<seq.size(); i++){\\n            if(seq[i]==\\'(\\')\\n                if(a<=b) ans[i]=0, a++;\\n                else ans[i]=1, b++;\\n            else\\n                if(b>0) ans[i]=1, b--;\\n                else ans[i]=0, a--;\\n        }\\n        return ans;\\n    }\\n```\\n# if y0u find it helpful, plz upvote",
                "solutionTags": [],
                "code": "```\\nvector<int> maxDepthAfterSplit(string &seq) {\\n        vector<int> ans(seq.size());\\n        int a=0,b=0;\\n        for(int i=0; i<seq.size(); i++){\\n            if(seq[i]==\\'(\\')\\n                if(a<=b) ans[i]=0, a++;\\n                else ans[i]=1, b++;\\n            else\\n                if(b>0) ans[i]=1, b--;\\n                else ans[i]=0, a--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203132,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = []\\n        depth = 0\\n        for char in seq:\\n          open = char == \\'(\\'\\n          if open:\\n            depth += 1\\n          ans.append(depth % 2) \\n\\t\\t  if not open:\\n            depth -=1\\n\\n        return ans\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = []\\n        depth = 0\\n        for char in seq:\\n          open = char == \\'(\\'\\n          if open:\\n            depth += 1\\n          ans.append(depth % 2) \\n\\t\\t  if not open:\\n            depth -=1\\n\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1170766,
                "title": "c-0ms-faster-than-100-submissions-supa-neat",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>ans;\\n        bool op=1,cl=1;\\n        for(auto x :seq){\\n            if(x==\\'(\\')\\n                ans.push_back(op),op=!op;\\n            else\\n                ans.push_back(cl),cl=!cl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>ans;\\n        bool op=1,cl=1;\\n        for(auto x :seq){\\n            if(x==\\'(\\')\\n                ans.push_back(op),op=!op;\\n            else\\n                ans.push_back(cl),cl=!cl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152278,
                "title": "2-variations",
                "content": "**Iffless \"checkerboard\" 1-pass solution : time `O(N)` space `O(1)`**\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/7968f864-ecf8-4c0c-9249-8abfe8aafdc8_1618656610.675834.png)\\n\\n<br>\\n\\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\tfor(int i{0}; i<size(s); ++i)\\n\\t\\tout[i]=i+s[i]&1;\\n\\treturn out;\\n}\\n```\\nNote that we don\\'t need to use `\\'(\\'` and `\\')\\'` constants.\\nBTW, due to [operator precedence rules](https://en.cppreference.com/w/cpp/language/operator_precedence): `i+s[i]&1 \\u2261 (i+s[i])&1`.\\n||\\nwith the help of `stl`\\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\ttransform(begin(s), end(s), begin(out), [h=-1](auto c) mutable { return ++h+c&1; });\\n\\treturn out;\\n}\\n```\\nBTW, `++h+c&1` could be reexpressed in a number of ways.\\nSee [this problem](https://leetcode.com/problems/determine-color-of-a-chessboard-square/discuss/1141116/5-1-liners) for an example. In essence\\n\\n```\\nbool((x+y)&1) \\u2261 bool((x&1)-(y&1)) \\u2261 bool((x-y)&1) \\u2261 bool((x^y)&1) \\u2261 bool((x&1)^(y&1)) \\u2261 bool(x%2!=y%2) \\u2261 bool(x&1!=y&1)\\n```\\n\\n**Intuitive \"height bookkeeping\" 1-pass solution : time `O(N)` space `O(1)`**\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/6c12b767-5f26-4386-abfe-79dd09cf7a56_1618133418.8952794.png)\\n\\n<br>\\n\\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out;\\n\\tfor(auto h{0}; const auto & c : s)\\n\\t\\tif(c==\\'(\\') \\n\\t\\t{\\n\\t\\t\\th++;\\n\\t\\t\\tout.push_back(h&1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\n\\t\\t\\tout.push_back(h&1);\\n\\t\\t\\th--;\\n\\t\\t}\\n\\treturn out;\\n}\\n```\\n||\\nwith the help of `stl`\\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\ttransform(begin(s), end(s), begin(out), [h=0](const auto & c) mutable { return c==\\'(\\' and ++h&1 or c==\\')\\' and h--&1; });\\n\\treturn out;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\tfor(int i{0}; i<size(s); ++i)\\n\\t\\tout[i]=i+s[i]&1;\\n\\treturn out;\\n}\\n```\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\ttransform(begin(s), end(s), begin(out), [h=-1](auto c) mutable { return ++h+c&1; });\\n\\treturn out;\\n}\\n```\n```\\nbool((x+y)&1) \\u2261 bool((x&1)-(y&1)) \\u2261 bool((x-y)&1) \\u2261 bool((x^y)&1) \\u2261 bool((x&1)^(y&1)) \\u2261 bool(x%2!=y%2) \\u2261 bool(x&1!=y&1)\\n```\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out;\\n\\tfor(auto h{0}; const auto & c : s)\\n\\t\\tif(c==\\'(\\') \\n\\t\\t{\\n\\t\\t\\th++;\\n\\t\\t\\tout.push_back(h&1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\n\\t\\t\\tout.push_back(h&1);\\n\\t\\t\\th--;\\n\\t\\t}\\n\\treturn out;\\n}\\n```\n```\\nvector<int> maxDepthAfterSplit(string s) \\n{\\n\\tvector<int> out(size(s));\\n\\ttransform(begin(s), end(s), begin(out), [h=0](const auto & c) mutable { return c==\\'(\\' and ++h&1 or c==\\')\\' and h--&1; });\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000543,
                "title": "max-depth-2",
                "content": "Use the `cnts` as usual for parentheses algorithms to count the depth, and use the `depth` to keep the depth of all parentheses.\\n\\nE.g.,\\n\\n`\"(()())\"`\\n\\nWe have `cnts = [1, 2, 1, 2, 1, 0]`, and `depth = [1, 2, 2, 2, 2, 1]`. \\n\\nNow we know the max depth is 2, so we use max-depth / 2 = 1 to separate two VPs: `depth <= 1` is one and otherwise the other.\\n\\n```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        cnts = [0] * len(seq)\\n        depth = [0] * len(seq)\\n        \\n        cnts[0] = 1  # for VPs\\n        depth[0] = 1\\n        \\n        for i in range(1, len(seq)):\\n            if seq[i] == \\'(\\':\\n                cnts[i] = cnts[i-1] + 1\\n                depth[i] = cnts[i]\\n            else:\\n                cnts[i] = cnts[i-1] - 1\\n                depth[i] = cnts[i-1]\\n        \\n        res = [0 if x <= max(cnts) // 2 else 1 for x in depth]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        cnts = [0] * len(seq)\\n        depth = [0] * len(seq)\\n        \\n        cnts[0] = 1  # for VPs\\n        depth[0] = 1\\n        \\n        for i in range(1, len(seq)):\\n            if seq[i] == \\'(\\':\\n                cnts[i] = cnts[i-1] + 1\\n                depth[i] = cnts[i]\\n            else:\\n                cnts[i] = cnts[i-1] - 1\\n                depth[i] = cnts[i-1]\\n        \\n        res = [0 if x <= max(cnts) // 2 else 1 for x in depth]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976339,
                "title": "greedy-solution-in-cpp-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.size());\\n        int a = 0;\\n        int b = 0;\\n        for(int i = 0; i < seq.size(); i++) {\\n            if(seq[i] == \\'(\\') {\\n                if(a == 0 or a <= b) {\\n                    ans[i] = 0;\\n                    a++;\\n                }\\n                else {\\n                    ans[i] = 1;\\n                    b++;\\n                }\\n            }\\n            else {\\n                if(a <= b) {\\n                    ans[i] = 1;\\n                    b--;\\n                }\\n                else {\\n                    ans[i] = 0;\\n                    a--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.size());\\n        int a = 0;\\n        int b = 0;\\n        for(int i = 0; i < seq.size(); i++) {\\n            if(seq[i] == \\'(\\') {\\n                if(a == 0 or a <= b) {\\n                    ans[i] = 0;\\n                    a++;\\n                }\\n                else {\\n                    ans[i] = 1;\\n                    b++;\\n                }\\n            }\\n            else {\\n                if(a <= b) {\\n                    ans[i] = 1;\\n                    b--;\\n                }\\n                else {\\n                    ans[i] = 0;\\n                    a--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911805,
                "title": "easy-python",
                "content": "class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        \\n        c=0\\n        s=seq\\n        a=[0]*len(s)\\n        \\n        for i in range(len(s)):\\n            \\n            if c == 0:\\n                c = c+1\\n                if s[i] == \\'(\\':\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                    \\n            elif c == 1:\\n                c = c-1\\n                if s[i] == \\')\\':\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                    \\n            \\n        return a",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        \\n        c=0\\n        s=seq\\n        a=[0]*len(s)\\n        \\n        for i in range(len(s)):\\n            \\n            if c == 0:\\n                c = c+1\\n                if s[i] == \\'(\\':\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                    \\n            elif c == 1:\\n                c = c-1\\n                if s[i] == \\')\\':\\n                    a[i] = 1\\n                else:\\n                    a[i] = 0\\n                    \\n            \\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 868492,
                "title": "simple-c-greedy-solution-o-n",
                "content": "/*\\n    Simple greedy solution\\n    1. push all indices that have opening bracket character in one queue\\n    2. push all indices that have closing bracket character in another queue\\n    3. match fronts of both queue alternatively.\\n*/\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n\\t\\t\\tint n = seq.size();\\n        \\tvector<int> ans(n, -1);\\n\\t\\t\\tqueue<int> qo;\\n\\t\\t\\tqueue<int> qc;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tif(seq[i] == \\'(\\')\\n\\t\\t\\t\\t\\tqo.push(i);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tqc.push(i);\\n\\t\\t\\t}\\n\\t\\t\\tint carry = 0;\\n\\t\\t\\tint u, v;\\n\\t\\t\\twhile(!qo.empty()){\\n\\t\\t\\t\\tu = qo.front();\\n\\t\\t\\t\\tqo.pop();\\n\\t\\t\\t\\tv = qc.front();\\n\\t\\t\\t\\tqc.pop();\\n\\t\\t\\t\\tans[u] = ans[v] = carry;\\n\\t\\t\\t\\tcarry = 1 - carry;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n\\t\\t\\tint n = seq.size();\\n        \\tvector<int> ans(n, -1);\\n\\t\\t\\tqueue<int> qo;\\n\\t\\t\\tqueue<int> qc;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tif(seq[i] == \\'(\\')\\n\\t\\t\\t\\t\\tqo.push(i);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tqc.push(i);\\n\\t\\t\\t}\\n\\t\\t\\tint carry = 0;\\n\\t\\t\\tint u, v;\\n\\t\\t\\twhile(!qo.empty()){\\n\\t\\t\\t\\tu = qo.front();\\n\\t\\t\\t\\tqo.pop();\\n\\t\\t\\t\\tv = qc.front();\\n\\t\\t\\t\\tqc.pop();\\n\\t\\t\\t\\tans[u] = ans[v] = carry;\\n\\t\\t\\t\\tcarry = 1 - carry;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832816,
                "title": "python-simple-solution",
                "content": "To translate the problem, actually it is looking to group the valid patenthesis into two groups. If there are multiple levels of (), what we need is to put the levels 1, 3, 5.. to one group, and levels 0, 2, 4, 6... to the other group. To do this, we can use a stack to track the number of \\'(\\'. When we encouter an odd number of this count, we can assign it to group number 1.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res = [0] * len(seq)\\n        dq = deque()\\n        for i, s in enumerate(seq):\\n            if s == \\'(\\':\\n                dq.append(i)\\n            if s == \\')\\':\\n                if len(dq) % 2 == 0:\\n                    res[dq[-1]] = 1\\n                    res[i] = 1\\n                dq.pop()\\n            \\n        return res",
                "solutionTags": [],
                "code": "To translate the problem, actually it is looking to group the valid patenthesis into two groups. If there are multiple levels of (), what we need is to put the levels 1, 3, 5.. to one group, and levels 0, 2, 4, 6... to the other group. To do this, we can use a stack to track the number of \\'(\\'. When we encouter an odd number of this count, we can assign it to group number 1.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res = [0] * len(seq)\\n        dq = deque()\\n        for i, s in enumerate(seq):\\n            if s == \\'(\\':\\n                dq.append(i)\\n            if s == \\')\\':\\n                if len(dq) % 2 == 0:\\n                    res[dq[-1]] = 1\\n                    res[i] = 1\\n                dq.pop()\\n            \\n        return res",
                "codeTag": "C++"
            },
            {
                "id": 765308,
                "title": "easy-python-with-explanation",
                "content": "o mean which one is open and c mean which one is close also best answer occurs when both the nesting are aqual (reason: think of A.M. and G.M. inequality)\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, s: str) -> List[int]:\\n        o=0\\n        c=0\\n        ans=[0]*(len(s))\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                ans[i]=o\\n                o^=1\\n            else:\\n                ans[i]=c\\n                c^=1\\n        return ans\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, s: str) -> List[int]:\\n        o=0\\n        c=0\\n        ans=[0]*(len(s))\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                ans[i]=o\\n                o^=1\\n            else:\\n                ans[i]=c\\n                c^=1\\n        return ans\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 726077,
                "title": "a-simple-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public int[] maxDepthAfterSplit(String seq) \\n    {\\n        int l=0;\\n        int[] result=new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++)\\n        {\\n            if(seq.charAt(i)==\\'(\\')\\n            {\\n                l++;\\n                if(l%2==0)\\n                    result[i]=1;\\n            }\\n            else\\n            {\\n                if(l%2==0)\\n                    result[i]=1;\\n                l--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] maxDepthAfterSplit(String seq) \\n    {\\n        int l=0;\\n        int[] result=new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++)\\n        {\\n            if(seq.charAt(i)==\\'(\\')\\n            {\\n                l++;\\n                if(l%2==0)\\n                    result[i]=1;\\n            }\\n            else\\n            {\\n                if(l%2==0)\\n                    result[i]=1;\\n                l--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724205,
                "title": "python-simple-greedy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\n        foo = lambda x: 1 if seq[x]==\"(\" else -1\\n\\n        # get max depth // 2 \\n        m = max(itertools.accumulate(map(foo, range(len(seq))))) // 2\\n        \\n        # variable to store if we are in above depth \"m\"\\n        inSecond = 0\\n        \\n        # stores result\\n        res = []\\n\\n        # loop through all seq and keep track of sum \"i\" given by {-1 for \\')\\' and +1 for \"(\" }\\n        # if we are in above depth \"m\" (we are in second subset) append 1 else if after going into\\n        # second subset the depth is less than \"m\", we are now in first subset append 0\\n        for i in itertools.accumulate(map(foo, range(len(seq)))):\\n            if i<m:\\tinSecond = 0\\n            if i>m:\\tinSecond = 1\\n            res.append(inSecond)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\n        foo = lambda x: 1 if seq[x]==\"(\" else -1\\n\\n        # get max depth // 2 \\n        m = max(itertools.accumulate(map(foo, range(len(seq))))) // 2\\n        \\n        # variable to store if we are in above depth \"m\"\\n        inSecond = 0\\n        \\n        # stores result\\n        res = []\\n\\n        # loop through all seq and keep track of sum \"i\" given by {-1 for \\')\\' and +1 for \"(\" }\\n        # if we are in above depth \"m\" (we are in second subset) append 1 else if after going into\\n        # second subset the depth is less than \"m\", we are now in first subset append 0\\n        for i in itertools.accumulate(map(foo, range(len(seq)))):\\n            if i<m:\\tinSecond = 0\\n            if i>m:\\tinSecond = 1\\n            res.append(inSecond)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647490,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cur = 1;\\n        vector<int> res;\\n        for (char c:seq){\\n            if (c==\\'(\\'){\\n                cur = (cur+1)%2;\\n                res.push_back(cur);\\n            }else{\\n                res.push_back(cur);\\n                cur = (cur+1)%2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cur = 1;\\n        vector<int> res;\\n        for (char c:seq){\\n            if (c==\\'(\\'){\\n                cur = (cur+1)%2;\\n                res.push_back(cur);\\n            }else{\\n                res.push_back(cur);\\n                cur = (cur+1)%2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597444,
                "title": "python-beats-99-very-easy-solution-with-explanations",
                "content": "- The only key idea to use is: when we have a nested parentheses string, we distribute them equally by having each nest belong to alternating groups.\\n- In order to achieve this, we use a binary variable ```tmp``` which only switches value when we encounter two consecutive identical symbols, to alternate the membership.\\n\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\t\\t# tmp is either 0 or 1\\n        tmp, res = 0, []\\n        for i, c in enumerate(seq[:-1]):\\n\\t\\t\\t# if \"((\" or \"))\", change tmp after appending\\n            if c == seq[i + 1]:\\n                res.append(tmp)\\n                tmp ^= 1\\n            else:\\n                res.append(tmp)\\n        return res + [tmp]\\n```",
                "solutionTags": [],
                "code": "```tmp```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\t\\t# tmp is either 0 or 1\\n        tmp, res = 0, []\\n        for i, c in enumerate(seq[:-1]):\\n\\t\\t\\t# if \"((\" or \"))\", change tmp after appending\\n            if c == seq[i + 1]:\\n                res.append(tmp)\\n                tmp ^= 1\\n            else:\\n                res.append(tmp)\\n        return res + [tmp]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595738,
                "title": "python3-90-speed-100-space-proof-included",
                "content": "```class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\t\\t## represent left parentheses to close\\n        A,B = 0\\n        answer = []\\n        for s in seq:\\n            if s == \\'(\\':\\n                if B < A:\\n                    B += 1\\n                    answer.append(1)\\n                else:\\n                    A += 1\\n                    answer.append(0)\\n            else:\\n                if B < A:\\n                    A -= 1\\n                    answer.append(0)\\n                else:\\n                    B -= 1\\n                    answer.append(1)\\n        return answer\\n```\\n\\nProof that this algorithm creates a splitting with minimal depth: Let n_i be the number of left parenthesis between indices [0,i] and m_i by the number of right parenthesis between [0,i]. The two claims together combine to a proof.\\n\\nClaim 1: Every splitting has depth at least max_i ceil((n_i - m_i) / 2). At point i, we have seen n_i - m_i more left parentheses than right parentheses. No matter the splitting of parentheses between A and B, one of A or B will have ceil((n_i - m_i) / 2) left parentheses that have not been closed. So the depth must be at least ceil((n_i - m_i) / 2) and this is true for every index i.\\n\\nClaim 2: The above code produces a splitting with depth at most max_i ceil((n_i - m_i) / 2). A and B represent that amount of left parentheses to close in each string. A and B are updated at each step so that their difference is at most 1. Since A+B = n_i - m_i at every step in the loop, max(A,B) = ceil((n_i - m_i)/2). Therefore, A and B are always less than or equal to max_i ceil((n_i - m_i)/2). Since A and B represent the number of left parentheses to close, the maximum they reach is the depth of the strings, which shows the claim.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\t\\t## represent left parentheses to close\\n        A,B = 0\\n        answer = []\\n        for s in seq:\\n            if s == \\'(\\':\\n                if B < A:\\n                    B += 1\\n                    answer.append(1)\\n                else:\\n                    A += 1\\n                    answer.append(0)\\n            else:\\n                if B < A:\\n                    A -= 1\\n                    answer.append(0)\\n                else:\\n                    B -= 1\\n                    answer.append(1)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558675,
                "title": "rust-one-expression-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        seq.chars().scan(0, |d, c| {\\n            if c == \\'(\\' {\\n                *d += 1;\\n                Some(*d & 1)\\n            } else {\\n                *d -= 1;\\n                Some((*d + 1) & 1)\\n            }\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        seq.chars().scan(0, |d, c| {\\n            if c == \\'(\\' {\\n                *d += 1;\\n                Some(*d & 1)\\n            } else {\\n                *d -= 1;\\n                Some((*d + 1) & 1)\\n            }\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535654,
                "title": "swift-stack-solution",
                "content": "```\\nclass Solution {\\n    func maxDepthAfterSplit(_ seq: String) -> [Int] {\\n        var stack:[Character] = []\\n        let arr = Array(seq)\\n        var res:[Int] = []\\n        for item in arr{\\n            if item == \"(\"{\\n                res.append(stack.count%2)\\n                stack.append(item)\\n            }else if item == \")\"{\\n                stack.removeLast()\\n                res.append(stack.count%2)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDepthAfterSplit(_ seq: String) -> [Int] {\\n        var stack:[Character] = []\\n        let arr = Array(seq)\\n        var res:[Int] = []\\n        for item in arr{\\n            if item == \"(\"{\\n                res.append(stack.count%2)\\n                stack.append(item)\\n            }else if item == \")\"{\\n                stack.removeLast()\\n                res.append(stack.count%2)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529194,
                "title": "rust-5-lines-0ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        let mut res = vec![0]; \\n        let cs:Vec<char> = seq.chars().collect();\\n        for i in 1..seq.len() {\\n            res.push(if cs[i] == \\'(\\' { i as i32 & 1 } else { 1 - (i as i32 & 1)});\\n        }\\n        res \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        let mut res = vec![0]; \\n        let cs:Vec<char> = seq.chars().collect();\\n        for i in 1..seq.len() {\\n            res.push(if cs[i] == \\'(\\' { i as i32 & 1 } else { 1 - (i as i32 & 1)});\\n        }\\n        res \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461180,
                "title": "python-3-beats-95-readable",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, P: str) -> List[int]:\\n        D, A, v = {\\'(\\':1, \\')\\':-1}, [], 0\\n        for p in P:\\n            if v*D[p] > 0:\\n                v -= D[p]\\n                A.append(0)\\n            else:\\n                v += D[p]\\n                A.append(1)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def maxDepthAfterSplit(self, P: str) -> List[int]:\\n        D, A, v = {\\'(\\':1, \\')\\':-1}",
                "codeTag": "Java"
            },
            {
                "id": 423375,
                "title": "i-don-t-know-how-i-solved-that-may-be-someone-else-will-understand-this",
                "content": "I genuinely do not know how I came up with that but it works. My brain just told me to type this and I am serious.\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        A, B,ans = 0,0,[]\\n        for c in seq:\\n            if c == \"(\":\\n                if A>=B:\\n                    ans.append(1)\\n                    B += 1\\n                else:\\n                    ans.append(0)\\n                    A += 1\\n            else:\\n                if A>=B:\\n                    ans.append(0)\\n                    A -= 1\\n                else:\\n                    ans.append(1)\\n                    B -= 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        A, B,ans = 0,0,[]\\n        for c in seq:\\n            if c == \"(\":\\n                if A>=B:\\n                    ans.append(1)\\n                    B += 1\\n                else:\\n                    ans.append(0)\\n                    A += 1\\n            else:\\n                if A>=B:\\n                    ans.append(0)\\n                    A -= 1\\n                else:\\n                    ans.append(1)\\n                    B -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383271,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        let mut cur_group = 0;\\n        let mut setup = vec![];\\n        let mut stack = vec![]; //para stack\\n        \\n        seq.chars().for_each(|ch| {\\n            match ch {\\n                \\'(\\' =>{\\n                    if !stack.is_empty() {\\n                        cur_group = 1 - cur_group;\\n                    }\\n                    setup.push(cur_group);\\n                    stack.push(cur_group);\\n                }\\n                \\')\\' =>{\\n                    setup.push(stack.pop().unwrap());\\n                    cur_group = 1 - cur_group;\\n                }\\n                _ => {/**/}\\n            }\\n        });\\n        setup\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_depth_after_split(seq: String) -> Vec<i32> {\\n        let mut cur_group = 0;\\n        let mut setup = vec![];\\n        let mut stack = vec![]; //para stack\\n        \\n        seq.chars().for_each(|ch| {\\n            match ch {\\n                \\'(\\' =>{\\n                    if !stack.is_empty() {\\n                        cur_group = 1 - cur_group;\\n                    }\\n                    setup.push(cur_group);\\n                    stack.push(cur_group);\\n                }\\n                \\')\\' =>{\\n                    setup.push(stack.pop().unwrap());\\n                    cur_group = 1 - cur_group;\\n                }\\n                _ => {/**/}\\n            }\\n        });\\n        setup\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 343699,
                "title": "no-stack-no-recursion-python-o-n-solution",
                "content": "check if current char is in a nested parenthesis, if it is, label it differently from previous\\n```class Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0]*len(seq)\\n        for i in xrange(1,len(seq)):\\n            if seq[i] != seq[i-1]:\\n                res[i] = res[i-1]\\n            else:\\n                if res[i-1] == 1:\\n                    res[i] = 0\\n                else:\\n                    res[i] = 1\\n        return res",
                "solutionTags": [],
                "code": "check if current char is in a nested parenthesis, if it is, label it differently from previous\\n```class Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0]*len(seq)\\n        for i in xrange(1,len(seq)):\\n            if seq[i] != seq[i-1]:\\n                res[i] = res[i-1]\\n            else:\\n                if res[i-1] == 1:\\n                    res[i] = 0\\n                else:\\n                    res[i] = 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 332815,
                "title": "simply-c-solution-with-explanation",
                "content": "The idea is to visualize the parentheses as a line plot.\\nFor those segments on even levels, we assign it to first group; otherwise, we assign it to second group.\\nThe remaining is just implementation details.\\n```\\n   /\\\\   ---- odd level\\n/\\\\/  \\\\  ---- even level\\n```\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int level = 0;\\n        vector<int> ans;\\n        for (char c : seq) {\\n            ans.push_back((level % 2 == 0 && c == \\'(\\') || (level % 2 == 1 && c == \\')\\'));\\n            ++level;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n   /\\\\   ---- odd level\\n/\\\\/  \\\\  ---- even level\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int level = 0;\\n        vector<int> ans;\\n        for (char c : seq) {\\n            ans.push_back((level % 2 == 0 && c == \\'(\\') || (level % 2 == 1 && c == \\')\\'));\\n            ++level;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329109,
                "title": "o-1-space-concise-python-solution",
                "content": "Alternate between choice of using a new opening parenthesis in subsequence A or B. Swap the choice before considering whichsubsequence to put a closing parenthesis in. \\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        l = True\\n        s = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                s[i] = int(l)\\n                l =  not l\\n            else:\\n                l = not l\\n                s[i] = int(l)\\n        return s\\n      \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        l = True\\n        s = [0] * len(seq)\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                s[i] = int(l)\\n                l =  not l\\n            else:\\n                l = not l\\n                s[i] = int(l)\\n        return s\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 328918,
                "title": "javascript-straight-forward-stack-solution-with-explanation",
                "content": "I used 2 stacks to track the status.\\nWhen we loop through the seq, if it\\'s \"(\", we push it to one of the stack, if it\\'s \")\", we pop it from one of the stack.\\nHow to decide which stack to go? Our default choice is `stack0`, but final choice depends on our current `seq[i]` and the length of `stack0` and `stack1`, which is the logic in the code.\\n\\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    let res = new Array(seq.length).fill(0);\\n    let stack0 = [];\\n    let stack1 = [];\\n    \\n    for(let i=0; i<seq.length; i++){\\n        if(seq[i] === \"(\"){\\n            if(stack0 <= stack1) {\\n                stack0.push(\"(\");\\n                res[i] = 0;\\n            } else {\\n                stack1.push(\"(\");\\n                res[i] = 1;\\n            }\\n        } else {\\n            if(stack0 <= stack1){\\n                stack1.pop();\\n                res[i] = 1;\\n            } else {\\n                stack0.pop();\\n                res[i] = 0;\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxDepthAfterSplit = function(seq) {\\n    let res = new Array(seq.length).fill(0);\\n    let stack0 = [];\\n    let stack1 = [];\\n    \\n    for(let i=0; i<seq.length; i++){\\n        if(seq[i] === \"(\"){\\n            if(stack0 <= stack1) {\\n                stack0.push(\"(\");\\n                res[i] = 0;\\n            } else {\\n                stack1.push(\"(\");\\n                res[i] = 1;\\n            }\\n        } else {\\n            if(stack0 <= stack1){\\n                stack1.pop();\\n                res[i] = 1;\\n            } else {\\n                stack0.pop();\\n                res[i] = 0;\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328898,
                "title": "simple-java-solution",
                "content": "Tracking the outermost parentheses.\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] depth = new int[seq.length()];\\n        int stack = 0;\\n        for (int i = 0; i < seq.length(); i++) {\\n            char c = seq.charAt(i);\\n            if (c == \\'(\\') {\\n                stack++;\\n                if (stack == 1) {\\n                    depth[i] = 0;\\n                } else {\\n                    depth[i] = 1;\\n                }\\n            } else {\\n                stack--;\\n                if (stack == 0) {\\n                    depth[i] = 0;\\n                } else {\\n                    depth[i] = 1;\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] depth = new int[seq.length()];\\n        int stack = 0;\\n        for (int i = 0; i < seq.length(); i++) {\\n            char c = seq.charAt(i);\\n            if (c == \\'(\\') {\\n                stack++;\\n                if (stack == 1) {\\n                    depth[i] = 0;\\n                } else {\\n                    depth[i] = 1;\\n                }\\n            } else {\\n                stack--;\\n                if (stack == 0) {\\n                    depth[i] = 0;\\n                } else {\\n                    depth[i] = 1;\\n                }\\n            }\\n        }\\n        return depth;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328897,
                "title": "java-concise-code",
                "content": "```\\npublic int[] maxDepthAfterSplit(String seq) {\\n        char[] tem = seq.toCharArray();\\n        int[] res = new int[seq.length()];\\n        int level = -1;\\n        for (int i = 0; i < tem.length; i++) {\\n            if (tem[i] == \\'(\\') {\\n                level++;\\n                res[i] = level % 2;\\n            } else {\\n                res[i] = level % 2;\\n                level--;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] maxDepthAfterSplit(String seq) {\\n        char[] tem = seq.toCharArray();\\n        int[] res = new int[seq.length()];\\n        int level = -1;\\n        for (int i = 0; i < tem.length; i++) {\\n            if (tem[i] == \\'(\\') {\\n                level++;\\n                res[i] = level % 2;\\n            } else {\\n                res[i] = level % 2;\\n                level--;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 328885,
                "title": "simple-java-solution-with-explaination",
                "content": "**Intuitive:**\\nIn order to make the depth of two groups as close as possible, we select parenthesis with levels at interval. \\n\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length();\\n        int[] res = new int[n];\\n        int lv = 0; // level\\n        for (int i = 0; i < n; i++) {\\n            char c = seq.charAt(i);\\n            if (c == \\'(\\') {\\n                lv++;\\n                res[i] = lv % 2;  \\n            } else {\\n                res[i] = lv % 2;         \\n                lv--;\\n            }    \\n        }       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length();\\n        int[] res = new int[n];\\n        int lv = 0; // level\\n        for (int i = 0; i < n; i++) {\\n            char c = seq.charAt(i);\\n            if (c == \\'(\\') {\\n                lv++;\\n                res[i] = lv % 2;  \\n            } else {\\n                res[i] = lv % 2;         \\n                lv--;\\n            }    \\n        }       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328844,
                "title": "simple-and-short-python-stack-based",
                "content": "The idea is to choose different depths for each nested level.\\nWhen there is a nesting, we determine the current level\\'s 0/1 value based on the opposite of the previous nesting.\\n\\n```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res, stack = [], []\\n        init = 1\\n        for ch in seq:        \\n            if not stack:\\n                init = init ^ 1\\n                stack.append(init)\\n                res.append(init)\\n            elif ch == \"(\":\\n                stack.append(stack[-1]^1)\\n                res.append(stack[-1])\\n            else:\\n                res.append(stack.pop())\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res, stack = [], []\\n        init = 1\\n        for ch in seq:        \\n            if not stack:\\n                init = init ^ 1\\n                stack.append(init)\\n                res.append(init)\\n            elif ch == \"(\":\\n                stack.append(stack[-1]^1)\\n                res.append(stack[-1])\\n            else:\\n                res.append(stack.pop())\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4093425,
                "title": "simple-alternating-class-solution-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n We assign each VPS to either A or B via a class parameter. The intuition is nuanced but to find the disjoint subsequence of VPS with minimum depth for max(depth(A), depth(B)), then essentially all we need to do is find minimum depth for split for the sequence. We need split the nested VPS\\'s with max depth. The trick is to see the following: 1) if we have ((())) and we need to split it so as to have minimum depth as outlined in problem, then we can assing the outer bracket (first nested bracket) to class 0, the second nested bracket to class 1 and the third bracket (that is not nested) again to class 0. The maximum depth would be 2 and this would be the minimal depth given the problem constraint. To this end, a simple solution is as follows:\\n1) Whenever we encounter a nested bracket we alternate our class, if previosely 0, then for next layer of the nested bracket it is turned to zero.\\n2) for \"summed\" VPS\\'s we do not change the class, that is if we have the following situation: ()(), as the depth does not change.   \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n#\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n#\\n# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\n\\n        stack_ = []\\n        N_stack = 0 \\n        arr_ = []\\n        class_ = 0\\n\\n        for seq_ in seq:\\n            if seq_==\")\":\\n                class_ = 1 - class_\\n                stack_  =stack_[1:]\\n                N_stack-=1\\n                arr_ +=[class_]\\n            else:\\n                arr_+=[class_]\\n                stack_ +=[\"(\"]\\n                class_ = 1 - class_\\n                N_stack +=1\\n                \\n\\n        return(arr_)    \\n                 \\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\n\\n        stack_ = []\\n        N_stack = 0 \\n        arr_ = []\\n        class_ = 0\\n\\n        for seq_ in seq:\\n            if seq_==\")\":\\n                class_ = 1 - class_\\n                stack_  =stack_[1:]\\n                N_stack-=1\\n                arr_ +=[class_]\\n            else:\\n                arr_+=[class_]\\n                stack_ +=[\"(\"]\\n                class_ = 1 - class_\\n                N_stack +=1\\n                \\n\\n        return(arr_)    \\n                 \\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081669,
                "title": "c-less-than-10-lines-beats-100-in-runtime",
                "content": "# Intuition\\nIf we want to decrease the depths of the two VPS A and B we can not include the deepest substring of the given VPS seq in any of the two. We must divide it in the two equally as possible. So here I have assigned them alternately.\\n\\n# Approach\\nSince the first character will always be \\'(\\' we can assign it to any one (I assigned it to A, i.e. 0)\\nIf the second character is also \\'(\\' that means the depth is increasing so we must put this character in the other VPS (which will be B in this case)\\nBut if it is \\')\\' then we must put it in the same VPS as previous one (A in this case) for it to be the valid VPS\\nSo we conclude that if the current character is same as the previous character then we change the VPS and if the character is different then we keep the VPS same\\n\\nExample: (()())    \\nDepth is increasing At index 1 and the previous and current characters are same so the VPS must be changed from 0 to 1. So our ans becomes {0, 1} \\nAt index 2 we got \\')\\' and the last char was \\'(\\' so the VPS must be same {0, 1, 1}\\nAt index 3 we got another \\'(\\' but the last char was also \\')\\' so we will not change the VPS {0, 1, 1, 1}\\nAt index 4 \\')\\' and the previous character was \\'(\\'. Different character same VPS {0, 1, 1, 1, 1}\\nAt index 5 \\')\\'and the previous character was \\')\\'. Same character change the VPS (from 1 to 0) resulting in the final answer {0, 1, 1, 1, 1, 0}.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> ans (n);\\n        ans[0] = 0;\\n\\n        for (int i = 1, j = 0; i < n; ++i, ++j) {\\n            ans[i] = (seq[j] == seq[i]) ? !ans[j] : ans[j];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size();\\n        vector<int> ans (n);\\n        ans[0] = 0;\\n\\n        for (int i = 1, j = 0; i < n; ++i, ++j) {\\n            ans[i] = (seq[j] == seq[i]) ? !ans[j] : ans[j];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961685,
                "title": "maximum-nesting-depth-of-two-valid-parentheses-strings-two-approach-easy-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n       /* stack<int>st,st1;\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<seq.size();i++){\\n            if(seq[i]==\\'(\\'&&count==0){\\n                st.push(seq[i]);\\n                ans.push_back(0);\\n                count++;\\n            }\\n            else if(seq[i]==\\'(\\'&&count>0){\\n                st1.push(seq[i]);\\n                ans.push_back(1);\\n            }\\n            else if(seq[i]==\\')\\'&&count>0&&!st1.empty()){\\n                st1.pop();\\n                ans.push_back(1);\\n            }\\n            else if(seq[i]==\\')\\'&&st1.empty()){\\n                st.pop();\\n                ans.push_back(0);\\n                count--;\\n            }*/\\n    vector<int>ans;\\n    int count=0;\\n    for(int i=0;i<seq.size();i++){\\n        if(seq[i]==\\'(\\'){\\n            count++;\\n            ans.push_back(count%2);\\n        }else{\\n            ans.push_back(count%2);\\n            count--;\\n        }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n       /* stack<int>st,st1;\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<seq.size();i++){\\n            if(seq[i]==\\'(\\'&&count==0){\\n                st.push(seq[i]);\\n                ans.push_back(0);\\n                count++;\\n            }\\n            else if(seq[i]==\\'(\\'&&count>0){\\n                st1.push(seq[i]);\\n                ans.push_back(1);\\n            }\\n            else if(seq[i]==\\')\\'&&count>0&&!st1.empty()){\\n                st1.pop();\\n                ans.push_back(1);\\n            }\\n            else if(seq[i]==\\')\\'&&st1.empty()){\\n                st.pop();\\n                ans.push_back(0);\\n                count--;\\n            }*/\\n    vector<int>ans;\\n    int count=0;\\n    for(int i=0;i<seq.size();i++){\\n        if(seq[i]==\\'(\\'){\\n            count++;\\n            ans.push_back(count%2);\\n        }else{\\n            ans.push_back(count%2);\\n            count--;\\n        }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959829,
                "title": "maximum-nesting-depth-of-two-valid-parentheses-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- just divide \\'()\\' into two groups , either 0 o 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Brute-Force Approach:**\\nIterate through the parentheses, assigning different depths to alternating groups. However, this doesn\\'t ensure balanced groups. Time: O(n), Space: O(n).\\n\\n- **Optimal Approach:**\\nAssign alternating group numbers to opening and closing parentheses, ensuring balanced groups. Traverse input once. Time: O(n), Space: O(n). This approach maintains equal maximum depths in two separate balanced groups of parentheses.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        vector<int> ans; // To store the assigned group numbers\\n        int group = 0;   // Initialize group number (0 or 1)\\n\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                ans.push_back(group);      // Assign current group to opening parenthesis\\n                group = 1 - group;        // Alternate the group number between 0 and 1\\n            } else {\\n                group = 1 - group;        // Alternate the group number for closing parenthesis\\n                ans.push_back(group);      // Assign the opposite group to closing parenthesis\\n            }\\n        }\\n\\n        return ans; // Return the assigned group numbers\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        vector<int> ans; // To store the assigned group numbers\\n        int group = 0;   // Initialize group number (0 or 1)\\n\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                ans.push_back(group);      // Assign current group to opening parenthesis\\n                group = 1 - group;        // Alternate the group number between 0 and 1\\n            } else {\\n                group = 1 - group;        // Alternate the group number for closing parenthesis\\n                ans.push_back(group);      // Assign the opposite group to closing parenthesis\\n            }\\n        }\\n\\n        return ans; // Return the assigned group numbers\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916548,
                "title": "run-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        st = deque()\\n        out = []\\n\\n        for i in range(len(seq)):\\n            if not len(st) and seq[i] == \"(\" :\\n                depth = 1\\n                st.append((seq[i],depth))\\n                out.append(0)\\n            elif len(st) and seq[i] == \"(\" :\\n                depth = 1+st[-1][1]\\n                st.append((seq[i],depth))\\n                if depth%2 == 0 :\\n                    out.append(1)\\n                else : \\n                    out.append(0)\\n            elif len(st) and seq[i] == \")\" :\\n                depth = st[-1][1]\\n                if depth%2 == 0 :\\n                    out.append(1)\\n                else : \\n                    out.append(0)\\n                st.pop()\\n        return out \\n            \\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        st = deque()\\n        out = []\\n\\n        for i in range(len(seq)):\\n            if not len(st) and seq[i] == \"(\" :\\n                depth = 1\\n                st.append((seq[i],depth))\\n                out.append(0)\\n            elif len(st) and seq[i] == \"(\" :\\n                depth = 1+st[-1][1]\\n                st.append((seq[i],depth))\\n                if depth%2 == 0 :\\n                    out.append(1)\\n                else : \\n                    out.append(0)\\n            elif len(st) and seq[i] == \")\" :\\n                depth = st[-1][1]\\n                if depth%2 == 0 :\\n                    out.append(1)\\n                else : \\n                    out.append(0)\\n                st.pop()\\n        return out \\n            \\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862328,
                "title": "100-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s){\\n        vector<int>v;\\n        int mx=0;\\n        for(auto i:s){\\n            if(i==\\'(\\'){\\n                mx++;\\n            }\\n            v.push_back(mx&1);\\n            if(i==\\')\\'){\\n                mx--;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s){\\n        vector<int>v;\\n        int mx=0;\\n        for(auto i:s){\\n            if(i==\\'(\\'){\\n                mx++;\\n            }\\n            v.push_back(mx&1);\\n            if(i==\\')\\'){\\n                mx--;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857315,
                "title": "easy-n-simple-0ms-runtime-100-faster",
                "content": "\\n# Complexity\\n time complexity - O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }\\n            else{\\n                a[i]=depth%2;\\n                depth--;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int depth =-1;\\n        int i=0;\\n        int ln =seq.length();\\n        int[] a = new int[ln];\\n        \\n        while(i<ln){\\n            if(seq.charAt(i)==\\'(\\'){\\n                depth++;\\n                a[i]=depth%2;   \\n            }\\n            else{\\n                a[i]=depth%2;\\n                depth--;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856989,
                "title": "use-flags",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution lies in the observation that the difference in nesting depth between two groups of parentheses can be maximized by alternating their handling of opening and closing parentheses. By doing so, the depth of one group will consistently be one level less than the other, leading to a balanced distribution of nested parentheses. This approach effectively minimizes the common depth between the two groups while maintaining overall balance, resulting in the maximum possible nesting depth difference between the groups.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key approach in this solution is to maintain two boolean flags, opening_A_turn and closing_A_turn, which determine the turn for two different groups. These flags alternate their states based on whether an opening or closing parenthesis is encountered. When an opening parenthesis is encountered, the flag associated with that group is toggled, and the corresponding group index is assigned to the current position in the output array. Similarly, when a closing parenthesis is encountered, the flag for the other group is toggled, and its index is assigned to the output array. This alternating mechanism ensures that the two groups take turns in handling the parentheses, leading to a balanced distribution of nested parentheses and maximizing the difference in nesting depth between the two groups.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nStore index and the group which it belongs to in a map\\nConvert this into an array\\n*/\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> OutputArr(seq.size(),-1);\\n        bool opening_A_turn = true;\\n        bool closing_A_turn = true;\\n\\n        for(int i=0; i<seq.size(); i++){\\n            char curr = seq[i];\\n            // ( and A turn\\n            if(curr == \\'(\\' && opening_A_turn){\\n                OutputArr[i] = 0;\\n                opening_A_turn = !opening_A_turn;\\n            }\\n            // ( and B turn\\n            else if(curr == \\'(\\' && !opening_A_turn ){\\n                OutputArr[i] = 1;\\n                opening_A_turn= !opening_A_turn;\\n            }\\n            // ) and A turn\\n            else if(curr == \\')\\' && closing_A_turn){\\n                OutputArr[i] = 0;\\n                closing_A_turn = !closing_A_turn;\\n            }\\n            // ) and B turn\\n            else{\\n                OutputArr[i] = 1;\\n                closing_A_turn = !closing_A_turn;\\n            }\\n        }\\n\\n        return OutputArr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n/*\\nStore index and the group which it belongs to in a map\\nConvert this into an array\\n*/\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> OutputArr(seq.size(),-1);\\n        bool opening_A_turn = true;\\n        bool closing_A_turn = true;\\n\\n        for(int i=0; i<seq.size(); i++){\\n            char curr = seq[i];\\n            // ( and A turn\\n            if(curr == \\'(\\' && opening_A_turn){\\n                OutputArr[i] = 0;\\n                opening_A_turn = !opening_A_turn;\\n            }\\n            // ( and B turn\\n            else if(curr == \\'(\\' && !opening_A_turn ){\\n                OutputArr[i] = 1;\\n                opening_A_turn= !opening_A_turn;\\n            }\\n            // ) and A turn\\n            else if(curr == \\')\\' && closing_A_turn){\\n                OutputArr[i] = 0;\\n                closing_A_turn = !closing_A_turn;\\n            }\\n            // ) and B turn\\n            else{\\n                OutputArr[i] = 1;\\n                closing_A_turn = !closing_A_turn;\\n            }\\n        }\\n\\n        return OutputArr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756090,
                "title": "python-90-faster-clear-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/e118239d-09dd-49b8-b343-918fd195d191_1689183834.8018787.png)\\n\\n\\nI was very confused by this problem, but after looking at some of the testcases, what we have to return is if the depth is odd, we have to return 0, and if it is even, we have to return 1, or I think we can do vice versa. Below is clear and simple code for checking the depth and returning the result respectively.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack=[]\\n        oc=0\\n        res=[]\\n        for i in seq:\\n            if i==\"(\":\\n                if oc%2!=0:\\n                    res.append(0)\\n                else:\\n                    res.append(1)\\n                oc+=1\\n            else:\\n                oc-=1\\n                if oc%2!=0:\\n                    res.append(0)\\n                else:\\n                    res.append(1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack=[]\\n        oc=0\\n        res=[]\\n        for i in seq:\\n            if i==\"(\":\\n                if oc%2!=0:\\n                    res.append(0)\\n                else:\\n                    res.append(1)\\n                oc+=1\\n            else:\\n                oc-=1\\n                if oc%2!=0:\\n                    res.append(0)\\n                else:\\n                    res.append(1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696753,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        ans.reserve(seq.size());\\n\\n        int a = 0;\\n        int b = 0;\\n        for(char& ch : seq) {\\n            if (ch == \\')\\') {\\n                if (a > b) {\\n                    ans.push_back(0);\\n                    a--;\\n                } else {\\n                    ans.push_back(1);\\n                    b--;\\n                }\\n            } else {\\n                if (a > b) {\\n                    ans.push_back(1);\\n                    b++;\\n                } else {\\n                    ans.push_back(0);\\n                    a++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        ans.reserve(seq.size());\\n\\n        int a = 0;\\n        int b = 0;\\n        for(char& ch : seq) {\\n            if (ch == \\')\\') {\\n                if (a > b) {\\n                    ans.push_back(0);\\n                    a--;\\n                } else {\\n                    ans.push_back(1);\\n                    b--;\\n                }\\n            } else {\\n                if (a > b) {\\n                    ans.push_back(1);\\n                    b++;\\n                } else {\\n                    ans.push_back(0);\\n                    a++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659860,
                "title": "c-easy-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n    int k=0;\\n    vector<int> ans(s.size(),0);\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'(\\')\\n        {\\n            k++;\\n            ans[i]=k%2;\\n        } else {\\n            ans[i]=k%2;\\n            k--;\\n        }\\n    }  \\n    return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n    int k=0;\\n    vector<int> ans(s.size(),0);\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'(\\')\\n        {\\n            k++;\\n            ans[i]=k%2;\\n        } else {\\n            ans[i]=k%2;\\n            k--;\\n        }\\n    }  \\n    return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559307,
                "title": "solutions-using-stack-and-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n<!-- Using Vector -->\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        vector<int> v;\\n        int d =0;\\n        for(auto &x : s){\\n            d+=x==\\'(\\';\\n            v.push_back(d%2);\\n            d-=x==\\')\\';\\n        }\\n        return v;\\n    \\n\\n\\n<!-- Using stack -->\\n\\n    stack<int> st;\\n    int n = s.length();\\n    vector<int> depth(n, 0);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'(\\') {\\n            if (!st.empty()) {\\n                depth[i] = st.top() + 1;\\n            }\\n            st.push(depth[i]);\\n        } else if (s[i] == \\')\\') {\\n            if (!st.empty()) {\\n                st.pop();\\n            }\\n            depth[i] = st.empty() ? 0 : st.top() + 1;\\n        }\\n    }\\n\\n    return depth;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n<!-- Using Vector -->\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        vector<int> v;\\n        int d =0;\\n        for(auto &x : s){\\n            d+=x==\\'(\\';\\n            v.push_back(d%2);\\n            d-=x==\\')\\';\\n        }\\n        return v;\\n    \\n\\n\\n<!-- Using stack -->\\n\\n    stack<int> st;\\n    int n = s.length();\\n    vector<int> depth(n, 0);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'(\\') {\\n            if (!st.empty()) {\\n                depth[i] = st.top() + 1;\\n            }\\n            st.push(depth[i]);\\n        } else if (s[i] == \\')\\') {\\n            if (!st.empty()) {\\n                st.pop();\\n            }\\n            depth[i] = st.empty() ? 0 : st.top() + 1;\\n        }\\n    }\\n\\n    return depth;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378439,
                "title": "python-greedy-solution",
                "content": "# Intuition\\nFirst we store the current depth of `A` and `B` in `level_A` and `level_B` respectively.\\n\\nThe current depth is defined to be the number of unclosed brackets in the string. For example\\n```\\nA = ()()() ; depth = 0\\nA = (      ; depth = 1\\nA = ((     ; depth = 2\\nA = (()    ; depth = 1\\n```\\n- When encounters a `(`, we greedily choose to append it to `A` or `B` based on the lower depth.\\n- When encounters a `)`, we greedily choose to append it to `A` or `B` based on the highest depth.\\n\\n# Example\\nRun through the example on the string`()(())()`:\\n\\n1. Initialize `A = \"\", B = \"\"`, encounters `(`:\\n    insert into either A or B since `level_A = level_B`, we choose `A = \"(\"`\\n2. Encounters `)`: \\n    insert into either A or B since `level_A = level_B`, we choose `A = \"()\"`\\n3. Encounters `(`:\\n    insert into either A or B since `level_A = level_B`, we choose `A = \"()(\"`\\n4. Encounters `(`:\\n    insert into `B = \"(\"` since `level_B` is smaller.\\n5. Encounters `)`:\\n    insert into either A or B since `level_A = level_B`, we choose `A = \"()()\"`\\n6. Encounters `)`:\\n    insert into `B = \"()\"` since `level_B` is greater.\\n7. Encounters `(`:\\n    insert into either A or B since `level_A = level_B`, we choose `A = \"()()(\"` \\n8. Encounters `)`:\\n    insert into `A = \"()()()\"` since `level_A` is greater.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        result = []\\n        level_A = 0\\n        level_B = 0\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                if level_A < level_B:\\n                    result.append(0)\\n                    level_A += 1\\n                else:\\n                    result.append(1)\\n                    level_B += 1\\n            else:\\n                if level_A > level_B:\\n                    result.append(0)\\n                    level_A -= 1\\n                else:\\n                    result.append(1)\\n                    level_B -= 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nA = ()()() ; depth = 0\\nA = (      ; depth = 1\\nA = ((     ; depth = 2\\nA = (()    ; depth = 1\\n```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        result = []\\n        level_A = 0\\n        level_B = 0\\n        for i, c in enumerate(seq):\\n            if c == \\'(\\':\\n                if level_A < level_B:\\n                    result.append(0)\\n                    level_A += 1\\n                else:\\n                    result.append(1)\\n                    level_B += 1\\n            else:\\n                if level_A > level_B:\\n                    result.append(0)\\n                    level_A -= 1\\n                else:\\n                    result.append(1)\\n                    level_B -= 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374604,
                "title": "considering-all-the-cases-tc-o-n-sc-o-1",
                "content": "I wanted to solve this question by considering diff cases as it forces you to think from diff angles.\\nHere is the process of how I solved the problem...\\n\\nA and B such that max(depth(A), depth(B)) is the minimum possible value. : is the given statement.\\nTo get the min possible depth we will have to divide the depth equally among both A & B.\\n\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\nO/p ans: A = ()() , B = ()\\n\\n[Note: Keep a track of no. of non-closed parenthesis in both grps. And when corresponding \")\" is found decrement the no. for that grp by 1.]\\n\\nWe cannot place consecutive (( in the same group...otherwise it will increase the depth. (place them in alternate fashion: ((( --> 0 1 0 ).\\n\\nIf the consecutive chars are () we add both () to the same grp. While adding them to the same grp (0 or 1) we will make sure that it is not getting added to the same grp whose ( is opened but not closed yet. Just like the above example.\\n\\nif consecutive chars are ))...we can keep track of the no. of \"(\" in both groups that doesn\\'t have \"(\". Take max no. and reduce it by 1 since we found the \")\" and place that corresponding grp no. there.\\n\\nI hope this helps...\\nDo upvote if it does...\\nAlso...Pls share your thoughts and suggestions.\\nHave a great coding day everyone!\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int i = 0, n = seq.length(), a = 0, b = 0;\\n        int[] ans = new int[n];\\n\\n        while(i < n-1) {\\n            char ch1 = seq.charAt(i), ch2 = seq.charAt(i+1);\\n            if(ch1 == \\'(\\' && ch2 == \\')\\') {\\n                if(a > 0) {\\n                    ans[i] = 1;\\n                    ans[i+1] = 1;\\n                }\\n                i += 2;\\n            }else if(ch1 == ch2 && ch1 == \\'(\\') {\\n                if(i != 0) {\\n                    if(ans[i-1] == 0) {\\n                        ans[i] = 1;\\n                        ans[i+1] = 0;\\n                    }else {\\n                        ans[i] = 0;\\n                        ans[i+1] = 1;\\n                    }\\n                }else ans[i+1] = 1;\\n                a++;\\n                b++;\\n                i += 2;\\n            }else {\\n                if(a <= b) {\\n                    ans[i] = 1;\\n                    b--;\\n                }else {\\n                    a--;\\n                }\\n                i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int i = 0, n = seq.length(), a = 0, b = 0;\\n        int[] ans = new int[n];\\n\\n        while(i < n-1) {\\n            char ch1 = seq.charAt(i), ch2 = seq.charAt(i+1);\\n            if(ch1 == \\'(\\' && ch2 == \\')\\') {\\n                if(a > 0) {\\n                    ans[i] = 1;\\n                    ans[i+1] = 1;\\n                }\\n                i += 2;\\n            }else if(ch1 == ch2 && ch1 == \\'(\\') {\\n                if(i != 0) {\\n                    if(ans[i-1] == 0) {\\n                        ans[i] = 1;\\n                        ans[i+1] = 0;\\n                    }else {\\n                        ans[i] = 0;\\n                        ans[i+1] = 1;\\n                    }\\n                }else ans[i+1] = 1;\\n                a++;\\n                b++;\\n                i += 2;\\n            }else {\\n                if(a <= b) {\\n                    ans[i] = 1;\\n                    b--;\\n                }else {\\n                    a--;\\n                }\\n                i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338649,
                "title": "track-height-and-closing-bracket-of-each-opening-bracket-you-can-include-maxdepth-2-height-in-a",
                "content": "# Intuition\\nTrack height and closing bracket of each opening bracket. You can include maxDepth / 2 height in A\\n# Code\\n```\\nfunc maxDepthAfterSplit(seq string) []int {\\n    stack := make([]int, 100000)\\n    top := 0\\n    height := make([]int, len(seq))\\n    closing := make([]int, len(seq))\\n    for i, _ := range height {\\n        height[i] = -1\\n        closing[i] = -1\\n    }\\n    clen := 0\\n    maxLen := 0\\n    update := func(x int) {\\n        if x > maxLen {\\n            maxLen = x\\n        }\\n    }\\n    for i, br := range seq {\\n        if br == \\'(\\' {\\n            clen++\\n            update(clen)\\n            height[i] = clen\\n            stack[top] = i\\n            top++\\n        } else {\\n            clen--\\n            if clen < 0 {\\n                panic(\"invalid vps\")\\n            }\\n            closing[stack[top-1]] = i\\n            top--\\n        }\\n    }\\n    reqH := maxLen / 2\\n    aIndex := make(map[int]bool)\\n    for i:=0; i<len(seq); i++ {\\n        if seq[i] == \\'(\\' && height[i] <= reqH {\\n            aIndex[i] = true\\n            aIndex[closing[i]] = true\\n        }\\n    }\\n    result := make([]int, len(seq))\\n    for i, _ := range result {\\n        _, isA := aIndex[i]\\n        if isA {\\n            result[i] = 0\\n        } else {\\n            result[i] = 1\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxDepthAfterSplit(seq string) []int {\\n    stack := make([]int, 100000)\\n    top := 0\\n    height := make([]int, len(seq))\\n    closing := make([]int, len(seq))\\n    for i, _ := range height {\\n        height[i] = -1\\n        closing[i] = -1\\n    }\\n    clen := 0\\n    maxLen := 0\\n    update := func(x int) {\\n        if x > maxLen {\\n            maxLen = x\\n        }\\n    }\\n    for i, br := range seq {\\n        if br == \\'(\\' {\\n            clen++\\n            update(clen)\\n            height[i] = clen\\n            stack[top] = i\\n            top++\\n        } else {\\n            clen--\\n            if clen < 0 {\\n                panic(\"invalid vps\")\\n            }\\n            closing[stack[top-1]] = i\\n            top--\\n        }\\n    }\\n    reqH := maxLen / 2\\n    aIndex := make(map[int]bool)\\n    for i:=0; i<len(seq); i++ {\\n        if seq[i] == \\'(\\' && height[i] <= reqH {\\n            aIndex[i] = true\\n            aIndex[closing[i]] = true\\n        }\\n    }\\n    result := make([]int, len(seq))\\n    for i, _ := range result {\\n        _, isA := aIndex[i]\\n        if isA {\\n            result[i] = 0\\n        } else {\\n            result[i] = 1\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336084,
                "title": "easy-c-100-faster-by-using-depth-parity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int d = 0;\\n        for(auto x:seq)\\n        {\\n            if(x==\\'(\\') d++;\\n            ans.push_back(d%2);\\n            if(x==\\')\\') d--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int d = 0;\\n        for(auto x:seq)\\n        {\\n            if(x==\\'(\\') d++;\\n            ans.push_back(d%2);\\n            if(x==\\')\\') d--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318138,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int[] MaxDepthAfterSplit(string seq) {\\n        var result = new int[seq.Length];\\n\\n        for (int i = 0; i < seq.Length; i++)\\n        {\\n            result[i] = seq[i] == \\'(\\' ? i % 2 : (i - 1) % 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxDepthAfterSplit(string seq) {\\n        var result = new int[seq.Length];\\n\\n        for (int i = 0; i < seq.Length; i++)\\n        {\\n            result[i] = seq[i] == \\'(\\' ? i % 2 : (i - 1) % 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291212,
                "title": "c-o-n-runtime-o-1-space-except-output",
                "content": "```\\nclass Solution {\\npublic:\\n    // algorithm\\n    // any time the depth is > max height / 2, assign other one\\n    // try even and odd cases\\n    // 3, > 3/2 = 2\\n    // 2, > 2/2 = 1\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cur = 0, largest = 0, prev = 0;\\n        for (auto& c : seq){\\n            if (c == \\'(\\') ++cur;\\n            else --cur;\\n            largest = max(largest, cur);\\n        }\\n        vector<int> ans;\\n        cur = 0;\\n        for (auto& c : seq){\\n            if (c == \\'(\\') ++cur;\\n            else --cur;\\n            if (cur > largest / 2 || prev > largest / 2) ans.push_back(0);\\n            else ans.push_back(1);\\n            prev = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // algorithm\\n    // any time the depth is > max height / 2, assign other one\\n    // try even and odd cases\\n    // 3, > 3/2 = 2\\n    // 2, > 2/2 = 1\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int cur = 0, largest = 0, prev = 0;\\n        for (auto& c : seq){\\n            if (c == \\'(\\') ++cur;\\n            else --cur;\\n            largest = max(largest, cur);\\n        }\\n        vector<int> ans;\\n        cur = 0;\\n        for (auto& c : seq){\\n            if (c == \\'(\\') ++cur;\\n            else --cur;\\n            if (cur > largest / 2 || prev > largest / 2) ans.push_back(0);\\n            else ans.push_back(1);\\n            prev = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263097,
                "title": "easy-understanding-easy-stack-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTask is to divide the given parentheses into two groups such that maximum depth of both groups should be minimum. \\n<!-- I thought of dividing string into group with depth -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can divide parentheses into two groups based on depth by creating a group with depth less than equal to maxDepth/2 and more than maxDepth/2\\n\\nIn 1st traversal check the max depth by checking size of stack containing only \\'(\\'.\\nIn 2nd traversal assign value to answer array with help of stack size i.e all parantheses with stack size less than equal to maxDepth/2 is assigned group 1 and rest group 2.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nwhere n== string length\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        stack<int>st;\\n        int mx=0;       //max size of stack with \\'(\\'\\n        for(char c:s){\\n            if(c==\\'(\\'){\\n                st.push(c);\\n                mx=max(mx,(int)st.size());\\n            }\\n            else{\\n                st.pop();\\n            }\\n        }\\n        vector<int>ans(s.size());\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n                if(st.size()<=mx/2){\\n                    ans[i]=1;\\n                }\\n            }\\n            else{\\n                if(st.size()<=mx/2){\\n                    ans[i]=1;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        stack<int>st;\\n        int mx=0;       //max size of stack with \\'(\\'\\n        for(char c:s){\\n            if(c==\\'(\\'){\\n                st.push(c);\\n                mx=max(mx,(int)st.size());\\n            }\\n            else{\\n                st.pop();\\n            }\\n        }\\n        vector<int>ans(s.size());\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n                if(st.size()<=mx/2){\\n                    ans[i]=1;\\n                }\\n            }\\n            else{\\n                if(st.size()<=mx/2){\\n                    ans[i]=1;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257369,
                "title": "python-use-two-levels-to-split-seq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        arr = list(seq)\\n        res = []\\n        level = 0\\n        while arr:\\n            current = arr.pop(0)\\n            if current == \"(\":\\n                level = 1 - level\\n                res.append(level)\\n            else:\\n                res.append(level)\\n                level = 1 - level\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        \"\"\"\\n        :type seq: str\\n        :rtype: List[int]\\n        \"\"\"\\n        arr = list(seq)\\n        res = []\\n        level = 0\\n        while arr:\\n            current = arr.pop(0)\\n            if current == \"(\":\\n                level = 1 - level\\n                res.append(level)\\n            else:\\n                res.append(level)\\n                level = 1 - level\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254832,
                "title": "python-o-n-time-and-o-1-space-really-short-and-easy-to-understand",
                "content": "So the idea is almost the same as [Maximum Nesting Depth of the Parentheses](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/). The idea is to \\n* have a variable `count` to check open parentheses \\n* assign the group before increase the `count` if char == \\'(\\'\\n* decrease `count` before assign the group if char == \\')\\'\\n\\nReason:\\nLet\\'s have the example `(()())`.\\nIf we don\\'t include the logic to assign group, the final count would be `[1, 2, 1, 2 ,1, 0]` and we want the count to become `[1, 2, 2, 2, 2, 1]`  or `[0, 1, 1, 1, 1, 0]` then we could use module to assign group for each position. \\n\\nSo the key part is to assign group before increase and decrease first then assign (or vise versa) to have each parentheses the same group.\\n\\n```\\n         (   (   )   (   )   )   \\nres      0   0   0   0   0   0     start with count = 0\\nres      0   0   0   0   0   0     now pointer moves to idx = 0, assign 0 % 2 = 0 to res[0], then count += 1  -> count = 1\\nres      0   1   0   0   0   0     now pointer moves to idx = 1, assign 1 % 2 = 1 to res[1], then count += 1  -> count = 2\\nres      0   1   1   0   0   0     now pointer moves to idx = 2, !decrease count first!, count -= 1 -> count = 1, assign 1 % 2 = 1 to res[2]\\nres      0   1   1   1   0   0     now pointer moves to idx = 3, assign 1 % 2 = 1 to res[3], then count += 1  -> count = 2\\nres      0   1   1   1   1   0     now pointer moves to idx = 4, !decrease count first!, count -= 1 -> count = 1, assign 1 % 2 = 1 to res[4]\\nres      0   1   1   1   1   0     now pointer moves to idx = 5, !decrease count first!, count -= 1 -> count = 0, assign 0 % 2 = 0 to res[5]\\n```\\n\\nC0DE, the least important part:\\n\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res = [0] * len(seq)\\n        count = 0\\n        \\n        for idx, i in enumerate(seq):\\n            if i == \\'(\\':\\n\\t\\t\\t\\t# Assign group first, then increase count\\n                res[idx] = count % 2\\n                count += 1\\n            else:\\n\\t\\t\\t\\t# Decrease group first then assign\\n                count -= 1\\n                res[idx] = count % 2\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n         (   (   )   (   )   )   \\nres      0   0   0   0   0   0     start with count = 0\\nres      0   0   0   0   0   0     now pointer moves to idx = 0, assign 0 % 2 = 0 to res[0], then count += 1  -> count = 1\\nres      0   1   0   0   0   0     now pointer moves to idx = 1, assign 1 % 2 = 1 to res[1], then count += 1  -> count = 2\\nres      0   1   1   0   0   0     now pointer moves to idx = 2, !decrease count first!, count -= 1 -> count = 1, assign 1 % 2 = 1 to res[2]\\nres      0   1   1   1   0   0     now pointer moves to idx = 3, assign 1 % 2 = 1 to res[3], then count += 1  -> count = 2\\nres      0   1   1   1   1   0     now pointer moves to idx = 4, !decrease count first!, count -= 1 -> count = 1, assign 1 % 2 = 1 to res[4]\\nres      0   1   1   1   1   0     now pointer moves to idx = 5, !decrease count first!, count -= 1 -> count = 0, assign 0 % 2 = 0 to res[5]\\n```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res = [0] * len(seq)\\n        count = 0\\n        \\n        for idx, i in enumerate(seq):\\n            if i == \\'(\\':\\n\\t\\t\\t\\t# Assign group first, then increase count\\n                res[idx] = count % 2\\n                count += 1\\n            else:\\n\\t\\t\\t\\t# Decrease group first then assign\\n                count -= 1\\n                res[idx] = count % 2\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254104,
                "title": "intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust alternate group every position belongs to \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAll you have to do is to make sure that you\\'re not repeating the group you\\'ve used before.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\nfun maxDepthAfterSplit(seq: String): IntArray {\\n\\n    val stack = Stack<ParentEle>()\\n    var group = 1\\n    val answer = IntArray(seq.length) { -1 }\\n    for (i in 0 until seq.length) {\\n        if (seq[i] == \\'(\\') {\\n            stack.push(ParentEle(i, \\'(\\'))\\n            group = if (group == 1) 0 else 1\\n        } else if (stack.peek().char == \\'(\\') {\\n            val prev = stack.pop()\\n            answer[prev.pos] = group\\n            answer[i] = group\\n            group = if (group == 1) 0 else 1\\n        }\\n    }\\n    return answer\\n}\\n\\ndata class ParentEle(val pos: Int, val char: Char)\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\nfun maxDepthAfterSplit(seq: String): IntArray {\\n\\n    val stack = Stack<ParentEle>()\\n    var group = 1\\n    val answer = IntArray(seq.length) { -1 }\\n    for (i in 0 until seq.length) {\\n        if (seq[i] == \\'(\\') {\\n            stack.push(ParentEle(i, \\'(\\'))\\n            group = if (group == 1) 0 else 1\\n        } else if (stack.peek().char == \\'(\\') {\\n            val prev = stack.pop()\\n            answer[prev.pos] = group\\n            answer[i] = group\\n            group = if (group == 1) 0 else 1\\n        }\\n    }\\n    return answer\\n}\\n\\ndata class ParentEle(val pos: Int, val char: Char)\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225836,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] arr = new int[seq.length()];\\n\\n        int length = arr.length;\\n        int count=0;\\n        for(int i=0; i<length; i++){\\n            if(seq.charAt(i)==\\'(\\'){\\n                count++;\\n                arr[i] = count%2;\\n            }\\n            else{\\n                arr[i] = count%2;\\n                count--;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] arr = new int[seq.length()];\\n\\n        int length = arr.length;\\n        int count=0;\\n        for(int i=0; i<length; i++){\\n            if(seq.charAt(i)==\\'(\\'){\\n                count++;\\n                arr[i] = count%2;\\n            }\\n            else{\\n                arr[i] = count%2;\\n                count--;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217530,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maxDepthAfterSplit(_ seq: String) -> [Int] {\\n        \\n        var ds = [Int]()\\n        var d = 0\\n\\n        for c in seq {\\n            if c == \"(\" {\\n                d += 1\\n                ds.append(d)\\n            }\\n            else {\\n                ds.append(d)\\n                d -= 1\\n            }\\n        }\\n\\n        let m = (ds.min()! + ds.max()!) / 2\\n\\n        return ds.map { $0 > m ? 1 : 0 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDepthAfterSplit(_ seq: String) -> [Int] {\\n        \\n        var ds = [Int]()\\n        var d = 0\\n\\n        for c in seq {\\n            if c == \"(\" {\\n                d += 1\\n                ds.append(d)\\n            }\\n            else {\\n                ds.append(d)\\n                d -= 1\\n            }\\n        }\\n\\n        let m = (ds.min()! + ds.max()!) / 2\\n\\n        return ds.map { $0 > m ? 1 : 0 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148890,
                "title": "clean-python-1-line-high-speed-o-n-time-o-1-space-beats-98-9",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq):\\n        return [i & 1 ^ (seq[i] == \\'(\\') for i, c in enumerate(seq)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq):\\n        return [i & 1 ^ (seq[i] == \\'(\\') for i, c in enumerate(seq)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134157,
                "title": "easy-o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust make all left braces and right braces ABAB...\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        bool left=true,right=true;\\n        for(char c:seq)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                res.push_back(left?0:1);\\n                left=!left;\\n            }\\n            else\\n            {\\n                res.push_back(right?0:1);\\n                right=!right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> res;\\n        bool left=true,right=true;\\n        for(char c:seq)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                res.push_back(left?0:1);\\n                left=!left;\\n            }\\n            else\\n            {\\n                res.push_back(right?0:1);\\n                right=!right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121400,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n       int[] arr=new int[seq.length()];\\n       int lvl=0;\\n       for(int i=0;i<seq.length();i++){\\n           if(seq.charAt(i)==\\'(\\'){\\n                arr[i]=++lvl%2;\\n           }else{\\n               arr[i]=lvl--%2;\\n           }\\n       } \\n       return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n       int[] arr=new int[seq.length()];\\n       int lvl=0;\\n       for(int i=0;i<seq.length();i++){\\n           if(seq.charAt(i)==\\'(\\'){\\n                arr[i]=++lvl%2;\\n           }else{\\n               arr[i]=lvl--%2;\\n           }\\n       } \\n       return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916017,
                "title": "100-faster-soln-only-stack-easy-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>p;\\n        int max=0;\\n        for(int i=0;i<seq.length();i++){\\n            if(seq[i]==\\'(\\') max++;\\n            p.push_back(max%2);\\n            if(seq[i]==\\')\\') max--; \\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>p;\\n        int max=0;\\n        for(int i=0;i<seq.length();i++){\\n            if(seq[i]==\\'(\\') max++;\\n            p.push_back(max%2);\\n            if(seq[i]==\\')\\') max--; \\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794266,
                "title": "stack-iteration",
                "content": "class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] ans = new int[seq.length()];\\n                    int count = 0;\\n\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n               ans[i] = ++count%2;\\n            }\\n            else if (seq.charAt(i) == \\')\\'){\\n                ans[i] = count--%2;\\n            }\\n            // ans[i] = count;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] ans = new int[seq.length()];\\n                    int count = 0;\\n\\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq.charAt(i) == \\'(\\'){\\n               ans[i] = ++count%2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2792026,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        A = []\\n        B = []\\n        ans = []\\n        for i in seq:\\n            if i == \\'(\\':\\n                if A == [] and B == []:\\n                    A.append(i)\\n                    ans.append(0)\\n                elif len(A) < len(B):\\n                    A.append(i)\\n                    ans.append(0)\\n                else:\\n                    B.append(i)\\n                    ans.append(1)\\n            elif i == \\')\\':\\n                if A and A[-1] == \\'(\\':\\n                    A.pop()\\n                    ans.append(0)\\n                elif B and B[-1] == \\'(\\':\\n                    B.pop()\\n                    ans.append(1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        A = []\\n        B = []\\n        ans = []\\n        for i in seq:\\n            if i == \\'(\\':\\n                if A == [] and B == []:\\n                    A.append(i)\\n                    ans.append(0)\\n                elif len(A) < len(B):\\n                    A.append(i)\\n                    ans.append(0)\\n                else:\\n                    B.append(i)\\n                    ans.append(1)\\n            elif i == \\')\\':\\n                if A and A[-1] == \\'(\\':\\n                    A.pop()\\n                    ans.append(0)\\n                elif B and B[-1] == \\'(\\':\\n                    B.pop()\\n                    ans.append(1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786540,
                "title": "python-3-simple-o-n-o-1",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        curOpen = 0\\n        answer = []\\n        for c in seq:\\n            if c == \\'(\\':\\n                curOpen += 1\\n                answer.append(curOpen & 1)\\n            else:\\n                answer.append(curOpen & 1)\\n                curOpen -= 1\\n        \\n        return answer\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        curOpen = 0\\n        answer = []\\n        for c in seq:\\n            if c == \\'(\\':\\n                curOpen += 1\\n                answer.append(curOpen & 1)\\n            else:\\n                answer.append(curOpen & 1)\\n                curOpen -= 1\\n        \\n        return answer\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693402,
                "title": "c-easunderstnding-basic-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>s;\\n        int d = 0;\\n        for(auto c : seq){\\n            bool flag = c == \\'(\\';\\n            if(flag)d++; // open bracket\\n            s.push_back(d%2);\\n            if(!flag)d--; // closed bracket\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>s;\\n        int d = 0;\\n        for(auto c : seq){\\n            bool flag = c == \\'(\\';\\n            if(flag)d++; // open bracket\\n            s.push_back(d%2);\\n            if(!flag)d--; // closed bracket\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657782,
                "title": "c-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\n`O(n)` -> `n` is the length of string `seq`.\\n\\n- Space complexity:\\n`O(n)` -> `n` is the length of string `seq`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static vector<int> maxDepthAfterSplit(const string& seq) {\\n        vector<int> ret;\\n        int st = 0, max_depth = 0;\\n        for(char c : seq)\\n            if(\\'(\\' == c)\\n                max_depth = max(max_depth, ++st);\\n            else\\n                --st;\\n        const int half_depth = max_depth >> 1;\\n        for(char c : seq)\\n            if(\\'(\\' == c)\\n                ret.push_back(++st > half_depth);\\n            else\\n                ret.push_back(st-- > half_depth);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static vector<int> maxDepthAfterSplit(const string& seq) {\\n        vector<int> ret;\\n        int st = 0, max_depth = 0;\\n        for(char c : seq)\\n            if(\\'(\\' == c)\\n                max_depth = max(max_depth, ++st);\\n            else\\n                --st;\\n        const int half_depth = max_depth >> 1;\\n        for(char c : seq)\\n            if(\\'(\\' == c)\\n                ret.push_back(++st > half_depth);\\n            else\\n                ret.push_back(st-- > half_depth);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605751,
                "title": "simple-intuitive-python-solution",
                "content": "The maximum of the depths of the 2 parts is minimum when both the parts have almost same length.\\nIn other sub-optimal cases, the less deeper one part gets, the more deeper the other has to get which increases the maximum depth of the 2 parts. \\n\\nSo, we need to break down the string to two parts that are as balanced as possible.\\n\\nOne way to do this:\\n- Start with 2 empty stacks\\n- When there is an opening parenthesis, we want to keep both stack lengths as close as possible. Pushing to the larger stack will only increase the gap between the two. So, we push to the smaller stack.\\n- When there is a closing parenthesis, popping from the smaller stack will further increase the gap. So, we need to pop from the larger stack.\\n- At every element in the sequence, we append 0 to the result array if we are pushing/popping from stack 1 and append 1 if we are pushing/popping from stack 2.\\n\\n\\nNote: Since we are only concerned with the stack lengths - we don\\'t need 2 stacks but just 2 counters that store the lengths of stack 1 and stack 2. We increment the counter while pushing and decrement it while popping.\\n\\n```class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack1 = 0\\n        stack2 = 0\\n        res = []\\n        \\n        for ele in seq:\\n            if ele == \\'(\\':\\n                if stack1 <= stack2:\\n                    res.append(0)\\n                    stack1 += 1\\n                else:\\n                    res.append(1)\\n                    stack2 += 1\\n            else:\\n                if stack1 >= stack2:\\n                    res.append(0)\\n                    stack1 -= 1\\n                else:\\n                    res.append(1)\\n                    stack2 -= 1\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The maximum of the depths of the 2 parts is minimum when both the parts have almost same length.\\nIn other sub-optimal cases, the less deeper one part gets, the more deeper the other has to get which increases the maximum depth of the 2 parts. \\n\\nSo, we need to break down the string to two parts that are as balanced as possible.\\n\\nOne way to do this:\\n- Start with 2 empty stacks\\n- When there is an opening parenthesis, we want to keep both stack lengths as close as possible. Pushing to the larger stack will only increase the gap between the two. So, we push to the smaller stack.\\n- When there is a closing parenthesis, popping from the smaller stack will further increase the gap. So, we need to pop from the larger stack.\\n- At every element in the sequence, we append 0 to the result array if we are pushing/popping from stack 1 and append 1 if we are pushing/popping from stack 2.\\n\\n\\nNote: Since we are only concerned with the stack lengths - we don\\'t need 2 stacks but just 2 counters that store the lengths of stack 1 and stack 2. We increment the counter while pushing and decrement it while popping.\\n\\n```class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        stack1 = 0\\n        stack2 = 0\\n        res = []\\n        \\n        for ele in seq:\\n            if ele == \\'(\\':\\n                if stack1 <= stack2:\\n                    res.append(0)\\n                    stack1 += 1\\n                else:\\n                    res.append(1)\\n                    stack2 += 1\\n            else:\\n                if stack1 >= stack2:\\n                    res.append(0)\\n                    stack1 -= 1\\n                else:\\n                    res.append(1)\\n                    stack2 -= 1\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2448152,
                "title": "java-easy-soln",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        Stack <Character> stk= new Stack<>();\\n        int []soln= new int[seq.length()];\\n        for (int i = 0; i < seq.length(); i++) {\\n            if(stk.isEmpty()){\\n                stk.push(\\'(\\');\\n                soln[i]=0;\\n            }\\n            else if(seq.charAt(i)==\\'(\\'){\\n                stk.push(\\'(\\');\\n                if(stk.size()%2==0) soln[i]=1;\\n                else soln[i]=0;\\n            }\\n            else{\\n                stk.pop();\\n                if(stk.isEmpty()) soln[i]=0;\\n                else if(stk.size()%2==0) soln[i]=0;\\n                else soln[i]=1;\\n            }\\n        }\\n        return soln;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        Stack <Character> stk= new Stack<>();\\n        int []soln= new int[seq.length()];\\n        for (int i = 0; i < seq.length(); i++) {\\n            if(stk.isEmpty()){\\n                stk.push(\\'(\\');\\n                soln[i]=0;\\n            }\\n            else if(seq.charAt(i)==\\'(\\'){\\n                stk.push(\\'(\\');\\n                if(stk.size()%2==0) soln[i]=1;\\n                else soln[i]=0;\\n            }\\n            else{\\n                stk.pop();\\n                if(stk.isEmpty()) soln[i]=0;\\n                else if(stk.size()%2==0) soln[i]=0;\\n                else soln[i]=1;\\n            }\\n        }\\n        return soln;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406730,
                "title": "c-easy-solution-o-n",
                "content": "Time complexity   :- O(N)\\nspace complexity :- O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n         vector< int > ans ;\\n         int openc = 0 ;\\n         int maxi = 0 ;\\n         for( auto x : seq)\\n         {\\n             if ( x == \\'(\\' )\\n             {\\n                 openc++ ;\\n                 maxi = max(  maxi , openc ) ;\\n             }\\n             else openc-- ;\\n         }\\n         maxi = (maxi+1)/2 ;\\n         openc = 0 ;\\n         int  flag = 0  ;\\n        for( int i = 0 ; i<seq.length() ; i++ )\\n        {\\n            if( seq[i] == \\'(\\' ) openc++ ;\\n            else openc-- ;\\n            \\n            if( flag ) \\n            {   ans.push_back(0) ;\\n                flag = 0  ;\\n                continue ;\\n            }\\n            if( openc <= maxi )\\n                ans.push_back( 1 ) ;\\n            else \\n            {   ans.push_back( 0 ) ;\\n                flag = 1 ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n         vector< int > ans ;\\n         int openc = 0 ;\\n         int maxi = 0 ;\\n         for( auto x : seq)\\n         {\\n             if ( x == \\'(\\' )\\n             {\\n                 openc++ ;\\n                 maxi = max(  maxi , openc ) ;\\n             }\\n             else openc-- ;\\n         }\\n         maxi = (maxi+1)/2 ;\\n         openc = 0 ;\\n         int  flag = 0  ;\\n        for( int i = 0 ; i<seq.length() ; i++ )\\n        {\\n            if( seq[i] == \\'(\\' ) openc++ ;\\n            else openc-- ;\\n            \\n            if( flag ) \\n            {   ans.push_back(0) ;\\n                flag = 0  ;\\n                continue ;\\n            }\\n            if( openc <= maxi )\\n                ans.push_back( 1 ) ;\\n            else \\n            {   ans.push_back( 0 ) ;\\n                flag = 1 ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394086,
                "title": "c-simple-loop",
                "content": "Here we have to distribute `(` and `)` *evenly* between `A` and `B`. We can do in this way:\\n\\n1. If we have `(` and the last opened `(` was in A, put it into B and vice versa\\n2. If we have `)` and last opened `(` was in A put it into A and mark B as having last opened \\'(` and vice versa.\\n\\n**Code**, time complexity O(n), extra space (answer excluded) - `O(1)`\\n\\n```\\npublic class Solution {\\n     public int[] MaxDepthAfterSplit(string seq) {\\n        int current = 1;\\n        \\n        int[] result = new int[seq.Length];\\n        \\n        for (int i = 0; i < seq.Length; ++i) \\n            if (seq[i] == \\'(\\') \\n                result[i] = (current = 1 - current);\\n            else {\\n                result[i] = current;\\n                \\n                current = 1 - current;\\n            }\\n                \\n        return result;\\n    }\\n }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n     public int[] MaxDepthAfterSplit(string seq) {\\n        int current = 1;\\n        \\n        int[] result = new int[seq.Length];\\n        \\n        for (int i = 0; i < seq.Length; ++i) \\n            if (seq[i] == \\'(\\') \\n                result[i] = (current = 1 - current);\\n            else {\\n                result[i] = current;\\n                \\n                current = 1 - current;\\n            }\\n                \\n        return result;\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381145,
                "title": "python-o-1-space-solution",
                "content": "```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\ts, seq = 0, list(seq)\\n\\tfor i in range(len(seq)):\\n\\t\\tc = seq[i]\\n\\t\\tif c==\\'(\\':\\n\\t\\t\\tseq[i] = int(s>0)\\n\\t\\t\\tif s <= 0:\\n\\t\\t\\t\\ts += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts -= 1\\n\\t\\telse:\\n\\t\\t\\tseq[i] = int(s<0)\\n\\t\\t\\tif s >= 0:\\n\\t\\t\\t\\ts -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts += 1\\n\\treturn seq\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n\\ts, seq = 0, list(seq)\\n\\tfor i in range(len(seq)):\\n\\t\\tc = seq[i]\\n\\t\\tif c==\\'(\\':\\n\\t\\t\\tseq[i] = int(s>0)\\n\\t\\t\\tif s <= 0:\\n\\t\\t\\t\\ts += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts -= 1\\n\\t\\telse:\\n\\t\\t\\tseq[i] = int(s<0)\\n\\t\\t\\tif s >= 0:\\n\\t\\t\\t\\ts -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts += 1\\n\\treturn seq\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2277171,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        \\n        vector<int> vec;\\n        int mx=0, ans=0;\\n        for(auto itr: seq)\\n        {\\n            if(itr==\\'(\\')\\n                ans++;\\n            mx = max(mx, ans);\\n            vec.push_back(ans);\\n            if(itr==\\')\\')\\n                ans--;\\n        }\\n        \\n        mx = mx/2;\\n        for(int i=0; i<seq.size(); i++)\\n        {\\n            if(vec[i]<=mx)\\n                vec[i]=0;\\n            else\\n                vec[i]=1;\\n        }\\n        \\n        return vec;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        \\n        vector<int> vec;\\n        int mx=0, ans=0;\\n        for(auto itr: seq)\\n        {\\n            if(itr==\\'(\\')\\n                ans++;\\n            mx = max(mx, ans);\\n            vec.push_back(ans);\\n            if(itr==\\')\\')\\n                ans--;\\n        }\\n        \\n        mx = mx/2;\\n        for(int i=0; i<seq.size(); i++)\\n        {\\n            if(vec[i]<=mx)\\n                vec[i]=0;\\n            else\\n                vec[i]=1;\\n        }\\n        \\n        return vec;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236885,
                "title": "c-2-passes-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int depth(const string& s) {\\n        int l = 0, res = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            l += s[i] == \\'(\\' ? 1 : -1;\\n            res = max(res, l);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int d = depth(seq) / 2;\\n        int l = 0;\\n        vector<int> res(seq.size());\\n        for (int i = 0; i < seq.size(); ++i) {\\n            res[i] = seq[i] == \\'(\\' ? ++l > d : l-- > d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int depth(const string& s) {\\n        int l = 0, res = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            l += s[i] == \\'(\\' ? 1 : -1;\\n            res = max(res, l);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int d = depth(seq) / 2;\\n        int l = 0;\\n        vector<int> res(seq.size());\\n        for (int i = 0; i < seq.size(); ++i) {\\n            res[i] = seq[i] == \\'(\\' ? ++l > d : l-- > d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178655,
                "title": "python-sol-greedy-easy-explained-linear-time-complexity",
                "content": "# EXPLANATION\\n```\\n\\n\\n**DURING OPENING CHOOSE THE PART WHERE NO OF OPENING BRAKCETS ARE LESS\\nDURING CLOSING CHOOSE THE PART WHERE NO OF OPENING BRACKETS ARE MORE**\\n\\n\\nThe idea is simple :\\nwe need to minimize the maximum ( depth(A) , depth(B) )\\nSO whenever we open a bracket :\\n1. If previous opening was for A : open for B\\n2. If previous opening was for B : open for A\\n\\nwhenever we close a bracket :\\n1. If previous opening was for A : close for A\\n2. If previous opening was for B : close for B\\n\\n\\nBy this we ensure to get the required answer\\n```\\n\\n\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = []\\n        last = 1\\n        for i in seq:\\n            if i == \\'(\\':\\n                if last == 0: ans.append(1)\\n                else:ans.append(0)\\n            else:\\n                ans.append(last)\\n            last = (last + 1) % 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\n\\n\\n**DURING OPENING CHOOSE THE PART WHERE NO OF OPENING BRAKCETS ARE LESS\\nDURING CLOSING CHOOSE THE PART WHERE NO OF OPENING BRACKETS ARE MORE**\\n\\n\\nThe idea is simple :\\nwe need to minimize the maximum ( depth(A) , depth(B) )\\nSO whenever we open a bracket :\\n1. If previous opening was for A : open for B\\n2. If previous opening was for B : open for A\\n\\nwhenever we close a bracket :\\n1. If previous opening was for A : close for A\\n2. If previous opening was for B : close for B\\n\\n\\nBy this we ensure to get the required answer\\n```\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        ans = []\\n        last = 1\\n        for i in seq:\\n            if i == \\'(\\':\\n                if last == 0: ans.append(1)\\n                else:ans.append(0)\\n            else:\\n                ans.append(last)\\n            last = (last + 1) % 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147600,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/ca0cac29-1d8b-4fc1-a0c7-76e8bc029520_1655132341.8941426.png)\\n```\\nint* maxDepthAfterSplit(char* seq, int* returnSize) {\\n    int len = strlen(seq), top = 0;\\n    int* ans = (int*) calloc(len, sizeof(int));\\n    for (int i = 0; i < len; i++) {\\n        if (seq[i] == \\'(\\') {\\n            top++;\\n            ans[i] = top % 2 == 0 ? 1 : 0;\\n        }\\n        if (seq[i] == \\')\\') {\\n            ans[i] = top % 2 == 0 ? 1 : 0;\\n            top--;\\n        }\\n    }\\n    *returnSize = len;\\n    return ans;\\n}\\n//----------------------- another way -----------------------//\\nint* maxDepthAfterSplit(char* seq, int* returnSize) {\\n    *returnSize = strlen(seq);\\n    int idx = 0;\\n    int* ans = (int*) calloc((*returnSize), sizeof(int));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        ans[idx] = (seq[i] ^ idx) & 1;\\n\\t\\tidx++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* maxDepthAfterSplit(char* seq, int* returnSize) {\\n    int len = strlen(seq), top = 0;\\n    int* ans = (int*) calloc(len, sizeof(int));\\n    for (int i = 0; i < len; i++) {\\n        if (seq[i] == \\'(\\') {\\n            top++;\\n            ans[i] = top % 2 == 0 ? 1 : 0;\\n        }\\n        if (seq[i] == \\')\\') {\\n            ans[i] = top % 2 == 0 ? 1 : 0;\\n            top--;\\n        }\\n    }\\n    *returnSize = len;\\n    return ans;\\n}\\n//----------------------- another way -----------------------//\\nint* maxDepthAfterSplit(char* seq, int* returnSize) {\\n    *returnSize = strlen(seq);\\n    int idx = 0;\\n    int* ans = (int*) calloc((*returnSize), sizeof(int));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        ans[idx] = (seq[i] ^ idx) & 1;\\n\\t\\tidx++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2109577,
                "title": "c-using-two-variables-very-easy",
                "content": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n            \\n        vector<int> ans;\\n        int a = 0;\\n        int b = 0;\\n        \\n        for(auto c: seq){\\n            if(c == \\'(\\'){\\n                if(a <= b){\\n                    a++;\\n                    ans.push_back(0);\\n                } else {\\n                    b++;\\n                    ans.push_back(1);\\n                }\\n            } else {\\n                if(a >= b){\\n                    a--;\\n                    ans.push_back(0);\\n                } else {\\n                    b--;\\n                    ans.push_back(1);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n            \\n        vector<int> ans;\\n        int a = 0;\\n        int b = 0;\\n        \\n        for(auto c: seq){\\n            if(c == \\'(\\'){\\n                if(a <= b){\\n                    a++;\\n                    ans.push_back(0);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2016574,
                "title": "c-solution-for-this-very-interesting-medium-level-puzzle",
                "content": "To solve this problem, one must realize that A and B shall only pick parentheses at certain levels. \\n\\nFor instance:\\n```\\n(())()((()))\\n122111123321\\n```\\n\\nYou can set all the parentheses at odd-numbered levels for partition A and the remaining ones for B. (It\\'s up to you). The maximum depth is minimal.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int lvl;\\n    stack<int> S;\\n    \\n    vector<int> maxDepthAfterSplit(string seq) {        \\n        lvl = 0;\\n        int len = seq.length();\\n        vector<int> res = vector<int>(len, -1);\\n        int st = 0;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (seq[i] == \\'(\\') {\\n                S.push(i);\\n                lvl++;\\n            }\\n            else if (seq[i] == \\')\\') {\\n                int st = S.top(); S.pop();\\n                int mk = 0;\\n                if ((lvl & 1) == 0) mk = 1;\\n                res[st] = mk;\\n                res[i] = mk;\\n                lvl--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n(())()((()))\\n122111123321\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int lvl;\\n    stack<int> S;\\n    \\n    vector<int> maxDepthAfterSplit(string seq) {        \\n        lvl = 0;\\n        int len = seq.length();\\n        vector<int> res = vector<int>(len, -1);\\n        int st = 0;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (seq[i] == \\'(\\') {\\n                S.push(i);\\n                lvl++;\\n            }\\n            else if (seq[i] == \\')\\') {\\n                int st = S.top(); S.pop();\\n                int mk = 0;\\n                if ((lvl & 1) == 0) mk = 1;\\n                res[st] = mk;\\n                res[i] = mk;\\n                lvl--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010764,
                "title": "golang",
                "content": "```\\nfunc maxDepthAfterSplit(seq string) []int {\\n    deep :=0\\n    res := make([]int,len(seq))\\n    for i,c := range []byte(seq) {\\n        if c == \\'(\\'{\\n            deep++\\n            res[i] = deep%2\\n        }else {\\n            res[i] = deep%2\\n            deep--\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc maxDepthAfterSplit(seq string) []int {\\n    deep :=0\\n    res := make([]int,len(seq))\\n    for i,c := range []byte(seq) {\\n        if c == \\'(\\'{\\n            deep++\\n            res[i] = deep%2\\n        }else {\\n            res[i] = deep%2\\n            deep--\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982903,
                "title": "easy-c-solution-runtime-faster-than-80-43-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n=seq.length();\\n        vector<int> ans(n);\\n\\t\\t\\n        int cur = 0;\\n        int max_depth = 0;\\n        for(int i=0;i<n;i++){\\n            if(seq[i]==\\'(\\'){\\n                ans[i] = ++cur;\\n                max_depth = max(max_depth,cur);\\n            }\\n            else\\n                ans[i] = cur--;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(ans[i]<=max_depth/2)\\n                ans[i] = 0;\\n            else\\n                ans[i] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n=seq.length();\\n        vector<int> ans(n);\\n\\t\\t\\n        int cur = 0;\\n        int max_depth = 0;\\n        for(int i=0;i<n;i++){\\n            if(seq[i]==\\'(\\'){\\n                ans[i] = ++cur;\\n                max_depth = max(max_depth,cur);\\n            }\\n            else\\n                ans[i] = cur--;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(ans[i]<=max_depth/2)\\n                ans[i] = 0;\\n            else\\n                ans[i] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960254,
                "title": "c-o-n-time-and-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int i = 0, n = s.length();\\n        vector<int> ans(n,0);\\n        \\n        while(i < n) {\\n            int cnt = 1, depth = 1, j = i+1;\\n            while(j < n and cnt) {\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                \\n                depth = max(depth,cnt);\\n                j++;\\n            }\\n        \\n            cnt = 0;\\n            for(int k = i; k < j; k++) {\\n                if(s[k] == \\'(\\') {\\n                    cnt++;\\n                    if(cnt > depth/2) ans[k] = 1;\\n                }\\n                else {\\n                    if(cnt > depth/2) ans[k] = 1;\\n                    cnt--;\\n                }\\n            }\\n            \\n            i = j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int i = 0, n = s.length();\\n        vector<int> ans(n,0);\\n        \\n        while(i < n) {\\n            int cnt = 1, depth = 1, j = i+1;\\n            while(j < n and cnt) {\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                \\n                depth = max(depth,cnt);\\n                j++;\\n            }\\n        \\n            cnt = 0;\\n            for(int k = i; k < j; k++) {\\n                if(s[k] == \\'(\\') {\\n                    cnt++;\\n                    if(cnt > depth/2) ans[k] = 1;\\n                }\\n                else {\\n                    if(cnt > depth/2) ans[k] = 1;\\n                    cnt--;\\n                }\\n            }\\n            \\n            i = j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952350,
                "title": "working-solution-java",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] output = new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++) {\\n            output[i] = (seq.charAt(i) == \\'(\\') ?\\n                            (i&1) : \\n                            ((1 - i) & 1);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] output = new int[seq.length()];\\n        for(int i=0; i<seq.length(); i++) {\\n            output[i] = (seq.charAt(i) == \\'(\\') ?\\n                            (i&1) : \\n                            ((1 - i) & 1);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890224,
                "title": "python3-99-7-runtime-91-6-space",
                "content": "We only care about minimizing `max(depth_A, depth_B)`. The best way to do this is to place all the chars at even depth into split `A`, and all the chars at odd depth into split `B`. This means that split `A` will have depth `floor(max_depth / 2)`, and split `B` will have depth `ceil(max_depth / 2)`.\\n\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        depth = 0\\n        ans = list()\\n        for c in seq:\\n            if c == \"(\":\\n                ans.append(depth % 2)\\n                depth += 1\\n            else:\\n                depth -= 1\\n                ans.append(depth % 2)\\n        return ans\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        depth = 0\\n        ans = list()\\n        for c in seq:\\n            if c == \"(\":\\n                ans.append(depth % 2)\\n                depth += 1\\n            else:\\n                depth -= 1\\n                ans.append(depth % 2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878940,
                "title": "c-parity-by-depth",
                "content": "```\\npublic class Solution {\\n    public int[] MaxDepthAfterSplit(string s) {\\n        Stack<int> st = new Stack<int>();\\n        int n = s.Length;\\n        int[] depth = new int[n];\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\') {\\n                st.Push(i);\\n            } else {\\n                depth[i] = depth[st.Pop()] = st.Count;\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < n; ++i) {\\n            max = Math.Max(max, depth[i]);\\n        }\\n        if (max == 0) {\\n            ans[0] = ans[1] = 0;\\n            for (int i = 2; i < n; ++i) ans[i] = 1;\\n        } else {\\n            for (int i = 0; i < n; ++i) {\\n                if (depth[i] % 2 == 0) {\\n                    ans[i] = 0;\\n                } else {\\n                    ans[i] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] MaxDepthAfterSplit(string s) {\\n        Stack<int> st = new Stack<int>();\\n        int n = s.Length;\\n        int[] depth = new int[n];\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'(\\') {\\n                st.Push(i);\\n            } else {\\n                depth[i] = depth[st.Pop()] = st.Count;\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < n; ++i) {\\n            max = Math.Max(max, depth[i]);\\n        }\\n        if (max == 0) {\\n            ans[0] = ans[1] = 0;\\n            for (int i = 2; i < n; ++i) ans[i] = 1;\\n        } else {\\n            for (int i = 0; i < n; ++i) {\\n                if (depth[i] % 2 == 0) {\\n                    ans[i] = 0;\\n                } else {\\n                    ans[i] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841684,
                "title": "c-alternative-splitting-by-depth-o-n",
                "content": "How you split the string does\\'nt matter but the relative ordering of indices of slipted string matters, that is, relative ordering of elements of string in both the splitted string should not change.\\nSplitting can be done by **alternative splitting by** **depth** in the following way:\\n1. find the depth of each VPS in the string\\n1. if the depth is even, split it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        vector<int> nums(n,0); int depth = 0,i=0;\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){\\n                st.push(i); depth++; \\n                if(depth%2==0) nums[i] = 1;\\n            }\\n            else{\\n                nums[i] = nums[st.top()]; depth--; st.pop();\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        vector<int> nums(n,0); int depth = 0,i=0;\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){\\n                st.push(i); depth++; \\n                if(depth%2==0) nums[i] = 1;\\n            }\\n            else{\\n                nums[i] = nums[st.top()]; depth--; st.pop();\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793665,
                "title": "c-0ms-100-space-o1-explained",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\nMemory Usage: 7.4 MB, less than 43.69% of C++ online submissions for Maximum Nesting Depth of Two Valid Parentheses Strings.\\n\\n**General idea :**\\n1. Do traversal from leftmost to rightmost and find maximal depth for each brace\\n2. Devide our maximal depth on 2. \\n3. Do traversal from leftmost to rightmost and check : have our current depth value greater than maximal depth or not for each brace. if have answer = 1, if not answer = 0 .\\n\\n```\\nclass Solution {\\npublic:\\n  vector<int> maxDepthAfterSplit(string seq) {\\n    int max_depth = 0, cur_depth = 0;    \\n    \\n    for(auto ch: seq)\\n      if(ch == \\'(\\') cur_depth++;\\n      else max_depth = max<int>(max_depth, cur_depth--);\\n       \\n    max_depth >>= 1, cur_depth = 0;\\n    vector<int>ans(seq.size(), 0);\\n    for(int i = 0; i != seq.size(); i++)\\n      if(seq[i] == \\'(\\') {if(++cur_depth > max_depth) ans[i] = 1;}\\n      else if(cur_depth-- > max_depth) ans[i] = 1;\\n      \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> maxDepthAfterSplit(string seq) {\\n    int max_depth = 0, cur_depth = 0;    \\n    \\n    for(auto ch: seq)\\n      if(ch == \\'(\\') cur_depth++;\\n      else max_depth = max<int>(max_depth, cur_depth--);\\n       \\n    max_depth >>= 1, cur_depth = 0;\\n    vector<int>ans(seq.size(), 0);\\n    for(int i = 0; i != seq.size(); i++)\\n      if(seq[i] == \\'(\\') {if(++cur_depth > max_depth) ans[i] = 1;}\\n      else if(cur_depth-- > max_depth) ans[i] = 1;\\n      \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785117,
                "title": "beginner-friendly-javascript-solution",
                "content": "Time Complexity : O(n)\\n```\\n/**\\n * @param {string} seq\\n * @return {number[]}\\n */\\nvar maxDepthAfterSplit = function(seq) {\\n    let arr = []\\n    for(let i=0; i<seq.length; i++){\\n        arr.push(seq[i] == \"(\" ? i & 1 : 1-i & 1)\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} seq\\n * @return {number[]}\\n */\\nvar maxDepthAfterSplit = function(seq) {\\n    let arr = []\\n    for(let i=0; i<seq.length; i++){\\n        arr.push(seq[i] == \"(\" ? i & 1 : 1-i & 1)\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760836,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) \\n    {\\n        vector<int> ans;\\n        int depth=0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                depth++;\\n                ans.push_back(depth%2);\\n            }\\n            else\\n            {\\n                ans.push_back(depth%2);\\n                depth--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) \\n    {\\n        vector<int> ans;\\n        int depth=0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                depth++;\\n                ans.push_back(depth%2);\\n            }\\n            else\\n            {\\n                ans.push_back(depth%2);\\n                depth--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663111,
                "title": "javascript-nothing-fancy-but-still-runs-in-o-n-time-and-o-1-space",
                "content": "The idea is to have the max depth of each subgroup near the 1/2 of the original seq.  So I :\\n1. get max depth of seq and determine that the new max depth for each group must be newMaxDepth=Math.round(maxDepth/2) for one group, the other group will have max depth of maxDepth-newMaxDepth\\n2. traverse from left to right, use greedy approach to collect up to (including) dep into group A if currentDepth<newMaxDepth\\n```\\nvar maxDepthAfterSplit = function(seq) {\\n    let r=new Array(seq.length).fill(1);\\n    let mdep=0, cdep=0;\\n    for (let c of seq) \\n        if (c===\\'(\\') mdep=Math.max(++cdep,mdep);\\n        else --cdep;\\n    let dep=Math.round(mdep/2);\\n    //find VPS string A, marked with 0\\n    cdep=0;\\n    for (let i=0; i<seq.length; ++i) {\\n        if (seq[i]===\\'(\\') {\\n           if (cdep<dep) {\\n              r[i]=0; \\n              ++cdep;\\n           }\\n        }\\n        else {\\n            if (cdep<=dep && cdep>0) {\\n                r[i]=0;\\n                --cdep;\\n            }\\n        }\\n    }\\n    return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxDepthAfterSplit = function(seq) {\\n    let r=new Array(seq.length).fill(1);\\n    let mdep=0, cdep=0;\\n    for (let c of seq) \\n        if (c===\\'(\\') mdep=Math.max(++cdep,mdep);\\n        else --cdep;\\n    let dep=Math.round(mdep/2);\\n    //find VPS string A, marked with 0\\n    cdep=0;\\n    for (let i=0; i<seq.length; ++i) {\\n        if (seq[i]===\\'(\\') {\\n           if (cdep<dep) {\\n              r[i]=0; \\n              ++cdep;\\n           }\\n        }\\n        else {\\n            if (cdep<=dep && cdep>0) {\\n                r[i]=0;\\n                --cdep;\\n            }\\n        }\\n    }\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658656,
                "title": "python3-6-lines-o-n",
                "content": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res,depth=[],0\\n        for el in seq:\\n            if el==\\'(\\': depth+=1\\n            res.append(depth%2)\\n            if el==\\')\\': depth-=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        res,depth=[],0\\n        for el in seq:\\n            if el==\\'(\\': depth+=1\\n            res.append(depth%2)\\n            if el==\\')\\': depth-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621825,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] r = new int[seq.length()];\\n        int md = 0;\\n        int cd = 0;\\n        for (int i=0;i<seq.length();i++) {\\n            if (seq.charAt(i) == \\'(\\') cd++;\\n            if (seq.charAt(i) == \\')\\') cd--;\\n            if (cd>md) md = cd;\\n        }\\n        int hd = md/2;\\n        cd = 0;\\n        for (int i=0;i<seq.length();i++) {\\n            if (seq.charAt(i) == \\'(\\') cd++;\\n            if (cd>hd) r[i] = 1;\\n            if (seq.charAt(i) == \\')\\') cd--;\\n        }\\n        \\n        return r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int[] r = new int[seq.length()];\\n        int md = 0;\\n        int cd = 0;\\n        for (int i=0;i<seq.length();i++) {\\n            if (seq.charAt(i) == \\'(\\') cd++;\\n            if (seq.charAt(i) == \\')\\') cd--;\\n            if (cd>md) md = cd;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1517903,
                "title": "java-solution-with-explanation-bitwise-operator",
                "content": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length();\\n        int[] result = new int[n];\\n        for(int i =0 ; i < n; i++){\\n            //& is a bitwise operator which gives 0 or 1 if even or odd respectively.\\n            //1-i&1 : this basically does inverse of above\\n            result[i] = seq.charAt(i) == \\'(\\' ? i & 1 : 1 - i & 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maxDepthAfterSplit(String seq) {\\n        int n = seq.length();\\n        int[] result = new int[n];\\n        for(int i =0 ; i < n; i++){\\n            //& is a bitwise operator which gives 0 or 1 if even or odd respectively.\\n            //1-i&1 : this basically does inverse of above\\n            result[i] = seq.charAt(i) == \\'(\\' ? i & 1 : 1 - i & 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500796,
                "title": "simple-linear-traversal",
                "content": "We want to make subsequence such that we can break the original string into subseq A and B both of them finally to be of the form \"()()()()\" as a result the max depth will always be equal to min equal to 1 \\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int i,n=s.length();\\n        vector<int> ans(n,0);\\n        for(i=1;i<n;i++){\\n            if(s[i]==s[i-1])\\n                ans[i]=1-ans[i-1];\\n            else\\n                ans[i]=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int i,n=s.length();\\n        vector<int> ans(n,0);\\n        for(i=1;i<n;i++){\\n            if(s[i]==s[i-1])\\n                ans[i]=1-ans[i-1];\\n            else\\n                ans[i]=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420857,
                "title": "python-greedy-beats-100",
                "content": "```\\n\\n```class Solution(object):\\n    def maxDepthAfterSplit(self, seq):\\n        A_depth = 0\\n        B_depth = 0\\n        sol = []\\n        last_open = []\\n        last_closed = 0\\n        for i in range(len(seq)):\\n            if seq[i] == \\'(\\':\\n                if A_depth <= B_depth:\\n                    sol.append(0)\\n                    A_depth += 1\\n                else:\\n                    sol.append(1)\\n                    B_depth += 1\\n                last_open.append(i)\\n            else:\\n                x = sol[last_open.pop()]\\n                sol.append(x)\\n                if x == 0:\\n                    A_depth -= 1\\n                else:\\n                    B_depth -= 1\\n        return sol",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1414307,
                "title": "beats-100-5-liner-easy-code-depth-of-parenthesis",
                "content": "We always want to split the nested parentesis into alternatively, i.e. \\n1st goes to A, 2nd goes to B, 3rd goes to A, $th goes to B and so on, to minimize the overall depth\\n```\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;int d=0;\\n        for(auto e:seq)\\n            if(e==\\'(\\')ans.push_back(1&d++);\\n            else ans.push_back(--d&1);\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "We always want to split the nested parentesis into alternatively, i.e. \\n1st goes to A, 2nd goes to B, 3rd goes to A, $th goes to B and so on, to minimize the overall depth\\n```\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;int d=0;\\n        for(auto e:seq)\\n            if(e==\\'(\\')ans.push_back(1&d++);\\n            else ans.push_back(--d&1);\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1384132,
                "title": "python-one-pass-value-switching-method-o-n",
                "content": "The idea is simple, as deeper you go in a parenthesis, you keep switching value (0 -> 1, 1-> 0). This ensures that the max depth between group0 and group1 keeps minimum.\\n```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def switch(n):\\n            if n == 0:\\n                return 1\\n            else:\\n                return 0\\n        val = 0\\n        q = []\\n        dicc = {}\\n        ans = []\\n        q.append(seq[0])\\n        dicc[0] = val\\n        for s in range(1, len(seq)):\\n            if seq[s] == \\')\\':\\n                dicc[s] = val\\n                q.pop()\\n                if q:\\n                    val = switch (val)\\n            else:\\n                if q:\\n                    val = switch(val)\\n                dicc[s] = val\\n                q.append(seq[s])\\n        for i in dicc.keys():\\n            ans.append(dicc[i])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def switch(n):\\n            if n == 0:\\n                return 1\\n            else:\\n                return 0\\n        val = 0\\n        q = []\\n        dicc = {}\\n        ans = []\\n        q.append(seq[0])\\n        dicc[0] = val\\n        for s in range(1, len(seq)):\\n            if seq[s] == \\')\\':\\n                dicc[s] = val\\n                q.pop()\\n                if q:\\n                    val = switch (val)\\n            else:\\n                if q:\\n                    val = switch(val)\\n                dicc[s] = val\\n                q.append(seq[s])\\n        for i in dicc.keys():\\n            ans.append(dicc[i])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1281783,
                "title": "c-very-easy-to-understand-solution-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size(), maxdepth = 0, d = 0;\\n        vector<int> arr(n);\\n        for(int i=0; i<n; i++){\\n            if(seq[i] == \\'(\\'){\\n                d++;          \\n                arr[i] = d;\\n            }                \\n            else{\\n                arr[i] = d;\\n                d--;                \\n            }                \\n            \\n            if(maxdepth < d){\\n                maxdepth = d;\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(2*arr[i] <= maxdepth)\\n                arr[i] = 0;\\n            else\\n                arr[i] = 1;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        int n = seq.size(), maxdepth = 0, d = 0;\\n        vector<int> arr(n);\\n        for(int i=0; i<n; i++){\\n            if(seq[i] == \\'(\\'){\\n                d++;          \\n                arr[i] = d;\\n            }                \\n            else{\\n                arr[i] = d;\\n                d--;                \\n            }                \\n            \\n            if(maxdepth < d){\\n                maxdepth = d;\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(2*arr[i] <= maxdepth)\\n                arr[i] = 0;\\n            else\\n                arr[i] = 1;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280652,
                "title": "need-help-the-output-i-m-generating-is-wrong-why",
                "content": "Wrong Answer\\nRuntime: 0 ms\\nYour input\\n\"(()())\"\\nOutput\\n[1,0,1,0,0,0]\\nExpected\\n[0,1,1,1,1,0]",
                "solutionTags": [],
                "code": "Wrong Answer\\nRuntime: 0 ms\\nYour input\\n\"(()())\"\\nOutput\\n[1,0,1,0,0,0]\\nExpected\\n[0,1,1,1,1,0]",
                "codeTag": "Unknown"
            },
            {
                "id": 1272383,
                "title": "python-stack-solution",
                "content": "1) Allocate all string to A by marking all elements in result[ ] as 0  \\n2) First Calculate Depths of all independent VPS(valid paranthesis string)\\n3) For paranthesis that is in deep below depth//2 mark 1\\n```\\nclass Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def calculateDepth(index):\\n            stack = [seq[index]]\\n            depth = 1\\n            index+=1\\n            while stack:\\n                if seq[index]==\"(\":\\n                    stack.append(\"(\")\\n                    depth = max(depth,len(stack))\\n                else:\\n                    stack.pop()\\n                index+=1\\n            return [depth,index]\\n        \\n        def colourize(depth,index,result):\\n            stack = [seq[index]]\\n            index+=1\\n            while stack:        \\n                if seq[index]==\"(\":\\n                    stack.append(\"(\")\\n                else:\\n                    if len(stack)>depth//2 and result[index-1]:\\n                        result[index]=1\\n                    stack.pop()\\n                    index+=1\\n                    continue\\n                    \\n                if len(stack)>depth//2:\\n                    result[index]=1\\n                index+=1\\n                \\n            return index\\n        \\n        starts = {}\\n        result = [0 for i in range(len(seq))]\\n        index = 0\\n        \\n        \\n        while index<len(seq):\\n            depth,i= calculateDepth(index)\\n            starts[index] = depth\\n            index = i\\n        \\n        index = 0\\n        while index<len(seq):\\n            index = colourize(starts[index],index,result)\\n        \\n        return result",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def maxDepthAfterSplit(self, seq: str) -> List[int]:\\n        def calculateDepth(index):\\n            stack = [seq[index]]\\n            depth = 1\\n            index+=1\\n            while stack:\\n                if seq[index]==\"(\":\\n                    stack.append(\"(\")\\n                    depth = max(depth,len(stack))\\n                else:\\n                    stack.pop()\\n                index+=1\\n            return [depth,index]\\n        \\n        def colourize(depth,index,result):\\n            stack = [seq[index]]\\n            index+=1\\n            while stack:        \\n                if seq[index]==\"(\":\\n                    stack.append(\"(\")\\n                else:\\n                    if len(stack)>depth//2 and result[index-1]:\\n                        result[index]=1\\n                    stack.pop()\\n                    index+=1\\n                    continue\\n                    \\n                if len(stack)>depth//2:\\n                    result[index]=1\\n                index+=1\\n                \\n            return index\\n        \\n        starts = {}",
                "codeTag": "Java"
            },
            {
                "id": 1269991,
                "title": "c-solution-simple-observation",
                "content": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int num=1;\\n        for(int i=0;i<seq.length();i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n                num=1-num;\\n                ans.push_back(num);\\n            }\\n            else\\n            {\\n                ans.push_back(num);\\n                num=1-num;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans;\\n        int num=1;\\n        for(int i=0;i<seq.length();i++)\\n        {\\n            if(seq[i]==\\'(\\')\\n            {\\n                num=1-num;\\n                ans.push_back(num);\\n            }\\n            else\\n            {\\n                ans.push_back(num);\\n                num=1-num;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266469,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int n=s.size();\\n        \\n        vector<int> result(n);\\n        vector<int> open;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                int temp =  open.size();\\n                if(temp==0)\\n                {\\n                    open.push_back(0);\\n                    result[i]=0;\\n                }\\n                else\\n                {\\n                        if(open[temp-1]==0)\\n                        {\\n                            open.push_back(1);\\n                            result[i] = 1;\\n                        }\\n                        else\\n                        {\\n                            open.push_back(0);\\n                            result[i]=0;\\n                        }\\n                }    \\n            }\\n            else\\n            {\\n                int temp=open.size();\\n                result[i]=open[temp-1];\\n                open.pop_back();\\n            }\\n        }\\n    return result;\\n    }   \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string s) {\\n        int n=s.size();\\n        \\n        vector<int> result(n);\\n        vector<int> open;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                int temp =  open.size();\\n                if(temp==0)\\n                {\\n                    open.push_back(0);\\n                    result[i]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1266375,
                "title": "concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(const string& seq) {\\n        vector<int> result;\\n        int depth = 0;\\n        for(int i = 0; i < seq.size(); ++i) {\\n            if(seq[i] == \\'(\\') {\\n                result.push_back(depth % 2);\\n                ++depth;\\n            } else if(seq[i] == \\')\\') {\\n                --depth;\\n                result.push_back(depth % 2);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(const string& seq) {\\n        vector<int> result;\\n        int depth = 0;\\n        for(int i = 0; i < seq.size(); ++i) {\\n            if(seq[i] == \\'(\\') {\\n                result.push_back(depth % 2);\\n                ++depth;\\n            } else if(seq[i] == \\')\\') {\\n                --depth;\\n                result.push_back(depth % 2);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255230,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.length());\\n        int first = 0, second = 0;\\n        \\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq[i] == \\'(\\'){\\n                if(i == 0 || first <= second){\\n                    ans[i] = 0;\\n                    first++;\\n                }\\n                else{\\n                    ans[i] = 1;\\n                    second++;\\n                }\\n            }\\n            else{\\n                if(second > first){\\n                    ans[i] = 1;\\n                    second--;\\n                }\\n                else{\\n                    ans[i] = 0;\\n                    first--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.length());\\n        int first = 0, second = 0;\\n        \\n        for(int i = 0; i < seq.length(); i++){\\n            if(seq[i] == \\'(\\'){\\n                if(i == 0 || first <= second){\\n                    ans[i] = 0;\\n                    first++;\\n                }\\n                else{\\n                    ans[i] = 1;\\n                    second++;\\n                }\\n            }\\n            else{\\n                if(second > first){\\n                    ans[i] = 1;\\n                    second--;\\n                }\\n                else{\\n                    ans[i] = 0;\\n                    first--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246468,
                "title": "c-solution-100-beats-time",
                "content": "Simple Greedy Solution :\\n\\nWe have two buckets named **bucket-0** and **bucket-1**\\n\\nDecisions :\\n1) if current bracket is opening bracket, then put it into the bucket which has **less opening brackets**\\n2) if current bracket is closing bracket, then put it into the bucket which has **more opening brackets** (since we are equally assigning the opening brackets to the both buckets, difference between the number of opening brakcets of in two buckets is less than or eqaul to 1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.size());\\n        int open_0 = 0, open_1 = 0;\\n        for(int i=0; i<seq.size(); i++){\\n            if(seq[i] == \\'(\\'){\\n                if(open_0 <= open_1)\\n                    ans[i] = 0, open_0++;\\n                else\\n                    ans[i] = 1, open_1++;\\n            }\\n            else{\\n                if(open_1 >= open_0)\\n                    ans[i] = 1, open_1--;\\n                else\\n                    ans[i] = 0, open_0--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> ans(seq.size());\\n        int open_0 = 0, open_1 = 0;\\n        for(int i=0; i<seq.size(); i++){\\n            if(seq[i] == \\'(\\'){\\n                if(open_0 <= open_1)\\n                    ans[i] = 0, open_0++;\\n                else\\n                    ans[i] = 1, open_1++;\\n            }\\n            else{\\n                if(open_1 >= open_0)\\n                    ans[i] = 1, open_1--;\\n                else\\n                    ans[i] = 0, open_0--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238137,
                "title": "c-greedy-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>ans(seq.length(),-1);\\n        ans[0] = 0;\\n        for(int i=1;i<seq.size();i++)\\n        {\\n            if(seq[i-1]==\\'(\\' && seq[i]==\\')\\'||seq[i-1]==\\')\\' && seq[i]==\\'(\\')\\n                ans[i] = ans[i-1];\\n            else if(seq[i-1]==seq[i])\\n                ans[i] = !ans[i-1];\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int>ans(seq.length(),-1);\\n        ans[0] = 0;\\n        for(int i=1;i<seq.size();i++)\\n        {\\n            if(seq[i-1]==\\'(\\' && seq[i]==\\')\\'||seq[i-1]==\\')\\' && seq[i]==\\'(\\')\\n                ans[i] = ans[i-1];\\n            else if(seq[i-1]==seq[i])\\n                ans[i] = !ans[i-1];\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229916,
                "title": "simple-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> v;\\n        stack<int> st;\\n        v.push_back(0);\\n        st.push(0);\\n        for(int i = 1; i<seq.length(); i++)\\n        {\\n            if(seq[i] == \\'(\\')\\n            {\\n                if(st.empty() || st.top() == 1)\\n                {\\n                    st.push(0);\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    st.push(1);\\n                    v.push_back(1);\\n                }\\n            }\\n            else\\n            {\\n                v.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\nTIme - O(n)\\nSpace - O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxDepthAfterSplit(string seq) {\\n        vector<int> v;\\n        stack<int> st;\\n        v.push_back(0);\\n        st.push(0);\\n        for(int i = 1; i<seq.length(); i++)\\n        {\\n            if(seq[i] == \\'(\\')\\n            {\\n                if(st.empty() || st.top() == 1)\\n                {\\n                    st.push(0);\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    st.push(1);\\n                    v.push_back(1);\\n                }\\n            }\\n            else\\n            {\\n                v.push_back(st.top());\\n                st.pop();\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565708,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565869,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565330,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565871,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1568375,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566359,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566868,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566567,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1568176,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1567608,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565708,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565869,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565330,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1565871,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1568375,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566359,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566868,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1566567,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1568176,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            },
            {
                "id": 1567608,
                "content": [
                    {
                        "username": "Jdg1125",
                        "content": "Please reword the question prompt. It\\'s highly unclear. The word concatenation doesn\\'t precisely describe the interleaving relationship between sequences A and B. Overall, there is simply a much better way of phrasing the question. Thanks!"
                    },
                    {
                        "username": "ping_pong",
                        "content": "I couldn\\'t undestand the sample test cases can anyone explain how the given output have come for the given examples.\\n\\nExample 1:\\nInput: seq = \"(()())\"\\nOutput: [0,1,1,1,1,0]\\n\\nExample 2:\\nInput: seq = \"()(())()\"\\nOutput: [0,0,0,1,1,0,1,1]"
                    },
                    {
                        "username": "werewolf97",
                        "content": "Is there any binary search solution which gives answer in less than O(n) ?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@werewolf97](/werewolf97) It's not possible to solve it under O(N) because you have to at least read each character once. You can solve it using binary search but it will take O(N log(N)) time. Here's my binary search [solution](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)."
                    },
                    {
                        "username": "FeiD",
                        "content": "Actually there is only one thing needs to expalin in the quesiton description:\\n\\'\\'\\'Given a VPS seq, split it into two disjoint subsequences A and B\\'\\'\\'\\nHere,\\'two disjoint subsequences\\' not only means ()(())()=>() || (())() or ()(()) || (), it can also be A:()#()###  and B:##(##)(), as example 2 said.\\nI think disjoint just means A and B should not contain same element in seq.\\nEasy to solve + hard to understand = median question\\nUpvote me to help others."
                    },
                    {
                        "username": "happy_little_pig",
                        "content": "**Spent one hour undersdaning the crapy description.  And another hour trying to solve the problem, only to find this is a problem not worth doing.  A waste of two hours in my life.  No wonder so much dislikes and so little likes.......  There is a reason for that!**"
                    },
                    {
                        "username": "harryyu1994",
                        "content": "Here are some of my thought process when I first encountered this question:\\n\\nWhenever I see a string related question, the first thing that I do is to determine whether the question asks for a substring or subsequence. In this case it asks for two subsequences. \\n\\nThen I think about how I would solve the examples on a piece of paper.\\nFor subsequences, we can tear apart the original string char by char.\\nFor each char, we can either put it into bucket A or bucket B.\\n\\nNow it comes down to this decision, why bucket A over bucket B for a given char?\\nIf bucket A\\'s depth <= bucket B\\'s depth, we would obviously prefer bucket A so that the max depth doesnt change.\\n\\nAnd then you start realizing there is a greedy solution to this!\\n\\nI used two stacks for the two buckets (A and B) first. Push to stack when \\'(\\', pop off when \\')\\'\\nThen I optimized out the stacks with two single variables to keep track of the depth.\\n\\n\\n\\n"
                    },
                    {
                        "username": "shine123glow",
                        "content": "please help me to understand the question."
                    },
                    {
                        "username": "xinghua_lin",
                        "content": "Can someone provide an idea or code for how to solve this question using Binary Search?"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@xinghua_lin](/xinghua_lin) You can check out my post with explanation [here](https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/2971954/python-binary-search-solution-on-logn/)"
                    },
                    {
                        "username": "coolgal",
                        "content": "I am not understanding what problem is asking for. Can some body please explain it. \\n\\nI saw this solution -\\nhttps://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/discuss/328841/JavaC%2B%2BPython-O(1)-Extra-Space-Except-Output\\n\\nSince I am not understand problem statement , cant understand the solution."
                    },
                    {
                        "username": "_Evankhell_",
                        "content": "I cant seem to understand what the question is and what it wants me to do,maybe because its weird languague,can someone please simplify the question and tell me in a simple way what to do?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Split a String Into the Max Number of Unique Substrings",
        "question_content": "<p>Given a string&nbsp;<code>s</code><var>,</var>&nbsp;return <em>the maximum&nbsp;number of unique substrings that the given string can be split into</em>.</p>\n\n<p>You can split string&nbsp;<code>s</code> into any list of&nbsp;<strong>non-empty substrings</strong>, where the concatenation of the substrings forms the original string.&nbsp;However, you must split the substrings such that all of them are <strong>unique</strong>.</p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters within a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ababccc&quot;\n<strong>Output:</strong> 5\n<strong>Explanation</strong>: One way to split maximally is [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;]. Splitting like [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;cc&#39;] is not valid as you have &#39;a&#39; and &#39;b&#39; multiple times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> 2\n<strong>Explanation</strong>: One way to split maximally is [&#39;a&#39;, &#39;ba&#39;].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;\n<strong>Output:</strong> 1\n<strong>Explanation</strong>: It is impossible to split the string any further.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 16</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> contains&nbsp;only lower case English letters.</p>\n\t</li>\n</ul>\n",
        "solutions": [
            {
                "id": 855073,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet<>();\\n        return dfs(set, 0, s);\\n    }\\n    \\n    private int dfs(Set<String> set, int idx, String s) {\\n        if (idx >= s.length()) return 0;\\n        int res = -1;  // did not find method to split;\\n        for (int i = idx + 1; i <= s.length(); i++) {\\n            String sub = s.substring(idx, i);\\n            if (!set.add(sub)) continue; //already contains sub\\n            int next = dfs(set, i, s);\\n            if (next >= 0) res = Math.max(res, next + 1);\\n            set.remove(sub);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nupdate 12/03, 2020:\\nuse @agarwalaarrav\\'s suggestion for ln:\\n```\\nif (!set.add(sub)) continue; //already contains sub\\n```\\nupdare 01/17, thanks to @feresini\\'s reference:\\nMedium article with code, analysis, and step-by-step solution explanation: https://federico-feresini.medium.com/split-a-string-into-the-max-number-of-unique-substrings-algorithms-visualizations-6116561b7fc6\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet<>();\\n        return dfs(set, 0, s);\\n    }\\n    \\n    private int dfs(Set<String> set, int idx, String s) {\\n        if (idx >= s.length()) return 0;\\n        int res = -1;  // did not find method to split;\\n        for (int i = idx + 1; i <= s.length(); i++) {\\n            String sub = s.substring(idx, i);\\n            if (!set.add(sub)) continue; //already contains sub\\n            int next = dfs(set, i, s);\\n            if (next >= 0) res = Math.max(res, next + 1);\\n            set.remove(sub);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nif (!set.add(sub)) continue; //already contains sub\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855153,
                "title": "c-brute-force",
                "content": "This one puzzled me quite a bit. It sounded too hard for the second problem in the contest.\\n\\nThen I looked at the constraints, and realized that a simple DFS without memoisation would do.\\n\\n```cpp\\nunordered_set<string> st;\\nint maxUniqueSplit(string &s, int p = 0) {\\n    if (p == s.size())\\n        return 0;\\n    int res = -1;\\n    for (int sz = 1; p + sz <= s.size(); ++sz) {\\n        auto it = st.insert(s.substr(p, sz));\\n        if (it.second) {\\n            int n_res = maxUniqueSplit(s, p + sz);\\n            if (n_res != -1)\\n                res = max(res, 1 + n_res);\\n            st.erase(it.first);\\n        }    \\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nunordered_set<string> st;\\nint maxUniqueSplit(string &s, int p = 0) {\\n    if (p == s.size())\\n        return 0;\\n    int res = -1;\\n    for (int sz = 1; p + sz <= s.size(); ++sz) {\\n        auto it = st.insert(s.substr(p, sz));\\n        if (it.second) {\\n            int n_res = maxUniqueSplit(s, p + sz);\\n            if (n_res != -1)\\n                res = max(res, 1 + n_res);\\n            st.erase(it.first);\\n        }    \\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855077,
                "title": "python3-backtracking",
                "content": "```python\\ndef maxUniqueSplit(self, s: str) -> int:\\n\\tseen = set()\\n\\treturn self.helper(s, seen)\\n\\ndef helper(self, s, seen):\\n\\tans = 0\\n\\tif s:\\n\\t\\tfor i in range(1, len(s) + 1):\\n\\t\\t\\tcandidate = s[:i]\\n\\t\\t\\tif candidate not in seen:\\n\\t\\t\\t\\tseen.add(candidate)\\n\\t\\t\\t\\tans = max(ans, 1 + self.helper(s[i:], seen))\\n\\t\\t\\t\\tseen.remove(candidate)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxUniqueSplit(self, s: str) -> int:\\n\\tseen = set()\\n\\treturn self.helper(s, seen)\\n\\ndef helper(self, s, seen):\\n\\tans = 0\\n\\tif s:\\n\\t\\tfor i in range(1, len(s) + 1):\\n\\t\\t\\tcandidate = s[:i]\\n\\t\\t\\tif candidate not in seen:\\n\\t\\t\\t\\tseen.add(candidate)\\n\\t\\t\\t\\tans = max(ans, 1 + self.helper(s[i:], seen))\\n\\t\\t\\t\\tseen.remove(candidate)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 855690,
                "title": "c-iterative-100ms-beats-100-with-bit-twiddling",
                "content": "I have not yet seen a well explained bit twiddeling solution so here is mine:\\n\\n1. **How many ways are there to divide the string `S`?**\\n\\tAnswer: Let `N = S.length()`. Let the characters be `a1,a2...,an` . Then there are `N-1` fences between the characters: `a1 | a2 | a3 .. | an`. Well each fence can either exist or not. This means that for each fence there are `2` states. Each fence is unique so there are `2*2*2...*2` number of unique divisions or `2^(N-1)` divisions. So let\\'s say we have `N=3` characters and two fences. Then there are `4 (=2^N-1)` possible divisions: \\n\\t`a1 | a2 | a3 `\\n\\t `a1 | a2 a3`\\n\\t `a1 a2 | a3`\\n\\t `a1 a2 a3`\\n\\t \\n2. **How can we represent the fences efficiently?**\\n\\tAnswer: Since each fence can either exist or not, bits are perfect. If a fence exists then we represent it with a 1 and if not then a 0. Since there are N-1 fences we need a type with at least N-1 bits. The maximum N is 16 so a 32 bit integer should be more than enough.\\n\\t\\n3. **How can we iterate through all possible solutions?**\\n\\tAnswer: Lets examine the problem with 3 letters again but this time let\\'s look at the bit representation of the fences:\\n\\t`11` = 3\\n\\t`10` = 2\\n\\t`01` = 1\\n\\t`00` = 0\\n\\tIterestingly enough these are all the numbers smaller than `2^(N-1)`. So it will be extremely easy to iterate all the possible solutions! Just a simple for loop from `0` to `2^(N-1)`.\\n\\t`for(int fences = 0; fences < pow(2,N-1); ++fences)`\\n\\tBut what does `pow(2,n)` actually represent in binary? For example `pow(2,0) = 1 = 000...001b`, `pow(2,1) = 2 = 000..010b`, `pow(2,2) = 4 = 000...100b`. Notice that it just shifts 1 `n` bits to the left. So `pow(2,N-1) = 1<<N-1`\\n\\t\\n4.  **How do we generate the actual strings?**\\n\\tAnswer: We will use the fences to divide the string! All the characters between two fences (or the begining and the first fence or the last fence and the end) form a single string. With our example `a1 a2 | a3` the strings will be `a1a2` and `a3`.\\n\\n5. **How do we know if the strings are unique?**\\n\\tAnswer: This is easy! Just keep a set of all the strings and check if the current string is already in the set. If so then the strings are obviously not unique and the solution is NOT a valid one.\\n\\t\\n**BONUS:** If you want to optimize your solution even more then we can count the number of set bits and if they are less than the best found solution yet then just skip processing it. Let\\'s say for example the best solution yet is `a1a2a3 | a4 | a5 | a6a7`. The bit representation of this solution would be `001110b`. Now lets say we are processing the solution `010010`. We can skip it because it has only two set bits which will divide the string into 3 and this is worse than the current best!\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int maxUniqueSplit(string s) {\\n        uint32_t maxi = 1;\\n        int32_t N = s.size();\\n        for(uint32_t fences = 0; fences < (1<<N-1); ++fences)\\n        {\\n            if(__builtin_popcount(fences) < maxi)\\n                continue;\\n            \\n            std::unordered_set<std::string> S;\\n            std::string curr{s[0]};\\n            bool unique = true;\\n            for(int32_t bit = 0; bit < N-1; ++bit)\\n            {\\n                if(fences>>bit&1)\\n                {\\n                    if(!S.insert(curr).second)\\n                    {\\n                        unique = false;\\n                        break;\\n                    }\\n                    \\n                    curr.clear();\\n                }\\n                curr.push_back(s[bit+1]);\\n            }\\n            if(!S.insert(curr).second)\\n                continue;\\n            if(unique)\\n                maxi = std::max(maxi,(uint32_t)S.size());\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxUniqueSplit(string s) {\\n        uint32_t maxi = 1;\\n        int32_t N = s.size();\\n        for(uint32_t fences = 0; fences < (1<<N-1); ++fences)\\n        {\\n            if(__builtin_popcount(fences) < maxi)\\n                continue;\\n            \\n            std::unordered_set<std::string> S;\\n            std::string curr{s[0]};\\n            bool unique = true;\\n            for(int32_t bit = 0; bit < N-1; ++bit)\\n            {\\n                if(fences>>bit&1)\\n                {\\n                    if(!S.insert(curr).second)\\n                    {\\n                        unique = false;\\n                        break;\\n                    }\\n                    \\n                    curr.clear();\\n                }\\n                curr.push_back(s[bit+1]);\\n            }\\n            if(!S.insert(curr).second)\\n                continue;\\n            if(unique)\\n                maxi = std::max(maxi,(uint32_t)S.size());\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855065,
                "title": "c-backtracking-using-set-commented-explained",
                "content": "explaination\\nconsider example \"addbsd\"\\nx->0\\n\"a\" is unique add to ss and backtrack from 1\\nx->1\\n\"d\" is unique add to ss and backtrack from 2\\nx->2\\n\"d\" is not unique add next elm that is \"b\"\\n\"db\" is unique add to ss and backtrack from 4\\nx->4\\n\"s\" is unique add to ss and backtrack from 5\\nx->5\\n\"d\" is not unique and is last so go back to x=4;\\n\\nx->4\\n\"sd\" is unique add to ss and backtrack from 6\\n\\nx->6\\nx==n res=max(res,4(size of set)),return;\\n\\nsmilarly we wil get this also->\\na dd b s d\\nres=5\\n\\n```\\n int n;\\n    string s;\\n    int res;\\n     set<string>ss; //to store current partitiond string\\n    int maxUniqueSplit(string g) {\\n        s=g;\\n        res=0;\\n        n=s.length();\\n       \\n        check(0);\\n        return res;\\n    }\\n    void check(int x)\\n    {\\n        if(x==n)\\n        {\\n            int r=ss.size();\\n            res=max(res,r); //store the max value\\n            return;\\n        }\\n        string g=\"\";\\n       for(int i=x;i<n;i++)\\n       {\\n           g+=s[i]; // add next char to current partioned string \\n           if(ss.find(g)==ss.end()) //if this string is unique\\n           {\\n               ss.insert(g); // store it in set \\n               check(i+1); //backtrack with next index\\n               ss.erase(g);// remove from set so it may not effect upcoming checks \\n           }\\n       }\\n    }\\n};\\n```\\n**please upvote if helpful**",
                "solutionTags": [],
                "code": "```\\n int n;\\n    string s;\\n    int res;\\n     set<string>ss; //to store current partitiond string\\n    int maxUniqueSplit(string g) {\\n        s=g;\\n        res=0;\\n        n=s.length();\\n       \\n        check(0);\\n        return res;\\n    }\\n    void check(int x)\\n    {\\n        if(x==n)\\n        {\\n            int r=ss.size();\\n            res=max(res,r); //store the max value\\n            return;\\n        }\\n        string g=\"\";\\n       for(int i=x;i<n;i++)\\n       {\\n           g+=s[i]; // add next char to current partioned string \\n           if(ss.find(g)==ss.end()) //if this string is unique\\n           {\\n               ss.insert(g); // store it in set \\n               check(i+1); //backtrack with next index\\n               ss.erase(g);// remove from set so it may not effect upcoming checks \\n           }\\n       }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855109,
                "title": "java-dfs-very-easy-to-understand",
                "content": "There is actually no good way to optimize.\\nBrute force seems to be the only way.\\n```\\n    public int maxUniqueSplit(String s) {\\n        int[] res = new int[1];\\n        Set<String> set = new HashSet<>();\\n        \\n        dfs(res, s, set, 0);\\n        return res[0];\\n    }\\n    \\n    private void dfs(int[] res, String s, Set<String> set, int cur) {\\n        if (cur == s.length()) {\\n            res[0] = Math.max(res[0], set.size());\\n            return;\\n        }\\n        \\n        for (int i = cur; i < s.length(); i++) {\\n            String word = s.substring(cur, i + 1);\\n            if (!set.contains(word)) {\\n                set.add(word);\\n                dfs(res, s, set, i + 1);\\n                set.remove(word);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxUniqueSplit(String s) {\\n        int[] res = new int[1];\\n        Set<String> set = new HashSet<>();\\n        \\n        dfs(res, s, set, 0);\\n        return res[0];\\n    }\\n    \\n    private void dfs(int[] res, String s, Set<String> set, int cur) {\\n        if (cur == s.length()) {\\n            res[0] = Math.max(res[0], set.size());\\n            return;\\n        }\\n        \\n        for (int i = cur; i < s.length(); i++) {\\n            String word = s.substring(cur, i + 1);\\n            if (!set.contains(word)) {\\n                set.add(word);\\n                dfs(res, s, set, i + 1);\\n                set.remove(word);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 857169,
                "title": "c-simple-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>st;\\n    int ans=0;\\n    void dfs(string &s, int idx)\\n    {\\n        if(st.size()>ans) ans=st.size();\\n        if(idx>=s.length()) return;\\n        string str=\"\";\\n        for(int i=idx ; i<s.length() ; i++)\\n        {\\n            str += s[i];\\n            if(st.find(str)==st.end())\\n            {\\n                st.insert(str);\\n                dfs(s,i+1);\\n                st.erase(str);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        dfs(s,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>st;\\n    int ans=0;\\n    void dfs(string &s, int idx)\\n    {\\n        if(st.size()>ans) ans=st.size();\\n        if(idx>=s.length()) return;\\n        string str=\"\";\\n        for(int i=idx ; i<s.length() ; i++)\\n        {\\n            str += s[i];\\n            if(st.find(str)==st.end())\\n            {\\n                st.insert(str);\\n                dfs(s,i+1);\\n                st.erase(str);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        dfs(s,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855038,
                "title": "python-bit-strings",
                "content": "Any split into subsets can be represented by bit strings starting from `0...00` to `1...11` where length of the bit strings equal that of `s`. We can lazily generate all splits, check if they result in all unique substrings, and in turn check that against maximum length.\\n\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n\\t\\t#split into substrings given bit string b\\n\\t\\t#e.g. s = abcd, b=1101, output = [ab, c, d]\\n        def split(s, b): \\n            res = []\\n            x, y = s[0], b[0]\\n            for i in range(1, len(s)):\\n                if b[i]==y:\\n                    x += s[i]\\n                else:\\n                    res.append(x)\\n                    x, y = s[i], b[i]\\n            res.append(x)\\n            return res\\n        \\n        max_len = 0\\n        for i in range(2**len(s)):\\n            b = bin(i)[2:]\\n            b = \\'0\\'*(len(s)-len(b)) + b\\n            res = split(s,b) #split based on bit string\\n            if len(res)==len(set(res)): #check if the split forms valid substrings\\n                max_len = max(max_len, len(res)) #compare against max length so far\\n        return max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n\\t\\t#split into substrings given bit string b\\n\\t\\t#e.g. s = abcd, b=1101, output = [ab, c, d]\\n        def split(s, b): \\n            res = []\\n            x, y = s[0], b[0]\\n            for i in range(1, len(s)):\\n                if b[i]==y:\\n                    x += s[i]\\n                else:\\n                    res.append(x)\\n                    x, y = s[i], b[i]\\n            res.append(x)\\n            return res\\n        \\n        max_len = 0\\n        for i in range(2**len(s)):\\n            b = bin(i)[2:]\\n            b = \\'0\\'*(len(s)-len(b)) + b\\n            res = split(s,b) #split based on bit string\\n            if len(res)==len(set(res)): #check if the split forms valid substrings\\n                max_len = max(max_len, len(res)) #compare against max length so far\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860904,
                "title": "java-clean-optimized-code",
                "content": "```\\n\\nclass Solution {\\n    int max = 0;\\n    public int maxUniqueSplit(String s) {\\n        int n = s.length();\\n        backtrack(s, 0, new HashSet<String>());\\n        return max;\\n    }\\n    public void backtrack(String s, int start, Set<String> h) {\\n        if(start == s.length()) {\\n            max = Math.max(max, h.size());\\n        }\\n        String res = \"\";\\n        \\n        for(int i = start;i < s.length();i++) {\\n            res += s.charAt(i);\\n            if(h.contains(res)) continue;\\n            h.add(res);\\n            backtrack(s, i+1, h);\\n            h.remove(res);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution {\\n    int max = 0;\\n    public int maxUniqueSplit(String s) {\\n        int n = s.length();\\n        backtrack(s, 0, new HashSet<String>());\\n        return max;\\n    }\\n    public void backtrack(String s, int start, Set<String> h) {\\n        if(start == s.length()) {\\n            max = Math.max(max, h.size());\\n        }\\n        String res = \"\";\\n        \\n        for(int i = start;i < s.length();i++) {\\n            res += s.charAt(i);\\n            if(h.contains(res)) continue;\\n            h.add(res);\\n            backtrack(s, i+1, h);\\n            h.remove(res);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855405,
                "title": "python-3-backtracking-dfs-clean-explanations",
                "content": "### Explanation\\n- The length of `s` is only up to 16, so it won\\'t hurt if we exhaustively try out all possibility\\n- And intuitively backtracking + DFS is very good at doing job like this\\n- Check comment for more detail, pretty standard backtracking problem\\n### Implementation\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans, n = 0, len(s)\\n        def dfs(i, cnt, visited):\\n            nonlocal ans, n\\n            if i == n: ans = max(ans, cnt); return  # stop condition\\n            for j in range(i+1, n+1):    \\n                if s[i:j] in visited: continue      # avoid re-visit/duplicates\\n                visited.add(s[i:j])                 # update visited set\\n                dfs(j, cnt+1, visited)              # backtracking\\n                visited.remove(s[i:j])              # recover visited set for next possibility\\n        dfs(0, 0, set())                            # function call\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans, n = 0, len(s)\\n        def dfs(i, cnt, visited):\\n            nonlocal ans, n\\n            if i == n: ans = max(ans, cnt); return  # stop condition\\n            for j in range(i+1, n+1):    \\n                if s[i:j] in visited: continue      # avoid re-visit/duplicates\\n                visited.add(s[i:j])                 # update visited set\\n                dfs(j, cnt+1, visited)              # backtracking\\n                visited.remove(s[i:j])              # recover visited set for next possibility\\n        dfs(0, 0, set())                            # function call\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855187,
                "title": "clean-python-3-backtracking",
                "content": "Time: `O(N^3)`, N^2 for iterating `i` and `j`, N for `s[i:j]`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        def backtracking(i: int, occur: set) -> int:\\n            if i == len(s): return 0\\n            M = 0\\n            for j in range(i + 1, len(s) + 1):\\n                if (part := s[i:j]) not in occur:\\n                    occur.add(part)\\n                    M = max(M, backtracking(j, occur) + 1)\\n                    occur.discard(part)\\n            return M\\n        return backtracking(0, set())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        def backtracking(i: int, occur: set) -> int:\\n            if i == len(s): return 0\\n            M = 0\\n            for j in range(i + 1, len(s) + 1):\\n                if (part := s[i:j]) not in occur:\\n                    occur.add(part)\\n                    M = max(M, backtracking(j, occur) + 1)\\n                    occur.discard(part)\\n            return M\\n        return backtracking(0, set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438525,
                "title": "c-backtracking-dfs",
                "content": "**Recursion call explanation**\\n\\nstring str = \"*ababccc*\"\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      (  ababccc )\\n\\t\\t\\t\\t\\t\\t/      /       |         |          \\\\          \\\\              \\\\ \\n\\t\\t\\t\\t\\t  a    ab  aba     abab    ababc   ababcc     ababccc\\n\\t\\t\\t\\t\\t/   \\n\\t\\t\\t\\ta,b \\n\\t\\t\\t\\t/\\n\\t\\t\\t a,b,a  --> Here we get duplicate *a* hence we will cut the recursion tree or else continue the dfs and when index reaches \"n\" update the result\\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=1;\\n    void helper(string &str,int ind,vector<string> &temp,unordered_set<string> &st)\\n    {\\n        if(ind == str.length()){\\n            \\n            int l=temp.size();\\n            ans = max(ans,l);\\n            return;\\n        }\\n        string s=\"\";\\n        for(int i=ind;i<str.length();i++){\\n            s.push_back(str[i]);\\n            if(!st.count(s)){                              // call only when string s is not in our set or s is not repeated.\\n                temp.push_back(s);\\n                st.insert(s);\\n                helper(str,i+1,temp,st);\\n                st.erase(s);                         // backtrack\\n                temp.pop_back();                     // backtrack \\n            }\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        \\n        vector<string> temp;\\n        unordered_set<string> st;\\n        helper(s,0,temp,st);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n**PLEASE UPVOTE IF THIS HELPS YOU**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ans=1;\\n    void helper(string &str,int ind,vector<string> &temp,unordered_set<string> &st)\\n    {\\n        if(ind == str.length()){\\n            \\n            int l=temp.size();\\n            ans = max(ans,l);\\n            return;\\n        }\\n        string s=\"\";\\n        for(int i=ind;i<str.length();i++){\\n            s.push_back(str[i]);\\n            if(!st.count(s)){                              // call only when string s is not in our set or s is not repeated.\\n                temp.push_back(s);\\n                st.insert(s);\\n                helper(str,i+1,temp,st);\\n                st.erase(s);                         // backtrack\\n                temp.pop_back();                     // backtrack \\n            }\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        \\n        vector<string> temp;\\n        unordered_set<string> st;\\n        helper(s,0,temp,st);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982485,
                "title": "java-backtracking-solution-with-complexity-analysis",
                "content": "Time Complexity: O(2^N)\\n\\nThink about it this way: Since we are exploring all the possible combinations of substrings to find the best result, we are trying to insert a split in between every two characters.\\n\\nThere are a total number of N characters in the string, so the number of gaps in between characters is `N - 1`. At each gap, we have 2 choices: whether or not to split at current position. In total we have O(2^N) possibilities.\\n\\n```\\nclass Solution {\\n    int maxSplit;\\n    String s;\\n    public int maxUniqueSplit(String s) {\\n        maxSplit = 0;\\n        this.s = s;\\n        helper(0, new HashSet<String>());\\n        return maxSplit;\\n    }\\n    \\n    private void helper(int start, HashSet<String> visited){\\n        // start out of bound, reaching the end of the string, update maxSplit accordingly\\n        if(start == s.length()){\\n            maxSplit = Math.max(visited.size(), maxSplit);\\n            return;\\n        }\\n        // end is ranging from [1...N] because we take the substring s[index, end)\\n        for(int end = start + 1; end <= s.length(); end++){\\n            String newStr = s.substring(start, end);\\n            if(!visited.contains(newStr)){\\n                visited.add(newStr);\\n                helper(end, visited);\\n                visited.remove(newStr);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int maxSplit;\\n    String s;\\n    public int maxUniqueSplit(String s) {\\n        maxSplit = 0;\\n        this.s = s;\\n        helper(0, new HashSet<String>());\\n        return maxSplit;\\n    }\\n    \\n    private void helper(int start, HashSet<String> visited){\\n        // start out of bound, reaching the end of the string, update maxSplit accordingly\\n        if(start == s.length()){\\n            maxSplit = Math.max(visited.size(), maxSplit);\\n            return;\\n        }\\n        // end is ranging from [1...N] because we take the substring s[index, end)\\n        for(int end = start + 1; end <= s.length(); end++){\\n            String newStr = s.substring(start, end);\\n            if(!visited.contains(newStr)){\\n                visited.add(newStr);\\n                helper(end, visited);\\n                visited.remove(newStr);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855071,
                "title": "python3-backtracking",
                "content": "\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        \\n        def fn(i):\\n            \"\"\"Find max length via backtracking.\"\"\"\\n            nonlocal ans \\n            if i == len(s): return (ans := max(ans, len(tabu)))\\n            for ii in range(i+1, len(s)+1): \\n                if s[i:ii] not in tabu: \\n                    tabu.add(s[i:ii])\\n                    fn(ii)\\n                    tabu.remove(s[i:ii])\\n            \\n        ans = 1\\n        tabu = set()\\n        fn(0)\\n        return ans \\n```\\n\\nEdited on 9/21/2020\\n@kunqian gives a more concise implementation in this [post](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/discuss/855077/Python3-Backtracking). \\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        \\n        def fn(i, seen=set()):\\n            \"\"\"Find max length via backtracking.\"\"\"\\n            ans = 0\\n            if i < len(s): # boundary condition when i == len(s)\\n                for ii in range(i+1, len(s)+1): \\n                    if s[i:ii] not in seen: \\n                        seen.add(s[i:ii])\\n                        ans = max(ans, 1 + fn(ii, seen))\\n                        seen.remove(s[i:ii])\\n            return ans \\n            \\n        return fn(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        \\n        def fn(i):\\n            \"\"\"Find max length via backtracking.\"\"\"\\n            nonlocal ans \\n            if i == len(s): return (ans := max(ans, len(tabu)))\\n            for ii in range(i+1, len(s)+1): \\n                if s[i:ii] not in tabu: \\n                    tabu.add(s[i:ii])\\n                    fn(ii)\\n                    tabu.remove(s[i:ii])\\n            \\n        ans = 1\\n        tabu = set()\\n        fn(0)\\n        return ans \\n```\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        \\n        def fn(i, seen=set()):\\n            \"\"\"Find max length via backtracking.\"\"\"\\n            ans = 0\\n            if i < len(s): # boundary condition when i == len(s)\\n                for ii in range(i+1, len(s)+1): \\n                    if s[i:ii] not in seen: \\n                        seen.add(s[i:ii])\\n                        ans = max(ans, 1 + fn(ii, seen))\\n                        seen.remove(s[i:ii])\\n            return ans \\n            \\n        return fn(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313171,
                "title": "c-hash-map-backtracking-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int res=0;\\n    void solve(string s,int idx,string curr_s,int ans)\\n    {\\n        if(idx>=s.size())\\n        {\\n            res=max(res,ans);\\n            return ;\\n        }\\n        curr_s+=s[idx];\\n        if(mp[curr_s]==0)\\n        {\\n            mp[curr_s]=1;\\n            ans++;\\n            solve(s,idx+1,\"\",ans);\\n            mp[curr_s]=0;\\n            ans--;\\n        }\\n        solve(s,idx+1,curr_s,ans);\\n    }\\n    int maxUniqueSplit(string s) \\n    {\\n        solve(s,0,\"\",0);\\n        return res;\\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int res=0;\\n    void solve(string s,int idx,string curr_s,int ans)\\n    {\\n        if(idx>=s.size())\\n        {\\n            res=max(res,ans);\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1707625,
                "title": "c-easy-backtracking-approach",
                "content": "```\\nclass Solution {\\npublic: \\n    int count=0;\\n    void helper(set<string>&m,string s,string d){\\n        if(s.empty())\\n        {   int len=m.size();\\n            count=max(count,len);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n           d=s.substr(0,i+1);\\n            if(m.find(d)==m.end()){\\n                m.insert(d);\\n                helper(m,s.substr(i+1),d);\\n                m.erase(d);\\n            }\\n        }\\n        return ;\\n    }\\n    int maxUniqueSplit(string s) {\\n        set<string>m;\\n        string d;\\n        helper(m,s,d);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int count=0;\\n    void helper(set<string>&m,string s,string d){\\n        if(s.empty())\\n        {   int len=m.size();\\n            count=max(count,len);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n           d=s.substr(0,i+1);\\n            if(m.find(d)==m.end()){\\n                m.insert(d);\\n                helper(m,s.substr(i+1),d);\\n                m.erase(d);\\n            }\\n        }\\n        return ;\\n    }\\n    int maxUniqueSplit(string s) {\\n        set<string>m;\\n        string d;\\n        helper(m,s,d);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856195,
                "title": "recurse-assess-and-backtrack-simple-java-solution-with-comments",
                "content": "```\\n/**\\nThis is a try-all-possibilities question! \\nTry splitting in a way until end of string, assess, before going to the next \\niteration reset the used set by removing the candidiate\\n*/\\nclass Solution {\\n    \\n    private int max;\\n    \\n    public int maxUniqueSplit(String s) {\\n        if(s == null || s.length() == 0){\\n            return 0;\\n        }\\n        \\n        dfs(s, 0, new HashSet<String>());\\n        return max;\\n    }\\n    \\n    private void dfs(String s, int counter, Set<String> used){\\n        \\n        if(s.length() == 0){\\n            // successfully split strings and came to the end of the string. Time to assess.\\n            max = Math.max(max, counter);\\n            return;\\n        }\\n        \\n        for(int endIndex=1; endIndex <= s.length(); endIndex++){\\n            String candidate = s.substring(0, endIndex);\\n            if(used.contains(candidate)){\\n                continue; // try the next index, this split doesnt work\\n            }\\n            used.add(candidate);\\n            dfs(s.substring(endIndex, s.length()), counter + 1, used);\\n            // now before going to the next iteration, lets get rid of the current\\n            // candidate in the used set - i.e. backtrack\\n            used.remove(candidate);\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\nThis is a try-all-possibilities question! \\nTry splitting in a way until end of string, assess, before going to the next \\niteration reset the used set by removing the candidiate\\n*/\\nclass Solution {\\n    \\n    private int max;\\n    \\n    public int maxUniqueSplit(String s) {\\n        if(s == null || s.length() == 0){\\n            return 0;\\n        }\\n        \\n        dfs(s, 0, new HashSet<String>());\\n        return max;\\n    }\\n    \\n    private void dfs(String s, int counter, Set<String> used){\\n        \\n        if(s.length() == 0){\\n            // successfully split strings and came to the end of the string. Time to assess.\\n            max = Math.max(max, counter);\\n            return;\\n        }\\n        \\n        for(int endIndex=1; endIndex <= s.length(); endIndex++){\\n            String candidate = s.substring(0, endIndex);\\n            if(used.contains(candidate)){\\n                continue; // try the next index, this split doesnt work\\n            }\\n            used.add(candidate);\\n            dfs(s.substring(endIndex, s.length()), counter + 1, used);\\n            // now before going to the next iteration, lets get rid of the current\\n            // candidate in the used set - i.e. backtrack\\n            used.remove(candidate);\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855340,
                "title": "clean-python-backtracking-solution",
                "content": "```\\ndef maxUniqueSplit(self, s: str) -> int:\\n        \\n\\tdef backtrack(s, seen=()):\\n\\t\\tmaximum = 0\\n\\t\\tfor i in range(1, len(s) + 1):\\n\\t\\t\\tcandidate = s[:i]\\n\\t\\t\\tif candidate not in seen:\\n\\t\\t\\t\\tmaximum = max(maximum, 1 + backtrack(s[i:], {candidate, *seen}))\\n\\t\\treturn maximum\\n        \\n\\treturn backtrack(s)\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxUniqueSplit(self, s: str) -> int:\\n        \\n\\tdef backtrack(s, seen=()):\\n\\t\\tmaximum = 0\\n\\t\\tfor i in range(1, len(s) + 1):\\n\\t\\t\\tcandidate = s[:i]\\n\\t\\t\\tif candidate not in seen:\\n\\t\\t\\t\\tmaximum = max(maximum, 1 + backtrack(s[i:], {candidate, *seen}))\\n\\t\\treturn maximum\\n        \\n\\treturn backtrack(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 856712,
                "title": "python-have-a-set-to-record-the-unique-substrs-and-do-backtrack-traverse-all-candidates",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        haveBefore = set()\\n        rst = 0\\n        def dfs(start):\\n            \"\"\"\\n            start: int, start index\\n            \"\"\"\\n            nonlocal rst\\n            if start == len(s):\\n                rst = max(rst, len(haveBefore))\\n                return\\n            \\n            for i in range(start, len(s)):\\n                substr = s[start: i + 1]\\n                if substr in haveBefore:\\n                    continue\\n                haveBefore.add(substr)\\n                dfs(i + 1)\\n                haveBefore.remove(substr)\\n        dfs(0)\\n        return rst\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        haveBefore = set()\\n        rst = 0\\n        def dfs(start):\\n            \"\"\"\\n            start: int, start index\\n            \"\"\"\\n            nonlocal rst\\n            if start == len(s):\\n                rst = max(rst, len(haveBefore))\\n                return\\n            \\n            for i in range(start, len(s)):\\n                substr = s[start: i + 1]\\n                if substr in haveBefore:\\n                    continue\\n                haveBefore.add(substr)\\n                dfs(i + 1)\\n                haveBefore.remove(substr)\\n        dfs(0)\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855565,
                "title": "simple-c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> ht;\\n    int result=0;\\n    \\n    void splitString(string s, int pos, int partial){\\n        if(pos==s.size()){\\n            result=max(result, partial);\\n            return;\\n        }\\n        \\n        for(int i=pos; i<s.size(); i++){\\n            string substr = s.substr(pos, i-pos+1);\\n            \\n            if(ht.find(substr)==ht.end()){\\n                ht.insert(substr);\\n                partial++;\\n                \\n                splitString(s, i+1, partial);\\n                \\n                partial--;\\n                ht.erase(substr);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        splitString(s, 0, 0);\\n        \\n        return result;\\n    }\\n};\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> ht;\\n    int result=0;\\n    \\n    void splitString(string s, int pos, int partial){\\n        if(pos==s.size()){\\n            result=max(result, partial);\\n            return;\\n        }\\n        \\n        for(int i=pos; i<s.size(); i++){\\n            string substr = s.substr(pos, i-pos+1);\\n            \\n            if(ht.find(substr)==ht.end()){\\n                ht.insert(substr);\\n                partial++;\\n                \\n                splitString(s, i+1, partial);\\n                \\n                partial--;\\n                ht.erase(substr);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        splitString(s, 0, 0);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883430,
                "title": "economical-backtracking-solution-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis optimization problem will involve backtracking. The maximum length of s is 16, so there shouldn\\'t be too much of a problem with execution time, even though a more general (unlimited length) solution wouldn\\'t scale well at all, approaching O($$n!$$) for time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll work recursively, using depth-first search, and keeping track of the set of substrings that have been used already along the current path. The ***used*** set will grow as we move forward and shrink as we back up.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        # DFS-based solution\\n        used = set()                                    # Working set of substrings\\n        max_distinct = 0                                # Best answer so far\\n\\n        def propose(start, n):\\n            # DFS helper\\n            nonlocal max_distinct\\n            if start == len(s):                         # Stop recursion\\n                if n > max_distinct:                    # Adjust max if appropriate\\n                    max_distinct = n\\n            else:\\n                for i in range(start + 1, len(s) + 1):  # i is the substring end (+1)\\n                    candidate = s[start:i]\\n                    if candidate not in used:           # Unique so far, so legal\\n                        used.add(candidate)             # Add to set\\n                        propose(i, n + 1)               # Go deeper; next substring\\n                        used.remove(candidate)          # Remove (backtracking)\\n\\n        propose(0, 0)                                   # Start here\\n        return max_distinct\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        # DFS-based solution\\n        used = set()                                    # Working set of substrings\\n        max_distinct = 0                                # Best answer so far\\n\\n        def propose(start, n):\\n            # DFS helper\\n            nonlocal max_distinct\\n            if start == len(s):                         # Stop recursion\\n                if n > max_distinct:                    # Adjust max if appropriate\\n                    max_distinct = n\\n            else:\\n                for i in range(start + 1, len(s) + 1):  # i is the substring end (+1)\\n                    candidate = s[start:i]\\n                    if candidate not in used:           # Unique so far, so legal\\n                        used.add(candidate)             # Add to set\\n                        propose(i, n + 1)               # Go deeper; next substring\\n                        used.remove(candidate)          # Remove (backtracking)\\n\\n        propose(0, 0)                                   # Start here\\n        return max_distinct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690324,
                "title": "java-backtracking-easy-understanding",
                "content": "```\\nclass Solution {\\n    \\n    int max = 0;\\n    public int maxUniqueSplit(String s) {\\n        split(0,new HashSet<>(),s);\\n        return max;\\n    }\\n    \\n    public void split(int ind , Set<String> set , String s){\\n        \\n        if(ind >= s.length()){\\n            max = Math.max(set.size(),max);\\n            return;\\n        }\\n    \\n        for(int i  = ind + 1 ; i <= s.length() ; i++){\\n            String newS = s.substring(ind,i);\\n            if(set.add(newS)){\\n                split(i,set,s);\\n                set.remove(newS);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int max = 0;\\n    public int maxUniqueSplit(String s) {\\n        split(0,new HashSet<>(),s);\\n        return max;\\n    }\\n    \\n    public void split(int ind , Set<String> set , String s){\\n        \\n        if(ind >= s.length()){\\n            max = Math.max(set.size(),max);\\n            return;\\n        }\\n    \\n        for(int i  = ind + 1 ; i <= s.length() ; i++){\\n            String newS = s.substring(ind,i);\\n            if(set.add(newS)){\\n                split(i,set,s);\\n                set.remove(newS);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417102,
                "title": "set-backtracking-c",
                "content": "```\\nclass Solution {\\n    void dfs(int i, int n, string &str, unordered_set<string> &s, int &ans) {\\n        if(i == n) {\\n            ans = max(ans, (int)s.size());\\n            return;\\n        }\\n        string t;\\n        for(int j=i; j<n; j++) {\\n            t += str[j];\\n            if(s.find(t) == s.end()) {\\n                s.insert(t);\\n                dfs(j + 1, n, str, s, ans);\\n                s.erase(t);\\n            }\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string str) {\\n        int n = str.size(), ans = 0;\\n        unordered_set<string> s;\\n\\n        dfs(0, n, str, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int n, string &str, unordered_set<string> &s, int &ans) {\\n        if(i == n) {\\n            ans = max(ans, (int)s.size());\\n            return;\\n        }\\n        string t;\\n        for(int j=i; j<n; j++) {\\n            t += str[j];\\n            if(s.find(t) == s.end()) {\\n                s.insert(t);\\n                dfs(j + 1, n, str, s, ans);\\n                s.erase(t);\\n            }\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string str) {\\n        int n = str.size(), ans = 0;\\n        unordered_set<string> s;\\n\\n        dfs(0, n, str, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232348,
                "title": "c-solution-backtracking-unordered-set",
                "content": "```\\nclass Solution {\\nprivate:\\n    int solve(int ind, string& s, unordered_set<string>& st, string temp){\\n        if(ind == s.length())\\n            return 0;\\n        else{\\n            temp.push_back(s[ind]);\\n            int op1 = -1;\\n            int op2 = -1;\\n\\t\\t\\t// if new substring is not present in the set\\n            if(st.find(temp) == st.end()){\\n                st.insert(temp);\\n                op1 = 1 + solve(ind+1, s, st, \"\");  //since new substring is added we increase the cnt by 1 and create a new substring to check from very next index -----> in other words we pick that string\\n                st.erase(temp);\\n            }\\n\\t\\t\\t// picked part was done,  its time for not picking the char at that index and moving to the next one\\n            op2 = solve(ind+1, s, st, temp);\\n            return max(op1, op2);\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        // creating unordered_set to keep track which substring is visited\\n        unordered_set<string> st;\\n\\t\\t// recursion function\\n        return solve(0, s, st, \"\"); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int ind, string& s, unordered_set<string>& st, string temp){\\n        if(ind == s.length())\\n            return 0;\\n        else{\\n            temp.push_back(s[ind]);\\n            int op1 = -1;\\n            int op2 = -1;\\n\\t\\t\\t// if new substring is not present in the set\\n            if(st.find(temp) == st.end()){\\n                st.insert(temp);\\n                op1 = 1 + solve(ind+1, s, st, \"\");  //since new substring is added we increase the cnt by 1 and create a new substring to check from very next index -----> in other words we pick that string\\n                st.erase(temp);\\n            }\\n\\t\\t\\t// picked part was done,  its time for not picking the char at that index and moving to the next one\\n            op2 = solve(ind+1, s, st, temp);\\n            return max(op1, op2);\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        // creating unordered_set to keep track which substring is visited\\n        unordered_set<string> st;\\n\\t\\t// recursion function\\n        return solve(0, s, st, \"\"); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169127,
                "title": "easy-and-well-explained-code-commented-beats-95-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVery easy approach , just create a set to store all the possible sub strings and keet storing set size in your ans variable, do recursive call to find out for all possible sub strings and then backtrack.\\n\\nLook out at the code for better understanding :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> st; //set to store all unique substrings\\n    int ans=0;\\n    void lol(int ind, string &s){\\n        //if index exceeds string then store set size in ans\\n        if(ind>=s.length()) {\\n            ans = max(ans, (int)st.size());\\n            return;\\n        }\\n        string temp=\"\"; // temp string to iterate and store the substring\\n        for(int i=ind;i<s.length();i++){\\n            temp+=s[i];\\n            if(st.find(temp)==st.end()){ //if the substring not found in set then \\n            //insert and call recursive function for the next index and string\\n                st.insert(temp);\\n                lol(i+1, s);\\n                st.erase(temp); //backtrack (vv imp)\\n            }\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        lol(0,s);\\n        return ans; \\n    }\\n};\\n\\n```\\n\\n# Please do upvote if you found it helpful\\n\\n![image.png](https://assets.leetcode.com/users/images/2a8fbaf3-9795-494f-b888-67d926eccf34_1676052176.9830995.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st; //set to store all unique substrings\\n    int ans=0;\\n    void lol(int ind, string &s){\\n        //if index exceeds string then store set size in ans\\n        if(ind>=s.length()) {\\n            ans = max(ans, (int)st.size());\\n            return;\\n        }\\n        string temp=\"\"; // temp string to iterate and store the substring\\n        for(int i=ind;i<s.length();i++){\\n            temp+=s[i];\\n            if(st.find(temp)==st.end()){ //if the substring not found in set then \\n            //insert and call recursive function for the next index and string\\n                st.insert(temp);\\n                lol(i+1, s);\\n                st.erase(temp); //backtrack (vv imp)\\n            }\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        lol(0,s);\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715338,
                "title": "c-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>st;\\n    int ans=INT_MIN;\\n    int maxUniqueSplit(string s) \\n    {\\n       int count=0;\\n       fun(s,count);\\n       return ans;\\n    }\\n    void fun(string s,int count)\\n    {\\n        //cout<<s<<endl;\\n        if(s.length()==0)\\n        {\\n            ans=max(ans,count);\\n            return;\\n        }\\n        string first=\"\";\\n        string second=\"\";\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            first.push_back(s[i]);\\n\\n            if(st.find(first)==st.end())   //first entry of this type of string\\n            {\\n                st.insert(first);\\n                second = s.substr(i+1,s.length());\\n                fun(second,count+1);\\n                st.erase(first);         //backtraing\\n            }\\t\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>st;\\n    int ans=INT_MIN;\\n    int maxUniqueSplit(string s) \\n    {\\n       int count=0;\\n       fun(s,count);\\n       return ans;\\n    }\\n    void fun(string s,int count)\\n    {\\n        //cout<<s<<endl;\\n        if(s.length()==0)\\n        {\\n            ans=max(ans,count);\\n            return;\\n        }\\n        string first=\"\";\\n        string second=\"\";\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            first.push_back(s[i]);\\n\\n            if(st.find(first)==st.end())   //first entry of this type of string\\n            {\\n                st.insert(first);\\n                second = s.substr(i+1,s.length());\\n                fun(second,count+1);\\n                st.erase(first);         //backtraing\\n            }\\t\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2569403,
                "title": "java-backtracking-tc-o-2-n",
                "content": "```\\npublic int maxUniqueSplit(String s) {\\n        return helper(s, new HashSet<>());\\n}\\n    \\npublic int helper(String s, HashSet<String> visited) {\\n        int max = 0;\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(visited.add(temp)) {\\n                max = Math.max(max, 1 + helper(s.substring(i), visited));\\n                visited.remove(temp);\\n            }\\n        }\\n        return max;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic int maxUniqueSplit(String s) {\\n        return helper(s, new HashSet<>());\\n}\\n    \\npublic int helper(String s, HashSet<String> visited) {\\n        int max = 0;\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(visited.add(temp)) {\\n                max = Math.max(max, 1 + helper(s.substring(i), visited));\\n                visited.remove(temp);\\n            }\\n        }\\n        return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511102,
                "title": "go-backtracking",
                "content": "```\\nfunc maxUniqueSplit(s string) int {\\n\\tn := len(s)\\n\\tmemo := make(map[string]bool)\\n\\tresult := 0\\n\\t\\n\\tvar backtrack func(pos int, currentResult int) \\n\\t\\n\\tbacktrack = func(pos int, currentResult int) {\\n\\t\\tif pos >= n {\\n\\t\\t\\tif currentResult > result {\\n\\t\\t\\t\\tresult = currentResult\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor i:=pos+1; i<=n; i++ {\\n\\t\\t\\tnewS := s[pos:i]\\n\\t\\t\\tif v, ok := memo[newS]; ok && v {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tmemo[newS] = true\\n\\t\\t\\tbacktrack(i, currentResult + 1)\\n\\t\\t\\tmemo[newS] = false\\n\\t\\t}\\n\\t}\\n\\n\\tbacktrack(0, 0)\\n\\t\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc maxUniqueSplit(s string) int {\\n\\tn := len(s)\\n\\tmemo := make(map[string]bool)\\n\\tresult := 0\\n\\t\\n\\tvar backtrack func(pos int, currentResult int) \\n\\t\\n\\tbacktrack = func(pos int, currentResult int) {\\n\\t\\tif pos >= n {\\n\\t\\t\\tif currentResult > result {\\n\\t\\t\\t\\tresult = currentResult\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor i:=pos+1; i<=n; i++ {\\n\\t\\t\\tnewS := s[pos:i]\\n\\t\\t\\tif v, ok := memo[newS]; ok && v {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tmemo[newS] = true\\n\\t\\t\\tbacktrack(i, currentResult + 1)\\n\\t\\t\\tmemo[newS] = false\\n\\t\\t}\\n\\t}\\n\\n\\tbacktrack(0, 0)\\n\\t\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2439304,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int ans = 0;\\n    void dfs(int idx, string &s, unordered_map<string,int> &um)\\n    {\\n        if(idx == s.size())\\n        {\\n            int sz = um.size();\\n            ans = max(sz, ans);\\n            return;\\n        }\\n        string tmp = \"\";\\n        for(int i = idx; i < s.size(); i++)\\n        {\\n            tmp += s[i];\\n            if(um.count(tmp))\\n                continue;\\n            um[tmp]++;\\n            dfs(i+1, s, um);\\n            um.erase(tmp);\\n        }\\n        return;\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_map<string,int> um;\\n        dfs(0,s, um);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    void dfs(int idx, string &s, unordered_map<string,int> &um)\\n    {\\n        if(idx == s.size())\\n        {\\n            int sz = um.size();\\n            ans = max(sz, ans);\\n            return;\\n        }\\n        string tmp = \"\";\\n        for(int i = idx; i < s.size(); i++)\\n        {\\n            tmp += s[i];\\n            if(um.count(tmp))\\n                continue;\\n            um[tmp]++;\\n            dfs(i+1, s, um);\\n            um.erase(tmp);\\n        }\\n        return;\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_map<string,int> um;\\n        dfs(0,s, um);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013829,
                "title": "java-recursion-bactracking",
                "content": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        \\n        build(s, 0);\\n        return count;\\n    }\\n    \\n    HashMap<String, Integer> map = new HashMap<String, Integer>();\\n    int count = 0;\\n    \\n    public void build(String s, int index) {\\n        \\n        if(index == s.length()) {\\n        \\n            if(count < map.size()) {\\n                count = map.size();\\n            }\\n          //  System.out.println(map);\\n            return;\\n        }\\n        \\n        \\n        for(int i = index ; i < s.length(); i++) {\\n            String t = s.substring(index, i+1);\\n            if(map.get(t) != null) {\\n               // map.remove(t);\\n                continue;\\n            }\\n            map.put(t, 1);\\n            build(s, i+1);\\n            map.remove(t);\\n        }\\n        \\n    }\\n    \\n    \\n}\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int maxUniqueSplit(String s) {\\n        \\n        build(s, 0);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2007644,
                "title": "java-backtracking-maintain-the-set-of-strings-visited-elegant-and-concise-solution",
                "content": "```\\nclass Solution {\\n    private int ans;\\n    \\n    public int maxUniqueSplit(String s) {\\n        this.ans = 0;\\n        find(0, s, new HashSet<String>());\\n        return ans;\\n    }\\n    \\n    private void find(int index, String s, HashSet<String> visited){\\n        if(index == s.length()){\\n            this.ans = Math.max(this.ans, visited.size());\\n            return;\\n        }\\n        \\n        for(int i=index; i<s.length(); i++){\\n            String subStr = s.substring(index, i+1);\\n            if(visited.contains(subStr)) continue;\\n            \\n            visited.add(subStr);\\n            find(i+1, s, visited);\\n            visited.remove(subStr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int ans;\\n    \\n    public int maxUniqueSplit(String s) {\\n        this.ans = 0;\\n        find(0, s, new HashSet<String>());\\n        return ans;\\n    }\\n    \\n    private void find(int index, String s, HashSet<String> visited){\\n        if(index == s.length()){\\n            this.ans = Math.max(this.ans, visited.size());\\n            return;\\n        }\\n        \\n        for(int i=index; i<s.length(); i++){\\n            String subStr = s.substring(index, i+1);\\n            if(visited.contains(subStr)) continue;\\n            \\n            visited.add(subStr);\\n            find(i+1, s, visited);\\n            visited.remove(subStr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869426,
                "title": "java-binary-search-backtracking-99-at-4ms",
                "content": "**Intuition**\\n\\nIf we can split a substring `s` into `k` unique substrings, then we can split it into `k - 1` unique substrings.\\nHence binary search comes in handy here.\\n\\n**Solution**\\n```Java\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        int lo = 1, hi = s.length();\\n        while(lo < hi){ // binary search\\n            int mid = (lo + hi + 1) >> 1;\\n            if (ok(0, mid, 0, s, new HashSet<>())){\\n                lo = mid;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n\\n    private boolean ok(int depth, int end, int curLen, String s, Set<String> seen){\\n        if (depth == end){\\n            return true;\\n        }\\n\\n        for (int j = curLen; j < s.length(); j++){\\n            if (s.length() - j < end - depth){ // not enough length remains to reach the end.\\n                break;\\n            }\\n            String cur = s.substring(curLen, j + 1);\\n            if (seen.add(cur)){\\n                if (ok(depth + 1, end, j + 1, s, seen)){\\n                    return true;\\n                }\\n                seen.remove(cur);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        int lo = 1, hi = s.length();\\n        while(lo < hi){ // binary search\\n            int mid = (lo + hi + 1) >> 1;\\n            if (ok(0, mid, 0, s, new HashSet<>())){\\n                lo = mid;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n\\n    private boolean ok(int depth, int end, int curLen, String s, Set<String> seen){\\n        if (depth == end){\\n            return true;\\n        }\\n\\n        for (int j = curLen; j < s.length(); j++){\\n            if (s.length() - j < end - depth){ // not enough length remains to reach the end.\\n                break;\\n            }\\n            String cur = s.substring(curLen, j + 1);\\n            if (seen.add(cur)){\\n                if (ok(depth + 1, end, j + 1, s, seen)){\\n                    return true;\\n                }\\n                seen.remove(cur);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842219,
                "title": "order-n-sol-help-me-to-complete",
                "content": "can someone help me to complete this logic or tell whether any this logic is correct or not\\n\\n```\\nclass Solution {\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_map<string,int>mp;\\n        for(int i=0; i<s.length(); i++){\\n            string temp=\"\";\\n            temp+=s[i];\\n            while(mp[temp]!=0 && i<s.length()){\\n                temp+=s[++i];\\n            }\\n            if(mp[temp] != 0){\\n                mp[temp]++;    \\n            }\\n            \\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_map<string,int>mp;\\n        for(int i=0; i<s.length(); i++){\\n            string temp=\"\";\\n            temp+=s[i];\\n            while(mp[temp]!=0 && i<s.length()){\\n                temp+=s[++i];\\n            }\\n            if(mp[temp] != 0){\\n                mp[temp]++;    \\n            }\\n            \\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749644,
                "title": "easy-using-python3-and-backtracking",
                "content": "\\tclass Solution:\\n\\t\\tdef maxUniqueSplit(self, s: str) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\tn = len(s)\\n\\t\\t\\tdef solve(index,current,vis):\\n\\t\\t\\t\\tnonlocal ans,n\\n\\t\\t\\t\\tif(index == n):\\n\\t\\t\\t\\t\\tans = max(ans,current)\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(index,n):\\n\\t\\t\\t\\t\\t# print(s[index:i])\\n\\t\\t\\t\\t\\tif(s[index:i+1] not in vis):\\n\\t\\t\\t\\t\\t\\tsolve(i+1,current+1,vis+(s[index:i+1],))\\n\\t\\t\\tsolve(0,0,())\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxUniqueSplit(self, s: str) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\tn = len(s)\\n\\t\\t\\tdef solve(index,current,vis):\\n\\t\\t\\t\\tnonlocal ans,n\\n\\t\\t\\t\\tif(index == n):\\n\\t\\t\\t\\t\\tans = max(ans,current)\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tfor i in range(index,n):\\n\\t\\t\\t\\t\\t# print(s[index:i])\\n\\t\\t\\t\\t\\tif(s[index:i+1] not in vis):\\n\\t\\t\\t\\t\\t\\tsolve(i+1,current+1,vis+(s[index:i+1],))\\n\\t\\t\\tsolve(0,0,())\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 1686530,
                "title": "c-backtracking-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    void backtrack(int &ans,string s,unordered_set<string>&seen){\\n        if(s.empty()){\\n            int len=seen.size();\\n            ans=max(ans,len);\\n        } else {\\n            for(int i=0;i<s.size();i++){\\n                string cnd=s.substr(0,i+1);\\n                if(seen.count(cnd)==0){\\n                    seen.insert(cnd);\\n                    backtrack(ans,s.substr(i+1),seen);\\n                    seen.erase(cnd);\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        int ans=0;\\n        unordered_set<string>seen;\\n        backtrack(ans,s,seen);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\nprivate:\\n    void backtrack(int &ans,string s,unordered_set<string>&seen){\\n        if(s.empty()){\\n            int len=seen.size();\\n            ans=max(ans,len);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1661141,
                "title": "1593-python3-backtracking-with-pruning",
                "content": "You should know that this is a backtracking problem the moment you finish reading this problem.\\n\\nQ: When should we use backtracking?\\n**A: When we have to check every possible situation/combination, we use backtracking. During the process, we either store all of these possible situations/combinations, or we pick the one we want (the longest/shortest/...).**\\n\\n**Solution 1: backtracking without pruning**\\nRuntime: ~400 - 500ms for Python\\n\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        def backtrack(start, path):\\n            if start == len(s):\\n                return len(path)\\n            res = 0\\n            for i in range(start + 1, len(s) + 1):\\n                if s[start:i] not in path:\\n                    res = max(res, backtrack(i, path | {s[start:i]}))\\n            return res\\n        \\n        return backtrack(0, set())\\n```\\n\\n**Solution 2: backtracking with pruning**\\nRuntime: ~50ms for Python\\n\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        def backtrack(start, path):\\n            nonlocal res\\n            if n - start + len(path) <= res:\\n                return\\n            if start == n:\\n                res = max(res, len(path))\\n                return\\n            for i in range(start + 1, n + 1):\\n                if s[start:i] not in path:\\n                    backtrack(i, path | {s[start:i]})\\n\\n        n, res = len(s), 0\\n        backtrack(0, set())\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        def backtrack(start, path):\\n            if start == len(s):\\n                return len(path)\\n            res = 0\\n            for i in range(start + 1, len(s) + 1):\\n                if s[start:i] not in path:\\n                    res = max(res, backtrack(i, path | {s[start:i]}))\\n            return res\\n        \\n        return backtrack(0, set())\\n```\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        def backtrack(start, path):\\n            nonlocal res\\n            if n - start + len(path) <= res:\\n                return\\n            if start == n:\\n                res = max(res, len(path))\\n                return\\n            for i in range(start + 1, n + 1):\\n                if s[start:i] not in path:\\n                    backtrack(i, path | {s[start:i]})\\n\\n        n, res = len(s), 0\\n        backtrack(0, set())\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617957,
                "title": "subsequnce-type-solution-dfs",
                "content": "```\\n/*this question is similerly like the no of subsequence that are not repeated \\naddition to this question we were asked to cut the string means find all the subsequnce \\nthat are unique and max the maximimum no of counts */\\n\\nclass Solution {\\nprivate:\\n    int max_cnt = 0;\\n    unordered_set<string>st;\\n    void dfs(string s,int idx){\\n        if(idx == s.size()){\\n            max_cnt = max(max_cnt,(int)st.size());\\n            return;\\n        }\\n        \\n        for(int i = idx;i<s.size();i++){\\n            string temp = s.substr(idx,i-idx+1);\\n            if(st.count(temp) != 0) continue;\\n            st.insert(temp);\\n            dfs(s,i+1);\\n            st.erase(temp);\\n        }\\n        return;\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        dfs(s,0);\\n        return max_cnt;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\nprivate:\\n    int max_cnt = 0;\\n    unordered_set<string>st;\\n    void dfs(string s,int idx){\\n        if(idx == s.size()){\\n            max_cnt = max(max_cnt,(int)st.size());\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1443566,
                "title": "python-backtrack",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.maxy=0\\n        def dfs(a,arr):\\n            if not a:\\n                self.maxy=max(self.maxy,len(arr))\\n            tmp=\\'\\'\\n            for i in range(len(a)):\\n                tmp+=a[i]\\n                if tmp not in arr:\\n                    dfs(a[i+1:],arr+[tmp])\\n        dfs(s,[])\\n        return self.maxy\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.maxy=0\\n        def dfs(a,arr):\\n            if not a:\\n                self.maxy=max(self.maxy,len(arr))\\n            tmp=\\'\\'\\n            for i in range(len(a)):\\n                tmp+=a[i]\\n                if tmp not in arr:\\n                    dfs(a[i+1:],arr+[tmp])\\n        dfs(s,[])\\n        return self.maxy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383700,
                "title": "java-easy-to-understand-backtracking",
                "content": "```\\nclass Solution {\\n    \\n    int max = Integer.MIN_VALUE;\\n    public int maxUniqueSplit(String s) {\\n        \\n        HashSet<String> hs = new HashSet<>();       \\n        backtrack(hs, s, 0);\\n        return max;\\n        \\n    }\\n    \\n    public void backtrack(HashSet<String> hs, String s, int index){\\n        \\n        if(index > s.length()){\\n            return;\\n        }\\n        if(index == s.length()){\\n            max = Math.max(max, hs.size());\\n            return;\\n        }\\n        \\n       for(int i = index; i < s.length(); i++){\\n           String str = s.substring(index, i+1);\\n           if(hs.contains(str) == false){\\n               hs.add(str);\\n               backtrack(hs, s, i+1);\\n               hs.remove(str);\\n           }\\n           \\n       }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    int max = Integer.MIN_VALUE;\\n    public int maxUniqueSplit(String s) {\\n        \\n        HashSet<String> hs = new HashSet<>();       \\n        backtrack(hs, s, 0);\\n        return max;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1369267,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        \\n        \\n        # backTracking O(N ** 2)\\n        \\n        def backTracking(curr_path, s):\\n            if not s:\\n                return len(curr_path)\\n            \\n            res = 0\\n            for i in range(1, len(s) + 1):\\n                sub_string = s[0 : i]\\n                if sub_string not in curr_path:\\n                    res = max(res, backTracking(curr_path + [sub_string], s[i : ]))\\n                    \\n            return res\\n        \\n        L = backTracking([], s)\\n        return L\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        \\n        \\n        # backTracking O(N ** 2)\\n        \\n        def backTracking(curr_path, s):\\n            if not s:\\n                return len(curr_path)\\n            \\n            res = 0\\n            for i in range(1, len(s) + 1):\\n                sub_string = s[0 : i]\\n                if sub_string not in curr_path:\\n                    res = max(res, backTracking(curr_path + [sub_string], s[i : ]))\\n                    \\n            return res\\n        \\n        L = backTracking([], s)\\n        return L\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357604,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n       int ans=0; \\n        \\n int  unique(string s,unordered_set<string> &se){\\n           \\n        if(s.empty())return se.size();   \\n     \\n        for(int j=0;j<s.length();j++){    \\n                \\n            string res=s.substr(0,j+1);\\n            string p=s.substr(j+1);   \\n            if(se.find(res)==se.end()){\\n                se.insert(res);    \\n                int op1 = unique(p,se);\\n                se.erase(res);   \\n                ans=max(ans,op1);   \\n            } \\n        }\\n         \\n      return ans;     \\n   }     \\n        \\n    int maxUniqueSplit(string s){\\n            \\n        unordered_set<string> se;\\n        return unique(s,se);    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int ans=0; \\n        \\n int  unique(string s,unordered_set<string> &se){\\n           \\n        if(s.empty())return se.size();   \\n     \\n        for(int j=0;j<s.length();j++){    \\n                \\n            string res=s.substr(0,j+1);\\n            string p=s.substr(j+1);   \\n            if(se.find(res)==se.end()){\\n                se.insert(res);    \\n                int op1 = unique(p,se);\\n                se.erase(res);   \\n                ans=max(ans,op1);   \\n            } \\n        }\\n         \\n      return ans;     \\n   }     \\n        \\n    int maxUniqueSplit(string s){\\n            \\n        unordered_set<string> se;\\n        return unique(s,se);    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356962,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n        \\n   void uniquestr(string s,unordered_set<string> &se,int &ans){\\n    \\n        if(s.empty())return;   \\n     \\n        for(int j=0;j<s.length();j++){\\n                \\n             string res=s.substr(0,j+1);       // checking every possible string \\n        \\n             if(se.find(res)==se.end()){\\n                se.insert(res);\\n                     \\n                uniquestr(s.substr(j+1),se,ans);\\n                                                          \\n                if(se.size()>ans){             // when string is empty we are checking our ans\\n                    ans=se.size(); \\n                }\\n                se.erase(res);                 // erasing string from set \\n             }                                 // to check other possible  partitions\\n        }\\n   }     \\n        \\n    int maxUniqueSplit(string s){\\n        int ans=0;\\n        unordered_set<string> se;\\n        uniquestr(s,se,ans);    \\n        \\n    return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n   void uniquestr(string s,unordered_set<string> &se,int &ans){\\n    \\n        if(s.empty())return;   \\n     \\n        for(int j=0;j<s.length();j++){\\n                \\n             string res=s.substr(0,j+1);       // checking every possible string \\n        \\n             if(se.find(res)==se.end()){\\n                se.insert(res);\\n                     \\n                uniquestr(s.substr(j+1),se,ans);\\n                                                          \\n                if(se.size()>ans){             // when string is empty we are checking our ans\\n                    ans=se.size(); \\n                }\\n                se.erase(res);                 // erasing string from set \\n             }                                 // to check other possible  partitions\\n        }\\n   }     \\n        \\n    int maxUniqueSplit(string s){\\n        int ans=0;\\n        unordered_set<string> se;\\n        uniquestr(s,se,ans);    \\n        \\n    return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346599,
                "title": "clean-python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.maxVal=0\\n        def backtrack(index,currentSet):\\n            if index==len(s):\\n                self.maxVal=max(self.maxVal,len(currentSet))\\n                return\\n            word=\\'\\'    \\n            for i in range(index,len(s)):\\n                word+=s[i]\\n                if word not in currentSet:\\n                    currentSet.add(word)\\n                    backtrack(i+1,currentSet)\\n                    currentSet.remove(word)\\n        backtrack(0,set())\\n        return self.maxVal\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.maxVal=0\\n        def backtrack(index,currentSet):\\n            if index==len(s):\\n                self.maxVal=max(self.maxVal,len(currentSet))\\n                return\\n            word=\\'\\'    \\n            for i in range(index,len(s)):\\n                word+=s[i]\\n                if word not in currentSet:\\n                    currentSet.add(word)\\n                    backtrack(i+1,currentSet)\\n                    currentSet.remove(word)\\n        backtrack(0,set())\\n        return self.maxVal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225012,
                "title": "c-simple-backtracking-solution-beats-100",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    string s;\\n    unordered_set<string> st;\\n\\n    void recur(int ind) {\\n        if (ind == s.length()) {\\n            ans = max(ans, (int)st.size()); return;\\n        }\\n        string tmp;\\n        for (int i = ind; i < s.length(); ++i)\\n        {\\n            // optimization\\n            if (st.size() + (s.length() - i) <= ans) return;\\n\\n            tmp.push_back(s[i]);\\n\\n            if (st.count(tmp)) continue;\\n\\n            st.insert(tmp);\\n            recur(i + 1);\\n            st.erase(tmp);\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string S) {\\n        s = S;\\n        recur(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    string s;\\n    unordered_set<string> st;\\n\\n    void recur(int ind) {\\n        if (ind == s.length()) {\\n            ans = max(ans, (int)st.size()); return;\\n        }\\n        string tmp;\\n        for (int i = ind; i < s.length(); ++i)\\n        {\\n            // optimization\\n            if (st.size() + (s.length() - i) <= ans) return;\\n\\n            tmp.push_back(s[i]);\\n\\n            if (st.count(tmp)) continue;\\n\\n            st.insert(tmp);\\n            recur(i + 1);\\n            st.erase(tmp);\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string S) {\\n        s = S;\\n        recur(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190417,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxUniqueSplit = function(s) {\\n    const len = s.length\\n    function helper(setSF, fromIndex) {\\n        if (fromIndex === len)  return setSF.size\\n        \\n        let result = 0\\n        for (let toIndex = fromIndex; toIndex < len; toIndex++) {\\n            const substring = s.slice(fromIndex, 1 + toIndex)\\n            if (!setSF.has(substring)) {\\n                setSF.add(substring)\\n                let subresult = helper(setSF, 1 + toIndex)\\n                result = Math.max(result, subresult)\\n                setSF.delete(substring)\\n            }\\n        }\\n\\n        return result\\n    }\\n    \\n    \\n    let setSF = new Set()\\n    let result = helper(setSF, 0)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxUniqueSplit = function(s) {\\n    const len = s.length\\n    function helper(setSF, fromIndex) {\\n        if (fromIndex === len)  return setSF.size\\n        \\n        let result = 0\\n        for (let toIndex = fromIndex; toIndex < len; toIndex++) {\\n            const substring = s.slice(fromIndex, 1 + toIndex)\\n            if (!setSF.has(substring)) {\\n                setSF.add(substring)\\n                let subresult = helper(setSF, 1 + toIndex)\\n                result = Math.max(result, subresult)\\n                setSF.delete(substring)\\n            }\\n        }\\n\\n        return result\\n    }\\n    \\n    \\n    let setSF = new Set()\\n    let result = helper(setSF, 0)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152379,
                "title": "c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string >s;\\n#define pb push_back\\nint ans = INT_MIN;\\nvoid solve(string str) {\\n\\tif (str.size() == 0) {\\n\\t\\tint a = s.size();\\n\\t\\tans = max(ans, a);\\n\\t}\\n\\tfor (int i = 0; i < str.size(); i++) {\\n\\t\\tstring left = str.substr(0, i + 1);\\n\\t\\tstring right = str.substr(i + 1);\\n\\t\\tif (s.find(left) == s.end()) {\\n\\t\\t\\ts.insert(left);\\n\\t\\t\\tsolve(right);\\n\\t\\t\\ts.erase(left);\\n\\t\\t}\\n\\t}\\n}\\n    int maxUniqueSplit(string s) {\\n        \\tsolve(s);\\n\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string >s;\\n#define pb push_back\\nint ans = INT_MIN;\\nvoid solve(string str) {\\n\\tif (str.size() == 0) {\\n\\t\\tint a = s.size();\\n\\t\\tans = max(ans, a);\\n\\t}\\n\\tfor (int i = 0; i < str.size(); i++) {\\n\\t\\tstring left = str.substr(0, i + 1);\\n\\t\\tstring right = str.substr(i + 1);\\n\\t\\tif (s.find(left) == s.end()) {\\n\\t\\t\\ts.insert(left);\\n\\t\\t\\tsolve(right);\\n\\t\\t\\ts.erase(left);\\n\\t\\t}\\n\\t}\\n}\\n    int maxUniqueSplit(string s) {\\n        \\tsolve(s);\\n\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995311,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int ans=0;\\n    int maxUniqueSplit(string s) {\\n        int n = s.size();\\n        rec(s,n,0,0);\\n        return ans;\\n    }\\n    void rec(string s,int n,int val,int k){\\n        if(k>=n){\\n            ans=max(ans,val);\\n            return;\\n        }\\n        for(int i=k;i<n;i++){\\n            if(mp[s.substr(k,i-k+1)]==0){\\n                mp[s.substr(k,i-k+1)]=1;\\n                rec(s,n,val+1,i+1);\\n                mp[s.substr(k,i-k+1)]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    int ans=0;\\n    int maxUniqueSplit(string s) {\\n        int n = s.size();\\n        rec(s,n,0,0);\\n        return ans;\\n    }\\n    void rec(string s,int n,int val,int k){\\n        if(k>=n){\\n            ans=max(ans,val);\\n            return;\\n        }\\n        for(int i=k;i<n;i++){\\n            if(mp[s.substr(k,i-k+1)]==0){\\n                mp[s.substr(k,i-k+1)]=1;\\n                rec(s,n,val+1,i+1);\\n                mp[s.substr(k,i-k+1)]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973890,
                "title": "simple-python-recursive-solution",
                "content": "```python\\nclass Solution(object):\\n    def maxUniqueSplit(self, s):\\n        self.maxVal = 0\\n        def check(string, currString=\"\", vals=set()):\\n            if len(string) == 0:\\n                self.maxVal = max(len(vals), self.maxVal)\\n            else:\\n                check(string[1:], currString+string[0], vals)\\n                if currString+string[0] not in vals:\\n                    check(string[1:], \\'\\', vals.union({currString+string[0]}))\\n            return self.maxVal\\n        \\n        return check(list(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def maxUniqueSplit(self, s):\\n        self.maxVal = 0\\n        def check(string, currString=\"\", vals=set()):\\n            if len(string) == 0:\\n                self.maxVal = max(len(vals), self.maxVal)\\n            else:\\n                check(string[1:], currString+string[0], vals)\\n                if currString+string[0] not in vals:\\n                    check(string[1:], \\'\\', vals.union({currString+string[0]}))\\n            return self.maxVal\\n        \\n        return check(list(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957180,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        unique = set()\\n        ans = 1\\n        \\n\\n        def backtrack(curr):\\n            nonlocal ans, unique\\n            if not curr:\\n                ans = max(len(unique), ans)         \\n            for idx, val in enumerate(curr):\\n                if curr[:idx+1] not in unique:\\n                    unique.add(curr[:idx+1])\\n                    backtrack(curr[idx+1:])\\n                    unique.remove(curr[:idx+1])\\n        backtrack(s)\\n        return ans\\n                \\n```\\n\\nAny solution better than mine? I would be greatly appreciated if you share.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        unique = set()\\n        ans = 1\\n        \\n\\n        def backtrack(curr):\\n            nonlocal ans, unique\\n            if not curr:\\n                ans = max(len(unique), ans)         \\n            for idx, val in enumerate(curr):\\n                if curr[:idx+1] not in unique:\\n                    unique.add(curr[:idx+1])\\n                    backtrack(curr[idx+1:])\\n                    unique.remove(curr[:idx+1])\\n        backtrack(s)\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 951559,
                "title": "java-backtracking-24ms-clean-code-with-time-complexity-o-n-2-n",
                "content": "Time Complexity ```O(n*2^n)```\\nIf string length is n, then we will try to split the string in n or n-1 or n-2 ..... 1 subtrings. In worst case we will have to try all these possible splits. Hence we will have to try ``` nCn + nC(n-1) + nCn-2 + ..... nC1 = 2^n ``` possibilities.\\n\\n```\\nclass Solution {\\n    HashSet<String> uniqueSubstr = new HashSet();\\n\\n    // Time Complexity: O(n*2^n)\\n    public int maxUniqueSplit(String s) {\\n        int len = s.length();\\n        if (len == 0)\\n            return 0;\\n        if (len == 1)\\n        {\\n            return (uniqueSubstr.contains(s) ? 0 : 1);\\n        }\\n        \\n        int maxUniqueSub = 0;\\n        for(int i = 1; i <= len; i++)\\n        {\\n            String temp = s.substring(0, i);\\n            if (!uniqueSubstr.contains(temp))\\n            {\\n                if (i == len)\\n                {\\n                    maxUniqueSub = Math.max(maxUniqueSub, 1);\\n                }\\n                else\\n                {\\n                    uniqueSubstr.add(temp);\\n                    int ans = maxUniqueSplit(s.substring(i,len));\\n                    if (ans > 0)\\n                    {\\n                        maxUniqueSub = Math.max(maxUniqueSub, ans+1);\\n                    }\\n                    uniqueSubstr.remove(temp);\\n                }\\n            }\\n        }\\n        return maxUniqueSub;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```O(n*2^n)```\n``` nCn + nC(n-1) + nCn-2 + ..... nC1 = 2^n ```\n```\\nclass Solution {\\n    HashSet<String> uniqueSubstr = new HashSet();\\n\\n    // Time Complexity: O(n*2^n)\\n    public int maxUniqueSplit(String s) {\\n        int len = s.length();\\n        if (len == 0)\\n            return 0;\\n        if (len == 1)\\n        {\\n            return (uniqueSubstr.contains(s) ? 0 : 1);\\n        }\\n        \\n        int maxUniqueSub = 0;\\n        for(int i = 1; i <= len; i++)\\n        {\\n            String temp = s.substring(0, i);\\n            if (!uniqueSubstr.contains(temp))\\n            {\\n                if (i == len)\\n                {\\n                    maxUniqueSub = Math.max(maxUniqueSub, 1);\\n                }\\n                else\\n                {\\n                    uniqueSubstr.add(temp);\\n                    int ans = maxUniqueSplit(s.substring(i,len));\\n                    if (ans > 0)\\n                    {\\n                        maxUniqueSub = Math.max(maxUniqueSub, ans+1);\\n                    }\\n                    uniqueSubstr.remove(temp);\\n                }\\n            }\\n        }\\n        return maxUniqueSub;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921456,
                "title": "c-backtracking-solution-explanation",
                "content": "We use a set to restore the substring we used (remember to erase the string after backtracking). And a backtracking function to iteratively find the result. (Remember to set up for the termination condition)\\n```\\nclass Solution \\n{\\npublic:\\n    int maxUniqueSplit(string s) \\n    {\\n        unordered_set<string> mp;\\n        int ret = 0;\\n        helper(s, mp, 0, ret);\\n        return ret;\\n    }\\n    void helper(string s, unordered_set<string>& mp, int cnt, int& ret)\\n    {\\n        if(s == \"\")\\n        {\\n            ret = max(ret, cnt);\\n            return;\\n        }\\n        for(int i = 1; i <= s.size(); i++)\\n        {\\n            if(!mp.count(s.substr(0, i)))\\n            {\\n                mp.insert(s.substr(0, i));\\n                helper(s.substr(i), mp, cnt+1, ret);\\n                mp.erase(mp.find(s.substr(0, i)));\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxUniqueSplit(string s) \\n    {\\n        unordered_set<string> mp;\\n        int ret = 0;\\n        helper(s, mp, 0, ret);\\n        return ret;\\n    }\\n    void helper(string s, unordered_set<string>& mp, int cnt, int& ret)\\n    {\\n        if(s == \"\")\\n        {\\n            ret = max(ret, cnt);\\n            return;\\n        }\\n        for(int i = 1; i <= s.size(); i++)\\n        {\\n            if(!mp.count(s.substr(0, i)))\\n            {\\n                mp.insert(s.substr(0, i));\\n                helper(s.substr(i), mp, cnt+1, ret);\\n                mp.erase(mp.find(s.substr(0, i)));\\n            }\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883730,
                "title": "swift-dfs-backtracking-beats-100-40ms",
                "content": "Had to follow the hint, but also using other constraints to limit the amount of permutations we need to go through. See below. With this addition: ```&& count + str.count-j > ret ``` the routine execution time was reduced ten-fold. If we don\\'t practically have possibility to beat the current highest unique split count (in other words there\\'s not enough single chars left),  then there\\'s no need to continue with that permutation subtree and we can backtrack. Also, string operations are a bitch with Swift (8-16 bit unicode), so using an array of characters instead.\\n\\n```\\nclass Solution {\\n     func maxUniqueSplit(_ s: String) -> Int {\\n         var strSet = Set<String>()\\n         let str = Array(s)\\n         var ret = 0\\n        \\n         func helper(_ i: Int, _ count: Int) {\\n             if i == str.count { ret = max(count, ret); return }\\n            \\n             for j in i..<str.count {\\n                 let subStr = \"\\\\(str[i...j].reduce(\"\"){$0+\"\\\\($1)\"})\"\\n                 if !strSet.contains(subStr) && count + str.count-j > ret {\\n                     strSet.insert(subStr)\\n                     helper(j+1, count + 1)\\n\\t\\t\\t\\t\\t strSet.remove(subStr) // restore the memo-map for next permutations\\n                 }\\n             }\\n         }\\n         helper(0,0)\\n         return ret        \\n     }\\n}",
                "solutionTags": [],
                "code": "```&& count + str.count-j > ret ```",
                "codeTag": "Unknown"
            },
            {
                "id": 868544,
                "title": "cpp-simple-backtraking",
                "content": "```\\n\\nclass Solution {\\npublic:\\n     unordered_map<string, int>mp;\\n    int ans;\\n    void dfs(string s, int pos, int n)\\n    {\\n        if(pos==n+1)\\n        {\\n             ans= max(ans, (int)mp.size());\\n               return;\\n        }\\n        string d=\"\";\\n       for(int i=pos; i<=n; i++)\\n       {\\n             d+=s[i];\\n           if(mp.find(d)==mp.end())\\n           {\\n               mp[d]++;\\n               dfs(s, i+1, n);\\n               mp.erase(d);\\n           }\\n       }\\n    }\\n    int maxUniqueSplit(string s) {\\n         mp.clear();\\n         ans=0;\\n       dfs(s,0,s.size()-1) ;\\n         return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n     unordered_map<string, int>mp;\\n    int ans;\\n    void dfs(string s, int pos, int n)\\n    {\\n        if(pos==n+1)\\n        {\\n             ans= max(ans, (int)mp.size());\\n               return;\\n        }\\n        string d=\"\";\\n       for(int i=pos; i<=n; i++)\\n       {\\n             d+=s[i];\\n           if(mp.find(d)==mp.end())\\n           {\\n               mp[d]++;\\n               dfs(s, i+1, n);\\n               mp.erase(d);\\n           }\\n       }\\n    }\\n    int maxUniqueSplit(string s) {\\n         mp.clear();\\n         ans=0;\\n       dfs(s,0,s.size()-1) ;\\n         return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865562,
                "title": "java-simple-and-efficient-time-complexity-explained",
                "content": "\\n```\\npublic int maxUniqueSplit(String s) {\\n        /*\\n            Time : O(2 ^ n-1), where \\'n\\' is length of String\\n            Space: O(n)\\n            \\n            For example if input is \"1234\", possibilities                  \\n            \\n                1   2   3   4       -> 1\\n                        34          -> 2\\n                    23  4           -> 3\\n                    234             -> 4                    \\n                12  3   4           -> 5\\n                    34              -> 6                \\n                123 4               -> 7                \\n                1234                -> 8\\n                \\n                2 ^ 4-1 => 2^3 => 8 possibilities\\n        */\\n        Set<String> set = new HashSet<>();\\n        max = 0;\\n        dft(set, s.toCharArray(), 0);\\n        return max;\\n    }\\n    int max = 0;\\n    \\n    void dft(Set<String> set, char[] s, int start) {\\n        if (start == s.length) {\\n            max = Math.max(max, set.size());\\n            return;\\n        }\\n        StringBuilder curr = new StringBuilder();\\n        for (int i = start; i < s.length; i++) {\\n            if (set.size() + s.length - i < max) {\\n                // Largest size this path can reach is still less than current \\'max\\'\\n                // skipping will save search paths\\n                return;\\n            }\\n            curr.append(s[i]);\\n            String subStr = curr.toString();\\n            // If the subString already exists and can\\'t be added\\n            // taking the path will not lead to subsets of all characters so no need to follow this path\\n            if (!set.contains(subStr)) {\\n                set.add(subStr);\\n                dft(set, s, i+1);\\n                set.remove(subStr);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxUniqueSplit(String s) {\\n        /*\\n            Time : O(2 ^ n-1), where \\'n\\' is length of String\\n            Space: O(n)\\n            \\n            For example if input is \"1234\", possibilities                  \\n            \\n                1   2   3   4       -> 1\\n                        34          -> 2\\n                    23  4           -> 3\\n                    234             -> 4                    \\n                12  3   4           -> 5\\n                    34              -> 6                \\n                123 4               -> 7                \\n                1234                -> 8\\n                \\n                2 ^ 4-1 => 2^3 => 8 possibilities\\n        */\\n        Set<String> set = new HashSet<>();\\n        max = 0;\\n        dft(set, s.toCharArray(), 0);\\n        return max;\\n    }\\n    int max = 0;\\n    \\n    void dft(Set<String> set, char[] s, int start) {\\n        if (start == s.length) {\\n            max = Math.max(max, set.size());\\n            return;\\n        }\\n        StringBuilder curr = new StringBuilder();\\n        for (int i = start; i < s.length; i++) {\\n            if (set.size() + s.length - i < max) {\\n                // Largest size this path can reach is still less than current \\'max\\'\\n                // skipping will save search paths\\n                return;\\n            }\\n            curr.append(s[i]);\\n            String subStr = curr.toString();\\n            // If the subString already exists and can\\'t be added\\n            // taking the path will not lead to subsets of all characters so no need to follow this path\\n            if (!set.contains(subStr)) {\\n                set.add(subStr);\\n                dft(set, s, i+1);\\n                set.remove(subStr);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859704,
                "title": "c-backtracking-with-string-view-and-unordered-set",
                "content": "```\\nint maxUniqueSplit(string s) {\\n\\tunordered_set<string_view> uset;\\n\\treturn dfs(s, uset, 0); \\n}\\n\\nint dfs(string& s, unordered_set<string_view>& uset, int i){\\n\\tif(i==s.length()) return 0;\\n\\tint res=0;\\n\\tfor(size_t len=1; len<=s.length()-i; len++){\\n\\t\\tif(!uset.count({s.c_str()+i, len})){\\n\\t\\t\\tuset.insert({s.c_str()+i, len});\\n\\t\\t\\tres = max(res, 1 + dfs(s, uset, i+len));\\n\\t\\t\\tuset.erase({s.c_str()+i, len});\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxUniqueSplit(string s) {\\n\\tunordered_set<string_view> uset;\\n\\treturn dfs(s, uset, 0); \\n}\\n\\nint dfs(string& s, unordered_set<string_view>& uset, int i){\\n\\tif(i==s.length()) return 0;\\n\\tint res=0;\\n\\tfor(size_t len=1; len<=s.length()-i; len++){\\n\\t\\tif(!uset.count({s.c_str()+i, len})){\\n\\t\\t\\tuset.insert({s.c_str()+i, len});\\n\\t\\t\\tres = max(res, 1 + dfs(s, uset, i+len));\\n\\t\\t\\tuset.erase({s.c_str()+i, len});\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859030,
                "title": "java-solution-using-backtracking",
                "content": "class Solution {\\n    public int maxUniqueSplit(String s) {\\n      int maximum[]=new int[1];\\n      \\n      HashSet<String> unique=new HashSet<>();\\n        \\n      rec(s,unique,maximum,0); \\n        \\n      return maximum[0];  \\n        \\n    }\\n    \\n    \\n    public void rec(String s,HashSet<String> unique,int []maximum,int count){\\n        if(s.equals(\"\")){\\n            maximum[0]=Math.max(maximum[0],count);\\n            return;\\n        }\\n        \\n        \\n        for(int i=1;i<=s.length();i++){\\n            \\n            String p=s.substring(0,i);\\n            \\n            if(! unique.contains(p)){\\n                unique.add(p);\\n                rec(s.substring(i),unique,maximum,count+1);\\n                unique.remove(p);\\n            }\\n            \\n            \\n            \\n        }\\n        \\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxUniqueSplit(String s) {\\n      int maximum[]=new int[1];\\n      \\n      HashSet<String> unique=new HashSet<>();\\n        \\n      rec(s,unique,maximum,0); \\n        \\n      return maximum[0];  \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 858554,
                "title": "python-dfs",
                "content": "```py\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        n = len(s)\\n        self.res = 0\\n        def helper(idx, cur_word, str_set):\\n            if idx == n:\\n                self.res = max(self.res, len(str_set))\\n                return\\n            # don\\'t split\\n            helper(idx + 1, cur_word + s[idx], str_set)\\n            # split\\n            if cur_word + s[idx] not in str_set:\\n                helper(idx + 1, \\'\\', str_set | {cur_word + s[idx]})\\n            \\n        helper(0, \\'\\', set())\\n        return self.res\\n```\\t\\t",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        n = len(s)\\n        self.res = 0\\n        def helper(idx, cur_word, str_set):\\n            if idx == n:\\n                self.res = max(self.res, len(str_set))\\n                return\\n            # don\\'t split\\n            helper(idx + 1, cur_word + s[idx], str_set)\\n            # split\\n            if cur_word + s[idx] not in str_set:\\n                helper(idx + 1, \\'\\', str_set | {cur_word + s[idx]})\\n            \\n        helper(0, \\'\\', set())\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856610,
                "title": "c-recursive-solution-with-binary-search-8-ms",
                "content": "The idea behind is that if there are at most `n` unique strings, there must be a way to split the string such that there are  `m < n` uniqle strings.\\nSo if we can find `m` unique strings, there are no points of trying solution with less splits, and vice versa.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> p;\\n        int n = s.length();\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int m = r - (r - l) / 2;\\n            if (solve(0, n, m, s, p))\\n                l = m;\\n            else\\n                r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    bool solve(int i, int n, int m, string &s, unordered_set<string> &p) {\\n        if (m == 1)\\n            return p.find({s.begin()+i, s.end()}) == p.end();\\n        for (int l = 1; l <= n - i - m + 1; l++) {\\n            string curr(s.begin()+i, s.begin()+i+l);\\n            if (p.find(curr) == p.end()) {\\n                p.insert(curr);\\n                bool res = solve(i+l, n, m-1, s, p);\\n                p.erase(curr);\\n                if (res)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> p;\\n        int n = s.length();\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int m = r - (r - l) / 2;\\n            if (solve(0, n, m, s, p))\\n                l = m;\\n            else\\n                r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    bool solve(int i, int n, int m, string &s, unordered_set<string> &p) {\\n        if (m == 1)\\n            return p.find({s.begin()+i, s.end()}) == p.end();\\n        for (int l = 1; l <= n - i - m + 1; l++) {\\n            string curr(s.begin()+i, s.begin()+i+l);\\n            if (p.find(curr) == p.end()) {\\n                p.insert(curr);\\n                bool res = solve(i+l, n, m-1, s, p);\\n                p.erase(curr);\\n                if (res)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856370,
                "title": "easy-understanding-backtracking-solution-python",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.res = 1\\n        \\n        # input: start index, seen set\\n        def dfs(idx, seen):\\n            if idx == len(s):\\n                self.res = max(self.res, len(seen))\\n                return\\n\\n            for end in range(idx+1, len(s)+1):\\n                cur = s[idx:end]\\n                if cur not in seen:\\n                    seen.add(cur)\\n                    dfs(end, seen)\\n                    seen.remove(cur)\\n\\n        dfs(0, set())\\n        return self.res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.res = 1\\n        \\n        # input: start index, seen set\\n        def dfs(idx, seen):\\n            if idx == len(s):\\n                self.res = max(self.res, len(seen))\\n                return\\n\\n            for end in range(idx+1, len(s)+1):\\n                cur = s[idx:end]\\n                if cur not in seen:\\n                    seen.add(cur)\\n                    dfs(end, seen)\\n                    seen.remove(cur)\\n\\n        dfs(0, set())\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855901,
                "title": "java-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int max=-1;\\n    public int maxUniqueSplit(String s) {\\n        ArrayList<String> set=new ArrayList<>();\\n       helper(s,0,\"\",set,0);\\n        return max;\\n    }\\n    public void helper(String s,int i,String temp,ArrayList<String> set,int count){\\n        if(i==s.length()){\\n           \\n            max=Math.max(max,set.size());\\n            return;\\n        }\\n        \\n        for(int k=i;k<s.length();k++){\\n            temp+=s.charAt(k)+\"\";\\n            if(set.contains(temp)){\\n          \\n             helper(s,k+1,temp,set,count);\\n            }\\n            else{\\n                set.add(temp);\\n                helper(s,k+1,\"\",set,count+1);\\n                set.remove(set.size()-1); \\n                 }\\n\\t\\t\\t}\\n        \\n               }\\n             }\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    int max=-1;\\n    public int maxUniqueSplit(String s) {\\n        ArrayList<String> set=new ArrayList<>();\\n       helper(s,0,\"\",set,0);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 855895,
                "title": "java-simple-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        return dfs(s, 0, new HashSet<>(), 1);\\n    }\\n    \\n    private int dfs(String s, int index, Set<String> set, int cur) {\\n        if (cur == s.length() + 1) {\\n            if (index == s.length()) {\\n                return set.size();\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        String sub = s.substring(index, cur);\\n        int answer = 0;\\n        if (!set.contains(sub)) {\\n            set.add(sub);\\n            answer = dfs(s, cur, set, cur + 1);\\n            set.remove(sub);\\n        }\\n        \\n        return Math.max(answer, dfs(s, index, set, cur + 1));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        return dfs(s, 0, new HashSet<>(), 1);\\n    }\\n    \\n    private int dfs(String s, int index, Set<String> set, int cur) {\\n        if (cur == s.length() + 1) {\\n            if (index == s.length()) {\\n                return set.size();\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        String sub = s.substring(index, cur);\\n        int answer = 0;\\n        if (!set.contains(sub)) {\\n            set.add(sub);\\n            answer = dfs(s, cur, set, cur + 1);\\n            set.remove(sub);\\n        }\\n        \\n        return Math.max(answer, dfs(s, index, set, cur + 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855790,
                "title": "simple-python3-backtracking-solution-w-explanation",
                "content": "Hello everyone! This solution is a recursive **backtracking** solution which I have implemented in python. I derived it as follows:\\n\\nWe know that in splitting a string of length n, we have n-1 places to break the string in two. Therefore, for our input string s, we want to break the string at each of these partition indices and evaluate the resulting strings recursively. We will add the string before the partition to our possible result set, and the second half will be recurred over.\\n\\nIf we\\'ve already added the piece before the partition to the result, though, we don\\'t want to investigate this branch of the recursion because it will result in a duplicate substring.\\n\\nOnce we recur to the point at which we reach a string of length 1, we first check if we\\'ve already seen that substring. If we haven\\'t seen it yet, we have found one possible solution of maximum unique substrings. We will pass the number of substrings back up to the parent call, where it is evaluated against all the other partitions for a maximum. Here also we can avoid solutions with duplicate substrings by returning 0 if we *have* seen the single-character substring.\\n\\n**Note that the above step is also achievable by looping to  `len(s)+1` and instead checking if our substring is empty*.\\n\\nEach parent call evaluates the maximum of all the partition calls and the number of substrings so far (if we think of the recursion as branches, the root of the tree is the initial call, whose return value is the maximum of all branches, whose return values are the maximum of all leaves).\\n\\nThis is a backtracking solution -- if you\\'re looking for the add and remove steps, I just avoid mutating the set for each iteration of the loop by simply doing the union of the set with the new substring.\\n\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        def maxU(s, soFar=set()):\\n            if len(s) == 1 and s in soFar:\\n                return 0\\n            maxSplit = len(soFar)+1\\n            for partition in range(1, len(s)):\\n                a = s[:partition]\\n                b = s[partition:]\\n                if a not in soFar:\\n                    maxSplit = max(maxSplit, maxU(b, soFar|{a}))\\n            return maxSplit\\n        return maxU(s)\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        def maxU(s, soFar=set()):\\n            if len(s) == 1 and s in soFar:\\n                return 0\\n            maxSplit = len(soFar)+1\\n            for partition in range(1, len(s)):\\n                a = s[:partition]\\n                b = s[partition:]\\n                if a not in soFar:\\n                    maxSplit = max(maxSplit, maxU(b, soFar|{a}))\\n            return maxSplit\\n        return maxU(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855709,
                "title": "swift-dfs-easy-to-understand",
                "content": "```swift\\nclass Solution {\\n\\n    var visited = Set<String>()\\n    var res = 0;\\n\\n    func maxUniqueSplit(_ s: String) -> Int {\\n        dfs(Array(s), &visited, 0)\\n        return res\\n    }\\n\\n    private func dfs(_ s: [Character], _ visited: inout Set<String>, _ start: Int) {\\n        res = max(res, visited.count)\\n        var i = start\\n        while i < s.count {\\n            i += 1\\n            let pre = String(s[start..<i])\\n            if visited.contains(pre) { continue }\\n            visited.insert(pre)\\n            dfs(s, &visited, i)\\n            visited.remove(pre)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n\\n    var visited = Set<String>()\\n    var res = 0;\\n\\n    func maxUniqueSplit(_ s: String) -> Int {\\n        dfs(Array(s), &visited, 0)\\n        return res\\n    }\\n\\n    private func dfs(_ s: [Character], _ visited: inout Set<String>, _ start: Int) {\\n        res = max(res, visited.count)\\n        var i = start\\n        while i < s.count {\\n            i += 1\\n            let pre = String(s[start..<i])\\n            if visited.contains(pre) { continue }\\n            visited.insert(pre)\\n            dfs(s, &visited, i)\\n            visited.remove(pre)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855637,
                "title": "java-backtracking-with-comments",
                "content": "```\\nclass Solution {\\npublic static int maxUniqueSplit(String str) {\\n        HashSet<String> hs = new HashSet<>();\\n        max = Integer.MIN_VALUE;\\n        Deque<String> output = new ArrayDeque<>();\\n        recur(str, output);\\n        return max;\\n    }\\n    static int max;\\n    public static void recur(String str, Deque<String> output)\\n    {\\n        // if all characters of the input String are processed,\\n        // print the output String\\n        if (str.length() == 0)\\n        {\\n            HashSet<String> hs = new HashSet<>();\\n            Iterator<String> i = output.descendingIterator();\\n            while(i.hasNext()){\\n                hs.add(i.next());\\n            }\\n            max = Math.max(max , hs.size());\\n            return;\\n        }\\n\\n        // add each substring [0, i] in the output string and recur for\\n        // remaining substring [i+1, n-1]\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            // push substring [0, i] into output string\\n            output.addLast(str.substring(0, i + 1));\\n\\n            // recur for remaining String [i+1, n-1]\\n            recur(str.substring(i + 1), output);\\n\\n            // backtrack (remove current substring from string)\\n            output.pollLast();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic static int maxUniqueSplit(String str) {\\n        HashSet<String> hs = new HashSet<>();\\n        max = Integer.MIN_VALUE;\\n        Deque<String> output = new ArrayDeque<>();\\n        recur(str, output);\\n        return max;\\n    }\\n    static int max;\\n    public static void recur(String str, Deque<String> output)\\n    {\\n        // if all characters of the input String are processed,\\n        // print the output String\\n        if (str.length() == 0)\\n        {\\n            HashSet<String> hs = new HashSet<>();\\n            Iterator<String> i = output.descendingIterator();\\n            while(i.hasNext()){\\n                hs.add(i.next());\\n            }\\n            max = Math.max(max , hs.size());\\n            return;\\n        }\\n\\n        // add each substring [0, i] in the output string and recur for\\n        // remaining substring [i+1, n-1]\\n        for (int i = 0; i < str.length(); i++)\\n        {\\n            // push substring [0, i] into output string\\n            output.addLast(str.substring(0, i + 1));\\n\\n            // recur for remaining String [i+1, n-1]\\n            recur(str.substring(i + 1), output);\\n\\n            // backtrack (remove current substring from string)\\n            output.pollLast();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855617,
                "title": "c-python-backtracking-trie-explained-324ms",
                "content": "As it can be easily figured out that we need to use backtracking by looking at the constraints.\\n\\nAt each function call, we can use unordered_set or set to check whether current string is unique or not.\\n\\nUnordered_set  Time - 1752ms and Memory - 365MB\\nSet Time - 1996ms and Memory - 422MB\\n**C++ Solution**\\n```\\n// unordered_set solution\\n\\tint ans;\\n    void recFunc(string s, int idx, int len, unordered_set<string> hmap){\\n        if(idx == len){\\n            if(hmap.size()>ans)  ans = hmap.size();\\n            return;\\n        }\\n        for(int i=idx; i<len; i++){\\n            string curr = s.substr(idx, i-idx+1);\\n            if(hmap.find(curr)==hmap.end()){\\n                hmap.insert(curr);\\n                recFunc(s, i+1, len, hmap);\\n                hmap.erase(curr);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        recFunc(s, 0, s.size(), {});\\n        return ans;\\n    }\\n```\\n\\nNow we will going to optimize it, as you can see we need to first check whether a word is present or not. If not then we will going to add it. We can use Trie to search and add the word efficiently.\\n\\n**Trie  Time - 324ms and Memory - 20MB** \\n**C++ Solution**\\n```\\n// For storing information of Trie \\nstruct node{\\n    char val;\\n    node* hmap[26];\\n    bool terminate;\\n\\tnode(char ch): val(ch), terminate(false){\\n        for(auto &e :hmap)  e = NULL;\\n    }\\n};\\n\\n// Implementing Trie \\nclass Trie{\\npublic:\\n    node* head;\\n    int size;\\n    Trie(){\\n        head = new node(\\'0\\');\\n    }\\n    void add(string word){\\n        node* iter = head;\\n        for(auto w: word){\\n            if(iter->hmap[w-\\'a\\'] == NULL)   iter->hmap[w-\\'a\\'] = new node(w-\\'a\\');\\n            iter = iter->hmap[w-\\'a\\'];\\n        }\\n        size++;\\n        iter->terminate = true;\\n    }\\n    bool search(string word){\\n        node* iter = head;\\n        for(auto w: word){\\n            if(iter->hmap[w-\\'a\\'] == NULL)   return 0;\\n            iter = iter->hmap[w-\\'a\\'];\\n        }\\n        if(iter->terminate) return 1;\\n        return 0;\\n    }\\n    void remove(string word){\\n        node* iter = head;\\n        for(auto w: word){\\n            iter = iter->hmap[w-\\'a\\'];\\n        }\\n        size--;\\n        iter->terminate = 0;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    Trie obj;\\n    void backTrack(string s, int idx, int n){\\n        if(idx == n){\\n            if(obj.size>ans)  ans = obj.size;\\n            return;\\n        }\\n        for(int i=idx; i<n; i++){\\n            string curr = s.substr(idx, i-idx+1);\\n            if(!obj.search(curr)){\\n                obj.add(curr);\\n                backTrack(s, i+1, n);\\n                obj.remove(curr);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        backTrack(s, 0, s.size());\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python Solution**\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.hmap = {}\\n        self.terminate = False\\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(\"0\")\\n        self.size = 0\\n    \\n    def search(self, word):\\n        it = self.head\\n        for i in word:\\n            if i not in it.hmap:    return False\\n            it = it.hmap[i]\\n        if it.terminate:    return True\\n        return False\\n    \\n    def addWord(self, word):\\n        it = self.head\\n        for i in word:\\n            if i not in it.hmap:    it.hmap[i] = Node(i)\\n            it = it.hmap[i]\\n        it.terminate, self.size = True, self.size + 1\\n        \\n    def removeWord(self, word):\\n        it = self.head\\n        for i in word:\\n            it = it.hmap[i]\\n        it.terminate, self.size = False, self.size -1\\n        \\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans, obj = 0, Trie()\\n        def backTrack(s, idx, n):\\n            nonlocal ans\\n            if idx == n:\\n                ans = max(ans, obj.size)\\n                return\\n            for i in range(idx, n):\\n                if not obj.search(s[idx: i+1]):\\n                    obj.addWord(s[idx: i+1])\\n                    backTrack(s, i+1, n)\\n                    obj.removeWord(s[idx: i+1])\\n        backTrack(s, 0, len(s))\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\n// unordered_set solution\\n\\tint ans;\\n    void recFunc(string s, int idx, int len, unordered_set<string> hmap){\\n        if(idx == len){\\n            if(hmap.size()>ans)  ans = hmap.size();\\n            return;\\n        }\\n        for(int i=idx; i<len; i++){\\n            string curr = s.substr(idx, i-idx+1);\\n            if(hmap.find(curr)==hmap.end()){\\n                hmap.insert(curr);\\n                recFunc(s, i+1, len, hmap);\\n                hmap.erase(curr);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        recFunc(s, 0, s.size(), {});\\n        return ans;\\n    }\\n```\n```\\n// For storing information of Trie \\nstruct node{\\n    char val;\\n    node* hmap[26];\\n    bool terminate;\\n\\tnode(char ch): val(ch), terminate(false){\\n        for(auto &e :hmap)  e = NULL;\\n    }\\n};\\n\\n// Implementing Trie \\nclass Trie{\\npublic:\\n    node* head;\\n    int size;\\n    Trie(){\\n        head = new node(\\'0\\');\\n    }\\n    void add(string word){\\n        node* iter = head;\\n        for(auto w: word){\\n            if(iter->hmap[w-\\'a\\'] == NULL)   iter->hmap[w-\\'a\\'] = new node(w-\\'a\\');\\n            iter = iter->hmap[w-\\'a\\'];\\n        }\\n        size++;\\n        iter->terminate = true;\\n    }\\n    bool search(string word){\\n        node* iter = head;\\n        for(auto w: word){\\n            if(iter->hmap[w-\\'a\\'] == NULL)   return 0;\\n            iter = iter->hmap[w-\\'a\\'];\\n        }\\n        if(iter->terminate) return 1;\\n        return 0;\\n    }\\n    void remove(string word){\\n        node* iter = head;\\n        for(auto w: word){\\n            iter = iter->hmap[w-\\'a\\'];\\n        }\\n        size--;\\n        iter->terminate = 0;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    Trie obj;\\n    void backTrack(string s, int idx, int n){\\n        if(idx == n){\\n            if(obj.size>ans)  ans = obj.size;\\n            return;\\n        }\\n        for(int i=idx; i<n; i++){\\n            string curr = s.substr(idx, i-idx+1);\\n            if(!obj.search(curr)){\\n                obj.add(curr);\\n                backTrack(s, i+1, n);\\n                obj.remove(curr);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        backTrack(s, 0, s.size());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.hmap = {}\\n        self.terminate = False\\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(\"0\")\\n        self.size = 0\\n    \\n    def search(self, word):\\n        it = self.head\\n        for i in word:\\n            if i not in it.hmap:    return False\\n            it = it.hmap[i]\\n        if it.terminate:    return True\\n        return False\\n    \\n    def addWord(self, word):\\n        it = self.head\\n        for i in word:\\n            if i not in it.hmap:    it.hmap[i] = Node(i)\\n            it = it.hmap[i]\\n        it.terminate, self.size = True, self.size + 1\\n        \\n    def removeWord(self, word):\\n        it = self.head\\n        for i in word:\\n            it = it.hmap[i]\\n        it.terminate, self.size = False, self.size -1\\n        \\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans, obj = 0, Trie()\\n        def backTrack(s, idx, n):\\n            nonlocal ans\\n            if idx == n:\\n                ans = max(ans, obj.size)\\n                return\\n            for i in range(idx, n):\\n                if not obj.search(s[idx: i+1]):\\n                    obj.addWord(s[idx: i+1])\\n                    backTrack(s, i+1, n)\\n                    obj.removeWord(s[idx: i+1])\\n        backTrack(s, 0, len(s))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855502,
                "title": "go-recursive",
                "content": "The problem wants maximum count of substring, and concatenation of all substrings form original string.\\n\\nTo get maximum count of substring, it tends to cut string as small as possible.\\n\\nTake `abcdefg` as an example, separate into `a`, `b`, `c`, `d`, `e`, ..., etc. gets maximum substring count.\\n\\nHowever, to make each substring unique, the shorter substring, the higher chances to collides.\\n\\nTake `aaa` as an example, separations into `a`, `a`, `a` causes duplicates which is not allowed.\\n\\nWith these two constraints, it seems that every combinations should be tried, because even for same location, already separated substrings might cause different result.\\n\\nTake `aaabaaa` as an example:\\n\\n- separate first `aaa` into `a` & `aa`, rest of string `baaa` cannot contains `a` & `aa`  since already used, and maximum separations should be `b`, `aaa`\\n\\n- take first `aaa` as a substring, rest of string `baaa` cannot contains `aaa` since already used, and maximum separations should be `b`, `a`, `aa`\\n\\nSo, dp technique of memoization cannot be applied in thie problem, because in order to faster computation, memo needs to have same results when start & end is determined. By example above demonstrated, this condition does not hold.\\n\\nBelow is my code\\n\\n```go\\nfunc maxUniqueSplit(s string) int {\\n\\tset := make(map[string]bool)\\n\\n\\treturn recursive(s, 0, set)\\n}\\n\\nfunc recursive(str string, start int, set map[string]bool) int {\\n\\t// terminate condition\\n\\tif start == len(str) {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tmaxPossible := math.MinInt32\\n\\n\\tfor i := start; i < len(str); i++ {\\n\\t\\tif !set[str[start:i+1]] {\\n\\t\\t\\tset[str[start:i+1]] = true\\n\\n\\t\\t\\tafter := recursive(str, i+1, set)\\n\\t\\t\\tset[str[start:i+1]] = false\\n\\n\\t\\t\\tif after == -1 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxPossible = max(maxPossible, after+1)\\n\\t\\t}\\n\\t}\\n\\n\\tif maxPossible == math.MinInt32 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn maxPossible\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```go\\nfunc maxUniqueSplit(s string) int {\\n\\tset := make(map[string]bool)\\n\\n\\treturn recursive(s, 0, set)\\n}\\n\\nfunc recursive(str string, start int, set map[string]bool) int {\\n\\t// terminate condition\\n\\tif start == len(str) {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tmaxPossible := math.MinInt32\\n\\n\\tfor i := start; i < len(str); i++ {\\n\\t\\tif !set[str[start:i+1]] {\\n\\t\\t\\tset[str[start:i+1]] = true\\n\\n\\t\\t\\tafter := recursive(str, i+1, set)\\n\\t\\t\\tset[str[start:i+1]] = false\\n\\n\\t\\t\\tif after == -1 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxPossible = max(maxPossible, after+1)\\n\\t\\t}\\n\\t}\\n\\n\\tif maxPossible == math.MinInt32 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn maxPossible\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855413,
                "title": "c-using-trie",
                "content": "```\\n\\ntypedef struct trie\\n{\\n    int val;\\n    struct trie* next[26];\\n}trie;\\n\\ntrie * createone()\\n{\\n    trie *obj = (trie*)malloc(sizeof(trie));\\n    obj->val = 0;\\n    for(int i=0;i<26;i++)\\n        obj->next[i] = NULL;\\n    return obj;\\n}\\n\\nint insert(trie*obj,char *a)\\n{\\n    if(*a==0) return 0;\\n    int ans = -1;\\n    trie* or = obj;\\n    while(*a)\\n    {\\n        int temp = *a-\\'a\\';\\n        if(obj->next[temp]==NULL || obj->next[temp]->val==0)\\n        {\\n            if(obj->next[temp]==NULL)\\n                obj->next[temp] = createone();\\n            obj->next[temp]->val = 1;\\n            int ret = insert(or, a+1);\\n            if(ret>=0)\\n            {\\n                if(ans<ret+1) ans = ret+1;\\n            }\\n            obj->next[temp]->val = 0;\\n        }\\n        obj=obj->next[temp];\\n        a++;\\n    }\\n    \\n    return ans;\\n}\\n\\n\\nint maxUniqueSplit(char * s){\\n\\n    trie* obj = createone();\\n    \\n    return insert(obj,s);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntypedef struct trie\\n{\\n    int val;\\n    struct trie* next[26];\\n}trie;\\n\\ntrie * createone()\\n{\\n    trie *obj = (trie*)malloc(sizeof(trie));\\n    obj->val = 0;\\n    for(int i=0;i<26;i++)\\n        obj->next[i] = NULL;\\n    return obj;\\n}\\n\\nint insert(trie*obj,char *a)\\n{\\n    if(*a==0) return 0;\\n    int ans = -1;\\n    trie* or = obj;\\n    while(*a)\\n    {\\n        int temp = *a-\\'a\\';\\n        if(obj->next[temp]==NULL || obj->next[temp]->val==0)\\n        {\\n            if(obj->next[temp]==NULL)\\n                obj->next[temp] = createone();\\n            obj->next[temp]->val = 1;\\n            int ret = insert(or, a+1);\\n            if(ret>=0)\\n            {\\n                if(ans<ret+1) ans = ret+1;\\n            }\\n            obj->next[temp]->val = 0;\\n        }\\n        obj=obj->next[temp];\\n        a++;\\n    }\\n    \\n    return ans;\\n}\\n\\n\\nint maxUniqueSplit(char * s){\\n\\n    trie* obj = createone();\\n    \\n    return insert(obj,s);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 855409,
                "title": "java-backtracking-100",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxUniqueSplit(String s) {\\n        dfs(s, 0, new HashSet<String>());\\n        return max;\\n    }\\n    private void dfs(String s, int pos, HashSet<String> seen) {\\n        if(pos == s.length()) {\\n            max = Math.max(max, seen.size());\\n            return;\\n        }\\n        for(int i = pos; i < s.length(); i++) {\\n            String cur = s.substring(pos, i + 1);\\n            if(seen.contains(cur)) continue;\\n            seen.add(cur);\\n            dfs(s, i + 1, seen);\\n            seen.remove(cur);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int max = 0;\\n    public int maxUniqueSplit(String s) {\\n        dfs(s, 0, new HashSet<String>());\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 855371,
                "title": "python3-standard-backtracking-bfs-solution-with-explanation",
                "content": "**My backtracking template : **\\n\\n![image](https://assets.leetcode.com/users/images/386b3033-4cce-45c7-990c-cf1698fe83ea_1600579499.9221513.png)\\n\\nThis process could be widely applied in many backtracking problems. I will take this problem as an example\\nThere are only two things you need to concern: \\n\\t1. For each letter, you can decide whether you want to put it in result dictionary or not. \\n\\t2. If you want to put it inside, what condition it should be satisfied. \\n\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        return self.bt(s, set(), 0,1, 0)\\n    \\n   \\n   def bt(self, s, d, l, r, maxl): \\n        if r>=len(s):\\n            maxl = max(len(d), maxl)\\n            return maxl\\n        else:\\n            for r in range(l+1,len(s)+1):  \\n                if s[l:r] not in d:   # before put the current stage into your dictionary, make sure it meet the condition. \\n                    d.add(s[l:r])     # then, you have two choices: put \\n                    maxl=self.bt(s, d, r,r, maxl)\\n                    d.remove(s[l:r])   # the other choice is not put. (add, then remove)\\n            return maxl\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        return self.bt(s, set(), 0,1, 0)\\n    \\n   \\n   def bt(self, s, d, l, r, maxl): \\n        if r>=len(s):\\n            maxl = max(len(d), maxl)\\n            return maxl\\n        else:\\n            for r in range(l+1,len(s)+1):  \\n                if s[l:r] not in d:   # before put the current stage into your dictionary, make sure it meet the condition. \\n                    d.add(s[l:r])     # then, you have two choices: put \\n                    maxl=self.bt(s, d, r,r, maxl)\\n                    d.remove(s[l:r])   # the other choice is not put. (add, then remove)\\n            return maxl\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855309,
                "title": "java-backtracking-with-explanation",
                "content": "Key Points:\\n1. Since we want the unique substrings, we need a set to store the unique substrings.\\n2. Iterating string `text` from the beginning, when we find a unique substring, then add this unique substring to the set, and do the same thing on the rest substring.\\n3. If we add a prefix substring, we need to remove it, because the characters cannot be reused.\\n\\n```java\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        return maxUnique(s, new HashSet<String>());\\n    }\\n    \\n    public int maxUnique(String s, Set<String> set) {\\n        int max = 0;\\n        for(int i=1; i<=s.length(); i++) {\\n            String tmp = s.substring(0, i);\\n            if(!set.contains(tmp)) {\\n                set.add(tmp); // May added or may not\\n                max = Math.max(max, maxUnique(s.substring(i), set) + 1);\\n                set.remove(tmp);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        return maxUnique(s, new HashSet<String>());\\n    }\\n    \\n    public int maxUnique(String s, Set<String> set) {\\n        int max = 0;\\n        for(int i=1; i<=s.length(); i++) {\\n            String tmp = s.substring(0, i);\\n            if(!set.contains(tmp)) {\\n                set.add(tmp); // May added or may not\\n                max = Math.max(max, maxUnique(s.substring(i), set) + 1);\\n                set.remove(tmp);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855230,
                "title": "simple-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> m;\\n    int ans = 0;\\n    void dfs(string &s, int idx) {\\n        if(idx >= s.size()) {\\n            ans = max(ans, (int)m.size());\\n            return;\\n        }\\n        for(int i = idx; i < s.size(); ++i) {\\n            string ns = s.substr(idx, i - idx + 1);\\n            if(m.count(ns)) continue;\\n            m.insert(ns);\\n            dfs(s, i + 1);\\n            m.erase(ns);\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        dfs(s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> m;\\n    int ans = 0;\\n    void dfs(string &s, int idx) {\\n        if(idx >= s.size()) {\\n            ans = max(ans, (int)m.size());\\n            return;\\n        }\\n        for(int i = idx; i < s.size(); ++i) {\\n            string ns = s.substr(idx, i - idx + 1);\\n            if(m.count(ns)) continue;\\n            m.insert(ns);\\n            dfs(s, i + 1);\\n            m.erase(ns);\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        dfs(s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855168,
                "title": "c-backtracking-simple-using-set-comments-for-better-understanding-added-time-complexity",
                "content": "runtime: 376ms\\nspace: 43.1 mb\\n```\\nclass Solution {\\npublic:\\n    int max_unique_substrings(string s,unordered_set<string>&seen)\\n    {\\n        int maximum = 0;\\n        for(int i = 1;i<s.length() + 1;i++)\\n        {\\n\\t\\t\\t//simply take current substring as candidate and put it in seen if being seen for the 1st time\\n            string candidate = s.substr(0,i);\\n            if(seen.count(candidate) == 0)\\n            {\\n                seen.insert(candidate);\\n\\t\\t\\t\\t//recur for the remaining substring\\n                maximum = max(maximum, 1 + max_unique_substrings(s.substr(i),seen));\\n                seen.erase(candidate);//backtracking\\n            }\\n        }\\n        return maximum;\\n    }\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> seen;\\n        return max_unique_substrings(s,seen);\\n    }\\n};\\n```\\nTime Complexity: O(2^s.length())\\nPlease upvote if you find this helpful!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_unique_substrings(string s,unordered_set<string>&seen)\\n    {\\n        int maximum = 0;\\n        for(int i = 1;i<s.length() + 1;i++)\\n        {\\n\\t\\t\\t//simply take current substring as candidate and put it in seen if being seen for the 1st time\\n            string candidate = s.substr(0,i);\\n            if(seen.count(candidate) == 0)\\n            {\\n                seen.insert(candidate);\\n\\t\\t\\t\\t//recur for the remaining substring\\n                maximum = max(maximum, 1 + max_unique_substrings(s.substr(i),seen));\\n                seen.erase(candidate);//backtracking\\n            }\\n        }\\n        return maximum;\\n    }\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> seen;\\n        return max_unique_substrings(s,seen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855149,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string s;\\n    int ans = 0;\\n    void f(int i, unordered_set<string> & S) {\\n        if (i == s.length()) {\\n            ans = max(ans, (int)S.size());\\n            return;\\n        }\\n        string t;\\n        for (int j = i; j < s.length(); j++) {\\n            t.push_back(s[j]);\\n            if (S.find(t) == S.end()) {\\n                S.insert(t);\\n                f(j+1, S);\\n                S.erase(t);\\n            }\\n        }\\n    }\\n    int maxUniqueSplit(string t) {\\n        s = t;\\n        unordered_set<string> S;\\n        f(0, S);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string s;\\n    int ans = 0;\\n    void f(int i, unordered_set<string> & S) {\\n        if (i == s.length()) {\\n            ans = max(ans, (int)S.size());\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 855127,
                "title": "simple-python-backtracking-solution",
                "content": "```\\ndef maxUniqueSplit(self, s: str) -> int:\\n        sett = set()\\n        def helper(s,sett):\\n            if(s==\"\"):\\n                return 0\\n            if(s in sett):\\n                return -1\\n            strr = \"\"\\n            ans = -2\\n            for i in range(len(s)):\\n                c = s[i]\\n                strr+=c\\n                if(strr not in sett):\\n                    sett.add(strr)\\n                    if(i!=len(s)-1):\\n                        res = helper(s[i+1:],sett)\\n                    else:\\n                        res = 0\\n                    if(res!=-1):\\n                        ans = max(res+1,ans)\\n                    sett.remove(strr)\\n            return ans\\n        return helper(s,sett)\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef maxUniqueSplit(self, s: str) -> int:\\n        sett = set()\\n        def helper(s,sett):\\n            if(s==\"\"):\\n                return 0\\n            if(s in sett):\\n                return -1\\n            strr = \"\"\\n            ans = -2\\n            for i in range(len(s)):\\n                c = s[i]\\n                strr+=c\\n                if(strr not in sett):\\n                    sett.add(strr)\\n                    if(i!=len(s)-1):\\n                        res = helper(s[i+1:],sett)\\n                    else:\\n                        res = 0\\n                    if(res!=-1):\\n                        ans = max(res+1,ans)\\n                    sett.remove(strr)\\n            return ans\\n        return helper(s,sett)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 855101,
                "title": "c-brute-force-time-complexity-o-2-n-space-complexity-o-2-n",
                "content": "```\\npublic class Solution {\\n    public int MaxUniqueSplit(string s) {\\n        HashSet<string> substringSet = new HashSet<string>();\\n        return MaxUniqueSplit(s, 0, substringSet);\\n    }\\n    \\n    private int MaxUniqueSplit(string s, int start, HashSet<string> substringSet)\\n    {\\n        if (start == s.Length)\\n        {\\n            return 0;\\n        }\\n        int count = 0;\\n        \\n        int max = 0;\\n        for (int i = start; i < s.Length; i++)\\n        {\\n            string sub = s.Substring(start, i - start + 1);\\n            if (substringSet.Contains(sub))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                substringSet.Add(sub);\\n            }\\n            max = Math.Max(max, MaxUniqueSplit(s, i + 1, substringSet) + 1);\\n            substringSet.Remove(sub);\\n        }\\n        \\n        return count + max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxUniqueSplit(string s) {\\n        HashSet<string> substringSet = new HashSet<string>();\\n        return MaxUniqueSplit(s, 0, substringSet);\\n    }\\n    \\n    private int MaxUniqueSplit(string s, int start, HashSet<string> substringSet)\\n    {\\n        if (start == s.Length)\\n        {\\n            return 0;\\n        }\\n        int count = 0;\\n        \\n        int max = 0;\\n        for (int i = start; i < s.Length; i++)\\n        {\\n            string sub = s.Substring(start, i - start + 1);\\n            if (substringSet.Contains(sub))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                substringSet.Add(sub);\\n            }\\n            max = Math.Max(max, MaxUniqueSplit(s, i + 1, substringSet) + 1);\\n            substringSet.Remove(sub);\\n        }\\n        \\n        return count + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855069,
                "title": "javascript-python3-c-dfs-bt-solutions",
                "content": "**Synopsis:**\\n\\nLet `paths` be a unique set of non-overlapping substrings from the input string `s`.  Construct each candidate `cand` substring `path` one `j`<sup>th</sup> character at a time via depth-first-search + back-tracking.  Return the maximum amount of unique substring `paths`.\\n\\n---\\n\\n**Weekly Contest 207 Screenshare:** https://www.youtube.com/watch?v=mPiQqrMmbhU\\n\\n---\\n\\n*Javascript*\\n```\\nlet maxUniqueSplit = (s, best = 0) => {\\n    let N = s.length;\\n    let go = (i = 0, paths = new Set()) => {\\n        if (i == N)\\n            return best = Math.max(best, paths.size)\\n        let path = [];\\n        for (let j = i; j < N; ++j) {\\n            path.push(s[j]);\\n            let cand = path.join(\\'\\');\\n            if (!paths.has(cand))\\n                paths.add(cand),\\n                go(j + 1, paths),\\n                paths.delete(cand);\\n        }\\n        return best;\\n    };\\n    return go();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str, best = 0) -> int:\\n        N = len(s)\\n        def go(i = 0, paths = set()):\\n            nonlocal best\\n            if i == N:\\n                best = max(best, len(paths))\\n                return\\n            path = []\\n            for j in range(i, N):\\n                path.append(s[j])\\n                cand = \\'\\'.join(path)\\n                if cand not in paths:\\n                    paths.add(cand)\\n                    go(j + 1, paths)\\n                    paths.remove(cand)\\n            return best\\n        return go()\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int, Set&&)>;\\n    int maxUniqueSplit(string s, int best = 0) {\\n        int N = s.size();\\n        fun go = [&](int i, Set&& paths) {\\n            if (i == N)\\n                return best = max(best, int(paths.size()));\\n            string path;\\n            for (auto j{ i }; j < N; ++j) {\\n                path.push_back(s[j]);\\n                if (paths.insert(path).second)\\n                    go(j + 1, move(paths)),\\n\\t\\t\\t\\t\\tpaths.erase(path);\\n            }\\n            return best;\\n        };\\n        return go(0, {});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet maxUniqueSplit = (s, best = 0) => {\\n    let N = s.length;\\n    let go = (i = 0, paths = new Set()) => {\\n        if (i == N)\\n            return best = Math.max(best, paths.size)\\n        let path = [];\\n        for (let j = i; j < N; ++j) {\\n            path.push(s[j]);\\n            let cand = path.join(\\'\\');\\n            if (!paths.has(cand))\\n                paths.add(cand),\\n                go(j + 1, paths),\\n                paths.delete(cand);\\n        }\\n        return best;\\n    };\\n    return go();\\n};\\n```\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str, best = 0) -> int:\\n        N = len(s)\\n        def go(i = 0, paths = set()):\\n            nonlocal best\\n            if i == N:\\n                best = max(best, len(paths))\\n                return\\n            path = []\\n            for j in range(i, N):\\n                path.append(s[j])\\n                cand = \\'\\'.join(path)\\n                if cand not in paths:\\n                    paths.add(cand)\\n                    go(j + 1, paths)\\n                    paths.remove(cand)\\n            return best\\n        return go()\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int, Set&&)>;\\n    int maxUniqueSplit(string s, int best = 0) {\\n        int N = s.size();\\n        fun go = [&](int i, Set&& paths) {\\n            if (i == N)\\n                return best = max(best, int(paths.size()));\\n            string path;\\n            for (auto j{ i }; j < N; ++j) {\\n                path.push_back(s[j]);\\n                if (paths.insert(path).second)\\n                    go(j + 1, move(paths)),\\n\\t\\t\\t\\t\\tpaths.erase(path);\\n            }\\n            return best;\\n        };\\n        return go(0, {});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855048,
                "title": "c-simple-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> umap;\\n    int dfs(string &s, int pos){\\n        if(pos==s.length())\\n            return 0;\\n        string tmp = \"\";\\n        int ans = 0;\\n        for(int i=pos;i<s.length();i++){\\n            tmp+=s[i];\\n            if(umap.find(tmp)==umap.end()){\\n                umap.insert(tmp);\\n                ans=max(ans,1+dfs(s,i+1));\\n                umap.erase(tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxUniqueSplit(string s) {\\n        return dfs(s,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> umap;\\n    int dfs(string &s, int pos){\\n        if(pos==s.length())\\n            return 0;\\n        string tmp = \"\";\\n        int ans = 0;\\n        for(int i=pos;i<s.length();i++){\\n            tmp+=s[i];\\n            if(umap.find(tmp)==umap.end()){\\n                umap.insert(tmp);\\n                ans=max(ans,1+dfs(s,i+1));\\n                umap.erase(tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxUniqueSplit(string s) {\\n        return dfs(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855045,
                "title": "python3-simple-backtracking",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.res = 0\\n        partition = []\\n        def backtrack(start_i):\\n            if start_i == len(s):\\n                self.res = max(self.res, len(set(partition)))\\n            else:\\n                for j in range(start_i + 1, len(s) + 1):\\n                    partition.append(s[start_i:j])\\n                    backtrack(j)\\n                    partition.pop()\\n        backtrack(0)\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.res = 0\\n        partition = []\\n        def backtrack(start_i):\\n            if start_i == len(s):\\n                self.res = max(self.res, len(set(partition)))\\n            else:\\n                for j in range(start_i + 1, len(s) + 1):\\n                    partition.append(s[start_i:j])\\n                    backtrack(j)\\n                    partition.pop()\\n        backtrack(0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855043,
                "title": "javascript-greedy-solution",
                "content": "```\\nvar maxUniqueSplit = function(s) {\\n    let wordSet = new Set(), res = 1;\\n    \\n    function checkUniqueSubstring(i) {\\n        if (i === s.length) {\\n            res = Math.max(wordSet.size, res);\\n            return;\\n        }\\n        \\n        for (let j = i+1; j <= s.length; j++) {\\n            let str = s.substring(i,j);\\n            if (!wordSet.has(str)) {\\n                wordSet.add(str);\\n                checkUniqueSubstring(j);\\n                wordSet.delete(str);\\n            }\\n        }\\n    }\\n    \\n    checkUniqueSubstring(0);\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar maxUniqueSplit = function(s) {\\n    let wordSet = new Set(), res = 1;\\n    \\n    function checkUniqueSubstring(i) {\\n        if (i === s.length) {\\n            res = Math.max(wordSet.size, res);\\n            return;\\n        }\\n        \\n        for (let j = i+1; j <= s.length; j++) {\\n            let str = s.substring(i,j);\\n            if (!wordSet.has(str)) {\\n                wordSet.add(str);\\n                checkUniqueSubstring(j);\\n                wordSet.delete(str);\\n            }\\n        }\\n    }\\n    \\n    checkUniqueSubstring(0);\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855040,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        Set<String> hs = new HashSet();\\n        return rec(s, hs, 0);\\n    }\\n    \\n    private int rec(String s, Set<String> hs, int in){\\n        if(in == s.length()){\\n            return hs.size();\\n        }\\n        int res = 0;\\n        for(int i=in;i<s.length();i++){\\n            if(!hs.contains(s.substring(in, i+1))){\\n                hs.add(s.substring(in, i+1));\\n                res = Math.max(res, rec(s, hs, i+1));\\n                hs.remove(s.substring(in, i+1));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        Set<String> hs = new HashSet();\\n        return rec(s, hs, 0);\\n    }\\n    \\n    private int rec(String s, Set<String> hs, int in){\\n        if(in == s.length()){\\n            return hs.size();\\n        }\\n        int res = 0;\\n        for(int i=in;i<s.length();i++){\\n            if(!hs.contains(s.substring(in, i+1))){\\n                hs.add(s.substring(in, i+1));\\n                res = Math.max(res, rec(s, hs, i+1));\\n                hs.remove(s.substring(in, i+1));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101322,
                "title": "simple-bactracking-an-old-solution-to-new-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets analyze this question. So, on the first look if you would have know recursion for some time then you would realize that this is something related to it or another method is by seeing that it is not possible using iterative as you don\\'t want to hardcode for loop for every iteration. Now coming to how I got it then I would say thanks to this similar question https://leetcode.com/problems/palindrome-partitioning/ this is a copy of the present solution exactly same just a the return types are different.\\n\\nTrick to understand a backtracking solution:\\nWhenever you encounter try all possible ways, max/min out of all possible ways,number of possible ways etc. are all related to recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs I already talked about the similar question with exactly similar approach so, i would just give a brush up with the changing parameter. \\n1st: The substring should be able to concatenate to the original String(Not needed to be precise)\\n2nd: All the substrings should be unique\\n\\nNow most of you might think after seeing the unique keyword and got an urged to use Set DS but let me tell you it isn\\'t necessary though you can(As I had Also used it) but I will say a different scenario where you might not be able to print if asked to print in the way original string was if used hashset. So , yes I would also be providing another solution where you can also print the substring.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nexponential: 2^n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSet+recursion stack space+iteration\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n         \\n        Set<String> temp= new HashSet<>();\\n       return dfs(s,0,temp);\\n        \\n    }\\n    int dfs(String s,int index, Set<String> temp){\\n        <!-- this can also be initialized as global but not a good practice -->\\n        int max=0;\\n        if(index==s.length()){\\n            return temp.size();\\n        }\\n        <!-- why i+1? cause in substring end part is exclusive -->\\n        for(int i=index;i<s.length();i++){\\n            if(!temp.contains(s.substring(index,i+1))){\\n                temp.add(s.substring(index,i+1));\\n                max = Math.max(max,dfs(s,i+1,temp));\\n                temp.remove(s.substring(index,i+1));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\n\\n<!-- Code to print all the possible substring useful for follow up -->\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n         \\n       List<List<String>> ans=new ArrayList<>();\\n         List<String> temp= new ArrayList<>();\\n        dfs(s,0,ans,temp);\\n        for(List<String> a:ans){\\n            System.out.println(a);\\n        }\\n        // dummy return\\n        return 1;\\n    }\\n    void dfs(String s,int index,List<List<String>> ans,List<String> temp){\\n//         base case when string size and index is equal we found a partition\\n        if(index==s.length()){\\n\\n           \\n            ans.add(new ArrayList(temp));\\n           \\n            return;\\n        }\\n        \\n        for(int i=index;i<s.length();i++){\\n            if(!temp.contains(s.substring(index,i+1))){\\n                temp.add(s.substring(index,i+1));\\n              \\n                dfs(s,i+1,ans,temp);\\n                temp.remove(s.substring(index,i+1));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n         \\n        Set<String> temp= new HashSet<>();\\n       return dfs(s,0,temp);\\n        \\n    }\\n    int dfs(String s,int index, Set<String> temp){\\n        <!-- this can also be initialized as global but not a good practice -->\\n        int max=0;\\n        if(index==s.length()){\\n            return temp.size();\\n        }\\n        <!-- why i+1? cause in substring end part is exclusive -->\\n        for(int i=index;i<s.length();i++){\\n            if(!temp.contains(s.substring(index,i+1))){\\n                temp.add(s.substring(index,i+1));\\n                max = Math.max(max,dfs(s,i+1,temp));\\n                temp.remove(s.substring(index,i+1));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\n\\n<!-- Code to print all the possible substring useful for follow up -->\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n         \\n       List<List<String>> ans=new ArrayList<>();\\n         List<String> temp= new ArrayList<>();\\n        dfs(s,0,ans,temp);\\n        for(List<String> a:ans){\\n            System.out.println(a);\\n        }\\n        // dummy return\\n        return 1;\\n    }\\n    void dfs(String s,int index,List<List<String>> ans,List<String> temp){\\n//         base case when string size and index is equal we found a partition\\n        if(index==s.length()){\\n\\n           \\n            ans.add(new ArrayList(temp));\\n           \\n            return;\\n        }\\n        \\n        for(int i=index;i<s.length();i++){\\n            if(!temp.contains(s.substring(index,i+1))){\\n                temp.add(s.substring(index,i+1));\\n              \\n                dfs(s,i+1,ans,temp);\\n                temp.remove(s.substring(index,i+1));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101096,
                "title": "recursion-used-dictionary",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.count = 0\\n        self.counter = {}\\n\\n        def solve(s, cnt):\\n            if s == \"\":\\n                self.count = max(self.count, cnt)\\n                return\\n\\n            for i in range(len(s)):\\n                if s[:i+1] not in self.counter:\\n                    self.counter[s[:i+1]] = 1\\n                    solve(s[i+1:], cnt+1)\\n                    del self.counter[s[:i+1]]\\n        \\n            return\\n\\n        solve(s, 0)\\n        return self.count\\n        \\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.count = 0\\n        self.counter = {}\\n\\n        def solve(s, cnt):\\n            if s == \"\":\\n                self.count = max(self.count, cnt)\\n                return\\n\\n            for i in range(len(s)):\\n                if s[:i+1] not in self.counter:\\n                    self.counter[s[:i+1]] = 1\\n                    solve(s[i+1:], cnt+1)\\n                    del self.counter[s[:i+1]]\\n        \\n            return\\n\\n        solve(s, 0)\\n        return self.count\\n        \\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090769,
                "title": "python3-backtracking",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        unique = set()\\n        curr = []\\n        max_len = 1\\n\\n        def backtrack(i):\\n            nonlocal max_len\\n            if i == len(s):\\n                if len(curr) > 1:\\n                    max_len = max(max_len,len(curr))\\n                return\\n            for k in range(i, len(s)):\\n                sub = s[i:k + 1]\\n                if sub not in unique:\\n                    curr.append(sub)\\n                    unique.add(sub)\\n                    backtrack(k + 1)\\n                    unique.remove(sub)\\n                    curr.pop()\\n\\n        backtrack(0)\\n        return max_len         \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        unique = set()\\n        curr = []\\n        max_len = 1\\n\\n        def backtrack(i):\\n            nonlocal max_len\\n            if i == len(s):\\n                if len(curr) > 1:\\n                    max_len = max(max_len,len(curr))\\n                return\\n            for k in range(i, len(s)):\\n                sub = s[i:k + 1]\\n                if sub not in unique:\\n                    curr.append(sub)\\n                    unique.add(sub)\\n                    backtrack(k + 1)\\n                    unique.remove(sub)\\n                    curr.pop()\\n\\n        backtrack(0)\\n        return max_len         \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053180,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\n    void solve(int i, string &s, set<string> &Set, int &ans) { \\n        if(i == s.length()) {\\n            ans = max(ans, (int)Set.size());\\n            return;\\n        }\\n        for(int j = s.length() - i; j >= 1; j--) {\\n            string part = s.substr(i, j);\\n            if(Set.find(part) != Set.end()) continue;\\n            Set.insert(part);\\n            solve(i + j, s, Set, ans);\\n            Set.erase(part);\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        int ans = 0;\\n        set<string> Set;\\n        solve(0, s, Set, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    void solve(int i, string &s, set<string> &Set, int &ans) { \\n        if(i == s.length()) {\\n            ans = max(ans, (int)Set.size());\\n            return;\\n        }\\n        for(int j = s.length() - i; j >= 1; j--) {\\n            string part = s.substr(i, j);\\n            if(Set.find(part) != Set.end()) continue;\\n            Set.insert(part);\\n            solve(i + j, s, Set, ans);\\n            Set.erase(part);\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        int ans = 0;\\n        set<string> Set;\\n        solve(0, s, Set, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028294,
                "title": "backtracking-explained",
                "content": "# Approach\\nWe try to build all possible scenarios by using dfs and backtracking\\n\\nFor Each dfs invocation we try to cut a string and invoke dfs on the next substring\\nExample aaab, we cut first \\'a\\' and call next dfs(\\'aab\\')\\nnext dfs repeated the cycle, eventualy we got back to the first call and cut \\'aa\\' and call dfs(\\'ab\\')\\n\\nExample (spaces are cut points)  \\n aaabbc\\n a aa b bc\\n a aa bb c\\n a aa bbc\\n a aab b c\\n a aab bc\\n ....\\n\\nImportant part is we have to keep track of substrings in a set and remove last substring we cut \\nPlus each dfs should have a base case and return the length of the Set\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^n)$$\\n\\n- Space complexity:\\n$$O(2n)$$\\n\\n# Code\\n```\\nvar maxUniqueSplit = function(s) {\\n    \\n    const dfs=(start, set)=>{\\n        if(start===s.length){\\n            return set.size;\\n        }\\n        let subStr=\\'\\', maxSize=0;\\n        for(let i=start;i<s.length;i++){\\n            subStr+=s[i];\\n            if(set.has(subStr)) continue;\\n            set.add(subStr);\\n            maxSize=Math.max(maxSize,dfs(i+1,set));\\n            set.delete(subStr);\\n        }    \\n        return maxSize;\\n    }\\n    \\n    return dfs(0,new Set());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxUniqueSplit = function(s) {\\n    \\n    const dfs=(start, set)=>{\\n        if(start===s.length){\\n            return set.size;\\n        }\\n        let subStr=\\'\\', maxSize=0;\\n        for(let i=start;i<s.length;i++){\\n            subStr+=s[i];\\n            if(set.has(subStr)) continue;\\n            set.add(subStr);\\n            maxSize=Math.max(maxSize,dfs(i+1,set));\\n            set.delete(subStr);\\n        }    \\n        return maxSize;\\n    }\\n    \\n    return dfs(0,new Set());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996081,
                "title": "easy-to-understand-javascript-solution-backtracking",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar maxUniqueSplit = function(s) {\\n    const size = s.length;\\n    const splitStringSet = new Set();\\n    let result = 0;\\n    const backtrackingUniqueString = (start = 0) => {\\n        if (start === size) {\\n            result = Math.max(splitStringSet.size, result);\\n            return;\\n        }\\n\\n        for (let index = start + 1; index <= size; index++) {\\n            const subString = s.slice(start, index);\\n\\n            if (splitStringSet.has(subString)) continue;\\n            splitStringSet.add(subString);\\n            backtrackingUniqueString(index);\\n            splitStringSet.delete(subString);\\n        }\\n    };\\n\\n    backtrackingUniqueString();\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxUniqueSplit = function(s) {\\n    const size = s.length;\\n    const splitStringSet = new Set();\\n    let result = 0;\\n    const backtrackingUniqueString = (start = 0) => {\\n        if (start === size) {\\n            result = Math.max(splitStringSet.size, result);\\n            return;\\n        }\\n\\n        for (let index = start + 1; index <= size; index++) {\\n            const subString = s.slice(start, index);\\n\\n            if (splitStringSet.has(subString)) continue;\\n            splitStringSet.add(subString);\\n            backtrackingUniqueString(index);\\n            splitStringSet.delete(subString);\\n        }\\n    };\\n\\n    backtrackingUniqueString();\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896908,
                "title": "c-solution-recursion-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int solution(int i, unordered_set<string> &ss, string &s, string &temp)\\n {\\n     if(i==s.length()) return 0;\\n     string blankstr = \"\";\\n        \\n     int new_ =0;\\n     int new_2=0;\\n    \\n        temp += s[i];\\n        ++i;\\n        if(ss.find(temp)==ss.end()){\\n            ss.insert(temp);\\n            \\n            new_ = solution(i,ss,s,blankstr)+1;\\n            ss.erase(temp);\\n        }\\n        new_2 = solution(i, ss,s,temp);\\n        \\n\\n    \\n     return max(new_2,new_);\\n }\\n int maxUniqueSplit(string s) {\\n\\n        \\n        unordered_set<string> ss;\\n        string temp = \"\";\\n        int cunt = solution(0,ss,s, temp);\\n        \\n        return cunt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int solution(int i, unordered_set<string> &ss, string &s, string &temp)\\n {\\n     if(i==s.length()) return 0;\\n     string blankstr = \"\";\\n        \\n     int new_ =0;\\n     int new_2=0;\\n    \\n        temp += s[i];\\n        ++i;\\n        if(ss.find(temp)==ss.end()){\\n            ss.insert(temp);\\n            \\n            new_ = solution(i,ss,s,blankstr)+1;\\n            ss.erase(temp);\\n        }\\n        new_2 = solution(i, ss,s,temp);\\n        \\n\\n    \\n     return max(new_2,new_);\\n }\\n int maxUniqueSplit(string s) {\\n\\n        \\n        unordered_set<string> ss;\\n        string temp = \"\";\\n        int cunt = solution(0,ss,s, temp);\\n        \\n        return cunt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833327,
                "title": "c-backtracking-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=1;\\nvoid solve(int i,string &s,unordered_set<string> &st){\\n    if(i==s.size()){\\n        int x=st.size();\\n        ans=max(ans,x);\\n        return;\\n    }\\n    string temp=\"\";\\n    for(int j=i;j<s.size();j++){\\n        temp+=s[j];\\n        if(st.find(temp)==st.end()){\\n            st.insert(temp);\\n            solve(j+1,s,st);\\n            st.erase(temp);\\n        }\\n    }\\n}\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> st;\\n        solve(0,s,st);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=1;\\nvoid solve(int i,string &s,unordered_set<string> &st){\\n    if(i==s.size()){\\n        int x=st.size();\\n        ans=max(ans,x);\\n        return;\\n    }\\n    string temp=\"\";\\n    for(int j=i;j<s.size();j++){\\n        temp+=s[j];\\n        if(st.find(temp)==st.end()){\\n            st.insert(temp);\\n            solve(j+1,s,st);\\n            st.erase(temp);\\n        }\\n    }\\n}\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> st;\\n        solve(0,s,st);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822327,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        unique_set=set()\\n        count=0\\n        ans=0\\n        def backtrack(start, count):\\n            nonlocal ans\\n            if start==len(s):\\n                ans= max(ans, count)\\n            for end in range(start+1, len(s)+1):\\n                substring=s[start:end]\\n                if substring not in unique_set:\\n                    unique_set.add(substring)\\n                    backtrack(end, count+1)\\n                    unique_set.remove(substring)\\n            return ans\\n        backtrack(0,count)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        unique_set=set()\\n        count=0\\n        ans=0\\n        def backtrack(start, count):\\n            nonlocal ans\\n            if start==len(s):\\n                ans= max(ans, count)\\n            for end in range(start+1, len(s)+1):\\n                substring=s[start:end]\\n                if substring not in unique_set:\\n                    unique_set.add(substring)\\n                    backtrack(end, count+1)\\n                    unique_set.remove(substring)\\n            return ans\\n        backtrack(0,count)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792856,
                "title": "golang-solution",
                "content": "\\n```\\nfunc maxUniqueSplit(s string) int {\\n \\tvar result int\\n\\tm := make(map[string]bool)\\n\\thelper1(s, m, &result, 0)\\n\\treturn result   \\n}\\n\\nfunc helper1(s string, m map[string]bool, result *int, cur int) {\\n\\n\\tif cur == len(s) {\\n\\t\\t*result = max(*result, len(m))\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := cur; i < len(s); i++ {\\n\\t\\tstr := s[cur : i+1]\\n\\t\\tif !m[str] {\\n\\t\\t\\tm[str] = true\\n\\t\\t\\thelper1(s, m, result, i+1)\\n\\t\\t\\tdelete(m, str)\\n\\t\\t}\\n\\n\\t}\\n}\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\n\\nor\\n\\n```\\nfunc helper(s string, m map[string]bool, result *int) int {\\n\\tvar mx int\\n\\tfor i := 1; i <= len(s); i++ {\\n\\t\\tstr := s[:i]\\n\\t\\tif !m[str] {\\n\\t\\t\\tm[str] = true\\n\\t\\t\\tnext := helper(s[i:], m, result)\\n\\t\\t\\tmx = max(mx, 1+next)\\n\\t\\t\\tdelete(m, str)\\n\\t\\t}\\n\\t}\\n\\treturn mx\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxUniqueSplit(s string) int {\\n \\tvar result int\\n\\tm := make(map[string]bool)\\n\\thelper1(s, m, &result, 0)\\n\\treturn result   \\n}\\n\\nfunc helper1(s string, m map[string]bool, result *int, cur int) {\\n\\n\\tif cur == len(s) {\\n\\t\\t*result = max(*result, len(m))\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := cur; i < len(s); i++ {\\n\\t\\tstr := s[cur : i+1]\\n\\t\\tif !m[str] {\\n\\t\\t\\tm[str] = true\\n\\t\\t\\thelper1(s, m, result, i+1)\\n\\t\\t\\tdelete(m, str)\\n\\t\\t}\\n\\n\\t}\\n}\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\n```\\nfunc helper(s string, m map[string]bool, result *int) int {\\n\\tvar mx int\\n\\tfor i := 1; i <= len(s); i++ {\\n\\t\\tstr := s[:i]\\n\\t\\tif !m[str] {\\n\\t\\t\\tm[str] = true\\n\\t\\t\\tnext := helper(s[i:], m, result)\\n\\t\\t\\tmx = max(mx, 1+next)\\n\\t\\t\\tdelete(m, str)\\n\\t\\t}\\n\\t}\\n\\treturn mx\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733526,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MaxUniqueSplit(string s) {\\n        return MaxUniqueSplitUntil(s, new HashSet<string>(), 1, s[0].ToString());\\n    }\\n\\n    private int MaxUniqueSplitUntil(string s, HashSet<string> set, int idx, string str) {\\n        if(idx == s.Length)\\n            return !set.Contains(str) ? 1 : 0;\\n\\n        var res = MaxUniqueSplitUntil(s, set, 1 + idx, str + s[idx]);\\n        if(!set.Contains(str)) {\\n            set.Add(str);\\n            res = Math.Max(res, 1 + MaxUniqueSplitUntil(s, set, 1 + idx, s[idx].ToString()));\\n            set.Remove(str);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxUniqueSplit(string s) {\\n        return MaxUniqueSplitUntil(s, new HashSet<string>(), 1, s[0].ToString());\\n    }\\n\\n    private int MaxUniqueSplitUntil(string s, HashSet<string> set, int idx, string str) {\\n        if(idx == s.Length)\\n            return !set.Contains(str) ? 1 : 0;\\n\\n        var res = MaxUniqueSplitUntil(s, set, 1 + idx, str + s[idx]);\\n        if(!set.Contains(str)) {\\n            set.Add(str);\\n            res = Math.Max(res, 1 + MaxUniqueSplitUntil(s, set, 1 + idx, s[idx].ToString()));\\n            set.Remove(str);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724733,
                "title": "92-backtracking-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    int solve(string &s, int i, string str){\\n        if(i >= s.length())\\n            return 0;\\n\\n        int b = 0;\\n        if(!mp[str+s[i]]){\\n            mp[str + s[i]] = 1;\\n            b = solve(s, i+1, \"\") + 1;\\n            mp[str + s[i]] = 0;\\n        }\\n\\n        return max(solve(s, i+1, str + s[i]), b);\\n    }\\n    int maxUniqueSplit(string s) {\\n        string str = \"\";\\n        return solve(s, 0, str);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    int solve(string &s, int i, string str){\\n        if(i >= s.length())\\n            return 0;\\n\\n        int b = 0;\\n        if(!mp[str+s[i]]){\\n            mp[str + s[i]] = 1;\\n            b = solve(s, i+1, \"\") + 1;\\n            mp[str + s[i]] = 0;\\n        }\\n\\n        return max(solve(s, i+1, str + s[i]), b);\\n    }\\n    int maxUniqueSplit(string s) {\\n        string str = \"\";\\n        return solve(s, 0, str);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717989,
                "title": "easy-c-solution-unordered-set-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res=INT_MIN;\\n    void solve(unordered_set<string>m,int temp,int count,string s){\\n        if(count==s.size()){\\n            res=max(res,temp);\\n            return ;\\n        }\\n        string f=\"\";\\n        for(int i=count;i<s.size();i++){\\n            f+=s[i];\\n            if(m.count(f)==0){\\n                m.insert(f);\\n                solve(m,temp+1,i+1,s);\\n                m.erase(f);\\n            }           \\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>m;\\n        int temp=0;\\n        int count=0;\\n        solve(m,temp,count,s);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=INT_MIN;\\n    void solve(unordered_set<string>m,int temp,int count,string s){\\n        if(count==s.size()){\\n            res=max(res,temp);\\n            return ;\\n        }\\n        string f=\"\";\\n        for(int i=count;i<s.size();i++){\\n            f+=s[i];\\n            if(m.count(f)==0){\\n                m.insert(f);\\n                solve(m,temp+1,i+1,s);\\n                m.erase(f);\\n            }           \\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>m;\\n        int temp=0;\\n        int count=0;\\n        solve(m,temp,count,s);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663810,
                "title": "python3-simple-backtracking",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.hs = set()\\n        def helper(cur):\\n            if cur >= len(s):\\n                return 0\\n            ret = 0\\n            for i in range(cur+1, len(s)+1):\\n                if s[cur: i] not in self.hs:\\n                    self.hs.add(s[cur: i])\\n                    ret = max(ret, helper(i) + 1) \\n                    self.hs.remove(s[cur: i])\\n            return ret\\n\\n        return helper(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.hs = set()\\n        def helper(cur):\\n            if cur >= len(s):\\n                return 0\\n            ret = 0\\n            for i in range(cur+1, len(s)+1):\\n                if s[cur: i] not in self.hs:\\n                    self.hs.add(s[cur: i])\\n                    ret = max(ret, helper(i) + 1) \\n                    self.hs.remove(s[cur: i])\\n            return ret\\n\\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628999,
                "title": "c-brute-force-bit-mask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince `s` is quite short, we can use *brute force*: check all possible splits.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force with a help of bit mask.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxUniqueSplit(string s) {\\n        int result = 0;\\n\\n        HashSet<string> hs = new();\\n\\n        for (int mask = 0; mask < (1 << s.Length); ++mask) {\\n            int count = BitOperations.PopCount((uint)mask);\\n\\n            if (count <= result)\\n               continue;\\n\\n            hs.Clear();\\n\\n            bool ok = true;\\n            int start = 0;\\n\\n            for (int i = 0; i < s.Length && ok; ++i) \\n                if ((mask & (1 << i)) != 0) {\\n                    ok = hs.Add(s.Substring(start, i - start + 1));\\n\\n                    start = i + 1;\\n                } \\n\\n            if (ok && hs.Add(s.Substring(start)))\\n               result = count;\\n        }   \\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxUniqueSplit(string s) {\\n        int result = 0;\\n\\n        HashSet<string> hs = new();\\n\\n        for (int mask = 0; mask < (1 << s.Length); ++mask) {\\n            int count = BitOperations.PopCount((uint)mask);\\n\\n            if (count <= result)\\n               continue;\\n\\n            hs.Clear();\\n\\n            bool ok = true;\\n            int start = 0;\\n\\n            for (int i = 0; i < s.Length && ok; ++i) \\n                if ((mask & (1 << i)) != 0) {\\n                    ok = hs.Add(s.Substring(start, i - start + 1));\\n\\n                    start = i + 1;\\n                } \\n\\n            if (ok && hs.Add(s.Substring(start)))\\n               result = count;\\n        }   \\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576002,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s):\\n        n = len(s)\\n\\n        def backtrack(s,path):\\n            if not s:\\n                res.append(path)\\n\\n            for i in range(1,len(s)+1):\\n                if s[:i] not in path:\\n                    backtrack(s[i:],path+[s[:i]])\\n\\n        res = []\\n        backtrack(s,[])\\n        return max([len(i) for i in res])\\n\\n\\n                    \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s):\\n        n = len(s)\\n\\n        def backtrack(s,path):\\n            if not s:\\n                res.append(path)\\n\\n            for i in range(1,len(s)+1):\\n                if s[:i] not in path:\\n                    backtrack(s[i:],path+[s[:i]])\\n\\n        res = []\\n        backtrack(s,[])\\n        return max([len(i) for i in res])\\n\\n\\n                    \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540527,
                "title": "typical-backtracking-problem-clear-code-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Use a set to keep track of which substrings have been used already.\\n2. Try each possible substring at every position and backtrack if a complete split is not possible.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a helper function to do backtracking with three param `i` which is the position that we want to test out all the possible substring. `count` is the local count of number of substrings that currently splited. `visited` is a set used to check if the current substring is used already.\\n2. When `i==len(s)` we already reach the end of the string so we update the  `ans`, otherwise, we try out all possible substring starting at index `i` to `j` and skip all visited substring. For the non-visited one, we take it and do backtracking.\\n3. return the final `ans`\\n# Complexity\\n- Time complexity: O(n^2) where `n` is the size of `s`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2) since the set is similar structure as a dictionary\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans = 0\\n        def helper(i, count, visited):\\n            nonlocal ans\\n            if i == len(s):\\n                # update the ans\\n                ans = max(ans, count)\\n            else:\\n                for j in range(i + 1, len(s) + 1):\\n                    if s[i:j] in visited:\\n                        continue\\n                    else:\\n                        # backtracking\\n                        visited.add(s[i:j])\\n                        helper(j, count + 1, visited)\\n                        visited.remove(s[i:j])\\n        helper(0, 0, set())\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans = 0\\n        def helper(i, count, visited):\\n            nonlocal ans\\n            if i == len(s):\\n                # update the ans\\n                ans = max(ans, count)\\n            else:\\n                for j in range(i + 1, len(s) + 1):\\n                    if s[i:j] in visited:\\n                        continue\\n                    else:\\n                        # backtracking\\n                        visited.add(s[i:j])\\n                        helper(j, count + 1, visited)\\n                        visited.remove(s[i:j])\\n        helper(0, 0, set())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470039,
                "title": "javascript",
                "content": "# Complexity\\n- Time complexity:\\nNumber of possible unique substrings is 2^n. Because character can be either be included or not.\\nPlus we have loop. So overall time complexity:\\n$$O(n * 2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxUniqueSplit = function(s) {\\n    return getMaxUniqueSplit(0, s, new Set())\\n};\\n\\nfunction getMaxUniqueSplit(start, s, set) {\\n    if (start === s.length) {\\n        return set.size\\n    }\\n    let count = 0\\n    for (let i = start + 1; i <= s.length; i++) {\\n        let substring = s.substring(start, i)\\n\\n        if (!set.has(substring)) {\\n            set.add(substring)\\n            count = Math.max(count, getMaxUniqueSplit(i, s, set))\\n            set.delete(substring)\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxUniqueSplit = function(s) {\\n    return getMaxUniqueSplit(0, s, new Set())\\n};\\n\\nfunction getMaxUniqueSplit(start, s, set) {\\n    if (start === s.length) {\\n        return set.size\\n    }\\n    let count = 0\\n    for (let i = start + 1; i <= s.length; i++) {\\n        let substring = s.substring(start, i)\\n\\n        if (!set.has(substring)) {\\n            set.add(substring)\\n            count = Math.max(count, getMaxUniqueSplit(i, s, set))\\n            set.delete(substring)\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418879,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maxUniqueSplit(_ s: String) -> Int {\\n        \\n        func build(_ s: String = s, _ c: Set<String> = Set()) -> Int {\\n            guard !s.isEmpty else { return c.count }\\n\\n            var best = [-1]\\n            \\n            for i in 1...s.count {\\n\\n                let sub = String(s.prefix(i))\\n                guard !c.contains(sub) else { continue }\\n\\n                let rest = String(s.dropFirst(i))\\n                var newc = c\\n                newc.insert(sub)\\n\\n                let res = build(rest, newc)\\n                best.append(res)\\n            }\\n\\n            return best.max()!\\n        }\\n\\n        return build()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxUniqueSplit(_ s: String) -> Int {\\n        \\n        func build(_ s: String = s, _ c: Set<String> = Set()) -> Int {\\n            guard !s.isEmpty else { return c.count }\\n\\n            var best = [-1]\\n            \\n            for i in 1...s.count {\\n\\n                let sub = String(s.prefix(i))\\n                guard !c.contains(sub) else { continue }\\n\\n                let rest = String(s.dropFirst(i))\\n                var newc = c\\n                newc.insert(sub)\\n\\n                let res = build(rest, newc)\\n                best.append(res)\\n            }\\n\\n            return best.max()!\\n        }\\n\\n        return build()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410460,
                "title": "o-2-n-backtracking-java-3ms-faster-than-100-pruning",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int length = 0;\\n    public int maxUniqueSplit(String s) {\\n\\n        char[] cs = s.toCharArray();\\n        HashSet<String> set = new HashSet<>();\\n\\n        backtrack(set, cs, 0, new StringBuilder());\\n        return length;\\n    }\\n    // two cases, we\\'re creating new substring, or we\\'re adding to existing;\\n    private void backtrack(HashSet<String> set, char[] cs, int start, StringBuilder str){\\n        if (start == cs.length){\\n            if (!set.contains(String.valueOf(str))) {\\n                length = Math.max(length, set.size()+1);\\n            }\\n            return;\\n        }\\n\\n        if (length > set.size() + cs.length-start) return;\\n\\n        if (str.length() != 0 && !set.contains(String.valueOf(str))) {\\n            String s = String.valueOf(str);\\n            StringBuilder newStr = new StringBuilder();\\n            set.add(s);\\n            newStr.append(cs[start]);\\n            backtrack(set, cs, start+1, newStr);\\n            set.remove(s);\\n            newStr.deleteCharAt(newStr.length()-1);\\n        }\\n\\n        str.append(cs[start]);\\n        backtrack(set, cs, start+1, str);\\n        str.deleteCharAt(str.length()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int length = 0;\\n    public int maxUniqueSplit(String s) {\\n\\n        char[] cs = s.toCharArray();\\n        HashSet<String> set = new HashSet<>();\\n\\n        backtrack(set, cs, 0, new StringBuilder());\\n        return length;\\n    }\\n    // two cases, we\\'re creating new substring, or we\\'re adding to existing;\\n    private void backtrack(HashSet<String> set, char[] cs, int start, StringBuilder str){\\n        if (start == cs.length){\\n            if (!set.contains(String.valueOf(str))) {\\n                length = Math.max(length, set.size()+1);\\n            }\\n            return;\\n        }\\n\\n        if (length > set.size() + cs.length-start) return;\\n\\n        if (str.length() != 0 && !set.contains(String.valueOf(str))) {\\n            String s = String.valueOf(str);\\n            StringBuilder newStr = new StringBuilder();\\n            set.add(s);\\n            newStr.append(cs[start]);\\n            backtrack(set, cs, start+1, newStr);\\n            set.remove(s);\\n            newStr.deleteCharAt(newStr.length()-1);\\n        }\\n\\n        str.append(cs[start]);\\n        backtrack(set, cs, start+1, str);\\n        str.deleteCharAt(str.length()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405757,
                "title": "python-backtracking-w-set",
                "content": "\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.res = 0\\n        def backtrack(partition, start):\\n            if start == len(s):\\n                self.res = max(len(partition), self.res)\\n                return\\n            for i in range(start, len(s)):\\n                substr = s[start:i+1]\\n                if substr not in partition:\\n                    partition.add(substr)\\n                    backtrack(partition, i+1)\\n                    partition.remove(substr)\\n        backtrack(set(), 0)\\n        return self.res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.res = 0\\n        def backtrack(partition, start):\\n            if start == len(s):\\n                self.res = max(len(partition), self.res)\\n                return\\n            for i in range(start, len(s)):\\n                substr = s[start:i+1]\\n                if substr not in partition:\\n                    partition.add(substr)\\n                    backtrack(partition, i+1)\\n                    partition.remove(substr)\\n        backtrack(set(), 0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383043,
                "title": "easy-backtracking-solution-c",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    unordered_set<string> uSet;\\npublic:\\n    Solution(){uSet = {} ;}\\n    int dfs(int index , string&s ){\\n        if(index == s.size()){\\n            return 0 ; \\n        }\\n\\n\\n        int mx{INT_MIN};\\n        string st{}; \\n        for(int i = index ; i < s.size() ; i++){\\n             st+= s[i];\\n             if(uSet.find(st) == uSet.end()){\\n                 uSet.insert(st);\\n                 mx = max (mx , 1 + dfs(i+1 , s));\\n                 uSet.erase(st);\\n\\n             }\\n        }\\n        return mx ; \\n    }\\n    int maxUniqueSplit(string s) {\\n        return dfs(0 , s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_set<string> uSet;\\npublic:\\n    Solution(){uSet = {} ;}\\n    int dfs(int index , string&s ){\\n        if(index == s.size()){\\n            return 0 ; \\n        }\\n\\n\\n        int mx{INT_MIN};\\n        string st{}; \\n        for(int i = index ; i < s.size() ; i++){\\n             st+= s[i];\\n             if(uSet.find(st) == uSet.end()){\\n                 uSet.insert(st);\\n                 mx = max (mx , 1 + dfs(i+1 , s));\\n                 uSet.erase(st);\\n\\n             }\\n        }\\n        return mx ; \\n    }\\n    int maxUniqueSplit(string s) {\\n        return dfs(0 , s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347363,
                "title": "backtracking-set-c",
                "content": "# Intuition\\nSimilar to [Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning)\\n\\n###### When ever there will be questions like \"divide into partitions that sum up to the string itself\" we will have to solve it using substrings from \\'ind to i\\'\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int ind, unordered_set<string>&st, string &s, int n, int &len){\\n        if(ind == n){\\n            if(st.size() > len) len = st.size();\\n            return;\\n        }\\n        for(int i = ind; i < n ; i++){\\n            if(st.find(s.substr(ind, i-ind+1)) == st.end()){\\n                st.insert(s.substr(ind, i-ind+1));\\n                solve(i+1, st, s, n, len);\\n                st.erase(s.substr(ind, i-ind+1));\\n            }\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        int n = s.size();\\n        unordered_set<string>st;\\n        int len = 0;\\n        solve(0, st, s, n, len);\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int ind, unordered_set<string>&st, string &s, int n, int &len){\\n        if(ind == n){\\n            if(st.size() > len) len = st.size();\\n            return;\\n        }\\n        for(int i = ind; i < n ; i++){\\n            if(st.find(s.substr(ind, i-ind+1)) == st.end()){\\n                st.insert(s.substr(ind, i-ind+1));\\n                solve(i+1, st, s, n, len);\\n                st.erase(s.substr(ind, i-ind+1));\\n            }\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        int n = s.size();\\n        unordered_set<string>st;\\n        int len = 0;\\n        solve(0, st, s, n, len);\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317814,
                "title": "python-dfs-and-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.max_slen = 0\\n        self.s = s\\n        self.len_s = len(s)\\n        \\n        self.dfsFindSub(0, set())\\n        return self.max_slen\\n    \\n        \\n    def dfsFindSub(self, sidx, subs):\\n        if sidx == self.len_s:\\n            if len(subs) > self.max_slen:\\n                self.max_slen = len(subs)\\n                return\\n            \\n        for nidx in range(sidx + 1, self.len_s + 1):\\n            t_subs = self.s[sidx:nidx]\\n            if t_subs not in subs:\\n                subs.add(t_subs)\\n                self.dfsFindSub(nidx, subs)\\n                subs.remove(t_subs)\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        self.max_slen = 0\\n        self.s = s\\n        self.len_s = len(s)\\n        \\n        self.dfsFindSub(0, set())\\n        return self.max_slen\\n    \\n        \\n    def dfsFindSub(self, sidx, subs):\\n        if sidx == self.len_s:\\n            if len(subs) > self.max_slen:\\n                self.max_slen = len(subs)\\n                return\\n            \\n        for nidx in range(sidx + 1, self.len_s + 1):\\n            t_subs = self.s[sidx:nidx]\\n            if t_subs not in subs:\\n                subs.add(t_subs)\\n                self.dfsFindSub(nidx, subs)\\n                subs.remove(t_subs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305655,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    // map\\n    // try insert all subsequences\\n    // n count\\n    // 2 ^ 16 = 65536\\n    int maxUniqueSplit(string s) {\\n        unordered_map<string,int> m;\\n        return dfs(s, 0, m, \"\");\\n    }\\n    int dfs(string& s, int i, unordered_map<string,int>& m, string cur){\\n        // iterate thru map and see there are no duplicates\\n        // if no duplicates return size of map\\n        // else return 0\\n        if (i == s.size()){\\n            if (cur.size() > 0) ++m[cur];\\n            for (auto& [f,s] : m)\\n                if (s != 1){\\n                    if (cur.size() > 0)\\n                        if (--m[cur] == 0) m.erase(cur);\\n                    return 0;\\n                }\\n            if (cur.size() > 0)\\n                if (--m[cur] == 0) m.erase(cur);\\n            return m.size();\\n        }\\n        cur += s[i];\\n        ++m[cur];\\n        int ans = dfs(s, i + 1, m, \"\");\\n        if (--m[cur] == 0) m.erase(cur);\\n        ans = max(ans, dfs(s, i + 1, m, cur));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // map\\n    // try insert all subsequences\\n    // n count\\n    // 2 ^ 16 = 65536\\n    int maxUniqueSplit(string s) {\\n        unordered_map<string,int> m;\\n        return dfs(s, 0, m, \"\");\\n    }\\n    int dfs(string& s, int i, unordered_map<string,int>& m, string cur){\\n        // iterate thru map and see there are no duplicates\\n        // if no duplicates return size of map\\n        // else return 0\\n        if (i == s.size()){\\n            if (cur.size() > 0) ++m[cur];\\n            for (auto& [f,s] : m)\\n                if (s != 1){\\n                    if (cur.size() > 0)\\n                        if (--m[cur] == 0) m.erase(cur);\\n                    return 0;\\n                }\\n            if (cur.size() > 0)\\n                if (--m[cur] == 0) m.erase(cur);\\n            return m.size();\\n        }\\n        cur += s[i];\\n        ++m[cur];\\n        int ans = dfs(s, i + 1, m, \"\");\\n        if (--m[cur] == 0) m.erase(cur);\\n        ans = max(ans, dfs(s, i + 1, m, cur));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273674,
                "title": "java-dfs-backtrack-beats-100-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    static int res=0;\\n    public int maxUniqueSplit(String s) {\\n        res=0;\\n        ArrayList<String> al = new ArrayList<String>();\\n        backtrack(s,al, 0);\\n        return res;\\n    }\\n    public static void backtrack(String s, ArrayList<String> al,int index)\\n    {\\n        if(index==s.length())\\n        {\\n            res=Math.max(res,al.size());\\n            return;\\n        }\\n        for(int i=index+1;i<s.length()+1;i++)\\n        {\\n            String add = s.substring(index,i);\\n            if(!al.contains(add))\\n            {\\n                al.add(add);\\n                // to reduce the number of function calls, we dont call the function again if there is no higher value possible.\\n                if(!(al.size()+s.length()-i<=res)) backtrack(s,al,i);\\n                al.remove(al.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    static int res=0;\\n    public int maxUniqueSplit(String s) {\\n        res=0;\\n        ArrayList<String> al = new ArrayList<String>();\\n        backtrack(s,al, 0);\\n        return res;\\n    }\\n    public static void backtrack(String s, ArrayList<String> al,int index)\\n    {\\n        if(index==s.length())\\n        {\\n            res=Math.max(res,al.size());\\n            return;\\n        }\\n        for(int i=index+1;i<s.length()+1;i++)\\n        {\\n            String add = s.substring(index,i);\\n            if(!al.contains(add))\\n            {\\n                al.add(add);\\n                // to reduce the number of function calls, we dont call the function again if there is no higher value possible.\\n                if(!(al.size()+s.length()-i<=res)) backtrack(s,al,i);\\n                al.remove(al.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271137,
                "title": "python-solution",
                "content": "![Screenshot 2023-03-08 at 07.41.30.png](https://assets.leetcode.com/users/images/788a17ad-2f88-47db-afdc-e8e6704b0284_1678254145.32608.png)\\n\\n\\n# Approach\\nThe solution impl a backtracking algorithm to find the maximum number of unique substrings that a given string can be split into.\\n\\nThe algorithm uses a set to store the unique substrings seen so far, and it only adds a substring to the set if it has not been seen before. This ensures that all the substrings in a split are unique. The backtracking approach allows the algorithm to explore all possible splits of the string without having to generate all possible combinations of substrings upfront.\\n\\nThe time complexity of the algorithm is exponential, as the number of possible splits grows exponentially with the length of the string. However, in practice, the actual number of splits explored is much smaller than the total number of possible splits, as many splits can be pruned early based on the set of unique substrings seen so far.\\n\\nThe space complexity of the algorithm is also exponential, as the size of the set of unique substrings can grow exponentially with the length of the string. However, again, in practice, the actual size of the set is much smaller than the total number of possible substrings, as many substrings can be pruned early based on the set of unique substrings seen so far.\\n\\nOverall, the solution is well-written, easy to understand, and provides a correct and efficient implementation of the backtracking algorithm to solve the given problem.\\n\\n# Complexity\\n- Time complexity:\\nFor the time complexity, the algorithm uses backtracking to generate all possible splits of the string, and at each step, it tries all possible substrings starting from the current position. The number of possible substrings starting from a position is proportional to the length of the remaining string. Therefore, the total number of recursive calls made by the algorithm is proportional to the sum of the lengths of all possible substrings, which is exponential in the length of the original string. This gives the worst-case time complexity of O(2^n), where n is the length of the input string.\\n\\n- Space complexity:\\nFor the space complexity, the algorithm uses a set to store the unique substrings seen so far. The size of the set can grow exponentially in the worst case if all possible unique substrings are distinct. The worst-case space complexity is also O(2^n), where n is the length of the input string.\\n\\n# More\\nMore LeetCode solutions of mine at https://github.com/aurimas13/Solutions-To-Problems. \\n\\n# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        # Create a set to store unique substrings\\n        unique_substrings = set()\\n\\n        def backtrack(start):\\n            # Base case: all substrings have been processed\\n            if start == len(s):\\n                return 0\\n\\n            # Initialize the maximum number of unique substrings\\n            max_count = 0\\n\\n            # Try all possible substrings starting from the current position\\n            for end in range(start + 1, len(s) + 1):\\n                substring = s[start:end]\\n\\n                # If the substring has not been seen before, add it to the set\\n                if substring not in unique_substrings:\\n                    unique_substrings.add(substring)\\n\\n                    # Recursively process the remaining part of the string\\n                    count = backtrack(end)\\n\\n                    # Update the maximum count\\n                    max_count = max(max_count, count + 1)\\n\\n                    # Remove the substring from the set for backtracking\\n                    unique_substrings.remove(substring)\\n\\n            return max_count\\n\\n        # Call the backtrack function starting from the first character\\n        return backtrack(0)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        # Create a set to store unique substrings\\n        unique_substrings = set()\\n\\n        def backtrack(start):\\n            # Base case: all substrings have been processed\\n            if start == len(s):\\n                return 0\\n\\n            # Initialize the maximum number of unique substrings\\n            max_count = 0\\n\\n            # Try all possible substrings starting from the current position\\n            for end in range(start + 1, len(s) + 1):\\n                substring = s[start:end]\\n\\n                # If the substring has not been seen before, add it to the set\\n                if substring not in unique_substrings:\\n                    unique_substrings.add(substring)\\n\\n                    # Recursively process the remaining part of the string\\n                    count = backtrack(end)\\n\\n                    # Update the maximum count\\n                    max_count = max(max_count, count + 1)\\n\\n                    # Remove the substring from the set for backtracking\\n                    unique_substrings.remove(substring)\\n\\n            return max_count\\n\\n        # Call the backtrack function starting from the first character\\n        return backtrack(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269561,
                "title": "backtracking-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:  \\n    int fun(int idx,int n,string &s,string temp,unordered_set<string>&st){\\n        if(idx==n){\\n            return 0;\\n        }\\n        temp+=s[idx];\\n        int nottake=fun(idx+1,n,s,temp,st);\\n        int take=0;\\n        if(st.find(temp)==st.end()){\\n            st.insert(temp);\\n            take=1+fun(idx+1,n,s,\"\",st);\\n            st.erase(temp);\\n        }\\n        return max(take,nottake);\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>st;\\n        int n=s.length();\\n        return fun(0,n,s,\"\",st);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:  \\n    int fun(int idx,int n,string &s,string temp,unordered_set<string>&st){\\n        if(idx==n){\\n            return 0;\\n        }\\n        temp+=s[idx];\\n        int nottake=fun(idx+1,n,s,temp,st);\\n        int take=0;\\n        if(st.find(temp)==st.end()){\\n            st.insert(temp);\\n            take=1+fun(idx+1,n,s,\"\",st);\\n            st.erase(temp);\\n        }\\n        return max(take,nottake);\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>st;\\n        int n=s.length();\\n        return fun(0,n,s,\"\",st);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269560,
                "title": "backtracking-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:  \\n    int fun(int idx,int n,string &s,string temp,unordered_set<string>&st){\\n        if(idx==n){\\n            return 0;\\n        }\\n        temp+=s[idx];\\n        int nottake=fun(idx+1,n,s,temp,st);\\n        int take=0;\\n        if(st.find(temp)==st.end()){\\n            st.insert(temp);\\n            take=1+fun(idx+1,n,s,\"\",st);\\n            st.erase(temp);\\n        }\\n        return max(take,nottake);\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>st;\\n        int n=s.length();\\n        return fun(0,n,s,\"\",st);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:  \\n    int fun(int idx,int n,string &s,string temp,unordered_set<string>&st){\\n        if(idx==n){\\n            return 0;\\n        }\\n        temp+=s[idx];\\n        int nottake=fun(idx+1,n,s,temp,st);\\n        int take=0;\\n        if(st.find(temp)==st.end()){\\n            st.insert(temp);\\n            take=1+fun(idx+1,n,s,\"\",st);\\n            st.erase(temp);\\n        }\\n        return max(take,nottake);\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>st;\\n        int n=s.length();\\n        return fun(0,n,s,\"\",st);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135951,
                "title": "c-recursion-backtracking-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    void solve(int idx,string& s,unordered_map<string,int>& m)\\n    {\\n        if(idx==s.size())\\n        {\\n            ans = max(ans,(int)m.size());\\n            return;\\n        }\\n        for(int i=1;i+idx<=s.size();i++)\\n        {\\n            string tmp = s.substr(idx,i);\\n            m[tmp]++;\\n            solve(i+idx,s,m);\\n            m[tmp]--;\\n            if(m[tmp]==0)\\n            m.erase(tmp);\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        ans=0;\\n        unordered_map<string,int> m;\\n        solve(0,s,m);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void solve(int idx,string& s,unordered_map<string,int>& m)\\n    {\\n        if(idx==s.size())\\n        {\\n            ans = max(ans,(int)m.size());\\n            return;\\n        }\\n        for(int i=1;i+idx<=s.size();i++)\\n        {\\n            string tmp = s.substr(idx,i);\\n            m[tmp]++;\\n            solve(i+idx,s,m);\\n            m[tmp]--;\\n            if(m[tmp]==0)\\n            m.erase(tmp);\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        ans=0;\\n        unordered_map<string,int> m;\\n        solve(0,s,m);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127746,
                "title": "c-visualization-backtracking-easy-understanding",
                "content": "```\\n/*\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tababccc\\na|babccc    ab|abccc   abc|abccc   abca|bccc   abcab|ccc   abcabc|cc   abcabcc|c   abcabccc|\\na|b|abccc ...   ....   ....\\n\\nDo partition check for maximum and also maintain a seen set for no duplicacy objective\\n\\n*/\\n```\\n```\\nclass Solution {\\npublic:\\n    void solve(string s, unordered_set<string>&seen, int idx, int& res){\\n        int n = seen.size();\\n        if(n > res)res = seen.size();\\n        if(idx == s.size())return;\\n        \\n        string str = \"\";\\n        for(int i = idx ; i < s.size() ; i++){\\n            str += s[i];\\n            if(seen.find(str) == seen.end()){\\n                seen.insert(str);\\n                solve(s, seen, i + 1, res);\\n                seen.erase(str);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>seen; int res = INT_MIN;\\n        solve(s, seen, 0, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tababccc\\na|babccc    ab|abccc   abc|abccc   abca|bccc   abcab|ccc   abcabc|cc   abcabcc|c   abcabccc|\\na|b|abccc ...   ....   ....\\n\\nDo partition check for maximum and also maintain a seen set for no duplicacy objective\\n\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(string s, unordered_set<string>&seen, int idx, int& res){\\n        int n = seen.size();\\n        if(n > res)res = seen.size();\\n        if(idx == s.size())return;\\n        \\n        string str = \"\";\\n        for(int i = idx ; i < s.size() ; i++){\\n            str += s[i];\\n            if(seen.find(str) == seen.end()){\\n                seen.insert(str);\\n                solve(s, seen, i + 1, res);\\n                seen.erase(str);\\n            }\\n        }\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>seen; int res = INT_MIN;\\n        solve(s, seen, 0, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118769,
                "title": "simple-c-solution-recursion-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = 0;\\n\\n    void dfs(string &s,int ind,unordered_map<string,int>&mp,int k){\\n        if(ind == s.size()){\\n            ans = max(ans,k);\\n            return;\\n        }\\n\\n        string curr = \"\";      \\n        for(int i=ind;i<s.size();i++){\\n            curr += s[i];\\n\\n            if(mp[curr]>0){\\n                continue;\\n            }\\n            else{\\n                mp[curr]++;\\n                dfs(s,i+1,mp,k+1);\\n                mp[curr]--;\\n            }\\n        }       \\n    }\\n\\n    int maxUniqueSplit(string s) {\\n        unordered_map<string,int>mp;\\n        dfs(s,0,mp,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = 0;\\n\\n    void dfs(string &s,int ind,unordered_map<string,int>&mp,int k){\\n        if(ind == s.size()){\\n            ans = max(ans,k);\\n            return;\\n        }\\n\\n        string curr = \"\";      \\n        for(int i=ind;i<s.size();i++){\\n            curr += s[i];\\n\\n            if(mp[curr]>0){\\n                continue;\\n            }\\n            else{\\n                mp[curr]++;\\n                dfs(s,i+1,mp,k+1);\\n                mp[curr]--;\\n            }\\n        }       \\n    }\\n\\n    int maxUniqueSplit(string s) {\\n        unordered_map<string,int>mp;\\n        dfs(s,0,mp,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115190,
                "title": "easy-handwritten-explanation-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot_20230130_014113.png](https://assets.leetcode.com/users/images/35b9071f-9820-4756-8de7-7af6e87f1106_1675023136.9251227.png)\\n![Screenshot_20230130_014120.png](https://assets.leetcode.com/users/images/b52b6122-a22a-427b-bdf0-aa7f6165be22_1675023152.537594.png)\\n![Screenshot_20230130_014140.png](https://assets.leetcode.com/users/images/84ffb1e6-2e77-4873-8c27-52594a84b36e_1675023161.229801.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>map;\\n    int helper(int index,string s)\\n    {\\n        if(index==s.size())\\n            return 0;\\n\\n        int ans=INT_MIN;\\n        for(int i=index;i<s.size();i++)\\n        {\\n            int substring_size=i-index+1;\\n            string substring=s.substr(index,substring_size);\\n            if(map.find(substring)==map.end())\\n            {\\n                map[substring]++;\\n                ans=max(ans,1+helper(i+1,s));\\n                map.erase(substring);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    int maxUniqueSplit(string s) \\n    {\\n        return helper(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>map;\\n    int helper(int index,string s)\\n    {\\n        if(index==s.size())\\n            return 0;\\n\\n        int ans=INT_MIN;\\n        for(int i=index;i<s.size();i++)\\n        {\\n            int substring_size=i-index+1;\\n            string substring=s.substr(index,substring_size);\\n            if(map.find(substring)==map.end())\\n            {\\n                map[substring]++;\\n                ans=max(ans,1+helper(i+1,s));\\n                map.erase(substring);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    int maxUniqueSplit(string s) \\n    {\\n        return helper(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114668,
                "title": "java-beats-75-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet<>();\\n        dfs(s, 0, set);\\n        return count;\\n    }\\n    public void dfs(String s, int idx, Set<String> set) {\\n        if (idx == s.length()) {\\n            count = Math.max(count, set.size());\\n            return;\\n        }\\n        for (int i = idx; i < s.length(); i++) {\\n            String sub = s.substring(idx,i+1);\\n            if (!set.contains(sub)) {\\n                set.add(sub);\\n                dfs(s, i+1, set);\\n                set.remove(sub);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet<>();\\n        dfs(s, 0, set);\\n        return count;\\n    }\\n    public void dfs(String s, int idx, Set<String> set) {\\n        if (idx == s.length()) {\\n            count = Math.max(count, set.size());\\n            return;\\n        }\\n        for (int i = idx; i < s.length(); i++) {\\n            String sub = s.substring(idx,i+1);\\n            if (!set.contains(sub)) {\\n                set.add(sub);\\n                dfs(s, i+1, set);\\n                set.remove(sub);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109700,
                "title": "c-solution-recursive-solution-faster-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<string,int> mp;\\npublic: \\n    int maxUniqueSplit(string s) {\\n        if(s.size() == 0) return 0;\\n        \\n        string str = \"\";\\n        int ans = 0;\\n\\n        for(int i=0;i<s.size();i++){\\n            str += s[i];\\n            if(mp[str] == 0){\\n                mp[str]++;\\n                ans = max(ans,1 + maxUniqueSplit(s.substr(i+1)));\\n                mp[str]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string,int> mp;\\npublic: \\n    int maxUniqueSplit(string s) {\\n        if(s.size() == 0) return 0;\\n        \\n        string str = \"\";\\n        int ans = 0;\\n\\n        for(int i=0;i<s.size();i++){\\n            str += s[i];\\n            if(mp[str] == 0){\\n                mp[str]++;\\n                ans = max(ans,1 + maxUniqueSplit(s.substr(i+1)));\\n                mp[str]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108762,
                "title": "c-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> us;\\n    int solve(int ind,string & s){\\n        if(ind>=s.size()) return 0;\\n        int maxi = 0;\\n        for(int i=ind;i<s.size();i++){\\n            string t = s.substr(ind,i-ind+1);\\n            if(us.find(t)==us.end())\\n            {\\n                us.insert(t);\\n                maxi = max(maxi,1+solve(i+1,s));\\n                us.erase(t);\\n            }\\n            \\n        }\\n        return maxi;\\n    }\\n    int maxUniqueSplit(string s) {\\n        return solve(0,s);\\n    }\\n};\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> us;\\n    int solve(int ind,string & s){\\n        if(ind>=s.size()) return 0;\\n        int maxi = 0;\\n        for(int i=ind;i<s.size();i++){\\n            string t = s.substr(ind,i-ind+1);\\n            if(us.find(t)==us.end())\\n            {\\n                us.insert(t);\\n                maxi = max(maxi,1+solve(i+1,s));\\n                us.erase(t);\\n            }\\n            \\n        }\\n        return maxi;\\n    }\\n    int maxUniqueSplit(string s) {\\n        return solve(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108143,
                "title": "easy-simple-c-short-code",
                "content": "# Intuition\\nWe will be using a set and a simple backtrack algorithm\\n\\n# Approach\\n1.We will take a set and then call the recursive function.\\n2.In the recursive function we will take maxi = 0.\\n3.In the loop that starts from 1->length of string , we will take a substring and see if it is present in the set or not.\\n4.if it is not present we will add the string into set and call the recursive function.\\n5.After completeing traversal we will backtrack.\\n6.Finally we will return the maxi value.\\n\\nWe will doing for all the choices of substring.\\n\\n# Complexity\\n- Time complexity:\\n0(n) - for loop\\n\\n- Space complexity:\\n0(n) - set\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int helper(string s, unordered_set<string>& st){\\n        int maxi = 0;\\n        for(int i=1;i<=s.size();i++){\\n            string candidate = s.substr(0,i-0);\\n            if(st.find(candidate)==st.end()){\\n                st.insert(candidate);\\n                maxi = max(maxi,1+helper(s.substr(i,s.size()-i),st));\\n                st.erase(candidate);\\n            }            \\n        }\\n        return maxi;\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>st;\\n        return helper(s,st);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(string s, unordered_set<string>& st){\\n        int maxi = 0;\\n        for(int i=1;i<=s.size();i++){\\n            string candidate = s.substr(0,i-0);\\n            if(st.find(candidate)==st.end()){\\n                st.insert(candidate);\\n                maxi = max(maxi,1+helper(s.substr(i,s.size()-i),st));\\n                st.erase(candidate);\\n            }            \\n        }\\n        return maxi;\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>st;\\n        return helper(s,st);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107949,
                "title": "python-short-and-clean-dfs-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n\\n\\n        def dfs(st,seen):\\n            mx=0\\n            \\n            for i in range(len(st)):\\n                if st[:i+1] in seen:\\n                    continue\\n\\n                mx=max(mx , 1 + dfs(st[i+1:],seen | {st[:i+1]}))\\n            \\n            return mx\\n        \\n        return dfs(s,set())\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n\\n\\n        def dfs(st,seen):\\n            mx=0\\n            \\n            for i in range(len(st)):\\n                if st[:i+1] in seen:\\n                    continue\\n\\n                mx=max(mx , 1 + dfs(st[i+1:],seen | {st[:i+1]}))\\n            \\n            return mx\\n        \\n        return dfs(s,set())\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071977,
                "title": "java-backtracking-easy",
                "content": "```\\nclass Solution {\\n    HashSet<String> set = new HashSet<>();\\n    int count;\\n    public int maxUniqueSplit(String s) {\\n        helper(s, 0, \"\");\\n        return count;\\n    }\\n    \\n    public void helper(String s,int idx, String str )\\n    {\\n        if(idx == s.length())\\n        {\\n           count = Math.max(count, set.size());\\n            return;\\n        }\\n          \\n        \\n        for(int i =idx;i<s.length();i++)\\n        {        \\n            str = s.substring(idx,i+1);\\n            if(set.contains(str))\\n                continue;\\n             set.add(str);\\n             helper(s,i+1, str);\\n             set.remove(str);\\n           \\n        }\\n       \\n      \\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    HashSet<String> set = new HashSet<>();\\n    int count;\\n    public int maxUniqueSplit(String s) {\\n        helper(s, 0, \"\");\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3064534,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nstruct t{\\n    int len;\\n    char s[16];\\n};\\nbool find(struct t *map,int index,char *temp,int temp_len){\\n    if(index==-1) return false;\\n    for(int i=0;i<=index;i++){\\n        if(map[i].len==temp_len){\\n            if(!strncmp(&(map[i].s),temp,temp_len)){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n} \\nbool isvaild(char *s,int slen,int spilt,int *numberOfActiveBits){\\n    struct t map[slen];\\n    int index=-1;\\n    \\n    char temp[slen];\\n    int temp_len=1;\\n    memcpy(&temp[0],&s[0],1);\\n    \\n    // printf(\"map[index].s : %s\",map[index].s);\\n\\n    for(int i=0;i<slen-1;i++){\\n        if((spilt>>i)&1){\\n            if(find(map,index,temp,temp_len)){\\n                return false;\\n            }\\n            index++;\\n            memcpy(&(map[index].s),&temp[0],temp_len);\\n            map[index].s[temp_len]=\\'\\\\0\\';\\n            map[index].len=temp_len;\\n            (*numberOfActiveBits)++;\\n            // printf(\"split : %d | map : %s | len : %d, | numberOfActiveBits : %d\\\\n\",spilt,map[index].s,map[index].len,*numberOfActiveBits);\\n\\n            temp_len=0;\\n            temp[temp_len++]=s[i+1];\\n            \\n            \\n        }\\n        else{\\n            temp[temp_len++]=s[i+1];\\n        }\\n        \\n    }\\n    if(temp_len!=0 && find(map,index,temp,temp_len)) return false;\\n    // printf(\"------\\\\n\");\\n    return true;\\n}\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\nint maxUniqueSplit(char * s){\\n    int slen=strlen(s);\\n    if(slen==1) return 1;\\n    int maxsize=pow(2,slen-1);\\n    printf(\"maxsize : %d\\\\n\",maxsize);\\n    int maximumSplits=0;\\n    for(int split=0;split<maxsize;split++){\\n        int numberOfBars = 0;\\n        if(isvaild(s, slen,split, &numberOfBars))\\n            maximumSplits = max(maximumSplits, numberOfBars);\\n    }\\n    \\n    return maximumSplits+1;\\n       \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct t{\\n    int len;\\n    char s[16];\\n};\\nbool find(struct t *map,int index,char *temp,int temp_len){\\n    if(index==-1) return false;\\n    for(int i=0;i<=index;i++){\\n        if(map[i].len==temp_len){\\n            if(!strncmp(&(map[i].s),temp,temp_len)){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n} \\nbool isvaild(char *s,int slen,int spilt,int *numberOfActiveBits){\\n    struct t map[slen];\\n    int index=-1;\\n    \\n    char temp[slen];\\n    int temp_len=1;\\n    memcpy(&temp[0],&s[0],1);\\n    \\n    // printf(\"map[index].s : %s\",map[index].s);\\n\\n    for(int i=0;i<slen-1;i++){\\n        if((spilt>>i)&1){\\n            if(find(map,index,temp,temp_len)){\\n                return false;\\n            }\\n            index++;\\n            memcpy(&(map[index].s),&temp[0],temp_len);\\n            map[index].s[temp_len]=\\'\\\\0\\';\\n            map[index].len=temp_len;\\n            (*numberOfActiveBits)++;\\n            // printf(\"split : %d | map : %s | len : %d, | numberOfActiveBits : %d\\\\n\",spilt,map[index].s,map[index].len,*numberOfActiveBits);\\n\\n            temp_len=0;\\n            temp[temp_len++]=s[i+1];\\n            \\n            \\n        }\\n        else{\\n            temp[temp_len++]=s[i+1];\\n        }\\n        \\n    }\\n    if(temp_len!=0 && find(map,index,temp,temp_len)) return false;\\n    // printf(\"------\\\\n\");\\n    return true;\\n}\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\nint maxUniqueSplit(char * s){\\n    int slen=strlen(s);\\n    if(slen==1) return 1;\\n    int maxsize=pow(2,slen-1);\\n    printf(\"maxsize : %d\\\\n\",maxsize);\\n    int maximumSplits=0;\\n    for(int split=0;split<maxsize;split++){\\n        int numberOfBars = 0;\\n        if(isvaild(s, slen,split, &numberOfBars))\\n            maximumSplits = max(maximumSplits, numberOfBars);\\n    }\\n    \\n    return maximumSplits+1;\\n       \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3049074,
                "title": "easy-c-partition-dp-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = 1; \\n    int count(string s , int index , set < string > & st ){\\n        if(index == s.size()){\\n            return 0; \\n        }\\n        int maxi = -1*1e9 ; \\n        string temp = \"\"; \\n        bool tt = false; \\n        int curr = 0 ; \\n        for(int i = index ; i < s.size() ; i++){\\n            temp += s[i]; \\n            if(st.find(temp) == st.end()){\\n                st.insert(temp); \\n                int p = count(s , i+1 , st); \\n                st.erase(temp); \\n                tt = true;\\n               maxi = max(maxi , p+1);  \\n            }\\n        }\\n        return maxi ;     \\n    }\\n    int maxUniqueSplit(string s) {\\n        set < string > st ; \\n        return count(s, 0 , st ); \\n        return ans ;         \\n    }\\n};\\n\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = 1; \\n    int count(string s , int index , set < string > & st ){\\n        if(index == s.size()){\\n            return 0; \\n        }\\n        int maxi = -1*1e9 ; \\n        string temp = \"\"; \\n        bool tt = false; \\n        int curr = 0 ; \\n        for(int i = index ; i < s.size() ; i++){\\n            temp += s[i]; \\n            if(st.find(temp) == st.end()){\\n                st.insert(temp); \\n                int p = count(s , i+1 , st); \\n                st.erase(temp); \\n                tt = true;\\n               maxi = max(maxi , p+1);  \\n            }\\n        }\\n        return maxi ;     \\n    }\\n    int maxUniqueSplit(string s) {\\n        set < string > st ; \\n        return count(s, 0 , st ); \\n        return ans ;         \\n    }\\n};\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975851,
                "title": "swift-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take each character, add to set if don\\'t exist\\n2. `for` loop will add next character\\n3. Update result according to max value once reach base condition reached\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n.2^n)$$\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ + $$O(n)$$ + $$O(n)$$ + $$O(1)$$\\nAuxillary stack + Set + Temp DS + Result\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func maxUniqueSplit(_ s: String) -> Int {\\n        var result = Int.min\\n        var temp = [String]()\\n        var set = Set<String>()\\n        let index = 0\\n        var n = s.count\\n        f(index, s, n, &set, &temp, &result)\\n        return result\\n    }\\n\\n    private func f(_ index: Int,\\n                    _ s: String,\\n                    _ n: Int,\\n                    _ set: inout Set<String>,\\n                    _ temp: inout [String],\\n                    _ result: inout Int) {\\n        if index == n {\\n            result = max(result, temp.count)\\n            return\\n        }\\n\\n        var string = String()\\n\\n        for i in index..<n {\\n            string.append(s[i])\\n\\n            if !set.contains(string) {\\n                set.insert(string)\\n                temp.append(string)\\n\\n                f(i + 1, s, n, &set, &temp, &result)\\n\\n                set.remove(string)\\n                temp.removeLast()\\n            }\\n        }\\n    }\\n}\\n\\nextension String {\\n    subscript (_ at: Int) -> Self {\\n        return String( self[index(startIndex, offsetBy: at)] )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxUniqueSplit(_ s: String) -> Int {\\n        var result = Int.min\\n        var temp = [String]()\\n        var set = Set<String>()\\n        let index = 0\\n        var n = s.count\\n        f(index, s, n, &set, &temp, &result)\\n        return result\\n    }\\n\\n    private func f(_ index: Int,\\n                    _ s: String,\\n                    _ n: Int,\\n                    _ set: inout Set<String>,\\n                    _ temp: inout [String],\\n                    _ result: inout Int) {\\n        if index == n {\\n            result = max(result, temp.count)\\n            return\\n        }\\n\\n        var string = String()\\n\\n        for i in index..<n {\\n            string.append(s[i])\\n\\n            if !set.contains(string) {\\n                set.insert(string)\\n                temp.append(string)\\n\\n                f(i + 1, s, n, &set, &temp, &result)\\n\\n                set.remove(string)\\n                temp.removeLast()\\n            }\\n        }\\n    }\\n}\\n\\nextension String {\\n    subscript (_ at: Int) -> Self {\\n        return String( self[index(startIndex, offsetBy: at)] )\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969868,
                "title": "backtracking-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int f(string s, set<string> vis)\\n    {\\n        if(vis.find(s)!=vis.end()) return 0;\\n        int n=s.size();\\n        if(n==0 || n==1) return n;\\n        int ans=1;\\n        for(int k=1; k<n; k++)\\n        {\\n            string a=s.substr(0,k);\\n            string b=s.substr(k);\\n            if(vis.find(a)==vis.end())\\n            {\\n                vis.insert(a);\\n                int t=1+f(b,vis);\\n                ans=max(ans,t);\\n                auto it=vis.find(a);\\n                vis.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxUniqueSplit(string s) \\n    {\\n        set<string> vis;\\n        int n=s.size();\\n        return f(s,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int f(string s, set<string> vis)\\n    {\\n        if(vis.find(s)!=vis.end()) return 0;\\n        int n=s.size();\\n        if(n==0 || n==1) return n;\\n        int ans=1;\\n        for(int k=1; k<n; k++)\\n        {\\n            string a=s.substr(0,k);\\n            string b=s.substr(k);\\n            if(vis.find(a)==vis.end())\\n            {\\n                vis.insert(a);\\n                int t=1+f(b,vis);\\n                ans=max(ans,t);\\n                auto it=vis.find(a);\\n                vis.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxUniqueSplit(string s) \\n    {\\n        set<string> vis;\\n        int n=s.size();\\n        return f(s,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968470,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void helper(string s,int& ans,set<string>st,int ind,int n)\\n   {\\n     if (ind>=n)\\n     {\\n         int curr=st.size();\\n         if (curr>ans)\\n         {\\n         ans=max(ans,curr);\\n         for (auto it:st)\\n         {\\n             cout<<it<<\" \";\\n         }\\n         }\\n     }\\n     for (int i=ind;i<n;i++)\\n     {\\n         if (st.find(s.substr(ind,ind-i+1))==st.end())\\n         {\\n             string temp=s.substr(ind,i-ind+1);\\n             st.insert(temp);\\n             //cout<<s.substr(ind,ind-i+1)<<\" \";\\n             helper(s,ans,st,i+1,n);\\n\\n            st.erase(temp);\\n         }\\n     }\\n   }\\n    int maxUniqueSplit(string s) {\\n        set<string>st;\\n        int ans=INT_MIN;\\n        int n=s.size();\\n        helper(s,ans,st,0,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void helper(string s,int& ans,set<string>st,int ind,int n)\\n   {\\n     if (ind>=n)\\n     {\\n         int curr=st.size();\\n         if (curr>ans)\\n         {\\n         ans=max(ans,curr);\\n         for (auto it:st)\\n         {\\n             cout<<it<<\" \";\\n         }\\n         }\\n     }\\n     for (int i=ind;i<n;i++)\\n     {\\n         if (st.find(s.substr(ind,ind-i+1))==st.end())\\n         {\\n             string temp=s.substr(ind,i-ind+1);\\n             st.insert(temp);\\n             //cout<<s.substr(ind,ind-i+1)<<\" \";\\n             helper(s,ans,st,i+1,n);\\n\\n            st.erase(temp);\\n         }\\n     }\\n   }\\n    int maxUniqueSplit(string s) {\\n        set<string>st;\\n        int ans=INT_MIN;\\n        int n=s.size();\\n        helper(s,ans,st,0,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2953345,
                "title": "c",
                "content": "```\\n// RS Hash Function\\nunsigned int RSHash(char *str, int n)\\n{\\n    unsigned int b = 378551;\\n    unsigned int a = 63689;\\n    unsigned int hash = 0;\\n\\n    for(int i = 0; i < n ;i++)\\n    {\\n        hash = hash * a + str[i];\\n        a *= b;\\n    }\\n\\n    return (hash & 0x7FFFFFFF);\\n}\\nvoid dfs(char * s, int* hash, int N, int* ans, int count){\\n    if(*s == \\'\\\\0\\'){\\n        *ans = fmax(*ans, count);\\n        return ;\\n    }\\n    int n = strlen(s);\\n    for(int i = 1; i <= n; i++){\\n        unsigned int val = RSHash(s, i);\\n        unsigned int d = val;\\n        while(1){\\n            if(hash[d % N] == -1){\\n                hash[d % N] = val;\\n                break;\\n            }\\n            else if(hash[d % N] == val){\\n                goto next;\\n            }\\n            else\\n                d++;\\n        }\\n    \\n        dfs(&s[i], hash, N, ans, count+1);\\n        hash[d % N] = -1;\\n        \\n        next: \\n            continue;\\n    }\\n}\\n\\nint maxUniqueSplit(char * s){\\n    int n = strlen(s);\\n    int N = 50;\\n    int hash[50] ;\\n    for(int i = 0; i < 50; i++){\\n        hash[i] = -1;\\n    }\\n    int ans = 0;\\n    dfs(s, hash, N, &ans, 0);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// RS Hash Function\\nunsigned int RSHash(char *str, int n)\\n{\\n    unsigned int b = 378551;\\n    unsigned int a = 63689;\\n    unsigned int hash = 0;\\n\\n    for(int i = 0; i < n ;i++)\\n    {\\n        hash = hash * a + str[i];\\n        a *= b;\\n    }\\n\\n    return (hash & 0x7FFFFFFF);\\n}\\nvoid dfs(char * s, int* hash, int N, int* ans, int count){\\n    if(*s == \\'\\\\0\\'){\\n        *ans = fmax(*ans, count);\\n        return ;\\n    }\\n    int n = strlen(s);\\n    for(int i = 1; i <= n; i++){\\n        unsigned int val = RSHash(s, i);\\n        unsigned int d = val;\\n        while(1){\\n            if(hash[d % N] == -1){\\n                hash[d % N] = val;\\n                break;\\n            }\\n            else if(hash[d % N] == val){\\n                goto next;\\n            }\\n            else\\n                d++;\\n        }\\n    \\n        dfs(&s[i], hash, N, ans, count+1);\\n        hash[d % N] = -1;\\n        \\n        next: \\n            continue;\\n    }\\n}\\n\\nint maxUniqueSplit(char * s){\\n    int n = strlen(s);\\n    int N = 50;\\n    int hash[50] ;\\n    for(int i = 0; i < 50; i++){\\n        hash[i] = -1;\\n    }\\n    int ans = 0;\\n    dfs(s, hash, N, &ans, 0);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2929750,
                "title": "one-simple-way-to-boost-the-speed",
                "content": "```\\nclass Solution {\\n   int res = Integer.MIN_VALUE;\\n    public int maxUniqueSplit(String s) {\\n            process(s,0,new HashSet<>(),0);\\n            return res;\\n    }\\n\\n    public void process(String s, int idx, HashSet<String> set,int len){\\n        if(idx == s.length()){\\n            res = Math.max(len,res);\\n            return;\\n        }\\n        if(s.length()-idx + len < res) return; // early stop to boost speed\\n        for (int i = idx + 1; i <= s.length(); i++) {\\n            String cur_str = s.substring(idx,i);\\n                    if(set.contains(cur_str)) continue;\\n                    set.add(cur_str);\\n                    process(s,i,set,len+1);\\n                    set.remove(cur_str);\\n        }\\n        return;\\n    }\\n}\\n```\\n\\nNotice this line \"if(s.length()-idx + len < res) return;\" before putting this early stop condition, the run time is 99ms\\nAfter having this condition, I got like 19ms runtime. If the current array size of substrings is already larger than waht we got, we dont need to explore this branch..",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   int res = Integer.MIN_VALUE;\\n    public int maxUniqueSplit(String s) {\\n            process(s,0,new HashSet<>(),0);\\n            return res;\\n    }\\n\\n    public void process(String s, int idx, HashSet<String> set,int len){\\n        if(idx == s.length()){\\n            res = Math.max(len,res);\\n            return;\\n        }\\n        if(s.length()-idx + len < res) return; // early stop to boost speed\\n        for (int i = idx + 1; i <= s.length(); i++) {\\n            String cur_str = s.substring(idx,i);\\n                    if(set.contains(cur_str)) continue;\\n                    set.add(cur_str);\\n                    process(s,i,set,len+1);\\n                    set.remove(cur_str);\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909920,
                "title": "cpp-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string>t;\\n    int maxi=1;\\n    void helper(int ind, string &s){\\n        if(ind>=s.size()){\\n            int p=t.size();\\n            maxi=max(maxi,p);\\n            return ;\\n        }\\n        string temp=\"\";\\n        for(int i=ind;i<s.size();i++){\\n            temp+=s[i];\\n            if(!t.count(temp)){\\n                t.insert(temp);\\n                helper(i+1,s);\\n                t.erase(temp);\\n            }\\n        }\\n        return ;\\n    }\\n    int maxUniqueSplit(string s) {\\n        helper(0,s);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>t;\\n    int maxi=1;\\n    void helper(int ind, string &s){\\n        if(ind>=s.size()){\\n            int p=t.size();\\n            maxi=max(maxi,p);\\n            return ;\\n        }\\n        string temp=\"\";\\n        for(int i=ind;i<s.size();i++){\\n            temp+=s[i];\\n            if(!t.count(temp)){\\n                t.insert(temp);\\n                helper(i+1,s);\\n                t.erase(temp);\\n            }\\n        }\\n        return ;\\n    }\\n    int maxUniqueSplit(string s) {\\n        helper(0,s);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879547,
                "title": "python3-backtracking",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans = -1\\n        def solve(i , l):\\n            nonlocal ans\\n            if i == len(s):\\n                ans = max(ans , len(set(l)))\\n            for j in range(i + 1  , len(s) + 1 ):\\n                solve(j , l + [s[i: j]])\\n        solve(0 , []) \\n        return ans                \\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans = -1\\n        def solve(i , l):\\n            nonlocal ans\\n            if i == len(s):\\n                ans = max(ans , len(set(l)))\\n            for j in range(i + 1  , len(s) + 1 ):\\n                solve(j , l + [s[i: j]])\\n        solve(0 , []) \\n        return ans                \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869553,
                "title": "swift-solution-100-fast",
                "content": "```\\nclass Solution {\\n    func countUniqueSplit(_ start:Int,_ uniqueSet: inout Set<String>,_ s: [Character],_ ans: inout Int){\\n    \\n    ans = max(ans, uniqueSet.count)\\n    var i = start\\n    while i < s.count{\\n        i+=1\\n        var string1 = String(s[start..<i])\\n        if uniqueSet.contains(string1){\\n            continue\\n        }\\n        uniqueSet.insert(string1)\\n        countUniqueSplit(i,&uniqueSet,s, &ans)\\n        uniqueSet.remove(string1)\\n    }\\n}\\n\\nfunc maxUniqueSplit(_ s: String) -> Int {\\n    var countSet = Set<String>()\\n    var ans = 0\\n    var s = Array(s)\\n    countUniqueSplit(0,&countSet, s, &ans)\\n    return ans\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func countUniqueSplit(_ start:Int,_ uniqueSet: inout Set<String>,_ s: [Character],_ ans: inout Int){\\n    \\n    ans = max(ans, uniqueSet.count)\\n    var i = start\\n    while i < s.count{\\n        i+=1\\n        var string1 = String(s[start..<i])\\n        if uniqueSet.contains(string1){\\n            continue\\n        }\\n        uniqueSet.insert(string1)\\n        countUniqueSplit(i,&uniqueSet,s, &ans)\\n        uniqueSet.remove(string1)\\n    }\\n}\\n\\nfunc maxUniqueSplit(_ s: String) -> Int {\\n    var countSet = Set<String>()\\n    var ans = 0\\n    var s = Array(s)\\n    countUniqueSplit(0,&countSet, s, &ans)\\n    return ans\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786620,
                "title": "python-backtracking-and-pruning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxUniqueSplit_fun(self, s: str, cur_list, sub_set, res) -> int:\\n        if len(cur_list) > 0:\\n            sub = s[cur_list[-1]:] \\n            if len(sub) > 0 and sub not in sub_set:\\n                res[0] = max(res[0], len(cur_list) + 1)\\n            if len(cur_list) + len(s) - cur_list[-1] - 1 < res[0]:\\n                return\\n        start = 1\\n        if len(cur_list) > 0:\\n            start = cur_list[-1] + 1\\n        for i in range(start, len(s)):\\n            sub = s[start-1:i]\\n            if sub not in sub_set:\\n                cur_list.append(i)\\n                sub_set.add(sub)\\n                self.maxUniqueSplit_fun(s, cur_list, sub_set, res)\\n                sub_set.remove(sub)\\n                del cur_list[-1]\\n        \\n    def maxUniqueSplit(self, s: str) -> int:\\n        res = [1]\\n        self.maxUniqueSplit_fun(s, [], set(), res)\\n        return res[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit_fun(self, s: str, cur_list, sub_set, res) -> int:\\n        if len(cur_list) > 0:\\n            sub = s[cur_list[-1]:] \\n            if len(sub) > 0 and sub not in sub_set:\\n                res[0] = max(res[0], len(cur_list) + 1)\\n            if len(cur_list) + len(s) - cur_list[-1] - 1 < res[0]:\\n                return\\n        start = 1\\n        if len(cur_list) > 0:\\n            start = cur_list[-1] + 1\\n        for i in range(start, len(s)):\\n            sub = s[start-1:i]\\n            if sub not in sub_set:\\n                cur_list.append(i)\\n                sub_set.add(sub)\\n                self.maxUniqueSplit_fun(s, cur_list, sub_set, res)\\n                sub_set.remove(sub)\\n                del cur_list[-1]\\n        \\n    def maxUniqueSplit(self, s: str) -> int:\\n        res = [1]\\n        self.maxUniqueSplit_fun(s, [], set(), res)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768254,
                "title": "c-fast-and-furious",
                "content": "```\\nclass Solution {\\n    void maxUniqueSplit(const string& s, int idx, unordered_set<string>& used, int& mc) {\\n        if (idx >= s.size()) {\\n            if (used.size() > mc) {\\n                mc = used.size();\\n            }\\n            return;\\n        }\\n        if (used.size() + s.size() - idx <= mc) {\\n            return;\\n        }\\n\\n        for (int i = 1; idx + i <= s.size(); i++) {\\n            const string& ss = s.substr(idx, i);\\n            if (used.find(ss) == used.end()) {\\n                used.insert(ss);\\n                maxUniqueSplit(s, idx + i, used, mc);\\n                used.erase(ss);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    \\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> used;\\n        int mc = 0;\\n        maxUniqueSplit(s, 0, used, mc);\\n        return mc;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void maxUniqueSplit(const string& s, int idx, unordered_set<string>& used, int& mc) {\\n        if (idx >= s.size()) {\\n            if (used.size() > mc) {\\n                mc = used.size();\\n            }\\n            return;\\n        }\\n        if (used.size() + s.size() - idx <= mc) {\\n            return;\\n        }\\n\\n        for (int i = 1; idx + i <= s.size(); i++) {\\n            const string& ss = s.substr(idx, i);\\n            if (used.find(ss) == used.end()) {\\n                used.insert(ss);\\n                maxUniqueSplit(s, idx + i, used, mc);\\n                used.erase(ss);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    \\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> used;\\n        int mc = 0;\\n        maxUniqueSplit(s, 0, used, mc);\\n        return mc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745644,
                "title": "can-someone-please-explain-to-me-this-test",
                "content": "Why this test expected a result of 11 : \"**wwwzfvedwfvhsww**\" ?\\n\\nI found only a result of 10 : **[\\'w\\', \\'ww\\', \\'z\\', \\'f\\', \\'v\\', \\'e\\', \\'d\\', \\'wf\\', \\'vh\\', \\'sww\\']**",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2739339,
                "title": "java-easy-solution-backtracking",
                "content": "```\\nclass Solution {\\n    private int maxLen = 0;\\n    private void backtrack(String s, int index, Set<String>set){\\n        if(index == s.length()){\\n            return;\\n        }\\n        for (int i = index + 1; i <= s.length(); i++) {\\n            String sub = s.substring(index, i);\\n            if (set.contains(sub)){ \\n                continue;\\n            }\\n            set.add(sub);\\n            maxLen = Math.max(maxLen, set.size());\\n            backtrack(s, i, set);\\n            set.remove(sub);\\n        }\\n        \\n    }\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet<>();\\n        backtrack(s, 0, set);\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    private int maxLen = 0;\\n    private void backtrack(String s, int index, Set<String>set){\\n        if(index == s.length()){\\n            return;\\n        }\\n        for (int i = index + 1; i <= s.length(); i++) {\\n            String sub = s.substring(index, i);\\n            if (set.contains(sub)){ \\n                continue;\\n            }\\n            set.add(sub);\\n            maxLen = Math.max(maxLen, set.size());\\n            backtrack(s, i, set);\\n            set.remove(sub);\\n        }\\n        \\n    }\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet<>();\\n        backtrack(s, 0, set);\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731922,
                "title": "easy-to-understand-simple-backtracking-of-the-sub-string-that-is-get-used",
                "content": "class Solution {\\n    private:\\n   void solve(int ptr,int &ans,int currcnt,unordered_map<string,bool>&mp,string &s){\\n        if(ptr==s.size()){\\n            ans=max(ans,currcnt);\\n            return;\\n        }\\n        for(int i=1;i<s.size()-ptr+1;i++){\\n            string temp=s.substr(ptr,i);\\n            if(mp[temp]==0){\\n                mp[temp]=1;\\n                solve(ptr+i,ans,currcnt+1,mp,s);\\n                mp[temp]=0;\\n            }\\n        }\\n    }\\npublic:\\n    int maxUniqueSplit(string s) {\\n      //  vector<string>res;\\n        unordered_map<string,bool>mp;\\n        int ans=0,currcnt=0;\\n        solve(0,ans,0,mp,s);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    private:\\n   void solve(int ptr,int &ans,int currcnt,unordered_map<string,bool>&mp,string &s){\\n        if(ptr==s.size()){\\n            ans=max(ans,currcnt);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2727946,
                "title": "dfs-backtracking-java",
                "content": "```\\nclass Solution {\\n    private int backtrack(String s, int i, int j, Set<String> set) {\\n        if(j == s.length()) {\\n            return set.size();\\n        }\\n        int max = -1;\\n        for(int k=j+1; k<=s.length(); k++) {\\n            String substr = s.substring(j, k);\\n            if(!set.contains(substr)) {\\n                set.add(substr);\\n                int res = backtrack(s, j, k, set);\\n                max = Math.max(res, max);\\n                set.remove(substr);\\n            }\\n        }\\n        return max;\\n    }\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet();\\n        return backtrack(s, 0, 0, set);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int backtrack(String s, int i, int j, Set<String> set) {\\n        if(j == s.length()) {\\n            return set.size();\\n        }\\n        int max = -1;\\n        for(int k=j+1; k<=s.length(); k++) {\\n            String substr = s.substring(j, k);\\n            if(!set.contains(substr)) {\\n                set.add(substr);\\n                int res = backtrack(s, j, k, set);\\n                max = Math.max(res, max);\\n                set.remove(substr);\\n            }\\n        }\\n        return max;\\n    }\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet();\\n        return backtrack(s, 0, 0, set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715378,
                "title": "c-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>st;\\n        int ans=0;\\n        fun(s,st,ans);\\n        return ans;\\n    }\\n    void fun(string s,unordered_set<string>st,int &ans)\\n    {\\n        if(s.length()<=0)\\n        {\\n            int len=st.size();\\n            ans=max(ans,len);\\n            return;\\n        }\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            s1.push_back(s[i]);\\n            if(st.find(s1)==st.end())\\n            {\\n                st.insert(s1);\\n                fun(s.substr(i+1,s.length()),st,ans);\\n                st.erase(s1);\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>st;\\n        int ans=0;\\n        fun(s,st,ans);\\n        return ans;\\n    }\\n    void fun(string s,unordered_set<string>st,int &ans)\\n    {\\n        if(s.length()<=0)\\n        {\\n            int len=st.size();\\n            ans=max(ans,len);\\n            return;\\n        }\\n        string s1=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            s1.push_back(s[i]);\\n            if(st.find(s1)==st.end())\\n            {\\n                st.insert(s1);\\n                fun(s.substr(i+1,s.length()),st,ans);\\n                st.erase(s1);\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707905,
                "title": "c-backtracking-hash-table",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n \\\\times 2^n)$$ -> `n` is the length of string `s`.\\n\\n- Space complexity:\\n$$O(n^2)$$ -> `n` is the length of string `s`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int maxUniqueSplit(const string& s) {\\n        unordered_map<string_view, int> mp;\\n        int ret = 0, a = 0;\\n\\n        function<void(string_view)> solve = [&] (string_view s) {\\n            if (s.empty())\\n                return;\\n            const int n = size(s);\\n            for (int i = 1; i <= n; ++i) {\\n                auto left = s.substr(0, i);\\n                auto right = s.substr(i);\\n                if (++mp[left] == 1)\\n                    ret = max(ret, ++a);\\n                solve(right);\\n                if (--mp[left] == 0)\\n                    --a;\\n            }\\n        };\\n\\n        solve(s);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int maxUniqueSplit(const string& s) {\\n        unordered_map<string_view, int> mp;\\n        int ret = 0, a = 0;\\n\\n        function<void(string_view)> solve = [&] (string_view s) {\\n            if (s.empty())\\n                return;\\n            const int n = size(s);\\n            for (int i = 1; i <= n; ++i) {\\n                auto left = s.substr(0, i);\\n                auto right = s.substr(i);\\n                if (++mp[left] == 1)\\n                    ret = max(ret, ++a);\\n                solve(right);\\n                if (--mp[left] == 0)\\n                    --a;\\n            }\\n        };\\n\\n        solve(s);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689569,
                "title": "easy-c-backtracking-solution",
                "content": "class Solution {\\npublic:\\n    bool IsSafe(string &temp,set<string>&checker)\\n    {\\n        if(checker.find(temp) == checker.end())\\n            return true;\\n        return false;\\n    }\\n    void solve(string &s,int index,set<string>&checker,string &temp,int &ans)\\n    {\\n        if(index == s.length())\\n        {\\n            int len = checker.size();\\n            ans = max(ans,len);\\n            return;\\n        }\\n        // including the character\\n        temp.push_back(s[index]);\\n        if(IsSafe(temp,checker))\\n        {\\n            // adding into set\\n            checker.insert(temp);\\n            string str = \"\";\\n            solve(s,index+1,checker,str,ans);\\n            //backtracking\\n            checker.erase(temp);\\n        }\\n        // not including or excluding \\n        solve(s,index+1,checker,temp,ans);\\n        \\n    }\\n    int maxUniqueSplit(string s) {\\n        string temp = \"\";\\n        set<string>checker;\\n        int index = 0;\\n        int ans = 0;\\n        solve(s,index,checker,temp,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool IsSafe(string &temp,set<string>&checker)\\n    {\\n        if(checker.find(temp) == checker.end())\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2645246,
                "title": "c-backtracking-brute-force-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int func(int i, string&s, unordered_set<string>&us){\\n        if(i == s.size()){\\n            return 0;\\n        }\\n        \\n        int currmax = 0;\\n        for(int j = i; j<s.size(); j++){\\n            string curr(s.begin()+i, s.begin()+j+1);\\n            if(us.count(curr)==0){\\n                us.insert(curr);\\n                currmax = max(currmax, 1+func(j+1, s, us));\\n                us.erase(curr);\\n            }\\n        }\\n        \\n        return currmax;\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>us;\\n        return func(0, s, us);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int func(int i, string&s, unordered_set<string>&us){\\n        if(i == s.size()){\\n            return 0;\\n        }\\n        \\n        int currmax = 0;\\n        for(int j = i; j<s.size(); j++){\\n            string curr(s.begin()+i, s.begin()+j+1);\\n            if(us.count(curr)==0){\\n                us.insert(curr);\\n                currmax = max(currmax, 1+func(j+1, s, us));\\n                us.erase(curr);\\n            }\\n        }\\n        \\n        return currmax;\\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        unordered_set<string>us;\\n        return func(0, s, us);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611885,
                "title": "c-backtracking-hashing-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=1;\\n    \\n    void helper(string &s, unordered_set<string> &mp, int ind){\\n        if(ind == s.length()){\\n            int n = mp.size();\\n            ans = max(ans, n);\\n            return;\\n        }\\n        for(int i=ind; i<s.length(); i++){\\n            if(mp.find(s.substr(ind, i-ind+1)) != mp.end()) continue;\\n            mp.insert(s.substr(ind, i-ind+1));\\n            helper(s, mp, i+1);\\n            mp.erase(s.substr(ind, i-ind+1));\\n        }\\n        \\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> mp;\\n        helper(s, mp, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=1;\\n    \\n    void helper(string &s, unordered_set<string> &mp, int ind){\\n        if(ind == s.length()){\\n            int n = mp.size();\\n            ans = max(ans, n);\\n            return;\\n        }\\n        for(int i=ind; i<s.length(); i++){\\n            if(mp.find(s.substr(ind, i-ind+1)) != mp.end()) continue;\\n            mp.insert(s.substr(ind, i-ind+1));\\n            helper(s, mp, i+1);\\n            mp.erase(s.substr(ind, i-ind+1));\\n        }\\n        \\n    }\\n    \\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> mp;\\n        helper(s, mp, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602938,
                "title": "simple-backtracking-solution-java",
                "content": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet<>();\\n        return findUniqueSubStringCount(s, 0, set);\\n    }\\n    \\n    public int findUniqueSubStringCount(String s, int ind, Set<String> set) {\\n        \\n        if(ind >= s.length()) return 0;\\n        \\n        int result = 0;\\n        for(int i = ind; i < s.length(); i++) {\\n            if(set.contains(s.substring(ind, i + 1))) continue;\\n            \\n            set.add(s.substring(ind, i + 1));\\n            result = Math.max(result, 1 + findUniqueSubStringCount(s, i + 1, set));\\n            set.remove(s.substring(ind, i + 1));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        Set<String> set = new HashSet<>();\\n        return findUniqueSubStringCount(s, 0, set);\\n    }\\n    \\n    public int findUniqueSubStringCount(String s, int ind, Set<String> set) {\\n        \\n        if(ind >= s.length()) return 0;\\n        \\n        int result = 0;\\n        for(int i = ind; i < s.length(); i++) {\\n            if(set.contains(s.substring(ind, i + 1))) continue;\\n            \\n            set.add(s.substring(ind, i + 1));\\n            result = Math.max(result, 1 + findUniqueSubStringCount(s, i + 1, set));\\n            set.remove(s.substring(ind, i + 1));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599741,
                "title": "python-clear-backtrack-solution",
                "content": "```\\n   def maxUniqueSplit(self, s: str) -> int:\\n        self.ans = 0\\n        \\n        def btrack(t, visited):\\n            if not t:\\n                self.ans = max(self.ans, len(visited))\\n            cur = \\'\\'\\n            for i in range(len(t)):\\n                cur += t[i]\\n                if cur not in visited:\\n                    btrack(t[i+1:], visited|{cur})\\n        \\n        btrack(s, set())\\n        return self.ans \\n```",
                "solutionTags": [],
                "code": "```\\n   def maxUniqueSplit(self, s: str) -> int:\\n        self.ans = 0\\n        \\n        def btrack(t, visited):\\n            if not t:\\n                self.ans = max(self.ans, len(visited))\\n            cur = \\'\\'\\n            for i in range(len(t)):\\n                cur += t[i]\\n                if cur not in visited:\\n                    btrack(t[i+1:], visited|{cur})\\n        \\n        btrack(s, set())\\n        return self.ans \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2549499,
                "title": "easy-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int res = 1;\\n    void dfsHelper(string s, int start, unordered_set<string>& st) {\\n        if(start == s.length()){\\n            int n = st.size();\\n            res = max(res, n);\\n            return;\\n        }\\n        for(int i=start; i<s.length();i++){\\n            string temp = s.substr(start, i-start+1);\\n            if(st.find(temp) != st.end()) continue;\\n            st.insert(temp);\\n            dfsHelper(s, i+1, st);\\n            st.erase(temp);\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> st;\\n        dfsHelper(s, 0, st);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 1;\\n    void dfsHelper(string s, int start, unordered_set<string>& st) {\\n        if(start == s.length()){\\n            int n = st.size();\\n            res = max(res, n);\\n            return;\\n        }\\n        for(int i=start; i<s.length();i++){\\n            string temp = s.substr(start, i-start+1);\\n            if(st.find(temp) != st.end()) continue;\\n            st.insert(temp);\\n            dfsHelper(s, i+1, st);\\n            st.erase(temp);\\n        }\\n    }\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> st;\\n        dfsHelper(s, 0, st);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541586,
                "title": "simple-java-backtracking",
                "content": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        return backtrack(s, 0, new HashSet<>());\\n    }\\n    \\n    int backtrack(String s, int idx, HashSet<String> set) {\\n        if(idx == s.length()) return set.size();\\n        \\n        int max = 1;\\n        \\n        for(int i = idx; i < s.length(); i++) {\\n            String sub = s.substring(idx, i + 1);\\n            \\n            if(set.add(sub)) {\\n                max = Math.max(max, backtrack(s, i + 1, set));\\n                set.remove(sub);\\n            }\\n        }\\n            \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxUniqueSplit(String s) {\\n        return backtrack(s, 0, new HashSet<>());\\n    }\\n    \\n    int backtrack(String s, int idx, HashSet<String> set) {\\n        if(idx == s.length()) return set.size();\\n        \\n        int max = 1;\\n        \\n        for(int i = idx; i < s.length(); i++) {\\n            String sub = s.substring(idx, i + 1);\\n            \\n            if(set.add(sub)) {\\n                max = Math.max(max, backtrack(s, i + 1, set));\\n                set.remove(sub);\\n            }\\n        }\\n            \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494293,
                "title": "easy-c-solution-using-set-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> set;\\n        dfs(set,s,0,0);\\n        return res;\\n    }\\n    void dfs(unordered_set<string>& set,string& s,int ind,int cnt)\\n    {\\n        if(ind==s.length())\\n        {\\n            res=max(res,cnt);\\n            return ;\\n        }\\n        //now try every possible string starting from ind if it not in set\\n        string curr=\"\";\\n        for(int i=ind;i<s.length();i++)\\n        {\\n            curr.push_back(s[i]);\\n            if(!set.count(curr))\\n            {\\n                set.insert(curr);\\n                dfs(set,s,i+1,cnt+1);\\n                set.erase(curr);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> set;\\n        dfs(set,s,0,0);\\n        return res;\\n    }\\n    void dfs(unordered_set<string>& set,string& s,int ind,int cnt)\\n    {\\n        if(ind==s.length())\\n        {\\n            res=max(res,cnt);\\n            return ;\\n        }\\n        //now try every possible string starting from ind if it not in set\\n        string curr=\"\";\\n        for(int i=ind;i<s.length();i++)\\n        {\\n            curr.push_back(s[i]);\\n            if(!set.count(curr))\\n            {\\n                set.insert(curr);\\n                dfs(set,s,i+1,cnt+1);\\n                set.erase(curr);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479626,
                "title": "python-backtracking",
                "content": "```\\n\\n\\n\\nclass Solution:\\n    \\n    def recursive(self,s,idx,hashset,ans):\\n        \\n        if idx ==len(s):\\n            count = len(hashset)\\n            \\n            if ans[0]<count:\\n                ans[0] = count\\n            return\\n        \\n        for i in range(idx+1,len(s)+1):\\n            \\n            if s[idx:i] in hashset:\\n                continue\\n                \\n            hashset.add(s[idx:i])\\n            \\n            self.recursive(s,i,hashset,ans)\\n            hashset.remove(s[idx:i])\\n                \\n    \\n    \\n    def maxUniqueSplit(self, s: str) -> int:\\n        hashset = set()\\n        ans = [-1]\\n        self.recursive(s,0,hashset,ans)\\n        return ans[0]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\n\\n\\n\\nclass Solution:\\n    \\n    def recursive(self,s,idx,hashset,ans):\\n        \\n        if idx ==len(s):\\n            count = len(hashset)\\n            \\n            if ans[0]<count:\\n                ans[0] = count\\n            return\\n        \\n        for i in range(idx+1,len(s)+1):\\n            \\n            if s[idx:i] in hashset:\\n                continue\\n                \\n            hashset.add(s[idx:i])\\n            \\n            self.recursive(s,i,hashset,ans)\\n            hashset.remove(s[idx:i])\\n                \\n    \\n    \\n    def maxUniqueSplit(self, s: str) -> int:\\n        hashset = set()\\n        ans = [-1]\\n        self.recursive(s,0,hashset,ans)\\n        return ans[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473823,
                "title": "python3-intuitive-recursion-backtracking-approach",
                "content": "```\\nclass Solution:\\n#Time-Complexity: O(n^n *  n*n), since rec. tree has worst case branching factor and depth of both n! #-> Also, every rec. call will loop at most n times and the splicing operation takes linear time, which\\n#will copy in worst case each and every n characters! -> O(n^(n+2)) -> O(n^n)\\n#Space-Complexity: O(n + n) -> O(n) due to call stack from recursion and seen set!\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans = 0\\n        #2 paramters: remaining string cur, seen which is a set of string elements that \\n        #are already substrings that we formed!\\n        def helper(cur, seen):\\n            nonlocal ans\\n            #base case:if current string is empty, we can\\'t form any more substrings!\\n            if(cur == \"\"):\\n                #we need to update answer!\\n                ans =max(ans, len(seen))\\n                return\\n            \\n            #otherwise, for current string we are on, we need to consider all possible ways we can\\n            #break it up!\\n            #we can take the first char and form substring, first two characters and form substr,                 #..., etc.! Hence, there are choices to make at every local call, where the number\\n            #of choices equals relatively the number of characters in input string cur!\\n            substring = \"\"\\n            for i in range(0, len(cur)):\\n                #concatenate the ith index char of cur to built up substring!\\n                substring += cur[i]\\n                #here, boolean flag serves to indicate whether we recursed or not recursed!\\n                flag = False\\n                #we should only recurse if substring we formed is not already previously\\n                #formed substring in seen set!\\n                if(substring not in seen):\\n                    flag = True\\n                    #mark the substring as used already by updating the seen set!\\n                    seen.add(substring)\\n                    #remainder is splice of cur starting from index i + 1 and onwards \\n                    remainder = cur[i+1:]\\n                    helper(remainder, seen)\\n                #once recursion returns, we don\\'t need to update cur since it\\'s unchanged!\\n                #all we need to do is when we backtrack, we need to restore the state of set!\\n                #if we recursed, we for sure added the substring to the seen set!\\n                #make sure to remove it when backtracking after rec. call finishes!\\n                if(flag):\\n                    seen.remove(substring)\\n        #kick off recursion by passing in entire string input s and seen set as initially empty\\n        #set!\\n        helper(s, set())\\n        #once recursion finishes, ans should be updated to reflect max. number of unique\\n        #substrings we can form!\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#Time-Complexity: O(n^n *  n*n), since rec. tree has worst case branching factor and depth of both n! #-> Also, every rec. call will loop at most n times and the splicing operation takes linear time, which\\n#will copy in worst case each and every n characters! -> O(n^(n+2)) -> O(n^n)\\n#Space-Complexity: O(n + n) -> O(n) due to call stack from recursion and seen set!\\n    def maxUniqueSplit(self, s: str) -> int:\\n        ans = 0\\n        #2 paramters: remaining string cur, seen which is a set of string elements that \\n        #are already substrings that we formed!\\n        def helper(cur, seen):\\n            nonlocal ans\\n            #base case:if current string is empty, we can\\'t form any more substrings!\\n            if(cur == \"\"):\\n                #we need to update answer!\\n                ans =max(ans, len(seen))\\n                return\\n            \\n            #otherwise, for current string we are on, we need to consider all possible ways we can\\n            #break it up!\\n            #we can take the first char and form substring, first two characters and form substr,                 #..., etc.! Hence, there are choices to make at every local call, where the number\\n            #of choices equals relatively the number of characters in input string cur!\\n            substring = \"\"\\n            for i in range(0, len(cur)):\\n                #concatenate the ith index char of cur to built up substring!\\n                substring += cur[i]\\n                #here, boolean flag serves to indicate whether we recursed or not recursed!\\n                flag = False\\n                #we should only recurse if substring we formed is not already previously\\n                #formed substring in seen set!\\n                if(substring not in seen):\\n                    flag = True\\n                    #mark the substring as used already by updating the seen set!\\n                    seen.add(substring)\\n                    #remainder is splice of cur starting from index i + 1 and onwards \\n                    remainder = cur[i+1:]\\n                    helper(remainder, seen)\\n                #once recursion returns, we don\\'t need to update cur since it\\'s unchanged!\\n                #all we need to do is when we backtrack, we need to restore the state of set!\\n                #if we recursed, we for sure added the substring to the seen set!\\n                #make sure to remove it when backtracking after rec. call finishes!\\n                if(flag):\\n                    seen.remove(substring)\\n        #kick off recursion by passing in entire string input s and seen set as initially empty\\n        #set!\\n        helper(s, set())\\n        #once recursion finishes, ans should be updated to reflect max. number of unique\\n        #substrings we can form!\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2470340,
                "title": "python-backtracking-solution",
                "content": "```\\n def maxUniqueSplit(self, s: str) -> int:\\n        def helper(i, seq):\\n            if len(seq) > len(s):\\n                return\\n            \\n            if \\'\\'.join(seq) == s:\\n                self.results.append(seq.copy())\\n          \\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] not in seq:\\n                    temp = seq.copy()\\n                    seq += [s[i:j]]\\n                    helper(j, seq)\\n                    seq = temp.copy()\\n            \\n                        \\n        self.results = []\\n        helper(0, [])\\n        maxlength = -inf\\n        for i in range(len(self.results)):\\n            maxlength = max(maxlength, len(self.results[i]))\\n        \\n        return maxlength\\n",
                "solutionTags": [],
                "code": "```\\n def maxUniqueSplit(self, s: str) -> int:\\n        def helper(i, seq):\\n            if len(seq) > len(s):\\n                return\\n            \\n            if \\'\\'.join(seq) == s:\\n                self.results.append(seq.copy())\\n          \\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] not in seq:\\n                    temp = seq.copy()\\n                    seq += [s[i:j]]\\n                    helper(j, seq)\\n                    seq = temp.copy()\\n            \\n                        \\n        self.results = []\\n        helper(0, [])\\n        maxlength = -inf\\n        for i in range(len(self.results)):\\n            maxlength = max(maxlength, len(self.results[i]))\\n        \\n        return maxlength\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2467595,
                "title": "c-solution-unordered-set-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int split(int i, string temp, unordered_set<string>& st,string& s)\\n    {\\n        if(i==s.size()) return 0;\\n        int a=0,b=0;\\n        temp+=s[i];\\n        if(st.find(temp)==st.end()){\\n            st.insert(temp);\\n            a = 1 + split(i+1, \"\",st,s);\\n            st.erase(temp);\\n        }\\n        else\\n        {\\n            a = split(i+1, temp, st,s);\\n        }\\n        b = split(i+1, temp, st,s);\\n        return max(a,b);\\n    }\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> st;\\n        return split(0,\"\",st,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int split(int i, string temp, unordered_set<string>& st,string& s)\\n    {\\n        if(i==s.size()) return 0;\\n        int a=0,b=0;\\n        temp+=s[i];\\n        if(st.find(temp)==st.end()){\\n            st.insert(temp);\\n            a = 1 + split(i+1, \"\",st,s);\\n            st.erase(temp);\\n        }\\n        else\\n        {\\n            a = split(i+1, temp, st,s);\\n        }\\n        b = split(i+1, temp, st,s);\\n        return max(a,b);\\n    }\\n    int maxUniqueSplit(string s) {\\n        unordered_set<string> st;\\n        return split(0,\"\",st,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458084,
                "title": "simple-and-fast-98-backtracking-in-python",
                "content": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        \"\"\"\\n       https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/\\n\\n        Input is a string.\\n        Return the maximum number of unique splits of the string into consecutive substrings.\\n\\n        The number of splits is not known.\\n        Each len - 1 position to split is a bit, that we are deciding.\\n\\n        # Brute Force\\n        We could start splitting by maximum splits which is len - 1.\\n        Then gradually reducing that if all are not unique.\\n        Testing all possible split variants with given split count.\\n\\n        # Backtracking\\n        Gradually test out the splits, but remember current substrings and backtrack if a duplicate found.\\n        This could be fast enough since the string is max 16 long.\\n        Each step is an optional split. If it finds duplicate, we try making bigger step.\\n        After reaching the end of the string we go back to the last split and try different option.\\n        If we find we made fewer splits, we don\\'t increase the maximum.\\n\\n        \"\"\"\\n\\n        max_unique_strings = 0\\n\\n        # length also gives the number of splits\\n        current_strings = set()\\n\\n        def split(i: int):\\n            nonlocal max_unique_strings, current_strings\\n\\n            if len(current_strings) + (len(s) - i) <= max_unique_strings:\\n                # Cannot find bigger solution even if I split on each character.\\n                return\\n\\n            for j in range(i+1, len(s) + 1):\\n                if s[i:j] in current_strings:\\n                    continue\\n\\n                else:\\n                    current_strings.add(s[i:j])\\n                    if j == len(s):\\n                        max_unique_strings = max(len(current_strings), max_unique_strings)\\n\\n                    else:\\n                        split(j)\\n\\n                    current_strings.remove(s[i:j])\\n\\n            return\\n\\n        split(0)\\n        return max_unique_strings\\n\\n\\nassert Solution().maxUniqueSplit(\"ababccc\") == 5\\n\\n```\\n\\nUpvote and consider following me at https://vaclavkosar.com/",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxUniqueSplit(self, s: str) -> int:\\n        \"\"\"\\n       https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/\\n\\n        Input is a string.\\n        Return the maximum number of unique splits of the string into consecutive substrings.\\n\\n        The number of splits is not known.\\n        Each len - 1 position to split is a bit, that we are deciding.\\n\\n        # Brute Force\\n        We could start splitting by maximum splits which is len - 1.\\n        Then gradually reducing that if all are not unique.\\n        Testing all possible split variants with given split count.\\n\\n        # Backtracking\\n        Gradually test out the splits, but remember current substrings and backtrack if a duplicate found.\\n        This could be fast enough since the string is max 16 long.\\n        Each step is an optional split. If it finds duplicate, we try making bigger step.\\n        After reaching the end of the string we go back to the last split and try different option.\\n        If we find we made fewer splits, we don\\'t increase the maximum.\\n\\n        \"\"\"\\n\\n        max_unique_strings = 0\\n\\n        # length also gives the number of splits\\n        current_strings = set()\\n\\n        def split(i: int):\\n            nonlocal max_unique_strings, current_strings\\n\\n            if len(current_strings) + (len(s) - i) <= max_unique_strings:\\n                # Cannot find bigger solution even if I split on each character.\\n                return\\n\\n            for j in range(i+1, len(s) + 1):\\n                if s[i:j] in current_strings:\\n                    continue\\n\\n                else:\\n                    current_strings.add(s[i:j])\\n                    if j == len(s):\\n                        max_unique_strings = max(len(current_strings), max_unique_strings)\\n\\n                    else:\\n                        split(j)\\n\\n                    current_strings.remove(s[i:j])\\n\\n            return\\n\\n        split(0)\\n        return max_unique_strings\\n\\n\\nassert Solution().maxUniqueSplit(\"ababccc\") == 5\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576639,
                "content": [
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/fab8001d-cd7d-4abc-bc74-e4575feae7e9_1650280031.21348.png)\\n![image](https://assets.leetcode.com/users/images/24560f15-d35f-4fb5-8ca1-88d5f92997c6_1650280035.617771.png)\\n**Please Upvote this Post if you get any help from it.**"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "please don\\'t post solutions here. This is the discussion tab. You can post your solution in the solutions tab."
                    },
                    {
                        "username": "sunnychaubeych",
                        "content": "To all my new homies just do palindrome partitioning because this problem is the exact copy of that. "
                    }
                ]
            },
            {
                "id": 2075837,
                "content": [
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/fab8001d-cd7d-4abc-bc74-e4575feae7e9_1650280031.21348.png)\\n![image](https://assets.leetcode.com/users/images/24560f15-d35f-4fb5-8ca1-88d5f92997c6_1650280035.617771.png)\\n**Please Upvote this Post if you get any help from it.**"
                    },
                    {
                        "username": "schatterjee380",
                        "content": "please don\\'t post solutions here. This is the discussion tab. You can post your solution in the solutions tab."
                    },
                    {
                        "username": "sunnychaubeych",
                        "content": "To all my new homies just do palindrome partitioning because this problem is the exact copy of that. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Eliminate Maximum Number of Monsters",
        "question_content": "<p>You are playing a video game where you are defending your city from a group of <code>n</code> monsters. You are given a <strong>0-indexed</strong> integer array <code>dist</code> of size <code>n</code>, where <code>dist[i]</code> is the <strong>initial distance</strong> in kilometers of the <code>i<sup>th</sup></code> monster from the city.</p>\n\n<p>The monsters walk toward the city at a <strong>constant</strong> speed. The speed of each monster is given to you in an integer array <code>speed</code> of size <code>n</code>, where <code>speed[i]</code> is the speed of the <code>i<sup>th</sup></code> monster in kilometers per minute.</p>\n\n<p>You have a weapon that, once fully charged, can eliminate a <strong>single</strong> monster. However, the weapon takes <strong>one minute</strong> to charge.The weapon is fully charged at the very start.</p>\n\n<p>You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a <strong>loss</strong>, and the game ends before you can use your weapon.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of monsters that you can eliminate before you lose, or </em><code>n</code><em> if you can eliminate all the monsters before they reach the city.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dist = [1,3,4], speed = [1,1,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nIn the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster.\nAll 3 monsters can be eliminated.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dist = [1,1,2,3], speed = [1,1,1,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nIn the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,0,1,2], so you lose.\nYou can only eliminate 1 monster.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> dist = [3,2,4], speed = [5,3,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nIn the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,0,2], so you lose.\nYou can only eliminate 1 monster.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == dist.length == speed.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= dist[i], speed[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1314550,
                "title": "sort-by-arrival",
                "content": "We first compute how many minutes each monster needs to reach the city, based on the initial position and speed.\\n\\nThen, we sort our monsters by their arrival time. \\n\\n> I tried to use min heap (second solution below), but, even with the bulk insert, it was slower than sorting (154 vs 116 ms). \\n\\nFinally, we shoot monsters (in the arrival order), until a monster arrives earlier than we can make our next shot. For example, if we have made 5 shots, and the next monster arrives in 4 minutes, we lose.\\n\\n**C++**\\n```cpp\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n    for (int i = 0; i < dist.size(); ++i)\\n        dist[i] = (dist[i] - 1) / speed[i];\\n    sort(begin(dist), end(dist));\\n    for (int i = 0; i < dist.size(); ++i)\\n        if (i > dist[i])\\n            return i;\\n    return dist.size();\\n} \\n```\\n**Java**\\n```java\\npublic int eliminateMaximum(int[] dist, int[] speed) {\\n    for (int i = 0; i < dist.length; ++i)\\n        dist[i] = (dist[i] - 1) / speed[i];\\n    Arrays.sort(dist);\\n    for (int i = 0; i < dist.length; ++i)\\n        if (i > dist[i])\\n            return i;\\n    return dist.length;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for i, t in enumerate(sorted([(d - 1) // s for d, s in zip(dist, speed)])):\\n            if i > t:\\n                return i\\n        return len(dist)  \\n```\\n#### Min Heap\\nNote that this solution is slower than when sorting, perhaps related to the test cases. Min heap should be faster if we can eliminate less than `n` monsters.\\n\\n**C++**\\n```cpp\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n    for (int i = 0; i < dist.size(); ++i)\\n        dist[i] = (dist[i] - 1) / speed[i];\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(dist), end(dist));\\n    for (int i = 0; i < dist.size() && i <= pq.top(); ++i)\\n        pq.pop();\\n    return dist.size() - pq.size();\\n}   \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n    for (int i = 0; i < dist.size(); ++i)\\n        dist[i] = (dist[i] - 1) / speed[i];\\n    sort(begin(dist), end(dist));\\n    for (int i = 0; i < dist.size(); ++i)\\n        if (i > dist[i])\\n            return i;\\n    return dist.size();\\n} \\n```\n```java\\npublic int eliminateMaximum(int[] dist, int[] speed) {\\n    for (int i = 0; i < dist.length; ++i)\\n        dist[i] = (dist[i] - 1) / speed[i];\\n    Arrays.sort(dist);\\n    for (int i = 0; i < dist.length; ++i)\\n        if (i > dist[i])\\n            return i;\\n    return dist.length;\\n}\\n```\n```python\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for i, t in enumerate(sorted([(d - 1) // s for d, s in zip(dist, speed)])):\\n            if i > t:\\n                return i\\n        return len(dist)  \\n```\n```cpp\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n    for (int i = 0; i < dist.size(); ++i)\\n        dist[i] = (dist[i] - 1) / speed[i];\\n    priority_queue<int, vector<int>, greater<int>> pq(begin(dist), end(dist));\\n    for (int i = 0; i < dist.size() && i <= pq.top(); ++i)\\n        pq.pop();\\n    return dist.size() - pq.size();\\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314389,
                "title": "intuitive-greedy-detailed-in-depth-explanation-and-analysis",
                "content": "**Greedy Assumption 1:** As we need to prevent the monsters from reaching our city by killing one monster every second, the greedy choice will be to kill the monster whose current position is closest to our city.\\n**Proof of failure of above Assumption:** \\n* We must realise that this greedy **assumption fails**, as, although a monster might be at a farther position than others at the current second, it might have such a **high speed** that at the very next second it reaches our city. \\n*  Example: `dist:[2,3], speed[1,5]` --> If we choose to kill 0th(0-indexed) monster at `time = 0` as it has a lower distance value, then at `time = 1`, 1st monster will already have reached our city so we\\'ll only be able to kill a a total of one montser.\\n*  Now instead, if we had killed the 1st monster first, then,  at time = 1, 0th monster  would still be at `dist = 1` from the city, so we can kill it too and hence we\\'ll be able to **kill both the monsters.**\\n**Greedy Assumption 2:**\\n* So, as our greedy position assumption 1 clearly fails, what shall we base our order of choices on? Something that will take care of` both distance and speed`? **TIME!**\\n* So, to bring some logical ordering in our approach, we use given initial `dist[i] and speed[i]` to calculate initial `time[i]`.\\n*  Logically, a monster with a lower time value would reach the city before a monster with a higher time value.\\n**Time Calculation:**\\n* As each monster much be killed at an inital second, so for example if `dist = 1 `, and `speed = 2` , although time will be = 1/2, which in integer will give 0, we can still kill this monster, as at `time =0`, this monster will be 1/2 time units away from arrival. \\n* Conclusion --> Formula for time must be `time[i] = ceil(dist[i]/speed[i]);`\\n**Algorithm:**\\n* The last thing that\\'s left now is pushing all these time values into a a `min priority queue (min_heap)` and greedily killing the monster with the `lowest time of arrival value` at each second and then popping it out of the heap.\\n*  If at any instant, the element at the top of the heap, that is, the lowest time value is `less than or equal to our curent_time` instant value, this means that the monster has already reached our city and hence we can\\'t kill anymore monsters.\\n**Time Complexity:**   `O(NlogN + N) ~ O(NlogN)`: N for max number of seconds and NlogN for N heap operations with each operation taking logN time.\\n```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double, vector<double>, greater<double>>min_arrivals;//min_heap of ceil of time of arrivals\\n        int ans = 0;\\n        for(int i = 0; i<dist.size(); i++){\\n            min_arrivals.push(ceil((double)dist[i]/speed[i]));\\n        }\\n        int current_time = 0;//Current time iterator\\n        while(!min_arrivals.empty()){\\n            if(current_time<min_arrivals.top()){//Current minimum time of Arrival monster has not yet reached our city, so kill it.\\n                min_arrivals.pop();\\n                ans++;\\n            }\\n            else return ans;//Current minimum time of Arrival monster has already reached our city, hence return.\\n            current_time++;\\n        }\\n        return ans;\\n    }\\n```\\nConcise version:\\nCredits @saksham-kapoor\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double, vector<double>, greater<double>> pq;\\n        \\n        for(int i = 0; i < dist.size(); ++i)\\n            pq.push(ceil((double)dist[i] / speed[i] ));\\n        \\n        int t = 0;\\n        while(pq.size() && pq.top() > t++) pq.pop();\\n        return dist.size() - pq.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double, vector<double>, greater<double>>min_arrivals;//min_heap of ceil of time of arrivals\\n        int ans = 0;\\n        for(int i = 0; i<dist.size(); i++){\\n            min_arrivals.push(ceil((double)dist[i]/speed[i]));\\n        }\\n        int current_time = 0;//Current time iterator\\n        while(!min_arrivals.empty()){\\n            if(current_time<min_arrivals.top()){//Current minimum time of Arrival monster has not yet reached our city, so kill it.\\n                min_arrivals.pop();\\n                ans++;\\n            }\\n            else return ans;//Current minimum time of Arrival monster has already reached our city, hence return.\\n            current_time++;\\n        }\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double, vector<double>, greater<double>> pq;\\n        \\n        for(int i = 0; i < dist.size(); ++i)\\n            pq.push(ceil((double)dist[i] / speed[i] ));\\n        \\n        int t = 0;\\n        while(pq.size() && pq.top() > t++) pq.pop();\\n        return dist.size() - pq.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314338,
                "title": "c-easy-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int> temp(n);\\n\\t\\t\\n        // calculate time req for each monster to reach city\\n        for(int i=0;i<n;i++){\\n            temp[i] = ceil ( (1.0*dist[i])/speed[i]);\\n        }\\n\\t\\t\\n\\t\\t// Sort according to their time\\n        sort(temp.begin(),temp.end());  // We are sorting because we want to kill those monsters first which take less time to reach the city\\n        int time=1;\\n\\t\\t\\n\\t\\t// Checking how many monsters we can kill\\n        for(int i=0;i<n;i++){\\n            if(time>temp[i]){  // This means current monster reached the city before we can kill it\\n                return i;\\n            }\\n            time++;\\n        }\\n        return n;  \\n    }\\n};\\n\\n# HIT UPVOTE IF YOU LIKE :)\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int> temp(n);\\n\\t\\t\\n        // calculate time req for each monster to reach city\\n        for(int i=0;i<n;i++){\\n            temp[i] = ceil ( (1.0*dist[i])/speed[i]);\\n        }\\n\\t\\t\\n\\t\\t// Sort according to their time\\n        sort(temp.begin(),temp.end());  // We are sorting because we want to kill those monsters first which take less time to reach the city\\n        int time=1;\\n\\t\\t\\n\\t\\t// Checking how many monsters we can kill\\n        for(int i=0;i<n;i++){\\n            if(time>temp[i]){  // This means current monster reached the city before we can kill it\\n                return i;\\n            }\\n            time++;\\n        }\\n        return n;  \\n    }\\n};\\n\\n# HIT UPVOTE IF YOU LIKE :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314387,
                "title": "simple-solution-w-explanation-sort-by-time-to-reach-city",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nWe can simply sort by the time required for monsters to reach the city. We will initialize time `T = 0` and keep killing the monster in each iteration that\\'s closest to reach the city. Whenever a monster arrives at the city (`monster_time <= T`), we end the loop and return the total kills.\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = size(dist), ans = 0, T = 0;\\n        multiset<double> s;\\n        for(int i = 0; i < n; i++) s.insert(dist[i] * 1. / speed[i]);   // sorting by time to reach city\\n        for(auto& el : s) \\n            if(T >= el) break;     // monster reached city\\n            else ans++, T++;       // kill monster and increase time\\n        return ans;\\n    }\\n};\\n```\\t\\n\\n***Time Complexity :*** **`O(nlogn)`**, where `n` is the number of monsters.\\n***Space Complexity :*** **`O(n)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = size(dist), ans = 0, T = 0;\\n        multiset<double> s;\\n        for(int i = 0; i < n; i++) s.insert(dist[i] * 1. / speed[i]);   // sorting by time to reach city\\n        for(auto& el : s) \\n            if(T >= el) break;     // monster reached city\\n            else ans++, T++;       // kill monster and increase time\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314324,
                "title": "java-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        /* Calculate the time for each monster to reach the\\n           city and start elimiating one every minute starting\\n           from 0 with one with least time until any monster\\n           reaches a city. */\\n        PriorityQueue<Double> pq = new PriorityQueue<>();\\n        for (int i = 0; i < dist.length; i++) {\\n            pq.add(dist[i] * 1.0 / speed[i]);\\n        }\\n        \\n        double min = 0.0;\\n        int count = 0;\\n        while (!pq.isEmpty() && pq.poll() > min) {\\n            min += 1.0;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        /* Calculate the time for each monster to reach the\\n           city and start elimiating one every minute starting\\n           from 0 with one with least time until any monster\\n           reaches a city. */\\n        PriorityQueue<Double> pq = new PriorityQueue<>();\\n        for (int i = 0; i < dist.length; i++) {\\n            pq.add(dist[i] * 1.0 / speed[i]);\\n        }\\n        \\n        double min = 0.0;\\n        int count = 0;\\n        while (!pq.isEmpty() && pq.poll() > min) {\\n            min += 1.0;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314346,
                "title": "c-easy-to-understand-sorting-beginner-friendly",
                "content": "In this question we are asked to count the number of \\nmonsters that we can eliminate before lose.\\n\\n* find the time of every monster to reach the city\\n* then sort them in ascending order\\n* count them until any monster reaches the city\\n\\nHere\\'s the code:\\n```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        // make a vector of time and store the time corresponding to its distance and speed\\n        vector<double> time(dist.size());\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            time[i]=dist[i]/(double)speed[i];\\n        }\\n        // sort time in ascending order\\n        sort(time.begin(),time.end());\\n    \\n       // initialize t(time at which we kill the moster) to 0\\n        int t=0;\\n        //  cnt for count of monsters killed\\n        int cnt=0;\\n        // iterate unitl t is less than time to reach city.\\n        for(int i=0;i<time.size();i++ )\\n        {\\n            if(t<time[i])\\n                cnt++;\\n            else break;\\n            t++;\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        // make a vector of time and store the time corresponding to its distance and speed\\n        vector<double> time(dist.size());\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            time[i]=dist[i]/(double)speed[i];\\n        }\\n        // sort time in ascending order\\n        sort(time.begin(),time.end());\\n    \\n       // initialize t(time at which we kill the moster) to 0\\n        int t=0;\\n        //  cnt for count of monsters killed\\n        int cnt=0;\\n        // iterate unitl t is less than time to reach city.\\n        for(int i=0;i<time.size();i++ )\\n        {\\n            if(t<time[i])\\n                cnt++;\\n            else break;\\n            t++;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314897,
                "title": "c-o-n-solution-108ms",
                "content": "**Intuition**\\nWe can kill 1 monster every minute so for any time ```t``` we can kill atmost ```t``` monsters. If more monsters are able to reach city in time ```t```  we lose.\\n**Approach**\\n```freq[t]``` stores count of monsters reaching the city at exact time ```t```\\nWe iterate through ```freq``` and get total number of monsters till that time. If the number exceeds our killing capacity or we kill all monsters we stop.\\n```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = dist.size();\\n        int freq[(int)1e5+1];  //time->count\\n        memset(freq,0,sizeof(freq));\\n        \\n        for(int i=0;i<n;i+=1)\\n        {\\n            int t = dist[i]/speed[i] + (dist[i]%speed[i]!=0);\\n            freq[t] += 1;\\n        }\\n\\t\\t\\n        int i;\\n        for(i=1;i<(int)1e5+1;i+=1)\\n        {\\n            freq[i] += freq[i-1];\\n\\t\\t\\t// we lose\\n            if(freq[i]>i)\\n                break;\\n            \\n\\t\\t\\t// no monsters left\\n            if(freq[i]==n)\\n                break;\\n        }\\n        return min(i,n);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```t```\n```t```\n```t```\n```freq[t]```\n```t```\n```freq```\n```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = dist.size();\\n        int freq[(int)1e5+1];  //time->count\\n        memset(freq,0,sizeof(freq));\\n        \\n        for(int i=0;i<n;i+=1)\\n        {\\n            int t = dist[i]/speed[i] + (dist[i]%speed[i]!=0);\\n            freq[t] += 1;\\n        }\\n\\t\\t\\n        int i;\\n        for(i=1;i<(int)1e5+1;i+=1)\\n        {\\n            freq[i] += freq[i-1];\\n\\t\\t\\t// we lose\\n            if(freq[i]>i)\\n                break;\\n            \\n\\t\\t\\t// no monsters left\\n            if(freq[i]==n)\\n                break;\\n        }\\n        return min(i,n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314357,
                "title": "python-3-using-zip-sorted-easy-understanding",
                "content": "~~~\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        res, t = 0, []\\n        for s, v in zip(dist, speed):\\n            t.append(s/v)\\n        t.sort()\\n        for i in range(len(dist)):\\n            if t[i] > i:\\n                res += 1\\n            else:\\n                break\\n        return res\\n~~~\\n\\nTime Complexity : O(nlogn), where n is the number of monsters.\\nSpace Complexity : O(n)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "~~~\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        res, t = 0, []\\n        for s, v in zip(dist, speed):\\n            t.append(s/v)\\n        t.sort()\\n        for i in range(len(dist)):\\n            if t[i] > i:\\n                res += 1\\n            else:\\n                break\\n        return res\\n~~~\\n\\nTime Complexity : O(nlogn), where n is the number of monsters.\\nSpace Complexity : O(n)",
                "codeTag": "Java"
            },
            {
                "id": 1314987,
                "title": "java-o-nlogn-solution-with-explanation-greedy-sort",
                "content": "**Basic idea : Greedily eliminate the monster which will reach the city earliest**\\n\\nTo do so, we can create an array \\'time\\' which will keep track of when(at what minute) a monster will reach the city.\\nSort the array such that the monster which arrives first comes first in the array.\\n\\n**When can we eliminate the monster ?**\\nAt 0th minute, we can eliminate monsters arriving at 1st minute, 2nd minute, .....\\nAt 1st minute, we can eliminate monsters arriving at 2nd minute, 3rd minute, .....\\n\\n**Thus, for any minute m, we eliminate the first monster arriving at a time greater than m.**\\n\\n**If at any minute m, a monster(which has not been eliminated yet) reaches a city on or before mth minute, we lose the game.**\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        \\n        int n = dist.length;\\n        \\n        int[] time = new int[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            time[i] = (int)Math.ceil(dist[i] * 1.0 / speed[i]);\\n        }\\n        \\n        Arrays.sort(time);\\n        \\n        int eliminated = 0;\\n\\t\\t\\n\\t\\t// At i = 0, minute = 0 ( therefore, we can use i in place of minute )\\n        \\n        for(int i = 0; i < n; i++){\\n\\t\\t\\t \\n            if(time[i] > i){  // At ith minute, eliminate the first monster arriving after ith minute\\n                eliminated++;\\n            }else{\\n                break; // Monster reached the city\\n            }\\n        }\\n        \\n        return eliminated;\\n    }\\n}\\n```\\n\\n**Time Complexity : O(nlogn)** ( Because we have sorted the \\'time\\' array )\\n**Space Complexity : O(n)** ( We have created a new array \\'time\\' )",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        \\n        int n = dist.length;\\n        \\n        int[] time = new int[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            time[i] = (int)Math.ceil(dist[i] * 1.0 / speed[i]);\\n        }\\n        \\n        Arrays.sort(time);\\n        \\n        int eliminated = 0;\\n\\t\\t\\n\\t\\t// At i = 0, minute = 0 ( therefore, we can use i in place of minute )\\n        \\n        for(int i = 0; i < n; i++){\\n\\t\\t\\t \\n            if(time[i] > i){  // At ith minute, eliminate the first monster arriving after ith minute\\n                eliminated++;\\n            }else{\\n                break; // Monster reached the city\\n            }\\n        }\\n        \\n        return eliminated;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314372,
                "title": "easy-c-solution-using-min-heap",
                "content": "**Everytime we have to select that monster whose current reaching time to the destination is minimum. For that purpose we can use a min heap to get that monster in O(1) time.**\\n```\\ntypedef pair<double,int>p;\\n// first --> time to reach destination\\n// index of the monster\\nclass Solution \\n{\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n    {\\n        priority_queue<p,vector<p>,greater<p>>q;\\n        for(int i=0;i<speed.size();i++)\\n        {\\n            double time=(double)dist[i]/(double)speed[i];\\n            q.push({time,i});\\n        }\\n        int ans=0,t=0;\\n        while(!q.empty())\\n        {\\n            auto node=q.top();\\n            q.pop();\\n            int index=node.second;\\n            int d=dist[index]-(t*speed[index]);\\n            if(d<=0)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                ans++;\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<double,int>p;\\n// first --> time to reach destination\\n// index of the monster\\nclass Solution \\n{\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n    {\\n        priority_queue<p,vector<p>,greater<p>>q;\\n        for(int i=0;i<speed.size();i++)\\n        {\\n            double time=(double)dist[i]/(double)speed[i];\\n            q.push({time,i});\\n        }\\n        int ans=0,t=0;\\n        while(!q.empty())\\n        {\\n            auto node=q.top();\\n            q.pop();\\n            int index=node.second;\\n            int d=dist[index]-(t*speed[index]);\\n            if(d<=0)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                ans++;\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315142,
                "title": "faster-than-100-memory-less-than-100-java-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int time[] = new int[dist.length];\\n        for(int i=0;i<dist.length;i++){\\n            time[i] = (int)Math.ceil(dist[i]/(float)speed[i]);\\n        }\\n        \\n        Arrays.sort(time);\\n        int i = 1;\\n        for(;i<time.length;i++){\\n            if(i>=time[i]) return i;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int time[] = new int[dist.length];\\n        for(int i=0;i<dist.length;i++){\\n            time[i] = (int)Math.ceil(dist[i]/(float)speed[i]);\\n        }\\n        \\n        Arrays.sort(time);\\n        int i = 1;\\n        for(;i<time.length;i++){\\n            if(i>=time[i]) return i;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206791,
                "title": "java-c-100-solution-using-greedy-eliminate-maximum-number-of-monsters",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int[] time = new int[dist.length];\\n\\n        for(int i=0;i<dist.length;i++)\\n            time[i] = (int)Math.ceil((double)dist[i]/speed[i]);\\n\\n        Arrays.sort(time);\\n\\n        int ans = 0;\\n        int T = 0;\\n        for(int i=0;i<time.length;i++)\\n        {\\n            if(T++<time[i])\\n                ans++;\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<int> time(dist.size());\\n\\n        for(int i=0;i<dist.size();i++)\\n            time[i] = ceil((float)dist[i]/speed[i]);\\n\\n        sort(time.begin(),time.end());\\n\\n        int ans = 0;\\n        int T = 0;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            if(T++<time[i])\\n                ans++;\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int[] time = new int[dist.length];\\n\\n        for(int i=0;i<dist.length;i++)\\n            time[i] = (int)Math.ceil((double)dist[i]/speed[i]);\\n\\n        Arrays.sort(time);\\n\\n        int ans = 0;\\n        int T = 0;\\n        for(int i=0;i<time.length;i++)\\n        {\\n            if(T++<time[i])\\n                ans++;\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<int> time(dist.size());\\n\\n        for(int i=0;i<dist.size();i++)\\n            time[i] = ceil((float)dist[i]/speed[i]);\\n\\n        sort(time.begin(),time.end());\\n\\n        int ans = 0;\\n        int T = 0;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            if(T++<time[i])\\n                ans++;\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839939,
                "title": "python-3-5-lines-zip-and-sort-w-example-t-m-94-86",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n\\n        n = len(dist)                                                       #    Ex: dist = [1,5,4,4,3]\\n                                                                            #       speed = [1,2,1,1,1]\\n        time = sorted(map(lambda x: int(ceil(x[0]/x[1])),zip(dist,speed)))  #\\n                                                                            #  time: sorted([1,3,4,4,3])        \\n        for i in range(n):                                                  #             = [1,3,3,4,4]    \\n            if i >= time[i]: return i                                       #            i:  0 1 2 3 4\\n                                                                            #                        |   \\n        return n                                                            #                    return 4\\n```\\n[https://leetcode.com/submissions/detail/848149616/](http://)\\n\\n\\n\\n\\n\\n\\nI could be wrong, but I think it\\'s *O*(*N*log*N*) / *O*(*N*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n\\n        n = len(dist)                                                       #    Ex: dist = [1,5,4,4,3]\\n                                                                            #       speed = [1,2,1,1,1]\\n        time = sorted(map(lambda x: int(ceil(x[0]/x[1])),zip(dist,speed)))  #\\n                                                                            #  time: sorted([1,3,4,4,3])        \\n        for i in range(n):                                                  #             = [1,3,3,4,4]    \\n            if i >= time[i]: return i                                       #            i:  0 1 2 3 4\\n                                                                            #                        |   \\n        return n                                                            #                    return 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314370,
                "title": "python3-3-line",
                "content": "\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for i, t in enumerate(sorted((d+s-1)//s for d, s in zip(dist, speed))): \\n            if i == t: return i\\n        return len(dist)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for i, t in enumerate(sorted((d+s-1)//s for d, s in zip(dist, speed))): \\n            if i == t: return i\\n        return len(dist)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314327,
                "title": "python-easy-solution-sorting-arrival-time",
                "content": "1. basic idea first we see at what time monster comes to reach us \\n2. then for eaxmple monster comes at 1 2 3 4 sec then we can kill all\\n3. but monsters comes at 2 2 2 seconds to uss then we can kill at max 2\\n4. prev is a time counter if times == monster coming time then monster will kill us \\n5. for example monster coming time is 1 2 3 3 then at t=0 we kill 1 st monster then prev becomes 1 then we kill monster who would have reached at 2 seconf then prev becomes 2 then we kill the monster who would have reached at 3 and prev becomes 3 but now one monster reached us game over \\n6. we used sort of times monster reach us \\n7. also we used count to see how many monsters we can kill\\n8. **if u like please do upvote it gives motivation**\\n```py\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        if 0 in set(dist):\\n            return 0\\n        ans=[]\\n        for i,el in enumerate(dist):\\n            t=math.ceil(el/speed[i])\\n            ans.append(t)\\n        ans.sort()\\n        count=0\\n        prev=0\\n        print(ans)\\n        for i in range(len(ans)):\\n            if prev==ans[i]:\\n                return count\\n            else :\\n                count+=1\\n                prev+=1\\n        return count        \\n                ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        if 0 in set(dist):\\n            return 0\\n        ans=[]\\n        for i,el in enumerate(dist):\\n            t=math.ceil(el/speed[i])\\n            ans.append(t)\\n        ans.sort()\\n        count=0\\n        prev=0\\n        print(ans)\\n        for i in range(len(ans)):\\n            if prev==ans[i]:\\n                return count\\n            else :\\n                count+=1\\n                prev+=1\\n        return count        \\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 3674714,
                "title": "easiest-c-approach-in-o-nlog-n-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first we need to think how much time a monster will take to reach the destination. If suppose it is at distance 5km and its speed is 2km/min ,so we can destroy that monster at max t=2min.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will take ceil of distance/speed of each monster and store them in the array. We will the sort that array and start killing the monster from time=0. We will subtract the time we have spend from the element,If after that the number obtained is greater than zero,that implies we can kill that monster ,so after that we will increase our answer with 1 and increase our time with 1 .\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlong(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<int>t;\\n        for(int i=0;i<dist.size();i++){\\n            t.push_back((dist[i]+speed[i]-1)/speed[i]);\\n        }\\n        sort(t.begin(),t.end());\\n        int time=1;\\n        int ans=1;\\n        for(int i=1;i<dist.size();i++){\\n            t[i]-=time;\\n            if(t[i]>0){\\n                ans++;\\n                time++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<int>t;\\n        for(int i=0;i<dist.size();i++){\\n            t.push_back((dist[i]+speed[i]-1)/speed[i]);\\n        }\\n        sort(t.begin(),t.end());\\n        int time=1;\\n        int ans=1;\\n        for(int i=1;i<dist.size();i++){\\n            t[i]-=time;\\n            if(t[i]>0){\\n                ans++;\\n                time++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547762,
                "title": "with-step-by-step-solution",
                "content": "## Explanation :\\n```\\nMethod 1 :\\n\\nAs we have to Eliminate Maximum Number of Monsters, means if we first kill monsters has \\nhigher speed, then we can kill more later by eliminating lower speed monsters.\\n\\nInput: dist = [3,2,4], speed = [5,3,2]\\n\\n1. Kill the first monster with the maximum speed 5;\\n       dist = [X,2,4], speed = [X,3,2]\\n\\n1i.After 1 minute(the weapon\\'s recharge time):\\n       dist = [X,0,2], speed = [X,3,2]\\n\\n( dist[1] - speed[1] = 2-3 = -1 means it reached the city + killed people also.\\nSo just put 0 )\\n\\nAs we\\'ve encountered 0 means we lost, so return 1 as we were able to kill 1.\\nTHIS WAY IS HASSLE AS WE HAVE TO UPDATE dist EACH TIME. So we need something\\nwhich will work as a medium for both dist and speed[method 2].\\n```\\n```CPP\\nMethod 2 : Time\\n\\nWe are given distance(dist) and speed where speed[i] for each monster is constant.\\n              If speed is constant then we know\\n              v = st, where v = speed, s = distance & t = time\\n           or t = v/s\\n\\n\\'THE GAME STARTS AT MINUTE 0\\'. First we kill, then we wait for \\'A MINUTE\\'. SO\\n\\n0 Minute : Kill one\\n1 Minute : Kill second\\n2 Minute : Kill third [ obviously applying conditions ]\\n......................\\n\\nIf we can know at which minute each monster is arriving at the city, \\nwe will be able to know if we can kill any monster at minute 0/1/2..\\n\\nSo to store time for each monster, we create another list/vector \\'time\\'\\n\\nCalculation : time[i] = ceil(dist[i]/speed[i]) as we saw t = s/v\\n              Same as = (dist[i]+speed[i]-1) / speed[i]\\n\\nThe reason we are doing ceil cause we will be working at minute \\'0\\'/\\'1\\'/..(INTEGER VALUE)\\nYou can also create A list/vector of float numbers.\\n\\nSORT the list/vector time because to kill MAXIMUM MONSTERS WE NEED TO KILL MONSTERS\\nWHO WILL ARRIVE AT THE CITY EARLIER. THIS WAY WE CAN KILL MORE, RIGHT?\\n\\n                 CPP\\nvector<int> time; int n = dist.size();\\n\\nfor(int i=0; i<n; i++)\\n     time.push_back((dist[i]+speed[i]-1)/speed[i]);\\n\\nsort(begin(time),end(time));\\n\\n                 PYTHON\\nn =  len(dist)\\n\\ntime = sorted(map(lambda x : (x[0]+x[1]-1)//x[1], zip(dist, speed)))\\n#time = sorted[(x[0]+x[1]-1)//x[1] for x in zip(dist, speed)]\\n\\ndist = [3,2,4], speed = [5,3,2], time = sorted([1,1,2]) = [1,1,2]\\n\\nNow we will run a for loop from minute 0 as the game starts at 0 minute.\\n\\nat minute = 0 : time[0] = 1, means we are at 0 minute and a monster need 1 minute \\nto reach the city, it hasn\\'t reached yet! So we kill it [1 KILL!]\\n\\nat minute = 1 : time[1] = 1, means after killing the first monster I needed 1 \\nminute to recharge my weapon, and also the second monster needed excactly one\\nminute to reach the city. After 1 minute passed MY WEAPON IS REACHARGED \\n+ THE SECOND MONSTER REACHED THE CITY.\\n\\n\" If a monster reaches the city at the exact moment the weapon is \\nfully charged, it counts as a loss \" \\n\\nSo we lost:( and we will return 1 as we killed only 1 monster, just return minute, \\nwe don\\'t need any counter to count how many monster we killed. But if we are able\\nto kill all monsters we return n = the size of dist/monster\\'s numbers \\n\\n                   CPP                                  Python\\nfor(int minute = 0; minute<n; minute++)        for minute in range(n):\\n{                                                  if minute >= time[minute]:\\n    if(minute>=time[minute])                          return minute\\n        return minute;\\n}                                              return n\\nreturn n;\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<int> time; int n = dist.size();\\n\\n        for(int i=0; i<n; i++)\\n            time.push_back((dist[i]+speed[i]-1)/speed[i]);\\n\\n        sort(begin(time),end(time));\\n\\n        for(int minute = 0; minute<n; minute++)\\n        {\\n            if(minute>=time[minute])\\n                return minute;\\n        }\\n        return n;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n =  len(dist)\\n\\n        time = sorted(map(lambda x : (x[0]+x[1]-1)//x[1], zip(dist, speed)))\\n       #time = sorted[(x[0]+x[1]-1)//x[1] for x in zip(dist, speed)]\\n        \\n        for minute in range(n):\\n            if minute >= time[minute]:\\n                return minute\\n        \\n        return n\\n```\\n```Python []\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for minute, time in enumerate(sorted( map(lambda x : (x[0]+x[1]-1)//x[1], zip(dist,speed)) )) :\\n            if minute>= time:\\n                return minute\\n\\n        return len(dist)\\n```\\n```Python []\\n# This one beats 94.5% in TC\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for minute, time in enumerate(sorted( [(d+s-1)//s for d,s in zip(dist,speed)] )):\\n            if minute>= time:\\n                return minute\\n\\n        return len(dist)\\n```\\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(n)\\n```\\n\\n## Thank you so much for reading my post, if it was helpful an upvote will really make me happy as I needed time to write this step by step. If any information was wrong please leave the correct one in the comment. \\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nMethod 1 :\\n\\nAs we have to Eliminate Maximum Number of Monsters, means if we first kill monsters has \\nhigher speed, then we can kill more later by eliminating lower speed monsters.\\n\\nInput: dist = [3,2,4], speed = [5,3,2]\\n\\n1. Kill the first monster with the maximum speed 5;\\n       dist = [X,2,4], speed = [X,3,2]\\n\\n1i.After 1 minute(the weapon\\'s recharge time):\\n       dist = [X,0,2], speed = [X,3,2]\\n\\n( dist[1] - speed[1] = 2-3 = -1 means it reached the city + killed people also.\\nSo just put 0 )\\n\\nAs we\\'ve encountered 0 means we lost, so return 1 as we were able to kill 1.\\nTHIS WAY IS HASSLE AS WE HAVE TO UPDATE dist EACH TIME. So we need something\\nwhich will work as a medium for both dist and speed[method 2].\\n```\n```CPP\\nMethod 2 : Time\\n\\nWe are given distance(dist) and speed where speed[i] for each monster is constant.\\n              If speed is constant then we know\\n              v = st, where v = speed, s = distance & t = time\\n           or t = v/s\\n\\n\\'THE GAME STARTS AT MINUTE 0\\'. First we kill, then we wait for \\'A MINUTE\\'. SO\\n\\n0 Minute : Kill one\\n1 Minute : Kill second\\n2 Minute : Kill third [ obviously applying conditions ]\\n......................\\n\\nIf we can know at which minute each monster is arriving at the city, \\nwe will be able to know if we can kill any monster at minute 0/1/2..\\n\\nSo to store time for each monster, we create another list/vector \\'time\\'\\n\\nCalculation : time[i] = ceil(dist[i]/speed[i]) as we saw t = s/v\\n              Same as = (dist[i]+speed[i]-1) / speed[i]\\n\\nThe reason we are doing ceil cause we will be working at minute \\'0\\'/\\'1\\'/..(INTEGER VALUE)\\nYou can also create A list/vector of float numbers.\\n\\nSORT the list/vector time because to kill MAXIMUM MONSTERS WE NEED TO KILL MONSTERS\\nWHO WILL ARRIVE AT THE CITY EARLIER. THIS WAY WE CAN KILL MORE, RIGHT?\\n\\n                 CPP\\nvector<int> time; int n = dist.size();\\n\\nfor(int i=0; i<n; i++)\\n     time.push_back((dist[i]+speed[i]-1)/speed[i]);\\n\\nsort(begin(time),end(time));\\n\\n                 PYTHON\\nn =  len(dist)\\n\\ntime = sorted(map(lambda x : (x[0]+x[1]-1)//x[1], zip(dist, speed)))\\n#time = sorted[(x[0]+x[1]-1)//x[1] for x in zip(dist, speed)]\\n\\ndist = [3,2,4], speed = [5,3,2], time = sorted([1,1,2]) = [1,1,2]\\n\\nNow we will run a for loop from minute 0 as the game starts at 0 minute.\\n\\nat minute = 0 : time[0] = 1, means we are at 0 minute and a monster need 1 minute \\nto reach the city, it hasn\\'t reached yet! So we kill it [1 KILL!]\\n\\nat minute = 1 : time[1] = 1, means after killing the first monster I needed 1 \\nminute to recharge my weapon, and also the second monster needed excactly one\\nminute to reach the city. After 1 minute passed MY WEAPON IS REACHARGED \\n+ THE SECOND MONSTER REACHED THE CITY.\\n\\n\" If a monster reaches the city at the exact moment the weapon is \\nfully charged, it counts as a loss \" \\n\\nSo we lost:( and we will return 1 as we killed only 1 monster, just return minute, \\nwe don\\'t need any counter to count how many monster we killed. But if we are able\\nto kill all monsters we return n = the size of dist/monster\\'s numbers \\n\\n                   CPP                                  Python\\nfor(int minute = 0; minute<n; minute++)        for minute in range(n):\\n{                                                  if minute >= time[minute]:\\n    if(minute>=time[minute])                          return minute\\n        return minute;\\n}                                              return n\\nreturn n;\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<int> time; int n = dist.size();\\n\\n        for(int i=0; i<n; i++)\\n            time.push_back((dist[i]+speed[i]-1)/speed[i]);\\n\\n        sort(begin(time),end(time));\\n\\n        for(int minute = 0; minute<n; minute++)\\n        {\\n            if(minute>=time[minute])\\n                return minute;\\n        }\\n        return n;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n =  len(dist)\\n\\n        time = sorted(map(lambda x : (x[0]+x[1]-1)//x[1], zip(dist, speed)))\\n       #time = sorted[(x[0]+x[1]-1)//x[1] for x in zip(dist, speed)]\\n        \\n        for minute in range(n):\\n            if minute >= time[minute]:\\n                return minute\\n        \\n        return n\\n```\n```Python []\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for minute, time in enumerate(sorted( map(lambda x : (x[0]+x[1]-1)//x[1], zip(dist,speed)) )) :\\n            if minute>= time:\\n                return minute\\n\\n        return len(dist)\\n```\n```Python []\\n# This one beats 94.5% in TC\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for minute, time in enumerate(sorted( [(d+s-1)//s for d,s in zip(dist,speed)] )):\\n            if minute>= time:\\n                return minute\\n\\n        return len(dist)\\n```\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636923,
                "title": "c-easy-to-understand-detailed",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int> temp(n);\\n\\t\\t\\n        // calculate time req for each monster to reach city\\n        for(int i=0;i<n;i++){\\n            temp[i] = ceil ( (1.0*dist[i])/speed[i]);\\n        }\\n\\t\\t\\n\\t\\t// Sort according to their time\\n        sort(temp.begin(),temp.end());  // We are sorting because we want to kill those monsters first which take less time to reach the city\\n        int time=1;\\n\\t\\t\\n\\t\\t// Checking how many monsters we can kill\\n        for(int i=0;i<n;i++){\\n            if(time>temp[i]){  // This means current monster reached the city before we can kill it\\n                return i;\\n            }\\n            time++;\\n        }\\n        return n;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int> temp(n);\\n\\t\\t\\n        // calculate time req for each monster to reach city\\n        for(int i=0;i<n;i++){\\n            temp[i] = ceil ( (1.0*dist[i])/speed[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1314475,
                "title": "java-simple-solution-no-edge-cases",
                "content": "```\\npublic int eliminateMaximum(int[] dist, int[] speed) {\\n        PriorityQueue<Double> timeTaken = new PriorityQueue<Double>();\\n\\n        for(int i =0;i<dist.length;i++) {\\n            timeTaken.offer(dist[i]/(speed[i]*1.0));\\n        }\\n        int time = 0;\\n        while(!timeTaken.isEmpty()) {\\n            double timeCurr = timeTaken.poll();\\n            if(timeCurr <= time) {\\n                return time;\\n            }\\n            time++;\\n        }\\n\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int eliminateMaximum(int[] dist, int[] speed) {\\n        PriorityQueue<Double> timeTaken = new PriorityQueue<Double>();\\n\\n        for(int i =0;i<dist.length;i++) {\\n            timeTaken.offer(dist[i]/(speed[i]*1.0));\\n        }\\n        int time = 0;\\n        while(!timeTaken.isEmpty()) {\\n            double timeCurr = timeTaken.poll();\\n            if(timeCurr <= time) {\\n                return time;\\n            }\\n            time++;\\n        }\\n\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314362,
                "title": "python-easy-comparator-sort",
                "content": "Create an arrray and make pair of distance and speed.\\nSort that array on the basis of time i.e dist/speed\\n\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n\\t\\tdef help(a):\\n            return a[0]/a[1]\\n        \\n\\t\\ttemp = []\\n        for i in range(len(dist)):\\n            temp.append([dist[i],speed[i]])\\n        temp = sorted(temp,key = help)\\n        ans = 0\\n        i = 0\\n\\n        while i<len(temp):\\n            if (temp[i][0] - (temp[i][1])*i) > 0 :\\n                ans += 1\\n                i += 1\\n            else:\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n\\t\\tdef help(a):\\n            return a[0]/a[1]\\n        \\n\\t\\ttemp = []\\n        for i in range(len(dist)):\\n            temp.append([dist[i],speed[i]])\\n        temp = sorted(temp,key = help)\\n        ans = 0\\n        i = 0\\n\\n        while i<len(temp):\\n            if (temp[i][0] - (temp[i][1])*i) > 0 :\\n                ans += 1\\n                i += 1\\n            else:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022155,
                "title": "c-greedy-easy-understanding",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        // Intution\\n        // The idea in here is really very simple. We will find the time taken by each monster to reach us with the help of the formual time is equal to distance / speed. Given that we will sort it and continue the process till we found that two correspodning elements are equal if we found that the corresponding elements are equal then we will elimnate them.\\n        vector<double> current;\\n        int size = dist.size();\\n        for(int i = 0 ; i < size ; i++){\\n            double value = dist[i] * 1.0 / speed[i] * 1.0;\\n            current.push_back(value);\\n        }\\n        sort(current.begin(), current.end());\\n        int answer = 0;\\n        for(int i = 0 ; i < size ; i++){\\n            if(i != 0 and i >= current[i]) break;\\n            answer += 1;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        // Intution\\n        // The idea in here is really very simple. We will find the time taken by each monster to reach us with the help of the formual time is equal to distance / speed. Given that we will sort it and continue the process till we found that two correspodning elements are equal if we found that the corresponding elements are equal then we will elimnate them.\\n        vector<double> current;\\n        int size = dist.size();\\n        for(int i = 0 ; i < size ; i++){\\n            double value = dist[i] * 1.0 / speed[i] * 1.0;\\n            current.push_back(value);\\n        }\\n        sort(current.begin(), current.end());\\n        int answer = 0;\\n        for(int i = 0 ; i < size ; i++){\\n            if(i != 0 and i >= current[i]) break;\\n            answer += 1;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661422,
                "title": "short-clean-9-lines-with-explanation",
                "content": "\\n```\\nclass Solution {\\npublic:\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<float> time(n);\\n        for(int i=0;i<n;++i)\\n        time[i]=(dist[i]/(float)speed[i]);\\n        sort(time.begin(),time.end());\\n        \\n        for(int i=0;i<n;++i)\\n            if(time[i]-i<=0)\\n                return i;\\n        \\n    return n;}\\n};\\n```\\n\\nExplanation:-\\n1)Assume they all are in a horizontal line in front of the destination.\\n2)we will calculate time for each in reaching the destination ans store in a times array.\\n3)Sort the time Array \\n4)Remember we need to consider their postion  at interval of 1 min (recharge time).So we made a time array to check for each element as where it is now after \\'i\\' minutes passed;\\n5) Traverse the time array and for each element calculate the time taken by it to reach destination now (time taken by it to reach destination - time passed ( i )  ).\\n6) if for any item time <= 0 means it reached before recharge then return i (no. of monsters killed).\\n7) if all loop traversed , return n (all killed).\\n:)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<float> time(n);\\n        for(int i=0;i<n;++i)\\n        time[i]=(dist[i]/(float)speed[i]);\\n        sort(time.begin(),time.end());\\n        \\n        for(int i=0;i<n;++i)\\n            if(time[i]-i<=0)\\n                return i;\\n        \\n    return n;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478396,
                "title": "c-simple-c-code-o-nlogn",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double> time;\\n        int n = dist.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            time.push_back((double)dist[i]/speed[i]);\\n        }\\n        sort(time.begin(), time.end());\\n        int currtime = 0, ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(currtime < time[i])\\n            {\\n                ans++;\\n                currtime++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double> time;\\n        int n = dist.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            time.push_back((double)dist[i]/speed[i]);\\n        }\\n        sort(time.begin(), time.end());\\n        int currtime = 0, ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(currtime < time[i])\\n            {\\n                ans++;\\n                currtime++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013442,
                "title": "easy-javascript",
                "content": "```\\nvar eliminateMaximum = function(dist, speed) {\\n \\xA0let arr=dist.map((elem,i)=>Math.ceil(elem/speed[i])); \\n \\xA0arr.sort((a,b)=>a-b);\\n  for(let i=1; i<arr.length; i++){\\n     if(arr[i]<i+1){ return i; }\\n  }\\n  return arr.length;   \\n}; \\xA0 \\xA0 \\xA0 \\xA0 \\n```",
                "solutionTags": [],
                "code": "```\\nvar eliminateMaximum = function(dist, speed) {\\n \\xA0let arr=dist.map((elem,i)=>Math.ceil(elem/speed[i])); \\n \\xA0arr.sort((a,b)=>a-b);\\n  for(let i=1; i<arr.length; i++){\\n     if(arr[i]<i+1){ return i; }\\n  }\\n  return arr.length;   \\n}; \\xA0 \\xA0 \\xA0 \\xA0 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435905,
                "title": "java-easy-solution-with-explanation-o-n",
                "content": "```\\n    /* Time Complexity: O(N), N = the length of the dist array\\n\\t *\\n\\t * Space Complexity: O(N)\\n\\t *\\n\\t */\\n\\tpublic int eliminateMaximum(int[] dist, int[] speed) {\\n\\t\\t/*\\n\\t\\t * Count the number of the monster arrived at each timestamp t. We are able to\\n\\t\\t * kill t monsters before timestamp t and we only have n monsters, so we don\\'t\\n\\t\\t * need to worry about the monster arrived after timestamp n.\\n\\t\\t */\\n\\t\\tint[] cnt = new int[dist.length];\\n\\t\\tfor (int i = 0; i < dist.length; i++) {\\n\\t\\t\\tint arriveTime = (int) Math.ceil((double) dist[i] / speed[i]);\\n\\t\\t\\tif (arriveTime < dist.length)\\n\\t\\t\\t\\tcnt[arriveTime]++;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * We are able to kill t monsters before timestamp t, If the total arrived\\n\\t\\t * monsters more than t, we fail the game.\\n\\t\\t */\\n\\t\\tint monster = 0;\\n\\t\\tfor (int i = 1; i < dist.length; i++) {\\n\\t\\t\\tmonster += cnt[i];\\n\\t\\t\\tif (monster > i)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn dist.length;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    /* Time Complexity: O(N), N = the length of the dist array\\n\\t *\\n\\t * Space Complexity: O(N)\\n\\t *\\n\\t */\\n\\tpublic int eliminateMaximum(int[] dist, int[] speed) {\\n\\t\\t/*\\n\\t\\t * Count the number of the monster arrived at each timestamp t. We are able to\\n\\t\\t * kill t monsters before timestamp t and we only have n monsters, so we don\\'t\\n\\t\\t * need to worry about the monster arrived after timestamp n.\\n\\t\\t */\\n\\t\\tint[] cnt = new int[dist.length];\\n\\t\\tfor (int i = 0; i < dist.length; i++) {\\n\\t\\t\\tint arriveTime = (int) Math.ceil((double) dist[i] / speed[i]);\\n\\t\\t\\tif (arriveTime < dist.length)\\n\\t\\t\\t\\tcnt[arriveTime]++;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * We are able to kill t monsters before timestamp t, If the total arrived\\n\\t\\t * monsters more than t, we fail the game.\\n\\t\\t */\\n\\t\\tint monster = 0;\\n\\t\\tfor (int i = 1; i < dist.length; i++) {\\n\\t\\t\\tmonster += cnt[i];\\n\\t\\t\\tif (monster > i)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn dist.length;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1326197,
                "title": "c-greedy-o-nlogn-solution-with-explanation",
                "content": "**My Approach**-->Greedy Approach\\nAt each point of time, we simply have to kill the next monster that will arrive at the city until a monster actually reaches the city.\\nWe use a min heap to store the exact time a monster reaches the city (in float). With each monster we kill, we increase the current time. When we reach a time when the current time is greater than or equal to the next monster that reaches the city, we break the loop.\\nTime Complexity->O(nlogn)\\nSpace Complexity->O(n)\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<float, vector<float>,greater<float>>pq;\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            pq.push(float(dist[i])/speed[i]);\\n        }\\n        int time=1;\\n        pq.pop();\\n        while(!pq.empty())\\n        {   \\n            if(pq.top()>time)\\n            {\\n                pq.pop();\\n                time++;\\n            }\\n            else break;\\n        }\\n        return time;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<float, vector<float>,greater<float>>pq;\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            pq.push(float(dist[i])/speed[i]);\\n        }\\n        int time=1;\\n        pq.pop();\\n        while(!pq.empty())\\n        {   \\n            if(pq.top()>time)\\n            {\\n                pq.pop();\\n                time++;\\n            }\\n            else break;\\n        }\\n        return time;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315066,
                "title": "faster-than-100-submissions-using-sorting",
                "content": "# ***In this approach we will first calculate time by dividing each dist and speed in dist and speed arrays.\\n# ****Then we will sort this time array Now we are having the time of monsters arriving the city in increasing order.\\n# ***Now we will start from oth index in time array and check if the element in 0th index is less than equal to corressponding minute if yes it means that the monster will reach the city and we will break our loop otherwise we will increment our count of monsters and minute***\\n```\\n\\t\\tclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n\\n        int n = dist.length;\\n        double time[] = new double[n];\\n        for(int i=0;i<n;i++){\\n            time[i] = dist[i]*1.0/speed[i];\\n        }\\n        Arrays.sort(time);\\n        int cnt=0;\\n        double min=0.0;\\n        for(int i=0;i<n;i++){\\n            if(time[i]<=min){\\n                break;\\n            }\\n            else{\\n                cnt++;\\n                 min=min+1.0;\\n            }\\n           \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n\\t\\tclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n\\n        int n = dist.length;\\n        double time[] = new double[n];\\n        for(int i=0;i<n;i++){\\n            time[i] = dist[i]*1.0/speed[i];\\n        }\\n        Arrays.sort(time);\\n        int cnt=0;\\n        double min=0.0;\\n        for(int i=0;i<n;i++){\\n            if(time[i]<=min){\\n                break;\\n            }\\n            else{\\n                cnt++;\\n                 min=min+1.0;\\n            }\\n           \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314503,
                "title": "easy-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        //calculate the time to reach the city for every monster\\n        //the optimal approach is to defeat the monster which arrives in lesser time\\n        \\n        //use min heap pq to store the time to reach the city \\n        priority_queue<double,vector<double>,greater<double>> pq;\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            double time= (double)(dist[i])/(speed[i]);\\n            pq.push(time);\\n        }\\n        \\n        int res=0;\\n        int currTime=0;\\n        //keep on defeating the monster which it has not yet reached\\n        while(!pq.empty() && pq.top()>currTime)\\n        {\\n            currTime++;\\n            res++;\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if this helps you:)**",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        //calculate the time to reach the city for every monster\\n        //the optimal approach is to defeat the monster which arrives in lesser time\\n        \\n        //use min heap pq to store the time to reach the city \\n        priority_queue<double,vector<double>,greater<double>> pq;\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            double time= (double)(dist[i])/(speed[i]);\\n            pq.push(time);\\n        }\\n        \\n        int res=0;\\n        int currTime=0;\\n        //keep on defeating the monster which it has not yet reached\\n        while(!pq.empty() && pq.top()>currTime)\\n        {\\n            currTime++;\\n            res++;\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314482,
                "title": "c-simple-solution-with-detailed-explaination",
                "content": "**Key Idea**\\nHere Basic idea is that demons order can get changed because the speeds are different \\n\\n**example** :\\nConsider the example : dist= 1 2 4 3  speed= 1 1 1 2\\nAt 0th sec : we can kill 0th demon as it is at **distance >=1** so\\nDist = X 2-1 4-1 3-2  == X 1 4 1 \\nHere you can observe that both demon 2 and demon 4 are at distance 1 so in this case you can kill **only one demon** and the other kills you \\n\\nApproach:\\n**1)calculate the time at which each demon comes to you (dist[i]==0)**\\n\\n For the above example \\nIt is time[0]= ceil(dist[i]/speed[i])=ceil(\\xBD)=1\\ntime[1]=ceil(2/1)=2\\ntime[2]=ceil(4/1)=4\\ntime[3]=ceil(3/2)=2\\ntime={1,2,4,2}\\n\\n**2)Sort times**\\ntime={1,2,2,4}\\nNow it is trivial that you can\\'t kill demon 3 at 3rd minute because it will reach you in 2 minutes only.\\nSo Find the number of i for which time[i]>i \\n\\n ```\\n int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n       int count=0;\\n        vector<int>time(dist.size());\\n       for( int i=0;i<dist.size();i++){\\n    time[i]=ceil(double(dist[i])/speed[i]);  //calculate time for each demon to reach you \\n             }\\n        sort(time.begin(),time.end()); \\n        for(int i=0;i<time.size();i++){\\n            if(time[i]>i) count++; //you can kill demon only if its reach time is less than the current time\\n            else break;\\n        }\\n        \\n        return count;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n       int count=0;\\n        vector<int>time(dist.size());\\n       for( int i=0;i<dist.size();i++){\\n    time[i]=ceil(double(dist[i])/speed[i]);  //calculate time for each demon to reach you \\n             }\\n        sort(time.begin(),time.end()); \\n        for(int i=0;i<time.size();i++){\\n            if(time[i]>i) count++; //you can kill demon only if its reach time is less than the current time\\n            else break;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314469,
                "title": "simple-solution-using-concept-of-priority-queue-explained",
                "content": "# **** Approach is simple physics calculate distance by speed ratio(which is time)and add to priority queue then check if queue.poll > minute increase count by one\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n       \\n        PriorityQueue<Double> que = new PriorityQueue<>();\\n        for (int i = 0; i < dist.length; i++) {\\n\\t\\t// CAlculate ratio of dist to speed\\n            que.add(dist[i] * 1.0 / speed[i]);   //change it to double *1.0 \\n        }\\n        \\n        double minute = 0.0;\\n        int cnt = 0;\\n        while (!que.isEmpty() && que.poll() > minute) {\\n\\t\\t//check if que.poll> minute if then cnt++\\n            minute += 1.0;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n       \\n        PriorityQueue<Double> que = new PriorityQueue<>();\\n        for (int i = 0; i < dist.length; i++) {\\n\\t\\t// CAlculate ratio of dist to speed\\n            que.add(dist[i] * 1.0 / speed[i]);   //change it to double *1.0 \\n        }\\n        \\n        double minute = 0.0;\\n        int cnt = 0;\\n        while (!que.isEmpty() && que.poll() > minute) {\\n\\t\\t//check if que.poll> minute if then cnt++\\n            minute += 1.0;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555253,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nFind the arrival time of all monsters.Then sort it\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dis: List[int], speed: List[int]) -> int:\\n        for idx in range(len(dis)):\\n            dis[idx] = dis[idx]//speed[idx] if dis[idx]%speed[idx] == 0 else dis[idx]//speed[idx] + 1\\n        dis.sort()\\n        for idx in range(len(dis)):\\n            if idx+1 > dis[idx]:\\n                return idx\\n        return len(dis)\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dis: List[int], speed: List[int]) -> int:\\n        for idx in range(len(dis)):\\n            dis[idx] = dis[idx]//speed[idx] if dis[idx]%speed[idx] == 0 else dis[idx]//speed[idx] + 1\\n        dis.sort()\\n        for idx in range(len(dis)):\\n            if idx+1 > dis[idx]:\\n                return idx\\n        return len(dis)\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508650,
                "title": "runtime-798-ms-beats-93-47-memory-32-1-mb-beats-11",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        k,count=sorted([i/j for i,j in zip(dist,speed)]),1\\n        for i in range(1,len(k)):\\n            if k[i]-i>0:count+=1\\n            else:break\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        k,count=sorted([i/j for i,j in zip(dist,speed)]),1\\n        for i in range(1,len(k)):\\n            if k[i]-i>0:count+=1\\n            else:break\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625657,
                "title": "pythonic-way",
                "content": "\\tclass Solution:\\n\\t\\tdef eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n\\t\\t\\tans=[]\\n\\t\\t\\tfor i,j in zip(dist,speed):\\n\\t\\t\\t\\tans.append((i+j-1)//j)\\n\\t\\t\\tans.sort()\\n\\t\\t\\tfor i in range(1,len(ans)):\\n\\t\\t\\t\\tif ans[i]<=i:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\treturn len(ans)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n\\t\\t\\tans=[]\\n\\t\\t\\tfor i,j in zip(dist,speed):\\n\\t\\t\\t\\tans.append((i+j-1)//j)\\n\\t\\t\\tans.sort()\\n\\t\\t\\tfor i in range(1,len(ans)):\\n\\t\\t\\t\\tif ans[i]<=i:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\treturn len(ans)",
                "codeTag": "Java"
            },
            {
                "id": 2557212,
                "title": "java-intuitive-explanation-o-n-log-n",
                "content": "\\n/**\\n\\nKey Insight: Preprocess the arrays so we have something we can sort and run a greedy solution on\\n\\nAlgorithm: We do not know which monsters we need to eliminate first (some may start closer but others that are further away may have a quicker speed). In order to determine which monsters to eliminate first determine when they will arrive. We know that they will arrive with the equation dist - speed * time = 0 -> time = Math.ceil(dist/speed). Now sort the monsters by the time they will arrive. Delete the ones that are coming fastest first. Increment curr_time by 1 for each monster you kill. If a monster ever arrives at a time <= curr_time then the city is destroyed. Return the number of monsters we killed\\n\\n**/\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int[] time_to_arriv = new int[dist.length];\\n        \\n        for (int idx = 0; idx < dist.length; idx++) {\\n           time_to_arriv[idx] = findTimeToArriv(idx, dist, speed); \\n        }\\n        \\n        Arrays.sort(time_to_arriv);\\n        \\n        int curr_time = 0, destroyed = 0;\\n        for (int idx = 0; idx < time_to_arriv.length; idx++) {\\n            if (time_to_arriv[idx] > curr_time) {\\n                destroyed++;\\n            } else {\\n                break;\\n            }\\n            curr_time++;\\n        }\\n        \\n        return destroyed;\\n    }\\n    \\n    public int findTimeToArriv(int idx, int[] dist, int[] speed) {\\n        // dist - speed * x = 0\\n        // x = dist / speed\\n        double curr_dist = dist[idx];\\n        double curr_speed = speed[idx];\\n        \\n        return (int) Math.ceil(curr_dist / curr_speed);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int[] time_to_arriv = new int[dist.length];\\n        \\n        for (int idx = 0; idx < dist.length; idx++) {\\n           time_to_arriv[idx] = findTimeToArriv(idx, dist, speed); \\n        }\\n        \\n        Arrays.sort(time_to_arriv);\\n        \\n        int curr_time = 0, destroyed = 0;\\n        for (int idx = 0; idx < time_to_arriv.length; idx++) {\\n            if (time_to_arriv[idx] > curr_time) {\\n                destroyed++;\\n            } else {\\n                break;\\n            }\\n            curr_time++;\\n        }\\n        \\n        return destroyed;\\n    }\\n    \\n    public int findTimeToArriv(int idx, int[] dist, int[] speed) {\\n        // dist - speed * x = 0\\n        // x = dist / speed\\n        double curr_dist = dist[idx];\\n        double curr_speed = speed[idx];\\n        \\n        return (int) Math.ceil(curr_dist / curr_speed);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162873,
                "title": "c-calculate-time-to-elim-and-sort",
                "content": "```\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<pair<int, int>> time_to_elim;\\n        \\n        for (int i = 0; i < dist.size(); ++i) \\n            time_to_elim.push_back({i, ceil((float)dist[i] / (float)speed[i])});\\n        \\n        sort(time_to_elim.begin(), time_to_elim.end(), [](auto& l, auto& r){\\n            return l.second < r.second; \\n        });\\n        \\n        int t = 0, cnt = 0;\\n        for (auto [m, time] : time_to_elim) {\\n            if (t < time) t++, cnt++;\\n            else break;\\n        }\\n        return cnt;\\n    } \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<pair<int, int>> time_to_elim;\\n        \\n        for (int i = 0; i < dist.size(); ++i) \\n            time_to_elim.push_back({i, ceil((float)dist[i] / (float)speed[i])});\\n        \\n        sort(time_to_elim.begin(), time_to_elim.end(), [](auto& l, auto& r){\\n            return l.second < r.second; \\n        });\\n        \\n        int t = 0, cnt = 0;\\n        for (auto [m, time] : time_to_elim) {\\n            if (t < time) t++, cnt++;\\n            else break;\\n        }\\n        return cnt;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076038,
                "title": "easy-solution-using-sortin-only-java",
                "content": "\\t\\tclass Solution {\\n\\t\\t\\tpublic int eliminateMaximum(int[] dist, int[] speed){\\n\\t\\t\\t\\tint n = dist.length;\\n\\n\\t\\t\\t\\t// here time[i] will represents when specific monster will reach the city --\\n\\t\\t\\t\\tint[] time = new int[n];\\n\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(speed[i]>dist[i])\\n\\t\\t\\t\\t\\t\\ttime[i] = 1;\\n\\n\\t\\t\\t\\t\\telse if(dist[i] % speed[i] !=0)\\n\\t\\t\\t\\t\\t\\ttime[i] = (dist[i]/speed[i]) + 1;\\n\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\ttime[i] = dist[i]/speed[i];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint t = 0;\\n\\t\\t\\t\\tArrays.sort(time);\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(t < time[i]){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic int eliminateMaximum(int[] dist, int[] speed){\\n\\t\\t\\t\\tint n = dist.length;\\n\\n\\t\\t\\t\\t// here time[i] will represents when specific monster will reach the city --\\n\\t\\t\\t\\tint[] time = new int[n];\\n\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(speed[i]>dist[i])\\n\\t\\t\\t\\t\\t\\ttime[i] = 1;\\n\\n\\t\\t\\t\\t\\telse if(dist[i] % speed[i] !=0)\\n\\t\\t\\t\\t\\t\\ttime[i] = (dist[i]/speed[i]) + 1;\\n\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\ttime[i] = dist[i]/speed[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2031620,
                "title": "easy-cpp-logical-sorting-8lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& D, vector<int>& S) {\\n        vector<int> P;\\n        for(int i=0;i<D.size();i++) P.push_back(ceil((float)D[i]/(float)S[i]));\\n        int sum=1;\\n        sort(P.begin(),P.end());\\n        for(int i=1;i<P.size();i++){\\n            if(sum>=P[i]) break;\\n              sum+=1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& D, vector<int>& S) {\\n        vector<int> P;\\n        for(int i=0;i<D.size();i++) P.push_back(ceil((float)D[i]/(float)S[i]));\\n        int sum=1;\\n        sort(P.begin(),P.end());\\n        for(int i=1;i<P.size();i++){\\n            if(sum>=P[i]) break;\\n              sum+=1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011783,
                "title": "4-liner",
                "content": "**bucketing + running sum**\\n**time: `O(N)`; space: `O(N)`**\\n```\\nint eliminateMaximum(vector<int>& d, vector<int>& s)\\n{\\n\\tint m[100001]{}, t{};\\n\\tfor(int i{}; i<size(d); ++m[(d[i]-1)/s[i]], ++i);\\n\\tfor(int r{}; t<size(d) and (r+=m[t++], r<=t);  );\\n\\treturn t;      \\n}\\n```\\n`m` - **m**ap: minute -> monsters reach city at this very minute;\\n`t` - **t**ime (in minutes) the gun shootes before being destroyed = number of killed monsters;\\n`r` - **r**unning sum of killed monsters.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint eliminateMaximum(vector<int>& d, vector<int>& s)\\n{\\n\\tint m[100001]{}, t{};\\n\\tfor(int i{}; i<size(d); ++m[(d[i]-1)/s[i]], ++i);\\n\\tfor(int r{}; t<size(d) and (r+=m[t++], r<=t);  );\\n\\treturn t;      \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966778,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer[]} dist\\n# @param {Integer[]} speed\\n# @return {Integer}\\ndef eliminate_maximum(dist, speed)\\n  dist.zip(speed).map { _1.to_r / _2 }.sort.zip(0..).take_while { _1 > _2 }.size \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} dist\\n# @param {Integer[]} speed\\n# @return {Integer}\\ndef eliminate_maximum(dist, speed)\\n  dist.zip(speed).map { _1.to_r / _2 }.sort.zip(0..).take_while { _1 > _2 }.size \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1744016,
                "title": "c-priority-queue",
                "content": "```\\nclass compare\\n{\\n    public:\\n        bool operator()(pair<int,int>&a,pair<int,int>&b)\\n        {\\n            double diff1 = (double)a.first / a.second;\\n            double diff2 = (double)b.first / b.second;\\n            if(diff1 == diff2)\\n                return (a.first > b.first);\\n            return (diff1 > diff2);\\n            \\n        }\\n};\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>&D, vector<int>&S) {\\n        int n = D.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,compare>pq;\\n        int count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push({D[i],S[i]});\\n        }\\n        while(!pq.empty())\\n        {\\n            pair<int,int>cur = pq.top();\\n            pq.pop();\\n            int check = cur.first - (cur.second * count);\\n            if(check <= 0)\\n                break;\\n            count++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass compare\\n{\\n    public:\\n        bool operator()(pair<int,int>&a,pair<int,int>&b)\\n        {\\n            double diff1 = (double)a.first / a.second;\\n            double diff2 = (double)b.first / b.second;\\n            if(diff1 == diff2)\\n                return (a.first > b.first);\\n            return (diff1 > diff2);\\n            \\n        }\\n};\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>&D, vector<int>&S) {\\n        int n = D.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,compare>pq;\\n        int count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push({D[i],S[i]});\\n        }\\n        while(!pq.empty())\\n        {\\n            pair<int,int>cur = pq.top();\\n            pq.pop();\\n            int check = cur.first - (cur.second * count);\\n            if(check <= 0)\\n                break;\\n            count++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735221,
                "title": "c-easy-to-understand-3-approaches",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Approach 1\\nusing extra space**\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n     int n=speed.size();\\n        vector<int> time(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            time[i]=(dist[i]-1)/speed[i];\\n        }\\n        sort(time.begin(),time.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(time[i]<i)\\n                return i;\\n        }\\n        return n;\\n    }\\n};\\n```\\n**Approach 2\\nwithout using extra space**\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n     int n=speed.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            dist[i]=(dist[i]-1)/speed[i];\\n        }\\n        sort(dist.begin(),dist.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dist[i]<i)\\n                return i;\\n        }\\n        return n;\\n    }\\n};\\n```\\n**Using priority queue (Min heap)**\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n     int n=speed.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            dist[i]=(dist[i]-1)/speed[i];\\n        }\\n        priority_queue<int,vector<int>,greater<int> > pq(dist.begin(),dist.end());\\n        int i=0;\\n        while(i<n&&i<=pq.top())\\n        {\\n            i++;\\n            pq.pop();\\n        }\\n        return n-pq.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n     int n=speed.size();\\n        vector<int> time(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            time[i]=(dist[i]-1)/speed[i];\\n        }\\n        sort(time.begin(),time.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(time[i]<i)\\n                return i;\\n        }\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n     int n=speed.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            dist[i]=(dist[i]-1)/speed[i];\\n        }\\n        sort(dist.begin(),dist.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dist[i]<i)\\n                return i;\\n        }\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n     int n=speed.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            dist[i]=(dist[i]-1)/speed[i];\\n        }\\n        priority_queue<int,vector<int>,greater<int> > pq(dist.begin(),dist.end());\\n        int i=0;\\n        while(i<n&&i<=pq.top())\\n        {\\n            i++;\\n            pq.pop();\\n        }\\n        return n-pq.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723695,
                "title": "be-greedy-in-selecting-goals-in-life",
                "content": "class Solution:\\n*     def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        Time = [0] * len(dist)\\n        for i in range(len(dist)):\\n            Time[i] = dist[i]/speed[i]\\n        \\n        Time.sort()\\n\\n        res = 0\\n        for i in range(len(dist)):\\n            Time[i] = Time[i] - (i*1)\\n            if Time[i] > 0:\\n                res += 1\\n\\n            else:\\n                return res\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n*     def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        Time = [0] * len(dist)\\n        for i in range(len(dist)):\\n            Time[i] = dist[i]/speed[i]\\n        \\n        Time.sort()\\n\\n        res = 0\\n        for i in range(len(dist)):\\n            Time[i] = Time[i] - (i*1)\\n            if Time[i] > 0:\\n                res += 1\\n\\n            else:\\n                return res\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1688180,
                "title": "c-sorting-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n         vector<float> time;\\n         for(int i=0; i<dist.size(); i++){\\n             time.push_back((float)dist[i] / speed[i]);\\n         }\\n         \\n         sort(time.begin(),time.end());\\n         int ans = 1;\\n         int chrg = 1;\\n         \\n         for(int i=1; i<time.size(); i++){\\n             if(time[i] - (float)chrg > 0) ans++;\\n             else break;\\n             chrg++;\\n         }\\n        \\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n         vector<float> time;\\n         for(int i=0; i<dist.size(); i++){\\n             time.push_back((float)dist[i] / speed[i]);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1665252,
                "title": "python-3-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n        #calculate how many minutes it will take each monster to reach the city\\n        mins = []\\n        for i in range(0, len(dist)):\\n            mins.append(math.ceil(dist[i]/speed[i]))\\n            \\n        #sort and go through. If at index i, the value is <=i, that means \\n        #you will have to take care of more than i monsters in < i minutes, which you can\\'t do\\n        mins.sort()\\n        for i in range(0, len(mins)):\\n            if mins[i]<=i:\\n                return i\\n        return len(dist)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n        #calculate how many minutes it will take each monster to reach the city\\n        mins = []\\n        for i in range(0, len(dist)):\\n            mins.append(math.ceil(dist[i]/speed[i]))\\n            \\n        #sort and go through. If at index i, the value is <=i, that means \\n        #you will have to take care of more than i monsters in < i minutes, which you can\\'t do\\n        mins.sort()\\n        for i in range(0, len(mins)):\\n            if mins[i]<=i:\\n                return i\\n        return len(dist)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629898,
                "title": "nlogn-easy-solution-for-beginners-in-js",
                "content": "```\\n/**\\n * @param {number[]} dist\\n * @param {number[]} speed\\n * @return {number}\\n */\\nvar eliminateMaximum = function(dist, speed) {\\n      let t = new Array(dist.legnth)\\n    for(let i = 0; i< dist.length; i++){\\n      let m =  Math.ceil(dist[i]/ speed[i])\\n      t[i] = m\\n    }\\n   t = t.sort((a,b) => a-b)\\n    let c = 0\\n     for(let i = 0; i< t.length; i++){\\n        if(t[i]-i > 0) c++\\n       else if(t[i]-i <= 0) return c\\n    }\\n    return c\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} dist\\n * @param {number[]} speed\\n * @return {number}\\n */\\nvar eliminateMaximum = function(dist, speed) {\\n      let t = new Array(dist.legnth)\\n    for(let i = 0; i< dist.length; i++){\\n      let m =  Math.ceil(dist[i]/ speed[i])\\n      t[i] = m\\n    }\\n   t = t.sort((a,b) => a-b)\\n    let c = 0\\n     for(let i = 0; i< t.length; i++){\\n        if(t[i]-i > 0) c++\\n       else if(t[i]-i <= 0) return c\\n    }\\n    return c\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1614191,
                "title": "c-and-python-code-using-priority-queue-and-sorting-respectively",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tC++\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double,vector<double>,greater<double>>pq;\\n        int n=dist.size();\\n        for(int i=0;i<n;++i)\\n        {\\n            float dis=dist[i]+0.0;\\n            float spd=speed[i]+0.0;\\n            double time=dis/spd;\\n            pq.push(time);\\n        }\\n          \\n        int time_used_in_refilling=0;\\n        int monsters=0;\\n        while(!pq.empty())\\n        {\\n            double curr=pq.top();\\n            if(curr - time_used_in_refilling<=0)\\n                return monsters;\\n            pq.pop();\\n            time_used_in_refilling++;\\n            monsters++;\\n        }\\n      \\n        return monsters;\\n        \\n    }\\n};\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tPYTHON\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        import math\\n        l=[]\\n        for i in range(0,len(dist)):\\n            l.append(dist[i]/speed[i])\\n        l.sort()\\n        reload_time=0\\n        monsters=0\\n        for time in l:\\n            if time-reload_time<=0:\\n                return monsters;\\n            reload_time+=1\\n            monsters+=1\\n        return monsters\\n```",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double,vector<double>,greater<double>>pq;\\n        int n=dist.size();\\n        for(int i=0;i<n;++i)\\n        {\\n            float dis=dist[i]+0.0;\\n            float spd=speed[i]+0.0;\\n            double time=dis/spd;\\n            pq.push(time);\\n        }\\n          \\n        int time_used_in_refilling=0;\\n        int monsters=0;\\n        while(!pq.empty())\\n        {\\n            double curr=pq.top();\\n            if(curr - time_used_in_refilling<=0)\\n                return monsters;\\n            pq.pop();\\n            time_used_in_refilling++;\\n            monsters++;\\n        }\\n      \\n        return monsters;\\n        \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        import math\\n        l=[]\\n        for i in range(0,len(dist)):\\n            l.append(dist[i]/speed[i])\\n        l.sort()\\n        reload_time=0\\n        monsters=0\\n        for time in l:\\n            if time-reload_time<=0:\\n                return monsters;\\n            reload_time+=1\\n            monsters+=1\\n        return monsters\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537783,
                "title": "simple-solution-with-expalnation-maths",
                "content": "First just calculate time of monster\\'s arrival using formula [speed = dist/time  so time = dist/speed]\\nmake a array of time sort in ascending order since we\\'ll first kill monster that is closest to use\\n\\nevery time you kill a monster increase unit of time by one means 2nd will be killed at two ,3rd will be at 3\\nand so on if our time is less than (1,2,3,4,5......) break out of loop otherwise increase answer by one\\n\\nThat\\'s it  \\nHere is my solution -\\n\\n\"\\'class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        \\n        vector<double> time;\\n        \\n        for(int i=0; i<speed.size(); i++){\\n            time.push_back((double)dist[i]/(double)speed[i]);\\n        }\\n        sort(time.begin(),time.end());\\n        \\n        int ourTime = 0;    //our clock\\n        int answer = 0;     //we can kill 1st monster we\\'ve energy\\n        \\n        for(auto Time : time){\\n            if(Time<= ourTime) break;\\n            else{\\n                ourTime++;    // Time is time of monster arrive the city\\n                answer++;     //next monster will reach at 2,3,4,5 unit time acc to our clock\\n            }\\n        }\\n            return answer;\\n    }\\n};\\n\"\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        \\n        vector<double> time;\\n        \\n        for(int i=0; i<speed.size(); i++){\\n            time.push_back((double)dist[i]/(double)speed[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1421548,
                "title": "without-sorting-priority-queue-cpp-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n    {\\n        priority_queue<double> pq;\\n        \\n        for(int i=0;i<dist.size();i++)\\n        {\\n            pq.push(-1*(double)(dist[i])/speed[i]);\\n        }\\n        double t=0;\\n        int n=0;\\n        while(!pq.empty() && abs(pq.top())>t)\\n        {\\n            n++;\\n            t++;\\n            pq.pop();\\n        }\\n        return n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n    {\\n        priority_queue<double> pq;\\n        \\n        for(int i=0;i<dist.size();i++)\\n        {\\n            pq.push(-1*(double)(dist[i])/speed[i]);\\n        }\\n        double t=0;\\n        int n=0;\\n        while(!pq.empty() && abs(pq.top())>t)\\n        {\\n            n++;\\n            t++;\\n            pq.pop();\\n        }\\n        return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391059,
                "title": "simple-java-sorting-solution-intuition-explained",
                "content": "```\\nclass Solution {\\n\\t// Intuition: consider you are standing at the city where collision will happen\\n\\t// now we can already tell based on timeToCity array which monster is going to strike next\\n\\t// so we sort in increasing order of arrival time\\n\\t// simply check if we can still shoot the next one or not\\n\\t// everytime we shoot take 1 min to load again\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double[] timeToCity = new double[n];\\n        for (int i = 0; i < n; i++) {\\n            timeToCity[i] = dist[i] / (1.0 * speed[i]);\\n        }\\n        Arrays.sort(timeToCity);\\n        double curTime = 0.0;\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (curTime < timeToCity[i]) {\\n                res++;\\n                curTime += 1.0;\\n            } else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t// Intuition: consider you are standing at the city where collision will happen\\n\\t// now we can already tell based on timeToCity array which monster is going to strike next\\n\\t// so we sort in increasing order of arrival time\\n\\t// simply check if we can still shoot the next one or not\\n\\t// everytime we shoot take 1 min to load again\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double[] timeToCity = new double[n];\\n        for (int i = 0; i < n; i++) {\\n            timeToCity[i] = dist[i] / (1.0 * speed[i]);\\n        }\\n        Arrays.sort(timeToCity);\\n        double curTime = 0.0;\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (curTime < timeToCity[i]) {\\n                res++;\\n                curTime += 1.0;\\n            } else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384373,
                "title": "simple-python-solution-heap",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time_left = [dist[i] / speed[i] for i in range(len(dist))]\\n        heapify(time_left)\\n        \\n        cur_time = 0\\n        \\n        while time_left:\\n            if heappop(time_left) <= cur_time: return cur_time\\n            cur_time += 1\\n            \\n        return cur_time",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time_left = [dist[i] / speed[i] for i in range(len(dist))]\\n        heapify(time_left)\\n        \\n        cur_time = 0\\n        \\n        while time_left:\\n            if heappop(time_left) <= cur_time: return cur_time\\n            cur_time += 1\\n            \\n        return cur_time",
                "codeTag": "Java"
            },
            {
                "id": 1378917,
                "title": "python-time-of-arrival-greedy-method-commented",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = [] \\n        for i in range(len(dist)):\\n            time.append(dist[i]/speed[i])  #note that this can be a float\\n        time.sort() #create time of arrival table, and sort it. we just greedily kill the monster that will arrive first\\n\\n        for t in range(len(time)): #t is also the current time\\n            monster_has_arrived = (time[t] - t <= 0)\\n            if monster_has_arrived : \\n                return t #we can just return the current time, which is also the number of monster we have killed, because we can only eliminate one monster per timestep\\n            \\n        return len(time) #we killed all monsters\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = [] \\n        for i in range(len(dist)):\\n            time.append(dist[i]/speed[i])  #note that this can be a float\\n        time.sort() #create time of arrival table, and sort it. we just greedily kill the monster that will arrive first\\n\\n        for t in range(len(time)): #t is also the current time\\n            monster_has_arrived = (time[t] - t <= 0)\\n            if monster_has_arrived : \\n                return t #we can just return the current time, which is also the number of monster we have killed, because we can only eliminate one monster per timestep\\n            \\n        return len(time) #we killed all monsters\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366809,
                "title": "sort-arrival-times-98-speed",
                "content": "Runtime: 792 ms, faster than 98.52% of Python3 online submissions for Eliminate Maximum Number of Monsters.\\nMemory Usage: 30.1 MB, less than 40.03% of Python3 online submissions for Eliminate Maximum Number of Monsters.\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for i, t in enumerate(sorted(d / s for d, s in zip(dist, speed))):\\n            if t <= i:\\n                return i\\n        return len(dist)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        for i, t in enumerate(sorted(d / s for d, s in zip(dist, speed))):\\n            if t <= i:\\n                return i\\n        return len(dist)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330532,
                "title": "c-using-sorting",
                "content": "```\\n\\n```public:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        long long int i,f=0,x;\\n        vector<int>v;\\n        for(i=0;i<speed.size();i++)\\n        {\\n            x=ceil(((double)dist[i]/(double)speed[i]));\\n            v.push_back(x);\\n        }\\n        sort(v.begin(),v.end());\\n            for(i=0;i<v.size();i++)\\n            {\\n                if(v[i]<=i)\\n                {\\n                    break;\\n                }\\n                    f++;\\n            }\\n        return f;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1327706,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        take = list() # how much time each monster needs to take to reach the  city\\n        for i in range(n := len(dist)):\\n            take.append(dist[i] / speed[i])\\n        take.sort()\\n        for i in range(n):\\n            if i >= take[i]: # monster[i] has already reached the city first, you lose\\n                return i\\n        return n # you can eliminate all monster and keep the city from attacking \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        take = list() # how much time each monster needs to take to reach the  city\\n        for i in range(n := len(dist)):\\n            take.append(dist[i] / speed[i])\\n        take.sort()\\n        for i in range(n):\\n            if i >= take[i]: # monster[i] has already reached the city first, you lose\\n                return i\\n        return n # you can eliminate all monster and keep the city from attacking \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326065,
                "title": "simple-c-using-ratio-of-dist-speed",
                "content": "class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& sp) {\\n        \\n        \\n        \\n        int n=dist.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int a;\\n            if(dist[i]%sp[i]==0) a=dist[i]/sp[i];\\n            else a=dist[i]/sp[i]+1;\\n            dist[i]=a;\\n        }\\n        sort(dist.begin(),dist.end());\\n      int i;\\n        \\n        for( i=1;i<n;i++){\\n            if(dist[i]-i<=0) return i;\\n            \\n        }\\n        \\n        return i;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& sp) {\\n        \\n        \\n        \\n        int n=dist.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int a;\\n            if(dist[i]%sp[i]==0) a=dist[i]/sp[i];\\n            else a=dist[i]/sp[i]+1;\\n            dist[i]=a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1323451,
                "title": "a-few-solutions",
                "content": "Sort by arrival time `A`.  Then greedily consume monsters which arrive before the current `i`<sup>th</sup> minute (+1 for 1-based arrival times).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun eliminateMaximum(dist: IntArray, speed: IntArray): Int {\\n        var N = dist.size\\n        var A = dist.mapIndexed{ i, _ -> Math.ceil(dist[i].toDouble() / speed[i].toDouble()).toInt() }.toIntArray().sortedArray()\\n        for (i in 0 until N)\\n            if (A[i] < i + 1)  // +1 for 1-based indexing of 0..N-1 inclusive\\n                return i\\n        return N\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet eliminateMaximum = (dist, speed) => {\\n    let N = dist.length;\\n    let A = [...dist].map((_, i) => Math.ceil(dist[i] / speed[i])).sort((a, b) => a - b);\\n    for (let i = 0; i < N; ++i)\\n        if (A[i] < i + 1)  // +1 for 1-based indexing of 0..N-1 inclusive\\n            return i;\\n    return N;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        N = len(dist)\\n        A = sorted([ceil(dist[i] / speed[i]) for i in range(N)])\\n        for i in range(N):\\n            if A[i] < i + 1:  # +1 for 1-based indexing of 0..N-1 inclusive\\n                return i\\n        return N\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int eliminateMaximum(VI& dist, VI& speed, VI A = {}) {\\n        int N = dist.size();\\n        for (auto i{ 0 }; i < N; A.push_back(ceil(double(dist[i]) / speed[i])), ++i);\\n        sort(A.begin(), A.end());\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (A[i] < i + 1)  // +1 for 1-based indexing of 0..N-1 inclusive\\n                return i;\\n        return N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun eliminateMaximum(dist: IntArray, speed: IntArray): Int {\\n        var N = dist.size\\n        var A = dist.mapIndexed{ i, _ -> Math.ceil(dist[i].toDouble() / speed[i].toDouble()).toInt() }.toIntArray().sortedArray()\\n        for (i in 0 until N)\\n            if (A[i] < i + 1)  // +1 for 1-based indexing of 0..N-1 inclusive\\n                return i\\n        return N\\n    }\\n}\\n```\n```\\nlet eliminateMaximum = (dist, speed) => {\\n    let N = dist.length;\\n    let A = [...dist].map((_, i) => Math.ceil(dist[i] / speed[i])).sort((a, b) => a - b);\\n    for (let i = 0; i < N; ++i)\\n        if (A[i] < i + 1)  // +1 for 1-based indexing of 0..N-1 inclusive\\n            return i;\\n    return N;\\n};\\n```\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        N = len(dist)\\n        A = sorted([ceil(dist[i] / speed[i]) for i in range(N)])\\n        for i in range(N):\\n            if A[i] < i + 1:  # +1 for 1-based indexing of 0..N-1 inclusive\\n                return i\\n        return N\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int eliminateMaximum(VI& dist, VI& speed, VI A = {}) {\\n        int N = dist.size();\\n        for (auto i{ 0 }; i < N; A.push_back(ceil(double(dist[i]) / speed[i])), ++i);\\n        sort(A.begin(), A.end());\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (A[i] < i + 1)  // +1 for 1-based indexing of 0..N-1 inclusive\\n                return i;\\n        return N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322051,
                "title": "c-faster-than-97-8-lines",
                "content": "class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        \\n        int n = speed.size();\\n        \\n        vector<int>v;\\n        for(int i=0 ; i< n; i++)\\n        {\\n            int t = dist[i]/speed[i] + (dist[i]%speed[i]!=0);\\n            v.push_back(t);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0 ; i<n ; i++)\\n            if(v[i]-i<=0) return i;\\n        \\n        return n;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        \\n        int n = speed.size();\\n        \\n        vector<int>v;\\n        for(int i=0 ; i< n; i++)\\n        {\\n            int t = dist[i]/speed[i] + (dist[i]%speed[i]!=0);\\n            v.push_back(t);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1316366,
                "title": "python-bucket-sort-o-n",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n = len(dist)\\n        buckets = [0] * n\\n        for i in range(n):\\n            arrival = math.ceil(dist[i] / speed[i])\\n            if arrival < n:\\n                buckets[arrival] += 1\\n        killed = 0\\n        for i in range(n):\\n            if killed + buckets[i] > i:\\n                return i\\n            killed += buckets[i]\\n        return n\\n```\\n\\nThe idea is to compare how many monsters we would need to kill at each arrival time. If we would have been able to fit the number of monsters we need to kill at time t into the t timeslots before it, then we increase the number of monsters we have killed. If the arrival of a monster is after time N (where N is the number of monsters) we don\\'t need to worry about it; we are guaranteed to have at least one bucket of time to handle it if we are able to handle the other monsters. We stop once the number of killed + the number of monsters arriving at time t is greater than t, or we got to time N, in which case we return we are able to kill all N monsters.\\n\\nThe result is O(N) runtime and space complexity.",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n = len(dist)\\n        buckets = [0] * n\\n        for i in range(n):\\n            arrival = math.ceil(dist[i] / speed[i])\\n            if arrival < n:\\n                buckets[arrival] += 1\\n        killed = 0\\n        for i in range(n):\\n            if killed + buckets[i] > i:\\n                return i\\n            killed += buckets[i]\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315617,
                "title": "c-easy-solution-100-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int>time(n);\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            if(dist[i]%speed[i]==0)\\n            {\\n                time[i]=(dist[i]/speed[i])-1;\\n            }\\n            else\\n            {\\n                time[i]=(dist[i]/speed[i]);\\n            }\\n        }\\n        sort(time.begin(),time.end());\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i>time[i])\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int>time(n);\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            if(dist[i]%speed[i]==0)\\n            {\\n                time[i]=(dist[i]/speed[i])-1;\\n            }\\n            else\\n            {\\n                time[i]=(dist[i]/speed[i]);\\n            }\\n        }\\n        sort(time.begin(),time.end());\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i>time[i])\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314783,
                "title": "easy-c-solution",
                "content": "```\\n\\tclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = dist.size();\\n        vector<int> temp(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            temp[i] = ceil((float)dist[i]/speed[i]);\\n        }\\n        sort(temp.begin(), temp.end());\\n        int cnt = 1, ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(temp[i] >= cnt)\\n                ans += 1;\\n            else if(temp[i] < cnt)\\n                break;\\n            cnt += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = dist.size();\\n        vector<int> temp(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            temp[i] = ceil((float)dist[i]/speed[i]);\\n        }\\n        sort(temp.begin(), temp.end());\\n        int cnt = 1, ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(temp[i] >= cnt)\\n                ans += 1;\\n            else if(temp[i] < cnt)\\n                break;\\n            cnt += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314775,
                "title": "java-easy-to-understand-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int []time  = new int[dist.length];\\n        for(int i = 0;i< dist.length;i++){\\n            time[i] = (int)Math.ceil(dist[i]*1.0/speed[i]);\\n        }\\n        Arrays.sort(time);\\n        int res = 0;\\n        for(int i = 0; i < time.length ;i++){\\n            if(time[i] <= res)break;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int []time  = new int[dist.length];\\n        for(int i = 0;i< dist.length;i++){\\n            time[i] = (int)Math.ceil(dist[i]*1.0/speed[i]);\\n        }\\n        Arrays.sort(time);\\n        int res = 0;\\n        for(int i = 0; i < time.length ;i++){\\n            if(time[i] <= res)break;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314621,
                "title": "easy-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n       // calculate time for every monster\\n        int n=speed.size();\\n        vector<double>time; // time can be decimal as well\\n        \\n        for(int i=0;i<n;i++){\\n            time.push_back((double) dist[i]/(double)speed[i]);\\n            // type casting bcz integer / integer is integer itself\\n        }\\n                \\n\\n        \\n        sort(time.begin(),time.end());\\n        int ans=0;\\n        int t=0; // initial time\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(time[i]<= t){\\n                break;\\n                // we lost the game\\n            }\\n            else{\\n                ans++;\\n                t++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n       // calculate time for every monster\\n        int n=speed.size();\\n        vector<double>time; // time can be decimal as well\\n        \\n        for(int i=0;i<n;i++){\\n            time.push_back((double) dist[i]/(double)speed[i]);\\n            // type casting bcz integer / integer is integer itself\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1314620,
                "title": "python-with-visual-explanation-the-easiest-solution-to-follow",
                "content": "![image](https://assets.leetcode.com/users/images/506687a3-ef78-4765-acf9-e2695847afc8_1625375062.1255114.png)\\n\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n        quotients = []\\n        \\n        for i in range(len(dist)):\\n\\t\\t\\t# we use ceiling rounding here to differentiate (dist,speed) pair of (1,1) and (5,4)\\n\\t\\t\\t# (1,1) has only one chance while (5,4) has one more breathing time to kill\\n            quotient = math.ceil(dist[i]/speed[i])\\n            quotients.append(quotient)\\n        \\n        quotients.sort()\\n        \\n        for i in range(len(quotients)):\\n            if quotients[i] == i:\\n                return i\\n        \\n        return len(dist)\\n        \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n        quotients = []\\n        \\n        for i in range(len(dist)):\\n\\t\\t\\t# we use ceiling rounding here to differentiate (dist,speed) pair of (1,1) and (5,4)\\n\\t\\t\\t# (1,1) has only one chance while (5,4) has one more breathing time to kill\\n            quotient = math.ceil(dist[i]/speed[i])\\n            quotients.append(quotient)\\n        \\n        quotients.sort()\\n        \\n        for i in range(len(quotients)):\\n            if quotients[i] == i:\\n                return i\\n        \\n        return len(dist)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314614,
                "title": "o-n-log-n-java-easy-solution-well-commented-code-memory-less-than-100",
                "content": "The idea is to siply check that the distance does\\'nt be 0 or negative according to the question\\nRuntime-78ms\\nMemory -49mb\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        //If rate is greater than sort according to it otherwise the one which is near will be removed first\\n        PriorityQueue <pair>pq=new PriorityQueue<>((a,b)->a.rate==b.rate?a.di-b.di:(Double.compare(a.rate, b.rate)));\\n        for(int i=0;i<dist.length;i++){\\n            pair a= new pair(dist[i],speed[i],(double)dist[i]/speed[i]);\\n            pq.add(a);}\\n        int count=0;\\n        while(!pq.isEmpty())\\n        {pair x=pq.poll();\\n            if((x.di-(x.spe*count))<=0.0)//we will simply check that if the distance is not negative\\n                 break;\\n            count++;}\\n        return count;\\n    }\\n               class pair\\n               {\\n                   int di, spe;\\n                  double rate;\\n                   pair(int di, int spe, double rate)\\n                   {\\n                       this.di=di;\\n                       this.spe=spe;\\n                       this.rate=rate; //rate at which it is approaching left\\n                   }\\n               }\\n}\\n```\\nDo upvote if you like",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        //If rate is greater than sort according to it otherwise the one which is near will be removed first\\n        PriorityQueue <pair>pq=new PriorityQueue<>((a,b)->a.rate==b.rate?a.di-b.di:(Double.compare(a.rate, b.rate)));\\n        for(int i=0;i<dist.length;i++){\\n            pair a= new pair(dist[i],speed[i],(double)dist[i]/speed[i]);\\n            pq.add(a);}\\n        int count=0;\\n        while(!pq.isEmpty())\\n        {pair x=pq.poll();\\n            if((x.di-(x.spe*count))<=0.0)//we will simply check that if the distance is not negative\\n                 break;\\n            count++;}\\n        return count;\\n    }\\n               class pair\\n               {\\n                   int di, spe;\\n                  double rate;\\n                   pair(int di, int spe, double rate)\\n                   {\\n                       this.di=di;\\n                       this.spe=spe;\\n                       this.rate=rate; //rate at which it is approaching left\\n                   }\\n               }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314595,
                "title": "c-o-n-log-n-sort-by-times-and-eliminate-one-at-each-minute",
                "content": "```csharp\\npublic int EliminateMaximum(int[] dist, int[] speed)\\n{\\n\\tdouble[] times = new double[dist.Length];\\n\\n\\tfor (int i = 0; i < dist.Length; i++)\\n\\t{\\n\\t\\ttimes[i] = (dist[i] * 1d) / speed[i];\\n\\t}\\n\\n\\tArray.Sort(times);\\n\\tint result = 0;\\n\\n\\tfor (int i = 0; i < times.Length; i++)\\n\\t{\\n\\t\\tif (times[i] > i)\\n\\t\\t{\\n\\t\\t\\tresult++;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int EliminateMaximum(int[] dist, int[] speed)\\n{\\n\\tdouble[] times = new double[dist.Length];\\n\\n\\tfor (int i = 0; i < dist.Length; i++)\\n\\t{\\n\\t\\ttimes[i] = (dist[i] * 1d) / speed[i];\\n\\t}\\n\\n\\tArray.Sort(times);\\n\\tint result = 0;\\n\\n\\tfor (int i = 0; i < times.Length; i++)\\n\\t{\\n\\t\\tif (times[i] > i)\\n\\t\\t{\\n\\t\\t\\tresult++;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314593,
                "title": "python-greedy-o-n-log-n-sorting-based-solution-bonus-one-liner",
                "content": "## Approach\\n* Sort the monsters based on the amount of time they will take to reach the city\\n* Find which ones can be eliminated before one of them reaches the city\\n\\n```\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = sorted([dist[i]/speed[i] for i in range(len(dist))])\\n\\t\\t# Another way to get the time\\n\\t\\t# time = sorted(d/s for d, s in zip(dist, speed))\\n        cnt = 0\\n        for i, t in enumerate(time):\\n            if i<t: cnt += 1\\n            else: break\\n                \\n        return cnt\\n```\\n\\n## Complexity\\n* Time: `O(n*log n)` where `n` is the number of monsters\\n* Space: `O(n)` to store the `time` each monster will take to reach the city\\n\\n## For the love of python one-liners\\n```\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        return ([1 if i<t else 0 for i,t in enumerate(sorted(d/s for d,s in zip(dist,speed)))] + [0]).index(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = sorted([dist[i]/speed[i] for i in range(len(dist))])\\n\\t\\t# Another way to get the time\\n\\t\\t# time = sorted(d/s for d, s in zip(dist, speed))\\n        cnt = 0\\n        for i, t in enumerate(time):\\n            if i<t: cnt += 1\\n            else: break\\n                \\n        return cnt\\n```\n```\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        return ([1 if i<t else 0 for i,t in enumerate(sorted(d/s for d,s in zip(dist,speed)))] + [0]).index(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1314586,
                "title": "1921-sort-by-distance-speed-ratio",
                "content": "---\\n\\nNeed to do similar problems. Took 1+ hours to get the `sort` right in contest :D\\n\\n---\\n\\n- Code from contest\\n- Code from practice 1 - easy to read\\n- Code from practice 2 - better due to initial prepossessing\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Code from contest**\\n\\n```\\nvar eliminateMaximum = function(D, S) {\\n    let count = 0;\\n\\n    let A = D.map((_, i) => [D[i], S[i]])\\n    A.sort((a, b) => (a[0] / b[0] - a[1] / b[1]))\\n\\n    let done = false;\\n    let elapsedTime = 1;\\n    A.forEach((_, i) => {\\n        if (done)\\n            return\\n        count++;\\n        if (i + 1 < A.length && (A[i + 1][0] - elapsedTime * A[i + 1][1]) <= 0) {\\n            done = true   // next one exists, and is bad (<=0) so exit\\n            return\\n        }\\n        elapsedTime++;\\n    });\\n\\n    return count;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/657f53b0-98bd-42c7-8fe6-cfe45c0d08c3_1625374156.5236957.png)\\n\\n---\\n\\n**Code from practice 1**\\n\\n```\\nvar eliminateMaximum = function(D, S) {\\n    let elapsedTime = 0;\\n\\n    D\\n        .map((_, i) => [D[i], S[i]])\\n        .sort(([d1, s1], [d2, s2]) => (d1 / d2 - s1 / s2)) // sort by ( Distance ratio ) then ( Speed ratio )\\n        .some(([d, s], i) => {\\n            if ((d - elapsedTime * s) <= 0)\\n                return true // bad one (<=0) so exit\\n            elapsedTime++;\\n            return false\\n        });\\n\\n    return elapsedTime;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/91c6735c-7661-4b08-b9a0-6a7a0f07ce8a_1625376631.2675278.png)\\n\\n---\\n\\n**Code from practice 2**\\n\\n```\\nvar eliminateMaximum = function(D, S) {\\n    let elapsedTime = 0;\\n\\n    D\\n        .map((_, i) => D[i] / S[i])\\n        .sort((a, b) => (a - b)) // sort by ( Distance / Speed ) ratio\\n        .some((dsR) => {\\n            if ((elapsedTime < dsR) <= 0)\\n                return true // bad one (<=0) so exit\\n            elapsedTime++;\\n            return false\\n        });\\n\\n    return elapsedTime;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/92a76a99-d2dc-4bb0-8321-0d3f7e1d5fea_1625377427.3017998.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar eliminateMaximum = function(D, S) {\\n    let count = 0;\\n\\n    let A = D.map((_, i) => [D[i], S[i]])\\n    A.sort((a, b) => (a[0] / b[0] - a[1] / b[1]))\\n\\n    let done = false;\\n    let elapsedTime = 1;\\n    A.forEach((_, i) => {\\n        if (done)\\n            return\\n        count++;\\n        if (i + 1 < A.length && (A[i + 1][0] - elapsedTime * A[i + 1][1]) <= 0) {\\n            done = true   // next one exists, and is bad (<=0) so exit\\n            return\\n        }\\n        elapsedTime++;\\n    });\\n\\n    return count;\\n};\\n```\n```\\nvar eliminateMaximum = function(D, S) {\\n    let elapsedTime = 0;\\n\\n    D\\n        .map((_, i) => [D[i], S[i]])\\n        .sort(([d1, s1], [d2, s2]) => (d1 / d2 - s1 / s2)) // sort by ( Distance ratio ) then ( Speed ratio )\\n        .some(([d, s], i) => {\\n            if ((d - elapsedTime * s) <= 0)\\n                return true // bad one (<=0) so exit\\n            elapsedTime++;\\n            return false\\n        });\\n\\n    return elapsedTime;\\n};\\n```\n```\\nvar eliminateMaximum = function(D, S) {\\n    let elapsedTime = 0;\\n\\n    D\\n        .map((_, i) => D[i] / S[i])\\n        .sort((a, b) => (a - b)) // sort by ( Distance / Speed ) ratio\\n        .some((dsR) => {\\n            if ((elapsedTime < dsR) <= 0)\\n                return true // bad one (<=0) so exit\\n            elapsedTime++;\\n            return false\\n        });\\n\\n    return elapsedTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314500,
                "title": "priority-queue-o-nlogn-simple-solution-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double> v(dist.size(),0);\\n        priority_queue<double> pq;\\n        for(int i=0;i<dist.size();i++){\\n            v[i] = ((double)dist[i])/((double)speed[i]);                           //gives us expected time to reach city\\n            pq.push(-1*v[i]);\\n        }\\n        int time=0;                                                         //starting clock at time=0;\\n        int count=0;\\n        while(true){\\n            if(pq.empty())\\n                break;\\n            auto top = pq.top();\\n            pq.pop();\\n            if((double)time<-1*top)                         //for the monsters to be killed then time must be less than \\n            {count++;time++;}                               //expected time value else the monster has already reached the city\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double> v(dist.size(),0);\\n        priority_queue<double> pq;\\n        for(int i=0;i<dist.size();i++){\\n            v[i] = ((double)dist[i])/((double)speed[i]);                           //gives us expected time to reach city\\n            pq.push(-1*v[i]);\\n        }\\n        int time=0;                                                         //starting clock at time=0;\\n        int count=0;\\n        while(true){\\n            if(pq.empty())\\n                break;\\n            auto top = pq.top();\\n            pq.pop();\\n            if((double)time<-1*top)                         //for the monsters to be killed then time must be less than \\n            {count++;time++;}                               //expected time value else the monster has already reached the city\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314473,
                "title": "c-simple-solution-priority-queue",
                "content": "```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double ,vector<double>,greater<double>>pq;\\n        for(int i=0;i<dist.size();i++){\\n            double num=ceil((double)dist[i]/(double)speed[i]);\\n            pq.push(num);\\n        }\\n         int count=0;\\n         double time=1.0;\\n         while(!pq.empty()){\\n             double tm=pq.top();\\n             pq.pop();\\n             if(tm<time)\\n                 return count;\\n             count++;\\n             time++;\\n             \\n         }\\n        return count;\\n\\t\\t\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double ,vector<double>,greater<double>>pq;\\n        for(int i=0;i<dist.size();i++){\\n            double num=ceil((double)dist[i]/(double)speed[i]);\\n            pq.push(num);\\n        }\\n         int count=0;\\n         double time=1.0;\\n         while(!pq.empty()){\\n             double tm=pq.top();\\n             pq.pop();\\n             if(tm<time)\\n                 return count;\\n             count++;\\n             time++;\\n             \\n         }\\n        return count;\\n\\t\\t\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314448,
                "title": "simple-c-o-nlogn-soln",
                "content": "```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int> time;\\n        for(int i=0;i<n;i++){\\n            time.push_back(ceil((double)dist[i]/speed[i]));\\n        }\\n        sort(time.begin(),time.end());\\n        int ans=0;\\n        int mintime=0;\\n        for(int i=0;i<n;i++){\\n            if(time[i]>mintime){\\n                ans++;\\n            }\\n            else{\\n                return ans;\\n            }\\n            mintime++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int> time;\\n        for(int i=0;i<n;i++){\\n            time.push_back(ceil((double)dist[i]/speed[i]));\\n        }\\n        sort(time.begin(),time.end());\\n        int ans=0;\\n        int mintime=0;\\n        for(int i=0;i<n;i++){\\n            if(time[i]>mintime){\\n                ans++;\\n            }\\n            else{\\n                return ans;\\n            }\\n            mintime++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314444,
                "title": "cpp-solution-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > min_heap;\\n        \\n        int n=dist.size(), tp=0;\\n        for(int i=0; i<n; i++){\\n            int k=ceil((double)dist[i]/(double)speed[i]); \\n            if(dist[i]/speed[i] > k)    k++;\\n            \\n            min_heap.push({k, dist[i]});\\n        }\\n        \\n        int count=0, time=0;\\n        if(min_heap.top().first<=0){\\n            count=1;\\n        }else{\\n            while(!min_heap.empty()){\\n                pair<int, int> mon=min_heap.top();\\n                min_heap.pop();\\n\\n                if(mon.first==0)   break;\\n\\n                if( mon.first > time){\\n                    count++;\\n                }else break;\\n\\n                time++;\\n            }\\n        }\\n               \\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > min_heap;\\n        \\n        int n=dist.size(), tp=0;\\n        for(int i=0; i<n; i++){\\n            int k=ceil((double)dist[i]/(double)speed[i]); \\n            if(dist[i]/speed[i] > k)    k++;\\n            \\n            min_heap.push({k, dist[i]});\\n        }\\n        \\n        int count=0, time=0;\\n        if(min_heap.top().first<=0){\\n            count=1;\\n        }else{\\n            while(!min_heap.empty()){\\n                pair<int, int> mon=min_heap.top();\\n                min_heap.pop();\\n\\n                if(mon.first==0)   break;\\n\\n                if( mon.first > time){\\n                    count++;\\n                }else break;\\n\\n                time++;\\n            }\\n        }\\n               \\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314421,
                "title": "python-best-soln-sorting-greedy",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        ans=[]\\n        n=len(dist)\\n        for i in range(n):\\n            ans.append(ceil(dist[i]/speed[i]))\\n        ans.sort()\\n        print(ans)\\n        i=0\\n        while(i<n):\\n            if (ans[i]<=i):\\n                return (i)\\n            i+=1\\n        return n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        ans=[]\\n        n=len(dist)\\n        for i in range(n):\\n            ans.append(ceil(dist[i]/speed[i]))\\n        ans.sort()\\n        print(ans)\\n        i=0\\n        while(i<n):\\n            if (ans[i]<=i):\\n                return (i)\\n            i+=1\\n        return n",
                "codeTag": "Java"
            },
            {
                "id": 1314406,
                "title": "easy-to-understand-c-o-nlogn",
                "content": "```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        pair<int,int> a[n];\\n       \\n            for (int i=0; i<n; i++)\\n             a[i]={i,ceil((double)dist[i]/speed[i])};\\n        \\n        sort(a,a+n,[](pair<int,int> c, pair<int,int> b) {return c.second <b.second; });\\n        int z=a[n-1].second;\\n        int j=0;\\n        int count=0;\\n        for(int i=0;i<z&&j<n;){\\n            if(a[i].second>i){\\n                count++;\\n                i++;j++;\\n            }\\n            else\\n                j++;\\n                \\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        pair<int,int> a[n];\\n       \\n            for (int i=0; i<n; i++)\\n             a[i]={i,ceil((double)dist[i]/speed[i])};\\n        \\n        sort(a,a+n,[](pair<int,int> c, pair<int,int> b) {return c.second <b.second; });\\n        int z=a[n-1].second;\\n        int j=0;\\n        int count=0;\\n        for(int i=0;i<z&&j<n;){\\n            if(a[i].second>i){\\n                count++;\\n                i++;j++;\\n            }\\n            else\\n                j++;\\n                \\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314371,
                "title": "short-python-solution",
                "content": "```\\nn = len(dist)\\narr = [1 if speed[i] >= dist[i] else ceil(1.0 * dist[i] / speed[i]) for i in range(n)]\\narr.sort()\\nfor i in range(n):\\n\\tif arr[i] < i + 1:\\n\\t\\treturn i\\nreturn n\\n```",
                "solutionTags": [],
                "code": "```\\nn = len(dist)\\narr = [1 if speed[i] >= dist[i] else ceil(1.0 * dist[i] / speed[i]) for i in range(n)]\\narr.sort()\\nfor i in range(n):\\n\\tif arr[i] < i + 1:\\n\\t\\treturn i\\nreturn n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043252,
                "title": "simple-python-solution",
                "content": "# Intuition\\nWe need some way of determining the order in which to kill the monsters. The monsters that will arrive first shall be those we kill first.\\n\\n\\n# Approach\\nCalculate the arrival time of each monster using the relation\\n\\ntime = distance / speed\\n\\nThis can be performed directly on the lists dist and speed by using Python\\'s map function. Truediv is used as the fractional part of time is important later.\\n\\nSort the time array to determine the order in which the monsters should be killed. The sorted array order is the order in which they will be killed.\\n\\nTreat the index of the sorted array as the minute at which the monster will be killed as we can only kill 1 monster per minute.\\n\\nIterate through time and see if there are any cases where the arrival time is before the value\\'s index in $time$. If this does happen, the game is lost and the score is returned. The score is just the index value (0-indexed therefore it doesn\\'t include the current monster in the count).\\n\\nIf the for loop doesn\\'t terminate early (i.e. no monsters reach the city before they are killed) return idx + 1. This is the length of dist, or how many monsters there are, n.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log n)$$ - a sort is used. Python\\'s native sort, Tim sort, is $$O(nlogn)$$.\\n\\n- Space complexity:\\n$$O(n)$$ - we use a list of n elements.\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = list(map(truediv, dist, speed))\\n        time.sort()\\n\\n        for idx, t in enumerate(time):\\n            if idx >= ceil(t):\\n                return idx\\n\\n        return idx + 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = list(map(truediv, dist, speed))\\n        time.sort()\\n\\n        for idx, t in enumerate(time):\\n            if idx >= ceil(t):\\n                return idx\\n\\n        return idx + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013678,
                "title": "python-sorting-greedy",
                "content": "<!--# Intuition-->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort by arrival time of monsters\\n- Every minute, try to defeat a monster by checking if weapon is ready\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        ready_time = 0\\n        defeated = 0\\n        arrival_times = sorted(d/s for d, s in zip(dist, speed))\\n        for time in arrival_times:\\n            if ready_time >= time:\\n                break\\n            defeated += 1\\n            ready_time += 1\\n        return defeated\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        ready_time = 0\\n        defeated = 0\\n        arrival_times = sorted(d/s for d, s in zip(dist, speed))\\n        for time in arrival_times:\\n            if ready_time >= time:\\n                break\\n            defeated += 1\\n            ready_time += 1\\n        return defeated\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011493,
                "title": "javascript-beats-100-speed-and-memory-o-n-time-o-1-space",
                "content": "```\\nvar eliminateMaximum = function(dist, speed) {\\n    const n = dist.length;\\n    for (let i = 0; i < dist.length; i++) {\\n        dist[i] = Math.ceil(dist[i] / speed[i]);\\n        speed[i] = 0;\\n    }\\n    for (const num of dist) {\\n        if (num >= n) continue;\\n        speed[num] += 1;\\n    }\\n    for (let i = 1; i < speed.length; i++) {\\n        speed[i] += speed[i-1];\\n        if (speed[i] > i) {\\n            return i;\\n        }\\n    }\\n    return n;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar eliminateMaximum = function(dist, speed) {\\n    const n = dist.length;\\n    for (let i = 0; i < dist.length; i++) {\\n        dist[i] = Math.ceil(dist[i] / speed[i]);\\n        speed[i] = 0;\\n    }\\n    for (const num of dist) {\\n        if (num >= n) continue;\\n        speed[num] += 1;\\n    }\\n    for (let i = 1; i < speed.length; i++) {\\n        speed[i] += speed[i-1];\\n        if (speed[i] > i) {\\n            return i;\\n        }\\n    }\\n    return n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994683,
                "title": "simple-beginner-level-c-solution-greedy-sorting-beats-100-in-runtime",
                "content": "\\n# Complexity\\n- Time complexity: ```O(nlogn)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```(O(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\n// Runtime 106 ms Beats 100% Memory 16.5 MB Beats 50%\\nint ascend(const void* pa, const void* pb) {\\n    const int a = *(const int*)pa;\\n    const int b = *(const int*)pb;\\n    if (a == b) {\\n        return 0;\\n    }\\n    return (a < b) ? -1 : 1;\\n}\\nint eliminateMaximum(int* dist, int distSize, int* speed, int speedSize) {\\n    // Greedy + Sorting\\n\\n    // Time comeplxity: O(nlogn)\\n    // Sacpe complexity: O(n)\\n\\n    const int n = distSize;\\n    int* arrivalTime = (int*)calloc(n, sizeof(int));\\n    \\n    for (int i = 0; i < n; i++) {\\n        arrivalTime[i] = (dist[i] - 1) / speed[i];\\n    }\\n\\n    qsort(arrivalTime, n, sizeof(int), ascend);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (i > arrivalTime[i]) {\\n            free(arrivalTime);\\n            return i;\\n        }\\n    }\\n\\n    free(arrivalTime);\\n    return n;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```O(nlogn)```\n```(O(n)```\n```cpp\\n// Runtime 106 ms Beats 100% Memory 16.5 MB Beats 50%\\nint ascend(const void* pa, const void* pb) {\\n    const int a = *(const int*)pa;\\n    const int b = *(const int*)pb;\\n    if (a == b) {\\n        return 0;\\n    }\\n    return (a < b) ? -1 : 1;\\n}\\nint eliminateMaximum(int* dist, int distSize, int* speed, int speedSize) {\\n    // Greedy + Sorting\\n\\n    // Time comeplxity: O(nlogn)\\n    // Sacpe complexity: O(n)\\n\\n    const int n = distSize;\\n    int* arrivalTime = (int*)calloc(n, sizeof(int));\\n    \\n    for (int i = 0; i < n; i++) {\\n        arrivalTime[i] = (dist[i] - 1) / speed[i];\\n    }\\n\\n    qsort(arrivalTime, n, sizeof(int), ascend);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (i > arrivalTime[i]) {\\n            free(arrivalTime);\\n            return i;\\n        }\\n    }\\n\\n    free(arrivalTime);\\n    return n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989405,
                "title": "c-greedy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = dist.size();\\n        vector<int> tim(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            tim[i] = ceil((double)dist[i]/speed[i]);\\n        }\\n        sort(tim.begin(),tim.end());\\n        int cnt = 0,ct = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tim[i]>ct)\\n            {\\n                cnt++;\\n                ct++;\\n            }\\n            else\\n            break;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = dist.size();\\n        vector<int> tim(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            tim[i] = ceil((double)dist[i]/speed[i]);\\n        }\\n        sort(tim.begin(),tim.end());\\n        int cnt = 0,ct = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tim[i]>ct)\\n            {\\n                cnt++;\\n                ct++;\\n            }\\n            else\\n            break;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981752,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n    const int n = dist.size();\\n    vector<int> arrivalTime(n);\\n\\n    for (int i = 0; i < n; ++i)\\n      arrivalTime[i] = (dist[i] - 1) / speed[i];\\n\\n    sort(arrivalTime.begin(), arrivalTime.end());\\n\\n    for (int i = 0; i < n; ++i)\\n      if (i > arrivalTime[i])\\n        return i;\\n\\n    return n;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n    const int n = dist.size();\\n    vector<int> arrivalTime(n);\\n\\n    for (int i = 0; i < n; ++i)\\n      arrivalTime[i] = (dist[i] - 1) / speed[i];\\n\\n    sort(arrivalTime.begin(), arrivalTime.end());\\n\\n    for (int i = 0; i < n; ++i)\\n      if (i > arrivalTime[i])\\n        return i;\\n\\n    return n;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920889,
                "title": "c-use-ceil-commented",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        for(int i =0 ; i < dist.size(); i++){\\n            dist[i] = max(1 ,(int)ceil((double)dist[i]/speed[i]));\\n            // cout<<dist[i]<<endl;\\n        }   \\n\\n        // we need ceil here because when we divide the dist w.r.t speeds \\n        //we have to round it to smallest integer greater than the decimal value.\\n        sort(dist.begin(), dist.end());\\n        //sort it based on times they will reach the destination\\n\\n        int count = 0;\\n        //count keeps count on time and compare with arrival times\\n        for(int i = 1; i <= dist.size(); i++){\\n                if(i <= dist[i - 1]){\\n                        count++;\\n        // we can attack as long as the time reached by the monster is greater than the time, \\n        //we will take if we try to attack the monster sequentially (every second)  \\n                }else{\\n                    return count;\\n        // if not possible return.\\n                }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        for(int i =0 ; i < dist.size(); i++){\\n            dist[i] = max(1 ,(int)ceil((double)dist[i]/speed[i]));\\n            // cout<<dist[i]<<endl;\\n        }   \\n\\n        // we need ceil here because when we divide the dist w.r.t speeds \\n        //we have to round it to smallest integer greater than the decimal value.\\n        sort(dist.begin(), dist.end());\\n        //sort it based on times they will reach the destination\\n\\n        int count = 0;\\n        //count keeps count on time and compare with arrival times\\n        for(int i = 1; i <= dist.size(); i++){\\n                if(i <= dist[i - 1]){\\n                        count++;\\n        // we can attack as long as the time reached by the monster is greater than the time, \\n        //we will take if we try to attack the monster sequentially (every second)  \\n                }else{\\n                    return count;\\n        // if not possible return.\\n                }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3888317,
                "title": "sort-by-time-reached-to-city-with-only-array-time-complexity-o-nlog-because-of-sorting",
                "content": "# Intuition\\nTwo arrays are kinda confusing. After all, the crux of the problem is that how long each monster takes to reach the city.\\n\\n# Approach\\nBy dividing the distance with speed, an array of time is produced.\\n\\nIf the time it takes for a monster to reach the city is less than the elapsed time represented by the ``index``, then the city is destroyed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nint compare(const void *a, const void *b) {\\n    double diff = *(double*)a - *(double*)b;\\n    return (diff > 0) - (diff < 0);\\n}\\n\\nint eliminateMaximum(int* dist, int distSize, int* speed, int speedSize) {\\n    double *time = (double*)malloc(distSize * sizeof(double));\\n    for (int i = 0; i < distSize; i++) {\\n        time[i] = (double)dist[i] / speed[i];\\n    }\\n    qsort(time, distSize, sizeof(double), compare);\\n    for (int i = 0; i < distSize; i++) {\\n        if (time[i] <= i) {\\n            free(time);\\n            return i;\\n        }\\n    }\\n    free(time);\\n    return distSize;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint compare(const void *a, const void *b) {\\n    double diff = *(double*)a - *(double*)b;\\n    return (diff > 0) - (diff < 0);\\n}\\n\\nint eliminateMaximum(int* dist, int distSize, int* speed, int speedSize) {\\n    double *time = (double*)malloc(distSize * sizeof(double));\\n    for (int i = 0; i < distSize; i++) {\\n        time[i] = (double)dist[i] / speed[i];\\n    }\\n    qsort(time, distSize, sizeof(double), compare);\\n    for (int i = 0; i < distSize; i++) {\\n        if (time[i] <= i) {\\n            free(time);\\n            return i;\\n        }\\n    }\\n    free(time);\\n    return distSize;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840522,
                "title": "simple-readable-python-heap-solution",
                "content": "# Intuition\\nClosest monsters should be killed first so we can sort monsters by how quickly they will arrive and kill the quickest ones first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'re going with a min heap so we create an array called time that stores how much time is left before a monster reaches the city. We then heapify it to sort by the closest monster and create variables to store our kills and how much time has passed. \\nWe start with a loaded weapon so we kill a monster to start and reload. If we still have monsters and the time left for our closest monster is lower than how much time has passed then we return how many monsters we killed.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\nheappop() takes $$O(logn)$$ time and while loop is $$O(n)$$ time\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nCreating the time array and making the heap are $$O(n)$$ each. We could store the times in either the distance or speed arrays but I like it as it is for readability.\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        from heapq import heappop, heappush, heapify\\n        time = [dist[i]/speed[i] for i in range(len(speed))]\\n        heapify(time)\\n        time_passed = 0\\n        kills = 0\\n        while time:\\n            heappop(time)\\n            kills += 1\\n            time_passed += 1\\n            if time:\\n                if time[0] - time_passed <= 0:\\n                    return kills\\n        return kills\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        from heapq import heappop, heappush, heapify\\n        time = [dist[i]/speed[i] for i in range(len(speed))]\\n        heapify(time)\\n        time_passed = 0\\n        kills = 0\\n        while time:\\n            heappop(time)\\n            kills += 1\\n            time_passed += 1\\n            if time:\\n                if time[0] - time_passed <= 0:\\n                    return kills\\n        return kills\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834178,
                "title": "go-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc eliminateMaximum(dist []int, speed []int) int {\\n    monsters := make([]Monster, 0, len(dist))\\n\\tfor i, d := range dist {\\n\\t\\tmonsters = append(monsters, Monster{d, speed[i], float64(d) / float64(speed[i])})\\n\\t}\\n\\tsort.Slice(monsters, func(i,j int) bool {\\n\\t\\treturn monsters[i].time < monsters[j].time\\n\\t})\\n\\tcount := 1\\n\\tsp := 1\\n\\tfor i := 1; i < len(monsters); i++{\\n\\t\\tif monsters[i].time - float64(sp) <= 0{\\n\\t\\t\\tbreak\\n\\t\\t} else {\\n\\t\\t\\tsp++\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n\\ntype Monster struct {\\n    dist int\\n    speed int\\n    time float64\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc eliminateMaximum(dist []int, speed []int) int {\\n    monsters := make([]Monster, 0, len(dist))\\n\\tfor i, d := range dist {\\n\\t\\tmonsters = append(monsters, Monster{d, speed[i], float64(d) / float64(speed[i])})\\n\\t}\\n\\tsort.Slice(monsters, func(i,j int) bool {\\n\\t\\treturn monsters[i].time < monsters[j].time\\n\\t})\\n\\tcount := 1\\n\\tsp := 1\\n\\tfor i := 1; i < len(monsters); i++{\\n\\t\\tif monsters[i].time - float64(sp) <= 0{\\n\\t\\t\\tbreak\\n\\t\\t} else {\\n\\t\\t\\tsp++\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n\\ntype Monster struct {\\n    dist int\\n    speed int\\n    time float64\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821937,
                "title": "o-nlogn-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the monster by their arrival time. Iterate the sorted array, eliminate one monster in each iteration, and recharge the weapon. If the recharge time (iteration number) takes more than the monster\\'s arrival, you lose else you kill all monsters.\\n\\nNote: recharge time is 1 min and no recharge is required at the start.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- set n = total number of monsters\\n- calculate the arrival time (distance - 1 / speed) of each monster and sort the arrival times\\n- set recharge = 0 to track the recharge time and number of monsters you killed. Increment it in each iteration, skip this if you use enumerate() because the initialization and increment will be auto done\\n- for each arrival time in the monster arrival array\\n    - if recharge time > arrival time, you lose, return recharge time (the number of monsters you killed)\\n- you killed all monsters, return n\\n\\n# Complexity\\n- Time complexity: O(sort + iteration) \\u2192 O(nlogn + n) \\u2192 O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(sort + arrival array) \\u2192 O(n + n) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n = len(dist)\\n        monster_arrival = sorted([(dist[i] - 1) // speed[i] for i in range(n)])\\n        for recharge, arrival in enumerate(monster_arrival):\\n            if recharge > arrival:\\n                return recharge\\n        return n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n = len(dist)\\n        monster_arrival = sorted([(dist[i] - 1) // speed[i] for i in range(n)])\\n        for recharge, arrival in enumerate(monster_arrival):\\n            if recharge > arrival:\\n                return recharge\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799654,
                "title": "python-greedy-approach-using-sorting-explained",
                "content": "# Intuition\\nFind the times and sort them. Keep track of the current time of the charge and when curr time is greater than or equal to a monster\\'s time return that index\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        #Find the times the mosters reach city and sort them\\n        times = sorted([dist[i] / speed[i] for i in range(len(dist))])\\n        curr_time = 0\\n        idx = 0\\n        while idx != len(dist):\\n            if times[idx] <= curr_time:\\n                return idx\\n            idx += 1\\n            curr_time += 1\\n        return len(dist)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        #Find the times the mosters reach city and sort them\\n        times = sorted([dist[i] / speed[i] for i in range(len(dist))])\\n        curr_time = 0\\n        idx = 0\\n        while idx != len(dist):\\n            if times[idx] <= curr_time:\\n                return idx\\n            idx += 1\\n            curr_time += 1\\n        return len(dist)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785109,
                "title": "80-faster-c-solution-with-explanation-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Monster to be eliminated, BEFORE it reaches the city\\n\\nclass Solution\\n{\\npublic:\\n    int eliminateMaximum(vector<int> &dist, vector<int> &speed)\\n    {\\n        int n = dist.size();\\n\\n        vector<double> mins(n); // time it will take each monster to reach.\\n\\n        for (int i = 0; i < n; i++)\\n            mins[i] = (double(dist[i]) / double(speed[i]));\\n\\n        sort(mins.begin(), mins.end());\\n\\n        // first monster killed immediately and one min taken already to charge again\\n\\n        int minspassed = 1; // minutes passed = no. of recharges = no. of monsters eliminated\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (minspassed < mins[i])\\n                minspassed++;\\n\\n            else\\n                return minspassed;\\n        }\\n\\n        return n;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Monster to be eliminated, BEFORE it reaches the city\\n\\nclass Solution\\n{\\npublic:\\n    int eliminateMaximum(vector<int> &dist, vector<int> &speed)\\n    {\\n        int n = dist.size();\\n\\n        vector<double> mins(n); // time it will take each monster to reach.\\n\\n        for (int i = 0; i < n; i++)\\n            mins[i] = (double(dist[i]) / double(speed[i]));\\n\\n        sort(mins.begin(), mins.end());\\n\\n        // first monster killed immediately and one min taken already to charge again\\n\\n        int minspassed = 1; // minutes passed = no. of recharges = no. of monsters eliminated\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (minspassed < mins[i])\\n                minspassed++;\\n\\n            else\\n                return minspassed;\\n        }\\n\\n        return n;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762363,
                "title": "c-easy-self-explanatory-time-array",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<double> time;\\n        for(int i=0; i<n; i++)\\n            time.push_back(((double)dist[i])/((double)speed[i]));\\n        \\n        sort(time.begin(), time.end());\\n        int count=0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<time[i]<<\" \";\\n            if(time[i]>i)\\n                count++;\\n            else \\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<double> time;\\n        for(int i=0; i<n; i++)\\n            time.push_back(((double)dist[i])/((double)speed[i]));\\n        \\n        sort(time.begin(), time.end());\\n        int count=0;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<time[i]<<\" \";\\n            if(time[i]>i)\\n                count++;\\n            else \\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3742908,
                "title": "greedy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        ret = 0\\n        tmp = [dist[i]/speed[i] for i in range(len(dist))]\\n        arrive = sorted(tmp, reverse=False)\\n        minute = 0\\n        ## Always eliminate the monster that arrives the fastest\\n        while arrive:\\n            first = arrive.pop(0) - minute\\n            if first <= 0: break\\n            ret += 1\\n            minute += 1\\n        if ret == 0: ret = 1\\n        return ret\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        ret = 0\\n        tmp = [dist[i]/speed[i] for i in range(len(dist))]\\n        arrive = sorted(tmp, reverse=False)\\n        minute = 0\\n        ## Always eliminate the monster that arrives the fastest\\n        while arrive:\\n            first = arrive.pop(0) - minute\\n            if first <= 0: break\\n            ret += 1\\n            minute += 1\\n        if ret == 0: ret = 1\\n        return ret\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742907,
                "title": "greedy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        ret = 0\\n        tmp = [dist[i]/speed[i] for i in range(len(dist))]\\n        arrive = sorted(tmp, reverse=False)\\n        minute = 0\\n        ## Always eliminate the monster that arrives the fastest\\n        while arrive:\\n            first = arrive.pop(0) - minute\\n            if first <= 0: break\\n            ret += 1\\n            minute += 1\\n        if ret == 0: ret = 1\\n        return ret\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        ret = 0\\n        tmp = [dist[i]/speed[i] for i in range(len(dist))]\\n        arrive = sorted(tmp, reverse=False)\\n        minute = 0\\n        ## Always eliminate the monster that arrives the fastest\\n        while arrive:\\n            first = arrive.pop(0) - minute\\n            if first <= 0: break\\n            ret += 1\\n            minute += 1\\n        if ret == 0: ret = 1\\n        return ret\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739682,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        double time [] = new double [dist.length];\\n        for(int i=0; i<dist.length; i++){\\n            time[i] =(double) dist[i]/speed[i];\\n        }\\n        Arrays.sort(time);\\n        for(int i=0; i<dist.length; i++){\\n            if(time[i] <= (double)i) return i;\\n        }\\n        return dist.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        double time [] = new double [dist.length];\\n        for(int i=0; i<dist.length; i++){\\n            time[i] =(double) dist[i]/speed[i];\\n        }\\n        Arrays.sort(time);\\n        for(int i=0; i<dist.length; i++){\\n            if(time[i] <= (double)i) return i;\\n        }\\n        return dist.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738077,
                "title": "memory-beats-100-easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def eliminateMaximum(self, dist, speed):\\n        x=[]\\n        for i in range(len(dist)):\\n            if dist[i]%speed[i]==0:\\n                x.append(dist[i]//speed[i])\\n            else:\\n                x.append((dist[i]//speed[i])+1)\\n        x.sort()\\n        c=0\\n        while len(x)!=1:\\n            x.pop(0)\\n            c+=1\\n            if x[0]-c==0:\\n                return c\\n        return c+1       \\n\\n\\n\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def eliminateMaximum(self, dist, speed):\\n        x=[]\\n        for i in range(len(dist)):\\n            if dist[i]%speed[i]==0:\\n                x.append(dist[i]//speed[i])\\n            else:\\n                x.append((dist[i]//speed[i])+1)\\n        x.sort()\\n        c=0\\n        while len(x)!=1:\\n            x.pop(0)\\n            c+=1\\n            if x[0]-c==0:\\n                return c\\n        return c+1       \\n\\n\\n\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694735,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n        n = len(dist)\\n        minReach = []\\n        \\n        for d,s in zip(dist,speed):\\n            minReach += [math.ceil(d/s)] # physics dist/speed = velocity \\n        \\n        minReach.sort()\\n        \\n        for i in range(n):\\n            if minReach[i]<=i:\\n                return i if i!=0 else 1 # it can atleast get to 1\\n        \\n        return n\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n        n = len(dist)\\n        minReach = []\\n        \\n        for d,s in zip(dist,speed):\\n            minReach += [math.ceil(d/s)] # physics dist/speed = velocity \\n        \\n        minReach.sort()\\n        \\n        for i in range(n):\\n            if minReach[i]<=i:\\n                return i if i!=0 else 1 # it can atleast get to 1\\n        \\n        return n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693115,
                "title": "o-n-log-n-solution-different-from-the-solns-at-the-top-with-line-by-line-explaination",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are calculating the time at which the monsters would reach the city.\\nThat is why we are sorting the time array so we target the monsters who will be arriving early.\\n\\ntime[0] = 0 means we will kill the first monster at time = 0 as gun is already loaded in the beginning.\\n\\nWe need time[i-1] + 1 minutes to kill the next monster. Although it has been provided that we cannot kill the monster when the reloading of gun and arrival of monster happens at the same time. That is why no \"=\" sign is there in conditon if(time[i-1] + 1 < time[i])\\n\\nIf the condition holds true we can kill the monster or else the city gets invaded and we break the loop and return answer.\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = dist.size();\\n        vector<double> time(n);\\n\\n        for(int i=0; i<n; i++) {\\n            time[i] = dist[i]/(double)speed[i];\\n        }\\n\\n        sort(time.begin(), time.end());\\n\\n        int ans = 1;\\n        time[0] = 0;\\n        for(int i=1; i<n; i++) {\\n            if(time[i-1] + 1 < time[i]) {\\n                ans++;\\n                time[i] = time[i-1] + 1;\\n            }\\n            else break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n = dist.size();\\n        vector<double> time(n);\\n\\n        for(int i=0; i<n; i++) {\\n            time[i] = dist[i]/(double)speed[i];\\n        }\\n\\n        sort(time.begin(), time.end());\\n\\n        int ans = 1;\\n        time[0] = 0;\\n        for(int i=1; i<n; i++) {\\n            if(time[i-1] + 1 < time[i]) {\\n                ans++;\\n                time[i] = time[i-1] + 1;\\n            }\\n            else break;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678867,
                "title": "very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n{\\n\\tint sz = dist.size(), killed = 0;\\n\\t\\tvector<int> arrival_time(sz);\\n\\n\\t\\tfor (int i = 0; i < sz; i++) {\\n\\t\\t\\tif (dist[i] % speed[i] == 0)\\n\\t\\t\\t\\tarrival_time[i] = dist[i] / speed[i];\\n\\t\\t\\telse\\n\\t\\t\\t\\tarrival_time[i] = dist[i] / speed[i] + 1;\\n\\t\\t}\\n\\n\\t\\tsort(arrival_time.begin(), arrival_time.end());\\n\\t\\tfor (int i = 0; i < sz && i < arrival_time[i]; i++)\\n\\t\\t\\tkilled+=1;\\n\\t\\treturn killed;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n{\\n\\tint sz = dist.size(), killed = 0;\\n\\t\\tvector<int> arrival_time(sz);\\n\\n\\t\\tfor (int i = 0; i < sz; i++) {\\n\\t\\t\\tif (dist[i] % speed[i] == 0)\\n\\t\\t\\t\\tarrival_time[i] = dist[i] / speed[i];\\n\\t\\t\\telse\\n\\t\\t\\t\\tarrival_time[i] = dist[i] / speed[i] + 1;\\n\\t\\t}\\n\\n\\t\\tsort(arrival_time.begin(), arrival_time.end());\\n\\t\\tfor (int i = 0; i < sz && i < arrival_time[i]; i++)\\n\\t\\t\\tkilled+=1;\\n\\t\\treturn killed;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678841,
                "title": "solution-is-very-simole",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n{\\n\\tint sz = dist.size(), killed = 0;\\n\\t\\tvector<int> arrival_time(sz);\\n\\n\\t\\tfor (int i = 0; i < sz; i++) {\\n\\t\\t\\tif (dist[i] % speed[i] == 0)\\n\\t\\t\\t\\tarrival_time[i] = dist[i] / speed[i];\\n\\t\\t\\telse\\n\\t\\t\\t\\tarrival_time[i] = dist[i] / speed[i] + 1;\\n\\t\\t}\\n\\n\\t\\tsort(arrival_time.begin(), arrival_time.end());\\n\\t\\tfor (int i = 0; i < sz && i < arrival_time[i]; i++)\\n\\t\\t\\tkilled+=1;\\n\\t\\treturn killed;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n{\\n\\tint sz = dist.size(), killed = 0;\\n\\t\\tvector<int> arrival_time(sz);\\n\\n\\t\\tfor (int i = 0; i < sz; i++) {\\n\\t\\t\\tif (dist[i] % speed[i] == 0)\\n\\t\\t\\t\\tarrival_time[i] = dist[i] / speed[i];\\n\\t\\t\\telse\\n\\t\\t\\t\\tarrival_time[i] = dist[i] / speed[i] + 1;\\n\\t\\t}\\n\\n\\t\\tsort(arrival_time.begin(), arrival_time.end());\\n\\t\\tfor (int i = 0; i < sz && i < arrival_time[i]; i++)\\n\\t\\t\\tkilled+=1;\\n\\t\\treturn killed;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616659,
                "title": "c-easy-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   Find the time array of all the monster to reach city.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   Just find the time of each monster from their initial position to the city by distance/speed. And now just calculate that you can kill that monster in that time or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<float> time;\\n        for(int i=0; i<dist.size(); i++){\\n            float d=dist[i], s=speed[i];\\n            float t=(d/s);\\n            time.push_back(t);\\n        }\\n        sort(time.begin(),time.end());\\n        int res=0;\\n        float t=0;\\n        for(int i=0; i<time.size(); i++){\\n            if(t>=time[i]){\\n                break;\\n            }\\n            t++;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<float> time;\\n        for(int i=0; i<dist.size(); i++){\\n            float d=dist[i], s=speed[i];\\n            float t=(d/s);\\n            time.push_back(t);\\n        }\\n        sort(time.begin(),time.end());\\n        int res=0;\\n        float t=0;\\n        for(int i=0; i<time.size(); i++){\\n            if(t>=time[i]){\\n                break;\\n            }\\n            t++;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613858,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n = len(dist)\\n        res = 1\\n        time = []\\n        for i in range(n):\\n            time.append(dist[i]/speed[i])\\n        time.sort()\\n     \\n        for i in range(1, n):\\n            if i >= time[i]:\\n                return res\\n            else:\\n                res += 1  \\n\\n        return n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n = len(dist)\\n        res = 1\\n        time = []\\n        for i in range(n):\\n            time.append(dist[i]/speed[i])\\n        time.sort()\\n     \\n        for i in range(1, n):\\n            if i >= time[i]:\\n                return res\\n            else:\\n                res += 1  \\n\\n        return n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573262,
                "title": "simple-java-solution-with-division-and-sorting",
                "content": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double[] arr = new double[n];\\n        for (int i = 0;i < arr.length;i++) {\\n            arr[i] = (double)((double)dist[i] / (double)speed[i]);\\n        }\\n        Arrays.sort(arr);\\n        int currTime = 0;\\n        int cnt = 0;\\n        for (int i = 0;i < n;i++) {\\n            if (arr[i] <= currTime) {\\n                break;\\n            }\\n            cnt++;\\n            currTime += 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double[] arr = new double[n];\\n        for (int i = 0;i < arr.length;i++) {\\n            arr[i] = (double)((double)dist[i] / (double)speed[i]);\\n        }\\n        Arrays.sort(arr);\\n        int currTime = 0;\\n        int cnt = 0;\\n        for (int i = 0;i < n;i++) {\\n            if (arr[i] <= currTime) {\\n                break;\\n            }\\n            cnt++;\\n            currTime += 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570794,
                "title": "monster-elimination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n    {\\n        vector<float> time;\\n        int count = 1;\\n        for (int i = 0; i < dist.size(); i++)\\n        {\\n            time.push_back(float(dist[i])/float(speed[i]));\\n        }\\n        sort(time.begin(),time.end());\\n        if(dist.size() > 1)\\n        {\\n            for (int i = 1; i < dist.size(); i++)\\n            {   \\n                if(((time[i] - i) <= 0))\\n                {\\n                    return count; \\n                }  \\n                if (((time[i-1] - i) == (time[i]-i)))\\n                {\\n                    count++;         \\n                }\\n                else\\n                {\\n                    count++;\\n                }                \\n                cout << \"i = \" << i << \" time = \" << time[i]-i << \" count = \"<< count<< endl;\\n            }\\n        }\\n\\n        return count;       \\n    }\\n};      \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n    {\\n        vector<float> time;\\n        int count = 1;\\n        for (int i = 0; i < dist.size(); i++)\\n        {\\n            time.push_back(float(dist[i])/float(speed[i]));\\n        }\\n        sort(time.begin(),time.end());\\n        if(dist.size() > 1)\\n        {\\n            for (int i = 1; i < dist.size(); i++)\\n            {   \\n                if(((time[i] - i) <= 0))\\n                {\\n                    return count; \\n                }  \\n                if (((time[i-1] - i) == (time[i]-i)))\\n                {\\n                    count++;         \\n                }\\n                else\\n                {\\n                    count++;\\n                }                \\n                cout << \"i = \" << i << \" time = \" << time[i]-i << \" count = \"<< count<< endl;\\n            }\\n        }\\n\\n        return count;       \\n    }\\n};      \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3535347,
                "title": "python-group-and-sort",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        newArr = []\\n        for a,b in zip(dist,speed):\\n            newArr.append(math.ceil(a/b))\\n        \\n        newArr.sort()\\n    \\n        for i in range(len(newArr)):\\n            if newArr[i] <= i:\\n                return i\\n        \\n        return len(newArr)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        newArr = []\\n        for a,b in zip(dist,speed):\\n            newArr.append(math.ceil(a/b))\\n        \\n        newArr.sort()\\n    \\n        for i in range(len(newArr)):\\n            if newArr[i] <= i:\\n                return i\\n        \\n        return len(newArr)",
                "codeTag": "Java"
            },
            {
                "id": 3492478,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int ans = 0, t =  0;\\n        double[] time = new double[dist.length];\\n        for(int i=0; i<dist.length; i++)\\n            time[i] = (double)dist[i]/(double)speed[i];\\n        Arrays.sort(time);\\n        for(double a: time){\\n            if(a<=t)\\n                break;\\n            else{\\n                ans++;\\n                t++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int ans = 0, t =  0;\\n        double[] time = new double[dist.length];\\n        for(int i=0; i<dist.length; i++)\\n            time[i] = (double)dist[i]/(double)speed[i];\\n        Arrays.sort(time);\\n        for(double a: time){\\n            if(a<=t)\\n                break;\\n            else{\\n                ans++;\\n                t++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490511,
                "title": "beats-100-simple-solution-explained-javascript-typescript",
                "content": "# Intuition\\nThe key to solve this problem beating 100% is to calculate how many rounds it will take to end in the beginning and build the solution around this information.\\n\\n# Approach\\n1 - We first calculate how many rounds it will take to end, which is `distance / speed`, and sort it.\\n\\n2- Based on this sorted array, we can iterate over it using `i` as rounds. \\nThe amount of monsters we manage to kill is equal to how far we can get in this array or how many rounds we survived basically.\\n\\n3 - In case we can kill them all, we just return the size of the initial `dist` array.\\n\\n# Complexity\\n- Time complexity: I believe it\\'s $$O(nlogn)$$\\n\\n\\n# Code\\n```\\nfunction eliminateMaximum(dist: number[], speed: number[]): number {\\n    // calculate the number of rounds it will take to end for each case\\n    // sort and check until where we can get in the array\\n    const roundsToEnd = [];\\n    for (let i = 0; i < dist.length; i++) {\\n        roundsToEnd[i] = Math.ceil(dist[i] / speed[i]); // round up to finish in the next round\\n    }\\n    roundsToEnd.sort(function(a,b){return a-b});\\n\\n    for (let i = 0; i < roundsToEnd.length; i++) {\\n        if (roundsToEnd[i] <= i) { // if we cant get to the position in i rounds, its over\\n            return i;\\n        }\\n    }\\n    return dist.length;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction eliminateMaximum(dist: number[], speed: number[]): number {\\n    // calculate the number of rounds it will take to end for each case\\n    // sort and check until where we can get in the array\\n    const roundsToEnd = [];\\n    for (let i = 0; i < dist.length; i++) {\\n        roundsToEnd[i] = Math.ceil(dist[i] / speed[i]); // round up to finish in the next round\\n    }\\n    roundsToEnd.sort(function(a,b){return a-b});\\n\\n    for (let i = 0; i < roundsToEnd.length; i++) {\\n        if (roundsToEnd[i] <= i) { // if we cant get to the position in i rounds, its over\\n            return i;\\n        }\\n    }\\n    return dist.length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444880,
                "title": "python3-solution-sorting",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n        n=len(dist)\\n        new=sorted(dist[i]/speed[i] for i in range(n))\\n        \\n        time=0\\n        count=1\\n        \\n        for t in new[1:]:\\n            time+=1\\n            if t<=time:\\n                return count\\n            \\n            count+=1\\n        \\n        return count\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        \\n        n=len(dist)\\n        new=sorted(dist[i]/speed[i] for i in range(n))\\n        \\n        time=0\\n        count=1\\n        \\n        for t in new[1:]:\\n            time+=1\\n            if t<=time:\\n                return count\\n            \\n            count+=1\\n        \\n        return count\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396416,
                "title": "c-code-for-beginners-basic-physics-speed-time-easy-to-understand-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> &P1, pair<int,int> &P2){\\n        /* BASIC PHYSICS=> SPEED = DISTANCE/TIME\\n           So, TIME = DISTANCE/SPEED\\n           This means you need to annihilate the monster that is arriving first, i.e in shortest time\\n        */\\n        double time1=(1.0 * P1.first)/(1.0 * P1.second);\\n        double time2=(1.0 * P2.first)/(1.0 * P2.second);\\n        return time1<time2;\\n    }\\n    \\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        \\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            vec.push_back({dist[i],speed[i]});\\n        }\\n        \\n        sort(vec.begin(),vec.end(),cmp);\\n\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            int distance=vec[i].first-(vec[i].second*i);\\n            if(distance<=0){\\n                break;\\n            }\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> &P1, pair<int,int> &P2){\\n        /* BASIC PHYSICS=> SPEED = DISTANCE/TIME\\n           So, TIME = DISTANCE/SPEED\\n           This means you need to annihilate the monster that is arriving first, i.e in shortest time\\n        */\\n        double time1=(1.0 * P1.first)/(1.0 * P1.second);\\n        double time2=(1.0 * P2.first)/(1.0 * P2.second);\\n        return time1<time2;\\n    }\\n    \\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        \\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            vec.push_back({dist[i],speed[i]});\\n        }\\n        \\n        sort(vec.begin(),vec.end(),cmp);\\n\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            int distance=vec[i].first-(vec[i].second*i);\\n            if(distance<=0){\\n                break;\\n            }\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372895,
                "title": "easy-solution-greedy-c-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this \\nproblem. -->\\n\\nFind out time to reach and sort based on that and then process \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double>res; \\n        int n = dist.size(); \\n        for(int i=0 ;i<n ;i++)\\n        {\\n            res.push_back(dist[i]*1.0/speed[i]); \\n\\n        }\\n        sort(res.begin(),res.end()); \\n        int tm = 0 ;\\n        int ans = 0 ; \\n        for(int i =0 ;i<n ;i++)\\n        {\\n            if(res[i]>tm)\\n            {\\n                ans++; \\n                tm++; \\n            }\\n            else break; \\n        }\\n        return ans ;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double>res; \\n        int n = dist.size(); \\n        for(int i=0 ;i<n ;i++)\\n        {\\n            res.push_back(dist[i]*1.0/speed[i]); \\n\\n        }\\n        sort(res.begin(),res.end()); \\n        int tm = 0 ;\\n        int ans = 0 ; \\n        for(int i =0 ;i<n ;i++)\\n        {\\n            if(res[i]>tm)\\n            {\\n                ans++; \\n                tm++; \\n            }\\n            else break; \\n        }\\n        return ans ;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343247,
                "title": "eliminate-maximum-number-of-monsters-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        count=0\\n        t=[]\\n        for i, j in zip(dist,speed):\\n            t.append(i/j)\\n        t.sort()\\n        for n in range(len(dist)):\\n            if t[n] > n:\\n                count += 1\\n            else:\\n                break\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        count=0\\n        t=[]\\n        for i, j in zip(dist,speed):\\n            t.append(i/j)\\n        t.sort()\\n        for n in range(len(dist)):\\n            if t[n] > n:\\n                count += 1\\n            else:\\n                break\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321213,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n -->\\n1.Use time=distance/speed concept \\n2.As I  know the time,then use python build-in function sort()\\nto sort the time \\n3. use while loop to control the time\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n=len(dist)\\n        time=[]\\n\\n        for i in range(n):\\n            time.append(dist[i]/speed[i])\\n\\n        time.sort()\\n        print(time)\\n        t=0\\n       \\n        while t<n:\\n            if time[t]<=t:\\n                return t\\n            else:\\n                t+=1\\n            \\n        return n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n=len(dist)\\n        time=[]\\n\\n        for i in range(n):\\n            time.append(dist[i]/speed[i])\\n\\n        time.sort()\\n        print(time)\\n        t=0\\n       \\n        while t<n:\\n            if time[t]<=t:\\n                return t\\n            else:\\n                t+=1\\n            \\n        return n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315938,
                "title": "eliminate-maximum-number-of-monsters-rust-implementation-using-sort-and-greedy-algorithm-chatgpt",
                "content": "# Intuition\\nGiven the arrays `dist` and `speed`, we need to find the maximum number of distances a person can travel, given that the `i-th` person has a speed of `speed[i]`.\\n\\nTo solve this problem, we can sort the distance array `dist` and calculate the time required to reach each point in the sorted `dist` array for each person using their respective speed. Then we can check if the person can reach the `i-th` point before or at the same time as the time required to reach the `i-th` point. If yes, then we can eliminate this point from further consideration, and move to the next point in the `dist` array.\\n\\n# Approach\\n1. Create a vector `times` to store the time required to reach each point in the sorted `dist` array for each person using their respective speed.\\n2. Sort the `dist` array in ascending order.\\n3. Loop through each point in the sorted `dist` array:\\n    1. Find the number of persons who can reach this point before or at the same time as the time required to reach this point, by counting the number of times in the `times` vector that are less than or equal to the time required to reach this point.\\n    2. If the number of persons who can reach this point before or at the same time as the time required to reach this point is greater than or equal to the number of points that have been eliminated so far, then eliminate this point and increment the count of eliminated points.\\n    3. If the number of points eliminated so far is equal to the length of the `dist` array, then we have eliminated all the points, so return the count of eliminated points.\\n4. If we have not eliminated all the points, then return the count of eliminated points.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n), where n is the length of the `dist` array. This is because we are sorting the `dist` array, which takes O(n log n) time, and then looping through the `dist` array and the `times` vector, which takes O(n) time.\\n\\n- Space complexity:\\nO(n), where n is the length of the `dist` array. This is because we are creating a vector `times` of size n to store the time required to reach each point in the sorted `dist` array for each person.\\n\\n# Code\\n```\\nuse std::cmp::min;\\n\\nimpl Solution {\\n    pub fn eliminate_maximum(dist: Vec<i32>, speed: Vec<i32>) -> i32 {\\n        let mut time_to_reach = Vec::new();\\n        for i in 0..dist.len() {\\n            let time = (dist[i] - 1) / speed[i] + 1;\\n            time_to_reach.push(time);\\n        }\\n        time_to_reach.sort();\\n        let mut eliminated = 0;\\n        for i in 0..time_to_reach.len() {\\n            if time_to_reach[i] <= i as i32 {\\n                break;\\n            }\\n            eliminated += 1;\\n        }\\n        eliminated\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nuse std::cmp::min;\\n\\nimpl Solution {\\n    pub fn eliminate_maximum(dist: Vec<i32>, speed: Vec<i32>) -> i32 {\\n        let mut time_to_reach = Vec::new();\\n        for i in 0..dist.len() {\\n            let time = (dist[i] - 1) / speed[i] + 1;\\n            time_to_reach.push(time);\\n        }\\n        time_to_reach.sort();\\n        let mut eliminated = 0;\\n        for i in 0..time_to_reach.len() {\\n            if time_to_reach[i] <= i as i32 {\\n                break;\\n            }\\n            eliminated += 1;\\n        }\\n        eliminated\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3295788,
                "title": "c-simple-code-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int>v(n);\\n        for(int i=0;i<n;i++)\\n        v[i]=ceil(float(dist[i])/float(speed[i]));\\n        sort(v.begin(),v.end());\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n           if(v[i]-i<=0)return ans;\\n           ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=dist.size();\\n        vector<int>v(n);\\n        for(int i=0;i<n;i++)\\n        v[i]=ceil(float(dist[i])/float(speed[i]));\\n        sort(v.begin(),v.end());\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n           if(v[i]-i<=0)return ans;\\n           ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281416,
                "title": "very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n\\n        vector<double>q;\\n        for(int i=0;i<dist.size();i++){\\n            q.push_back((double)dist[i]/(double)speed[i]);\\n        } \\n        sort(q.begin(),q.end());\\n        int t=0;    \\n        int ans=0;   \\n        for(auto a:q){\\n            if(a<=t){\\n                break;\\n            }\\n            else{\\n                ans++;\\n                t++;\\n            }\\n        }\\n        return ans;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n\\n        vector<double>q;\\n        for(int i=0;i<dist.size();i++){\\n            q.push_back((double)dist[i]/(double)speed[i]);\\n        } \\n        sort(q.begin(),q.end());\\n        int t=0;    \\n        int ans=0;   \\n        for(auto a:q){\\n            if(a<=t){\\n                break;\\n            }\\n            else{\\n                ans++;\\n                t++;\\n            }\\n        }\\n        return ans;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242682,
                "title": "python-solution-sort-by-time-to-city-and-then-simulate",
                "content": "# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n\\n        time_to_city = []\\n        for i in range(0, len(dist)):\\n            distance = dist[i]\\n            velocity = speed[i]\\n            time_to_city.append(distance/velocity)\\n        \\n        time_to_city.sort()\\n\\n        k = 0\\n        time = 0\\n        while k < len(dist):\\n            if time_to_city[k] > time:\\n                time += 1\\n                k += 1\\n            else:\\n                return k\\n        return k\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n\\n        time_to_city = []\\n        for i in range(0, len(dist)):\\n            distance = dist[i]\\n            velocity = speed[i]\\n            time_to_city.append(distance/velocity)\\n        \\n        time_to_city.sort()\\n\\n        k = 0\\n        time = 0\\n        while k < len(dist):\\n            if time_to_city[k] > time:\\n                time += 1\\n                k += 1\\n            else:\\n                return k\\n        return k\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230216,
                "title": "98-89-python",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution():\\n    def eliminateMaximum(self, dists, speeds):\\n        arrives = [dist/speed for dist, speed in zip(dists, speeds)]\\n        arrives.sort()\\n        for minute, arrive in enumerate(arrives):\\n            if arrive-minute <= 0:\\n                return minute\\n        return minute+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution():\\n    def eliminateMaximum(self, dists, speeds):\\n        arrives = [dist/speed for dist, speed in zip(dists, speeds)]\\n        arrives.sort()\\n        for minute, arrive in enumerate(arrives):\\n            if arrive-minute <= 0:\\n                return minute\\n        return minute+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220620,
                "title": "c-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& d, vector<int>& s) {\\n        vector<float> w;\\n        for(int i=0;i<d.size();i++)\\n        {\\n         float v=(float)d[i]/s[i];\\n         w.push_back(v);\\n        }\\n        sort(w.begin(),w.end());\\n        int l=0;int c=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            if(w[i]<=c) break;\\n            c++;\\n            l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& d, vector<int>& s) {\\n        vector<float> w;\\n        for(int i=0;i<d.size();i++)\\n        {\\n         float v=(float)d[i]/s[i];\\n         w.push_back(v);\\n        }\\n        sort(w.begin(),w.end());\\n        int l=0;int c=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            if(w[i]<=c) break;\\n            c++;\\n            l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197872,
                "title": "c-greedy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        //greedy, always attack the monster that arrives first \\n        int num = dist.size(); \\n        vector<int> round(num, 0); \\n        for(int i = 0; i < num; i++){\\n            round[i] = (dist[i]/speed[i]);\\n            if (dist[i]%speed[i]!=0) round[i]++;  \\n        }\\n        sort(round.begin(), round.end()); \\n        int time = 0;  \\n        int attack = 0; \\n        while(attack < num){\\n            if (round[attack] - time <= 0) break; //lose \\n            attack++; \\n            time++; \\n        }\\n        return attack; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        //greedy, always attack the monster that arrives first \\n        int num = dist.size(); \\n        vector<int> round(num, 0); \\n        for(int i = 0; i < num; i++){\\n            round[i] = (dist[i]/speed[i]);\\n            if (dist[i]%speed[i]!=0) round[i]++;  \\n        }\\n        sort(round.begin(), round.end()); \\n        int time = 0;  \\n        int attack = 0; \\n        while(attack < num){\\n            if (round[attack] - time <= 0) break; //lose \\n            attack++; \\n            time++; \\n        }\\n        return attack; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197572,
                "title": "essay-understanding-java",
                "content": "\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int ans=0;\\n        double time[]= new double[dist.length];\\n\\n        for(int i=0;i<dist.length;i++)\\n        {\\n            time[i]= (double)dist[i]/speed[i];\\n            System.out.println(time[i]);\\n        }\\n        Arrays.sort(time);\\n        for(int i=0;i<dist.length;i++)\\n        {\\n            if(time[i]-i>0)\\n            {\\n                ans++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int ans=0;\\n        double time[]= new double[dist.length];\\n\\n        for(int i=0;i<dist.length;i++)\\n        {\\n            time[i]= (double)dist[i]/speed[i];\\n            System.out.println(time[i]);\\n        }\\n        Arrays.sort(time);\\n        for(int i=0;i<dist.length;i++)\\n        {\\n            if(time[i]-i>0)\\n            {\\n                ans++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197204,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn eliminate_maximum(dist: Vec<i32>, speed: Vec<i32>) -> i32 {\\n    let n = dist.len();\\n    let mut memo = vec![0;n];\\n    for i in 0..n {\\n      let mut v = dist[i] / speed[i];\\n      if dist[i] % speed[i] != 0 {\\n        v += 1;\\n      }\\n      memo[i] = v;\\n    }\\n\\n    memo.sort();\\n    for i in 1..=n {\\n      if memo[i-1] < (i as i32) {\\n        return (i-1) as i32\\n      }\\n    }\\n    n as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn eliminate_maximum(dist: Vec<i32>, speed: Vec<i32>) -> i32 {\\n    let n = dist.len();\\n    let mut memo = vec![0;n];\\n    for i in 0..n {\\n      let mut v = dist[i] / speed[i];\\n      if dist[i] % speed[i] != 0 {\\n        v += 1;\\n      }\\n      memo[i] = v;\\n    }\\n\\n    memo.sort();\\n    for i in 1..=n {\\n      if memo[i-1] < (i as i32) {\\n        return (i-1) as i32\\n      }\\n    }\\n    n as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3195063,
                "title": "easy-to-understand-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>&d, vector<int>&s) {\\n        int n=d.size();\\n        vector<float>t(n);\\n        for(int i=0;i<n;i++){\\n            t[i]=(float)d[i]/(float)s[i];\\n        }\\n        sort(t.begin(),t.end());\\n        float tm=t[0];\\n        for(int i=1;i<n;i++){\\n            tm+=(t[i]-t[i-1]);\\n            tm--;\\n            if(tm<=0)return i;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>&d, vector<int>&s) {\\n        int n=d.size();\\n        vector<float>t(n);\\n        for(int i=0;i<n;i++){\\n            t[i]=(float)d[i]/(float)s[i];\\n        }\\n        sort(t.begin(),t.end());\\n        float tm=t[0];\\n        for(int i=1;i<n;i++){\\n            tm+=(t[i]-t[i-1]);\\n            tm--;\\n            if(tm<=0)return i;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192409,
                "title": "simple-approach-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = []\\n        ans=0\\n        for i in range(len(dist)):\\n            time.append(dist[i]/speed[i])\\n        \\n        time.sort()\\n        for i in range(len(time)):\\n            if time[i]>i:\\n                ans += 1\\n            else:\\n                break\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = []\\n        ans=0\\n        for i in range(len(dist)):\\n            time.append(dist[i]/speed[i])\\n        \\n        time.sort()\\n        for i in range(len(time)):\\n            if time[i]>i:\\n                ans += 1\\n            else:\\n                break\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154296,
                "title": "c-greedy-approach",
                "content": "\\tint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double,vector<double> ,greater<double>> pq;\\n        int ans = 0;\\n        \\n        if(dist.size() == 0)return 0;\\n        \\n        for(int i = 0; i < dist.size(); i++){\\n            double t = double(dist[i]) /double(speed[i]);\\n            pq.push(t);\\n        }\\n        \\n        int j = 0;\\n        \\n        while(!pq.empty()){\\n            if(pq.top() <= j){\\n                if(ans != 0)return ans;\\n            }\\n            ans++;\\n            pq.pop();\\n            j++;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        priority_queue<double,vector<double> ,greater<double>> pq;\\n        int ans = 0;\\n        \\n        if(dist.size() == 0)return 0;\\n        \\n        for(int i = 0; i < dist.size(); i++){\\n            double t = double(dist[i]) /double(speed[i]);\\n            pq.push(t);\\n        }\\n        \\n        int j = 0;\\n        \\n        while(!pq.empty()){\\n            if(pq.top() <= j){\\n                if(ans != 0)return ans;\\n            }\\n            ans++;\\n            pq.pop();\\n            j++;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3142428,
                "title": "easy-and-fast-python-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: list[int], speed: list[int]) -> int:\\n        count = 0\\n        s = 1\\n        def_indx = 0\\n        danger_list = [dist[i]/speed[i] for i in range(0, len(dist))]\\n        danger_list.sort()\\n        for indx in range(0, len(danger_list)-1):\\n            count += 1\\n            if danger_list[indx]-s <= 0 and danger_list[indx+1]-s <= 0:\\n                return count\\n            else:\\n                def_indx += 1\\n                s += 1\\n        return count + 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: list[int], speed: list[int]) -> int:\\n        count = 0\\n        s = 1\\n        def_indx = 0\\n        danger_list = [dist[i]/speed[i] for i in range(0, len(dist))]\\n        danger_list.sort()\\n        for indx in range(0, len(danger_list)-1):\\n            count += 1\\n            if danger_list[indx]-s <= 0 and danger_list[indx+1]-s <= 0:\\n                return count\\n            else:\\n                def_indx += 1\\n                s += 1\\n        return count + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131731,
                "title": "used-time-to-reach-to-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHave to check wich monster reach us first and kill him\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        timeToReachUs = [(dist[x]/speed[x]) for x in range(len(dist))]\\n        timeToReachUs.sort()\\n        count = 0\\n        for t in range(0,len(timeToReachUs)):\\n            if timeToReachUs[t]>t:\\n                count+=1\\n            else:\\n                break\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        timeToReachUs = [(dist[x]/speed[x]) for x in range(len(dist))]\\n        timeToReachUs.sort()\\n        count = 0\\n        for t in range(0,len(timeToReachUs)):\\n            if timeToReachUs[t]>t:\\n                count+=1\\n            else:\\n                break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081225,
                "title": "python-priority-queue",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist, speed):\\n        heap = []\\n        m = len(dist)\\n        for i in range(m):\\n            heappush(heap, dist[i] / speed[i])\\n        ans, totalTime = 0, 0\\n        while heap:\\n            time = heappop(heap)\\n            time -= totalTime\\n            if time > 0:\\n                ans += 1\\n            else:\\n                break\\n            totalTime += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist, speed):\\n        heap = []\\n        m = len(dist)\\n        for i in range(m):\\n            heappush(heap, dist[i] / speed[i])\\n        ans, totalTime = 0, 0\\n        while heap:\\n            time = heappop(heap)\\n            time -= totalTime\\n            if time > 0:\\n                ans += 1\\n            else:\\n                break\\n            totalTime += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022156,
                "title": "c-heap-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    double time(double d, double s){\\n        return d / s;\\n    }\\n    int eliminateMaximum(vector<int>& d, vector<int>& s) {\\n        priority_queue<double, vector<double>, greater<double>> q;\\n        double curTime = 0;\\n        int ans = 0;\\n        // if current time is greater than the smallest return ans\\n        // kill the monster that will take the shortest amount of time to come\\n        // increment current time and ans by 1\\n        for (int i = 0; i < d.size(); ++i)\\n            q.push(time(d[i], s[i]));\\n        while (!q.empty()){\\n            double mon = q.top();\\n            q.pop();\\n            if (mon <= curTime) break;\\n            ++curTime, ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double time(double d, double s){\\n        return d / s;\\n    }\\n    int eliminateMaximum(vector<int>& d, vector<int>& s) {\\n        priority_queue<double, vector<double>, greater<double>> q;\\n        double curTime = 0;\\n        int ans = 0;\\n        // if current time is greater than the smallest return ans\\n        // kill the monster that will take the shortest amount of time to come\\n        // increment current time and ans by 1\\n        for (int i = 0; i < d.size(); ++i)\\n            q.push(time(d[i], s[i]));\\n        while (!q.empty()){\\n            double mon = q.top();\\n            q.pop();\\n            if (mon <= curTime) break;\\n            ++curTime, ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007774,
                "title": "python-greedy-o-nlogn",
                "content": "# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        arrivals = [d/s for d, s in zip(dist, speed)]\\n        arrivals.sort(reverse = True)\\n        res = 0\\n        for t in range(len(arrivals)):\\n            mt = arrivals.pop()\\n            if t >= mt: break\\n            res += 1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        arrivals = [d/s for d, s in zip(dist, speed)]\\n        arrivals.sort(reverse = True)\\n        res = 0\\n        for t in range(len(arrivals)):\\n            mt = arrivals.pop()\\n            if t >= mt: break\\n            res += 1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975662,
                "title": "python-2-line-solution",
                "content": "```\\ndef eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n\\ttime = sorted([ceil(d/s) for d, s in zip(dist, speed)])\\n\\treturn min([i for i in range(len(time)) if i==time[i]] or [len(time)])\\n```",
                "solutionTags": [],
                "code": "```\\ndef eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n\\ttime = sorted([ceil(d/s) for d, s in zip(dist, speed)])\\n\\treturn min([i for i in range(len(time)) if i==time[i]] or [len(time)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2970848,
                "title": "c-find-time-foe-each-monster-sort-it-easy-can-use-priority-queue-also",
                "content": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double> time;\\n        int n=dist.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            time.push_back((1.0*dist[i])/(1.0*speed[i]));\\n        }\\n        sort(time.begin(),time.end());\\n        int minutes=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(minutes>=time[i])\\n            {\\n                return i;\\n            }\\n            minutes++;\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\nAN UPVOTE FROM YOUR SIDE IS HIGHLY APPRECIATED :)",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double> time;\\n        int n=dist.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            time.push_back((1.0*dist[i])/(1.0*speed[i]));\\n        }\\n        sort(time.begin(),time.end());\\n        int minutes=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(minutes>=time[i])\\n            {\\n                return i;\\n            }\\n            minutes++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966847,
                "title": "easy-java-solution-with-instructions-nlong-n",
                "content": "\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        \\n    //  we will use priorityQueue to prioritize monsters on the basis of time they reach to the city\\n    // so the monster which takes less time, will be on the top of the priorityQueue;\\n        PriorityQueue<Double> pq=new PriorityQueue<>((a,b)->{\\n         \\n        if(a<b) return -1;\\n\\n        return 1;\\n\\n        });\\n       int n=dist.length;\\n\\n        for(int i=0;i<n;i++){\\n       //adding time to reach the city of the monsters in priorityQueue \\n           pq.add(dist[i]*1.0/speed[i]);\\n        }\\n\\n       // loaded is time at the started when the gun is loaded basically\\n        double loaded=0;\\n        int kill=0;\\n        while(pq.size()>0){\\n            double mons=pq.remove();\\n            \\n        //if monster arrives before or at loading time we will lose and return previously kills\\n            if(mons<=loaded) return kill;\\n\\n        // increases value of loading time and no of kills by 1 since we have killed a monster    \\n            loaded++;\\n            kill++;\\n        }\\n        return kill;\\n\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        \\n    //  we will use priorityQueue to prioritize monsters on the basis of time they reach to the city\\n    // so the monster which takes less time, will be on the top of the priorityQueue;\\n        PriorityQueue<Double> pq=new PriorityQueue<>((a,b)->{\\n         \\n        if(a<b) return -1;\\n\\n        return 1;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2961127,
                "title": "java-pq",
                "content": "Record the number of times that the monsters need to reach the player in Priority Queue.\\n\\n# Code\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        if(dist.length == 0){\\n            return 0;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> Integer.compare(a, b));\\n        int count = 1;\\n        int output = 1;\\n        for(int i = 0; i < dist.length; i++){\\n            int temp = 0;\\n            if(dist[i] % speed[i] == 0){\\n                temp = dist[i] / speed[i];\\n            }else{\\n                temp = dist[i] / speed[i] + 1;\\n            }\\n            pq.add(temp);\\n        }\\n        pq.poll();\\n        while(!pq.isEmpty()){\\n            int temp = pq.poll();\\n            if(temp <= count){\\n                break;\\n            }\\n            // pq.add(new int[]{temp[0], temp[1]});\\n            count++;\\n            output++;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        if(dist.length == 0){\\n            return 0;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> Integer.compare(a, b));\\n        int count = 1;\\n        int output = 1;\\n        for(int i = 0; i < dist.length; i++){\\n            int temp = 0;\\n            if(dist[i] % speed[i] == 0){\\n                temp = dist[i] / speed[i];\\n            }else{\\n                temp = dist[i] / speed[i] + 1;\\n            }\\n            pq.add(temp);\\n        }\\n        pq.poll();\\n        while(!pq.isEmpty()){\\n            int temp = pq.poll();\\n            if(temp <= count){\\n                break;\\n            }\\n            // pq.add(new int[]{temp[0], temp[1]});\\n            count++;\\n            output++;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931672,
                "title": "intuitive-solution-using-sort",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        minsReach = []\\n        kills = 0\\n        for d, s in zip(dist, speed):\\n            minsReach.append(d/s)\\n        minsReach.sort()\\n        for i in range(len(minsReach)):\\n            if i < minsReach[i]:\\n                kills += 1\\n            else:\\n                break\\n        return kills\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        minsReach = []\\n        kills = 0\\n        for d, s in zip(dist, speed):\\n            minsReach.append(d/s)\\n        minsReach.sort()\\n        for i in range(len(minsReach)):\\n            if i < minsReach[i]:\\n                kills += 1\\n            else:\\n                break\\n        return kills\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907519,
                "title": "java-sort-o-nlogn-complexity",
                "content": "# Intuition\\nAs we know the time will be taken by a monster will be Distance/Speed. So we will calculate the time to be taken to reach the city by each monster.\\n\\n# Approach\\n Calculate the Time taken by each monster to reach the city. Then sort the calculated time array. At last check if the ith index value of time array is less than or equal to index - If yes then return the index. If no such index found then return length of array which means we will kill all monsters.\\n\\n# Complexity\\nTo calculate the time taken by each monster is O(n). \\nTo sort the array will take O(nlogn);\\nand overall complexity will be O(nlogn).\\n\\n- Space complexity:\\nWe are creating array to calulate the time which will be O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        double[] time = new double[dist.length];\\n        for(int i = 0; i < dist.length; i++) {\\n            time[i] = Double.valueOf(dist[i])/Double.valueOf(speed[i]);\\n        }\\n        Arrays.sort(time);\\n        //System.out.println(Arrays.toString(time));\\n        for(int i = 0; i < time.length; i++) {\\n            if(time[i] <= i) {\\n                //System.out.println(i);\\n                return i;\\n            }\\n        }\\n        return dist.length;\\n        //.6, .6, 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        double[] time = new double[dist.length];\\n        for(int i = 0; i < dist.length; i++) {\\n            time[i] = Double.valueOf(dist[i])/Double.valueOf(speed[i]);\\n        }\\n        Arrays.sort(time);\\n        //System.out.println(Arrays.toString(time));\\n        for(int i = 0; i < time.length; i++) {\\n            if(time[i] <= i) {\\n                //System.out.println(i);\\n                return i;\\n            }\\n        }\\n        return dist.length;\\n        //.6, .6, 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907509,
                "title": "easy-and-effective-c-solution-sorting",
                "content": "# Intuition\\nTry to find out time required by each monster to reach the city. \\n\\n# Approach\\nDivide distance by speed to get time required. Arrange the times in an increasing order. Then, if the time is less than or equal to its index it means than more than one monsters have reached the city at same time and hence we lost the game. Count the number of indices before we lost and that\\'s our answer.\\n\\n# Complexity\\n- Time complexity : O(nlogn) \\n\\n- Space complexity : O(1)  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int count=0;\\n        for(int i=0;i<dist.size();i++){\\n            if(dist[i]%speed[i]==0){\\n                dist[i]=(dist[i]/speed[i]);\\n            }\\n            else{\\n                dist[i]=((dist[i]/speed[i])+1);\\n            }\\n        }\\n        sort(dist.begin(),dist.end());\\n        for(int i=0;i<dist.size();i++){\\n            if(dist[i]==i){\\n                break;\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int count=0;\\n        for(int i=0;i<dist.size();i++){\\n            if(dist[i]%speed[i]==0){\\n                dist[i]=(dist[i]/speed[i]);\\n            }\\n            else{\\n                dist[i]=((dist[i]/speed[i])+1);\\n            }\\n        }\\n        sort(dist.begin(),dist.end());\\n        for(int i=0;i<dist.size();i++){\\n            if(dist[i]==i){\\n                break;\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893659,
                "title": "javascript-solution-with-sort",
                "content": "```\\n/**\\n * @param {number[]} dist\\n * @param {number[]} speed\\n * @return {number}\\n */\\nvar eliminateMaximum = function(dist, speed) {\\n    let res = 0;\\n    let len = dist.length;\\n    let map = new Map();\\n    for(let i=0; i<len; i++){\\n        // the last time to eliminate\\n        let a = Math.ceil(dist[i] / speed[i]);\\n        if(map.has(a)){\\n            let c = map.get(a);\\n            c ++;\\n            map.set(a, c);\\n        }else{\\n            map.set(a, 1);\\n        }\\n    }\\n\\n    let keys = Array.from(map.keys());\\n    keys.sort((a, b) => a-b);\\n    // time to eliminate\\n    let t = 0;\\n    for(let i=0; i<keys.length; i++){\\n        let c = map.get(keys[i]);\\n        if(c > keys[i]-t){\\n            res += keys[i]-t;\\n            break;\\n        }else{\\n            res += c;\\n            t += c;\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} dist\\n * @param {number[]} speed\\n * @return {number}\\n */\\nvar eliminateMaximum = function(dist, speed) {\\n    let res = 0;\\n    let len = dist.length;\\n    let map = new Map();\\n    for(let i=0; i<len; i++){\\n        // the last time to eliminate\\n        let a = Math.ceil(dist[i] / speed[i]);\\n        if(map.has(a)){\\n            let c = map.get(a);\\n            c ++;\\n            map.set(a, c);\\n        }else{\\n            map.set(a, 1);\\n        }\\n    }\\n\\n    let keys = Array.from(map.keys());\\n    keys.sort((a, b) => a-b);\\n    // time to eliminate\\n    let t = 0;\\n    for(let i=0; i<keys.length; i++){\\n        let c = map.get(keys[i]);\\n        if(c > keys[i]-t){\\n            res += keys[i]-t;\\n            break;\\n        }else{\\n            res += c;\\n            t += c;\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2893375,
                "title": "eliminate-max-number-of-monsters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity: As we have taken another array So O(n) space.\\n\\n# Code\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int[] time = new int[dist.length];\\n        for(int i = 0;i < dist.length;i++){\\n            time[i] = (dist[i]+speed[i]-1) / speed[i];\\n        }\\n        Arrays.sort(time);\\n        int count = 1;\\n        for(int i = 1;i < dist.length;i++){\\n            if(i >= time[i])\\n            break;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int[] time = new int[dist.length];\\n        for(int i = 0;i < dist.length;i++){\\n            time[i] = (dist[i]+speed[i]-1) / speed[i];\\n        }\\n        Arrays.sort(time);\\n        int count = 1;\\n        for(int i = 1;i < dist.length;i++){\\n            if(i >= time[i])\\n            break;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888647,
                "title": "pythonic-5-lines-fast-t-m-99-7-76",
                "content": "# Intuition / Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the time of arrival for each monster. (dist/speed)\\nSort the list of Estimated Time of Arrivals (eta). \\n\\nticks=   0,   1,   2,   3\\neta = [1.0, 1.5, 1.7, 2.0]\\n\\nTicks is the same as num monsters eliminated since we can eliminate one per tick. \\n\\nThe monster arriving in 1.7 will beat our ticks of 2, so we can\\'t eliminate that one or the ones following it. \\n\\nWe only eliminated 2 monsters\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) for the sorting\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) with one new list, \"eta\"\\n\\n# Code\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        eta =  [dist[i]/speed[i] for i in range(len(dist))]\\n        eta = sorted(eta)\\n        \\n        ticks = 0 # Ticks is both monsters eliminated and clock ticks\\n        while ticks < len(eta) and eta[ticks] > ticks:\\n            ticks += 1\\n        return ticks\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        eta =  [dist[i]/speed[i] for i in range(len(dist))]\\n        eta = sorted(eta)\\n        \\n        ticks = 0 # Ticks is both monsters eliminated and clock ticks\\n        while ticks < len(eta) and eta[ticks] > ticks:\\n            ticks += 1\\n        return ticks\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887614,
                "title": "priority-queue-o-nlogn-heap-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key point of problem is how many minutes each monster has before reaching out to 0. \\n\\nIf the size of N is small, then you can iterate and calculate distances after killing K monsters. If there is any monster that reaches out to 0, then you are being killed while charging a weapon.\\n\\nBut now, the maximum size of N is 10,000. So it takes too long to iterate and calculate every time you kill the monster.(O(N^2))\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe important thing is when distance between you and monster becomes 0. Let\\'s say, the initial distance of a monster is 7 and its the speed is 3. Then it will take 3 minutes to meet you. \\n\\n- After 1 minute, distance becomes 4\\n- After 2 minutes, distance becomes 1\\n- After 3 minutes, distance becomes -2 <- you are killed here.\\n\\nSo, this monster should be killed within 3 monsters because you can kill one monster at the beginning.\\n\\n\\nNow, you can calculate the maximum number of turns each of them should be killed not to be killed.\\n\\n\\n`maximum_turn = (distance + speed - 1) // speed`\\n- If the distance is divided by speed, then distance // speed\\n- If not, then distance // speed + 1 (leftover)\\n\\n\\nYou need to kill the monster from the monster which has the shortest maximum turn. If the current turn is larger than or equal to the maximum turn of it, then you are killed while charging the weapon.\\n\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n = len(dist)\\n        heap = []\\n        heapq.heapify(heap)\\n        for d, s in zip(dist, speed):\\n            v = (d + s - 1) // s\\n            heapq.heappush(heap, v)\\n\\n        ans = 0\\n        while len(heap):\\n            v = heapq.heappop(heap)\\n            if ans < v:\\n                ans += 1\\n            else:\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        n = len(dist)\\n        heap = []\\n        heapq.heapify(heap)\\n        for d, s in zip(dist, speed):\\n            v = (d + s - 1) // s\\n            heapq.heappush(heap, v)\\n\\n        ans = 0\\n        while len(heap):\\n            v = heapq.heappop(heap)\\n            if ans < v:\\n                ans += 1\\n            else:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867568,
                "title": "c-greedy-solution-find-the-time-at-which-monsters-will-reach-the-destination",
                "content": "# Intuition\\nwe will find the time at which monsters will reach the destination, and then we will sort the time at which they all will arrive at the destination, so that we destroy the monster reaching the destination early. And the monsters reaching the destination later will be treated after them so that we get the time to charge the weapon. \\nif the monster reach the destination before the charging of the weapon then we loose and we return the monsters killed till now.\\n\\n# Complexity\\n- Time complexity:\\nO(N log N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<float>time(dist.size());\\n        for(int i = 0; i<dist.size(); i++){\\n            time[i] = ceil(dist[i]/float(speed[i]));\\n        }\\n\\n        sort(time.begin(), time.end());\\n        for(int i = 1; i<time.size(); i++){\\n            if(time[i]<=i){\\n                return i;\\n            }\\n        }\\n\\n        return dist.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<float>time(dist.size());\\n        for(int i = 0; i<dist.size(); i++){\\n            time[i] = ceil(dist[i]/float(speed[i]));\\n        }\\n\\n        sort(time.begin(), time.end());\\n        for(int i = 1; i<time.size(); i++){\\n            if(time[i]<=i){\\n                return i;\\n            }\\n        }\\n\\n        return dist.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862283,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double [] arr = new double[n];\\n\\n        for(int i = 0; i < n; i++){\\n            double time = (dist[i] * 1.0) / (speed[i] * 1.0);\\n            arr[i] = time;\\n        }\\n\\n        Arrays.sort(arr);\\n        int count = 0, currTime = 0;\\n\\n        for(double time : arr){\\n            if(time <= currTime){\\n                break;\\n            } else {\\n                count++;\\n                currTime++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double [] arr = new double[n];\\n\\n        for(int i = 0; i < n; i++){\\n            double time = (dist[i] * 1.0) / (speed[i] * 1.0);\\n            arr[i] = time;\\n        }\\n\\n        Arrays.sort(arr);\\n        int count = 0, currTime = 0;\\n\\n        for(double time : arr){\\n            if(time <= currTime){\\n                break;\\n            } else {\\n                count++;\\n                currTime++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859849,
                "title": "go-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nimport (\\n\\t\"sort\"\\n)\\n\\nfunc eliminateMaximum(dist []int, speed []int) int {\\n\\tminute := make([]float64, len(dist))\\n\\tfor i := 0; i < len(dist); i++ {\\n\\t\\tminute[i] = float64(dist[i]) / float64(speed[i])\\n\\t}\\n\\n\\tsort.Float64s(minute)\\n\\n\\tres := 0\\n\\tfor i := 0; i < len(dist); i++ {\\n\\t\\tif float64(i) < minute[i] {\\n\\t\\t\\tres++\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"sort\"\\n)\\n\\nfunc eliminateMaximum(dist []int, speed []int) int {\\n\\tminute := make([]float64, len(dist))\\n\\tfor i := 0; i < len(dist); i++ {\\n\\t\\tminute[i] = float64(dist[i]) / float64(speed[i])\\n\\t}\\n\\n\\tsort.Float64s(minute)\\n\\n\\tres := 0\\n\\tfor i := 0; i < len(dist); i++ {\\n\\t\\tif float64(i) < minute[i] {\\n\\t\\t\\tres++\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2817211,
                "title": "easiest-best-solution-in-c",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=speed.size(),ans=0;\\n        vector<double> time(n);\\n        for(int i=0;i<n;i++)\\n            time[i]=(1.0*dist[i])/speed[i];\\n        sort(time.begin(),time.end());\\n        for(int i=0;i<n;i++){\\n            time[i]-=i;\\n            if(time[i]>0)\\n                ans++;\\n            else if(time[i]<=0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        int n=speed.size(),ans=0;\\n        vector<double> time(n);\\n        for(int i=0;i<n;i++)\\n            time[i]=(1.0*dist[i])/speed[i];\\n        sort(time.begin(),time.end());\\n        for(int i=0;i<n;i++){\\n            time[i]-=i;\\n            if(time[i]>0)\\n                ans++;\\n            else if(time[i]<=0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799791,
                "title": "python-4-lines-sort-on-time-to-arrival",
                "content": "```\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        # sort by time to city\\n        for i, t in enumerate(sorted(dist[i]/speed[i] for i in range(len(dist)))):\\n            if i >= t:\\n                return i\\n        return len(dist)\\n```",
                "solutionTags": [],
                "code": "```\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        # sort by time to city\\n        for i, t in enumerate(sorted(dist[i]/speed[i] for i in range(len(dist)))):\\n            if i >= t:\\n                return i\\n        return len(dist)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2790426,
                "title": "c-easy-solution-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>a,pair<int,int>b){\\n        double p=a.first/(float)a.second;\\n        double q=b.first/(float)b.second;\\n        return p<q;\\n    }\\n    int eliminateMaximum(vector<int>& d, vector<int>& s) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++){\\n            v.push_back({d[i],s[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int c=1;\\n        int i=1;\\n        for(int j=1;j<v.size();j++){\\n            if((v[j].first-(v[j].second*i))<=0) break;\\n            i++;\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>a,pair<int,int>b){\\n        double p=a.first/(float)a.second;\\n        double q=b.first/(float)b.second;\\n        return p<q;\\n    }\\n    int eliminateMaximum(vector<int>& d, vector<int>& s) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++){\\n            v.push_back({d[i],s[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int c=1;\\n        int i=1;\\n        for(int j=1;j<v.size();j++){\\n            if((v[j].first-(v[j].second*i))<=0) break;\\n            i++;\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782335,
                "title": "if-current-time-time-it-takes-to-reach-answer-current-time-otherwise-answer-length-of-array",
                "content": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        l=len(dist)\\n        time=list(map(lambda x,y:math.ceil(x/y) , dist,speed))\\n        time.sort()\\n        print(time)\\n        for i in range(len(time)):\\n            if i >= time[i]:\\n                return i\\n        return l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        l=len(dist)\\n        time=list(map(lambda x,y:math.ceil(x/y) , dist,speed))\\n        time.sort()\\n        print(time)\\n        for i in range(len(time)):\\n            if i >= time[i]:\\n                return i\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761567,
                "title": "sort-their-reaching-times-time-o-nlogn-space-o-n",
                "content": "class Solution(object):\\n    def eliminateMaximum(self, dist, speed):\\n        \"\"\"\\n        :type dist: List[int]\\n        :type speed: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(dist)\\n        time_arr = [int(math.ceil(dist[i]/(1.0*speed[i]))) for i in range(n)]\\n        \\n        time_arr.sort()\\n        #print time_arr\\n        #print time_arr\\n        \\n        time = 0\\n        res = 0\\n        \\n        for t in time_arr:\\n            if t <= time:\\n                break\\n            else:\\n                res += 1\\n                time += 1\\n        \\n        return res",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def eliminateMaximum(self, dist, speed):\\n        \"\"\"\\n        :type dist: List[int]\\n        :type speed: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(dist)\\n        time_arr = [int(math.ceil(dist[i]/(1.0*speed[i]))) for i in range(n)]\\n        \\n        time_arr.sort()\\n        #print time_arr\\n        #print time_arr\\n        \\n        time = 0\\n        res = 0\\n        \\n        for t in time_arr:\\n            if t <= time:\\n                break\\n            else:\\n                res += 1\\n                time += 1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2750117,
                "title": "java-solution-calculate-time-of-arrival-sorting",
                "content": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        \\n        int[] time = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int d = dist[i];\\n            int s = speed[i];\\n            \\n            int t = d / s;\\n            if (d % s != 0)\\n                t++;\\n            \\n            time[i] = t;\\n        }\\n        \\n        Arrays.sort(time);\\n        \\n        int result = 0;\\n        while (result < n && result < time[result]) {\\n            result++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        \\n        int[] time = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int d = dist[i];\\n            int s = speed[i];\\n            \\n            int t = d / s;\\n            if (d % s != 0)\\n                t++;\\n            \\n            time[i] = t;\\n        }\\n        \\n        Arrays.sort(time);\\n        \\n        int result = 0;\\n        while (result < n && result < time[result]) {\\n            result++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730968,
                "title": "java-sorting-greedy",
                "content": "class Solution {\\n\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double[] arr = new double[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = ((double) dist[i] / speed[i]); //this array will tell us that at which time i-th monster will reach me\\n        }\\n\\n        Arrays.sort(arr); //sort time because we want to eliminate that monsters first who will reach faster\\n\\n        int c = 0; // count of total monsters eliminated till now\\n        int time = 0; // current time\\n        int ptr = 0; // current monster\\n\\n        while (ptr < n) {\\n            if (arr[ptr] > time) { //if monster is stil away from me eliminate it\\n                ptr++;\\n                c++;\\n            } else { // if monster has arrived so break and return;\\n                break;\\n            }\\n\\n            time++;\\n        }\\n\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int n = dist.length;\\n        double[] arr = new double[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = ((double) dist[i] / speed[i]); //this array will tell us that at which time i-th monster will reach me\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2703215,
                "title": "java-o-n",
                "content": "```\\n\\n\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int tmp[] = new int[dist.length + 1];\\n        for (int i = 0; i < dist.length; i++) {\\n            int timeInMin = (dist[i] - 1) / speed[i] + 1;\\n            if (timeInMin > dist.length) timeInMin = dist.length;\\n            tmp[timeInMin]++;\\n        }\\n        \\n        int count = 0;\\n        for (int i = 0; i < tmp.length; i++) {\\n            count += tmp[i];\\n            if (count > i) return i;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int eliminateMaximum(int[] dist, int[] speed) {\\n        int tmp[] = new int[dist.length + 1];\\n        for (int i = 0; i < dist.length; i++) {\\n            int timeInMin = (dist[i] - 1) / speed[i] + 1;\\n            if (timeInMin > dist.length) timeInMin = dist.length;\\n            tmp[timeInMin]++;\\n        }\\n        \\n        int count = 0;\\n        for (int i = 0; i < tmp.length; i++) {\\n            count += tmp[i];\\n            if (count > i) return i;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695272,
                "title": "o-nlogn-c-solution",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n    {\\n       int time = 1;\\n       int ans = 1;\\n       vector<double> t;\\n       for(int i=0; i<dist.size(); i++)\\n       {\\n           t.push_back((double)dist[i]/(double)speed[i]);\\n       }\\n       sort(t.begin(), t.end());\\n       for(int i=1; i<t.size(); i++)\\n       {\\n           if(time<t[i])\\n           {\\n               ans++;\\n               time++;\\n           }\\n           else\\n           {\\n               break;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) \\n    {\\n       int time = 1;\\n       int ans = 1;\\n       vector<double> t;\\n       for(int i=0; i<dist.size(); i++)\\n       {\\n           t.push_back((double)dist[i]/(double)speed[i]);\\n       }\\n       sort(t.begin(), t.end());\\n       for(int i=1; i<t.size(); i++)\\n       {\\n           if(time<t[i])\\n           {\\n               ans++;\\n               time++;\\n           }\\n           else\\n           {\\n               break;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690023,
                "title": "easy-python-sorting-solution-80-faster",
                "content": "![image](https://assets.leetcode.com/users/images/738ed7b3-b2a3-48d5-af9b-78059b02f32f_1665485987.0575442.png)\\n```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = []\\n        n = len(dist)\\n        for i in range(n):\\n            time.append(dist[i]/speed[i])\\n\\n        time = sorted(time)\\n        cur = 0\\n        res = 0\\n        for i in range(n):\\n            if time[i]-cur <= 0:break\\n            res += 1\\n            cur+=1\\n        \\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        time = []\\n        n = len(dist)\\n        for i in range(n):\\n            time.append(dist[i]/speed[i])\\n\\n        time = sorted(time)\\n        cur = 0\\n        res = 0\\n        for i in range(n):\\n            if time[i]-cur <= 0:break\\n            res += 1\\n            cur+=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689341,
                "title": "c-approach-by-calculating-time-easy-sorting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double> time;\\n        int n=dist.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            time.push_back((1.0*dist[i])/(1.0*speed[i]));\\n        }\\n        sort(time.begin(),time.end());\\n        int minutes=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(minutes>=time[i])\\n            {\\n                return i;\\n            }\\n            minutes++;\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\n\\nAN UPVOTE FROM SIDE IS HIGHLY APPRECIATED :)",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\\n        vector<double> time;\\n        int n=dist.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            time.push_back((1.0*dist[i])/(1.0*speed[i]));\\n        }\\n        sort(time.begin(),time.end());\\n        int minutes=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(minutes>=time[i])\\n            {\\n                return i;\\n            }\\n            minutes++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1760407,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1771733,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1746684,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 2004825,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1990160,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1901016,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1853888,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1838577,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1832532,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1798349,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1760407,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1771733,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1746684,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 2004825,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1990160,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1901016,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1853888,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1838577,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1832532,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            },
            {
                "id": 1798349,
                "content": [
                    {
                        "username": "nephaleum",
                        "content": "The hell?\n\ndist =\n[4,3,3,3,4]\nspeed =\n[1,1,1,1,4]\n\nOutput\n1\nExpected\n3\n\nHow is it even posible to kill 3 monsters before die? Distance between last monster litteraly equal to -8 then"
                    },
                    {
                        "username": "aadarsh__k",
                        "content": "no, first you kill the last monster, then it after a minute it will be \\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute \\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "manek",
                        "content": "[@Antarab](/Antarab) and OP\\n\\nI think you are looking at the timing of events wrong.  You fire instantaneously while the reload period occurs during the monster movement. \\n\\nT0: \\n1st shot, kill last monster => [4,3,3,3]\\nT1:\\nNew monster positions =>  [3,2,2,2]\\nKill last monster => [3,2,2]\\nT2:\\nNew monster positions =>  [2,1,1]\\nKill last monster => [2,1]\\nT3:\\nNew monster positions =>  [1,0]\\nYou are dead\\n\\n\\n"
                    },
                    {
                        "username": "Antarab",
                        "content": "yes, at max you can kill the 4th monster.\\n\\nkill 4th- left:\\ndist: [3,2,2,2]\\nspeed: [1,1,1,1]\\n\\nby the time he refills his gun...\\ndist: [2,1,1,1]\\nspeed: [1,1,1,]\\n\\nand then same time the monster reaches and he kills, but he loses"
                    },
                    {
                        "username": "venkat20",
                        "content": "I believe this test case is wrong. It\\'s contradicting the third example\\nInput\\ndist =\\n[4,3,4]\\nspeed =\\n[1,1,2]\\n\\nOutput\\n2\\nExpected\\n3"
                    },
                    {
                        "username": "speedyy",
                        "content": "The test case is Okay..We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill.\n` \nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost\n`\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0"
                    },
                    {
                        "username": "soofanseng",
                        "content": "i have the similar test case as this:\\ndist = [4,2,8]\\nspeed = [2,1,4]\\nthe expected output is 2.\\n\\nwhere as this test case give the expected output as 3.\\nKinda funny, can we report that ?"
                    },
                    {
                        "username": "mohitosri",
                        "content": "yes bro I also think the output is wrong.."
                    },
                    {
                        "username": "JTtime",
                        "content": "incorrect test cases"
                    },
                    {
                        "username": "arnabm12345",
                        "content": "Easy Question"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! 127/131 anyone help mee"
                    },
                    {
                        "username": "speedyy",
                        "content": "We need to find the MAXIMUM kill, means if we kill the monster who has the maximum speed, then we can have more kill. The Q didn't say we have to kill the first one, then the second. You can kill any mosnter.\n```\nNote : If any dist[i] becomes 0 you lose, X here means The Monster Got Killed, not 'You lost'\n```\n```\n dist = [4,3,4]            speed = [1,1,2]\n\nchoosing the high speed (speed[2] = 2)\ndist = [4,3,X]         speed = [1,1,X]\n            \"after 1 minute\"\ndist = [3,2,X]         speed = [1,1,X]\n\nchoosing the high speed (speed[1] = 1)\ndist = [3,X,X]         speed = [1,X,X]\n            \"after 1 minute\"\ndist = [2,X,X]         speed = [1,X,X]\n\nchoosing the high speed (speed[0] = 1)\ndist = [X,X,X]         speed = [X,X,X]\n```\nSo you can kill  3 monster here as no dist[i] found 0.\n\nIf anybody wants to see step by step explanation of why we did that in a particular step in easy language you can read my [solution](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/3547762/with-step-by-step-solution/) once"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Let's say we have `dist  = [1,2,10]` and `speed = [1,1,4]`, here speed of 3rd monster is the highest, but if you kill it first, the 1st monster would have reached the city and the max kills is 1 only. But if you go linearly, you will get to kill 2 monsters.\n\nSo the trick is to kill the monsters based on their arrival time - `ceil(dist[i] / (double) speed[i])`"
                    },
                    {
                        "username": "alonedevil",
                        "content": "Don\\'t think like program just think like real incident .\\nIf n number of monster are come to kill you shoot which monster which one is comming first you shoot that not shoot in order wise.like that this program works"
                    },
                    {
                        "username": "SoundsBetter",
                        "content": "Does distance matter for killing? Can we just shoot first to last in order?"
                    },
                    {
                        "username": "ashishsahu1",
                        "content": "Am I understanding something wrong here, as my solution is not able to pass the bellow test case\\n```\\ndist =\\n[4,3,3,3,4]\\nspeed =\\n[1,1,1,1,4]\\n\\nOutput\\n1\\nExpected\\n3\\n```\\n\\nbut in the solution there are multiple solution available which are able to pass all the testcase"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "first you kill the last monster, then it after a minute it will be\\ndist = [3,2,2,2,X]\\nspeed = [1,1,1,1,X]\\nthen you can kill any monster that is at the 2 dist as speed is same. after a minute\\ndist = [2,1,1,X,X]\\nspeed = [1,1,1,X,X]\\nthe again you can kill any monster that is at the 1 dist as speed is same. after a minute\\ndist = [2,0,X,X,X]\\nspeed = [1,1,X,X,X]\\nso the output is 3.\\nyou don\\'t kill the first monster. You kill the monster which is closet to you(closest means after subtracting the distance with speed)."
                    },
                    {
                        "username": "bdmgp",
                        "content": "Wrong test cases"
                    },
                    {
                        "username": "mr_softice",
                        "content": "Cases are correct. You just need to define wich monster will reach you first and eliminate it first. This condition hadn\\'t been described clear in task definition."
                    }
                ]
            }
        ]
    }
]